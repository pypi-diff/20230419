# Comparing `tmp/grapa-0.5.4.8.tar.gz` & `tmp/grapa-0.6.1.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist\grapa-0.5.4.8.tar", last modified: Wed Mar 24 16:51:25 2021, max compression
+gzip compressed data, was "grapa-0.6.1.0.tar", last modified: Wed Apr 19 13:10:54 2023, max compression
```

## Comparing `grapa-0.5.4.8.tar` & `grapa-0.6.1.0.tar`

### file list

```diff
@@ -1,645 +1,247 @@
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:25.000000 grapa-0.5.4.8/
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:24.000000 grapa-0.5.4.8/grapa/
--rw-rw-rw-   0        0        0    10300 2018-01-30 08:23:50.000000 grapa-0.5.4.8/grapa/colorscale.py
--rw-rw-rw-   0        0        0     1420 2017-11-01 13:59:54.000000 grapa-0.5.4.8/grapa/config.txt
--rw-rw-rw-   0        0        0     1358 2018-02-14 20:57:28.000000 grapa-0.5.4.8/grapa/config_anch.txt
--rw-rw-rw-   0        0        0     1420 2017-11-01 13:59:54.000000 grapa-0.5.4.8/grapa/config_default.txt
--rw-rw-rw-   0        0        0    50324 2021-03-24 16:38:10.000000 grapa-0.5.4.8/grapa/curve.py
--rw-rw-rw-   0        0        0     8249 2018-08-15 22:44:28.000000 grapa-0.5.4.8/grapa/curve_image.py
--rw-rw-rw-   0        0        0     2701 2018-01-30 08:24:18.000000 grapa-0.5.4.8/grapa/curve_inset.py
--rw-rw-rw-   0        0        0     4466 2018-01-30 08:24:22.000000 grapa-0.5.4.8/grapa/curve_subplot.py
--rw-rw-rw-   0        0        0    13298 2018-01-30 08:24:24.000000 grapa-0.5.4.8/grapa/database.py
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:24.000000 grapa-0.5.4.8/grapa/datatypes/
--rw-rw-rw-   0        0        0    20471 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/datatypes/AM0_2000_ASTM_E-490-00.txt
--rw-rw-rw-   0        0        0    56422 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/datatypes/AM1-5_Ed2-2008.txt
--rw-rw-rw-   0        0        0    20127 2018-05-23 21:17:34.000000 grapa-0.5.4.8/grapa/datatypes/curveArrhenius.py
--rw-rw-rw-   0        0        0    11623 2020-05-09 07:53:44.000000 grapa-0.5.4.8/grapa/datatypes/curveCf.py
--rw-rw-rw-   0        0        0    13234 2020-12-27 15:34:10.000000 grapa-0.5.4.8/grapa/datatypes/curveCV.py
--rw-rw-rw-   0        0        0    34821 2020-12-27 15:34:10.000000 grapa-0.5.4.8/grapa/datatypes/curveEQE.py
--rw-rw-rw-   0        0        0    20050 2020-02-14 10:47:15.000000 grapa-0.5.4.8/grapa/datatypes/curveJscVoc.py
--rw-rw-rw-   0        0        0    43487 2021-03-24 16:38:10.000000 grapa-0.5.4.8/grapa/datatypes/curveJV.py
--rw-rw-rw-   0        0        0     6691 2018-01-30 10:11:28.000000 grapa-0.5.4.8/grapa/datatypes/curveMath.py
--rw-rw-rw-   0        0        0     3927 2018-02-06 20:46:00.000000 grapa-0.5.4.8/grapa/datatypes/curveMCA.py
--rw-rw-rw-   0        0        0    12220 2021-03-24 16:38:10.000000 grapa-0.5.4.8/grapa/datatypes/curveSIMS.py
--rw-rw-rw-   0        0        0    22594 2021-03-20 17:04:42.000000 grapa-0.5.4.8/grapa/datatypes/curveSpectrum.py
--rw-rw-rw-   0        0        0    20760 2021-03-24 16:38:10.000000 grapa-0.5.4.8/grapa/datatypes/curveTRPL.py
--rw-rw-rw-   0        0        0     1651 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/datatypes/EQE_20.4_cell.txt
--rw-rw-rw-   0        0        0      685 2020-12-27 15:34:10.000000 grapa-0.5.4.8/grapa/datatypes/EQE_absorption_CdS.txt
--rw-rw-rw-   0        0        0     2599 2018-01-30 10:11:14.000000 grapa-0.5.4.8/grapa/datatypes/graphEQE_CSU.py
--rw-rw-rw-   0        0        0     6414 2018-03-03 16:09:08.000000 grapa-0.5.4.8/grapa/datatypes/graphJV.py
--rw-rw-rw-   0        0        0    10114 2021-03-24 16:38:10.000000 grapa-0.5.4.8/grapa/datatypes/graphJVDarkIllum.py
--rw-rw-rw-   0        0        0     1440 2018-01-30 10:11:10.000000 grapa-0.5.4.8/grapa/datatypes/graphMBElog.py
--rw-rw-rw-   0        0        0     4583 2018-01-30 10:11:06.000000 grapa-0.5.4.8/grapa/datatypes/graphMCAfit.py
--rw-rw-rw-   0        0        0     2352 2018-01-30 10:11:04.000000 grapa-0.5.4.8/grapa/datatypes/graphPGZ.py
--rw-rw-rw-   0        0        0    15922 2018-04-08 01:15:52.000000 grapa-0.5.4.8/grapa/datatypes/graphSIMS.py
--rw-rw-rw-   0        0        0     7312 2018-02-11 09:09:16.000000 grapa-0.5.4.8/grapa/datatypes/graphSpectrum.py
--rw-rw-rw-   0        0        0     5193 2019-11-24 11:14:58.000000 grapa-0.5.4.8/grapa/datatypes/graphSquidAdmiral.py
--rw-rw-rw-   0        0        0     2376 2018-02-06 21:37:40.000000 grapa-0.5.4.8/grapa/datatypes/graphXLS.py
--rw-rw-rw-   0        0        0     3884 2018-02-06 21:45:20.000000 grapa-0.5.4.8/grapa/datatypes/graphXML.py
--rw-rw-rw-   0        0        0     2154 2018-01-30 10:10:50.000000 grapa-0.5.4.8/grapa/datatypes/graphXPS.py
--rw-rw-rw-   0        0        0    41205 2018-02-10 19:56:22.000000 grapa-0.5.4.8/grapa/datatypes/spectrumInstrumentalResponses.txt
--rw-rw-rw-   0        0        0    36628 2018-02-11 14:13:12.000000 grapa-0.5.4.8/grapa/datatypes/spectrumSubstrates.txt
--rw-rw-rw-   0        0        0        0 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/datatypes/__init__.py
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:24.000000 grapa-0.5.4.8/grapa/examples/
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:25.000000 grapa-0.5.4.8/grapa/examples/boxplot/
--rw-rw-rw-   0        0        0      585 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/boxplot/export_sample_a_summary_illum.txt
--rw-rw-rw-   0        0        0     4347 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/boxplot/export_sample_b_3layermo_summary_illum.txt
--rw-rw-rw-   0        0        0     3981 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/boxplot/export_sample_b_5layermo_summary_illum.txt
--rw-rw-rw-   0        0        0     2555 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/boxplot/I-V_CA160_Param.txt
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:24.000000 grapa-0.5.4.8/grapa/examples/Cf/
--rw-rw-rw-   0        0        0     2784 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_123K.txt
--rw-rw-rw-   0        0        0     2763 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_133K.txt
--rw-rw-rw-   0        0        0     2741 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_143K.txt
--rw-rw-rw-   0        0        0     2717 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_153K.txt
--rw-rw-rw-   0        0        0     2740 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_163K.txt
--rw-rw-rw-   0        0        0     2769 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_173K.txt
--rw-rw-rw-   0        0        0     2743 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_183K.txt
--rw-rw-rw-   0        0        0     2772 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_193K.txt
--rw-rw-rw-   0        0        0     2759 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_203K.txt
--rw-rw-rw-   0        0        0     2730 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_213K.txt
--rw-rw-rw-   0        0        0     2769 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_223K.txt
--rw-rw-rw-   0        0        0     2761 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_233K.txt
--rw-rw-rw-   0        0        0     2750 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_243K.txt
--rw-rw-rw-   0        0        0     2744 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_253K.txt
--rw-rw-rw-   0        0        0     2761 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_263K.txt
--rw-rw-rw-   0        0        0     2701 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_273K.txt
--rw-rw-rw-   0        0        0     2729 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_283K.txt
--rw-rw-rw-   0        0        0     2770 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_293K.txt
--rw-rw-rw-   0        0        0     2721 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_303K.txt
--rw-rw-rw-   0        0        0    12288 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/Cf/Thumbs.db
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:24.000000 grapa-0.5.4.8/grapa/examples/CV/
--rw-rw-rw-   0        0        0     2166 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=123_K.txt
--rw-rw-rw-   0        0        0     2163 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=133_K.txt
--rw-rw-rw-   0        0        0     2171 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=143_K.txt
--rw-rw-rw-   0        0        0     2164 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=153_K.txt
--rw-rw-rw-   0        0        0     2160 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=163_K.txt
--rw-rw-rw-   0        0        0     2157 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=173_K.txt
--rw-rw-rw-   0        0        0     2163 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=183_K.txt
--rw-rw-rw-   0        0        0     2153 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=193_K.txt
--rw-rw-rw-   0        0        0     2160 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=203_K.txt
--rw-rw-rw-   0        0        0     2158 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=213_K.txt
--rw-rw-rw-   0        0        0     2156 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=223_K.txt
--rw-rw-rw-   0        0        0     2157 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=233_K.txt
--rw-rw-rw-   0        0        0     2155 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=243_K.txt
--rw-rw-rw-   0        0        0     2156 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=253_K.txt
--rw-rw-rw-   0        0        0     2152 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=263_K.txt
--rw-rw-rw-   0        0        0     2160 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=273_K.txt
--rw-rw-rw-   0        0        0     2159 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=283_K.txt
--rw-rw-rw-   0        0        0     2161 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=293_K.txt
--rw-rw-rw-   0        0        0     2160 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=303_K.txt
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:24.000000 grapa-0.5.4.8/grapa/examples/EQE/
--rw-rw-rw-   0        0        0     1706 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/EQE/1150-8-C3-QE.txt
--rw-rw-rw-   0        0        0     3673 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/EQE/SAMPLE_A_d1_1.sr
--rw-rw-rw-   0        0        0     3485 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/EQE/SAMPLE_B_TCObelowMo_d1_1.sr
--rw-rw-rw-   0        0        0     4759 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/EQE/SAMPLE_C_f1_1.sr
--rw-rw-rw-   0        0        0    23820 2018-03-20 19:12:34.000000 grapa-0.5.4.8/grapa/examples/example_datafile.txt
--rw-rw-rw-   0        0        0    20920 2018-01-07 12:53:44.000000 grapa-0.5.4.8/grapa/examples/example_datafile_withXY1rowcol.txt
--rw-rw-rw-   0        0        0      920 2019-07-01 12:36:08.000000 grapa-0.5.4.8/grapa/examples/example_imshow_datafile.txt
--rw-rw-rw-   0        0        0     1546 2018-03-20 18:53:00.000000 grapa-0.5.4.8/grapa/examples/example_imshow_datatable.txt
--rw-rw-rw-   0        0        0      907 2017-12-28 23:24:08.000000 grapa-0.5.4.8/grapa/examples/example_imshow_picture.txt
--rw-rw-rw-   0        0        0     1545 2018-01-27 14:35:46.000000 grapa-0.5.4.8/grapa/examples/fancyAnnotations.txt
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:24.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:25.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/
--rw-rw-rw-   0        0        0     2240 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0001_20.csv
--rw-rw-rw-   0        0        0     2264 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0002_20.csv
--rw-rw-rw-   0        0        0     2320 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0003_20.csv
--rw-rw-rw-   0        0        0     2265 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0004_20.csv
--rw-rw-rw-   0        0        0     2239 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0005_20.csv
--rw-rw-rw-   0        0        0     2272 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0006_20.csv
--rw-rw-rw-   0        0        0     2197 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0007_20.csv
--rw-rw-rw-   0        0        0     2233 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0008_20.csv
--rw-rw-rw-   0        0        0     2265 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0009_20.csv
--rw-rw-rw-   0        0        0     2251 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0010_20.csv
--rw-rw-rw-   0        0        0     2241 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0011_20.csv
--rw-rw-rw-   0        0        0     2266 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0012_20.csv
--rw-rw-rw-   0        0        0     2231 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0013_20.csv
--rw-rw-rw-   0        0        0     2237 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0014_20.csv
--rw-rw-rw-   0        0        0     2251 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0015_20.csv
--rw-rw-rw-   0        0        0     2261 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0016_20.csv
--rw-rw-rw-   0        0        0     2205 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0017_20.csv
--rw-rw-rw-   0        0        0     2236 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0018_20.csv
--rw-rw-rw-   0        0        0     2297 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0019_20.csv
--rw-rw-rw-   0        0        0     2258 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0020_20.csv
--rw-rw-rw-   0        0        0     2251 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0021_20.csv
--rw-rw-rw-   0        0        0     2254 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0022_20.csv
--rw-rw-rw-   0        0        0     2273 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0023_20.csv
--rw-rw-rw-   0        0        0     2246 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0024_20.csv
--rw-rw-rw-   0        0        0     2254 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0025_20.csv
--rw-rw-rw-   0        0        0     2258 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0026_20.csv
--rw-rw-rw-   0        0        0     2223 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0027_20.csv
--rw-rw-rw-   0        0        0     2279 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0028_20.csv
--rw-rw-rw-   0        0        0     2236 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0029_20.csv
--rw-rw-rw-   0        0        0     2250 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0030_20.csv
--rw-rw-rw-   0        0        0     2266 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0031_20.csv
--rw-rw-rw-   0        0        0     2288 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0032_20.csv
--rw-rw-rw-   0        0        0     2242 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0033_20.csv
--rw-rw-rw-   0        0        0     2261 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0034_20.csv
--rw-rw-rw-   0        0        0     2284 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0035_20.csv
--rw-rw-rw-   0        0        0     2276 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0036_20.csv
--rw-rw-rw-   0        0        0     2242 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0037_20.csv
--rw-rw-rw-   0        0        0     2206 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0038_20.csv
--rw-rw-rw-   0        0        0     2253 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0039_20.csv
--rw-rw-rw-   0        0        0     2309 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0040_20.csv
--rw-rw-rw-   0        0        0     2273 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0041_20.csv
--rw-rw-rw-   0        0        0     2264 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0042_20.csv
--rw-rw-rw-   0        0        0     2265 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0043_20.csv
--rw-rw-rw-   0        0        0     2315 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0044_20.csv
--rw-rw-rw-   0        0        0     2238 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0045_20.csv
--rw-rw-rw-   0        0        0     2279 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0046_20.csv
--rw-rw-rw-   0        0        0     2231 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0047_20.csv
--rw-rw-rw-   0        0        0     2248 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0048_20.csv
--rw-rw-rw-   0        0        0     2244 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0049_20.csv
--rw-rw-rw-   0        0        0     2293 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0050_20.csv
--rw-rw-rw-   0        0        0     2259 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0051_20.csv
--rw-rw-rw-   0        0        0     2272 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0052_20.csv
--rw-rw-rw-   0        0        0     2275 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0053_20.csv
--rw-rw-rw-   0        0        0     2258 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0054_20.csv
--rw-rw-rw-   0        0        0     2303 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0055_20.csv
--rw-rw-rw-   0        0        0     2299 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0056_20.csv
--rw-rw-rw-   0        0        0     2280 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0057_20.csv
--rw-rw-rw-   0        0        0     2266 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0058_20.csv
--rw-rw-rw-   0        0        0     2222 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0059_20.csv
--rw-rw-rw-   0        0        0     2248 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0060_20.csv
--rw-rw-rw-   0        0        0     2247 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0061_20.csv
--rw-rw-rw-   0        0        0     2266 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0062_20.csv
--rw-rw-rw-   0        0        0     2239 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0063_20.csv
--rw-rw-rw-   0        0        0     2250 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0064_20.csv
--rw-rw-rw-   0        0        0     2214 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0065_20.csv
--rw-rw-rw-   0        0        0     2302 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0066_20.csv
--rw-rw-rw-   0        0        0     2281 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0067_20.csv
--rw-rw-rw-   0        0        0     2234 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0068_20.csv
--rw-rw-rw-   0        0        0     2249 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0069_20.csv
--rw-rw-rw-   0        0        0     2217 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0070_20.csv
--rw-rw-rw-   0        0        0     2227 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0071_20.csv
--rw-rw-rw-   0        0        0     2269 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0072_20.csv
--rw-rw-rw-   0        0        0     2245 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0073_20.csv
--rw-rw-rw-   0        0        0     2293 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0074_20.csv
--rw-rw-rw-   0        0        0     2245 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0075_20.csv
--rw-rw-rw-   0        0        0     2301 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0076_20.csv
--rw-rw-rw-   0        0        0     2259 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0077_20.csv
--rw-rw-rw-   0        0        0     2222 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0078_20.csv
--rw-rw-rw-   0        0        0     2268 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0079_20.csv
--rw-rw-rw-   0        0        0     2219 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0080_20.csv
--rw-rw-rw-   0        0        0     2293 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0081_20.csv
--rw-rw-rw-   0        0        0     2237 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0082_20.csv
--rw-rw-rw-   0        0        0     2266 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0083_20.csv
--rw-rw-rw-   0        0        0     2282 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0084_20.csv
--rw-rw-rw-   0        0        0     2261 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0085_20.csv
--rw-rw-rw-   0        0        0     2230 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0086_20.csv
--rw-rw-rw-   0        0        0     2252 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0087_20.csv
--rw-rw-rw-   0        0        0     2260 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0088_20.csv
--rw-rw-rw-   0        0        0     2237 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0089_20.csv
--rw-rw-rw-   0        0        0     2254 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0090_20.csv
--rw-rw-rw-   0        0        0     2233 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0091_20.csv
--rw-rw-rw-   0        0        0     2227 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0092_20.csv
--rw-rw-rw-   0        0        0     2219 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0093_20.csv
--rw-rw-rw-   0        0        0     2273 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0094_20.csv
--rw-rw-rw-   0        0        0     2184 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0095_20.csv
--rw-rw-rw-   0        0        0     2273 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0096_20.csv
--rw-rw-rw-   0        0        0     2272 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0097_20.csv
--rw-rw-rw-   0        0        0     2263 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0098_20.csv
--rw-rw-rw-   0        0        0     2237 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0099_20.csv
--rw-rw-rw-   0        0        0     2271 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0100_20.csv
--rw-rw-rw-   0        0        0     2201 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0101_20.csv
--rw-rw-rw-   0        0        0     2206 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0102_20.csv
--rw-rw-rw-   0        0        0     2251 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0103_20.csv
--rw-rw-rw-   0        0        0     2234 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0104_20.csv
--rw-rw-rw-   0        0        0     2231 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0105_20.csv
--rw-rw-rw-   0        0        0     2262 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0106_20.csv
--rw-rw-rw-   0        0        0     2200 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0107_20.csv
--rw-rw-rw-   0        0        0     2216 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0108_20.csv
--rw-rw-rw-   0        0        0     2294 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0109_20.csv
--rw-rw-rw-   0        0        0     2278 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0110_20.csv
--rw-rw-rw-   0        0        0     2226 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0111_20.csv
--rw-rw-rw-   0        0        0     2289 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0112_20.csv
--rw-rw-rw-   0        0        0     2264 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0113_20.csv
--rw-rw-rw-   0        0        0     2252 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0114_20.csv
--rw-rw-rw-   0        0        0     2311 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0115_20.csv
--rw-rw-rw-   0        0        0     2157 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0116_20.csv
--rw-rw-rw-   0        0        0     2238 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0117_20.csv
--rw-rw-rw-   0        0        0     2279 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0118_20.csv
--rw-rw-rw-   0        0        0     2196 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0119_20.csv
--rw-rw-rw-   0        0        0     2320 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0120_20.csv
--rw-rw-rw-   0        0        0     2215 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0121_20.csv
--rw-rw-rw-   0        0        0     2236 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0122_20.csv
--rw-rw-rw-   0        0        0     2275 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0123_20.csv
--rw-rw-rw-   0        0        0     2197 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0124_20.csv
--rw-rw-rw-   0        0        0     2273 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0125_20.csv
--rw-rw-rw-   0        0        0     2248 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0126_20.csv
--rw-rw-rw-   0        0        0     2272 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0127_20.csv
--rw-rw-rw-   0        0        0     2320 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0128_20.csv
--rw-rw-rw-   0        0        0     2250 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0129_20.csv
--rw-rw-rw-   0        0        0     2303 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0130_20.csv
--rw-rw-rw-   0        0        0     2312 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0131_20.csv
--rw-rw-rw-   0        0        0     2245 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0132_20.csv
--rw-rw-rw-   0        0        0     2181 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0133_20.csv
--rw-rw-rw-   0        0        0     2266 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0134_20.csv
--rw-rw-rw-   0        0        0     2227 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0135_20.csv
--rw-rw-rw-   0        0        0     2272 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0136_20.csv
--rw-rw-rw-   0        0        0     2272 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0137_20.csv
--rw-rw-rw-   0        0        0     2255 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0138_20.csv
--rw-rw-rw-   0        0        0     2277 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0139_20.csv
--rw-rw-rw-   0        0        0     2283 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0140_20.csv
--rw-rw-rw-   0        0        0     2234 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0141_20.csv
--rw-rw-rw-   0        0        0     2250 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0142_20.csv
--rw-rw-rw-   0        0        0     2269 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0143_20.csv
--rw-rw-rw-   0        0        0     2266 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0144_20.csv
--rw-rw-rw-   0        0        0     2254 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0145_20.csv
--rw-rw-rw-   0        0        0     2270 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0146_20.csv
--rw-rw-rw-   0        0        0     2263 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0147_20.csv
--rw-rw-rw-   0        0        0     2239 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0148_20.csv
--rw-rw-rw-   0        0        0     2297 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0149_20.csv
--rw-rw-rw-   0        0        0     2267 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0150_20.csv
--rw-rw-rw-   0        0        0     2224 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0151_20.csv
--rw-rw-rw-   0        0        0     2286 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0152_20.csv
--rw-rw-rw-   0        0        0     2290 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0153_20.csv
--rw-rw-rw-   0        0        0     2273 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0154_20.csv
--rw-rw-rw-   0        0        0     2251 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0155_20.csv
--rw-rw-rw-   0        0        0     2263 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0156_20.csv
--rw-rw-rw-   0        0        0     2301 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0157_20.csv
--rw-rw-rw-   0        0        0     2237 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0158_20.csv
--rw-rw-rw-   0        0        0     2270 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0159_20.csv
--rw-rw-rw-   0        0        0     2246 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0160_20.csv
--rw-rw-rw-   0        0        0     2231 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0161_20.csv
--rw-rw-rw-   0        0        0     2224 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0162_20.csv
--rw-rw-rw-   0        0        0     2237 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0163_20.csv
--rw-rw-rw-   0        0        0     2255 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0164_20.csv
--rw-rw-rw-   0        0        0     2281 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0165_20.csv
--rw-rw-rw-   0        0        0     2272 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0166_20.csv
--rw-rw-rw-   0        0        0     2287 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0167_20.csv
--rw-rw-rw-   0        0        0     2277 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0168_20.csv
--rw-rw-rw-   0        0        0     2249 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0169_20.csv
--rw-rw-rw-   0        0        0     2263 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0170_20.csv
--rw-rw-rw-   0        0        0     2261 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0171_20.csv
--rw-rw-rw-   0        0        0     2238 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0172_20.csv
--rw-rw-rw-   0        0        0     2265 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0173_20.csv
--rw-rw-rw-   0        0        0     2281 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0174_20.csv
--rw-rw-rw-   0        0        0     2227 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0175_20.csv
--rw-rw-rw-   0        0        0     2290 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0176_20.csv
--rw-rw-rw-   0        0        0     2259 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0177_20.csv
--rw-rw-rw-   0        0        0     2288 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0178_20.csv
--rw-rw-rw-   0        0        0     2241 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0179_20.csv
--rw-rw-rw-   0        0        0     2278 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0180_20.csv
--rw-rw-rw-   0        0        0     2288 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0181_20.csv
--rw-rw-rw-   0        0        0     2274 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0182_20.csv
--rw-rw-rw-   0        0        0     2218 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0183_20.csv
--rw-rw-rw-   0        0        0     2284 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0184_20.csv
--rw-rw-rw-   0        0        0     2285 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0185_20.csv
--rw-rw-rw-   0        0        0     2270 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0186_20.csv
--rw-rw-rw-   0        0        0     2258 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0187_20.csv
--rw-rw-rw-   0        0        0     2251 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0188_20.csv
--rw-rw-rw-   0        0        0     2238 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0189_20.csv
--rw-rw-rw-   0        0        0     2283 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0190_20.csv
--rw-rw-rw-   0        0        0     2240 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0191_20.csv
--rw-rw-rw-   0        0        0     2247 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0192_20.csv
--rw-rw-rw-   0        0        0     2267 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0193_20.csv
--rw-rw-rw-   0        0        0     2280 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0194_20.csv
--rw-rw-rw-   0        0        0     2250 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0195_20.csv
--rw-rw-rw-   0        0        0     2239 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0196_20.csv
--rw-rw-rw-   0        0        0     2213 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0197_20.csv
--rw-rw-rw-   0        0        0     2284 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0198_20.csv
--rw-rw-rw-   0        0        0     2317 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0199_20.csv
--rw-rw-rw-   0        0        0     2275 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0200_20.csv
--rw-rw-rw-   0        0        0     2288 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0201_20.csv
--rw-rw-rw-   0        0        0     2267 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0202_20.csv
--rw-rw-rw-   0        0        0     2202 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0203_20.csv
--rw-rw-rw-   0        0        0     2268 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0204_20.csv
--rw-rw-rw-   0        0        0     2288 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0205_20.csv
--rw-rw-rw-   0        0        0     2295 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0206_20.csv
--rw-rw-rw-   0        0        0     2243 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0207_20.csv
--rw-rw-rw-   0        0        0     2282 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0208_20.csv
--rw-rw-rw-   0        0        0     2256 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0209_20.csv
--rw-rw-rw-   0        0        0     2157 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0210_20.csv
--rw-rw-rw-   0        0        0     2204 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0211_20.csv
--rw-rw-rw-   0        0        0     2283 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0212_20.csv
--rw-rw-rw-   0        0        0     2226 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0213_20.csv
--rw-rw-rw-   0        0        0     2264 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0214_20.csv
--rw-rw-rw-   0        0        0     2326 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0215_20.csv
--rw-rw-rw-   0        0        0     2283 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0216_20.csv
--rw-rw-rw-   0        0        0     2305 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0217_20.csv
--rw-rw-rw-   0        0        0     2278 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0218_20.csv
--rw-rw-rw-   0        0        0     2255 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0219_20.csv
--rw-rw-rw-   0        0        0     2245 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0220_20.csv
--rw-rw-rw-   0        0        0     2237 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0221_20.csv
--rw-rw-rw-   0        0        0     2259 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0222_20.csv
--rw-rw-rw-   0        0        0     2278 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0223_20.csv
--rw-rw-rw-   0        0        0     2292 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0224_20.csv
--rw-rw-rw-   0        0        0     2252 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0225_20.csv
--rw-rw-rw-   0        0        0     2284 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0226_20.csv
--rw-rw-rw-   0        0        0     2265 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0227_20.csv
--rw-rw-rw-   0        0        0     2280 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0228_20.csv
--rw-rw-rw-   0        0        0     2272 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0229_20.csv
--rw-rw-rw-   0        0        0     2252 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0230_20.csv
--rw-rw-rw-   0        0        0     2331 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0231_20.csv
--rw-rw-rw-   0        0        0     2328 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0232_20.csv
--rw-rw-rw-   0        0        0     2300 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0233_20.csv
--rw-rw-rw-   0        0        0     2267 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0234_20.csv
--rw-rw-rw-   0        0        0     2240 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0235_20.csv
--rw-rw-rw-   0        0        0     2248 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0236_20.csv
--rw-rw-rw-   0        0        0     2265 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0237_20.csv
--rw-rw-rw-   0        0        0     2242 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0238_20.csv
--rw-rw-rw-   0        0        0     2300 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0239_20.csv
--rw-rw-rw-   0        0        0     2249 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0240_20.csv
--rw-rw-rw-   0        0        0     2197 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0241_20.csv
--rw-rw-rw-   0        0        0     2230 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0242_20.csv
--rw-rw-rw-   0        0        0     2213 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0243_20.csv
--rw-rw-rw-   0        0        0     2254 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0244_20.csv
--rw-rw-rw-   0        0        0     2268 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0245_20.csv
--rw-rw-rw-   0        0        0     2256 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0246_20.csv
--rw-rw-rw-   0        0        0     2316 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0247_20.csv
--rw-rw-rw-   0        0        0     2269 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0248_20.csv
--rw-rw-rw-   0        0        0     2313 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0249_20.csv
--rw-rw-rw-   0        0        0     2269 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0250_20.csv
--rw-rw-rw-   0        0        0     2259 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0251_20.csv
--rw-rw-rw-   0        0        0     2266 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0252_20.csv
--rw-rw-rw-   0        0        0     2215 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0253_20.csv
--rw-rw-rw-   0        0        0     2243 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0254_20.csv
--rw-rw-rw-   0        0        0     2201 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0255_20.csv
--rw-rw-rw-   0        0        0     2266 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0256_20.csv
--rw-rw-rw-   0        0        0     2258 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0257_20.csv
--rw-rw-rw-   0        0        0     2268 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0258_20.csv
--rw-rw-rw-   0        0        0     2206 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0259_20.csv
--rw-rw-rw-   0        0        0     2265 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0260_20.csv
--rw-rw-rw-   0        0        0     2240 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0261_20.csv
--rw-rw-rw-   0        0        0     2218 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0262_20.csv
--rw-rw-rw-   0        0        0     2244 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0263_20.csv
--rw-rw-rw-   0        0        0     2273 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0264_20.csv
--rw-rw-rw-   0        0        0     2304 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0265_20.csv
--rw-rw-rw-   0        0        0     2280 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0266_20.csv
--rw-rw-rw-   0        0        0     2295 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0267_20.csv
--rw-rw-rw-   0        0        0     2228 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0268_20.csv
--rw-rw-rw-   0        0        0     2226 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0269_20.csv
--rw-rw-rw-   0        0        0     2270 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0270_20.csv
--rw-rw-rw-   0        0        0     2302 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0271_20.csv
--rw-rw-rw-   0        0        0     2268 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0272_20.csv
--rw-rw-rw-   0        0        0     2258 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0273_20.csv
--rw-rw-rw-   0        0        0     2255 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0274_20.csv
--rw-rw-rw-   0        0        0     2263 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0275_20.csv
--rw-rw-rw-   0        0        0     2258 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0276_20.csv
--rw-rw-rw-   0        0        0     2217 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0277_20.csv
--rw-rw-rw-   0        0        0     2252 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0278_20.csv
--rw-rw-rw-   0        0        0     2273 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0279_20.csv
--rw-rw-rw-   0        0        0     2315 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0280_20.csv
--rw-rw-rw-   0        0        0     2230 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0281_20.csv
--rw-rw-rw-   0        0        0     2287 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0282_20.csv
--rw-rw-rw-   0        0        0     2251 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0283_20.csv
--rw-rw-rw-   0        0        0     2267 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0284_20.csv
--rw-rw-rw-   0        0        0     2243 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0285_20.csv
--rw-rw-rw-   0        0        0     2281 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0286_20.csv
--rw-rw-rw-   0        0        0     2293 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0287_20.csv
--rw-rw-rw-   0        0        0     2242 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0288_20.csv
--rw-rw-rw-   0        0        0     2243 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0289_20.csv
--rw-rw-rw-   0        0        0     2265 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0290_20.csv
--rw-rw-rw-   0        0        0     2277 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0291_20.csv
--rw-rw-rw-   0        0        0     2226 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0292_20.csv
--rw-rw-rw-   0        0        0     2262 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0293_20.csv
--rw-rw-rw-   0        0        0     2245 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0294_20.csv
--rw-rw-rw-   0        0        0     2226 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0295_20.csv
--rw-rw-rw-   0        0        0     2275 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0296_20.csv
--rw-rw-rw-   0        0        0     2269 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0297_20.csv
--rw-rw-rw-   0        0        0     2272 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0298_20.csv
--rw-rw-rw-   0        0        0     2297 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0299_20.csv
--rw-rw-rw-   0        0        0     2267 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0300_20.csv
--rw-rw-rw-   0        0        0     2271 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0301_20.csv
--rw-rw-rw-   0        0        0     2296 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0302_20.csv
--rw-rw-rw-   0        0        0     2255 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0303_20.csv
--rw-rw-rw-   0        0        0     2312 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0304_20.csv
--rw-rw-rw-   0        0        0     2262 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0305_20.csv
--rw-rw-rw-   0        0        0     2244 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0306_20.csv
--rw-rw-rw-   0        0        0     2254 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0307_20.csv
--rw-rw-rw-   0        0        0     2298 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0308_20.csv
--rw-rw-rw-   0        0        0     2288 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0309_20.csv
--rw-rw-rw-   0        0        0     2258 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0310_20.csv
--rw-rw-rw-   0        0        0     2271 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0311_20.csv
--rw-rw-rw-   0        0        0     2285 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0312_20.csv
--rw-rw-rw-   0        0        0     2258 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0313_20.csv
--rw-rw-rw-   0        0        0     2230 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0314_20.csv
--rw-rw-rw-   0        0        0     2250 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0315_20.csv
--rw-rw-rw-   0        0        0     2250 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0316_20.csv
--rw-rw-rw-   0        0        0     2256 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0317_20.csv
--rw-rw-rw-   0        0        0     2210 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0318_20.csv
--rw-rw-rw-   0        0        0     2243 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0319_20.csv
--rw-rw-rw-   0        0        0     2225 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0320_20.csv
--rw-rw-rw-   0        0        0     2221 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0321_20.csv
--rw-rw-rw-   0        0        0     2266 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0322_20.csv
--rw-rw-rw-   0        0        0     2274 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0323_20.csv
--rw-rw-rw-   0        0        0     2280 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0324_20.csv
--rw-rw-rw-   0        0        0     2248 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0325_20.csv
--rw-rw-rw-   0        0        0     2299 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0326_20.csv
--rw-rw-rw-   0        0        0     2280 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0327_20.csv
--rw-rw-rw-   0        0        0     2286 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0328_20.csv
--rw-rw-rw-   0        0        0     2266 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0329_20.csv
--rw-rw-rw-   0        0        0     2282 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0330_20.csv
--rw-rw-rw-   0        0        0     2230 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0331_20.csv
--rw-rw-rw-   0        0        0     2237 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0332_20.csv
--rw-rw-rw-   0        0        0     2260 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0333_20.csv
--rw-rw-rw-   0        0        0     2282 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0334_20.csv
--rw-rw-rw-   0        0        0     2276 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0335_20.csv
--rw-rw-rw-   0        0        0     2223 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0336_20.csv
--rw-rw-rw-   0        0        0     2219 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0337_20.csv
--rw-rw-rw-   0        0        0     2291 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0338_20.csv
--rw-rw-rw-   0        0        0     2254 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0339_20.csv
--rw-rw-rw-   0        0        0     2296 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0340_20.csv
--rw-rw-rw-   0        0        0     2224 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0341_20.csv
--rw-rw-rw-   0        0        0     2239 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0342_20.csv
--rw-rw-rw-   0        0        0     2266 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0343_20.csv
--rw-rw-rw-   0        0        0     2221 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0344_20.csv
--rw-rw-rw-   0        0        0     2222 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0345_20.csv
--rw-rw-rw-   0        0        0     2265 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0346_20.csv
--rw-rw-rw-   0        0        0     2239 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0347_20.csv
--rw-rw-rw-   0        0        0     2252 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0348_20.csv
--rw-rw-rw-   0        0        0     2271 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0349_20.csv
--rw-rw-rw-   0        0        0     2251 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0350_20.csv
--rw-rw-rw-   0        0        0     2240 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0351_20.csv
--rw-rw-rw-   0        0        0     2236 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0352_20.csv
--rw-rw-rw-   0        0        0     2257 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0353_20.csv
--rw-rw-rw-   0        0        0     2246 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0354_20.csv
--rw-rw-rw-   0        0        0     2204 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0355_20.csv
--rw-rw-rw-   0        0        0     2251 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0356_20.csv
--rw-rw-rw-   0        0        0     2296 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0357_20.csv
--rw-rw-rw-   0        0        0     2278 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0358_20.csv
--rw-rw-rw-   0        0        0     2262 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0359_20.csv
--rw-rw-rw-   0        0        0     2208 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0360_20.csv
--rw-rw-rw-   0        0        0     2286 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0361_20.csv
--rw-rw-rw-   0        0        0     2230 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0362_20.csv
--rw-rw-rw-   0        0        0     2249 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0363_20.csv
--rw-rw-rw-   0        0        0     2302 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0364_20.csv
--rw-rw-rw-   0        0        0     2253 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0365_20.csv
--rw-rw-rw-   0        0        0     2253 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0366_20.csv
--rw-rw-rw-   0        0        0     2272 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0367_20.csv
--rw-rw-rw-   0        0        0     2255 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0368_20.csv
--rw-rw-rw-   0        0        0     2258 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0369_20.csv
--rw-rw-rw-   0        0        0     2264 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0370_20.csv
--rw-rw-rw-   0        0        0     2221 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0371_20.csv
--rw-rw-rw-   0        0        0     2268 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0372_20.csv
--rw-rw-rw-   0        0        0     2288 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0373_20.csv
--rw-rw-rw-   0        0        0     2288 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0374_20.csv
--rw-rw-rw-   0        0        0     2218 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0375_20.csv
--rw-rw-rw-   0        0        0     2258 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0376_20.csv
--rw-rw-rw-   0        0        0     2275 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0377_20.csv
--rw-rw-rw-   0        0        0     2234 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0378_20.csv
--rw-rw-rw-   0        0        0     2266 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0379_20.csv
--rw-rw-rw-   0        0        0     2303 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0380_20.csv
--rw-rw-rw-   0        0        0     2234 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0381_20.csv
--rw-rw-rw-   0        0        0     2287 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0382_20.csv
--rw-rw-rw-   0        0        0     2277 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/52_Oct1143/TF_2017-04-04_Oct1143_iv0383_20.csv
--rw-rw-rw-   0        0        0    30749 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/examples/HLsoaking/TF_2017-04-04_52_Oct1143_20.csv
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:25.000000 grapa-0.5.4.8/grapa/examples/JscVoc/
--rw-rw-rw-   0        0        0     5334 2020-02-11 21:27:50.000000 grapa-0.5.4.8/grapa/examples/JscVoc/JscVoc_SAMPLE_c2_Values.txt
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:24.000000 grapa-0.5.4.8/grapa/examples/JV/
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:25.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_A/
--rw-rw-rw-   0        0        0      177 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_A/area.txt
--rw-rw-rw-   0        0        0     2662 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_a2_01.txt
--rw-rw-rw-   0        0        0     2653 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_a2_02.txt
--rw-rw-rw-   0        0        0     2476 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_a2_02_dark.txt
--rw-rw-rw-   0        0        0     2660 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_a3_01.txt
--rw-rw-rw-   0        0        0     2374 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_b2_02_dark.txt
--rw-rw-rw-   0        0        0     2374 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_C2_02_dark.txt
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:25.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/
--rw-rw-rw-   0        0        0     2259 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_a1_01.txt
--rw-rw-rw-   0        0        0     2212 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_a2_01.txt
--rw-rw-rw-   0        0        0     2218 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_a3_01.txt
--rw-rw-rw-   0        0        0     2217 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_b1_01.txt
--rw-rw-rw-   0        0        0     2213 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_b2_01.txt
--rw-rw-rw-   0        0        0     2215 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_b3_01.txt
--rw-rw-rw-   0        0        0     2210 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_c1_01.txt
--rw-rw-rw-   0        0        0     2207 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_c1_02.txt
--rw-rw-rw-   0        0        0     2214 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_c2_01.txt
--rw-rw-rw-   0        0        0     2215 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_c3_01.txt
--rw-rw-rw-   0        0        0     2216 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_d1_01.txt
--rw-rw-rw-   0        0        0     2211 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_d2_01.txt
--rw-rw-rw-   0        0        0     2213 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_d3_01.txt
--rw-rw-rw-   0        0        0     2216 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_e1_01.txt
--rw-rw-rw-   0        0        0     2207 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_e2_01.txt
--rw-rw-rw-   0        0        0     2213 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_e3_01.txt
--rw-rw-rw-   0        0        0     2215 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_f1_01.txt
--rw-rw-rw-   0        0        0     2215 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_f2_01.txt
--rw-rw-rw-   0        0        0     2215 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_f3_01.txt
--rw-rw-rw-   0        0        0     2263 2020-12-27 15:34:11.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_f3_01_dark.txt
--rw-rw-rw-   0        0        0     2268 2020-12-27 15:34:11.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_f3_01_new_cont_01.txt
--rw-rw-rw-   0        0        0     4277 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_Param.txt
--rw-rw-rw-   0        0        0      180 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/SAMPLE_B_3LayerMo.txt
--rw-rw-rw-   0        0        0    65536 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/Thumbs.db
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:25.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/
--rw-rw-rw-   0        0        0      288 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/area.txt
--rw-rw-rw-   0        0        0     2209 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_a1_01.txt
--rw-rw-rw-   0        0        0     2215 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_a2_01.txt
--rw-rw-rw-   0        0        0     2211 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_a3_01.txt
--rw-rw-rw-   0        0        0     2211 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_b1_01.txt
--rw-rw-rw-   0        0        0     2212 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_b2_01.txt
--rw-rw-rw-   0        0        0     2266 2020-12-27 15:34:11.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_b2_01_dark.txt
--rw-rw-rw-   0        0        0     2210 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_b3_01.txt
--rw-rw-rw-   0        0        0     2221 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_c1_01.txt
--rw-rw-rw-   0        0        0     2209 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_c2_01.txt
--rw-rw-rw-   0        0        0     2214 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_c3_01.txt
--rw-rw-rw-   0        0        0     2213 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_d1_01.txt
--rw-rw-rw-   0        0        0     2215 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_d2_01.txt
--rw-rw-rw-   0        0        0     2217 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_d3_01.txt
--rw-rw-rw-   0        0        0     2210 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_e1_01.txt
--rw-rw-rw-   0        0        0     2205 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_e2_01.txt
--rw-rw-rw-   0        0        0     2223 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_e3_01.txt
--rw-rw-rw-   0        0        0     2219 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_f1_01.txt
--rw-rw-rw-   0        0        0     2211 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_f2_01.txt
--rw-rw-rw-   0        0        0     2218 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_f3_01.txt
--rw-rw-rw-   0        0        0     1788 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_Param.txt
--rw-rw-rw-   0        0        0    65024 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/Thumbs.db
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:25.000000 grapa-0.5.4.8/grapa/examples/SIMS/
--rw-rw-rw-   0        0        0   215354 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/SIMS/SAMPLE_CZTS_A_NoNa_1.TXT
--rw-rw-rw-   0        0        0   118326 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/SIMS/SAMPLE_D_c_1.TXT
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:25.000000 grapa-0.5.4.8/grapa/examples/Spectra/
--rw-rw-rw-   0        0        0    17255 2018-02-09 21:46:10.000000 grapa-0.5.4.8/grapa/examples/Spectra/CdS32nm_on_SLG_R.txt
--rw-rw-rw-   0        0        0    17564 2018-02-09 21:46:22.000000 grapa-0.5.4.8/grapa/examples/Spectra/CdS32nm_on_SLG_T.txt
--rw-rw-rw-   0        0        0     6099 2017-12-21 18:03:34.000000 grapa-0.5.4.8/grapa/examples/Spectra/PLexample_thinCIGSFilmWithInterference.dat
--rw-rw-rw-   0        0        0     4695 2018-02-06 19:09:52.000000 grapa-0.5.4.8/grapa/examples/Spectra/rem_Sample1_564_run2_i_TR.Sample.asc
--rw-rw-rw-   0        0        0      609 2018-01-03 22:57:48.000000 grapa-0.5.4.8/grapa/examples/subplots_examples.txt
--rw-rw-rw-   0        0        0     3554 2018-01-29 20:11:32.000000 grapa-0.5.4.8/grapa/examples/testRoutine.py
--rw-rw-rw-   0        0        0    20992 2017-12-19 08:44:28.000000 grapa-0.5.4.8/grapa/examples/Thumbs.db
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:25.000000 grapa-0.5.4.8/grapa/examples/TIV/
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:25.000000 grapa-0.5.4.8/grapa/examples/TIV/dark/
--rw-rw-rw-   0        0        0     3026 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_123K.txt
--rw-rw-rw-   0        0        0     2981 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_143K.txt
--rw-rw-rw-   0        0        0     2951 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_163K.txt
--rw-rw-rw-   0        0        0     2914 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_183K.txt
--rw-rw-rw-   0        0        0     2890 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_203K.txt
--rw-rw-rw-   0        0        0     2867 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_223K.txt
--rw-rw-rw-   0        0        0     2856 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_243K.txt
--rw-rw-rw-   0        0        0     2835 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_263K.txt
--rw-rw-rw-   0        0        0     2822 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_283K.txt
--rw-rw-rw-   0        0        0     2801 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_303K.txt
--rw-rw-rw-   0        0        0     4509 2018-02-14 20:57:40.000000 grapa-0.5.4.8/grapa/examples/TIV/dark_Oct1393_wARC_A_a2_123K.txt
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:25.000000 grapa-0.5.4.8/grapa/examples/TIV/illum/
--rw-rw-rw-   0        0        0     1643 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_123K.txt
--rw-rw-rw-   0        0        0     1643 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_143K.txt
--rw-rw-rw-   0        0        0     1642 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_163K.txt
--rw-rw-rw-   0        0        0     1639 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_183K.txt
--rw-rw-rw-   0        0        0     1630 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_203K.txt
--rw-rw-rw-   0        0        0     1635 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_223K.txt
--rw-rw-rw-   0        0        0     1632 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_243K.txt
--rw-rw-rw-   0        0        0     1636 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_264K.txt
--rw-rw-rw-   0        0        0     1629 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_283K.txt
--rw-rw-rw-   0        0        0     1627 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_303K.txt
--rw-rw-rw-   0        0        0     2700 2018-02-14 20:57:38.000000 grapa-0.5.4.8/grapa/examples/TIV/JV_illuminated_Oct1393_wARC_A_a2_123K.txt
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:25.000000 grapa-0.5.4.8/grapa/examples/TRPL/
--rw-rw-rw-   0        0        0   129474 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/TRPL/003.dat
--rw-rw-rw-   0        0        0    29591 2018-01-02 20:25:26.000000 grapa-0.5.4.8/grapa/examples/TRPL/522.dat
--rw-rw-rw-   0        0        0    43697 2017-12-21 21:13:10.000000 grapa-0.5.4.8/grapa/examples/turtle.jpg
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:25.000000 grapa-0.5.4.8/grapa/examples/XPS/
--rw-rw-rw-   0        0        0     6567 2018-01-29 20:25:18.000000 grapa-0.5.4.8/grapa/examples/XPS/Detailed_Vb_A_0.csv
--rw-rw-rw-   0        0        0    57049 2018-01-29 20:25:12.000000 grapa-0.5.4.8/grapa/examples/XPS/Survey_A_0.csv
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:25.000000 grapa-0.5.4.8/grapa/examples/XRF/
--rw-rw-rw-   0        0        0     6135 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/XRF/SAMPLE_G.mca
--rw-rw-rw-   0        0        0    24055 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/XRF/SAMPLE_G.mca_1.1.1.1.html
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:25.000000 grapa-0.5.4.8/grapa/examples/_subplots_insets/
--rw-rw-rw-   0        0        0   129474 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/_subplots_insets/003.dat
--rw-rw-rw-   0        0        0     2784 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/_subplots_insets/C-f_SAMPLE_f1_123K.txt
--rw-rw-rw-   0        0        0     1196 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/_subplots_insets/graph_matrix.txt
--rw-rw-rw-   0        0        0     2662 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/_subplots_insets/I-V_SAMPLE_A_a2_01.txt
--rw-rw-rw-   0        0        0     3673 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/_subplots_insets/SAMPLE_A_d1_1.sr
--rw-rw-rw-   0        0        0     2145 2017-12-05 07:37:04.000000 grapa-0.5.4.8/grapa/examples/_subplots_insets/scatter.txt
--rw-rw-rw-   0        0        0    47394 2021-03-24 16:38:10.000000 grapa-0.5.4.8/grapa/graph.py
--rw-rw-rw-   0        0        0    87228 2021-03-24 16:38:10.000000 grapa-0.5.4.8/grapa/graphIO.py
--rw-rw-rw-   0        0        0     2460 2018-11-05 07:20:06.000000 grapa-0.5.4.8/grapa/graphIO_aux.py
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:25.000000 grapa-0.5.4.8/grapa/gui/
--rw-rw-rw-   0        0        0     3102 2017-12-19 20:40:52.000000 grapa-0.5.4.8/grapa/gui/createToolTip.py
--rw-rw-rw-   0        0        0     4367 2018-02-08 08:01:50.000000 grapa-0.5.4.8/grapa/gui/GUIConfigEditor_.py
--rw-rw-rw-   0        0        0    12511 2019-07-06 08:23:35.000000 grapa-0.5.4.8/grapa/gui/GUIdataEditor.py
--rw-rw-rw-   0        0        0     8661 2019-07-01 09:45:14.000000 grapa-0.5.4.8/grapa/gui/GUIdataEditor_old.py
--rw-rw-rw-   0        0        0    15321 2021-03-24 16:38:10.000000 grapa-0.5.4.8/grapa/gui/GUIgraphManager.py
--rw-rw-rw-   0        0        0     9966 2021-03-24 16:38:10.000000 grapa-0.5.4.8/grapa/gui/GUImisc.py
--rw-rw-rw-   0        0        0    21838 2018-03-20 18:43:36.000000 grapa-0.5.4.8/grapa/gui/GUIpopup.py
--rw-rw-rw-   0        0        0        0 2018-02-04 17:55:56.000000 grapa-0.5.4.8/grapa/gui/__init__.py
--rw-rw-rw-   0        0        0   105024 2021-03-24 16:38:10.000000 grapa-0.5.4.8/grapa/GUI.py
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:25.000000 grapa-0.5.4.8/grapa/manual/
--rw-rw-rw-   0        0        0     4730 2018-01-30 08:25:06.000000 grapa-0.5.4.8/grapa/manual/curveMycurve.py
--rw-rw-rw-   0        0        0     5602 2017-12-27 10:29:32.000000 grapa-0.5.4.8/grapa/manual/example_sinx_x.txt
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:25.000000 grapa-0.5.4.8/grapa/manual/graphics/
--rw-rw-rw-   0        0        0      601 2018-02-11 12:59:20.000000 grapa-0.5.4.8/grapa/manual/graphics/schematics.txt
--rw-rw-rw-   0        0        0     2005 2018-02-11 09:44:16.000000 grapa-0.5.4.8/grapa/manual/graphics/schematics_full.txt
--rw-rw-rw-   0        0        0     1643 2018-02-11 11:50:14.000000 grapa-0.5.4.8/grapa/manual/graphics/schematics_layer.txt
--rw-rw-rw-   0        0        0     1467 2018-02-11 11:57:54.000000 grapa-0.5.4.8/grapa/manual/graphics/schematics_layer_simple.txt
--rw-rw-rw-   0        0        0     1666 2018-02-11 11:37:34.000000 grapa-0.5.4.8/grapa/manual/graphics/schematics_sub.txt
--rw-rw-rw-   0        0        0     2502 2018-01-30 08:25:04.000000 grapa-0.5.4.8/grapa/manual/graphMydata.py
--rw-rw-rw-   0        0        0   577655 2018-06-15 21:54:46.000000 grapa-0.5.4.8/grapa/manual/manual.pdf
--rw-rw-rw-   0        0        0     9510 2018-04-13 06:13:30.000000 grapa-0.5.4.8/grapa/mathModule.py
--rw-rw-rw-   0        0        0     4987 2018-01-30 08:24:34.000000 grapa-0.5.4.8/grapa/observable.py
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:25.000000 grapa-0.5.4.8/grapa/scripts/
--rw-rw-rw-   0        0        0     9988 2018-02-04 18:24:26.000000 grapa-0.5.4.8/grapa/scripts/script_JVSummaryToBoxPlots.py
--rw-rw-rw-   0        0        0    20899 2020-12-27 15:34:11.000000 grapa-0.5.4.8/grapa/scripts/script_processCVCf.py
--rw-rw-rw-   0        0        0     6213 2020-02-14 12:40:29.000000 grapa-0.5.4.8/grapa/scripts/script_processJscVoc.py
--rw-rw-rw-   0        0        0    24088 2021-03-24 16:45:18.000000 grapa-0.5.4.8/grapa/scripts/script_processJV.py
--rw-rw-rw-   0        0        0        0 2017-12-05 07:37:02.000000 grapa-0.5.4.8/grapa/scripts/__init__.py
--rw-rw-rw-   0        0        0      505 2020-03-12 07:09:15.000000 grapa-0.5.4.8/grapa/test.py
--rw-rw-rw-   0        0        0      426 2017-12-05 07:37:00.000000 grapa-0.5.4.8/grapa/TRANSITION_v0.3_TO v0.4.txt
--rw-rw-rw-   0        0        0    47198 2021-03-24 16:38:10.000000 grapa-0.5.4.8/grapa/versionNotes.txt
--rw-rw-rw-   0        0        0      280 2021-03-24 16:38:10.000000 grapa-0.5.4.8/grapa/__init__.py
-drwxrwxrwx   0        0        0        0 2021-03-24 16:51:24.000000 grapa-0.5.4.8/grapa.egg-info/
--rw-rw-rw-   0        0        0        1 2021-03-24 16:51:24.000000 grapa-0.5.4.8/grapa.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0      497 2021-03-24 16:51:24.000000 grapa-0.5.4.8/grapa.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0       23 2021-03-24 16:51:24.000000 grapa-0.5.4.8/grapa.egg-info/requires.txt
--rw-rw-rw-   0        0        0    37752 2021-03-24 16:51:24.000000 grapa-0.5.4.8/grapa.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        6 2021-03-24 16:51:24.000000 grapa-0.5.4.8/grapa.egg-info/top_level.txt
--rw-rw-rw-   0        0        0     1121 2018-01-30 10:15:20.000000 grapa-0.5.4.8/LICENSE
--rw-rw-rw-   0        0        0      470 2021-01-21 21:20:18.000000 grapa-0.5.4.8/MANIFEST.in
--rw-rw-rw-   0        0        0      497 2021-03-24 16:51:25.000000 grapa-0.5.4.8/PKG-INFO
--rw-rw-rw-   0        0        0       87 2021-03-24 16:51:25.000000 grapa-0.5.4.8/setup.cfg
--rw-rw-rw-   0        0        0     1402 2021-03-24 16:51:21.000000 grapa-0.5.4.8/setup.py
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:54.775004 grapa-0.6.1.0/
+-rw-rw-rw-   0        0        0     1121 2023-03-21 08:56:26.000000 grapa-0.6.1.0/LICENSE
+-rw-rw-rw-   0        0        0      476 2023-04-19 13:10:54.776004 grapa-0.6.1.0/PKG-INFO
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:53.807964 grapa-0.6.1.0/grapa/
+-rw-rw-rw-   0        0        0    26022 2023-04-13 07:15:21.000000 grapa-0.6.1.0/grapa/GUI.py
+-rw-rw-rw-   0        0        0      342 2023-03-20 21:44:54.000000 grapa-0.6.1.0/grapa/__init__.py
+-rw-rw-rw-   0        0        0    10471 2023-03-20 09:40:07.000000 grapa-0.6.1.0/grapa/colorscale.py
+-rw-rw-rw-   0        0        0     1420 2022-05-20 16:28:55.000000 grapa-0.6.1.0/grapa/config.txt
+-rw-rw-rw-   0        0        0     1358 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/config_anch.txt
+-rw-rw-rw-   0        0        0     1420 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/config_default.txt
+-rw-rw-rw-   0        0        0    51389 2023-04-13 07:15:21.000000 grapa-0.6.1.0/grapa/curve.py
+-rw-rw-rw-   0        0        0     8093 2023-03-20 09:40:07.000000 grapa-0.6.1.0/grapa/curve_image.py
+-rw-rw-rw-   0        0        0     2808 2023-03-20 09:40:07.000000 grapa-0.6.1.0/grapa/curve_inset.py
+-rw-rw-rw-   0        0        0     4676 2023-03-20 09:40:07.000000 grapa-0.6.1.0/grapa/curve_subplot.py
+-rw-rw-rw-   0        0        0    13298 2023-03-20 09:40:07.000000 grapa-0.6.1.0/grapa/database.py
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:54.003009 grapa-0.6.1.0/grapa/datatypes/
+-rw-rw-rw-   0        0        0    20471 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/datatypes/AM0_2000_ASTM_E-490-00.txt
+-rw-rw-rw-   0        0        0    56422 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/datatypes/AM1-5_Ed2-2008.txt
+-rw-rw-rw-   0        0        0     1651 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/datatypes/EQE_20.4_cell.txt
+-rw-rw-rw-   0        0        0      685 2020-08-20 21:28:45.000000 grapa-0.6.1.0/grapa/datatypes/EQE_absorption_CdS.txt
+-rw-rw-rw-   0        0        0     4006 2021-03-26 10:59:32.000000 grapa-0.6.1.0/grapa/datatypes/EQE_referenceSpectra.txt
+-rw-rw-rw-   0        0        0    14983 2021-04-06 12:10:20.000000 grapa-0.6.1.0/grapa/datatypes/XRF_photonenergiesintensities.txt
+-rw-rw-rw-   0        0        0        0 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/datatypes/__init__.py
+-rw-rw-rw-   0        0        0    22695 2021-10-22 07:07:12.000000 grapa-0.6.1.0/grapa/datatypes/curveArrhenius.py
+-rw-rw-rw-   0        0        0    10426 2023-03-20 09:40:07.000000 grapa-0.6.1.0/grapa/datatypes/curveCV.py
+-rw-rw-rw-   0        0        0     5065 2021-05-10 10:42:35.000000 grapa-0.6.1.0/grapa/datatypes/curveCf.py
+-rw-rw-rw-   0        0        0    34628 2023-03-20 09:35:21.000000 grapa-0.6.1.0/grapa/datatypes/curveEQE.py
+-rw-rw-rw-   0        0        0    46497 2023-03-20 10:11:09.000000 grapa-0.6.1.0/grapa/datatypes/curveJV.py
+-rw-rw-rw-   0        0        0    20367 2021-10-20 13:00:06.000000 grapa-0.6.1.0/grapa/datatypes/curveJscVoc.py
+-rw-rw-rw-   0        0        0     8368 2023-03-20 09:40:07.000000 grapa-0.6.1.0/grapa/datatypes/curveMCA.py
+-rw-rw-rw-   0        0        0     9586 2023-04-13 07:17:27.000000 grapa-0.6.1.0/grapa/datatypes/curveMath.py
+-rw-rw-rw-   0        0        0    12755 2022-01-25 21:20:05.000000 grapa-0.6.1.0/grapa/datatypes/curveSIMS.py
+-rw-rw-rw-   0        0        0    22492 2021-05-03 17:04:16.000000 grapa-0.6.1.0/grapa/datatypes/curveSpectrum.py
+-rw-rw-rw-   0        0        0    20548 2023-03-20 09:40:07.000000 grapa-0.6.1.0/grapa/datatypes/curveTRPL.py
+-rw-rw-rw-   0        0        0     3348 2021-05-10 10:24:30.000000 grapa-0.6.1.0/grapa/datatypes/graphCV.py
+-rw-rw-rw-   0        0        0     6807 2021-10-19 09:20:06.000000 grapa-0.6.1.0/grapa/datatypes/graphCf.py
+-rw-rw-rw-   0        0        0     3373 2023-03-20 09:40:17.000000 grapa-0.6.1.0/grapa/datatypes/graphEQE.py
+-rw-rw-rw-   0        0        0     2576 2021-05-10 16:12:13.000000 grapa-0.6.1.0/grapa/datatypes/graphEQE_CSU.py
+-rw-rw-rw-   0        0        0     6831 2023-03-20 21:59:47.000000 grapa-0.6.1.0/grapa/datatypes/graphJV.py
+-rw-rw-rw-   0        0        0    10128 2021-10-20 07:54:23.000000 grapa-0.6.1.0/grapa/datatypes/graphJVDarkIllum.py
+-rw-rw-rw-   0        0        0     2238 2023-03-20 10:09:11.000000 grapa-0.6.1.0/grapa/datatypes/graphJV_Ossila.py
+-rw-rw-rw-   0        0        0     1444 2021-06-09 15:56:17.000000 grapa-0.6.1.0/grapa/datatypes/graphMBElog.py
+-rw-rw-rw-   0        0        0     3724 2022-07-08 06:42:15.000000 grapa-0.6.1.0/grapa/datatypes/graphMCA.py
+-rw-rw-rw-   0        0        0     4935 2021-11-02 15:11:55.000000 grapa-0.6.1.0/grapa/datatypes/graphMCAfit.py
+-rw-rw-rw-   0        0        0     5574 2021-11-16 10:24:49.000000 grapa-0.6.1.0/grapa/datatypes/graphPAIOS.py
+-rw-rw-rw-   0        0        0     2322 2021-06-09 15:54:47.000000 grapa-0.6.1.0/grapa/datatypes/graphPGZ.py
+-rw-rw-rw-   0        0        0    17946 2022-01-25 21:36:36.000000 grapa-0.6.1.0/grapa/datatypes/graphSIMS.py
+-rw-rw-rw-   0        0        0     2192 2023-03-20 09:40:07.000000 grapa-0.6.1.0/grapa/datatypes/graphSPE.py
+-rw-rw-rw-   0        0        0     7212 2021-05-03 17:08:29.000000 grapa-0.6.1.0/grapa/datatypes/graphSpectrum.py
+-rw-rw-rw-   0        0        0     5312 2021-06-09 16:33:24.000000 grapa-0.6.1.0/grapa/datatypes/graphSquidAdmiral.py
+-rw-rw-rw-   0        0        0     3333 2021-06-09 09:48:32.000000 grapa-0.6.1.0/grapa/datatypes/graphTRPL.py
+-rw-rw-rw-   0        0        0     2383 2021-06-09 15:51:39.000000 grapa-0.6.1.0/grapa/datatypes/graphXLS.py
+-rw-rw-rw-   0        0        0     3884 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/datatypes/graphXML.py
+-rw-rw-rw-   0        0        0     2139 2021-06-09 15:52:37.000000 grapa-0.6.1.0/grapa/datatypes/graphXPS.py
+-rw-rw-rw-   0        0        0    51750 2021-03-26 09:25:18.000000 grapa-0.6.1.0/grapa/datatypes/spectrumInstrumentalResponses.txt
+-rw-rw-rw-   0        0        0    36628 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/datatypes/spectrumSubstrates.txt
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:54.044170 grapa-0.6.1.0/grapa/examples/
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:54.132003 grapa-0.6.1.0/grapa/examples/CV/
+-rw-rw-rw-   0        0        0     2166 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=123_K.txt
+-rw-rw-rw-   0        0        0     2163 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=133_K.txt
+-rw-rw-rw-   0        0        0     2171 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=143_K.txt
+-rw-rw-rw-   0        0        0     2164 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=153_K.txt
+-rw-rw-rw-   0        0        0     2160 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=163_K.txt
+-rw-rw-rw-   0        0        0     2157 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=173_K.txt
+-rw-rw-rw-   0        0        0     2163 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=183_K.txt
+-rw-rw-rw-   0        0        0     2153 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=193_K.txt
+-rw-rw-rw-   0        0        0     2160 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=203_K.txt
+-rw-rw-rw-   0        0        0     2158 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=213_K.txt
+-rw-rw-rw-   0        0        0     2156 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=223_K.txt
+-rw-rw-rw-   0        0        0     2157 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=233_K.txt
+-rw-rw-rw-   0        0        0     2155 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=243_K.txt
+-rw-rw-rw-   0        0        0     2156 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=253_K.txt
+-rw-rw-rw-   0        0        0     2152 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=263_K.txt
+-rw-rw-rw-   0        0        0     2160 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=273_K.txt
+-rw-rw-rw-   0        0        0     2159 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=283_K.txt
+-rw-rw-rw-   0        0        0     2161 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=293_K.txt
+-rw-rw-rw-   0        0        0     2160 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=303_K.txt
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:54.207715 grapa-0.6.1.0/grapa/examples/Cf/
+-rw-rw-rw-   0        0        0     2784 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_123K.txt
+-rw-rw-rw-   0        0        0     2763 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_133K.txt
+-rw-rw-rw-   0        0        0     2741 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_143K.txt
+-rw-rw-rw-   0        0        0     2717 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_153K.txt
+-rw-rw-rw-   0        0        0     2740 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_163K.txt
+-rw-rw-rw-   0        0        0     2769 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_173K.txt
+-rw-rw-rw-   0        0        0     2743 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_183K.txt
+-rw-rw-rw-   0        0        0     2772 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_193K.txt
+-rw-rw-rw-   0        0        0     2759 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_203K.txt
+-rw-rw-rw-   0        0        0     2730 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_213K.txt
+-rw-rw-rw-   0        0        0     2769 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_223K.txt
+-rw-rw-rw-   0        0        0     2761 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_233K.txt
+-rw-rw-rw-   0        0        0     2750 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_243K.txt
+-rw-rw-rw-   0        0        0     2744 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_253K.txt
+-rw-rw-rw-   0        0        0     2761 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_263K.txt
+-rw-rw-rw-   0        0        0     2701 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_273K.txt
+-rw-rw-rw-   0        0        0     2729 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_283K.txt
+-rw-rw-rw-   0        0        0     2770 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_293K.txt
+-rw-rw-rw-   0        0        0     2721 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_303K.txt
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:54.228116 grapa-0.6.1.0/grapa/examples/EQE/
+-rw-rw-rw-   0        0        0     1706 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/EQE/1150-8-C3-QE.txt
+-rw-rw-rw-   0        0        0     3673 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/EQE/SAMPLE_A_d1_1.sr
+-rw-rw-rw-   0        0        0     3485 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/EQE/SAMPLE_B_TCObelowMo_d1_1.sr
+-rw-rw-rw-   0        0        0     4760 2020-07-03 10:59:22.000000 grapa-0.6.1.0/grapa/examples/EQE/SAMPLE_C_f1_1.sr
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:53.701787 grapa-0.6.1.0/grapa/examples/JV/
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:54.263456 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_A/
+-rw-rw-rw-   0        0        0     2374 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_C2_02_dark.txt
+-rw-rw-rw-   0        0        0     2662 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_a2_01.txt
+-rw-rw-rw-   0        0        0     2653 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_a2_02.txt
+-rw-rw-rw-   0        0        0     2476 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_a2_02_dark.txt
+-rw-rw-rw-   0        0        0     2660 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_a3_01.txt
+-rw-rw-rw-   0        0        0     2374 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_b2_02_dark.txt
+-rw-rw-rw-   0        0        0      177 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_A/area.txt
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:54.407584 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/
+-rw-rw-rw-   0        0        0     4277 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_Param.txt
+-rw-rw-rw-   0        0        0     2259 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_a1_01.txt
+-rw-rw-rw-   0        0        0     2212 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_a2_01.txt
+-rw-rw-rw-   0        0        0     2218 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_a3_01.txt
+-rw-rw-rw-   0        0        0     2217 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_b1_01.txt
+-rw-rw-rw-   0        0        0     2213 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_b2_01.txt
+-rw-rw-rw-   0        0        0     2215 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_b3_01.txt
+-rw-rw-rw-   0        0        0     2210 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_c1_01.txt
+-rw-rw-rw-   0        0        0     2207 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_c1_02.txt
+-rw-rw-rw-   0        0        0     2214 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_c2_01.txt
+-rw-rw-rw-   0        0        0     2215 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_c3_01.txt
+-rw-rw-rw-   0        0        0     2216 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_d1_01.txt
+-rw-rw-rw-   0        0        0     2211 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_d2_01.txt
+-rw-rw-rw-   0        0        0     2213 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_d3_01.txt
+-rw-rw-rw-   0        0        0     2216 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_e1_01.txt
+-rw-rw-rw-   0        0        0     2207 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_e2_01.txt
+-rw-rw-rw-   0        0        0     2213 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_e3_01.txt
+-rw-rw-rw-   0        0        0     2215 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_f1_01.txt
+-rw-rw-rw-   0        0        0     2215 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_f2_01.txt
+-rw-rw-rw-   0        0        0     2215 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_f3_01.txt
+-rw-rw-rw-   0        0        0     2263 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_f3_01_dark.txt
+-rw-rw-rw-   0        0        0     2268 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_f3_01_new_cont_01.txt
+-rw-rw-rw-   0        0        0      180 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/SAMPLE_B_3LayerMo.txt
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:54.504017 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/
+-rw-rw-rw-   0        0        0     1788 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_Param.txt
+-rw-rw-rw-   0        0        0     2209 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_a1_01.txt
+-rw-rw-rw-   0        0        0     2215 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_a2_01.txt
+-rw-rw-rw-   0        0        0     2211 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_a3_01.txt
+-rw-rw-rw-   0        0        0     2211 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_b1_01.txt
+-rw-rw-rw-   0        0        0     2212 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_b2_01.txt
+-rw-rw-rw-   0        0        0     2266 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_b2_01_dark.txt
+-rw-rw-rw-   0        0        0     2210 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_b3_01.txt
+-rw-rw-rw-   0        0        0     2221 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_c1_01.txt
+-rw-rw-rw-   0        0        0     2209 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_c2_01.txt
+-rw-rw-rw-   0        0        0     2214 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_c3_01.txt
+-rw-rw-rw-   0        0        0     2213 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_d1_01.txt
+-rw-rw-rw-   0        0        0     2215 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_d2_01.txt
+-rw-rw-rw-   0        0        0     2217 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_d3_01.txt
+-rw-rw-rw-   0        0        0     2210 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_e1_01.txt
+-rw-rw-rw-   0        0        0     2205 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_e2_01.txt
+-rw-rw-rw-   0        0        0     2223 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_e3_01.txt
+-rw-rw-rw-   0        0        0     2219 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_f1_01.txt
+-rw-rw-rw-   0        0        0     2211 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_f2_01.txt
+-rw-rw-rw-   0        0        0     2218 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_f3_01.txt
+-rw-rw-rw-   0        0        0      288 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/area.txt
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:54.507009 grapa-0.6.1.0/grapa/examples/JscVoc/
+-rw-rw-rw-   0        0        0     5334 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/JscVoc/JscVoc_SAMPLE_c2_Values.txt
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:54.518551 grapa-0.6.1.0/grapa/examples/SIMS/
+-rw-rw-rw-   0        0        0   215354 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/SIMS/SAMPLE_CZTS_A_NoNa_1.TXT
+-rw-rw-rw-   0        0        0   118326 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/SIMS/SAMPLE_D_c_1.TXT
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:54.539595 grapa-0.6.1.0/grapa/examples/Spectra/
+-rw-rw-rw-   0        0        0    17255 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/Spectra/CdS32nm_on_SLG_R.txt
+-rw-rw-rw-   0        0        0    17564 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/Spectra/CdS32nm_on_SLG_T.txt
+-rw-rw-rw-   0        0        0     6099 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/Spectra/PLexample_thinCIGSFilmWithInterference.dat
+-rw-rw-rw-   0        0        0     4695 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/Spectra/rem_Sample1_564_run2_i_TR.Sample.asc
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:53.710735 grapa-0.6.1.0/grapa/examples/TIV/
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:54.584261 grapa-0.6.1.0/grapa/examples/TIV/dark/
+-rw-rw-rw-   0        0        0     3026 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_123K.txt
+-rw-rw-rw-   0        0        0     2981 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_143K.txt
+-rw-rw-rw-   0        0        0     2951 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_163K.txt
+-rw-rw-rw-   0        0        0     2914 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_183K.txt
+-rw-rw-rw-   0        0        0     2890 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_203K.txt
+-rw-rw-rw-   0        0        0     2867 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_223K.txt
+-rw-rw-rw-   0        0        0     2856 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_243K.txt
+-rw-rw-rw-   0        0        0     2835 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_263K.txt
+-rw-rw-rw-   0        0        0     2822 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_283K.txt
+-rw-rw-rw-   0        0        0     2801 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_303K.txt
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:54.633382 grapa-0.6.1.0/grapa/examples/TIV/illum/
+-rw-rw-rw-   0        0        0     1643 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_123K.txt
+-rw-rw-rw-   0        0        0     1643 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_143K.txt
+-rw-rw-rw-   0        0        0     1642 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_163K.txt
+-rw-rw-rw-   0        0        0     1639 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_183K.txt
+-rw-rw-rw-   0        0        0     1630 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_203K.txt
+-rw-rw-rw-   0        0        0     1635 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_223K.txt
+-rw-rw-rw-   0        0        0     1632 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_243K.txt
+-rw-rw-rw-   0        0        0     1636 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_264K.txt
+-rw-rw-rw-   0        0        0     1629 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_283K.txt
+-rw-rw-rw-   0        0        0     1627 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_303K.txt
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:54.643484 grapa-0.6.1.0/grapa/examples/TRPL/
+-rw-rw-rw-   0        0        0   129474 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/TRPL/003.dat
+-rw-rw-rw-   0        0        0    29591 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/TRPL/522.dat
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:54.654372 grapa-0.6.1.0/grapa/examples/XPS/
+-rw-rw-rw-   0        0        0     6567 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/XPS/Detailed_Vb_A_0.csv
+-rw-rw-rw-   0        0        0    57049 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/XPS/Survey_A_0.csv
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:54.662849 grapa-0.6.1.0/grapa/examples/XRF/
+-rw-rw-rw-   0        0        0     6135 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/XRF/SAMPLE_G.mca
+-rw-rw-rw-   0        0        0    24055 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/XRF/SAMPLE_G.mca_1.1.1.1.html
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:54.685174 grapa-0.6.1.0/grapa/examples/boxplot/
+-rw-rw-rw-   0        0        0     2555 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/boxplot/I-V_CA160_Param.txt
+-rw-rw-rw-   0        0        0      585 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/boxplot/export_sample_a_summary_illum.txt
+-rw-rw-rw-   0        0        0     4347 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/boxplot/export_sample_b_3layermo_summary_illum.txt
+-rw-rw-rw-   0        0        0     3981 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/boxplot/export_sample_b_5layermo_summary_illum.txt
+-rw-rw-rw-   0        0        0    23820 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/example_datafile.txt
+-rw-rw-rw-   0        0        0    20920 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/example_datafile_withXY1rowcol.txt
+-rw-rw-rw-   0        0        0      920 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/example_imshow_datafile.txt
+-rw-rw-rw-   0        0        0     1546 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/example_imshow_datatable.txt
+-rw-rw-rw-   0        0        0      907 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/example_imshow_picture.txt
+-rw-rw-rw-   0        0        0     1545 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/fancyAnnotations.txt
+-rw-rw-rw-   0        0        0      609 2021-04-12 06:49:22.000000 grapa-0.6.1.0/grapa/examples/subplots_examples.txt
+-rw-rw-rw-   0        0        0     3554 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/testRoutine.py
+-rw-rw-rw-   0        0        0    43697 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/examples/turtle.jpg
+-rw-rw-rw-   0        0        0    47954 2023-03-20 09:37:25.000000 grapa-0.6.1.0/grapa/graph.py
+-rw-rw-rw-   0        0        0    88883 2023-03-20 09:37:53.000000 grapa-0.6.1.0/grapa/graphIO.py
+-rw-rw-rw-   0        0        0     2838 2022-05-22 19:29:43.000000 grapa-0.6.1.0/grapa/graphIO_aux.py
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:54.721114 grapa-0.6.1.0/grapa/gui/
+-rw-rw-rw-   0        0        0     8893 2023-03-20 08:41:52.000000 grapa-0.6.1.0/grapa/gui/GUIFuncGUI.py
+-rw-rw-rw-   0        0        0    97036 2023-03-27 23:03:26.000000 grapa-0.6.1.0/grapa/gui/GUIMainElements.py
+-rw-rw-rw-   0        0        0    12484 2021-05-03 16:47:51.000000 grapa-0.6.1.0/grapa/gui/GUIdataEditor.py
+-rw-rw-rw-   0        0        0    17686 2021-04-27 13:36:59.000000 grapa-0.6.1.0/grapa/gui/GUIgraphManager.py
+-rw-rw-rw-   0        0        0    14893 2021-11-03 14:01:12.000000 grapa-0.6.1.0/grapa/gui/GUImisc.py
+-rw-rw-rw-   0        0        0    22474 2021-05-03 09:13:48.000000 grapa-0.6.1.0/grapa/gui/GUIpopup.py
+-rw-rw-rw-   0        0        0        0 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/gui/__init__.py
+-rw-rw-rw-   0        0        0     3097 2021-05-03 16:48:55.000000 grapa-0.6.1.0/grapa/gui/createToolTip.py
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:54.736976 grapa-0.6.1.0/grapa/manual/
+-rw-rw-rw-   0        0        0     4730 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/manual/curveMycurve.py
+-rw-rw-rw-   0        0        0     5602 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/manual/example_sinx_x.txt
+-rw-rw-rw-   0        0        0     2502 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/manual/graphMydata.py
+-rw-rw-rw-   0        0        0   577655 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/manual/manual.pdf
+-rw-rw-rw-   0        0        0    12624 2023-03-20 09:40:07.000000 grapa-0.6.1.0/grapa/mathModule.py
+-rw-rw-rw-   0        0        0     5251 2023-03-20 09:40:07.000000 grapa-0.6.1.0/grapa/observable.py
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:54.771693 grapa-0.6.1.0/grapa/scripts/
+-rw-rw-rw-   0        0        0        0 2020-07-03 10:59:23.000000 grapa-0.6.1.0/grapa/scripts/__init__.py
+-rw-rw-rw-   0        0        0     9927 2021-10-20 13:30:26.000000 grapa-0.6.1.0/grapa/scripts/script_JVSummaryToBoxPlots.py
+-rw-rw-rw-   0        0        0    22102 2021-10-20 13:12:24.000000 grapa-0.6.1.0/grapa/scripts/script_processCVCf.py
+-rw-rw-rw-   0        0        0    24907 2022-06-22 13:21:32.000000 grapa-0.6.1.0/grapa/scripts/script_processJV.py
+-rw-rw-rw-   0        0        0     6075 2021-10-20 13:00:38.000000 grapa-0.6.1.0/grapa/scripts/script_processJscVoc.py
+-rw-rw-rw-   0        0        0    50545 2023-04-19 12:34:54.000000 grapa-0.6.1.0/grapa/versionNotes.txt
+drwxrwxrwx   0        0        0        0 2023-04-19 13:10:53.838925 grapa-0.6.1.0/grapa.egg-info/
+-rw-rw-rw-   0        0        0      476 2023-04-19 13:10:52.000000 grapa-0.6.1.0/grapa.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0     9611 2023-04-19 13:10:53.000000 grapa-0.6.1.0/grapa.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2023-04-19 13:10:52.000000 grapa-0.6.1.0/grapa.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0       23 2023-04-19 13:10:52.000000 grapa-0.6.1.0/grapa.egg-info/requires.txt
+-rw-rw-rw-   0        0        0        6 2023-04-19 13:10:53.000000 grapa-0.6.1.0/grapa.egg-info/top_level.txt
+-rw-rw-rw-   0        0        0       87 2023-04-19 13:10:54.778416 grapa-0.6.1.0/setup.cfg
+-rw-rw-rw-   0        0        0     1402 2023-04-19 12:54:27.000000 grapa-0.6.1.0/setup.py
```

### filetype from file(1)

```diff
@@ -1 +1 @@
-POSIX tar archive (GNU)
+POSIX tar archive
```

### Comparing `grapa-0.5.4.8/grapa/colorscale.py` & `grapa-0.6.1.0/grapa/colorscale.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,128 +1,135 @@
 # -*- coding: utf-8 -*-
 """
 @author: Romain Carron
-Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+Copyright (c) 2023, Empa, Laboratory for Thin Films and Photovoltaics, Romain
+Carron
 """
 
 import numpy as np
 import colorsys
 import warnings
-from matplotlib import colors as matcolors
+# from matplotlib import colors as matcolors
 from tkinter import PhotoImage
 
 with warnings.catch_warnings():
     warnings.simplefilter('ignore')
     import matplotlib.pyplot as plt
 
-from grapa.mathModule import is_number, stringToVariable
+from grapa.mathModule import is_number, strToVar
 
 
-## Should make better use of matplotlib class Colormap - get rid of home-made ?
-# at the moment handles colormaps both ways: simpler home-made, and names of matplotlib colormaps
+# Should make better use of matplotlib class Colormap - get rid of home-made ?
+# at the moment handles colormaps both ways: simpler home-made, and names of
+# matplotlib colormaps
 
 class Color:
     """ internally stores colors in RGB colorspace """
+
     def __init__(self, code, space='rgb'):
         self.space = space.lower()
         self.code = code
+
     def get(self, space='rgb'):
         space = space.lower()
         # want to avoid unnecessary conversions (ie. hls -> rgb -> hls)
         if space == self.space:
             return self.code
         # needs a conversion: need to convert to rbg, then to output space
         code = self.code
         if self.space != 'rgb':
             if len(self.code) != 3:
-                print('ERROR color: please check input, only RBGA accepts color quadruplets (here colorspace is',self.space,')')
+                print('ERROR color: please check input, only RBGA accepts',
+                      'color quadruplets (here colorspace is', self.space, ')')
             if self.space == 'hls':
                 code = colorsys.hls_to_rgb(*self.code)
             elif self.space == 'hsv':
                 code = colorsys.hsv_to_rgb(*self.code)
             else:
-                print('Class Color __init__ color space not supported ('+ self.space +')')
+                print('Class Color __init__ color space not supported',
+                      '(' + self.space + ')')
         # now code is in rgb space
         if space == 'rgb':
             return code
         elif space == 'hls':
             return colorsys.rgb_to_hls(*code)
         elif space == 'hsv':
             return colorsys.rgb_to_hsv(*code)
         else:
             print('Class Color get color space not supported (' + space + ')')
         return None
 
 
-
 class PhotoImageColorscale(PhotoImage):
-    
     def __init__(self, width=32, height=32, **args):
         # typical call: (with=32, height=32)
         PhotoImage.__init__(self, width=width, height=height, **args)
+
     def pixel(self, pos, color):
         """ color in the form [r,g,b]; pos in the form (x,y) """
-        [r,g,b] = [int(c*255) for c in color]
-        x,y = pos
-        self.put("#%02x%02x%02x" % (r,g,b), (x,y))
+        [r, g, b] = [int(c*255) for c in color]
+        x, y = pos
+        self.put("#%02x%02x%02x" % (r, g, b), (x, y))
+
     def vline(self, x, color):
         """ color in the form [r,g,b]; x scalar """
-        [r,g,b] = [int(c*255) for c in color[0:3]]
-        hexcode = "#%02x%02x%02x" % (r,g,b)
-        for l in range(self.height()):
-            self.put(hexcode, (x,l))
+        [r, g, b] = [int(c*255) for c in color[0:3]]
+        hexcode = "#%02x%02x%02x" % (r, g, b)
+        for he in range(self.height()):
+            self.put(hexcode, (x, he))
+
     def hline(self, y, color):
         """ color in the form [r,g,b]; x scalar """
-        [r,g,b] = [int(c*255) for c in color[0:3]]
-        hexcode = "#%02x%02x%02x" % (r,g,b)
-        for l in range(self.height()):
-            self.put(hexcode, (l,y))
+        [r, g, b] = [int(c*255) for c in color[0:3]]
+        hexcode = "#%02x%02x%02x" % (r, g, b)
+        for he in range(self.height()):
+            self.put(hexcode, (he, y))
+
     def fillColorscale(self, colorscale):
         """ fills the image with a Colorscale gradient """
         if self.width() >= self.height():
             for x in range(self.width()):
-#                print('_', x, x/(self.width()-1), colorscale.valuesToColor(x/(self.width()-1)))
+                # print('_', x, x/(self.width()-1), colorscale.valuesToColor(x/(self.width()-1)))
                 self.vline(x, colorscale.valuesToColor(x/(self.width()-1)))
         else:
             for y in range(self.height()):
                 self.hline(y, colorscale.valuesToColor(y/(self.height()-1)))
-            
 
-            
-            
-            
 
 class Colorscale:
     """
     This class handles the color scales.
     """
 
     def __init__(self, colors=None, space='rgb', invert=False):
-        """ colors a list of colors in the format [[1,0,0], [1,1,0.5], [0,1,0]] """
-        self.colorsDefault = np.array([[1,0,0], [1,1,0.5], [0,1,0]])
+        """
+        Colors a list of colors in the format [[1,0,0], [1,1,0.5], [0,1,0]]
+        """
+        self.colorsDefault = np.array([[1, 0, 0], [1, 1, 0.5], [0, 1, 0]])
         self.space = space.lower()
         self.invert = False
         if isinstance(colors, str):
             # for example 'jet', 'inferno', etc.
             self.colors = colors
         else:
             if colors is None:
                 self.colors = self.colorsDefault
             else:
-                # overrides spaceInput if last element of colors is a string (for example 'hls')
+                # overrides spaceInput if last element of colors is a string
+                # (for example 'hls')
                 if isinstance(colors[-1], str):
                     self.space = colors[-1].lower()
                     colors = colors[:-1]
                 self.colors = np.array(colors)
         if invert:
             self.inverseScale()
 
     def __str__(self):
         return str(self.colors)
-    
+
     def GUIdefaults(config='', **newGraphKwargs):
         from grapa.graph import Graph
         graph = Graph('', **newGraphKwargs)
         out = []
         # retrieve colorscales from config
         try:
             kw = 'gui_colorscale'
@@ -131,16 +138,16 @@
             for key in keys:
                 if len(key) < len(kw) or key[:len(kw)] != kw:
                     del attr[key]
             keys = list(attr.keys())
             keys.sort()
             vals = []
             for key in keys:
-                val = stringToVariable(attr[key])
-                vals.append(stringToVariable(attr[key]))
+                val = strToVar(attr[key])
+                vals.append(strToVar(attr[key]))
         except Exception as e:
             print('Exception', e)
             vals = []
         # process colorscales and return Colorscales objects
         if vals != []:
             if not isinstance(vals, list):
                 vals = [vals]
@@ -150,29 +157,30 @@
                         out.append(Colorscale(np.array(val[:-1]), space=val[-1]))
                     else:
                         out.append(Colorscale(np.array(val)))
                 elif isinstance(val, str):
                     try:
                         plt.get_cmap(val, 1)
                         out.append(Colorscale(val))
-                    except ValueError as e:
-                        #print('Exception in Colorscale with keyword', val, e)
+                    except ValueError:
+                        # print('Exception in Colorscale with keyword', val, e)
                         pass
                 else:
-                    print('WARNING when loading default GUI colorscales: cannot interpret element', val)
+                    print('WARNING when loading default GUI colorscales:',
+                          'cannot interpret element', val)
             if len(out) > 0:
                 return out
         out = []
-        out.append(Colorscale(np.array([[1,0,0], [1,1,0.5], [0,1,0]])))
-        out.append(Colorscale(np.array([[1,0.3,0], [0.7,0,0.7], [0,0.3,1]])))
-        out.append(Colorscale(np.array([[1,0.43,0], [0,0,1]]))) # ThW admittance colorscale
-        out.append(Colorscale(np.array([[0.91,0.25,1], [1.09,0.75,1]]), space='hls'))
-        out.append(Colorscale(np.array([[0.70,0.25,1], [0.50,0.75,1]]), space='hls'))
-        out.append(Colorscale(np.array([[1,0,1], [1,0.5,1], [0.5,0.75,1]]), space='hls'))
-        keys =  ['inferno', 'gnuplot2', 'viridis']
+        out.append(Colorscale(np.array([[1, 0, 0], [1, 1, 0.5], [0, 1, 0]])))
+        out.append(Colorscale(np.array([[1, 0.3, 0], [0.7, 0, 0.7], [0, 0.3, 1]])))
+        out.append(Colorscale(np.array([[1, 0.43, 0], [0, 0, 1]])))  # ThW admittance colorscale
+        out.append(Colorscale(np.array([[0.91, 0.25, 1], [1.09, 0.75, 1]]), space='hls'))
+        out.append(Colorscale(np.array([[0.70, 0.25, 1], [0.50, 0.75, 1]]), space='hls'))
+        out.append(Colorscale(np.array([[1, 0, 1], [1, 0.5, 1], [0.5, 0.75, 1]]), space='hls'))
+        keys = ['inferno', 'gnuplot2', 'viridis']
         for key in keys:
             try:
                 plt.get_cmap(key, 1)
                 out.append(Colorscale(key))
             except ValueError:
                 pass
         return out
@@ -185,64 +193,65 @@
 
     def getColorScale(self):
         if self.space != 'rgb':
             return list([list(o) for o in self.colors]) + [self.space]
         return self.colors
 
     def valuesToColor(self, values, spaceOut='rgb', avoidWhite=True):
-        """ Return the color corresponding to a value.
-        values is a value np.array([value0, value1, value3, etc.]), with valuesN being between 0 and 1
+        """
+        Return the color corresponding to a value.
+        values is a value np.array([value0, value1, value3, etc.]), with
+        valuesN being between 0 and 1
         """
         spaceOut = spaceOut.lower()
         avoidWhiteParam = 0.85
         if is_number(values):
-            return list(self.valuesToColor([values], spaceOut=spaceOut, avoidWhite=avoidWhite)[0])
+            return list(self.valuesToColor([values], spaceOut=spaceOut,
+                                           avoidWhite=avoidWhite)[0])
         if not isinstance(values, np.ndarray):
             values = np.array(values)
         # from here we know values is an np.array
-        # if predefined matplotlib colorsmap (input was a colormap name str, ie. 'inferno', etc)
+        # if predefined matplotlib colorsmap (input was a colormap name str,
+        # ie. 'inferno', etc)
         if isinstance(self.colors, str):
-            col = plt.get_cmap(self.colors, 255) #, len(values)
+            col = plt.get_cmap(self.colors, 255)  # , len(values)
             if self.invert:
                 values = 1 - values
             # check if colorscale ends with white
             if avoidWhite:
-                if (list(col(0.0))[0:3] == [1,1,1]):
+                if (list(col(0.0))[0:3] == [1, 1, 1]):
                     values = avoidWhiteParam * values + (1-avoidWhiteParam)
-                if (list(col(1.0))[0:3] == [1,1,1]):
+                if (list(col(1.0))[0:3] == [1, 1, 1]):
                     values = avoidWhiteParam * values
             out = [list(o) for o in col(values)]
             if spaceOut != 'rgb':
                 out = [Color(o, 'rgb').get(spaceOut) for o in out]
         else:
-            # normalize: colormap spaced by 1 every color, values scaled [0, nb(color)]
+            # normalize: colormap spaced by 1 every color, values scaled
+            # [0, nb(color)]
             _3o4 = 4 if min([len(c) for c in self.colors]) > 3 else 3
             values *= (len(self.colors) - 1)
             i0 = np.floor(values).astype('int')
-            i1 = np.ceil (values).astype('int')
+            i1 = np.ceil(values).astype('int')
             if avoidWhite:
-                if (self.colors[0][:3]  == [1,1,1]).all():
+                if (self.colors[0][:3] == [1, 1, 1]).all():
                     values = avoidWhiteParam * values + (1-avoidWhiteParam)*(len(self.colors)-1)
-                if (self.colors[-1][:3] == [1,1,1]).all():
+                if (self.colors[-1][:3] == [1, 1, 1]).all():
                     values = avoidWhiteParam * values
             out = [0] * len(values)
-            for i in range(len(values)): # there iscertainly a smarter way to program this than a loop
-                if i0[i] == i1[i]: # if values[i] is integer
+            # there iscertainly a smarter way to program this than a loop
+            for i in range(len(values)):
+                if i0[i] == i1[i]:  # if values[i] is integer
                     out[i] = self.colors[i0[i]][0:_3o4]
-                else: # interpolate
+                else:  # interpolate
                     out[i] = self.colors[i0[i]][0:_3o4] * (float(i1[i])-values[i]) + self.colors[i1[i]][0:_3o4] * (values[i]-float(i0[i]))
                 out[i] = list(out[i])
             if spaceOut != self.space:
                 out = [Color(o, self.space).get(spaceOut) for o in out]
         return out
 
     def cmap(self, nbins=256, avoidWhite=False):
         from matplotlib.colors import LinearSegmentedColormap
         val = np.linspace(0, 1, nbins)
         colors = self.valuesToColor(val, avoidWhite=avoidWhite)
-        cm =  LinearSegmentedColormap.from_list('custom_cmap', colors, N=nbins)
+        cm = LinearSegmentedColormap.from_list('custom_cmap', colors, N=nbins)
         return cm
-        
-        
-        
-    
-
```

### Comparing `grapa-0.5.4.8/grapa/config.txt` & `grapa-0.6.1.0/grapa/config.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/config_anch.txt` & `grapa-0.6.1.0/grapa/config_anch.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/config_default.txt` & `grapa-0.6.1.0/grapa/config_default.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/curve.py` & `grapa-0.6.1.0/grapa/curve.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,62 +1,63 @@
 # -*- coding: utf-8 -*-
 
 """
 Created on Fri Jul 15 15:46:13 2016
 
 @author: Romain Carron
-Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain
+Carron
 """
 
 import numpy as np
 import warnings
 import inspect
 
-from grapa.mathModule import is_number
+from grapa.gui.GUIFuncGUI import FuncGUI
 
 
 class Curve:
 
     CURVE = 'Curve'
 
     NMTOEV = 1239.5
     LINESTYLEHIDE = ['none', 'None', None]
 
-    def __init__ (self, Curve, attributes, silent=True):
+    def __init__(self, Curve, attributes, silent=True):
         self.silent = silent
         self.data = np.array([])
         self.attributes = {}
         # add data
         if isinstance(Curve, (np.ndarray, np.generic)):
             self.data = Curve
         else:
             self.data = np.array(Curve)
-        if self.data.shape[0] < 2 :
+        if self.data.shape[0] < 2:
             self.data = self.data.reshape((2, len(self.data)))
-            print ('WARNING class Curve: data Curve need to contain at least 2 columns')
-            print ('   Shape of Curve:', self.data.shape)
+            print('WARNING class Curve: data Curve need to contain at least 2',
+                  'columns. Shape of Curve:', self.data.shape)
         # clean nan pairs at end of data
         iMax = self.data.shape[1]
-        for i in range(self.data.shape[1]-1, 0, -1): # loop down to 1 only, not 0
-            if np.isnan(self.data[:,i]).all():
+        # loop down to 1 only, not 0
+        for i in range(self.data.shape[1]-1, 0, -1):
+            if np.isnan(self.data[:, i]).all():
                 iMax -= 1
             else:
                 break
         if iMax < self.data.shape[1]:
-            self.data = self.data[:,:iMax]
+            self.data = self.data[:, :iMax]
         # add attributes
         if isinstance(attributes, dict):
             self.update(attributes)
         else:
-            print ('ERROR class Curve: attributes need to be of class dict.')
-
+            print('ERROR class Curve: attributes need to be of class dict.')
 
     # methods related to GUI
     @classmethod
-    def classNameGUI(cls): # can be overridden, see CurveArrhenius
+    def classNameGUI(cls):  # can be overridden, see CurveArrhenius
         return cls.CURVE
 
     def funcListGUI(self, **kwargs):
         """
         Fills in the Curve actions specific to the Curve type. Syntax:
         [func,
          'Button text',
@@ -66,154 +67,165 @@
          [dictFieldAttributes, {}, ...]] (optional)
         By default returns quick modifs for offset and muloffset (if already
         set), and a help for some plot types (errorbar, scatter)
         In principle the current Graph and the position of self in the Graph
         can be accessed through kwargs['graph'] and kwargs['graph_i']
         """
         out = []
-        # by default the offset and muloffset can be directly accessed if are already set
-        typeplot = self.getAttribute('type')
+        # offset and muloffset can be directly accessed if already set
+        typeplot = self.attr('type')
         try:
             graph = kwargs['graph']
             c = kwargs['graph_i']
-            if typeplot == 'errorbar': # assist functions for type errorbar
+            if typeplot == 'errorbar':  # helper for type errorbar
                 out += self.funcListGUI_errorbar(graph, c)
-            elif typeplot == 'scatter': # assist function for type scatter
+            elif typeplot == 'scatter':  # helper for type scatter
                 out += self.funcListGUI_scatter(graph, c)
-            elif typeplot.startswith('fill'): # assist function for type fill
+            elif typeplot.startswith('fill'):  # helper for type fill
                 out += self.funcListGUI_fill(graph, c)
-            elif typeplot.startswith('boxplot'): # assist function for type boxplot
+            elif typeplot.startswith('boxplot'):  # helper for type boxplot
                 out += self.funcListGUI_boxplot(graph, c)
         except Exception as e:
             print('Exception', type(e), 'in Curve.funcListGUI')
-        if self.getAttribute('offset', None) is not None or self.getAttribute('muloffset', None) is not None:
+        if (self.attr('offset', None) is not None
+                or self.attr('muloffset', None) is not None):
             from grapa.graph import Graph
             at = ['offset', 'muloffset']
-            values = {'offset': [], 'muloffset': []}
+            line = FuncGUI(self.updateValuesDictkeys, 'Modify screen offsets',
+                           hiddenvars={'keys': at})
             for key in at:
-                for i in range(len(Graph.dataInfoKeysGraphData)):
-                    if Graph.dataInfoKeysGraph[i] == key:
-                        values.update({key: Graph.dataInfoKeysGraphExalist[i]})
-                        break
-            out.append([self.updateValuesDictkeys, 'Modify screen offsets',
-                        at,
-                        [self.getAttribute(a) for a in at],
-                        {'keys': at},
-                        [{'field':'Combobox','values':values[a]} for a in at]])
+                vals = []
+                if key in Graph.dataInfoKeysGraph:
+                    i = Graph.dataInfoKeysGraph.index(key)
+                    vals = Graph.dataInfoKeysGraphExalist[i]
+                line.append(key, self.attr(key), widgetclass='Combobox',
+                            options={'values': vals})
+            out.append(line)
         return out
 
     def funcListGUI_errorbar(self, graph, c):
         out = []
         types = []
-        if c+1 < graph.length():
-            types.append(graph.curve(c+1).getAttribute('type'))
-        if c+2 < graph.length():
-            types.append(graph.curve(c+2).getAttribute('type'))
+        if c+1 < len(graph):
+            types.append(graph[c+1].attr('type'))
+        if c+2 < len(graph):
+            types.append(graph[c+2].attr('type'))
         xyerrOR = ''
         if len(types) > 0:
             choices = ['', 'errorbar_xerr', 'errorbar_yerr']
             labels = ['next Curves type: ('+str(c+1)+')']+['('+str(i)+')' for i in range(c+2, c+1+len(types))]
             fieldprops = [{'field': 'Combobox', 'values': choices}] * len(labels)
-            out.append([self.updateNextCurvesScatter, 'Save', labels, types, {'graph': graph, 'graph_i': c}, fieldprops])
+            out.append([self.updateNextCurvesScatter, 'Save', labels, types,
+                        {'graph': graph, 'graph_i': c}, fieldprops])
             xyerrOR = 'OR '
-        out.append([self.updateValuesDictkeys, 'Save', [xyerrOR+'error values x', 'y'], [self.getAttribute('xerr'), self.getAttribute('yerr')], {'keys': ['xerr', 'yerr']}])
+        out.append([self.updateValuesDictkeys, 'Save',
+                    [xyerrOR+'error values x', 'y'],
+                    [self.attr('xerr'), self.attr('yerr')],
+                    {'keys': ['xerr', 'yerr']}])
         at = ['capsize', 'ecolor']
-        out.append([self.updateValuesDictkeys, 'Save', at, [self.getAttribute(a) for a in at], {'keys': at}])
+        out.append([self.updateValuesDictkeys, 'Save', at,
+                    [self.attr(a) for a in at], {'keys': at}])
         return out
 
     def funcListGUI_scatter(self, graph, c):
         out = []
         types = []
-        if c+1 < graph.length():
-            types.append(graph.curve(c+1).getAttribute('type'))
-        if c+2 < graph.length():
-            types.append(graph.curve(c+2).getAttribute('type'))
+        if c+1 < len(graph):
+            types.append(graph[c+1].attr('type'))
+        if c+2 < len(graph):
+            types.append(graph[c+2].attr('type'))
         if len(types) > 0:
             choices = ['', 'scatter_c', 'scatter_s']
             labels = ['next Curves type: ('+str(c+1)+')']+['('+str(i)+')' for i in range(c+2, c+1+len(types))]
-            fieldprops = [{'field':'Combobox', 'values':choices}] * len(labels)
-            out.append([self.updateNextCurvesScatter, 'Save', labels, types, {'graph': graph, 'graph_i': c}, fieldprops])
+            fieldprops = [{'field': 'Combobox', 'values': choices}] * len(labels)
+            out.append([self.updateNextCurvesScatter, 'Save', labels, types,
+                        {'graph': graph, 'graph_i': c}, fieldprops])
         keys = ['cmap', 'vminmax']
-        out.append([self.updateValuesDictkeys, 'Save', keys, [self.getAttribute(k) for k in keys], {'keys': keys}])
+        out.append([self.updateValuesDictkeys, 'Save', keys,
+                    [self.attr(k) for k in keys], {'keys': keys}])
         return out
 
     def funcListGUI_fill(self, graph, c):
         out = []
         at = ['fill', 'hatch', 'fill_padto0']
         at2 = list(at)
         at2[2] = 'pad to 0'
         out.append([self.updateValuesDictkeys, 'Save', at2,
-                    [self.getAttribute(a) for a in at], {'keys': at},
+                    [self.attr(a) for a in at], {'keys': at},
                     [{'field': 'Combobox', 'values': ['True', 'False']},
-                     {'field': 'Combobox', 'values': ['', '.', '+', '/', r'\\'], 'width': 7},
+                     {'field': 'Combobox',
+                      'values': ['', '.', '+', '/', r'\\'], 'width': 7},
                      {'field': 'Combobox', 'values': ['', 'True', 'False']}]])
         return out
 
     def funcListGUI_boxplot(self, graph, c):
         out = []
         at = ['boxplot_position']
         at2 = ['position']
         out.append([self.updateValuesDictkeys, 'Save', at2,
-                    [self.getAttribute(a) for a in at], {'keys': at},
+                    [self.attr(a) for a in at], {'keys': at},
                     [{}]])
-        at =  ['widths', 'notch', 'vert']
+        at = ['widths', 'notch', 'vert']
         out.append([self.updateValuesDictkeysGraph, 'Save', at,
-                    [self.getAttribute(a) for a in at],
-                    {'keys': at, 'graph': graph, 'alsoAttr': ['type'], 'alsoVals': ['boxplot']},
+                    [self.attr(a) for a in at],
+                    {'keys': at, 'graph': graph, 'alsoAttr': ['type'],
+                     'alsoVals': ['boxplot']},
                     [{},
                      {'field': 'Combobox', 'values': ['True', 'False']},
                      {'field': 'Combobox', 'values': ['True', 'False']}]])
         return out
 
     def updateNextCurvesScatter(self, *values, **kwargs):
         try:
             graph = kwargs['graph']
             c = kwargs['graph_i']
         except KeyError:
-            print('KeyError in Curve.updateNextCurvesScatter: "graph" or "graph_i" not provided in kwargs')
+            print('KeyError in Curve.updateNextCurvesScatter: "graph" or',
+                  '"graph_i" not provided in kwargs')
         for i in range(len(values)):
-            if c+i < graph.length():
-                graph.curve(c+1+i).update({'type': values[i]})
+            if c+i < len(graph):
+                graph[c+1+i].update({'type': values[i]})
         return True
 
-
+    # alterListGUI
     def alterListGUI(self):
         """
         Determines the possible curve visualisations. Syntax:
         ['GUI label', ['alter_x', 'alter_y'], 'semilogx']
         By default only Linear (ie. raw data) is provided
         """
         out = []
-        out.append(['Linear', ['',''], ''])
+        out.append(['no transform', ['', ''], ''])
         return out
 
-
     # Function related to Fits
     def updateFitParam(self, *param):
-        f = self.getAttribute('_fitFunc', '')
-        #print ('Curve update', param, 'f', f)
+        f = self.attr('_fitFunc', '')
+        # print ('Curve update', param, 'f', f)
         if f != '' and not self.attributeEqual('_popt'):
             if hasattr(self, f):
                 self.setY(getattr(self, f)(self.x(), *param))
                 self.update({'_popt': self.updateFitParamFormatPopt(f, param)})
                 return True
-            return 'ERROR Update fit parameter: No such fit function (',f,').'
-        return 'ERROR Update fit parameter: Empty parameter (_fitFunc:',f,', _popt:',self.getAttribute('_popt'),').'
+            return 'ERROR Update fit parameter: No such fit function (', f, ').'
+        return ('ERROR Update fit parameter: Empty parameter (_fitFunc:', f,
+                ', _popt:', self.attr('_popt'), ').')
+
     def updateFitParamFormatPopt(self, f, param):
-         # possibility to override in subclasses, esp. when handling of tet input is required.
-         # by default, assumes all numeric -> best stored in a np.array
+        # possibility to override in subclasses, esp. when handling of test
+        # input is required.
+        # by default, assumes all numeric -> best stored in a np.array
         return np.array(param)
 
-
     # more classical class methods
-    def getData(self) :
+    def getData(self):
         return self.data
 
-    def shape (self, idx=':') :
-        if idx == ':' :
+    def shape(self, idx=':'):
+        if idx == ':':
             return self.data.shape
         return self.data.shape[idx]
 
     def _fractionToFloat(self, frac_str):
         try:
             return float(frac_str)
         except ValueError:
@@ -223,75 +235,79 @@
     def x_offsets(self, **kwargs):
         """
         Same as x(), including the effect of offset and muloffset on output.
         """
         reserved = ['minmax', '0max']
         special = None
         x = self.x(**kwargs)
-        offset = self.getAttribute('offset', None)
+        offset = self.attr('offset', None)
         if offset is not None:
             o = offset[0] if isinstance(offset, list) else 0
             if isinstance(o, str):
                 if o in reserved:
                     special = o
                     o = 0
                 else:
                     o = self._fractionToFloat(o)
             x = x + o
-        muloffset = self.getAttribute('muloffset', None)
+        muloffset = self.attr('muloffset', None)
         if muloffset is not None:
             o = muloffset[0] if isinstance(muloffset, list) else 1
             if isinstance(o, str):
-                if o.replace(' ','') in reserved:
+                if o.replace(' ', '') in reserved:
                     special = o
                     o = 1
                 else:
                     o = self._fractionToFloat(o)
             x = x * o
         if special is not None:
             m, M = np.min(x), np.max(x)
             if special == 'minmax':
                 x = (x - m) / (M - m)
             elif special == '0max':
                 x = x / M
         return x
 
-    def x (self, index=np.nan, alter='', xyValue=None, errorIfxyMix=False, neutral=False):
+    def x(self, index=np.nan, alter='', xyValue=None, errorIfxyMix=False, neutral=False):
         """
         Returns the x data.
         index: range to the data.
         alter: possible alteration to the data (i.e. '', 'nmeV')
-        xyValue: provide [x, y] value pair to be alter-ed. x, y can be np.array.
-        errorIfxyMix: throw ValueError exception if alter value calculation requires both x and y components. Useful for transforming xlim and ylim, where x do not know y in advance.
+        xyValue: provide [x, y] value pair to be alter-ed. x, y can be np.array
+        errorIfxyMix: throw ValueError exception if alter value calculation
+            requires both x and y components. Useful for transforming xlim and
+            ylim, where x do not know y in advance.
         neutral: no use yet, introduced to keep same call arguments as self.y()
         """
         if alter != '':
             if alter == 'nmeV':
-                if xyValue is not None: # invert order of xyValue, to help for graph xlim and ylim
+                # invert order of xyValue, to help for graph xlim and ylim
+                if xyValue is not None:
                     xyValue = np.array(xyValue)
                     if len(xyValue.shape) > 1:
-                        xyValue = [xyValue[0,::-1], xyValue[1,::-1]]
+                        xyValue = [xyValue[0, ::-1], xyValue[1, ::-1]]
                 with warnings.catch_warnings():
                     warnings.simplefilter('ignore')
                     return Curve.NMTOEV / self.x(index, xyValue=xyValue)
             elif alter == 'nmcm-1':
-                if xyValue is not None: # invert order of xyValue, to help for graph xlim and ylim
+                # invert order of xyValue, to help for graph xlim and ylim
+                if xyValue is not None:
                     xyValue = np.array(xyValue)
                     if len(xyValue.shape) > 1:
-                        xyValue = [xyValue[0,::-1], xyValue[1,::-1]]
+                        xyValue = [xyValue[0, ::-1], xyValue[1, ::-1]]
                 with warnings.catch_warnings():
                     warnings.simplefilter('ignore')
                     return 1e7 / self.x(index, xyValue=xyValue)
             elif alter == 'MCAkeV':
-                offset = self.getAttribute('_MCA_CtokeV_offset', default=0)
-                mult   = self.getAttribute('_MCA_CtokeV_mult',   default=1)
+                offset = self.attr('_MCA_CtokeV_offset', default=0)
+                mult = self.attr('_MCA_CtokeV_mult', default=1)
                 return mult * (self.x(index, xyValue=xyValue) + offset)
             elif alter == 'SIMSdepth':
-                offset = self.getAttribute('_SIMSdepth_offset', default=0)
-                mult   = self.getAttribute('_SIMSdepth_mult',   default=1)
+                offset = self.attr('_SIMSdepth_offset', default=0)
+                mult = self.attr('_SIMSdepth_mult', default=1)
                 return mult * (self.x(index, xyValue=xyValue) + offset)
             elif alter == 'y':
                 try:
                     xyValue = xyValue[::-1]
                 except TypeError:
                     pass
                 # print('x xyValue', xyValue, self.y(index, xyValue=xyValue))
@@ -302,78 +318,85 @@
                     module_name = 'grapa.datatypes.' + split[0][0].lower() + split[0][1:]
                     import importlib
                     try:
                         mod = importlib.import_module(module_name)
                         met = getattr(getattr(mod, split[0]), split[1])
                         return met(self, index=index, xyValue=xyValue)
                     except ImportError as e:
-                        print('ERROR Curve.x Exception raised during module import', module_name+':')
+                        print('ERROR Curve.x Exception raised during module',
+                              'import', module_name, ':')
                         print(e)
                 else:
-                    print('Error Curve.x: cannot identify alter keyword ('+alter+').')
+                    print('Error Curve.x: cannot identify alter keyword ('
+                          + alter + ').')
 
         # alter might be used by subclasses
         val = self.data if xyValue is None else np.array(xyValue)
-        if len(val.shape) > 1 :
-            if np.isnan(index).any() :
-                return val[0,:]
-            return val[0,index]
+        if len(val.shape) > 1:
+            if np.isnan(index).any():
+                return val[0, :]
+            return val[0, index]
         return val[0]
 
     def y_offsets(self, **kwargs):
         """
         Same as y(), including the effect of offset and muloffset on output.
         """
         reserved = ['minmax', '0max']
         special = None
         y = self.y(**kwargs)
-        offset = self.getAttribute('offset', None)
+        offset = self.attr('offset', None)
         if offset is not None:
             o = offset[1] if isinstance(offset, list) else offset
             if isinstance(o, str):
                 if o in reserved:
                     special = o
                     o = 0
                 else:
                     o = self._fractionToFloat(o)
             y = y + o
-        muloffset = self.getAttribute('muloffset', None)
+        muloffset = self.attr('muloffset', None)
         if muloffset is not None:
             o = muloffset[1] if isinstance(muloffset, list) else muloffset
             if isinstance(o, str):
-                if o.replace(' ','') in reserved:
+                if o.replace(' ', '') in reserved:
                     special = o
                     o = 1
                 else:
                     o = self._fractionToFloat(o)
             y = y * o
         if special is not None:
             m, M = np.min(y), np.max(y)
             if special == 'minmax':
                 y = (y - m) / (M - m)
             elif special == '0max':
                 y = y / M
         return y
 
-    def y (self, index=np.nan, alter='', xyValue=None, errorIfxyMix=False, neutral=False) :
+    def y(self, index=np.nan, alter='', xyValue=None, errorIfxyMix=False, neutral=False):
         """
         Returns the y data.
         index: range to the data.
         alter: possible alteration to the data (i.e. '', 'log10abs', 'tauc')
-        xyValue: provide [x, y] value pair to be alter-ed. x, y can be np.array.
-        errorIfxyMix: throw ValueError exception if alter value calculation requires both x and y components. Useful for transforming xlim and ylim, where x do not know y in advance.
-        neutral: additional parameter. If True prevent Jsc substraction for CurveJV.
+        xyValue: provide [x, y] value pair to be alter-ed. x, y can be np.array
+        errorIfxyMix: throw ValueError exception if alter value calculation
+            requires both x and y components. Useful for transforming xlim and
+            ylim, where x do not know y in advance.
+        neutral: additional parameter. If True prevent Jsc substraction for
+            CurveJV.
         """
-        # if some alteration required: make operation on data requested by itself, without operation
+
+        # if some alteration required: make operation on data requested by
+        # itself, without operation
         if alter != '':
             if alter == 'log10abs':
-                jsc = self.getAttribute ('Jsc') if self.getAttribute ('Jsc') != '' and not neutral else 0
+                jsc = self.attr('Jsc') if self.attr('Jsc') != '' and not neutral else 0
                 return np.log10(np.abs(self.y(index, xyValue=xyValue) + jsc))
             elif alter == 'abs':
-                jsc = self.getAttribute ('Jsc') if self.getAttribute ('Jsc') != '' and not neutral else 0
+                jsc = self.attr('Jsc') if self.attr('Jsc') != '' and not neutral else 0
                 return np.abs(self.y(index, xyValue=xyValue) + jsc)
             elif alter == 'abs0':
                 return np.abs(self.y(index, xyValue=xyValue))
             elif alter == 'tauc':
                 if errorIfxyMix:
                     return ValueError
                 return np.power(self.y(index, xyValue=xyValue) * self.x(index, alter='nmeV', xyValue=xyValue), 2)
@@ -381,15 +404,14 @@
                 if errorIfxyMix:
                     return ValueError
                 return np.power(np.log(1-self.y(index, xyValue=xyValue)) * self.x(index, alter='nmeV', xyValue=xyValue), 2)
             elif alter == 'normalized':
                 out = self.y(index, xyValue=xyValue)
                 return out / np.max(out)
             elif alter == 'x':
-                #print('y xyValue', xyValue[::-1], self.x(index, xyValue=xyValue))
                 try:
                     xyValue = xyValue[::-1]
                 except TypeError:
                     pass
                 return self.x(index, xyValue=xyValue)
             elif alter != '':
                 split = alter.split('.')
@@ -397,195 +419,212 @@
                     import importlib
                     module_name = 'grapa.datatypes.' + split[0][0].lower() + split[0][1:]
                     try:
                         mod = importlib.import_module(module_name)
                         met = getattr(getattr(mod, split[0]), split[1])
                         return met(self, index=index, xyValue=xyValue)
                     except ImportError as e:
-                        print('ERROR Curve.y Exception raised during module import', module_name+':')
+                        print('ERROR Curve.y Exception raised during module',
+                              'import', module_name+':')
                         print(e)
                 else:
                     if alter != 'idle':
-                        print('Error Curve.y: cannot identify alter keyword ('+alter+').')
-#        elif alter == '-dCdlnf':
-#            from mathModule import derivative
-#            return - derivative(np.log(self.x(index, xyValue=xyValue)), self.y(index, xyValue=xyValue))
-
+                        print('Error Curve.y: cannot identify alter keyword ('
+                              + alter + ').')
         # return (subset of) data
         val = self.data if xyValue is None else np.array(xyValue)
-        if len(val.shape) > 1 :
-            if np.isnan(index).any() :
-                return val[1,:]
-            return val[1,index]
+        if len(val.shape) > 1:
+            if np.isnan(index).any():
+                return val[1, :]
+            return val[1, index]
         return val[1]
 
-    def setX (self, x, index=np.nan) :
-        """ Set new value for the x data. Index can be provided (self.data[0,index] = x). """
-        if np.isnan(index) :
-            self.data[0,:] = x
-        else :
-            self.data[0,index] = x
-
-    def setY (self, y, index=np.nan):
-        """ Set new value for the y data. Index can be provided (self.data[1,index] = y). """
-        if len(self.shape()) > 1 :
-            if np.isnan(index) :
-                self.data[1,:] = y
-            else :
-                self.data[1,index] = y
-        else :
+    def setX(self, x, index=np.nan):
+        """
+        Set new value for the x data.
+        Index can be provided (self.data[0,index] = x).
+        """
+        if np.isnan(index):
+            self.data[0, :] = x
+        else:
+            self.data[0, index] = x
+
+    def setY(self, y, index=np.nan):
+        """
+        Set new value for the y data.
+        Index can be provided (self.data[1,index] = y).
+        """
+        if len(self.shape()) > 1:
+            if np.isnan(index):
+                self.data[1, :] = y
+            else:
+                self.data[1, index] = y
+        else:
             self.data[1] = y
 
     def appendPoints(self, xSeries, ySeries):
         xSeries, ySeries = np.array(xSeries), np.array(ySeries)
         if len(xSeries) == 0:
             print('Curve appendPoints: empty xSeries provided.')
             return False
         if len(ySeries) != len(xSeries):
-            print('Curve appendPoints: cannot handle different data series lengths.')
+            print('Curve appendPoints: cannot handle data series with',
+                  'different lengths.')
             return False
         self.data = np.append(self.data, np.array([xSeries, ySeries]), axis=1)
         return True
 
     def attr(self, key, default=''):
-        """ Shorter alias to getAttribute. """
-        return self.getAttribute(key, default=default)
-    def getAttribute (self, key, default='') :
         """ Getter of attribute """
-        if key.lower() in self.attributes :
+        if key.lower() in self.attributes:
             return self.attributes[key.lower()]
         return default
 
+    def getAttribute(self, key, default=''):
+        """ Legacy getter of attribute """
+        return self.attr(key, default=default)
+
     def getAttributes(self, keysList=None):
         """ Returns all attributes, or a subset with keys given in keyList """
         if isinstance(keysList, list):
             out = {}
             for key in keysList:
-                out.update({key: self.getAttribute(key)})
+                out.update({key: self.attr(key)})
             return out
         return self.attributes
 
-    def attributeEqual(self, key, value=''): # value='' must be same as the default parameter of method getAttribute
+    def attributeEqual(self, key, value=''):
         """
         Check if attribute 'key' has a certain value
-        The value can be left empty: check if getAttribute(key) returns the
+        The value can be left empty: check if attr(key) returns the
         default value.
         """
-        val = self.getAttribute(key)
+        # value='' must be same as the default parameter of method getAttribute
+        val = self.attr(key)
         if isinstance(val, type(value)) and val == value:
             return True
         return False
 
     def update(self, attributes):
-        for key in attributes :
+        """ Updates attributes. a dict must be provided """
+        for key in attributes:
             k = key.lower()
             if not isinstance(attributes[key], str) or attributes[key] != '':
-                self.attributes.update ({k.strip(' =:\t\n').replace('',''): attributes[key]})
-            elif k in self.attributes :
+                k_ = k.strip(' =:\t\n').replace('', '')
+                self.attributes.update({k_: attributes[key]})
+            elif k in self.attributes:
                 del self.attributes[k]
 
     def updateValuesDictkeys(self, *args, **kwargs):
         """
         Performs update({key1: value1, key2: value2, ...}) with
         arguments value1, value2, ... , (*args) and
         kwargument keys=['key1', 'key2', ...]
         """
         if 'keys' not in kwargs:
-            print('Error Curve updateValuesDictkeys: "keys" key must be provided, must be a list of keys corresponding to the values provided in *args.')
+            print('Error Curve updateValuesDictkeys: "keys" key must be',
+                  'provided, must be a list of keys corresponding to the',
+                  'values provided in *args.')
             return False
         if len(kwargs['keys']) != len(args):
-            print('WARNING Curve updateValuesDictkeys: len of list "keys" argument must match the number of provided values (',len(args),' args provided, ',len(kwargs['keys']),' keys).')
+            print('WARNING Curve updateValuesDictkeys: len of list "keys"',
+                  'argument must match the number of provided values (',
+                  len(args), 'args provided,', len(kwargs['keys']), 'keys).')
         lenmax = min(len(kwargs['keys']), len(args))
         for i in range(lenmax):
             self.update({kwargs['keys'][i]: args[i]})
         return True
 
     def updateValuesDictkeysGraph(self, *args, keys=None, graph=None, alsoAttr=None, alsoVals=None, **kwargs):
         """
         similar as updateValuesDictkeys, for all curves inside a given graph
         """
         from grapa.graph import Graph
         if not isinstance(keys, list):
-            print('Error Curve updateValuesDictkeysGraph: "keys" key must be provided, must be a list of keys corresponding to the values provided in *args.')
+            print('Error Curve updateValuesDictkeysGraph: "keys" key must be',
+                  'provided, must be a list of keys corresponding to the',
+                  'values provided in *args.')
             return False
         if not isinstance(graph, Graph):
-            print('Error Curve updateValuesDictkeysGraph: "graph" key must be provided, must be a Graph object.')
+            print('Error Curve updateValuesDictkeysGraph: "graph" key must be',
+                  'provided, must be a Graph object.')
             return False
         if not isinstance(alsoAttr, list):
-            print('Error Curve updateValuesDictkeysGraph: "alsoAttr" key must be provided, must be a list of attributes.')
+            print('Error Curve updateValuesDictkeysGraph: "alsoAttr" key must',
+                  'be provided, must be a list of attributes.')
             return False
         if not isinstance(alsoVals, list):
-            print('Error Curve updateValuesDictkeysGraph: "alsoVals" key must be provided, must be a list of values matching alsoAttr.')
+            print('Error Curve updateValuesDictkeysGraph: "alsoVals" key must',
+                  'be provided, must be a list of values matching alsoAttr.')
             return False
         while len(alsoVals) < len(alsoAttr):
             alsoVals.append('')
         for curve in graph.iterCurves():
             flag = True
             for i in range(len(alsoAttr)):
-                if not curve.getAttribute(alsoAttr[i]) == alsoVals[i]:
+                if not curve.attr(alsoAttr[i]) == alsoVals[i]:
                     flag = False
             if flag:
                 curve.updateValuesDictkeys(*args, keys=keys)
         return True
 
-
-
-
-    def delete (self, key) :
+    def delete(self, key):
         out = {}
-        if key.lower() in self.attributes :
-            out.update({key: self.getAttribute('key')})
+        if key.lower() in self.attributes:
+            out.update({key: self.attr('key')})
             del self.attributes[key.lower()]
         return out
 
     def swapShowHide(self):
         self.update({'linestyle': '' if self.isHidden() else 'none'})
         return True
-    def isHidden(self):
-        return True if self.getAttribute('linestyle') in Curve.LINESTYLEHIDE else False
-
 
+    def isHidden(self):
+        return True if self.attr('linestyle') in Curve.LINESTYLEHIDE else False
 
     def castCurveListGUI(self, onlyDifferent=True):
         curveTypes = [] if onlyDifferent else [Curve]
         curveTypes += Curve.__subclasses__()
         out = []
         for c in curveTypes:
             if not onlyDifferent or not isinstance(self, c):
                 name = c.classNameGUI()
                 out.append([name, c.__name__, c])
         key = [x[0] for x in out]
         for i in range(len(key)-2, -1, -1):
             if key[i] in key[:i]:
                 del key[i]
                 del out[i]
-        out = [x for (y,x) in sorted(zip(key, out), key=lambda pair: pair[0])] # sort list by name
-#        out.append()
+        # sort list by name
+        out = [x for (y, x) in sorted(zip(key, out), key=lambda pair: pair[0])]
         return out
 
     def castCurve(self, newTypeGUI):
         if newTypeGUI == 'Curve':
             newTypeGUI = 'Curve'
         if type(self).__name__ == newTypeGUI:
             return self
         curveTypes = self.castCurveListGUI()
         for typ_ in curveTypes:
             if newTypeGUI == 'Curve':
-                return Curve(self.data, attributes=self.getAttributes(), silent=True)
+                return Curve(self.data, attributes=self.getAttributes(),
+                             silent=True)
                 break
-            if newTypeGUI == typ_[0] or newTypeGUI == typ_[1] or newTypeGUI.replace(' ','') == typ_[1]:
+            if (newTypeGUI == typ_[0] or newTypeGUI == typ_[1]
+                    or newTypeGUI.replace(' ', '') == typ_[1]):
                 if isinstance(self, typ_[2]):
-                    print ('Curve.castCurve: already that type!')
+                    print('Curve.castCurve: already that type!')
                 else:
-                    return typ_[2](self.data, attributes=self.getAttributes(), silent=True)
+                    return typ_[2](self.data, attributes=self.getAttributes(),
+                                   silent=True)
                 break
-        print('Curve.castCurve: Cannot understand new type:', newTypeGUI, '(possible types:', [key for key in curveTypes],')')
+        print('Curve.castCurve: Cannot understand new type:', newTypeGUI,
+              '(possible types:', [key for key in curveTypes], ')')
         return False
 
-
     def selectData(self, xlim=None, ylim=None, alter='', offsets=False, data=None):
         """
         Returns slices of the data self.x(), self.y() which satisfy
         xlim[0] <= x <= xlim[1], and ylim[0] <= y <= ylim[1]
         alter: '', or ['', 'abs']. Affect the test AND the output.
         offset: if True, calls x and y are affected by offset and muloffset
         data [xSeries, ySeries] can be provided. Helps the code of calling
@@ -611,15 +650,14 @@
         for i in range(len(mask)):
             if x[i] < xlim[0] or x[i] > xlim[1]:
                 mask[i] = False
             if y[i] < ylim[0] or y[i] > ylim[1]:
                 mask[i] = False
         return x[mask], y[mask]
 
-
     def getPointClosestToXY(self, x, y, alter='', offsets=False):
         """
         Return the data point closest to the x,y values.
         Priority on x, compares y only if equal distance on x
         """
         if isinstance(alter, str):
             alter = ['', alter]
@@ -636,36 +674,38 @@
             datay = self.y_offsets(index=idx, alter=alter[1])
             absM = np.abs(datay - y)
             idX = np.where(absM == np.min(absM))
             if len(idX) == 0:
                 idx = idx[0]
             elif len(idX) == 1:
                 idx = idx[idX[0]]
-            else: # equally close in x and y -> returns first datapoint found
+            else:  # equally close in x and y -> returns first datapoint found
                 idx = idx[idX[0]]
         idxOut = idx if len(idx) <= 1 else idx[0]
         if offsets:
-            return self.x_offsets(index=idx)[0], self.y_offsets(index=idx)[0], idxOut # no alter, but offset for the return value
-        return self.x(index=idx)[0], self.y(index=idx)[0], idxOut # no alter, no offsets for the return value
+            # no alter, but offset for the return value
+            return self.x_offsets(index=idx)[0], self.y_offsets(index=idx)[0], idxOut
+        # no alter, no offsets for the return value
+        return self.x(index=idx)[0], self.y(index=idx)[0], idxOut
 
     def getDataCustomPickerXY(self, idx, alter='', strDescription=False):
         """
         Given an index in the Curve data, returns a modified data which has
         some sense to the user. Is overloaded in some child Curve classes, see
         for example CurveCf
         If strDescription is True, then returns a string which describes what
         this method is doing.
         """
         if strDescription:
             return '(x,y) data with offset and transform'
         if isinstance(alter, str):
             alter = ['', alter]
         attr = {}
-        return self.x_offsets(index=idx, alter=alter[0]), self.y_offsets(index=idx, alter=alter[1]), attr
-
+        return (self.x_offsets(index=idx, alter=alter[0]),
+                self.y_offsets(index=idx, alter=alter[1]), attr)
 
     def printHelpFunc(self, func, leadingstrings=None):
         """ prints the docstring of a function """
         if leadingstrings is None:
             leadingstrings = ['- ', '  ']
         a, idx = 0, None
         for line in func.__doc__.split('\n'):
@@ -674,147 +714,165 @@
             if idx is None:
                 idx = len(line) - len(line.lstrip(' '))
             if len(line) == idx:
                 continue
             print(leadingstrings[a] + line[idx:])
             a = 1
 
-
-
     # some arithmetics
     def __add__(self, other, sub=False, interpolate=-1, offsets=False, operator='add'):
         """
         Addition operation, element-wise or interpolated along x data
         interpolate: interpolate, or not the data on the x axis
             0: no interpolation, only consider y() values
-            1: interpolation, x are the points contained in self.x() or in other.x()
-            2: interpolation, x are the points of self.x(), restricted to min&max of other.x()
+            1: interpolation, x are the points contained in self.x() or in
+               other.x()
+            2: interpolation, x are the points of self.x(), restricted to
+               min&max of other.x()
             -1: 0 if same y values (gain time), otherwise 1
         With sub=True, performs substraction
         offsets: if True, adds Curves after computing offsets and muloffsets.
             If not adds on the raw data.
-        operator: 'add', 'sub', 'mul', 'div'. sub=True is a shortcut for operatore='sub'. Overriden by sub=True argument.
+        operator: 'add', 'sub', 'mul', 'div'. sub=True is a shortcut for
+            operatore='sub'. Overriden by sub=True argument.
         """
         def op(x, y, operator):
             if operator == 'sub':
                 return x - y
             if operator == 'mul':
                 return x * y
             if operator == 'div':
                 return x / y
             if operator == 'pow':
                 return x ** y
             if operator != 'add':
-                print('WARNING Curve.__add__: unexpected operator argument(' + operator + ').')
+                print('WARNING Curve.__add__: unexpected operator argument('
+                      + operator + ').')
             return x + y
 
         if sub == True:
             operator = 'sub'
         selfx = self.x_offsets if offsets else self.x
         selfy = self.y_offsets if offsets else self.y
-        if not isinstance(other, Curve): # add someting/number to a Curve
-            out = Curve([selfx(), op(selfy(), other, operator)], self.getAttributes())
-            if offsets: # remove offset information if use it during calculation
+        if not isinstance(other, Curve):  # add someting/number to a Curve
+            out = Curve([selfx(), op(selfy(), other, operator)],
+                        self.getAttributes())
+            # remove offset information if use it during calculation
+            if offsets:
                 out.update({'offset': '', 'muloffset': ''})
             out = out.castCurve(self.classNameGUI())
-            return out # cast type
+            return out  # cast type
         # curve1 is a Curve
         otherx = other.x_offsets if offsets else other.x
         othery = other.y_offsets if offsets else other.y
         # default mode -1: check if can gain time (avoid interpolating)
         r = range(0, min(len(selfy()), len(othery())))
         if interpolate == -1:
             interpolate = 0 if np.array_equal(selfx(index=r), otherx(index=r)) else 1
         # avoiding interpolation
         if not interpolate:
             le = min(len(selfy()), len(othery()))
             r = range(0, le)
             if le < len(selfy()):
-                print('WARNING Curve __add__: Curves not same lengths, clipped result to shortest (',len(selfy()),',',len(othery()),')')
+                print('WARNING Curve __add__: Curves not same lengths, clipped',
+                      'result to shortest (', len(selfy()), ',', len(othery()),
+                      ')')
             if not np.array_equal(selfx(index=r), otherx(index=r)):
-                print('WARNING Curve __add__ ('+operator+'): Curves not same x axis values. Consider interpolation (interpolate=1).')
+                print('WARNING Curve __add__ ('+operator+'): Curves not same x',
+                      'axis values. Consider interpolation (interpolate=1).')
             out = Curve([selfx(index=r), op(selfy(index=r), othery(index=r), operator)], other.getAttributes())
             out.update(self.getAttributes())
-            if offsets: # remove offset information if use it during calculation
+            if offsets:  # remove offset information if use during calculation
                 out.update({'offset': '', 'muloffset': ''})
             out = out.castCurve(self.classNameGUI())
             return out
-        else: # not elementwise : interpolate
+        else:  # not elementwise : interpolate
             from scipy.interpolate import interp1d
-            # construct new x -> all x which are in the range of the other curve
+            # construct new x -> all x which are in the range of the other curv
             datax = list(selfx())
-            if interpolate == 1: # x from both self and other
+            if interpolate == 1:  # x from both self and other
                 xmin = max(min(selfx()), min(otherx()))
                 xmax = min(max(selfx()), max(otherx()))
-                datax += [x for x in otherx() if x not in datax] # no duplicates
-            else: # interpolate 2: copy x from self, restrict to min&max of other
+                # no duplicates
+                datax += [x for x in otherx() if x not in datax]
+            else:
+                # interpolate 2: copy x from self, restrict to min&max of other
                 xmin, xmax = min(otherx()), max(otherx())
             datax = [x for x in datax if x <= xmax and x >= xmin]
             reverse = (selfx(index=0) > selfx(index=1)) if len(selfx()) > 1 else False
             datax.sort(reverse=reverse)
-            f0 = interp1d( selfx(),  selfy(), kind=1)
+            f0 = interp1d(selfx(), selfy(), kind=1)
             f1 = interp1d(otherx(), othery(), kind=1)
             datay = [op(f0(x), f1(x), operator) for x in datax]
             out = Curve([datax, datay], other.getAttributes())
             out.update(self.getAttributes())
-            if offsets: # remove offset information if use it during calculation
+            if offsets:  # remove offset information if use during calculation
                 out.update({'offset': '', 'muloffset': ''})
             out = out.castCurve(self.classNameGUI())
             return out
 
     def __radd__(self, other, **kwargs):
         return self.__add__(other, **kwargs)
+
     def __sub__(self, other, **kwargs):
         """ substract operation, element-wise or interpolated """
         kwargs.update({'sub': True})
         return self.__add__(other, **kwargs)
+
     def __rsub__(self, other, **kwargs):
         """ reversed substract operation, element-wise or interpolated """
         kwargs.update({'sub': False, 'operator': 'add'})
         return Curve.__add__(self.__neg__(), other, **kwargs)
+
     def __mul__(self, other, **kwargs):
         """ multiplication operation, element-wise or interpolated """
         kwargs.update({'operator': 'mul'})
         return self.__add__(other, **kwargs)
+
     def __rmul__(self, other, **kwargs):
         kwargs.update({'operator': 'mul'})
         return self.__add__(other, **kwargs)
+
     def __div__(self, other, **kwargs):
         """ division operation, element-wise or interpolated """
         kwargs.update({'operator': 'div'})
         return self.__add__(other, **kwargs)
+
     def __rdiv__(self, other, **kwargs):
         """ division operation, element-wise or interpolated """
         kwargs.update({'operator': 'mul'})
         return Curve.__add__(self.__invertArithmetic__(), other, **kwargs)
+
     def __truediv__(self, other, **kwargs):
         """ division operation, element-wise or interpolated """
         kwargs.update({'operator': 'div'})
         return self.__add__(other, **kwargs)
+
     def __rtruediv__(self, other, **kwargs):
         """ division operation, element-wise or interpolated """
         kwargs.update({'operator': 'mul'})
         return Curve.__add__(self.__invertArithmetic__(), other, **kwargs)
+
     def __pow__(self, other, **kwargs):
         """ power operation, element-wise or interpolated """
         kwargs.update({'operator': 'pow'})
         return self.__add__(other, **kwargs)
 
     def __neg__(self, **kwargs):
         out = Curve([self.x(), -self.y()], self.getAttributes())
         out = out.castCurve(self.classNameGUI())
         return out
+
     def __invertArithmetic__(self, **kwargs):
         out = Curve([self.x(), 1/self.y()], self.getAttributes())
         out = out.castCurve(self.classNameGUI())
         return out
 
 
-
-
+    # plot function
     def plot(self, ax, graph=None, graph_i=None, type_plot='', ignoreNext=0, boxplot=None, violinplot=None, violinplotkwargs={}):
         """
         plot a Curve on some axis
         graph, graph_i: a graph instance, such that self==graph.curve(graph_i)
             required to properly plot scatter with scatter_c, etc.
         alter: '', or ['nmeV', 'abs']
         type_plot: 'semilogy'
@@ -824,242 +882,272 @@
         violinplot:
         violinplotkwargs:
         """
         from grapa.graph import Graph
         handle = None
         # check default arguments
         if boxplot is None:
-            boxplot    = {'y':[], 'positions':[], 'labels':[], 'color':[], 'i':0}
+            boxplot = {'y': [], 'positions': [], 'labels': [], 'color': [],
+                       'i': 0}
         if violinplot is None:
-            violinplot = {'y':[], 'positions':[], 'labels':[], 'color':[]}
+            violinplot = {'y': [], 'positions': [], 'labels': [], 'color': []}
         if graph is None:
             graph_i = None
         else:
-            if graph.curve(graph_i) != self:
+            if graph[graph_i] != self:
                 graph_i = None
             if graph_i is None:
-                for c in range(graph.length()):
-                    if graph.curve(c) == self:
+                for c in range(len(graph)):
+                    if graph[c] == self:
                         graph_i = c
                         break
             if graph_i is None:
-                graph = None # self was not found in graph
+                graph = None  # self was not found in graph
                 print('Warning Curve.plot: Curve not found in provided Graph')
 
-
         # retrieve basic information
         alter = graph._getAlter() if graph is not None else ['', '']
         attr = self.getAttributes()
-        linespec = self.getAttribute('linespec')
-        # construct dict of keywords based on curves attributes, in a very restrictive way
-        # some attributes are commands for plotting, some are just related to the sample, and no obvious way to discriminate between the 2
+        linespec = self.attr('linespec')
+        # construct dict of keywords based on curves attributes, in a very
+        # restrictive way
+        # some attributes are commands for plotting, some are just related to
+        # the sample, and no obvious way to discriminate between the 2
         fmt = {}
         for key in attr:
             if not isinstance(key, str):
                 print(type(key), key, attr[key])
-            if (not isinstance(attr[key], str) or attr[key] != '') and key in Graph.dataInfoKeysGraph and key not in ['plot', 'linespec', 'type', 'ax_twinx', 'ax_twiny', 'offset', 'muloffset', 'labelhide', 'colorbar', 'xerr', 'yerr']:
+            if ((not isinstance(attr[key], str) or attr[key] != '')
+                    and key in Graph.dataInfoKeysGraph
+                    and key not in ['plot', 'linespec', 'type', 'ax_twinx',
+                                    'ax_twiny', 'offset', 'muloffset',
+                                    'labelhide', 'colorbar', 'xerr', 'yerr']):
                 fmt[key] = attr[key]
         # do not plot curve if was asked not to display it.
         if 'linestyle' in fmt and fmt['linestyle'] in Curve.LINESTYLEHIDE:
             return None, ignoreNext
         # some renaming of kewords, etc
         if 'legend' in fmt:
             fmt['label'] = fmt['legend']
             del fmt['legend']
         if 'cmap' in fmt and not isinstance(fmt['cmap'], str):
-             # convert Colorscale into matplotlib cmap
+            # convert Colorscale into matplotlib cmap
             from grapa.colorscale import Colorscale
             fmt['cmap'] = Colorscale(fmt['cmap']).cmap()
         if 'vminmax' in fmt:
             if isinstance(fmt['vminmax'], list) and len(fmt['vminmax']) > 1:
-                if fmt['vminmax'][0] != '' and not np.isnan(fmt['vminmax'][0]) and not np.isinf(fmt['vminmax'][0]):
+                if (fmt['vminmax'][0] != '' and not np.isnan(fmt['vminmax'][0])
+                        and not np.isinf(fmt['vminmax'][0])):
                     fmt.update({'vmin': fmt['vminmax'][0]})
-                if fmt['vminmax'][1] != '' and not np.isnan(fmt['vminmax'][1]) and not np.isinf(fmt['vminmax'][1]):
+                if (fmt['vminmax'][1] != '' and not np.isnan(fmt['vminmax'][1])
+                        and not np.isinf(fmt['vminmax'][1])):
                     fmt.update({'vmax': fmt['vminmax'][1]})
             del fmt['vminmax']
 
         # start plotting
         # retrieve data after transform, including of offset and muloffset
         x = self.x_offsets(alter=alter[0])
         y = self.y_offsets(alter=alter[1])
-        type_graph = self.getAttribute('type', 'plot')
+        type_graph = self.attr('type', 'plot')
         if type_plot.endswith(' norm.'):
             type_graph = type_plot[:-6]
             y = y / max(y)
 
         # add keyword arguments which are in the plot method prototypes
         try:
             sig = inspect.signature(getattr(ax, type_graph))
             for key in sig.parameters:
                 if key in attr and key not in fmt:
                     fmt.update({key: attr[key]})
         except AttributeError:
-            print('Curve.plot: desired plotting method not found ('+type_graph+'). Going for default.')
-            pass # for xample 'errorbar_yerr' after suppression of previous Curve 'errorbar'. Will be 'plot' anyway.
+            print('Curve.plot: desired plotting method not found ('+type_graph
+                  + '). Going for default.')
+            # for xample 'errorbar_yerr' after suppression of previous Curve
+            # 'errorbar'. Will be 'plot' anyway.
+            pass
         except Exception as e:
-            print('Exception in Curve.plot while identifying keyword arguments:')
+            print('Exception in Curve.plot while identifying keyword',
+                  'arguments:')
             print(type(e), e)
 
         if 'labelhide' in attr and attr['labelhide']:
             if 'label' in fmt:
                 del fmt['label']
 
-        # No support for the following methods (either 2D data, or complicated to implement):
+        # No support for the following methods (either 2D data, or complicated
+        # to implement):
         #    hlines, vlines, broken_barh, contour, contourf, polar,
         #    pcolor, pcolormesh, streamplot, tricontour, tricontourf,
         #    tripcolor
         # Partial support for:
         #    imgshow
-        attrIgnore = ['label', 'plot', 'linespec', 'type', 'ax_twinx', 'ax_twiny', 'offset', 'muloffset', 'labelhide', 'colorbar']
-
+        attrIgnore = ['label', 'plot', 'linespec', 'type', 'ax_twinx',
+                      'ax_twiny', 'offset', 'muloffset', 'labelhide',
+                      'colorbar']
         # "simple" plotting methods, with prototype similar to plot()
-        if type_graph in ['semilogx', 'semilogy', 'loglog', 'plot_date', 'stem', 'step', 'triplot']:
+        if type_graph in ['semilogx', 'semilogy', 'loglog', 'plot_date',
+                          'stem', 'step', 'triplot']:
             handle = getattr(ax, type_graph)(x, y, linespec, **fmt)
         elif type_graph in ['fill']:
-            if self.getAttribute('fill_padto0', False):
+            if self.attr('fill_padto0', False):
                 handle = ax.fill([x[0]]+list(x)+[x[-1]], [0]+list(y)+[0], linespec, **fmt)
             else:
                 handle = ax.fill(x, y, linespec, **fmt)
         # plotting methods not accepting formatting string as 3rd argument
-        elif type_graph in ['bar', 'barbs', 'barh', 'cohere', 'csd', 'fill_between', 'fill_betweenx', 'hexbin', 'hist2d', 'quiver', 'xcorr']:
+        elif type_graph in ['bar', 'barbs', 'barh', 'cohere', 'csd',
+                            'fill_between', 'fill_betweenx', 'hexbin',
+                            'hist2d', 'quiver', 'xcorr']:
             handle = getattr(ax, type_graph)(x, y, **fmt)
         #  plotting of single vector data
-        elif type_graph in ['acorr', 'angle_spectrum', 'eventplot', 'hist', 'magnitude_spectrum', 'phase_spectrum', 'pie', 'psd', 'specgram']:
+        elif type_graph in ['acorr', 'angle_spectrum', 'eventplot', 'hist',
+                            'magnitude_spectrum', 'phase_spectrum', 'pie',
+                            'psd', 'specgram']:
             # careful with eventplot, the Curve data are modified
             handle = getattr(ax, type_graph)(y, **fmt)
         # a more peculiar plotting
         elif type_graph in ['spy']:
             handle = getattr(ax, type_graph)([x, y], **fmt)
         elif type_graph == 'stackplot':
             # look for next Curves with type == 'stackplot', and same x
             nexty = []
             fmt['labels'], fmt['colors'] = [''], ['']
             if 'label' in fmt:
-                fmt['labels'] = ['' if self.getAttribute('labelhide') else fmt['label']]
+                fmt['labels'] = ['' if self.attr('labelhide') else fmt['label']]
                 del fmt['label']
             if 'color' in fmt:
                 fmt['colors'] = [fmt['color']]
                 del fmt['color']
             attrIgnore.append('color')
             if graph is not None:
-                for j in range(graph_i+1, graph.length()):
-                    if graph.curve(j).getAttribute('type') == type_graph and np.array_equal(x, graph.curve(j).x_offsets(alter=alter[0])):
+                for j in range(graph_i+1, len(graph)):
+                    if graph[j].attr('type') == type_graph and np.array_equal(x, graph[j].x_offsets(alter=alter[0])):
                         ignoreNext += 1
-                        if not graph.curve(j).isHidden():
-                            nexty.append(graph.curve(j).y_offsets(alter=alter[1]))
-                            lbl = graph.curve(j).getAttribute('label')
-                            fmt['labels'].append('' if graph.curve(j).getAttribute('labelhide') else lbl)
-                            fmt['colors'].append(graph.curve(j).getAttribute('color'))
+                        if not graph[j].isHidden():
+                            nexty.append(graph[j].y_offsets(alter=alter[1]))
+                            lbl = graph[j].attr('label')
+                            fmt['labels'].append('' if graph[j].attr('labelhide') else lbl)
+                            fmt['colors'].append(graph[j].attr('color'))
                             continue
                     else:
                         break
-            if np.all([(c=='') for c in fmt['colors']]):
+            if np.all([(c == '') for c in fmt['colors']]):
                 del fmt['colors']
             handle = getattr(ax, type_graph)(x, y, *nexty, **fmt)
         elif type_graph == 'errorbar':
             # look for next Curves, maybe xerr/yerr was provided
             if 'xerr' in attr:
                 fmt.update({'yerr': attr['xerr']})
             if 'yerr' in attr:
                 fmt.update({'yerr': attr['yerr']})
             if graph is not None:
-                for j in range(graph_i+1, min(graph_i+3, graph.length())):
-                    if len(graph.curve(j).y()) == len(y):
-                        typenext = graph.curve(j).getAttribute('type')
+                for j in range(graph_i+1, min(graph_i+3, len(graph))):
+                    if len(graph[j].y()) == len(y):
+                        typenext = graph[j].attr('type')
                         if typenext not in ['errorbar_xerr', 'errorbar_yerr']:
                             break
                         if typenext == 'errorbar_xerr':
-                            fmt.update({'xerr': graph.curve(j).y_offsets()})
+                            fmt.update({'xerr': graph[j].y_offsets()})
                             ignoreNext += 1
                             continue
                         if typenext == 'errorbar_yerr':
-                            fmt.update({'yerr': graph.curve(j).y_offsets()})
+                            fmt.update({'yerr': graph[j].y_offsets()})
                             ignoreNext += 1
                             continue
                     break
             handle = ax.errorbar(x, y, fmt=linespec, **fmt)
         elif type_graph == 'scatter':
             convert = {'markersize': 's', 'markeredgewidth': 'linewidths'}
             for key in convert:
                 if key in fmt:
                     fmt.update({convert[key]: fmt[key]})
                     del fmt[key]
             try:
                 if graph is not None:
-                    for j in range(graph_i+1, min(graph_i+3, graph.length())):
-                        typenext = graph.curve(j).getAttribute('type')
+                    for j in range(graph_i+1, min(graph_i+3, len(graph))):
+                        typenext = graph[j].attr('type')
                         if typenext not in ['scatter_c', 'scatter_s']:
                             break
                         if 's' not in fmt and typenext == 'scatter_s':
-                            fmt.update({'s': graph.curve(j).y_offsets(alter=alter[1])})
+                            fmt.update({'s': graph[j].y_offsets(alter=alter[1])})
                             ignoreNext += 1
                             continue
-                        elif 'c' not in fmt and (typenext == 'scatter_c' or np.array_equal(x, graph.curve(j).x_offsets(alter=alter[0]))):
-                            fmt.update({'c': graph.curve(j).y_offsets(alter=alter[1])})
+                        elif 'c' not in fmt and (typenext == 'scatter_c' or np.array_equal(x, graph[j].x_offsets(alter=alter[0]))):
+                            fmt.update({'c': graph[j].y_offsets(alter=alter[1])})
                             ignoreNext += 1
                             if 'color' in fmt:
-                                del fmt['color'] # there cannot be both c and color keywords
+                                # there cannot be both c and color keywords
+                                del fmt['color']
                             continue
                         else:
                             break
                 handle = ax.scatter(x, y, **fmt)
             except Exception as e:
-                print('ERROR! Exception occured in Curve.plot function during scatter.')
+                print('ERROR! Exception occured in Curve.plot function during',
+                      'scatter.')
                 print(type(e), e)
         elif type_graph == 'boxplot':
             if len(y) > 0 and not np.isnan(y).all():
-                bxpltpos = self.getAttribute('boxplot_position', None)
+                bxpltpos = self.attr('boxplot_position', None)
                 boxplot['y'].append(y[~np.isnan(y)])
                 boxplot['positions'].append(boxplot['i'] if bxpltpos is None else bxpltpos)
                 boxplot['labels'].append(fmt['label'] if 'label' in fmt else '')
-                boxplot['color'].append (fmt['color'] if 'color' in fmt else '')
+                boxplot['color'].append(fmt['color'] if 'color' in fmt else '')
                 for key in ['widths', 'notch', 'vert']:
-                    if self.getAttribute(key, None) is not None:
-                        boxplot.update({key: self.getAttribute(key)})
+                    if self.attr(key, None) is not None:
+                        boxplot.update({key: self.attr(key)})
                 boxplot['i'] += 1
         elif type_graph == 'violinplot':
             if len(y) > 0 and not np.isnan(y).all():
-                bxpltpos = self.getAttribute('boxplot_position', None)
+                bxpltpos = self.attr('boxplot_position', None)
                 violinplot['y'].append(y[~np.isnan(y)])
                 violinplot['positions'].append(boxplot['i'] if bxpltpos is None else bxpltpos)
                 violinplot['labels'].append(fmt['label'] if 'label' in fmt else '')
-                violinplot['color'].append (fmt['color'] if 'color' in fmt else '')
+                violinplot['color'].append(fmt['color'] if 'color' in fmt else '')
                 if 'showmeans' in attr:
                     violinplotkwargs.update({'showmeans':   attr['showmeans']})
                 if 'showmedians' in attr:
                     violinplotkwargs.update({'showmedians': attr['showmedians']})
                 if 'showextrema' in attr:
                     violinplotkwargs.update({'showextrema': attr['showextrema']})
                 boxplot['i'] += 1
         elif type_graph in ['imshow', 'contour', 'contourf']:
             from grapa.curve_image import Curve_Image
             img, ignoreNext, X, Y = Curve_Image.getImageData(self, graph, graph_i, alter, ignoreNext)
             if 'label' in fmt:
                 del fmt['label']
             if type_graph in ['contour', 'contourf']:
-                for key in ['corner_mask', 'colors', 'alpha', 'cmap', 'norm', 'vmin', 'vmax', 'levels', 'origin', 'extent', 'locator', 'extend', 'xunits', 'yunits', 'antialiased', 'nchunk', 'linewidths', 'linestyles', 'hatches']:
+                for key in ['corner_mask', 'colors', 'alpha', 'cmap', 'norm',
+                            'vmin', 'vmax', 'levels', 'origin', 'extent',
+                            'locator', 'extend', 'xunits', 'yunits',
+                            'antialiased', 'nchunk', 'linewidths',
+                            'linestyles', 'hatches']:
                     if key in attr and key not in fmt:
                         fmt.update({key: attr[key]})
-                # TODO: remove linewidths, linestyles for contourf, hatches for contour
+                # TODO: remove linewidths, linestyles for contourf, hatches for
+                # contour
             args = [img]
-            if X is not None and Y is not None and type_graph in ['contour', 'contourf']:
-                args = [X, Y] +  args
+            if (X is not None and Y is not None
+                    and type_graph in ['contour', 'contourf']):
+                args = [X, Y] + args
             try:
                 handle = getattr(ax, type_graph)(*args, **fmt)
             except Exception as e:
                 print('Curve plot', type_graph, 'Exception')
                 print(type(e), e)
-        else: # default is plot (lin-lin) # also valid if no information is stored, aka returned ''
+        else:
+            # default is plot (lin-lin) # also valid if no information is
+            # stored, aka returned ''
             handle = ax.plot(x, y, linespec, **fmt)
 
         handles = handle if isinstance(handle, list) else [handle]
         for key in attr:
             if key not in fmt and key not in attrIgnore:
                 for h in handles:
                     if hasattr(h, 'set_'+key):
                         try:
                             getattr(h, 'set_'+key)(attr[key])
                         except Exception as e:
-                            print('GraphIO Exception during plot kwargs adjustment for key', key, ':', type(e))
+                            print('GraphIO Exception during plot kwargs',
+                                  'adjustment for key', key, ':', type(e))
                             print(e)
 
         return handle, ignoreNext
```

### Comparing `grapa-0.5.4.8/grapa/curve_image.py` & `grapa-0.6.1.0/grapa/curve_image.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 # -*- coding: utf-8 -*-
 """
 Created on Sun Oct 29 14:19:52 2017
 
 @author: Romain Carron
-Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+Copyright (c) 2023, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
 """
 from copy import deepcopy
 import numpy as np
 
 from grapa.graph import Graph
 from grapa.curve import Curve
 
@@ -17,105 +17,105 @@
     """
 
     CURVE = 'image'
 
     def __init__(self, *args, **kwargs):
         Curve.__init__(self, *args, **kwargs)
         # define default values for important parameters
-        if self.getAttribute('type') not in ['imshow', 'contour', 'contourf']:
+        if self.attr('type') not in ['imshow', 'contour', 'contourf']:
             self.update ({'type': 'imshow'})
         # legacy keyword
-        imagefile = deepcopy(self.getAttribute('imagefile', None))
+        imagefile = deepcopy(self.attr('imagefile', None))
         if imagefile is not None:
             self.update({'datafile': imagefile, 'imagefile': ''})
         self.update({'Curve': Curve_Image.CURVE})
 
     # GUI RELATED FUNCTIONS
     def funcListGUI(self, **kwargs):
         out = Curve.funcListGUI(self, **kwargs)
-        texttype, default = "keyword 'type'", self.getAttribute('type')
+        texttype, default = "keyword 'type'", self.attr('type')
         if default not in ['imshow', 'contour', 'contourf']:
             texttype = "issue: keyword 'type' should be:"
             default = 'imshow'
         out.append([self.updateValuesDictkeys, 'Set', [texttype], [default],
                     {'keys': ['type']},
                     [{'field':'Combobox','values':['imshow','contour','contourf']}]])
         interpolation = ['', 'none', 'nearest', 'bilinear', 'bicubic',
             'spline16', 'spline36', 'hanning', 'hamming', 'hermite', 'kaiser',
             'quadric', 'catrom', 'gaussian', 'bessel', 'mitchell', 'sinc',
             'lanczos']
         aspect = ['', '1 scalar', 'auto', 'equal']
-        datafile_XY1rowcol = bool(self.getAttribute('datafile_XY1rowcol'))
+        datafile_XY1rowcol = bool(self.attr('datafile_XY1rowcol'))
         # file; X,Y 1st row column
         out.append([self.updateValuesDictkeys, 'Set',
                     ['data file', 'first row, column as coordinates'],
-                    [self.getAttribute('datafile'), datafile_XY1rowcol],
+                    [self.attr('datafile'), datafile_XY1rowcol],
                     {'keys': ['datafile', 'datafile_XY1rowcol']},
                     [{'width':25},{'field':'Checkbutton'}]])
         # transpose, rotate
         at = ['transpose', 'rotate']
         out.append([self.updateValuesDictkeys, 'Set', at,
-                    [self.getAttribute(a) for a in at], {'keys': at},
+                    [self.attr(a) for a in at], {'keys': at},
                     [{'field':'Combobox', 'values':['','True','False']},{}]])
         # extent
         if not datafile_XY1rowcol:
-            extent = list(self.getAttribute('extent'))
+            extent = list(self.attr('extent'))
             while len(extent) < 4:
                 extent.append('')
             out.append([self.updateExtent, 'Set', ['extent left', 'right', 'bottom', 'top'], extent])
         else:
             out.append([None, '(extent not active if first row, column as coordinates)', [], []])
         # colormap
         attxt = ['cmap (ignored if color image)', 'vmin', 'vmax']
         at = [a.split(' ')[0] for a in attxt]
-        out.append([self.updateValuesDictkeys, 'Set', attxt, [self.getAttribute(a) for a in at], {'keys': at}])
-        if self.getAttribute('type') == 'imshow':
+        out.append([self.updateValuesDictkeys, 'Set', attxt, [self.attr(a) for a in at], {'keys': at}])
+        if self.attr('type') == 'imshow':
             at = ['aspect', 'interpolation']
             out.append([self.updateValuesDictkeys, 'Set',
                         ['aspect ratio', 'interpolation'],
-                        [self.getAttribute(a) for a in at], {'keys': at},
+                        [self.attr(a) for a in at], {'keys': at},
                         [{'field':'Combobox', 'values':aspect, 'bind':'beforespace'},
                          {'field':'Combobox', 'values':interpolation}]])
         else: # contour, contourf
             at = ['levels']
             out.append([self.updateValuesDictkeys, 'Set',
                         ['levels (list of values)'],
-                        [self.getAttribute(a) for a in at], {'keys': at}])
-        
+                        [self.attr(a) for a in at], {'keys': at}])
+
         return out
 
     def updateExtent(self, *args):
         flag = False
         for a in args:
             if a != '':
                 flag = True
         self.update({'extent': (list(args) if flag else '')})
-    
+
     def printHelp(self):
         print('*** *** ***')
         print('Class Curve_Image facilitates the creation and customization of insets inside a Graph')
         print('Important parameters:')
         print('- insetfile: a path to a saved Graph, either absolute or relative to the main Graph.')
         print('  if set to ' ' (whitespace) or if no Curve are found in the given file, the next Curves of the main graph will be displayed in the inset.')
         print('- insetcoords: coordinates of the inset axis, relative to the main graph. Prototype: [left, bottom, width, height]')
         print('- insetupdate: a dict which will be applied to the inset graph. Provides basic support for run-time customization of the inset graph.')
         print("  Examples: {'fontsize':8}, or {'xlabel': 'An updated label'}")
         return True
 
-    
+
     def getImageData(self, graph, graph_i, alter, ignoreNext=0):
         """
         graph: the Graph the Curve is in
         graph_i: index of Curve in graph
         alter: 2-elements list for alter
         """
-        transpose = self.getAttribute('transpose', False)
-        rotate    = self.getAttribute('rotate', False)
-        datafile  = self.getAttribute('datafile', None)
-        
+        transpose = self.attr('transpose', False)
+        rotate    = self.attr('rotate', False)
+        datafile  = self.attr('datafile', None)
+
         data = np.zeros((2,2))
         X, Y = None, None
         if datafile is not None:
             if graph is not None:
                 datafile = graph.filenamewithpath(datafile)
             try:
                 try:
@@ -134,15 +134,15 @@
             except OSError: # file is not an image -> assume is data
                 complement = {'readas': 'generic', '_singlecurve':True}
                 graphtmp = Graph(datafile, complement)
                 if graphtmp.length() > 0:
                     data = graphtmp.curve(0).getData()
                     if transpose:
                         data = np.transpose(data)
-                    if self.getAttribute('datafile_XY1rowcol', False):
+                    if self.attr('datafile_XY1rowcol', False):
                         try:
                             X = data[0,1:]
                             Y = data[1:,0]
                             data = data[1:,1:]
                         except:
                             pass
                     if rotate:
@@ -158,19 +158,18 @@
                 for j in range(graph_i+1, graph.length()):
                     if np.array_equal(x, graph.curve(j).x_offsets(alter=alter[0])):
                         data.append(graph.curve(j).y_offsets(alter=alter[0]))
                         ignoreNext += 1
                     else:
                         break
             data = np.array(data)
-            if self.getAttribute('datafile_XY1rowcol', False):
+            if self.attr('datafile_XY1rowcol', False):
                 try:
                     X = data[0,1:]
                     Y = data[1:,0]
                     data = data[1:,1:]
                 except:
                     pass
             data = np.transpose(data) if transpose else np.array(data)
             if rotate:
                 data = np.rot90(data, k=int(rotate)) # only by 90
         return data, ignoreNext, X, Y
-
```

### Comparing `grapa-0.5.4.8/grapa/curve_inset.py` & `grapa-0.6.1.0/grapa/curve_inset.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,58 +1,67 @@
 # -*- coding: utf-8 -*-
 """
 Created on Sun Oct 29 14:19:52 2017
 
 @author: Romain Carron
-Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+Copyright (c) 2023, Empa, Laboratory for Thin Films and Photovoltaics, Romain
+Carron
 """
 
-from grapa.graph import Graph
+# from grapa.graph import Graph
 from grapa.curve import Curve
 
+
 class Curve_Inset(Curve):
     """
     The purpose is this class is to provid GUI support to create insets
     """
 
     CURVE = 'inset'
 
     def __init__(self, *args, **kwargs):
         Curve.__init__(self, *args, **kwargs)
         # define default values for important parameters
-        if self.getAttribute('insetfile') is '':
+        if self.attr('insetfile') == '':
             self.update({'insetfile': ''})
-        if self.getAttribute('insetcoords') is '':
-            self.update({'insetcoords': [0.3,0.2,0.4,0.3]})
-        if self.getAttribute('insetupdate') is '':
+        if self.attr('insetcoords') == '':
+            self.update({'insetcoords': [0.3, 0.2, 0.4, 0.3]})
+        if self.attr('insetupdate') == '':
             self.update({'insetupdate': {}})
-            
-        if self.getAttribute('insetfile') is ' ':
-            if self.getAttribute('subplotfile') not in ['', ' ']:
-                self.update({'insetfile': self.getAttribute('subplotfile')})
+
+        if self.attr('insetfile') == ' ':
+            if self.attr('subplotfile') not in ['', ' ']:
+                self.update({'insetfile': self.attr('subplotfile')})
                 self.update({'subplotfile': ''})
 
-        self.update ({'Curve': Curve_Inset.CURVE})
+        self.update({'Curve': Curve_Inset.CURVE})
 
     # GUI RELATED FUNCTIONS
     def funcListGUI(self, **kwargs):
         out = Curve.funcListGUI(self, **kwargs)
-        out.append([self.updateValuesDictkeys, 'Set', ['file inset'],   [self.getAttribute('insetfile')],   {'keys': ['insetfile']}])
-        out.append([self.updateValuesDictkeys, 'Set', ['coords, in figure fraction [left, bottom, width, height]'],       [self.getAttribute('insetcoords')], {'keys': ['insetcoords']}])
-        out.append([self.updateValuesDictkeys, 'Set', ['update inset'], [self.getAttribute('insetupdate')], {'keys': ['insetupdate']}])
-        out.append([self.printHelp, 'Help!', [], []]) # one line per function
+        out.append([self.updateValuesDictkeys, 'Set', ['file inset'],
+                    [self.attr('insetfile')], {'keys': ['insetfile']}])
+        out.append([self.updateValuesDictkeys, 'Set',
+                    ['coords, in figure fraction [left, bottom, width, height]'],
+                    [self.attr('insetcoords')], {'keys': ['insetcoords']}])
+        out.append([self.updateValuesDictkeys, 'Set', ['update inset'],
+                    [self.attr('insetupdate')], {'keys': ['insetupdate']}])
+        out.append([self.printHelp, 'Help!', [], []])  # one line per function
         return out
 
-    
-    
     def printHelp(self):
         print('*** *** ***')
-        print('Class Curve_Inset facilitates the creation and customization of insets inside a Graph')
+        print('Class Curve_Inset facilitates the creation and customization',
+              'of insets inside a Graph.')
         print('Important parameters:')
-        print('- insetfile: a path to a saved Graph, either absolute or relative to the main Graph.')
-        print('  if set to ' ' (whitespace) or if no Curve are found in the given file, the next Curves of the main graph will be displayed in the inset.')
-        print('- insetcoords: coordinates of the inset axis, relative to the main graph. Prototype: [left, bottom, width, height]')
-        print('- insetupdate: a dict which will be applied to the inset graph. Provides basic support for run-time customization of the inset graph.')
+        print('- insetfile: a path to a saved Graph, either absolute or',
+              'relative to the main Graph.')
+        print('  if set to ' ' (whitespace) or if no Curve are found in the',
+              'given file, the next Curves of the main graph will be',
+              'displayed in the inset.')
+        print('- insetcoords: coordinates of the inset axis, relative to the',
+              'main graph. Prototype: [left, bottom, width, height]')
+        print('- insetupdate: a dict which will be applied to the inset',
+              'graph. Provides basic support for run-time customization of',
+              'the inset graph.')
         print("  Examples: {'fontsize':8}, or {'xlabel': 'An updated label'}")
         return True
-
-
```

### Comparing `grapa-0.5.4.8/grapa/curve_subplot.py` & `grapa-0.6.1.0/grapa/curve_subplot.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,84 +1,98 @@
 # -*- coding: utf-8 -*-
 """
 Created on Sun Oct 29 15:03:50 2017
 
 @author: Romain Carron
-Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+Copyright (c) 2023, Empa, Laboratory for Thin Films and Photovoltaics, Romain
+Carron
 """
 
 from grapa.graph import Graph
 from grapa.curve import Curve
 
+
 class Curve_Subplot(Curve):
     """
     The purpose is this class is to provid GUI support to handle subplots
     """
 
     CURVE = 'subplot'
 
     def __init__(self, *args, **kwargs):
         Curve.__init__(self, *args, **kwargs)
         # define default values for important parameters
-        self.update ({'Curve': Curve_Subplot.CURVE})
-        
+        self.update({'Curve': Curve_Subplot.CURVE})
+
         def checkattr(key, default, typ_):
-            val = self.getAttribute(key)
-            if val is '':
+            val = self.attr(key)
+            if val == '':
                 self.update({key: default})
             elif not isinstance(val, typ_):
                 self.update({key: typ_(val)})
-        
+
         checkattr('subplotfile', ' ', str)
         checkattr('subplotrowspan', 1, int)
         checkattr('subplotcolspan', 1, int)
         checkattr('subplotupdate', {}, dict)
-        if self.getAttribute('subplotfile') is ' ':
-            if self.getAttribute('insetfile') not in ['', ' ']:
-                self.update({'subplotfile': self.getAttribute('insetfile')})
+        if self.attr('subplotfile') == ' ':
+            if self.attr('insetfile') not in ['', ' ']:
+                self.update({'subplotfile': self.attr('insetfile')})
                 self.update({'insetfile': ''})
 
     # GUI RELATED FUNCTIONS
     def funcListGUI(self, **kwargs):
         out = Curve.funcListGUI(self, **kwargs)
         graph = None
         if 'graph' in kwargs:
             graph = kwargs['graph']
             del kwargs['graph']
-        out.append([self.updateValuesDictkeys, 'Set', ['file subplot'], [self.getAttribute('subplotfile')],    {'keys': ['subplotfile']}])
-        dictspan = {'field':'Combobox', 'values':['', '1','2','3','4','1 number'], 'bind':'beforespace'}
+        out.append([self.updateValuesDictkeys, 'Set', ['file subplot'],
+                    [self.attr('subplotfile')], {'keys': ['subplotfile']}])
+        dictspan = {'field': 'Combobox', 'bind': 'beforespace',
+                    'values': ['', '1', '2', '3', '4', '1 number']}
         out.append([self.updateValuesDictkeys, 'Set', ['colspan', 'rowspan'],
-                    [self.getAttribute('subplotcolspan'), self.getAttribute('subplotrowspan')],
+                    [self.attr('subplotcolspan'), self.attr('subplotrowspan')],
                     {'keys': ['subplotcolspan', 'subplotrowspan']},
                     [dictspan, dictspan]])
-        out.append([self.updateValuesDictkeys, 'Set', ['update subplot'], [self.getAttribute('subplotupdate')],  {'keys': ['subplotupdate']}])
+        out.append([self.updateValuesDictkeys, 'Set', ['update subplot'],
+                    [self.attr('subplotupdate')],  {'keys': ['subplotupdate']}])
         if graph is not None and isinstance(graph, Graph):
             out.append([None, 'Graph options', [], []])
-            ncols = int(graph.getAttribute('subplotsncols', 2))
+            ncols = int(graph.attr('subplotsncols', 2))
             out.append([graph.updateValuesDictkeys, 'Set',
                         ['n cols', 'transpose', 'show id? or ('+u"\u0394x,\u0394y)"],
-                        [ncols, str(graph.getAttribute('subplotstranspose')), str(graph.getAttribute('subplotsid'))],
+                        [ncols, str(graph.attr('subplotstranspose')), str(graph.attr('subplotsid'))],
                         {'keys': ['subplotsncols', 'subplotstranspose', 'subplotsid']},
-                        [{'field':'Combobox', 'values':['','1','2','3','4','1 number']},
-                         {'field':'Combobox', 'values':['', '0 False', '1 True'], 'bind':'beforespace'},{}]])
-            out.append([graph.updateValuesDictkeys, 'Set', ['width ratios (i.e. [1,2,1])', 'height_ratios'], [graph.getAttribute('subplotswidth_ratios'), graph.getAttribute('subplotsheight_ratios')], {'keys': ['subplotswidth_ratios', 'subplotsheight_ratios']}])
-            out.append([graph.updateValuesDictkeys, 'Set', ['subplots_adjust [left, bottom, right, top, wspace, hspace]'], [graph.getAttribute('subplots_adjust')], {'keys': ['subplots_adjust']}])
-        out.append([self.printHelp, 'Help!', [], []]) # one line per function
+                        [{'field': 'Combobox', 'values': ['', '1', '2', '3', '4', '1 number']},
+                         {'field': 'Combobox', 'values': ['', '0 False', '1 True'], 'bind':'beforespace'},
+                         {}]])
+            out.append([graph.updateValuesDictkeys, 'Set',
+                        ['width ratios (i.e. [1,2,1])', 'height_ratios'],
+                        [graph.attr('subplotswidth_ratios'), graph.attr('subplotsheight_ratios')],
+                        {'keys': ['subplotswidth_ratios', 'subplotsheight_ratios']}])
+            out.append([graph.updateValuesDictkeys, 'Set',
+                        ['subplots_adjust [left, bottom, right, top, wspace, hspace]'],
+                        [graph.attr('subplots_adjust')],
+                        {'keys': ['subplots_adjust']}])
+        out.append([self.printHelp, 'Help!', [], []])  # one line per function
         return out
-    
 
-        
     def printHelp(self):
         print('*** *** ***')
-        print('Class Curve_Subplot facilitates the creation and customization of subplots inside a Graph.')
+        print('Class Curve_Subplot facilitates the creation and customization',
+              'of subplots inside a Graph.')
         print('The main graph will be subdivised in an array of subplots.')
         print('Important parameters:')
-        print('- subplotfile: saved Graph file which must be shown in subplot.')
-        print('  The next Curves will also be shown in the created axis, until the next Curve with same Curve_Subplot type.')
-        print('- subplotcolspan: on how many column the subplot will be plotted.')
-        print('- subplotrowspan: on how many rows the subplot will be plotted.')
-        print('- subplotupdate: a dict which will be applied to the subplot Graph. Provides basic support for run-time customization of the inset graph.')
-        print("  Examples: {'fontsize':8}, or {'xlabel': 'An updated label'}")
+        print('- subplotfile: saved Graph file which must be shown in'
+              'subplot. The next Curves will also be shown in the created',
+              'axis, until the next Curve with same Curve_Subplot type.')
+        print('- subplotcolspan: on how many column the subplot will be',
+              'plotted.')
+        print('- subplotrowspan: on how many rows the subplot will be',
+              'plotted.')
+        print('- subplotupdate: a dict which will be applied to the subplot',
+              'Graph. Provides basic support for run-time customization of',
+              'the inset graph.')
+        print("Examples: {'fontsize': 8}, or {'xlabel': 'An updated label'}")
         print()
         return True
-
-
```

### Comparing `grapa-0.5.4.8/grapa/database.py` & `grapa-0.6.1.0/grapa/database.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 # -*- coding: utf-8 -*-
 """
 Created on Fri Jul  1 15:22:51 2016
 
 @author: Romain Carron
-Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+Copyright (c) 2023, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
 """
 
 import numpy as np
 
 
 from grapa.graph import Graph
 from grapa.mathModule import is_number
```

### Comparing `grapa-0.5.4.8/grapa/datatypes/AM0_2000_ASTM_E-490-00.txt` & `grapa-0.6.1.0/grapa/datatypes/AM0_2000_ASTM_E-490-00.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/datatypes/AM1-5_Ed2-2008.txt` & `grapa-0.6.1.0/grapa/datatypes/AM1-5_Ed2-2008.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/datatypes/curveArrhenius.py` & `grapa-0.6.1.0/grapa/datatypes/curveArrhenius.py`

 * *Files 7% similar despite different names*

```diff
@@ -9,93 +9,90 @@
 import numpy as np
 import warnings
 
 from grapa.curve import Curve
 from grapa.mathModule import roundSignificant, roundSignificantRange
 
 
-        
 class CurveArrhenius(Curve):
     """
     Offers some support for fitting Arrhenius plots.
     A bit weid implementation: different types of data are handled with
     subclasses, but no instance is ever fabricated of these subclasses.
     Reason is, we don't knwo a priori which subclasse the instance will be,
     and we want to be able to easily switch from on type to the other.
     New types of plots can be implemented as subclasses without modifying the
     CurveArrhenius cain class.
     *** *** ***
     Generally assumes x as temperature [K] and y as a some kind of signal [eV].
-    
+
     By default the output of the fit is E, Offset, with E the energy [eV] and
     Offset the value at 1/T = 0.
     The default fit function is Offset - E/(k*T), with k in [eV/K].
-    
+
     Alternative implementations are:
      - _Arrhenius_variant is set to 'Cfdefects'
        Assumes input as omega [s-1] vs temperature [K].
        Useful to process C-f data. Relevant quantity to plot is
        log(omega * T**-2), and corresponding fit is log(2*ksi) - E /(kT).
     """
-    
+
     CURVE = 'Curve Arrhenius'
-    
-    k_eVoverK = 8.6173303e-5 # [eV K-1]
-    
+
+    k_eVoverK = 8.6173303e-5  # [eV K-1]
 
     def __init__(self, data, attributes, silent=False):
         # main constructor
         Curve.__init__(self, data, attributes, silent=silent)
         self.update({'Curve': CurveArrhenius.CURVE})
 
-    
     @classmethod
     def classNameGUI(cls):
         return cls.CURVE.replace('Curve', 'Fit')
-    
 
     # GUI RELATED FUNCTIONS
     def funcListGUI(self, **kwargs):
         out = Curve.funcListGUI(self, **kwargs)
         # format: [func, 'func label', ['input 1', 'input 2', 'input 3', ...]]
         variant = self.getVariant()
         isFit = True
-        if self.getAttribute('_fitFunc', None) is None or self.getAttribute('_popt', None) is None:
+        if self.attr('_fitFunc', None) is None or self.attr('_popt', None) is None:
             isFit = False
-        
+
         if not isFit:
             out.append([self.CurveArrhenius_fit, variant.BUTTONFitLabel(),
                         [variant.BUTTONFitROI()],
                         [list(roundSignificant([min(self.x_1000overK())*0.95, 1.05*max(self.x_1000overK())], 4))]])
         else:
             lbl = variant.poptLabel
-            param = roundSignificant(self.getAttribute('_popt'), 5)
+            param = roundSignificant(self.attr('_popt'), 5)
             out.append([self.updateFitParam, 'Update fit', [lbl[0], lbl[1]], [param[0], '{:1.4e}'.format(param[1])]])
         # switch Arrhenius type
         subclasses = [variant.name, variant.switchModel, '', '== other possibilities ==']
         for child in CurveArrhenius.__subclasses__():
             if hasattr(child, 'name'):
                 subclasses.append(child.name)
         out.append([self.setVariant, 'Switch model',
                     ['to model (now '+variant.name+')'],
                     [variant.switchModel], {},
-                    [{'field':'Combobox', 'values':subclasses}]])
+                    [{'field': 'Combobox', 'values': subclasses}]])
         # suggest default axis label
         if 'graph' in kwargs:
-            alter = kwargs['graph'].getAttribute('alter')
-            if alter in ['', ['','']]:
-                vals = self.getAttribute('_arrhenius_dataLabel', None)
+            alter = kwargs['graph'].attr('alter')
+            if alter in ['', ['', '']]:
+                vals = self.attr('_arrhenius_dataLabel', None)
                 if vals is None and hasattr(variant, 'dataLabel'):
                     vals = variant.dataLabel
                 if vals is not None:
-                        out.append([kwargs['graph'].updateValuesDictkeys,
+                    out.append([kwargs['graph'].updateValuesDictkeys,
                                 'Save', ['xlabel', 'ylabel'], vals,
                                 {'keys': ['xlabel', 'ylabel']}])
-            elif alter == ['CurveArrhenius.x_1000overK', 'CurveArrhenius.y_Arrhenius']:
-                vals = self.getAttribute('_arrhenius_dataLabelArrhenius', None)
+            elif alter == ['CurveArrhenius.x_1000overK',
+                           'CurveArrhenius.y_Arrhenius']:
+                vals = self.attr('_arrhenius_dataLabelArrhenius', None)
                 if vals is None and hasattr(variant, 'dataLabelArrhenius'):
                     vals = variant.dataLabelArrhenius
                 if vals is not None:
                     out.append([kwargs['graph'].updateValuesDictkeys,
                                 'Save', ['xlabel', 'ylabel'], vals,
                                 {'keys': ['xlabel', 'ylabel']}])
         # resample X
@@ -103,157 +100,184 @@
             xmin, xmax = np.min(self.x()), np.max(self.x())
             tmp = roundSignificantRange([xmin, xmax], 3)
             xmin, xmax = tmp[0], tmp[1]
             out.append([self.resampleX, 'Resample X',
                         ['', 'min', 'max', '#, step'],
                         ['linspace', xmin, xmax, 51],
                         {},
-                        [{'field': 'Combobox', 'values': ['linspace', 'logspace', 'arange']},
+                        [{'field': 'Combobox', 'values': ['linspace', 'arange', 'logspace', 'geomspace']},
                          {}, {}, {}]])
         out.append([self.printHelp, 'Help!', [], []])
         return out
-    
+
     def alterListGUI(self):
         variant = self.getVariant()
         if hasattr(variant, 'alterListGUIspecific'):
             return getattr(variant, 'alterListGUIspecific')(self)
         out = Curve.alterListGUI(self)
         out += [['Arrhenius vs 1000/T', ['CurveArrhenius.x_1000overK', 'CurveArrhenius.y_Arrhenius'], '']]
         return out
-    
+
     # these one can be overloaded
     @classmethod
     def BUTTONFitLabel(cls):
         return 'Fit Arrhenius'
+
     @classmethod
     def BUTTONFitROI(cls):
         return 'ROI [1000/K]'
-    
+
     def x_1000overK(self, index=np.nan, **kwargs):
         """ x-axis transform function """
-        variant = CurveArrhenius.getVariant(self) # syntax: not necessarily a CurveArrhenius
-        if variant != CurveArrhenius and 'x_1000overK' in variant.__dict__: # maybe to do a non-Arrhenius fit?
+        # syntax: not necessarily a CurveArrhenius
+        variant = CurveArrhenius.getVariant(self)
+        if variant != CurveArrhenius and 'x_1000overK' in variant.__dict__:
+            # maybe to do a non-Arrhenius fit?
             return variant.x_1000overK(self, index=index, **kwargs)
         return 1000 / self.x(index, **kwargs)
-    
+
     def y_Arrhenius(self, index=np.nan, **kwargs):
         """ y-axis transform function, getting the Arrhenius straight line """
-        variant = CurveArrhenius.getVariant(self) # syntax: not necessarily a CurveArrhenius
-        if variant != CurveArrhenius and 'y_Arrhenius' in variant.__dict__: # only if y_Arrhenius explicitely defined, not inherited
+        # syntax: not necessarily a CurveArrhenius
+        variant = CurveArrhenius.getVariant(self)
+        if variant != CurveArrhenius and 'y_Arrhenius' in variant.__dict__:
+            # only if y_Arrhenius explicitely defined, not inherited
             return variant.y_Arrhenius(self, index=index, **kwargs)
-        print('CurveArrhenius y_Arrhenius, normally should not come to this point!')
+        print('CurveArrhenius y_Arrhenius, normally should not come to this',
+              'point!')
         return self.y(index, **kwargs)
-    
+
     # handling of subclasses of CurveArrhenius
     def getVariant(self):
-        var = self.getAttribute('_Arrhenius_variant')
+        var = self.attr('_Arrhenius_variant')
         subclasses = CurveArrhenius.__subclasses__()
         for i in range(len(subclasses)):
             if var == subclasses[i].name:
                 return subclasses[i]
         return CurveArrheniusDefault
-        
+
     def setVariant(self, newVariant):
         subclasses = CurveArrhenius.__subclasses__()
         for i in range(len(subclasses)):
             if newVariant == subclasses[i].name:
                 self.update({'_Arrhenius_variant': newVariant})
                 return True
         if newVariant not in ['', 'CurveArrhenius', 'default']:
-            print('ERROR Arrhenius: cannot find model', newVariant,', going for default.')
+            print('ERROR Arrhenius: cannot find model', newVariant,
+                  ', going for default.')
         self.update({'_Arrhenius_variant': 'default'})
         return True
-        
+
     # functions for Arrhenius plot
     def CurveArrhenius_fit(self, Tlim, *args, silent=False):
         """ Returns a Curve based on a fit on Arrhenius plot. """
         variant = self.getVariant()
-        
+
         popt = self.fit_Arrhenius(Tlim=Tlim, addargs=args, silent=silent)
         attr = {'color': 'k', '_popt': list(popt), '_fitFunc': 'func_Arrhenius',
                 '_Arrhenius_variant': variant.name, '_fitROI': Tlim}
         lbl = variant.poptLabel
         if not silent:
-            print('Fit results:', lbl[0],'=', lbl[2].format(popt[0]) + ',',
-                                  lbl[1],'=', lbl[3].format(popt[1]) + '.')
-        return CurveArrhenius([self.x(), self.func_Arrhenius(self.x(), *popt)], attr)
-        
+            print('Fit results:', lbl[0], '=', lbl[2].format(popt[0]) + ',',
+                  lbl[1], '=', lbl[3].format(popt[1]) + '.')
+        return CurveArrhenius([self.x(), self.func_Arrhenius(self.x(), *popt)],
+                              attr)
+
     def _fit_Arrhenius_getData(self, Tlim=None):
         T = self.x_1000overK()
+        # select data input by values
         if Tlim is None:
             Tlim = [min(T), max(T)]
         mask = np.ones(len(self.x()), dtype=bool)
         for i in range(len(mask)):
             if T[i] < Tlim[0] or T[i] > Tlim[1]:
                 mask[i] = False
         datax = self.x_1000overK()[mask]
         datay = self.y_Arrhenius()[mask]
-        return datax, datay
+        # remove nan
+        isnan = np.isnan(datax) + np.isnan(datay)
+        return datax[~isnan], datay[~isnan]
+
     def fit_Arrhenius(self, Tlim=None, addargs=None, silent=False):
         """
         Fits the data on the Arrhenius plot, in ROI Tlim[0] to Tlim[1].
         Returns Energy barrier [eV] and prefactor.
         """
         if addargs is None:
             addargs = []
         datax, datay = self._fit_Arrhenius_getData(Tlim=Tlim)
+        # print('Arrhenius polyfit data', datax, datay)
         z = np.polyfit(datax, datay, 1, full=True)[0]
         # output
         variant = self.getVariant()
         if not silent:
-            print('CurveArrhenius fit variant', variant.name,', assumed input as',
-                  variant.dataLabel[1], 'vs', variant.dataLabel[0])
+            print('CurveArrhenius fit variant', variant.name, ', assumed',
+                  'input as', variant.dataLabel[1], 'vs', variant.dataLabel[0])
             print(variant.getHelp())
-        return variant.popt(z) # [-z[0]*CurveArrhenius.k_eVoverK * 1000, z[1]]
-    
+        return variant.popt(z)  # [-z[0]*CurveArrhenius.k_eVoverK * 1000, z[1]]
+
     def func_Arrhenius(self, T, E, prefactor):
         """
         Returns function(K) which will appear linear on a Arrhenius plot.
         E is energy barrier
         prefactor is value on plot at 1/T = 0
         """
         variant = self.getVariant()
         if hasattr(variant, 'func_Arrhenius'):
             return variant.func_Arrhenius(T, E, prefactor)
-        print('CurveArrhenius func_Arrhenius, normally should not come to this point!')
+        print('CurveArrhenius func_Arrhenius, normally should not come to',
+              'this point!')
         return prefactor - E / (CurveArrhenius.k_eVoverK * T)
-            
+
     def resampleX(self, method, xmin, xmax, cpl):
-        """ Resample the X values and computes the Y values on it """ 
-        func = {'linspace': [np.linspace, 'num'],
-                'arange': [np.arange, ''],
-                'logspace': [np.logspace, 'num']}
+        """ Resample the X values and computes the Y values on it """
+        func = {'linspace': {'func': np.linspace, 'cpl': {'kw': 'num', 'type': int}},
+                'arange': {'func': np.arange, 'cpl': {'kw': ''}},
+                'logspace': {'func': np.logspace, 'cpl': {'kw': 'num', 'type': int}}}
+        try:
+            func.update({'geomspace': {'func': np.geomspace, 'cpl': {'kw': 'num', 'type': int}}})
+        except AttributeError:
+            if method == 'geomspace':
+                print('Method geomspace not available in your version of numpy.')
         if method not in func:
-            print('Error CurveArrhenius.resampleX: cannot find selected method', method, ', aborted.')
+            print('Error CurveArrhenius.resampleX: cannot find selected',
+                  'method', method, ', aborted.')
             return False
         args = [xmin, xmax]
         kwargs = {}
-        if func[method][1] == '':
+        # format cpl to desired type
+        if 'type' in func[method]['cpl']:
+            cpl = func[method]['cpl']['type'](cpl)
+        # cpl to args or kwargs
+        if func[method]['cpl']['kw'] == '':
             args.append(cpl)
         else:
-            kwargs[func[method][1]] = cpl
+            kwargs[func[method]['cpl']['kw']] = cpl
         try:
-            x = func[method][0](*args, **kwargs)
+            x = func[method]['func'](*args, **kwargs)
         except Exception as e:
-            print('Exception', type(e),'in CurveArrhenius.resampleX:')
+            print('Exception', type(e), 'in CurveArrhenius.resampleX:')
             print(e)
+            print('args', args, 'kwargs', kwargs)
             return False
         y = [0] * len(x)
         self.data = np.array([x, y])
-        self.updateFitParam(*self.getAttribute('_popt'))
+        self.updateFitParam(*self.attr('_popt'))
         return True
-        
-        
+
     def printHelp(self):
         print('*** *** ***')
         print('Curve Arrhenius general help:')
         print('Offers some support for fitting Arrhenius plots.')
-        print('Generally assumes x as temperature [K] and y as a some kind of signal [eV].')
-        print('By default the output of the fit is E, Offset, with E the energy [eV] and Offset the value at 1/T = 0.')
-        print('The default fit function is Offset - E/(k*T), with k in [eV/K].')
+        print('Generally assumes x as temperature [K] and y as a some kind of',
+              'signal [eV].')
+        print('By default the output of the fit is E, Offset, with E the',
+              'energy [eV] and Offset the value at 1/T = 0.')
+        print('The default fit function is Offset - E/(k*T), with k in',
+              '[eV/K].')
         print('')
         print('List of alternative implementations:')
         dct = {}
         variant = self.getVariant()
         subclasses = CurveArrhenius.__subclasses__()
         for cls in subclasses:
             if cls != variant:
@@ -266,182 +290,265 @@
         print('Help on this specific implementation of Arrhenius Curve:')
         print(variant.getHelp())
         dataLabel = self.getVariant().dataLabel
         print('Expected data input:', dataLabel[0], ',', dataLabel[1])
         return True
 
 
-        
-        
 class CurveArrheniusDefault(CurveArrhenius):
     """
     The instances will be of CurveArrhenius, but main class will call the
     methods implemented in the desired child classes.
     """
-    name = 'default' # identifier
+    name = 'default'  # identifier
     dataLabel = ['Temperature [K]', 'Value [eV]']
     poptLabel = ['E [eV]', 'Offset [eV]', '{:1.4e}', '{:.4f}']
-    switchModel = '' # sggestion to user, a other model to try on his data
-    # default Curve attributes such that the CurveArrhenius is correctly defined
+    switchModel = ''  # sggestion to user, a other model to try on his data
+    # default Curve attributes such that CurveArrhenius is correctly defined
     attr = {'Curve': 'Curve Arrhenius', '_Arrhenius_variant': 'default',
             'label': 'value vs Temperature'}
-    def popt(z): # transforms polynom z into correct fit parameters
+
+    def popt(z):  # transforms polynom z into correct fit parameters
         return [-z[0]*CurveArrhenius.k_eVoverK * 1000, z[1]]
-    def getHelp(short=False): # the help dedicated to the specific implementation
+
+    def getHelp(short=False):
+        # the help dedicated to the specific implementation
         return 'Arrhenius plot is: value = offset - E /(kT)'
+
     def y_Arrhenius(self, index=np.nan, **kwargs):
-         return self.y(index, **kwargs)
+        return self.y(index, **kwargs)
+
     def func_Arrhenius(T, E, prefactor):
         return prefactor - E / (CurveArrhenius.k_eVoverK * T)
-    
+
+
 class CurveArrheniusJscVocJ00(CurveArrhenius):
     name = 'JscVocJ00'
     dataLabel = ['A(T) * Temperature [K]', 'J0 [mA cm-2]']
     poptLabel = ['E_A [eV]', 'J00 [mA cm-2]', '{:1.4f}', '{:1.4f}']
     switchModel = 'JscVocJ00'
     attr = {'Curve': 'Curve Arrhenius', '_Arrhenius_variant': 'JscVocJ00',
             'label': 'J0 [mA cm-2] vs A(t)*T [K]',
             'linestyle': 'none', 'linespec': 'o'}
-    def popt(z): # fit polynom z to desired output values
+
+    def popt(z):  # fit polynom z to desired output values
         return [-z[0]*CurveArrhenius.k_eVoverK * 1000, np.exp(z[1])]
-    def func_Arrhenius(T, E, prefactor): # replace default fit function
+
+    def func_Arrhenius(T, E, prefactor):  # replace default fit function
         return np.exp(np.log(prefactor) - E / (CurveArrhenius.k_eVoverK * T))
+
     def y_Arrhenius(self, index=np.nan, **kwargs):
         with warnings.catch_warnings():
             warnings.simplefilter('ignore')
             out = np.log(self.y(index=index, **kwargs))
         return out
+
     def getHelp(short=False):
-        out = 'Computes E_A the activation energy of J0, and J00 its value extrapolated at 1/T = 0.'
+        out = 'Computes E_A the activation energy of J0, and J00 its value' \
+               + 'extrapolated at 1/T = 0.'
         if not short:
-            out+= '\nThe equation is: log(J0) = log(J00) - E_A / (k AT),\n'
-            out+= '   stemming from J0 = J00 * exp(- E_A / (k AT))'
+            out += '\nThe equation is: log(J0) = log(J00) - E_A / (k AT),\n'
+            out += 'stemming from J0 = J00 * exp(- E_A / (k AT))'
         return out
 
 
 class CurveArrheniusCfDefects(CurveArrhenius):
     """ 'fit': 'ln2ksi-E/kT', 'y': 'ln(omega*T**-2)' """
     name = 'Cfdefects'
     dataLabel = ['Temperature [K]', 'omega [s-1]']
     poptLabel = ['E [eV]', 'ksi', '{:1.5f}', '{:.4e}']
     switchModel = 'Cfdefault'
     attr = {'Curve': 'Curve Arrhenius', '_Arrhenius_variant': 'Cfdefects',
             'label': 'omega vs Temperature', 'linestyle': 'none'}
-            # by default hidden - would cause strange value on derivative plot
+    # by default hidden - would cause strange value on derivative plot
     dataLabelArrhenius = [r'1000 / T', r'ln($\omega T^{-2}$)']
+
     def popt(z):
         return [-z[0] * CurveArrhenius.k_eVoverK * 1000, 0.5 * np.exp(z[1])]
+
     def func_Arrhenius(T, E, prefactor):
         return T**2 * np.exp(np.log(2 * prefactor) - E / (CurveArrhenius.k_eVoverK * T))
+
     def y_Arrhenius(self, index=np.nan, **kwargs):
-        # must compute omega T**-2 and show log, corresponding fit expression is 'log2ksi-omega/kT'
+        # must compute omega T**-2 and show log, corresponding fit expression
+        # is 'log2ksi-omega/kT'
         with warnings.catch_warnings():
             warnings.simplefilter('ignore')
             out = np.log(self.y(index, **kwargs) * self.x(index, **kwargs)**-2)
         return out
+
     def getHelp(short=False):
         if short:
             return 'Handles omega [s-1] vs T [K] inflection points of C-f curves, using a weak T**-2 temperature dependency.'
         out = 'Assumes traps can follow frequency: omega = 2 ksi T**2 exp(-E/(kT))\n'
-        out+= '    then Arrhenius plot is: ln(omega * T**-2) = ln(2*ksi) - E /(kT)'
+        out += '    then Arrhenius plot is: ln(omega * T**-2) = ln(2*ksi) - E /(kT)'
         return out
 
-     
+
 class CurveArrheniusCfdefault(CurveArrhenius):
     """ 'fit': 'ln2ni-E/kT', 'y': 'ln(omega)' """
     name = 'Cfdefault'
     dataLabel = ['Temperature [K]', 'omega [s-1]']
     poptLabel = ['E [eV]', 'nu', '{:1.5f}', '{:.4e}']
     switchModel = 'Cfdefects'
     attr = {'Curve': 'Curve Arrhenius', '_Arrhenius_variant': 'Cfdefault',
             'label': 'omega vs Temperature', 'linestyle': 'none'}
-            # by default hidden - would cause strange value on derivative plot
-    dataLabelArrhenius = [r'1000 / T', 'ln($\omega$)']
+    # by default hidden - would cause strange value on derivative plot
+    dataLabelArrhenius = [r'1000 / T', r'ln($\omega$)']
+
     def popt(z):
         return [-z[0] * CurveArrhenius.k_eVoverK * 1000, 0.5 * np.exp(z[1])]
+
     def func_Arrhenius(T, E, prefactor):
         return np.exp(np.log(2 * prefactor) - E / (CurveArrhenius.k_eVoverK * T))
+
     def y_Arrhenius(self, index=np.nan, **kwargs):
         with warnings.catch_warnings():
             warnings.simplefilter('ignore')
             out = np.log(self.y(index, **kwargs))
         return out
+
     def getHelp(short=False):
         if short:
             return 'Handles omega [s-1] vs T [K] inflection points of C-f curves, using no weak T**-2 temperature dependency.'
         out = 'Assumes a (barrier / trap / something without weak T dependency) can follow frequency:\n'
-        out+= 'omega = 2 nu exp(-E/(kT))\n'
-        out+='    then Arrhenius plot is: ln(omega) = ln(2*nu) - E /(kT)'
+        out += 'omega = 2 nu exp(-E/(kT))\n'
+        out += '    then Arrhenius plot is: ln(omega) = ln(2*nu) - E /(kT)'
         return out
 
 
 class CurveArrheniusExtrapolToZero(CurveArrhenius):
     """
     This is not an Arrhenius, but we can recyle the same code for any 1-degree
     polynomial interpolation.
     """
+    name = 'ExtrapolationTo0'  # NOT an Arrhenius fit, but can use polynom fit
+    dataLabel = ['Temperature [K]', 'Value [unit]']
+    poptLabel = ['Increase [unit / K]', 'Value at 0 [unit]', '{:.4e}', '{:.4e}']
+    switchModel = ''
+    attr = {'Curve': 'Curve Arrhenius',
+            '_Arrhenius_variant': 'ExtrapolationTo0'}
+    dataLabelArrhenius = ['Temperature [K]', 'Value [unit]']
+
     @classmethod
     def BUTTONFitLabel(cls):
         return 'Fit extrapolate to 0'
+
     @classmethod
     def BUTTONFitROI(cls):
         return 'ROI [K]'
-    name = 'ExtrapolationTo0' # is NOT an Arrhenius fit, still, can use polynom fit
-    dataLabel = ['Temperature [K]', 'Value [unit]']
-    poptLabel = ['Increase [unit / K]', 'Value at 0 [unit]', '{:.4e}', '{:.4e}']
-    switchModel = ''
-    attr = {'Curve': 'Curve Arrhenius', '_Arrhenius_variant': 'ExtrapolationTo0'}
-    dataLabelArrhenius = ['Temperature [K]', 'Value [unit]']
+
     def popt(z):
         return [z[0], z[1]]
+
     def func_Arrhenius(T, E, prefactor):
         return prefactor + E * T
+
     def y_Arrhenius(self, index=np.nan, **kwargs):
         return self.y(index, **kwargs)
-    def x_1000overK(self, index=np.nan, **kwargs): # NOT ARRHENIUS
+
+    def x_1000overK(self, index=np.nan, **kwargs):  # NOT ARRHENIUS
         return self.x(index, **kwargs)
+
     def getHelp(short=False):
         out = '(not Arrhenius relation) Fits the data with 1-degree polynom.'
         if short:
             return out
         out += '\nThe equation is: value = ValueAt0 + Increase * T'
         return out
-    
+
 
 class CurveArrheniusExpDecay(CurveArrhenius):
     """
     This is not an Arrhenius, but we can recyle the same code for another
     expression
-    Created to handle Urbach decays of EQE curves 
+    Created to handle Urbach decays of EQE curves
     """
+    name = 'expDecay'  # is NOT an Arrhenius fit, still, can use polynom fit
+    dataLabel = ['Wavelength [nm]', 'Value [unit]']
+    poptLabel = ['Decay energy [meV]', 'Energy @ 100% [eV]', '{:.4e}', '{:.4e}']
+    switchModel = ''
+    attr = {'Curve': 'Curve Arrhenius', '_Arrhenius_variant': 'expDecay'}
+    dataLabelArrhenius = ['Energy [eV]', 'log(value)']
+
     @classmethod
     def BUTTONFitLabel(cls):
         return 'Fit exp. decay'
+
     @classmethod
     def BUTTONFitROI(cls):
         return 'ROI [eV]'
-    name = 'expDecay' # is NOT an Arrhenius fit, still, can use polynom fit
-    dataLabel = ['Wavelength [nm]', 'Value [unit]']
-    poptLabel = ['Decay energy [meV]', 'Energy @ 100% [eV]', '{:.4e}', '{:.4e}']
-    switchModel = ''
-    attr = {'Curve': 'Curve Arrhenius', '_Arrhenius_variant': 'expDecay'}
-    dataLabelArrhenius = ['Energy [eV]', 'log(value)']
+
     def alterListGUIspecific(self):
         out = Curve.alterListGUI(self)
         return out
+
     def popt(z):
         return [1/z[0]*1000, -z[1]/z[0]]
+
     def func_Arrhenius(nm, U, E_at_1):
         return np.exp(((Curve.NMTOEV / nm) - (E_at_1)) / (U*0.001))
+
     def y_Arrhenius(self, index=np.nan, **kwargs):
         with warnings.catch_warnings():
             warnings.simplefilter('ignore')
             return np.log(self.y(index, **kwargs))
-    def x_1000overK(self, index=np.nan, **kwargs): # NOT ARRHENIUS
+
+    def x_1000overK(self, index=np.nan, **kwargs):  # NOT ARRHENIUS
         return self.x(index, alter='nmeV', **kwargs)
+
     def getHelp(short=False):
         out = 'Characterize an exponential decay (ie. Urbach).'
         if short:
             return out
         out += '\nThe equation is: value = exp((E - E_at_1) / (E_decay/1000))'
         return out
-    
+
+
+class CurveArrheniusPowerLaw(CurveArrhenius):
+    """
+    This is not an Arrhenius, but we can recyle the same code for another
+    expression
+    Created to handle power law: y = A * x**k
+    """
+    name = 'powerLaw'  # is NOT an Arrhenius fit, still, can use polynom fit
+    dataLabel = ['Parameter [unit]', 'Value [unit]']
+    poptLabel = ['Prefactor', 'Exponent', '{:.4e}', '{:.4e}']
+    switchModel = ''
+    attr = {'Curve': 'Curve Arrhenius', '_Arrhenius_variant': 'powerLaw'}
+    dataLabelArrhenius = ['log(parameter) [unit]', 'log(value) [unit]']
+
+    @classmethod
+    def BUTTONFitLabel(cls):
+        return 'Fit power law'
+
+    @classmethod
+    def BUTTONFitROI(cls):
+        return 'ROI [log(parameter)]'
+
+    def alterListGUIspecific(self):
+        out = Curve.alterListGUI(self)
+        out += [['Log-log', ['CurveArrhenius.x_1000overK', 'CurveArrhenius.y_Arrhenius'], '']]
+        return out
+
+    def popt(z):
+        return [np.exp(z[1]), z[0]]
+
+    def func_Arrhenius(x, A, k):
+        return np.exp(np.log(A) + k * np.log(x))
+
+    def y_Arrhenius(self, index=np.nan, **kwargs):
+        with warnings.catch_warnings():
+            warnings.simplefilter('ignore')
+            return np.log(self.y(index, **kwargs))
+
+    def x_1000overK(self, index=np.nan, **kwargs):  # NOT ARRHENIUS
+        with warnings.catch_warnings():
+            warnings.simplefilter('ignore')
+            return np.log(self.x(index, **kwargs))
+
+    def getHelp(short=False):
+        out = 'Characterize a power law.'
+        if short:
+            return out
+        out += '\nThe equation is: value = A * x**k'
+        return out
```

### Comparing `grapa-0.5.4.8/grapa/datatypes/curveCV.py` & `grapa-0.6.1.0/grapa/mathModule.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,297 +1,351 @@
 # -*- coding: utf-8 -*-
 """
-Created on Wed Feb 22 07:34:12 2017
+Created on Fri May  8 20:19:42 2015
+
 @author: Romain Carron
-Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+Copyright (c) 2023, Empa, Laboratory for Thin Films and Photovoltaics, Romain
+Carron
 """
-
 import numpy as np
+import ast
 import warnings
-from copy import deepcopy
-
+import codecs
 
-from grapa.graph import Graph
-from grapa.graphIO import GraphIO
-from grapa.curve import Curve
-from grapa.mathModule import roundSignificant, derivative, is_number
 
+MOJIBAKE_WINDOWS = [u'\xc2', u'\xc3']
+ESCAPE_WARNING = {'a': '\a', 'b': '\b', 'r': '\r', 'f': '\f'}
 
+"""
+ESCAPEWARNING = ['\a', '\b', '\f', '\r', '\v']  # likely errors
+# likely intent was latex code, eg. \nu instead of \n+u
+ESCAPEWARNING += ['\nu', '\nabla', '\nexists', '\neg', '\neq', '\notin']
+ESCAPEWARNING += ['\tau', '\theta', '\triangle', '\times']
+# '\newline': likely not an error
+# \\ ooo, \\ xhh: checks not implemented
+"""
 
-class GraphCV(Graph):
 
-    FILEIO_GRAPHTYPE = 'C-V curve'
+def find_nearest(array, value):
+    idx = (np.abs(array-value)).argmin()
+    return array[idx]
 
-    AXISLABELS = [['Voltage', 'V', 'V'], ['Capacitance', 'C', 'nF']] 
 
-    @classmethod
-    def isFileReadable(cls, fileName, fileExt, line1='', line2='', line3='', **kwargs):
-        if fileExt == '.txt' and line1.strip()[:12] == 'Sample name:' and fileName[0:4] == 'C-V_':
-           return True
+def is_number(s):
+    try:
+        float(s)
+        return True
+    except Exception:
         return False
-    
-        
-    def readDataFromFile(self, attributes, **kwargs):
-        len0 = self.length()
-        GraphIO.readDataFromFileGeneric(self, attributes)
-        self.castCurve('Curve CV', len0, silentSuccess=True)
-        # label based on file name, maybe want to base it on file content
-        self.curve(len0).update({'label': self.curve(len0).getAttribute('label').replace('C-V ','').replace(' [nF]','').replace(' Capacitance', '').replace('T=','')})
-        #set [nF] units
-        self.curve(len0).setY(1e9 * self.curve(len0).y())
-        # compute phase angle if required
-        nb_add = 0
-        if self.getAttribute('_CVLoadPhase', False) is not False:
-            f = 1e5 # [Hz]
-            C = self.curve(len0).y() * 1e-9 # in [F], not [nF]
-            conductance = None
-            for c in range(len0+1, self.length()): # retrieve resistance curve, not always same place
-                lbl = self.curve(c).getAttribute('Voltage')
-                if isinstance(lbl, str) and lbl[:1] == 'R':
-                    conductance = 1 / self.curve(c).y()
-                    break
-            if conductance is None:
-                print('ERROR Read', self.filename, 'as CurveCf with phase: cannot find R.')
-            else:
-                phase_angle = np.arctan(f * 2 * np.pi * C / conductance) * 180. / np.pi
-#                phase_angle = np.arctan(C / conductance) * 180. / np.pi
-                self.append(Curve([self.curve(len0).x(), phase_angle], self.curve(len0).getAttributes()))
-                nb_add += 1
-        # delete unneeded Curves
-        for c in range(self.length()-1-nb_add, len0, -1):
-            self.deleteCurve(c)
-        # cosmetics
-        axisLabels = deepcopy(GraphCV.AXISLABELS)
-        # normalize with area C
-        area = self.curve(len0).getAttribute('cell area (cm2)', None)
-        if area is None:
-            area = self.curve(len0).getAttribute('cell area', None)
-        if area is None:
-            area = self.curve(len0).getAttribute('area', None)
-        if area is not None:
-            self.curve(len0).setY(self.curve(len0).y() / area)
-            self.curve(len0).update({'cell area (cm2)': area})
-            axisLabels[1][2] = axisLabels[1][2].replace('F', 'F cm$^{-2}$')
-            if not self.silent:
-                print('Capacitance normalized to area', self.curve(len0).getArea(),'cm2.')
-        # graph cosmetics
-        self.update({'xlabel': self.formatAxisLabel(axisLabels[0]),
-                     'ylabel': self.formatAxisLabel(axisLabels[1])}) # default
-
 
 
-class CurveCV(Curve):
-    
-    CURVE = 'Curve CV'
-
-    CST_q = 1.6021766208e-19 # C # electrical charge
-    CST_eps0 = 8.85418782e-12 # m-3 kg-1 s4 A2 # vacuum permittivity
-    CST_epsR = 10 # relative permittivity
-    
-    CST_MottSchottky_Vlim_def = [0, 0.4]
-    CST_MottSchottky_Vlim_adaptative = [-0.5, np.inf]
-    
-    
-    def __init__(self, data, attributes, silent=False):
-        # main constructor
-        Curve.__init__(self, data, attributes, silent=silent)
-        # for saved files further re-reading
-        self.update ({'Curve': CurveCV.CURVE})
-    
-
-
-    # GUI RELATED FUNCTIONS
-    def funcListGUI(self, **kwargs):
-        out = Curve.funcListGUI(self, **kwargs)
-        # format: [func, 'func label', ['input 1', 'input 2', 'input 3', ...]]
-        out.append([self.setArea, 'Set cell area', ['New area'], [self.getArea()]])
-        # fit Mott-Schottky
-        if self.getAttribute('_fitFunc', None) is None or self.getAttribute('_popt', None) is None:
-            out.append([self.CurveCV_fitVbiN, 'Fit Mott-Schotty', ['ROI [V]'], [CurveCV.CST_MottSchottky_Vlim_def]])
-            out.append([self.CurveCV_fitVbiN_smart, 'Fit Mott-Schotty (around min N_CV)', ['Within range [V]'], [CurveCV.CST_MottSchottky_Vlim_adaptative]])
-        else:
-            param = roundSignificant(self.getAttribute('_popt'), 5)
-            out.append([self.updateFitParam, 'Update fit', ['V_bi', 'N_CV'], [param[0], '{:1.4e}'.format(param[1])]])
-        # curve extraction for doping at 0 V
-        out.append([self.CurveCV_0V, 'Show doping at', ['V='], [0]])
-        # set epsilon
-        out.append([self.setEpsR, 'Set epsilon r', ['default = 10'], [self.getEpsR()]])
-        out.append([self.printHelp, 'Help!', [], []])
-# 1/C2 = 2 / q / Nc / Ks / eps0 / A2 (Vbi-V)
-        
-        return out
-    
-    def alterListGUI(self):
-        out = Curve.alterListGUI(self)
-        #out.append(['nm <-> eV', ['nmeV', ''], ''])
-        out.append(['Mott-Schottky (1/C^2 vs V)', ['', 'CurveCV.y_ym2'], ''])
-        out.append(['Carrier density N_CV [cm-3] vs V', ['', 'CurveCV.y_CV_Napparent'], ''])
-        out.append(['Carrier density N_CV [cm-3] vs depth [nm]', ['CurveCV.x_CVdepth_nm', 'CurveCV.y_CV_Napparent'], ''])
-        return out
-
-    # FUNCTIONS used for curve transform (alter)
-    def y_ym2(self, xyValue=None, **kwargs):
-        """ Mott-Schottky plot: 1 / C**2 """
-        if xyValue is not None:
-            return xyValue[1]
-        return 1 / (self.y(**kwargs) ** 2)
-        
-    def x_CVdepth_nm(self, **kwargs):
-        """ apparent probing depth, assuming planar capacitor. """
-        eps_r = CurveCV.getEpsR(self)
-        with warnings.catch_warnings():
-            warnings.simplefilter("ignore")
-            w = eps_r * CurveCV.CST_eps0 / (1e-5 * self.y(**kwargs)) * 1e9 # y defined as nF/cm2, output depth in [nm]
-        return w
-    def y_CV_Napparent(self, xyValue=None, **kwargs):
-        """ apparent carrier density N_CV """
-        if xyValue is not None:
-            return xyValue[1]
-        with warnings.catch_warnings():
+def roundSignificant(xSeries, nDigits):
+    if isinstance(xSeries, (int, float)):
+        out = roundSignificant([xSeries], nDigits)
+        return out[0]
+    try:
+        out = [x if (x == 0 or np.isnan(x) or np.isinf(x)) else np.round(x, int(nDigits-1-np.floor(np.log10(np.abs(x))))) for x in xSeries]
+    except TypeError as e:
+        print('TypeError in roundSignificant, returned input.')
+        print(e)
+        print(type(xSeries), xSeries)
+        out = xSeries
+    return np.array(out)
+
+
+def roundSignificantRange(xSeries, nDigits):
+    nDigitsAdd = 0
+    span = np.abs(xSeries[1] - xSeries[0])
+    refs = np.abs([span, (xSeries[1] + xSeries[0])/2, xSeries[0], xSeries[1]])
+    try:
+        with warnings.catch_warnings():  # don't want warnings div by 0, etc.
             warnings.simplefilter("ignore")
-            dCm2dV = derivative(self.x(**kwargs), (1e-5 * self.y(**kwargs)) ** (-2)) # C from [nF cm2] to [F m-2]
-        eps_r = CurveCV.getEpsR(self)
-        N = - 2 / (CurveCV.CST_q * eps_r * CurveCV.CST_eps0 * (dCm2dV)) * 1e-6 # output unit in [cm-3]
-        return N
-    
-    
-    # FUNCTIONS RELATED TO GUI (fits, etc.)
-    def setArea(self, value):
-        oldArea = self.getArea()
-        self.update({'cell area (cm2)': value})
-        self.setY(self.y() / value * oldArea)
-        return True
-    def getArea(self):
-        return self.getAttribute('cell area (cm2)', 1)
-    
-    # handle custom-defined eps_r
-    def getEpsR(self):
-        if self.getAttribute('epsR', 0) != 0:
-            return self.getAttribute('epsR')
-        return CurveCV.CST_epsR
-    def setEpsR(self, value):
-        self.update({'epsR': value})
-
-        
-
-    # functions for fitting Mott-Schottky plot
-    def CurveCV_fitVbiN(self, Vlim=None, silent=False):
-        """
-        Returns a Curve based on a fit on Mott-Schottky plot.
-        Calls fit_MottSchottkyto get parameters, then call func_MottSchottky
-        to generate data.
-        """
-        Vbi, N_CV = self.fit_MottSchottky(Vlim=Vlim)
-        attr = {'color': 'k', 'area': self.getArea(), '_popt': [Vbi, N_CV], '_fitFunc': 'func_MottSchottky', '_Vlim': Vlim, 'filename': 'fit to '+self.getAttribute('filename').split('/')[-1].split('\\')[-1]}
-        if not silent:
-            print('Fit Mott-Schottky plot: Vbi =', Vbi, 'V, apparent doping N_CV =', '{:1.4e}'.format(N_CV) + '.')
-        return CurveCV([self.x(), self.func_MottSchottky(self.x(), Vbi, N_CV)], attr)
-    def CurveCV_fitVbiN_smart(self, Vrange=None, window=[-2,2], silent=False):
-        """
-        Returns a Curve based on a fit on Mott-Schottky plot, after first 
-        guessing best possible range for fifting (where N_CV is lowest)
-        """
-        Vlim = self.smartVlim_MottSchottky(Vlim=Vrange, window=window)
-        return self.CurveCV_fitVbiN(Vlim=Vlim, silent=False)
-
-    def fit_MottSchottky(self, Vlim=None):
-        """
-        Fits the C-V data on Mott-Schottky plot, in ROI Vlim[0] to Vlim[0].
-        Returns built-in voltage Vbi [V] and apparent doping density N_CV [cm-3].
-        """
-        datax, datay = self.selectData(xlim=Vlim)
-        if len(datax) == 0:
-            return np.nan, np.nan
-        datay =  1 / (datay * 1e-5) ** 2  # calculation in SI units [F m-2]
-        z = np.polyfit(datax, datay, 1, full=True)[0]
-        Vbi = - z[1] / z[0]
-        N_CV = - 2 / (CurveCV.CST_q * CurveCV.getEpsR(self) * CurveCV.CST_eps0) / z[0]
-        return Vbi, N_CV * 1e-6 # N_CV in [cm-3]
-    def func_MottSchottky(self, V, Vbi, N_CV):
-        """
-        Returns C(V) which will appear linear on a Mott-Schottky plot.
-        V_bi built-in voltage [V]
-        N_CV apparent doping density [cm-3]
-        Output: C [nF cm-2]
-        """
-        out = V * np.nan
-        if np.isnan(Vbi) or N_CV < 0:
-            return out
-        mask = (V < Vbi)
-        Cm2 = 2 / (CurveCV.CST_q * CurveCV.getEpsR(self) * CurveCV.CST_eps0 * (N_CV * 1e6)) * (Vbi - V)
-        out[mask] = (Cm2[mask] ** (-0.5))
-        return out * 1e5 # output unit [nF is cm-2]
-        
-        
-    def smartVlim_MottSchottky(self, Vlim=None, window=[-2,2]):
-        """
-        Returns Vlim [Vmin, Vmax] offering a possible best range for Mott-
-        Schottky fit.
-        Assumes V in monotoneous increasing/decreasing.
-        Window: how many points around best location are taken. Default [-2,2]
-        """
-        V = self.x()
-        N = self.y(alter='CurveCV.y_CV_Napparent')
-        # identify index within given V limits
-        if Vlim is None:
-            Vlim = CurveCV.CST_MottSchottky_Vlim_adaptative
-        Vlim = [min(Vlim), max(Vlim)]
-        ROI = [np.inf, -np.inf]
-        for i in range(len(V)):
-            if V[i] >= Vlim[0]:
-                ROI[0] = min(i, ROI[0])
-            if V[i] <= Vlim[1]:
-                ROI[1] = max(i, ROI[1])
-        # identify best: take few points around minimum of N
-        N[N<0] = np.inf					   
-        from scipy.signal import medfilt
-        N_ = medfilt(N, 3) # thus we eliminate faulty points
-        idx = np.argmin(N_[ROI[0]:ROI[1]])
-        #print(self.getAttribute('temperature [k]'), [V[ROI[0]+idx+window[0]], V[ROI[0]+idx+window[1]]])
-        lim0 = max(ROI[0]+idx+window[0], 0)
-        lim1 = min(ROI[0]+idx+window[1], len(V)-1)
-        return [V[lim0], V[lim1]]
-        
-        
-    def CurveCV_0V(self, Vtarget=0):
-        """
-        Creates a curve with require data to compute doping at V=0
-        Parameters:
-            Vtarget: extract doping around other voltage
-        """ 
-        if not is_number(Vtarget):
-            print('CurveCV.CurveCV_0V: please provide a number')
-            return False
-        Vtarget
-        i = np.argmin(np.abs(self.x() - Vtarget))
-        if i > 0 and i < len(self.x()) - 1:
-            x = np.concatenate(([0]     , self.x()[i-1:i+2], [0]))
-            y = np.concatenate(([np.nan], self.y()[i-1:i+2], [np.nan]))
-            curve = CurveCV([x, y], self.attributes)
-            curve.update({'linespec':'s', 'markeredgewidth':0, 'labelhide':1})
-            curve.update({'label':curve.attr('label')+' V='+str(Vtarget)})
-            return curve
+            nDigitsAdd = int(np.max([0, np.log10(np.max(refs)/span)]))
+    except Exception:
+        pass
+    return roundSignificant(xSeries, nDigits+nDigitsAdd)
+
+
+def roundgraphlim(lim):
+    """ Returns rounded graph limits. lim=[1.5,3.0] for example. """
+    lim = np.array(lim)
+    lim.sort()
+    diff = lim[1] - lim[0]
+    target = np.array([lim[0] - diff/10, lim[1] + diff/10])
+    magn = int(max(1 + np.ceil(-np.log10(np.abs(target)))))
+#    print ('roundgraphlim', lim, target, magn)
+    target[0] = np.floor(target[0] * 10**magn) / 10**magn
+    target[1] = np.ceil(target[1] * 10**magn) / 10**magn
+#    print ('   ',target)
+    return target
+
+
+def stringToVariable(val):
+    print('WARNING: stringToVariable, use strToVar instead (arg', val, ')')
+    return strToVar(val)
+
+
+def strToVar(val):
+    # val = codecs.getdecoder("unicode_escape")(val)[0]
+    flagast = False
+    try:
+        val = float(val)
+    except Exception:
+        try:
+            val = ast.literal_eval(val)
+            flagast = True
+        except Exception:
+            if isinstance(val, str) and len(val) > 1:
+                if ((val[0] == '[' and val[-1] == ']')
+                        or (val[0] == '(' and val[-1] == ')')):
+                    try:
+                        val = [float(v) for v in val[1:-1].replace(' ', '').replace('np.inf', 'inf').split(',')]
+                    except Exception:
+                        pass
+    # print('strToVar', val, flagast)
+    if not flagast:  # not needed when created through ast.literal_eval
+        val = strUnescapeIter(val)
+    # print('   ', val)
+    return val
+
+
+def strUnescapeIter(var):
+    if isinstance(var, list):
+        for i in range(len(var)):
+            var[i] = strUnescapeIter(var[i])
+    elif isinstance(var, dict):
+        for key in var:
+            var[key] = strUnescapeIter(var[key])
+    elif isinstance(var, str):
+
+        try:
+            var = codecs.getdecoder("unicode_escape")(var)[0]
+        except Exception as e:
+            print('Exception in function strToVar', type(e), e)
+            print('Input:', var)
+        try:
+            # handling of special characters transformed into mojibake
+            # The 2-pass code below can clean inputs with special characters
+            # encoded in:
+            # ANSI (e.g. Windows-1252), UTF-8, UTF-8 escaped (eg. \xb5 for mu)
+            # First pass
+            for char in MOJIBAKE_WINDOWS:
+                if char in var:
+                    # print('Suspicion mojibake, latin-1-utf-8 conversion')
+                    var = var.encode('latin-1').decode('utf-8')
+                    break
+            # Second pass. Appears necessary with some charset input
+            for char in MOJIBAKE_WINDOWS:
+                if char in var:
+                    # print('Suspicion mojibake (2), latin-1-utf-8 conversion')
+                    var = var.encode('latin-1').decode('utf-8')
+                    break
+            for key in ESCAPE_WARNING:
+                if ESCAPE_WARNING[key] in var:
+                    print('CAUTION, escape character detected (\\' + key
+                          + '). Please add double backslash (\\\\' + key + ')'
+                          + ' for Latex code.')
+        except Exception as e:
+            print('Exception in function strToVar (mojibake)', type(e), e)
+            print('Possibly, mix of special characters and escape sequences',
+                  'in same input')
+            print('Input:', var)
+            # keep current out value. Likely to fail
+    return var
+
+
+def varToStr(val):
+    # return codecs.getencoder("unicode_escape")(out)[0].decode('utf-8')
+    try:
+        out = repr(val).strip("'")
+    except Exception as e:
+        print('varToStr Exception', type(e), e)
+        print('Input:', val)
+        out = ''
+    return out
+
+
+def listToString(val):
+    """ Converts a list to a string with suitable formatting """
+    return '[' + ', '.join([str(element) if not isinstance(element, str) else '\''+element+'\'' for element in val]) + ']'
+
+
+def derivative(x, y):
+    """ numerical derivative dy/dx for the x and y datapoint series.
+    Symetrical differentialtion i+1, i+1
+    x is supposed to be monotonic (sorted up/down) !
+    """
+    if not isinstance(x, (np.ndarray)):
+        x = np.array(x)
+    if not isinstance(y, (np.ndarray)):
+        y = np.array(y)
+    if len(x) != len(y):
+        print('ERROR Math derivative: x and y not same length!')
+        print(x, y)
+        return False
+    if len(y) == 0:
+        return np.array([])
+    if len(y) == 1:
+        return np.array([0])
+    d = (y[1:]-y[:-1])/(x[1:]-x[:-1])
+    return np.append(np.append([d[0]], 0.5*(d[:-1]+d[1:])), d[-1])
+
+
+def derivative2nd(x, y):
+    """
+    Second numerical derivative d2y/dx2 for the x and y datapoint series.
+    x is supposed to be monotonic (sorted up/down) !
+    CAUTION: this function is locally more exact, but much more noisier than
+        derivative(derivative)!
+    Consider derivating twice on experiemental datasets.
+    """
+    if not isinstance(x, (np.ndarray)):
+        x = np.array(x)
+    if not isinstance(y, (np.ndarray)):
+        y = np.array(y)
+    if len(x) != len(y):
+        print('ERROR Math derivative: x and y not same length!')
+        print(x, y)
         return False
+    d = (y[1:] - y[:-1]) / (x[1:] - x[:-1])
+    dd = (d[1:] - d[:-1]) / (x[2:] - x[:-2]) * 2
+    return np.append(np.append((d[1]-d[0])/(x[0]-x[1]), dd), (d[-1]-d[-2])/(x[-1]-x[-2]))
+
+
+def smooth(x, window_len=11, window='hanning'):
+    """smooth the data using a window with requested size.
+    This method is based on the convolution of a scaled window with the signal.
+    The signal is prepared by introducing reflected copies of the signal
+    (with the window size) in both ends so that transient parts are minimized
+    in the begining and end part of the output signal.
+    input:
+        x: the input signal
+        window_len: the dimension of the smoothing window; should be an odd
+            integer
+        window: the type of window from 'flat', 'hanning', 'hamming',
+            'bartlett', 'blackman'
+            flat window will produce a moving average smoothing.
+    output:
+        the smoothed signal
+    Example:
+    t=linspace(-2,2,0.1)
+    x=sin(t)+randn(len(t))*0.1
+    y=smooth(x)
+    See also:
+    numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman,
+    numpy.convolve, scipy.signal.lfilter
+
+    TODO: the window parameter could be the window itself if an array instead
+        of a string
+    NOTE: length(output) != length(input), to correct this:
+        return y[(window_len/2-1):-(window_len/2)] instead of just y.
+    """
+    if x.ndim != 1:
+        raise ValueError("smooth only accepts 1 dimension arrays.")
+    if x.size < window_len:
+        raise ValueError("Input vector needs to be bigger than window size.")
+
+    if window_len < 3:
+        return x
+
+    if window not in ['flat', 'hanning', 'hamming', 'bartlett', 'blackman']:
+        raise ValueError("Window is on of 'flat', 'hanning', 'hamming',",
+                         " 'bartlett', 'blackman'")
+
+    s = np.r_[x[window_len-1:0:-1], x, x[-1:-window_len:-1]]
+    # print(len(s))
+    if window == 'flat':  # moving average
+        w = np.ones(window_len, 'd')
+    else:
+        w = eval('np.'+window+'(window_len)')
+
+    y = np.convolve(w/w.sum(), s, mode='valid')
+    return y[int((window_len-1)/2):int(len(y)-(window_len-1)/2)]
+
+
+def xAtValue(xSeries, ySeries, value, xMinMax=[-np.inf, np.inf], silent=False):
+    x = np.nan
+    # find x value at intercept
+    if len(xSeries) - len(ySeries) != 0:
+        print('Error function xAtValues: lenght of xSeries and ySeries not',
+              'identical!')
+        print('   len(xSeries): ', len(xSeries))
+        print('   len(ySeries): ', len(ySeries))
+        return 0
+
+    idxBot = -1
+    idxTop = -1
+    limits = 2 - (xSeries > min(xMinMax)) - (xSeries < max(xMinMax))
+    for i in range(len(xSeries)):
+        if limits[i]:
+            continue
+        x = xSeries[i]
+        y = ySeries[i]
+#        print (i, x, y, idxBot, idxTop)
+        if y <= value:
+            if idxBot < 0 or np.abs(y - value) < np.abs(ySeries[idxBot]-value):
+                idxBot = i
 
-        
-        
-    # other functions
-    
-
-    def printHelp(self):
-        print('*** *** ***')
-        print('CurveCV offer basic treatment of C-V curves of solar cells.')
-        print('Input units must be [V] and [nF] (or [nF cm-2]).')
-        print('Curve transforms:')
-        print(' - Linear: standard is Capacitance per area [nF cm-2] vs [V].')
-        print(' - Mott-Schottky: [1/(C cm-2)^2] vs V. Allows extraction of built-in voltage V_bi')
-        print('   (intercept with y=0) and carrier density (from slope).')
-        print(' - Carrier density N_CV [cm-3] vs V: the apparent carrier density is calculated')
-        print('   from formula N_CV = -2 / (eps0 epsr d/dV(C^-2)).')
-        print(' - Carrier density N_CV [cm-3] vs depth [nm]: the apparent depth is calculated from')
-        print('   parallel plate capacitor C = eps0 epsr / d.')
-        print('Analysis functions:')
-        print(' - Set area: can normalize input data. For proper data analysis the units should be [nF cm-2].')
-        print(' - Extract N_CV, Vbi: fits the linear segment on the Mott-Schottky plot.')
-        print('   Select the suitable ROI before fitting (enter min and max Voltages).')
-        return True
-    
+        else:
+            if idxTop < 0 or np.abs(y - value) < np.abs(ySeries[idxTop]-value):
+                idxTop = i
+
+    if np.abs(idxBot - idxTop) != 1:
+        if not silent:
+            print('Error function xAtValues: possibly 2 crossing values, or',
+                  'data not sorted.', idxBot, idxTop, value)
+            print(ySeries)
+
+    if idxBot + idxTop == -2:
+        print('Error function xAtValues: no suitable data found.')
+    elif idxBot != -1 and idxTop != -1:
+        # linear interpolation
+        x = xSeries[idxBot] + (xSeries[idxTop] - xSeries[idxBot]) * (value - ySeries[idxBot]) / (ySeries[idxTop] - ySeries[idxBot])
+    elif idxBot != -1:
+        x = xSeries[idxBot]
+    elif idxTop != -1:
+        x = xSeries[idxTop]
+    if np.isnan(x):
+        print('ERROR mathModule xAtValue: cannot find suitable value.')
+        print('   xSeries', xSeries)
+        print('   ySeries', ySeries)
+        print('   value', value)
+    return x
+
+
+# def bandgapFromTauc(nm, EQE, xLim=[600, 1500], yLim=[25, 70]):
+#     if max(EQE) < 1:
+#         print('Function bandgapFromTauc: max(EQE) < 1. Multiplied by 100 for',
+#               'datapoint selection.')
+#         EQE *= 100
+#
+#     mask = np.ones(len(nm), dtype=bool)
+#     for i in reversed(range(len(mask))):
+#         if (EQE[i] < yLim[0] or EQE[i] > yLim[1] or nm[i] < xLim[0]
+#                 or nm[i] > xLim[1]):
+#             mask[i] = False
+#     nm = nm[mask]
+#     EQE = EQE[mask]
+#
+#     eV = 1239.5 / nm
+#     tauc = (eV * EQE)**2
+#     if len(tauc > 1):
+#         z = np.polyfit(eV, tauc, 1, full=True)[0]
+#         # p = np.poly1d(z)
+#         bandgap = -z[1]/z[0]
+#         return [bandgap, z[0]]
+#     # print ('Function bandgapFromTauc: not enough suitable datapoints.')
+#     return [np.nan, np.nan]
+
+
+# def polynomFromDataSeries(xSeries, ySeries):
+#     if len(xSeries) == 0 or len(ySeries) == 0:
+#         print('Error polynomFromDataSeries: cannot find polynom with no data.',
+#               'Length of series:', len(xSeries), len(ySeries))
+#     if len(xSeries) != len(ySeries):
+#         print('Error polynomFromDataSeries: cannot find polynom when length',
+#               'of x and y series do not match. Length of series:',
+#               len(xSeries), len(ySeries))
+#     degree = len(xSeries)
+#     print('function not written yet')
+#     raise NotImplementedError
+#     return -1
```

### Comparing `grapa-0.5.4.8/grapa/datatypes/curveEQE.py` & `grapa-0.6.1.0/grapa/datatypes/curveEQE.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,532 +1,515 @@
 # -*- coding: utf-8 -*-
 """
 Created on Fri Jul 15 15:46:13 2016
 
 @author: Romain Carron
-Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+Copyright (c) 2023, Empa, Laboratory for Thin Films and Photovoltaics,
+Romain Carron
 """
 
 import numpy as np
 import os
 from scipy import interpolate
 from scipy.signal import medfilt
 
-
 from grapa.graph import Graph
 from grapa.curve import Curve
 from grapa.mathModule import roundSignificant, roundSignificantRange
+from grapa.gui.GUIFuncGUI import FuncGUI
 
+class CurveEQE(Curve):
+    """
+    CurveEQE offer basic treatment of (external) quantum efficiency curves of
+    solar cells.
+    Input units should be in [nm] and values within [0-1]. If needed,
+    CurveSpectrum can convert [eV] in [nm].
+    """
 
+    CURVE = 'Curve EQE'
 
-class GraphEQE(Graph):
-    
-    FILEIO_GRAPHTYPE = 'EQE curve'
-    FILEIO_GRAPHTYPE_OLD = 'EQE curve (old)'
-    
-    AXISLABELS = [['Wavelength', '\lambda', 'nm'], ['Cell EQE', '', '%']]
-    
-    @classmethod
-    def isFileReadable(cls, fileName, fileExt, line1='', **kwargs):
-        # new QE files
-        if fileExt == '.sr' and line1 == 'This is a QE measurment':
-            return True
-        # old setup QE files (2013(?) or older)
-        if fileExt == '.sr' and line1[0:16] == 'Reference Cell: ':
-            return True
-        return False
-
-    def readDataFromFile(self, attributes, **kwargs):
-        ifOld = False
-        # retrieve sample name - code should work for old and new file format
-        f = open(self.filename, 'r')
-        line = f.readline() # retrieve sample, should be stored on the 2nd line
-        if line[0:16] == 'Reference Cell: ':
-            ifOld = True
-        line = list(filter(len,
-                f.readline().replace(': ', '\t').strip(' \r\n\t').split('\t')))
-        # look for acquisition attributes
-        attributesFile = {}
-        interests = [['Amplification settings', 'amplification'],
-                     ['Lockin settings', 'lockin']]
-        for l in f:
-            for interest in interests:
-                if l.startswith(interest[0]):
-                    for param in l.strip().split('\t'):
-                        if ': ' in param:
-                            tmp = param.split(': ')
-                            attributesFile.update({interest[1]+tmp[0].replace(' ',''): tmp[1]})
-            if len(l) == 1 and l[0] in ['\n']:
-                break
-        f.close()
-        data = np.array([np.nan, np.nan])
-        try:
-            kw = {'delimiter': '\t', 'invalid_raise': False}
-            if ifOld:
-                kw.update({'skip_header': 14, 'usecols': [0, 6]})
-            else:
-                kw.update({'skip_header': 15, 'usecols': [0, 5]})
-            data = np.transpose(np.genfromtxt(self.filename, **kw))
-        except Exception:
-            if not self.silent:
-                print('readDataFromFileEQE cannot read file', self.filename)
-        # normalize data
-        self.append(CurveEQE(data, attributes))
-        self.curve(-1).update(attributesFile)
-        if len(data.shape) > 1:
-            self.curve(-1).update({'mulOffset': 100})
-        # update label with information stored inside the file
-        self.update({'label': line[-1].replace('_', ' ')})
-        # some default settings
-        self.update({'xlabel': self.formatAxisLabel(GraphEQE.AXISLABELS[0]),
-                     'ylabel': self.formatAxisLabel(GraphEQE.AXISLABELS[1]),
-                     'ylim': [0, 100], 'xlim': [300, np.nan]})
-        self.headers.update({'collabels': ['Wavelength [nm]', 'EQE [%]']})
-        # newer versions of EQE include phase signal -> one more header line
-        self.update({'sample': self.curve(0).getAttribute('label')})
-        # default value in files old setup
-        if self.headers['sample'] == 'Ref':
-            filenam_, fileext = os.path.splitext(self.getAttribute('filename'))
-            self.curve(-1).update({'label':
-                                   (filenam_.split('/')[-1]).split('\\')[-1]})
-            self.headers.update({'sample': filenam_})
-        if ifOld:
-            self.headers.update({'meastype': GraphEQE.FILEIO_GRAPHTYPE_OLD})
-
-
-
-    
+    EQE_AM15_REFERENCE = None
+    EQE_AM15_REFERENCE_FILE = 'AM1-5_Ed2-2008.txt'
+    EQE_AM0_REFERENCE = None
+    EQE_AM0_REFERENCE_FILE = 'AM0_2000_ASTM_E-490-00.txt'
 
-class CurveEQE(Curve):
-    
-    CURVE = 'Curve EQE'
+    EQE_REF_SPECTRA = None
+    EQE_REF_SPECTRA_FILE = 'EQE_referenceSpectra.txt'
 
-    EQE_AM15_REFERENCE = 'AM1-5_Ed2-2008.txt'
-    EQE_AM0_REFERENCE = 'AM0_2000_ASTM_E-490-00.txt'
-    EQE_BEST_CELL_REF = 'EQE_20.4_cell.txt'
-    EQE_BEST_CELL_LABEL = 'Empa 20.4%'
-    
-    
     def __init__(self, data, attributes, silent=False):
         # modify default label
         if 'label' in attributes:
             if not isinstance(attributes['label'], str):
                 attributes['label'] = str(attributes['label'])
             if '$' not in attributes['label']:
                 attributes['label'] = attributes['label'].replace('_', ' ')
         if not isinstance(data, (np.ndarray)):
             data = np.array(data)
         # detect possible empty lines at beginnning (some versions of EQE files
         # ahave different number of header lines)
-        flag = True if len(data.shape) > 1 else False # check if data loaded
-        while flag:
-            if data[0, 0] == 0:
-                data = data[:, 1:]
-            else:
-                flag = False
+        flag = True if len(data.shape) > 1 else False  # check if data loaded
+        try:
+            while flag:
+                if data[0, 0] == 0:
+                    data = data[:, 1:]
+                else:
+                    flag = False
+        except IndexError:
+            pass
         # main constructor
         Curve.__init__(self, data, attributes, silent=silent)
         # bandgap calculation
-        popt = self.getAttribute('_popt')
+        popt = self.attr('_popt')
         if isinstance(popt, str) and popt == '':
             bandgap = [np.nan, np.nan]
             try:
                 bandgap = self.bandgapFromTauc(self.x(), self.y())
             except Exception:
                 if not self.silent:
                     print('ERROR readDataFromFileEQE during Eg calculation',
                           self.filename, self.data[-1].data())
             # also useful to store information that we were *not* able to
             # compute bandgap
             self.update({'bandgap': bandgap[0], 'bandgapslope': bandgap[1]})
         # for saved files further re-reading
-        self.update ({'Curve': CurveEQE.CURVE})
-
-
+        self.update({'Curve': CurveEQE.CURVE})
 
     # GUI RELATED FUNCTIONS
     def funcListGUI(self, **kwargs):
         out = Curve.funcListGUI(self, **kwargs)
         # format: [func, 'func label', ['input 1', 'input 2', 'input 3', ...]]
+        mulOffset = self.attr('mulOffset', default=1)
+        if isinstance(mulOffset, list):
+            mulOffset = mulOffset[1]
+        try:
+            mulOffset = float(mulOffset)
+        except TypeError:
+            mulOffset = 1
+
         # tauc (E*EQE)**2
         if (not self.attributeEqual('_popt')
-            and self.attributeEqual('_fitfunc', 'func_bandgapTaucCurve')):
+                and self.attributeEqual('_fitfunc', 'func_bandgapTaucCurve')):
             out.append([self.updateFitParam, 'Update fit', ['Eg', 'slope'],
-                        roundSignificant(self.getAttribute('_popt'),5)])
+                        roundSignificant(self.attr('_popt'), 5)])
         elif self.attributeEqual('_popt'):
-            mulOffset = self.getAttribute('mulOffset', default=1)
             out.append([self.CurveEQE_bandgap_print,
                         'Bandgap fit Tauc (eV*EQE)^2', ['Range EQE'],
                        ['['+str(0.25*mulOffset)+', '+str(0.70*mulOffset)+']']])
+
         # Eg from derivative method
         if (not self.attributeEqual('_popt')
-            and self.attributeEqual('_fitfunc', 'bandgapDeriv_savgol')):
+                and self.attributeEqual('_fitfunc', 'bandgapDeriv_savgol')):
             out.append([None, 'Cannot update, must create a new one from '
-                        +'initial EQE curve', [], []])
+                        + 'initial EQE curve', [], []])
         elif self.attributeEqual('_popt'):
             xdata = self.x()
             try:
                 tmpmed = medfilt(self.y(), 5)
                 ROI = [xdata[np.argmax(tmpmed)], np.max(xdata)]
             except Exception:
-                ROI = [np.min(xdata), np.max(xdata)]
+                if len(xdata) > 0:
+                    ROI = [np.min(xdata), np.max(xdata)]
+                else:
+                    ROI = [0, 0]
             out.append([self.CurveEQE_bandgapDeriv_print, 'Bandgap derivative',
-                        ['Savitsky Golay width', 'degree', 'nm range'], [5,2, roundSignificantRange(ROI,3)]])
-        # EQE current
-        if self.attributeEqual('_popt'):
-            out.append([self.currentCalc, 'EQE current', ['ROI', 'interpolate', 'spectrum'],
-                        [[min(self.x()), max(self.x())], 'linear', self.EQE_AM15_REFERENCE.replace('.txt','')], {},
-                        [{'width': 15},
-                         {'width': 8, 'field':'Combobox', 'values':['linear', 'quadratic', 'cubic']},
-                         {'width': 8, 'field':'Combobox', 'values':[self.EQE_AM15_REFERENCE.replace('.txt',''), self.EQE_AM0_REFERENCE.replace('.txt','')]}]])
-        # EQE 20.4%
-        if self.attributeEqual('_popt'):
-            out.append([self.CurveEQE_Empa20p4, self.EQE_BEST_CELL_LABEL, [], []])
+                        ['Savitsky Golay width', 'degree', 'nm range'],
+                        [5, 2, roundSignificantRange(ROI, 3)]])
+
         # tauc (E*ln(1-EQE))**2
         if (not self.attributeEqual('_popt')
-            and self.attributeEqual('_fitfunc', 'func_bandgapTaucCurveLog')):
+                and self.attributeEqual('_fitfunc', 'func_bandgapTaucCurveLog')):
             out.append([self.updateFitParam, 'Update fit', ['Eg', 'slope'],
-                        roundSignificant(self.getAttribute('_popt'),5)])
+                        roundSignificant(self.attr('_popt'), 5)])
         elif self.attributeEqual('_popt'):
-            mulOffset = self.getAttribute('mulOffset', default=1)
+            mulOffset_suf = ' [%]' if mulOffset == 100 else ''
             out.append([self.CurveEQE_bandgapLog_print,
-                        'Bandgap fit Tauc (eV*ln(1-EQE))^2', ['Range EQE'],
-                    ['['+str(0.30*mulOffset)+', '+str(0.88*mulOffset)+']']])
+                        'Bandgap fit Tauc (eV*ln(1-EQE))^2',
+                        ['Range EQE'+mulOffset_suf],
+                        ['['+str(0.30*mulOffset)+', '+str(0.88*mulOffset)+']']])
+        
+        # EQE current
+        if self.attributeEqual('_popt'):
+            fnames = [self.EQE_AM15_REFERENCE_FILE.replace('.txt', ''),
+                      self.EQE_AM0_REFERENCE_FILE.replace('.txt', '')]
+            if len(self.x()) > 0:
+                mM = [min(self.x()), max(self.x())]
+            else:
+                mM = [0, 0]
+            line = FuncGUI(self.currentCalc, 'EQE current', hiddenvars={'ifGUI': True})
+            line.append('ROI [nm]', mM, options={'width': 15})
+            line.append('interpolation', 'linear',
+                        options={'width': 8, 'field': 'Combobox', 'values': ['linear', 'quadratic', 'cubic']})
+            line.append('', '', widgetclass='Frame')
+            line.append('          spectrum', fnames[0], options={'width': 15, 'field': 'Combobox', 'values': fnames})
+            line.append('integrated current as curve', False, options={'field': 'Checkbutton'})
+            out.append(line)
+
+        # reference spectra - 20.4%, 20.8%, etc.
+        refs = self._referenceEQESpectra()
+        lbls = [curve.attr('label') for curve in refs]
+        out.append([self.referenceEQESpectrum, 'Add', ['reference spectrum'],
+                   [lbls[0]], {},
+                   [{'field': 'Combobox', 'width': 25, 'values': lbls}]])
+
         # Urbach fitting
         if self.attributeEqual('_popt'):
-            try: # Urbach fitting
+            try:  # Urbach fitting
                 from grapa.datatypes.curveArrhenius import CurveArrheniusExpDecay
                 try:
                     x0 = 1 + np.where(list(reversed(self.y() > 0.1)))[0][0]
                 except IndexError:
                     x0 = 1
                 try:
                     x1 = 1 + np.where(list(reversed(self.y() > 8e-4)))[0][0]
                 except IndexError:
                     x1 = len(self.x())
                 x0, x1 = self.shape()[1] - x0, self.shape()[1] - x1
-                ROI = [self.x(index=x0, alter='nmeV'), self.x(index=x1, alter='nmeV')]
+                if len(self.x()) > 0:
+                    ROI = [self.x(index=x0, alter='nmeV'),
+                           self.x(index=x1, alter='nmeV')]
+                else:
+                    ROI = [0, 0]
                 ROI.sort()
                 ROI = roundSignificantRange(ROI, 3)
-                mulOffset = self.getAttribute('mulOffset', 1)
+                mulOffset = self.attr('mulOffset', 1)
                 out.append([self.CurveUrbachEnergy,
                             CurveArrheniusExpDecay.BUTTONFitLabel(),
                             [CurveArrheniusExpDecay.BUTTONFitROI()], [ROI]])
             except ImportError as e:
-                print('WARNING CurveEQE: do not find grapa.datatypes.curveArrhenius.')
+                print('WARNING CurveEQE: do not find',
+                      'grapa.datatypes.curveArrhenius.')
                 print(type(e), e)
+
         # ERE external radiative efficiency
         if self.attributeEqual('_popt'):
             Emin, unit = self.ERE_EminAuto()
             out.append([self.ERE_GUI, 'ERE external radiative eff.',
                         ['cell Voc', 'T', 'cut data', ''],
                         ['0.700', 273.15+25, Emin, unit],
                         {},
-                        [{'width':6}, {'width':7}, {'width':7},
-                         {'field': 'Combobox', 'values': ['nm', 'eV'], 'width':4}]])
+                        [{'width': 6}, {'width': 7}, {'width': 7},
+                         {'field': 'Combobox', 'values': ['nm', 'eV'], 'width': 4}]])
+
         # Absortion edge (CdS, etc)
         if self.attributeEqual('_popt'):
-            out.append([self.CurveEQE_absorptionEdge, 'Quick & dirty CdS estimate',
+            out.append([self.CurveEQE_absorptionEdge,
+                        'Quick & dirty CdS estimate',
                         ['thickness [nm]', 'I0', 'material'],
-                        [50, 1.0, 'CdS'],
-                        {},
-                        [{'width':6}, {'width':7}, {'width':7}]])
+                        [50, 1.0, 'CdS'], {},
+                        [{'width': 6}, {'width': 7}, {'width': 7}]])
         if (not self.attributeEqual('_popt')
-            and self.attributeEqual('_fitfunc', 'func_absorptionedge')):
+                and self.attributeEqual('_fitfunc', 'func_absorptionedge')):
             out.append([self.updateFitParam, 'Update fit',
-                        ['thickness [nm]', 'I0', 'material'], self.attr('_popt')])
+                        ['thickness [nm]', 'I0', 'material'],
+                        self.attr('_popt')])
+
         # Help button!
         out.append([self.printHelp, 'Help!', [], []])
         return out
-    
+
     def alterListGUI(self):
         out = Curve.alterListGUI(self)
         out.append(['nm <-> eV', ['nmeV', ''], ''])
         out.append(['Tauc plot', ['nmeV', 'tauc'], ''])
         if (not self.attributeEqual('_popt')
-            and self.attributeEqual('_fitfunc', 'func_bandgapTaucCurveLog')):
-            out.append(['Tauc plot (E ln(1-EQE)^2)', 
+                and self.attributeEqual('_fitfunc', 'func_bandgapTaucCurveLog')):
+            out.append(['Tauc plot (E ln(1-EQE)^2)',
                         ['nmeV', 'taucln1-eqe'], ''])
         return out
 
-
-
     def updateFitParamFormatPopt(self, f, param):
         """ override, for func_absorptionedge """
         if f == 'func_absorptionedge':
-            return list(param) # not np.array: last parameter can be str
+            return list(param)  # not np.array: last parameter can be str
         return Curve.updateFitParamFormatPopt(self, f, param)
 
-
     # FUNCTIONS RELATED TO FIT
-
-    def bandgapFromTauc(self, nm, EQE, yLim=[.25, .70], xLim=[600, 1500],
-                        mode='EQE') :
+    def bandgapFromTauc(self, nm, EQE, yLim=[.25, .70], xLim=[600, 1500], mode='EQE'):
         """
         Performs fit of low-energy side of EQE and returns [bandgap, slope].
         Executed at initialization.
         mode: 'EQE', or 'ln1-EQE'
         """
-        if max(EQE) > 10 :
-            print ('Function bandgapFromTauc: max(EQE) > 1. Multiplied by 0.01'
-                   + ' for datapoint selection.')
+        if max(EQE) > 10:
+            print('Function bandgapFromTauc: max(EQE) > 1. Multiplied by',
+                  '0.01 for datapoint selection.')
             EQE = EQE * 0.01
         # select suitable data range
         mask = np.ones(len(nm), dtype=bool)
-        for i in reversed(range (len (mask))) :
+        for i in reversed(range(len(mask))):
             if (EQE[i] < yLim[0] or EQE[i] > yLim[1] or nm[i] < xLim[0]
-                or nm[i] > xLim[1]):
+                    or nm[i] > xLim[1]):
                 mask[i] = False
         nm = nm[mask]
         EQE = EQE[mask]
         # perform fit
         eV = Curve.NMTOEV / nm
         tauc = (eV * np.log(1-EQE))**2 if mode == 'log1-EQE' else (eV * EQE)**2
-        if len (tauc > 1):
+        if len(tauc > 1):
             z = np.polyfit(eV, tauc, 1, full=True)[0]
-            bandgap = -z[1]/z[0] #p = np.poly1d(z)
+            bandgap = -z[1]/z[0]  # p = np.poly1d(z)
             return [bandgap, z[0]]
-        #print ('Function bandgapFromTauc: not enough suitable datapoints.')
+        # print ('Function bandgapFromTauc: not enough suitable datapoints.')
         return [np.nan, np.nan]
-    
+
     def CurveEQE_bandgap_print(self, yLim=None):
         out = self.CurveEQE_bandgap(yLim=yLim)
-        print ('Bandgap (Tauc (E*EQE)^2):',
-               roundSignificant(out.getAttribute('_popt')[0],4), 'eV')
+        print('Bandgap (Tauc (E*EQE)^2):',
+              roundSignificant(out.attr('_popt')[0], 4), 'eV')
         return out
+
     def CurveEQE_bandgap(self, yLim=None):
         if yLim is None:
             yLim = [.25, .70]
         try:
-            yLim = np.array(yLim) / self.getAttribute('mulOffset', default=1)
+            yLim = np.array(yLim) / self.attr('mulOffset', default=1)
             bandgap = self.bandgapFromTauc(self.x(), self.y(), yLim=yLim)
-        except:
+        except Exception:
             pass
         x = self.x()
         nm = np.arange(min(x), max(x), (max(x)-min(x))/1000)
         fit = self.func_bandgapTaucCurve(nm, *bandgap)
         return CurveEQE([nm, fit],
-                {'_popt': bandgap, '_fitFunc': 'func_bandgapTaucCurve',
-                 'color': 'k', 'data filename': self.getAttribute('filename'), 
-                 'muloffset': self.getAttribute('mulOffset', default=1)})
+                        {'_popt': bandgap, '_fitFunc': 'func_bandgapTaucCurve',
+                         'color': 'k', 'data filename': self.attr('filename'),
+                         'muloffset': self.attr('mulOffset', 1)})
+
     def func_bandgapTaucCurve(self, nm, *bandgap):
         z = [bandgap[1], -bandgap[0]*bandgap[1]]
         p = np.poly1d(z)
         fit = p(Curve.NMTOEV / nm)
         for i in range(len(fit)):
-            if fit[i] >=0:
+            if fit[i] >= 0:
                 fit[i] = np.sqrt(fit[i]) / (Curve.NMTOEV / nm[i])
             else:
                 fit[i] = np.nan
         return fit
-  
+
     def CurveEQE_bandgapLog_print(self, yLim=None):
         out = self.CurveEQE_bandgapLog(yLim=yLim)
-        print ('Bandgap (Tauc (E*ln(1-EQE))^2):',
-               roundSignificant(out.getAttribute('_popt')[0],4), 'eV')
+        print('Bandgap (Tauc (E*ln(1-EQE))^2):',
+              roundSignificant(out.attr('_popt')[0], 4), 'eV')
         return out
+
     def CurveEQE_bandgapLog(self, yLim=None):
         if yLim is None:
             yLim = [.25, .70]
         try:
-            yLim = np.array(yLim) / self.getAttribute('mulOffset', default=1)
+            yLim = np.array(yLim) / self.attr('mulOffset', default=1)
             bandgap = self.bandgapFromTauc(self.x(), self.y(), yLim=yLim,
                                            mode='log1-EQE')
-        except:
+        except Exception:
             pass
         x = self.x()
         nm = np.arange(min(x), max(x), (max(x)-min(x))/1000)
         fit = self.func_bandgapTaucCurveLog(nm, *bandgap)
         return CurveEQE([nm, fit],
                         {'_popt': bandgap,
-                        '_fitFunc': 'func_bandgapTaucCurveLog', 'color': 'k',
-                        'data filename': self.getAttribute('filename'),
-                       'muloffset': self.getAttribute('mulOffset', default=1)})
+                         '_fitFunc': 'func_bandgapTaucCurveLog', 'color': 'k',
+                         'data filename': self.attr('filename'),
+                         'muloffset': self.attr('mulOffset', default=1)})
+
     def func_bandgapTaucCurveLog(self, nm, *bandgap):
         z = [bandgap[1], -bandgap[0]*bandgap[1]]
         p = np.poly1d(z)
         fit = p(Curve.NMTOEV / nm)
         for i in range(len(fit)):
-            if fit[i] >=0:
+            if fit[i] >= 0:
                 fit[i] = 1 - np.exp(- np.sqrt(fit[i]) / (Curve.NMTOEV/nm[i]))
             else:
                 fit[i] = np.nan
         return fit
 
-
+    # bandgap derivative
     def bandgapDeriv(self, SGwidth=None, SGdegree=None, x_y_savgol=None, ROI=None):
         """
         Computes the bandgap based on the savitsky golay derivative,
         with a gaussian fit to the highest values
         SGwidth: 5. Parameters of Savitsky Golay filtering
         SGdegree: 3
         x_y_savgol (optional) to avoid calculating twice if already computed
             somewhere else
         """
         # need dummy x argument to use the updateFitParam method
         from scipy.optimize import curve_fit
         if x_y_savgol is None:
-            x_, y_, savgol = self.bandgapDeriv_savgol(SGwidth, SGdegree, ROI=ROI)
+            x_, y_, savgol = self.bandgapDeriv_savgol(SGwidth, SGdegree,
+                                                      ROI=ROI)
         else:
             x_, y_, savgol = x_y_savgol
         order = True if x_[1] > x_[0] else False
         # locate max, fit gaussian around location of max
         iMax_ = np.argmax(savgol)
         ROIfit = range(max(0, iMax_-1 - int(not order)),
                        min(len(savgol), iMax_+2 + int(order)))
         datax, datay = x_[ROIfit], savgol[ROIfit]
         p0 = [savgol[iMax_], x_[iMax_], 2*(datax[1]-datax[0])]
+
         def func_gaussSimple(x, a, x0, sigma):
-            return a * np.exp( - (x-x0)**2 / (2*sigma**2))
-        popt, pcov = curve_fit(func_gaussSimple, datax, datay, p0=p0)
+            return a * np.exp(- (x - x0)**2 / (2 * sigma**2))
+
+        try:
+            popt, pcov = curve_fit(func_gaussSimple, datax, datay, p0=p0)
+        except Exception as e:
+            print('Exception CurveEQE.bandgapDeriv. Provided to curve_fit',
+                  'length x', len(datax), 'length y', len(datay), ', p0', p0)
+            print(type(e), e)
+            popt = [np.nan, np.nan, np.nan]
         self.update({'bandgapDeriv': Curve.NMTOEV/popt[1]})
         return popt
+
     def bandgapDeriv_savgol(self, SGwidth=None, SGdegree=None, ROI=None):
         """ returns a reduced x,y range and the savitsky golay derivative """
         from scipy.signal import savgol_filter
         if SGwidth is None:
             SGwidth = 5
         if SGdegree is None:
             SGdegree = 2
         SGdegree = int(SGdegree)
         SGwidth = int(SGwidth)
         if SGdegree >= SGwidth:
-            print('Curve EQE bandgap derivative: degree must be lower than width for Savitsky-Golay filtering.')
+            print('Curve EQE bandgap derivative: degree must be lower than',
+                  'width for Savitsky-Golay filtering.')
             return None, None, None
         if SGwidth % 2 == 0:
-            print('Curve EQE bandgap derivative: width must be odd for Savitsky-Golay filtering.')
+            print('Curve EQE bandgap derivative: width must be odd for',
+                  'Savitsky-Golay filtering.')
             return None, None, None
-        #compute derivative
+        # compute derivative
         x, y = self.x(), self.y()
         if len(x) < 5:
             print('Not enough datapoints, cannot continue with processing.')
             return False
         # determines if sorted asc. or desc. Do NOT check if not monotoneous
         order = True if x[1] > x[0] else False
         # data selection - up to EQE maximum
         iMax = np.argmax(y)
         if ROI is None:
             if order:
-                ROI_ = range(max(0,iMax-2), len(y))
+                ROI_ = range(max(0, iMax - 2), len(y))
             else:
-                ROI_ = range(0, min(iMax+2, len(y)))
+                ROI_ = range(0, min(iMax + 2, len(y)))
         else:
             ROI_ = (x >= min(ROI)) * (x <= max(ROI))
         x_, y_, eV = x[ROI_], y[ROI_], Curve.NMTOEV / x[ROI_]
         # locate peak using Savitsky Golay filtering; then correct for possible
         # uneven data point spacing
         savgol = savgol_filter(y_, SGwidth, SGdegree, deriv=1)
-        savgol /= np.append(np.append(eV[1]-eV[0], (eV[2:]-eV[:-2])/2),
-                                      eV[-1]-eV[-2])
+        savgol /= np.append(np.append(eV[1] - eV[0], (eV[2:] - eV[:-2]) / 2),
+                            eV[-1] - eV[-2])
         return x_, y_, savgol
+
     def CurveEQE_bandgapDeriv_print(self, SGwidth=None, SGdegree=None, ROI=None):
-        out = self.CurveEQE_bandgapDeriv(SGwidth=SGwidth, SGdegree=SGdegree, ROI=ROI)
-        print ('Bandgap (derivative):',
-               roundSignificant(out.getAttribute('bandgapDeriv'), 4), 'eV')
+        out = self.CurveEQE_bandgapDeriv(SGwidth=SGwidth, SGdegree=SGdegree,
+                                         ROI=ROI)
+        print('Bandgap (derivative):',
+              roundSignificant(out.attr('bandgapDeriv'), 4), 'eV')
         return out
+
     def CurveEQE_bandgapDeriv(self, SGwidth=None, SGdegree=None, ROI=None):
         """ returns the curve, with correspoding bandgap in the attributes """
         x_, y_, savgol = self.bandgapDeriv_savgol(SGwidth=SGwidth,
                                                   SGdegree=SGdegree, ROI=ROI)
         popt = self.bandgapDeriv(SGwidth=SGwidth, SGdegree=SGdegree,
-                                 x_y_savgol=[x_,y_,savgol])
+                                 x_y_savgol=[x_, y_, savgol])
         out = CurveEQE([x_, savgol],
                        {'color': 'k', '_popt': [SGwidth, SGdegree],
-                       'bandgapDeriv': Curve.NMTOEV/popt[1],
-                       '_fitFunc': 'bandgapDeriv_savgol',
-                       'data filename': self.getAttribute('filename')})
-        out.update({'muloffset': self.getAttribute('mulOffset', 1)*0.1})# , 'offset':-max(out.y())})
+                        'bandgapDeriv': Curve.NMTOEV/popt[1],
+                        '_fitFunc': 'bandgapDeriv_savgol',
+                        'data filename': self.attr('filename')})
+        out.update({'muloffset': self.attr('mulOffset', 1)*0.1})
+        # , 'offset':-max(out.y())})
         return out
 
+    # reference spectra
+    def referenceEQESpectrum(self, label=''):
+        """
+        label: the label of the reference spectrum to return
+        """
+        refs = self._referenceEQESpectra()
+        for curve in refs:
+            if curve.attr('label') == label:
+                return curve
+        print('CurveEQE referenceEQESpectrum: cannot find curve "', label, '"')
+        print('Labels available:', [curve.attr('label') for curve in refs])
+        return False
 
+    @classmethod
+    def _referenceEQESpectra(cls):
+        """ returns the reference EQE spectra """
+        if CurveEQE.EQE_REF_SPECTRA is None:
+            path = os.path.dirname(os.path.abspath(__file__))
+            refs = Graph(os.path.join(path, CurveEQE.EQE_REF_SPECTRA_FILE))
+            CurveEQE.EQE_REF_SPECTRA = refs
+        return CurveEQE.EQE_REF_SPECTRA
 
-    def CurveEQE_Empa20p4(self):
-        """ Returns the 20.4% Empa cell EQE. """
-        import os.path
-        from grapa.graph import Graph
-        path = os.path.dirname(os.path.abspath(__file__))
-        graph = Graph(os.path.join(path, self.EQE_BEST_CELL_REF), silent=True)
-        if graph.length() > 0:
-            return graph.curve(-1)
-        graph = Graph(self.EQE_BEST_CELL_REF, silent=True)
-        if graph.length() > 0:
-            return graph.curve(-1)
-        graph = Graph('_modules/'+self.EQE_BEST_CELL_REF, silent=True)
-        if graph.length() > 0:
-            return graph.curve(-1)
-        print ('Data file EQE Empa 20.4% not found!')
-
-
-
-    # other functions
     def CurveEQE_returnAM15referenceCurve(self):
-        """ returns AM1.5 reference spectrum """
-        import os.path
-        from grapa.graph import Graph
-        path = os.path.dirname(os.path.abspath(__file__))
-        ref = Graph(os.path.join(path, self.EQE_AM15_REFERENCE), silent=True)
-        if ref.length() > 0:
-            return ref.curve(1)
-        ref = Graph(self.EQE_AM15_REFERENCE, silent=True)
-        if ref.length() > 0:
-            return ref.curve(1)
-        ref = Graph('_modules/'+self.EQE_AM15_REFERENCE, silent=True)
-        if ref.length() > 0:
-            return ref.curve(1)
-        print('ERROR CurveEQE_returnAM15reference: cannot find reference file',
-              self.EQE_AM15_REFERENCE)
-        return 0
+        # mechanisms to load file only once and store output as class variable
+        if CurveEQE.EQE_AM15_REFERENCE is None:
+            path = os.path.dirname(os.path.abspath(__file__))
+            refs = Graph(os.path.join(path, CurveEQE.EQE_AM15_REFERENCE_FILE))
+            if len(refs) <= 1:
+                print('ERROR CurveEQE_returnAM15referenceCurve: cannot find',
+                      'reference file', self.EQE_AM15_REFERENCE_FILE)
+                return 0
+            CurveEQE.EQE_AM15_REFERENCE = refs[1]
+        return CurveEQE.EQE_AM15_REFERENCE
+
     def CurveEQE_returnAM0referenceCurve(self):
         """
         Returns AM0 reference spectrum.
         Data are in W/m2/um, returns spectral photon irradiance
         """
-        from grapa.graph import Graph
-        path = os.path.dirname(os.path.abspath(__file__))
-        ref = Graph(os.path.join(path, self.EQE_AM0_REFERENCE))
-        if ref.length() > 0:
-            # h * c / wavelength -> energy WL conversion in vacuum for AM0
-            energy = 6.62607004E-34 * 299792458 / (1e-9 * ref.curve(0).x())
-            irrad = ref.curve(0).y() / energy / 1000
-            return Curve([ref.curve(0).x(), irrad], {})
-        return False
-    
-    
-    
-    # other functions
+        if CurveEQE.EQE_AM0_REFERENCE is None:
+            path = os.path.dirname(os.path.abspath(__file__))
+            refs = Graph(os.path.join(path, CurveEQE.EQE_AM0_REFERENCE_FILE))
+            if refs.length() == 0:
+                print('ERROR CurveEQE_returnAM0referenceCurve: cannot find',
+                      'reference file', self.EQE_AM0_REFERENCE_FILE)
+                return 0
+            CurveEQE.EQE_AM0_REFERENCE = refs[0]
+        curve = CurveEQE.EQE_AM0_REFERENCE
+        # h * c / wavelength -> energy WL conversion in vacuum for AM0
+        energy = 6.62607004E-34 * 299792458 / (1e-9 * curve.x())
+        irrad = curve.y() / energy / 1000
+        return Curve([curve.x(), irrad], {})
+
     def _curveReference(self, file):
-        """ returns some reference spectrum """
+        """
+        Returns some reference spectrum (spectral photon irradiance)
+        file: the user can specify its own file
+        """
         if file.endswith('.txt'):
             file = file[:-4]
-        if file == 'AM1-5_Ed2-2008':
+        if file == self.EQE_AM15_REFERENCE_FILE[:-4]:
             return self.CurveEQE_returnAM15referenceCurve()
-        if file == 'AM0_2000_ASTM_E-490-00':
+        if file == self.EQE_AM0_REFERENCE_FILE[:-4]:
             return self.CurveEQE_returnAM0referenceCurve()
-        import os.path
-        from grapa.graph import Graph
+        # maybe a custom input ?
         path = os.path.dirname(os.path.abspath(__file__))
         ref = Graph(os.path.join(path, file), silent=True)
         if ref.length() > 0:
             return ref.curve(0)
-        print('ERROR CurveEQE._curveReference: cannot find reference file', file)
+        print('ERROR CurveEQE._curveReference: cannot find reference file',
+              file)
         return False
-    
-    
-    
-    def currentCalc(self, ROI=None, interpolatekind='linear',
-                    spectralPhotonIrrad=None, silent=False):
+
+    # current calc
+    def currentCalc(self, ROI=None, interpolatekind='linear', spectralPhotonIrrad=None, showintegratedcurrent=False, silent=False, ifGUI=False):
         """
         Computes the current EQE current using AM1.5 spectrum.
         Assumes the EQE vales are in range [0,1] and NOT [0,100].
         ROI: [nm_min, nm_max]
         interpolatekind: order for interpolation of EQE data. default 'linear'.
-        refSpectrum: by default AM1.5G; otherwise filename in folder datatypes
+        spectralPhotonIrrad: filename in folder datatypes.
+            By default will use AM1.5G.
+        ifGUI: True will print the value, False will return the value.
         """
         if spectralPhotonIrrad is None:
-            spectralPhotonIrrad = CurveEQE.EQE_AM15_REFERENCE
+            spectralPhotonIrrad = CurveEQE.EQE_AM15_REFERENCE_FILE
         refIrrad = self._curveReference(spectralPhotonIrrad)
         if not refIrrad:
             print('Error CurveEQE currentCalc, cannot find reference spectrum',
                   spectralPhotonIrrad)
             return
         ROIdef = [min(self.x()), max(self.x())]
         if ROI is None:
@@ -534,194 +517,211 @@
         else:
             ROI = [max(ROIdef[0], ROI[0]), min(ROIdef[1], ROI[1])]
         # localize range of interest
         refROI = (refIrrad.x() >= ROI[0]) * (refIrrad.x() <= ROI[1])
         refDataX = refIrrad.x()[refROI]
         refDataY = refIrrad.y()[refROI]
         # interpolate data on ref x sampling
-        # spline interpolation degree 1
+        # -> implicitely assuming sampling with more datapoints in ref than in data
         f = interpolate.interp1d(self.x(), self.y(), kind=interpolatekind)
         interpData = f(refDataX)
         # compute final spectrum
         finalSpectrum = refDataY * interpData
         # integriere QE*spektrum (auf gewhltem range)
         Jo = np.trapz(finalSpectrum, refDataX)
-        EQEcurrent = Jo*1.602176487E-19/10
-        if not silent:
-            print('Curve', self.getAttribute('label'), 'EQE current:', 
-                  EQEcurrent, 'mA/cm2')
+        EQEcurrent = Jo * 1.602176487E-19 / 10
+        if not silent or ifGUI:
+            print('Curve', self.attr('label'), 'EQE current:', EQEcurrent, 'mA/cm2')
+        # return curve with integrated current
+        if showintegratedcurrent:
+            cumsum = [0]
+            for i in range(1, len(finalSpectrum)):
+                cumsum.append(cumsum[-1] + (finalSpectrum[i]+finalSpectrum[i-1])/2 * (refDataX[i] - refDataX[i-1]))
+            cumsum = np.array(cumsum) * 1.602176487E-19 / 10
+            color = self.attr('color', '')
+            if color == '':
+                color = 'k'
+            curvecumsum = Curve([refDataX, cumsum], {'color': 'k' })
+            curvecumsum.update({'label': self.attr('label') + ' cumulative EQE current',
+                                'ax_twinx': True, 'color': color})
+            return curvecumsum
+        if ifGUI:
+            return True
         return EQEcurrent
-        
-    
-        
+
+    # Urbach energy
     def CurveUrbachEnergy(self, ROIeV):
         """ Return fit in a Curve object, giving Urbach energy decay """
         from grapa.datatypes.curveArrhenius import CurveArrhenius, CurveArrheniusExpDecay
         ROIeV.sort()
         curve = CurveArrhenius(self.data, CurveArrheniusExpDecay.attr)
         out = curve.CurveArrhenius_fit(ROIeV)
         out.update(self.getAttributes(['offset', 'muloffset']))
         return out
-        
-        
-    
+
+    # ERE
     def ERE(self, Voc, T, Emin='auto', EminUnit='nm'):
         """
-        Computes the External Radiative Efficiency from the EQE curve and the cell
-        Voc.
+        Computes the External Radiative Efficiency from the EQE curve and the
+        cell Voc.
         Returns ERE, and a Curve with the integrand
         Parameters:
         - Voc: cell Voc voltage in [V]
         - T: temperature in [K]
         - Emin: min E on which the integral is computed.
             Can be given in eV or in nm, see Eminunit.
         - Eminunit: 'eV' if Emin is given in eV, 'nm' otherwise. Default 'nm'
         """
-        # does not matter if EQE is [0,1] or [0,100], this is corrected by the 
+        # does not matter if EQE is [0,1] or [0,100], this is corrected by the
         # calculation of Jsc (beware the day Jsc is patched!)
         import scipy.integrate as integrate
-        CST_q = 1.602176634e-19 # elemental charge [C]
-        CST_h = 6.62606979e-34 # Planck [J s]
-        CST_c = 299792458 # speed of light [m s-1]
-        CST_kb= 1.38064852e-23 # [J K-1]
+        CST_q = 1.602176634e-19  # elemental charge [C]
+        CST_h = 6.62606979e-34  # Planck [J s]
+        CST_c = 299792458  # speed of light [m s-1]
+        CST_kb = 1.38064852e-23  # [J K-1]
         # variables check
         if Emin == 'auto':
             Emin, EminUnit = self.ERE_EminAuto()
         if EminUnit != 'eV':
             EminUnit = 'nm'
         if Emin != 'auto' and EminUnit == 'nm':
-            Emin = Curve.NMTOEV / Emin # convert nm into eV
-       # retrieve data
+            Emin = Curve.NMTOEV / Emin  # convert nm into eV
+        # retrieve data
         nm, EQE = self.x(), self.y()
-        E = Curve.NMTOEV / nm * CST_q # photon energy [J]
-        Jsc = self.currentCalc(silent=True) * 10 # [A m-2] instead of [mA cm-2]
+        E = Curve.NMTOEV / nm * CST_q  # photon energy [J]
+        Jsc = self.currentCalc(silent=True) * 10  # [A m-2] instead of [mAcm-2]
         # mask for integration
         mask = (E >= Emin * CST_q) if Emin != 'auto' else (E > 0)
         # start computing the expression
-        integrand = EQE * E**2 / (np.exp(E / (CST_kb * T)) - 1) # [J2]
-        integral = np.abs(integrate.trapz(integrand[mask], x=E[mask])) # [J3]
-        ERE  = 2 * np.pi * CST_q / CST_h**3 / CST_c**2 / Jsc # [J-3]
-        ERE *= np.exp(CST_q * Voc / CST_kb / T) # new term unitless
-        ERE *= integral # output [unitless]
-        lbl = ['ERE integrand to '+self.getAttribute('label'), '', 'eV$^2$']
+        integrand = EQE * E**2 / (np.exp(E / (CST_kb * T)) - 1)  # [J2]
+        integral = np.abs(integrate.trapz(integrand[mask], x=E[mask]))  # [J3]
+        ERE = 2 * np.pi * CST_q / CST_h**3 / CST_c**2 / Jsc  # [J-3]
+        ERE *= np.exp(CST_q * Voc / CST_kb / T)  # new term unitless
+        ERE *= integral  # output [unitless]
+        lbl = ['ERE integrand to '+self.attr('label'), '', 'eV$^2$']
         return ERE, Curve([nm[mask], integrand[mask]/(CST_q)**2],
                           {'label': Graph().formatAxisLabel(lbl)})
+
     def ERE_GUI(self, Voc, T, Emin='auto', EminUnit='nm'):
         ERE, curve = self.ERE(Voc, T, Emin=Emin, EminUnit=EminUnit)
-        print('External radiative efficiency estimate:', "{:.2E}".format(ERE), '(input Voc:', Voc, ')')
-        curve.update({'ax_twinx':1, 'color': 'k'})
+        print('External radiative efficiency estimate:',
+              "{:.2E}".format(ERE), '(input Voc:', Voc, ')')
+        curve.update({'ax_twinx': 1, 'color': 'k'})
         return curve
+
     def ERE_EminAuto(self):
         # smart Emin autodetect
         nm, EQE = self.x(), self.y()
         try:
-            nmMax = np.max(nm[(EQE > 0.5*np.max(EQE))]) # identify nm where EQE = 0.5
-        except: # no suitable point
+            # identify nm where EQE = 0.5
+            nmMax = np.max(nm[(EQE > 0.5*np.max(EQE))])
+        except Exception:  # no suitable point
             return [0, 'nm']
         mask = (nm > nmMax) * (EQE > 0)
         nm_, EQElog = nm[mask], np.log10(EQE[mask])
         E = Curve.NMTOEV / nm_
         # sort nm & EQE in ascending nm order
         EQElog = EQElog[nm_.argsort()]
         nm_.sort()
-        diff = (EQElog[1:] - EQElog[:-1]) / (E[1:] - E[:-1]) # d/dE log(EQE)
+        diff = (EQElog[1:] - EQElog[:-1]) / (E[1:] - E[:-1])  # d/dE log(EQE)
         nfault = 0
-        Emin = np.max(nm) + 1 # by default, just below lowest point
+        Emin = np.max(nm) + 1  # by default, just below lowest point
         for i in range(1, len(diff)):
-            if diff[i] < np.min(diff[:i]) * 0.5: # 0.5 can be adjusted
-                nfault += 1 # or another algorithm implemented
+            if diff[i] < np.min(diff[:i]) * 0.5:  # 0.5 can be adjusted
+                nfault += 1  # or another algorithm implemented
             if nfault > 1 or diff[i] < 0:
                 Emin = roundSignificantRange([np.mean(nm_[i:i+2]), nm_[i]], 2)[0]
     #    graph2 = Graph([(0.5*(nm_[:-1]+nm_[1:])), diff])
     #    graph2.curve(0).update({'linespec': '-x'})
     #    graph2.plot()
         return [Emin, 'nm']
 
-
-
-    # Layer thickness estiamte (e.g. CdS)
+    # Quick & dirty calculation Layer thickness estiamte (e.g. CdS)
     def _materialRefractivek(self, material):
         """
-        Returns imaginary part of refractive index of CdS, k 
+        Returns imaginary part of refractive index of CdS, k
         Energy to be given in nm
         """
         from grapa.graph import Graph
         path = os.path.dirname(os.path.abspath(__file__))
-        matclean = 'EQE_absorption_' + material.replace('/','').replace('\\','') + '.txt'
+        matclean = 'EQE_absorption_' + material.replace('/', '').replace('\\', '') + '.txt'
         pathtest = os.path.join(path, matclean)
         if os.path.exists(pathtest):
             return Graph(pathtest)[0]
         try:
             # try open the file, and return first Curve assumed to be (nm, k)
             return Graph(material)[0]
         except Exception as e:
-            print('CurveEQE._materialRefractivek: please choose a material, or')
-            print('a file with (nm,k) data as 2-column. Input:', material)
+            print('CurveEQE._materialRefractivek: please choose a material, ',
+                  'or a file with (nm,k) data as 2-column. Input:', material)
             print('Exception', type(e), e)
             return False
         return False
+
     def func_absorptionedge(self, nm, thickness, I0, material='CdS'):
-        try: # check parameters are numeric
+        try:  # check parameters are numeric
             thickness, I0 = float(thickness), float(I0)
         except ValueError:
-            print('CurveEQE.func_absorptionedge: Did you really enter thickness and I0 as float?')
+            print('CurveEQE.func_absorptionedge: Did you really enter',
+                  'thickness and I0 as float?')
             return False
         k = self._materialRefractivek(material)
         if not k:
             return False
-        alpha = 4 * np.pi * k.y() / (k.x() * 1e-7) # in cm-1
+        alpha = 4 * np.pi * k.y() / (k.x() * 1e-7)  # in cm-1
         transmitted = I0 * np.exp(-alpha * thickness * 1e-7)
-        f = interpolate.interp1d(k.x(), transmitted, kind='linear', bounds_error=False)
+        f = interpolate.interp1d(k.x(), transmitted, kind='linear',
+                                 bounds_error=False)
         return f(nm)
+
     def CurveEQE_absorptionEdge(self, thickness, I0, material='CdS'):
         """
         Returns a Curve for quick-and-dirty estimate layer thickness, e.g. CdS.
-        Curve represents the light transmitted through the layer and is computed
-        from Beer-Lambert law as I0 * exp(-alpha * thickness),
+        Curve represents the light transmitted through the layer and is
+        computed from Beer-Lambert law as I0 * exp(-alpha * thickness),
         with alpha computed from k imaginary refractive index of material.
         thickness: layer thickness, in nm
         I0: amount of light entering the layer. Default: 1
         material: data  provided for 'CdS'. A file path might be provided,
             storing k data in 2-column file (nm, k)
         """
         values = self.func_absorptionedge(self.x(), thickness, I0, material)
         return CurveEQE([self.x(), values],
-                         {'_fitfunc': 'func_absorptionedge',
-                          '_popt':[thickness, I0, material],
-                          'muloffset': self.attr('muloffset')})
-        
-    
-    
+                        {'_fitfunc': 'func_absorptionedge',
+                         '_popt': [thickness, I0, material],
+                         'muloffset': self.attr('muloffset')})
+
+    # Help
     def printHelp(self):
         print('*** *** ***')
         print('CurveEQE offer basic treatment of (external) quantum')
         print('efficiency of solar cells.')
         print('Input units should be [nm] and [0-1] (if needed, CurveSpectrum')
         print('can convert [eV] in [nm]).')
         print('Curve transforms:')
         print(' - nm <-> eV: switches the horizontal axis from nm to eV.')
         print(' - Tauc plot: displays (eV*EQE)^2 vs eV. The corresponding')
         print('   Tauc fit is a straight line.')
         print(' - (optional) Tauc plot (E ln(1-EQE)^2): only appears if a ')
-        print( '  Curve was fitted with the corresponding formula.')
+        print('   Curve was fitted with the corresponding formula.')
         print('Analysis functions:')
         print(' - Bandgap fit Tauc (eV*EQE)^2: fit the bandgap with the')
         print(' indicated formula. Parameters:')
         print('   Range EQE: select data with EQE value in indicated range.')
         print(' - Bandgap derivative: determines the bandgap following the')
         print('   derivative approach. The derivative dEQE/dE is used instead')
         print('   of dEQE/dlambda as the resulting curve is often more')
         print('   symmetric. The algorithm computes the derivative with the')
         print('   Savitsky-Golay algorithm. Parameters:')
         print('   Savitsky Golay width, and degree: width should be odd, and')
         print('      degree must be between 1 and width. By default 5, 2.')
         print('      With parameters 3, 1 ones retrieves the symmetrical')
         print('      discrete difference (y_1+1 - y_i-1)  / (x_i+1 - x_i-1).')
         print(' - EQE current: integration of the product of the EQE with the')
-        print('   reference AM1.5 solar spectrum '+self.EQE_AM15_REFERENCE+'.')
+        print('   reference AM1.5 solar spectrum '+self.EQE_AM15_REFERENCE_FILE+'.')
         print('   The code is similar to that of CurrentCalc matlab code.')
         print(' - Bandgap fit Tauc (eV*ln(1-EQE))^2: fits the bandgap with')
         print('   the indicated formula. In principle more exact, however')
         print('   highly sensitive to reflective and collection losses. Less')
         print('   robust than (eV*EQE)^2. Parameters:')
         print('   Range EQE: select data with EQE value in indicated range.')
         print(' - Urbach energies from fit to exponential decay.')
@@ -738,9 +738,7 @@
         print('   thickness, e.g. CdS. The light transmitted is computed from')
         print('   Beer-Lambert law I0*exp(-alpha*thickness).')
         print('   thickness: layer thickness, in nm')
         print('   I0: amount of light entering the layer. Default: 1')
         print('   material: data provided for "CdS". Custom 2-column files')
         print('      might be provided (nm, k).')
         return True
-
-
```

### Comparing `grapa-0.5.4.8/grapa/datatypes/curveJscVoc.py` & `grapa-0.6.1.0/grapa/datatypes/curveJscVoc.py`

 * *Files 5% similar despite different names*

```diff
@@ -11,75 +11,83 @@
 
 from grapa.graph import Graph
 from grapa.graphIO import GraphIO
 from grapa.curve import Curve
 from grapa.mathModule import is_number, roundSignificant, roundSignificantRange
 
 
-
 class GraphJscVoc(Graph):
-    
+
     FILEIO_GRAPHTYPE = 'Jsc-Voc curve'
-    
+
     AXISLABELS = [['Voc', '', 'V'], ['Jsc', '', 'mA cm$^{-2}$']]
-    
+
     @classmethod
     def isFileReadable(cls, fileName, fileExt, line1='', line2='', line3='', **kwargs):
-        if fileExt == '.txt' and fileName[:7] == 'JscVoc_' and line1[:14] == 'Sample name: 	':
-           return True # can open this stuff
+        if (fileExt == '.txt' and fileName[:7] == 'JscVoc_'
+                and line1[:14] == 'Sample name: 	'):
+            return True  # can open this stuff
         return False
-    
+
     def readDataFromFile(self, attributes, **kwargs):
         le = self.length()
         GraphIO.readDataFromFileGeneric(self, attributes, **kwargs)
         # expect 3 columns data
         self.castCurve(CurveJscVoc.CURVE, le, silentSuccess=True)
         # remove strange characters from attributes keys
         attr = self.curve(le).getAttributes()
         dictUpd = {}
         for key in attr:
-            if key.replace('', '2').replace('','2') != key:
-                dictUpd.update({key.replace('', '2').replace().replace('','2'): attr[key]})
+            if '' in key or '' in key:
+                dictUpd.update({key.replace('', '2').replace('', '2').replace('', '2'): attr[key]})
                 dictUpd.update({key: ''})
-        self.curve(le).update(dictUpd)
-        self.curve(le).update({'type': 'scatter', 'cmap': [[0,0,1], [1,0.43,0]], 'markeredgewidth': 0})
-        lbl = self.getAttribute('label').replace('JscVoc ','').replace('','2').replace(' Values Jsc [mA/cm2]','')
-        self.curve(le).update({'label': lbl})
-        self.curve(le+1).update({'type': 'scatter_c'})
-        #self.curve(le+1).swapShowHide() # hide T curve
+        self[le].update(dictUpd)
+        # remove strange characters from attributes values
+        for key in self[le].getAttributes():
+            val = self[le].attr(key)
+            if isinstance(val, str) and r'' in val:
+                self[le].update({key: val.replace(r'', '2')})
+        # cosmetics
+        self[le].update({'type': 'scatter', 'cmap': [[0, 0, 1], [1, 0.43, 0]],
+                         'markeredgewidth': 0})
+        lbl = self.attr('label').replace('JscVoc ', '').replace('','2').replace(' Values Jsc [mA/cm2]', '')
+        self[le].update({'label': lbl, 'sample': lbl})
+        self[le+1].update({'type': 'scatter_c'})
+        # self.curve(le+1).swapShowHide() # hide T curve
         self.update({'typeplot': 'semilogy', 'alter': ['', 'abs'],
                      'xlabel': self.formatAxisLabel(GraphJscVoc.AXISLABELS[0]),
                      'ylabel': self.formatAxisLabel(GraphJscVoc.AXISLABELS[1])})
 
-    
     def findCurveWithX(self, curve):
         """
         Find the Curve with same x data as the given Curve
         JscVoc: that Curve should store temperatures
         """
-        for cu in range(self.length()):
-            if self.curve(cu) == curve:
+        for cu in range(len(self)):
+            if self[cu] == curve:
                 # start looping at position of the curve
-                for c in range(cu+1, self.length()):
-                    if np.array_equiv(curve.x(), self.curve(c).x()):
-                        return self.curve(c)
+                for c in range(cu+1, len(self)):
+                    if np.array_equiv(curve.x(), self[c].x()):
+                        return self[c]
                 # could not find, start looking from beginning
                 for c in range(cu):
-                    if np.array_equiv(curve.x(), self.curve(c)):
-                        return self.curve(c)
+                    if np.array_equiv(curve.x(), self[c].x()):
+                        return self[c]
                 return False
+
     def splitTemperatures(self, curve, threshold=3):
         """
         Splits the compiled data into different data (one for each T)
         curve: stores the Jsc-Voc pairs - will need to find the T
         threshold in C
         """
         T = GraphJscVoc.findCurveWithX(self, curve)
         if T == False:
-            print('Error JscVoc: cannot find temperature Curve, must have same Voc list as Jsc-Voc Curve. Aborted.')
+            print('Error JscVoc: cannot find temperature Curve, must have same',
+                  'Voc list as Jsc-Voc Curve. Aborted.')
             return [], []
         Voc = curve.x()
         Jsc = curve.y()
         Tem = T.y()
         datas = []
         temps = []
         j = 0
@@ -89,111 +97,118 @@
             if j != 0:
                 if np.abs(Tem[i] - np.average(temp)) > threshold:
                     datas.append(data)
                     temps.append(np.average(temp))
                     data = []
                     temp = []
                     j = 0
-            if j == 0: # is new temperature
+            if j == 0:  # is new temperature
                 data = [[Voc[i]], [Jsc[i]]]
                 temp = [Tem[i]]
-            else: # is not new
+            else:  # is not new
                 data[0].append(Voc[i])
                 data[1].append(Jsc[i])
                 temp.append(Tem[i])
             j += 1
         datas.append(data)
         temps.append(np.average(temp))
         return datas, temps
+
     def CurvesJscVocSplitTemperature(self, threshold=3, curve=None):
         """
         Splits the compiled data into different data (one for each T)
         threshold in C
         curve: stores the Jsc-Voc pairs. If None: error. Weird prototype design
             to allow calls from GUI
         """
         if curve is None:
-            print('Error CurvesJscVocSplitTemperature, you must provide argument key "curve" with a Jsc-Voc Curve.')
+            print('Error CurvesJscVocSplitTemperature, you must provide',
+                  'argument key "curve" with a Jsc-Voc Curve.')
         datas, temps = GraphJscVoc.splitTemperatures(self, curve, threshold=3)
         attr = curve.getAttributes()
         out = []
         for i in range(len(datas)):
             out.append(CurveJscVoc(datas[i], attr))
             out[-1].update({'temperature': temps[i], 'type': '', 'cmap': ''})
-            out[-1].update({'label': out[-1].getAttribute('label')+' '+'{:.0f}'.format(temps[i])+'K'})
+            out[-1].update({'label': out[-1].attr('label')+' '+'{:.0f}'.format(temps[i])+'K'})
         return out
- 
+
     # handling of curve fitting
     def CurveJscVoc_fitNJ0(self, Voclim=None, Jsclim=None, threshold=3, graphsnJ0=True, curve=None, silent=False):
         """
         Fit the Jsc-Voc data, returns fitted Curves.
         If required, first splits data in different temperatures.
         Voclim, Jsclim: fit limits for Voc and Jsc, in data units
         threshold in C
         graphsnJ0: if True, also returns A vs T, J0 vs T and J0 vs A*T
         curve: stores the Jsc-Voc pairs. If None: error. Weird prototype design
             to allow calls from GUI
         """
         if curve is None:
-            print('Error CurveJscVoc_fitNJ0, you must provide argument key "curve" with a Jsc-Voc Curve.')
+            print('Error CurveJscVoc_fitNJ0, you must provide argument key',
+                  '"curve" with a Jsc-Voc Curve.')
             return False
         try:
             T = curve.T(default=np.nan, silent=True)
         except Exception:
-            print('Warning CurveJscVoc_fitNJ0, method T() not found. Curve type not suitable?')
+            print('Warning CurveJscVoc_fitNJ0, method T() not found. Curve',
+                  'type not suitable?')
             T = np.nan
         # check if is single or multiple temperature
         if np.isnan(T):
             datas, temps = GraphJscVoc.splitTemperatures(self, curve, threshold=threshold)
         else:
             datas, temps = [[curve.x(), curve.y()]], [T]
         # fit different data series (different illuminations at same T)
         out = []
         ns, J0s = [], []
         for i in range(len(datas)):
             n, J0 = curve.fit_nJ0(Voclim=Voclim, Jsclim=Jsclim, data=datas[i], T=temps[i])
-            attr = {'color': 'k', 'area': curve.getArea(), '_popt': [n, J0], 
+            attr = {'color': 'k', 'area': curve.getArea(), '_popt': [n, J0],
                     '_fitFunc': 'func_nJ0', '_Voclim': Voclim, '_Jsclim': Jsclim,
                     'temperature': temps[i],
-                    'filename': 'fit to '+curve.getAttribute('filename').split('/')[-1].split('\\')[-1]}
+                    'filename': 'fit to '+curve.attr('filename').split('/')[-1].split('\\')[-1]}
             if not silent:
-                print('Fit Jsc-Voc (T =',temps[i],'): ideality factor n =', n, ', J0 =', '{:1.4e}'.format(J0), '[mA/cm2].')
+                print('Fit Jsc-Voc (T =', temps[i], '): ideality factor n =',
+                      n, ', J0 =', '{:1.4e}'.format(J0), '[mA/cm2].')
             x, y = curve.selectData(xlim=Voclim, ylim=Jsclim, data=datas[i])
             out.append(CurveJscVoc([x, curve.func_nJ0(x, n, J0, T=temps[i])], attr))
             ns.append(n)
             J0s.append(J0)
         if graphsnJ0:
             from grapa.datatypes.curveArrhenius import CurveArrhenius, CurveArrheniusJscVocJ00
             # generate n vs T, J0 vs T
-            lbl = curve.getAttribute('label')
+            lbl = curve.attr('label')
             if len(lbl) > 0:
                 lbl += ' '
             out.append(Curve([temps, ns],  {'linestyle': 'none', 'linespec': 'o', 'label': lbl+'Ideality factor A vs T [K]'}))
             out.append(Curve([temps, J0s], {'linestyle': 'none', 'linespec': 'o', 'label': lbl+'J0 vs T [K]'}))
             out.append(CurveArrhenius([np.array(temps)*np.array(ns), J0s], CurveArrheniusJscVocJ00.attr))
-            out[-1].update({'label': lbl+out[-1].getAttribute('label')})# 'label': lbl+'J0 vs A*T'
-            #out[-1].update({'type': 'scatter', 'markeredgewidth':0, 'markersize':100, 'cmap': 'inferno'})# 'label': lbl+'J0 vs A*T'
-            #out.append(Curve([np.array(temps)*np.array(ns), np.array(temps)], {'linestyle': 'none', 'type': 'scatter_c'}))
+            out[-1].update({'label': lbl+out[-1].attr('label')})  # 'label': lbl+'J0 vs A*T'
+            # out[-1].update({'type': 'scatter', 'markeredgewidth':0, 'markersize':100, 'cmap': 'inferno'})# 'label': lbl+'J0 vs A*T'
+            # out.append(Curve([np.array(temps)*np.array(ns), np.array(temps)], {'linestyle': 'none', 'type': 'scatter_c'}))
         return out
 
-    
     def splitIllumination(self, threshold=3, ifFit=False, fitTlim=None, extend0=False, curve=None, silent=False):
         """
         Splits Jsc Voc data according to illumination intensity.
         Assumes data are stored as intensity series, grouped by temperatures
         """
         from grapa.datatypes.curveArrhenius import CurveArrhenius
         # retrieves data
         if curve is None:
-            print('Error splitIllumination, you must provide argument key "curve" with a Jsc-Voc Curve.')
+            print('Error splitIllumination, you must provide argument key',
+                  '"curve" with a Jsc-Voc Curve.')
             return False
         # check if is single or multiple temperature
         curveT = GraphJscVoc.findCurveWithX(self, curve)
         if not isinstance(curveT, Curve):
-            print('Error splitIllumination, cannot find Curve with T information (must have same x data as the selected Jsc vs Voc Curve).')
+            print('Error splitIllumination, cannot find Curve with T',
+                  'information (must have same x data as the selected Jsc vs',
+                  'Voc Curve).')
             return False
         Ts = curveT.y()
         x = curve.x()
         T = np.inf
         j = 0
         data = []
         for i in range(len(x)):
@@ -202,26 +217,26 @@
             if i == j:
                 data.append([[], []])
             data[j][0].append(Ts[i])
             data[j][1].append(x[i])
             T = Ts[i]
             j += 1
         attr = {'area': curve.getArea(),
-                'filename': 'extracted from '+curve.getAttribute('filename').split('/')[-1].split('\\')[-1]}
+                'filename': 'extracted from '+curve.attr('filename').split('/')[-1].split('\\')[-1]}
         try:
             from grapa.colorscale import Colorscale
-            colorscale = Colorscale(np.array([[0.91,0.25,1], [1.09,0.75,1]]), space='hls')
+            colorscale = Colorscale(np.array([[0.91, 0.25, 1], [1.09, 0.75, 1]]), space='hls')
             colors = colorscale.valuesToColor(np.array(range(len(data))) / len(data))
-        except:
+        except Exception:
             colors = [''] * len(data)
         xylbls = [self.formatAxisLabel(['Temperature', 'T', 'K']),
                   self.formatAxisLabel(['Voc', '', 'V'])]
         res = []
         out = []
-        for j in range(len(data)-1,-1,-1):
+        for j in range(len(data)-1, -1, -1):
             out.append(CurveArrhenius(data[j], attr))
             out[-1].update({'label': 'Voc vs T, intensity ' + str(j),
                             'labelhide': 1,
                             'linespec': 'o', 'color': colors[j],
                             '_Arrhenius_variant': 'ExtrapolationTo0',
                             '_Arrhenius_dataLabel': xylbls,
                             '_Arrhenius_dataLabelArrhenius': xylbls})
@@ -238,132 +253,129 @@
                 print('Intensity level, Voc @ T=0 [V]')
                 for r in res:
                     print(str(r[0]), r[1][1])
         if len(out) > 0:
             out[0].update({'labelhide': ''})
             out[-2].update({'labelhide': ''})
         return out
-        
-            
-        
-            
-        
+
+
 class CurveJscVoc(Curve):
 
     CURVE = 'Curve JscVoc'
-    
-    CST_Jsclim0 = 1.0 # mA/cm2
-    
-    q = 1.60217657E-19 # [C]
-    k = 1.38E-23    # [J K-1]
+
+    CST_Jsclim0 = 1.0  # mA/cm2
+
+    q = 1.60217657E-19  # [C]
+    k = 1.38E-23   # [J K-1]
 
     Tdefault = 273.15 + 25
-    
-    
-    def __init__ (self, data, attributes, silent=False) :
-        # delete area from attributes, to avoid normalization during initialization
-        Curve.__init__ (self, data, attributes, silent=silent)
-        self.update ({'Curve': CurveJscVoc.CURVE}) # for saved files further re-reading
 
-    
+    def __init__(self, data, attributes, silent=False):
+        # delete area from attributes, to avoid normalization during init
+        Curve.__init__(self, data, attributes, silent=silent)
+        self.update({'Curve': CurveJscVoc.CURVE})  # for saved files further re-reading
+
     # RELATED TO GUI
     def funcListGUI(self, **kwargs):
         out = Curve.funcListGUI(self, **kwargs)
         graph = kwargs['graph'] if 'graph' in kwargs else None
         # format: [func, 'func label', ['input 1', 'input 2', 'input 3', ...] (, [default1, default2, ...]) ]
         lbl = 'Area [cm2] (old value ' + "{:4.3f}".format(self.getArea()) + ')'
         out.append([self.setArea, 'Area correction', [lbl], [ "{:6.5f}".format(self.getArea())]]) # one line per function
         # fit function
         if self.getAttribute('_fitFunc') == '' or self.getAttribute('_popt', None) is None:
             Voclim = roundSignificantRange([0, max(self.x())*1.01], 3)
             Jsclim = roundSignificantRange([0.1, max(self.y())*1.1], 2)
             out.append([GraphJscVoc.CurveJscVoc_fitNJ0, 'Fit J0 & ideality', ['Voclim', 'Jsclim', 'T max fluct.', 'compile'], [Voclim, Jsclim, 3, True], {'curve': self}])
-        else: # if fitted Curve
+        else:  # if fitted Curve
             out.append([self.updateFitParam, 'Modify fit', ['n', 'J0'], roundSignificant(self.getAttribute('_popt'), 5)])
         # split according to temperatures
         out.append([GraphJscVoc.CurvesJscVocSplitTemperature, 'Separate according to T', ['T max fluctuations'], [3], {'curve': self}])
         # split according to illumination intensities (Voc vs T)
-        Tlim = [0,350]
+        Tlim = [0, 350]
         if graph is not None:
             for c in range(graph.length() - 1):
                 if graph.curve(c) == self:
                     if np.array_equiv(graph.curve(c+1).x(), graph.curve(c).x()):
                         Tlim = [0.99*np.min(graph.curve(c+1).y()), 1.01*np.max(graph.curve(c+1).y())]
                         break
         Tlim = roundSignificantRange(Tlim, 3)
         out.append([GraphJscVoc.splitIllumination, 'Separate Voc vs T',
                     ['T max fluct.', 'fit Voc(T)', 'T limits', 'extend to 0'],
                     [3, True, Tlim, True], {'curve': self},
                     [{}, {'field': 'Checkbutton'}, {}, {'field': 'Checkbutton'}]])
         out.append([self.printHelp, 'Help!', [], []])
         return out
-    
+
     def alterListGUI(self):
         out = Curve.alterListGUI(self)
         out.append(['Log10 abs', ['', 'abs'], 'semilogy'])
         return out
 
-
     # Handling of cell area
     def getArea(self):
         """ return area of the cell as stored in the Curve parameters """
         area = self.getAttribute('area [cm2]')
         if is_number(area):
             return area
         return 1
+
     def setArea(self, new):
         """ correct the cell area, and scale the y (list of Jsc) accordingly """
         old = self.getArea()
         self.setY(self.y() * old / new)
         self.update({'area [cm2]': new})
         return True
-        
-        
+
     def fit_nJ0(self, Voclim=None, Jsclim=None, data=None, T=None):
         """ perform fitting, returns best fit parameters """
         datax, datay = self.selectData(xlim=Voclim, ylim=Jsclim, data=data)
         if len(datax) < 2 or len(datay) < 2:
             return [np.nan, np.nan]
         if T is None:
             T = self.T()
         # actual fitting
         datay = np.log(datay)
         z = np.polyfit(datax, datay, 1, full=True)[0]
         n = self.q / self.k / T / z[0]
         J0 = np.exp(z[1])
         return [n, J0]
+
     def func_nJ0(self, Voc, n, J0, T=None):
         """ fit function """
         if T is None:
             T = self.T()
         out = J0 * np.exp(self.q * Voc / (n * self.k * T))
         return out
-    
+
     def T(self, default=None, silent=False):
-        """ Returns the acquisition temperature, otherwise default. """ 
+        """ Returns the acquisition temperature, otherwise default. """
         test = self.getAttribute('temperature', 0)
         if test != 0:
             return test
         if not silent:
-            print('Curve JscVoc cannot find keyword temperature.', self.getAttributes())
+            print('Curve JscVoc cannot find keyword temperature.',
+                  self.getAttributes())
         if default is None:
             return CurveJscVoc.Tdefault
         return default
 
     def splitIllumination(self, curve, threshold=3):
         """
         Splits the compiled data into different data (one for each intensity)
         curve: stores the Jsc-Voc pairs - will need to find the T
         threshold in C
         ifFit: bool. if True, also fits the output Curves
         fitTlim: T range to for the fit Voc(T)
         """
         T = GraphJscVoc.findCurveWithX(self, curve)
         if T == False:
-            print('Error JscVoc: cannot find temperature Curve, must have same Voc list as Jsc-Voc Curve. Aborted.')
+            print('Error JscVoc: cannot find temperature Curve, must have',
+                  'same Voc list as Jsc-Voc Curve. Aborted.')
             return [], []
         Voc = curve.x()
         Jsc = curve.y()
         Tem = T.y()
         datas = []
         temps = []
         j = 0
@@ -373,59 +385,59 @@
             if j != 0:
                 if np.abs(Tem[i] - np.average(temp)) > threshold:
                     datas.append(data)
                     temps.append(np.average(temp))
                     data = []
                     temp = []
                     j = 0
-            if j == 0: # is new temperature
+            if j == 0:  # is new temperature
                 data = [[Voc[i]], [Jsc[i]]]
                 temp = [Tem[i]]
-            else: # is not new
+            else:  # is not new
                 data[0].append(Voc[i])
                 data[1].append(Jsc[i])
                 temp.append(Tem[i])
             j += 1
         datas.append(data)
         temps.append(np.average(temp))
         return datas, temps
+
     def CurvesJscVocSplitIllumination(self, curve=None):
         """
         Splits the compiled data into different curves (one for each intensity)
         curve: stores the Jsc-Voc pairs. If None: error. Weird prototype design
             to allow calls from GUI
         """
         if curve is None:
             print('Error CurvesJscVocSplitIllumination, you must provide argument key "curve" with a Jsc-Voc Curve.')
         datas, temps = GraphJscVoc.splitTemperatures(self, curve, threshold=3)
         attr = curve.getAttributes()
         out = []
         for i in range(len(datas)):
             out.append(CurveJscVoc(datas[i], attr))
             out[-1].update({'temperature': temps[i], 'type': '', 'cmap': ''})
-            out[-1].update({'label': out[-1].getAttribute('label')+' '+'{:.0f}'.format(temps[i])+'K'})
+            out[-1].update({'label': out[-1].attr('label')+' '+'{:.0f}'.format(temps[i])+'K'})
         return out
-         
+
     def printHelp(self):
         print('*** *** ***')
         print('CurveJV offer basic treatment of Jsc-Voc pairs of solar cells.')
         print('Based on Thomas Weiss script, and on the following references:')
-        print('   Schock, Scheer, p111, footnote 20')
-        print('   Hages et al., JAP 115, 234504 (2014)')
+        print('  Schock, Scheer, p111, footnote 20')
+        print('  Hages et al., JAP 115, 234504 (2014)')
         print('Curve transforms:')
-        print(' - Linear: standard is current density [mA cm-2] versus [V], at different light intensitites.')
-        print(' - Log 10 abs: logarithm of J vs V. Same display as JV curve, to visualize the diode behavior.')
+        print('- Linear: standard is current density [mA cm-2] versus [V], at different light intensitites.')
+        print('- Log 10 abs: logarithm of J vs V. Same display as JV curve, to visualize the diode behavior.')
         print('Analysis functions:')
-        print(' - Area correction: scale Jsc data according to cell area.')
-        print(' - Fit J0 & ideality: fit Jsc vs Voc data and extract J0 and ideality factor A. Parameters:')
-        print('   Voclim, Jsclim: fit limits for Voc and Jsc')
-        print('   T max fluct.: identify groups of temperatures to fit only relevant data together.')
-        print('       A new temperature is identified if a point deviates more than "value" from the average.')
-        print('   compile: after fitting data, returns Curves with results: ideality factor versus T,')
-        print('      J0 versus T, and J0 vs A * T.')
-        print(' - Separate according to T: split data in several Curves according to the temperature identified.')
-        print('   T max fluct.: identify groups of temperatures to fit only relevant data together.')
-        print('       A new Curve is created once a point deviates more than this value from the average.')
-        print(' - Extract Voc vs T: split data in several Curves, grouping Voc vs T data acquired with same illumination intensity.')
-        print('   T max fluct.: identify groups of temperatures to group relevant intensities together.')
+        print('- Area correction: scale Jsc data according to cell area.')
+        print('- Fit J0 & ideality: fit Jsc vs Voc data and extract J0 and ideality factor A. Parameters:')
+        print('  Voclim, Jsclim: fit limits for Voc and Jsc')
+        print('  T max fluct.: identify groups of temperatures to fit only relevant data together.')
+        print('      A new temperature is identified if a point deviates more than "value" from the average.')
+        print('  compile: after fitting data, returns Curves with results: ideality factor versus T,')
+        print('     J0 versus T, and J0 vs A * T.')
+        print('- Separate according to T: split data in several Curves according to the temperature identified.')
+        print('  T max fluct.: identify groups of temperatures to fit only relevant data together.')
+        print('      A new Curve is created once a point deviates more than this value from the average.')
+        print('- Extract Voc vs T: split data in several Curves, grouping Voc vs T data acquired with same illumination intensity.')
+        print('  T max fluct.: identify groups of temperatures to group relevant intensities together.')
         return True
-
```

### Comparing `grapa-0.5.4.8/grapa/datatypes/curveJV.py` & `grapa-0.6.1.0/grapa/datatypes/curveJV.py`

 * *Files 7% similar despite different names*

```diff
@@ -17,277 +17,312 @@
 
 from grapa.graph import Graph
 from grapa.graphIO import GraphIO
 from grapa.curve import Curve
 from grapa.mathModule import xAtValue, is_number, roundSignificant, derivative, smooth
 
 
-
-
-
-
 class CurveJV(Curve):
 
-    q = 1.60217657E-19 # [C]
+    q = 1.60217657E-19  # [C]
     k = 1.38E-23    # [J K-1]
-    defaultIllumPower = 1000 # W/m2
+    defaultIllumPower = 1000  # W/m2
 
     CURVE = 'Curve JV'
 
     # to retrieve info from filename: sample name, cell, measurement id
     FINDALLSTR = '^(I-V_)*(.*)_([a-zA-Z]+[0-9]+)_([0-9]+)([_a-zA-Z0-9]*).txt'
 
-    def __init__ (self, dataJV, attributes, units=['V', 'mAcm-2'], illumPower=defaultIllumPower, ifCalc=True, silent=False) :
-        # delete area from attributes, to avoid normalization during initialization
+    def __init__(self, dataJV, attributes, units=['V', 'mAcm-2'], illumPower=defaultIllumPower, ifCalc=True, silent=False) :
+        # delete area from attributes, to avoid normalization during
+        # initialization
         tempArea = {}
         if 'area' in attributes:
             tempArea = {'area': attributes['area']}
             del attributes['area']
-        Curve.__init__ (self, dataJV, attributes, silent=silent)
-        if 'area' in tempArea: # by default: do not normalize data
+        Curve.__init__(self, dataJV, attributes, silent=silent)
+        if 'area' in tempArea:  # by default: do not normalize data
             Curve.update(self, tempArea)
-        if self.area() == 0: # set 1 if no input
-            Curve.update(self, {'area': 1}) # to allow later changes
+        if self.area() == 0:  # set 1 if no input
+            Curve.update(self, {'area': 1})  # to allow later changes
             print('Cell area was set to 1.')
-        elif self.getAttribute('area', None) is None:
-            Curve.update(self, {'area': self.area()}) # to allow later changes
+        elif self.attr('area', None) is None:
+            Curve.update(self, {'area': self.area()})  # to allow later changes
         # internally all units are treated as V and mA/cm2
-        if units[0] == 'mV' :
-            self.setX (self.x() / 1000)
-            print ('class CurveJV: V axis rescaling into V.')
-        if units[1] == 'Am-2' : # converts in mAcm-2
-            self.setY (self.y() * 1000 / (100*100))
-            print ('class CurveJV: J axis rescaling into mA/cm2.')
+        if units[0] == 'mV':
+            self.setX(self.x() / 1000)
+            print('class CurveJV: V axis rescaling into V.')
+        if units[1] == 'Am-2':  # converts in mAcm-2
+            self.setY(self.y() * 1000 / (100*100))
+            print('class CurveJV: J axis rescaling into mA/cm2.')
         # illumPower default 1000 W/m2
         illumPower = illumPower if is_number(illumPower) else float(illumPower)
-        self.update ({'units': units, 'illumPower': illumPower})
-        self.T = self.getAttribute('Temperature') if is_number (self.getAttribute('Temperature')) else 273.15 + 25
-        if self.getAttribute('_fitDiodeWeight') == '':
+        self.update({'units': units, 'illumPower': illumPower})
+        # temperature. self.T for convenience. See also update() override
+        self.T = 273.15 + 25
+        if is_number(self.attr('Temperature')):
+            self.T = self.attr('Temperature')
+
+        if self.attr('_fitDiodeWeight') == '':
             self.update({'_fitDiodeWeight': 5})
-        self.update ({'Curve': self.CURVE}) # for saved files further re-reading
+        self.update({'Curve': self.CURVE})  # for saved files further re-reading
         # some warning for the user
         if np.max(self.x() > 10):
-            print('Warning CurveJV: max voltage > 10 detected. Voltage input expected in V, please correct if possible. Fitting is likely to fail on provided input.')
+            print('Warning CurveJV: max voltage > 10 detected. Voltage input',
+                  'expected in V, please correct if possible. Fitting is',
+                  'likely to fail on provided input.')
+        self.sample(forceCalc=True)
         if ifCalc:
-            self.calcVocJscFFEffMPP ()
-
+            try:
+                self.calcVocJscFFEffMPP()
+            except Exception as e:
+                print('WARNING CurveJV init: Exception', type(e))
+                print(e)
 
     # RELATED TO GUI
     def funcListGUI(self, **kwargs):
         out = Curve.funcListGUI(self, **kwargs)
         # format: [func, 'func label', ['input 1', 'input 2', 'input 3', ...] (, [default1, default2, ...]) ]
         lbl = 'Area [cm2] (old value ' + "{:4.3f}".format(self.area()) + ')'
-        out.append([self.setArea, 'Area correction', [lbl], [ "{:6.5f}".format(self.area())]]) # one line per function
-        out.append([self.calcVocJscFFEffMPP_print, 'Voc, Jsc, FF, Eff, MPP', [], []]) # one line per function
+        out.append([self.setArea, 'Area correction', [lbl],
+                    ["{:6.5f}".format(self.area())]])
+        out.append([self.calcVocJscFFEffMPP_print, 'Voc, Jsc, FF, Eff, MPP',
+                    [], []])
         # if data and not fitted Curve
-        if self.getAttribute('_fitFunc') == '' or self.getAttribute('_popt', None) is None:
-            out.append([self.CurveJVFromFit_print, 'JV fit', ['Fit range', 'Fit weight diode region\n1 neutral, 10 incr. weight'], ['[-0.5, np.inf]', self.getAttribute('_fitDiodeWeight')]]) # one line per function
+        if self.attr('_fitFunc') == '' or self.attr('_popt', None) is None:
+            out.append([self.CurveJVFromFit_print, 'JV fit',
+                        ['Fit range', 'Fit weight diode region\n1 neutral, 10 incr. weight'],
+                        ['[-0.5, np.inf]', self.attr('_fitDiodeWeight')]])
             out.append([self.diodeFit_BestGuess, 'JV curve initial guess', [], []])
-        else: # if fitted Curve
-            out.append([self.updateFitParam, 'Modify fit', ['n', 'Jl', 'J0', 'Rs', 'Rp'], roundSignificant(self.getAttribute('_popt'), 5)])
-            out.append([self.fit_resampleX, 'Resample V', ['delta x, or [-0.3, 1, 0.01]'], [roundSignificant((self.V(1)-self.V(0))/10,5)]])
+        else:  # if fitted Curve
+            out.append([self.updateFitParam, 'Modify fit',
+                        ['n', 'Jl', 'J0', 'Rs', 'Rp'],
+                        roundSignificant(self.attr('_popt'), 5)])
+            out.append([self.fit_resampleX, 'Resample V',
+                        ['delta x, or [-0.3, 1, 0.01]'],
+                        [roundSignificant((self.V(1)-self.V(0))/10,5)]])
+        if 'graph' in kwargs:
+            out.append([self.extractJscVoc, 'Extract Jsc-Voc values', [], [],
+                        {'graph': kwargs['graph']}])
         out.append([self.printHelp, 'Help!', [], []])
         return out
 
     def alterListGUI(self):
         out = Curve.alterListGUI(self)
         out.append(['Log10 abs', ['', 'abs'], 'semilogy'])
         out.append(['Log10 abs (raw)', ['', 'abs0'], 'semilogy'])
-        out.append(['Differential R = dV/dJ [Ohm cm2]', ['', 'CurveJV.yDifferentialR'], 'semilogy'])
+        out.append(['Differential R = dV/dJ [Ohm cm2]',
+                    ['', 'CurveJV.yDifferentialR'], 'semilogy'])
         return out
 
-
     # overloaded Curve methods
-    def update (self, attributes) :
-        """ Override default update method, to handle the case where a new area would be set. """
-        for key in attributes :
-            if key == 'area':
-                self.setArea(attributes[key])
+    def update(self, attributes):
+        """
+        Override default update method, to handle the case where a new area
+        or temperature would be set.
+        """
+        for key in attributes:
+            if key.lower() == 'area':
+                self.setArea(attributes[key])  # bypass default behavior
+            elif key.lower() == 'temperature':
+                if is_number(attributes[key]):
+                    self.T = attributes[key]  # behavior in addition to default
+                Curve.update(self, {key: attributes[key]})
             else:
                 Curve.update(self, {key: attributes[key]})
 
-
     # OTHER
-    def area (self) :
-        if self.getAttribute('area') != '' :
-            return self.getAttribute('area')
-        if self.getAttribute('Acquis soft Cell area') != '':
-            return self.getAttribute('Acquis soft Cell area')
+    def area(self):
+        if self.attr('area') != '':
+            return self.attr('area')
+        if self.attr('Acquis soft Cell area') != '':
+            return self.attr('Acquis soft Cell area')
         return 0
 
     def setArea(self, area, ifCalc=True):
         if not is_number(area) :
-            print ('CurveJV setArea ERROR: parameter not numeric (value',area,').')
+            print('CurveJV setArea ERROR: parameter not numeric (value', area,
+                  ').')
             return
         if area == self.area():
             if not self.silent:
                 print('CurveJV setArea: new area identical to previous value.')
             return
-        if self.area() == '': # for example when loading fileGeneric
+        if self.area() == '':  # for example when loading fileGeneric
             Curve.update(self, {'area': area})
             return
         if not self.silent:
-            print ('CurveJV setArea: new area (new',area,', old',self.area(),')')
+            print('CurveJV setArea: new area (new', area, ', old', self.area(),
+                  ')')
         oldarea = self.area()
         self.setY(self.y() * oldarea / area)
         Curve.update(self, {'area': area})
         if not self.silent:
-            print ('Area set to', area, '(old value',oldarea,')')
+            print('Area set to', area, '(old value', oldarea, ')')
         # recalculate basic parameters
         if ifCalc:
-            self.calcVocJscFFEffMPP ()
+            self.calcVocJscFFEffMPP()
             # erase information about fitting
             self.update({'diodefit': ''})
         return True
 
-
-    def V (self, idx=np.nan) :
+    def V(self, idx=np.nan):
         return self.x(idx)
-    def J (self, idx=np.nan) :
+
+    def J(self, idx=np.nan):
         return self.y(idx)
 
     def yDifferentialR(self, index=np.nan, xyValue=None):
         """ Returns differential resistance of the J-V curve R = dV/dI"""
         if xyValue is not None:
             return np.array(xyValue)[1]
-        V, J = self.x(), self.y()/1000 # J in A/cm2
-        val = derivative(J, V) # R in Ohm cm2
+        V, J = self.x(), self.y()/1000  # J in A/cm2
+        val = derivative(J, V)  # R in Ohm cm2
         if np.isnan(index).any():
             return val[:]
         return val[index]
 
 
-    def interpJ (self, V) :
+    def interpJ(self, V):
         # returns values of a spline interpolation degree 3 at the V values
-        f = interpolate.interp1d(self.V(), self.J()) # spline interpolation degree 3
+        f = interpolate.interp1d(self.V(), self.J())
         idx = (V > np.min(self.V())) * (V < np.max(self.V()))
         out = []
-        for i in range(len(V)) :
+        for i in range(len(V)):
             out.append(f(V[i] if idx[i] else np.nan))
         return np.array(out)
 
-    def simpleLabel (self, forceCalc=False):
-        if self.getAttribute('label') == '' or forceCalc:
-            old = os.path.split(self.getAttribute('label'))[1]
+    def simpleLabel(self, forceCalc=False):
+        if self.attr('label') == '' or forceCalc:
+            old = os.path.split(self.attr('label'))[1]
             old = old.split('\\')[-1] + ' '
-            old = resub(r'_[0-9][0-9](?P<next>[_ d$])', '\g<1>', old) # remove msmt number
-            old = old.replace('I-V_','').replace('_',' ').replace('  ',' ').strip(' ')
-#        print ('simpleLabel', self.getAttribute('label'), old)
+            old = resub(r'_[0-9][0-9](?P<next>[_ d$])', '\g<1>', old)  # remove msmt number
+            old = old.replace('I-V_','').replace('_', ' ').replace('  ', ' ').strip(' ')
             self.update({'label': old})
-        return self.getAttribute('label')
+        return self.attr('label')
 
-    def sample (self, forceCalc=False) :
-        if self.getAttribute('sample') == '' or forceCalc :
-            name = os.path.split(self.getAttribute('filename'))[1]
+    def sample(self, forceCalc=False):
+        if self.attr('sample') == '' or forceCalc:
+            name = os.path.split(self.attr('filename'))[1]
             split = refindall(self.FINDALLSTR, name)
             if len(split) > 0 and len(split[0]) > 1:
                 self.update({'sample': split[0][1]})
             # old version, replaced on 19.08.2020
             # split = refindall('I-V_(.*)_[a-zA-Z][0-9]_', name); split[0].lower()})
-        return self.getAttribute('sample')
+        return self.attr('sample')
 
-    def cell (self, forceCalc=False) :
-        if self.getAttribute('cell') == '' or forceCalc :
-            name = os.path.split(self.getAttribute('filename'))[1]
+    def cell(self, forceCalc=False):
+        if self.attr('cell') == '' or forceCalc:
+            name = os.path.split(self.attr('filename'))[1]
             split = refindall(self.FINDALLSTR, name)
             if len(split) > 0 and len(split[0]) > 2:
                 self.update({'cell': split[0][2].lower()})
             # old version, replaced on 19.08.2020
             # split = refindall('_([a-zA-Z][0-9])_', name); split[0].lower()})
-        return self.getAttribute('cell')
+        return self.attr('cell')
 
-    def measId (self, forceCalc=False) :
-        if self.getAttribute('measId') == '' or forceCalc :
+    def measId(self, forceCalc=False):
+        if self.attr('measId') == '' or forceCalc:
             name = os.path.split(self.getAttribute('filename'))[-1]
             split = refindall(self.FINDALLSTR, name)
             if len(split) > 0 and len(split[0]) > 3:
                 self.update({'measId': split[0][3]})
             # old version, replaced on 19.08.2020
             # split = refindall('_([0-9][0-9])[._]', name); split[0]})
-        return self.getAttribute('measId')
-
+        return self.attr('measId')
 
-    def darkOrIllum (self, ifText=False, forceCalc=False, ifJscBelow=0.1) :
-        if self.getAttribute('darkOrIllum') == '' or forceCalc :
+    def darkOrIllum(self, ifText=False, forceCalc=False, ifJscBelow=0.1):
+        if self.attr('darkOrIllum') == '' or forceCalc :
             sure = False
-            name = self.getAttribute('filename').split('/')[-1]
+            name = self.attr('filename').split('/')[-1]
             split = refindall('([dD][aA][rR][kK])', name)
-            if len(split) > 0 :
+            if len(split) > 0:
                 ifDark = True
                 sure = True
-            if not sure :
-                if is_number(ifJscBelow) :
-                    if self.getAttribute('Jsc') != '' :
-                        if np.abs(self.getAttribute('Jsc')) < ifJscBelow : # 0.1 mA/cm2 is criterion for a dark JV curve
+            if not sure:
+                if is_number(ifJscBelow):
+                    if self.attr('Jsc') != '':
+                        if np.abs(self.attr('Jsc')) < ifJscBelow:
+                            # 0.1 mA/cm2 is criterion for a dark JV curve
                             ifDark = True
-                        else :
+                        else:
                             ifDark = False
                         sure = True
-            if not sure :
+            if not sure:
                 ifDark = False
             self.update({'darkOrIllum': ifDark})
-        if not ifText :
+        if not ifText:
             return self.getAttribute('darkOrIllum')
-        else :
+        else:
             out = 'dark' if self.getAttribute('darkOrIllum') else 'illum'
             return out
 
 
     def CurveJVFromFit (self, fitRange=None, diodeFitWeight=None, V=None, silent=False):
-        """ Returns a CurveJV object, as the fit to the self object on the same Voltage points.
-        diodeFitWeight: 0 for no change, otherwise divide the fit sigma in the diode behavior region. Values such as 10 significantly improve the fittin in this region.
-        V: alternative V datapoints on which evaluate function after the fit. Default is full set of V datapoints.
+        """
+        Returns a CurveJV object, as the fit to the self object on the same
+        Voltage points.
+        diodeFitWeight: 0 for no change, otherwise divide the fit sigma in the
+            diode behavior region. Values such as 10 significantly improve the
+            fittin in this region.
+        V: alternative V datapoints on which evaluate function after the fit.
+            Default is full set of V datapoints.
         """
         if diodeFitWeight is not None:
             self.update({'_fitDiodeWeight': diodeFitWeight})
         p = self.diodeFit(ifPlot=False, silent=True, fitRange=fitRange)
         if p is False:
             print('Could not fit CurveJV.')
             return None
-        Jsc = self.getAttribute('Jsc')
+        Jsc = self.attr('Jsc')
         if V is None:
             V = self.V()
         J = self.func_diodeResistors_Jsc(V, p[0], p[1], p[2], p[3], p[4])
-        out = CurveJV([V, J], {'color': 'k', 'Jsc': Jsc, 'diodefit': p, 'Temperature': self.T, 'area': self.area(), '_popt': p, '_fitfunc': 'func_diodeResistors_Jsc', '_fitDiodeWeight': self.getAttribute('_fitDiodeWeight'), 'data filename': self.getAttribute('filename')}, ifCalc=False)
+        out = CurveJV([V, J],
+                      {'color': 'k', 'Jsc': Jsc, 'diodefit': p,
+                       'Temperature': self.T, 'area': self.area(), '_popt': p,
+                       '_fitfunc': 'func_diodeResistors_Jsc',
+                       '_fitDiodeWeight': self.attr('_fitDiodeWeight'),
+                       'data filename': self.attr('filename')},
+                      ifCalc=False)
         if not silent:
-            print('CurveJV fit (n, Jl, J0, Rs, Rp):', ', '.join([str(num) for num in roundSignificant(p, 5)]))
+            print('CurveJV fit (n, Jl, J0, Rs, Rp):',
+                  ', '.join([str(num) for num in roundSignificant(p, 5)]))
             print('   units: n [ ], Jl, J0 [mA cm-2], Rs, Rp [Ohm cm2].')
         return out
 
-
     def CurveJVFromFit_print(self, fitRange=None, fitDiodeWeight=None):
         if fitDiodeWeight is not None:
             self.update({'_fitDiodeWeight': fitDiodeWeight})
         ans = self.CurveJVFromFit(fitRange=fitRange)
-        out = self.printShort(header=True).replace('\n','')
-        try :
-            out+= self.printShort().replace
-            print (out)
-        except:
+        out = self.printShort(header=True).replace('\n', '')
+        try:
+            out += self.printShort().replace
+            print(out)
+        except Exception:
             pass
         return ans
 
 
-
-
     # expected output file format
     #Cell	Voc_V	Jsc_mApcm2	FF_pc	Eff_pc	Area_cm2	Vmpp_V	Jmpp_mApcm2	Pmpp_mWpcm2	Rp_Ohmcm2	Rs_Ohmcm2	MeasTime	Temp_DegC	IllumCorr	CellCommt	GlobalCommt	FileName
     #d1	0.66	18.6	72.3	8.9	0.57	0.53	16.8	8.9	9710	1.1	11.07.2016 16:02:23	25	1			G:\CIGS\RC\_data\JV\Oct1048_ref\I-V_Oct1048ref_d1_01.txt
-    def printShort (self, header=False) :
+    def printShort(self, header=False) :
         if header :
             out = 'Cell\tVoc [V]\tJsc [mA/cm2]\tFF [%]\tEff. [%]\tArea [cm-2]\tVmpp [V]\tJmpp [mA/cm2]\tPmpp [mW/cm2]\tRp [Ohmcm2]\tRs [Ohmcm2]\tn\tJ0 [A/cm2]\tTemperature [K]\tAcquis. T [C]\tFilename\tRemarks\n'
             return out
-        def st (st, precis) :
-            return str(np.round(st, precis+1)) # +1: hacked my own function to increase precision for every parameter
+        def st(st, precis):
+            return str(np.round(st, precis+1))
+            # +1: hacked my own function to increase precision for every parameter
         attr = self.getAttributes()
-        popt = self.getAttribute('diodeFit', [np.nan]*5)
+        popt = self.attr('diodeFit', [np.nan]*5)
         out  = self.cell() + '\t' + st(attr['voc'],4) + '\t' + st(attr['jsc'],2) + '\t' + st(attr['ff']*100,2) + '\t' + st(attr['eff']*100,2) + '\t' + st(self.area(),4)
         out += '\t' + st(attr['mpp'][0],4) + '\t' + st(-attr['mpp'][1],2) + '\t' + st(attr['mpp'][2],2) + '\t' + st(attr['rp'],0) + '\t' + st(popt[3],2) + '\t' + st(popt[0],2)
-        out += '\t' + '{:.2e}'.format(0.001*popt[2]) + '\t' + st(self.T,1) + '\t' + st(attr['acquis soft temperature'] if 'acquis soft temperature' is attr else np.nan, 1) + '\t' + attr['filename'] + '\t'
-        out += self.getAttribute('_fitDiodeWarning') # will be '' if no warning issued.
+        out += '\t' + '{:.2e}'.format(0.001*popt[2]) + '\t' + st(self.T, 1) + '\t' + st(attr['acquis soft temperature'] if 'acquis soft temperature' in attr else np.nan, 1) + '\t' + attr['filename'] + '\t'
+        out += self.attr('_fitDiodeWarning')  # will be '' if no warning issued.
         out += '\n'
         return out
 
     def calcVocJscFFEffMPP_print(self):
         tmp = self.silent
         self.silent = False
         self.calcVocJscFFEffMPP()
@@ -295,44 +330,46 @@
         return True
 
     def calcVocJscFFEffMPP(self):
         # remove NaN values from data, as well as saturated datapoints
         V, J = self.cleanDataVJ()
         # calculate Jsc
         Jsc = self.calcJsc(V, J)
-        self.update ({'Jsc': Jsc})
+        self.update({'Jsc': Jsc})
         # compute Rp, same idea as Jsc (update: V in [-0.2 V, +0.1])
         Rp = self.calcRp(V, J)
         self.update({'Rp': Rp})
         # calculate Voc
-        # idea: interpolate JV curve with 3-order polynom between 2 closest datapoints, then look for V @ J=0
+        # idea: interpolate JV curve with 3-order polynom between 2 closest
+        # datapoints, then look for V @ J=0
         Jabs = np.abs(J)
         if np.abs(np.sum(np.sign(J))) == len(J):
             # J does not cross 0
             Voc = np.nan
         else:
             try:
                 i = list(Jabs).index(min(Jabs))
-                idx = list(range(i-1, i+3) if J[i] < 0 else range (i-2, i+2))
+                idx = list(range(i-1, i+3) if J[i] < 0 else range(i-2, i+2))
                 if idx[-1] >= len(V):
                     idx = [-4, -3, -2, -1]
                 if idx[0] < 0:
                     idx = [0, 1, 2, 3]
-                f = interpolate.interp1d(V[idx], J[idx], 3) # spline interpolation
+                f = interpolate.interp1d(V[idx], J[idx], 3)  # spline interpolation
                 dx = np.abs(V[idx[:-1]] - V[idx[1:]])
                 dxmin = np.min(dx[dx > 0])
                 maxV = np.max(V[idx])
-                x = np.arange(V[idx[0]], V[idx[-1]], dxmin/100) # tolerance is 1/100 of smallest dx
+                x = np.arange(V[idx[0]], V[idx[-1]], dxmin/100)  # tolerance is 1/100 of smallest dx
                 x = np.array([min(v, maxV) for v in x])
-                Voc = xAtValue (x, f(x), 0, silent=True)
+                Voc = xAtValue(x, f(x), 0, silent=True)
             except ValueError:
                 Voc = np.nan
-        self.update ({'Voc': Voc})
+        self.update({'Voc': Voc})
         # calculate Eff (method with interpolation)
-        # idea: interpolate JV curve with 3-order polynom between 2 closest datapoints, then look for max(J*V)
+        # idea: interpolate JV curve with 3-order polynom between 2 closest
+        # datapoints, then look for max(J*V)
         powDens = - J * V
         try:
             i = list(powDens).index(max(powDens))
             i = max(1, min(len(powDens)-2, i))
             idx = list(range(i-1, i+3) if powDens[i-1] < powDens[i+1] else range(i-2, i+2))
             if idx[0] < 0:
                 idx = [0, 1, 2, 3]
@@ -343,296 +380,298 @@
             dxmin = np.min(dx[dx > 0])
             maxV = np.max(V[idx])
             x = np.arange(V[idx[0]], V[idx[-1]], dxmin/100)
             x = np.array([min(v, maxV) for v in x])
             try:
                 Vmpp = x[list(f(x)).index(max(f(x)))]
                 Pmpp = f(Vmpp)
-                Eff  = f(Vmpp) / (self.getAttribute('illumPower')/10) # *10 to convert illumpower in mW/cm2
-                self.update ({'Eff': Eff, 'MPP': [Vmpp, -f(Vmpp) / Vmpp, float(Pmpp)]})
+                Eff = f(Vmpp) / (self.attr('illumPower')/10)
+                # *10 to convert illumpower in mW/cm2
+                self.update({'Eff': Eff, 'MPP': [Vmpp, -f(Vmpp) / Vmpp, float(Pmpp)]})
             except ValueError as e:
                 print('Error CurveJV MPP: cannot identify MPP. Exception:')
                 print(e)
                 Eff = 0
-                self.update ({'Eff': 0.0, 'MPP': [np.nan, np.nan, np.nan]})
+                self.update({'Eff': 0.0, 'MPP': [np.nan, np.nan, np.nan]})
         except ValueError:
             Eff = np.nan
-            self.update ({'Eff': np.nan, 'MPP': [np.nan]*3})
+            self.update({'Eff': np.nan, 'MPP': [np.nan]*3})
         # calculate FF
-        FF  = np.abs(Eff * (self.getAttribute('illumPower')/10) / (Voc * Jsc)) # /10 to convert illumpower in mW/cm2
+        FF = np.abs(Eff * (self.attr('illumPower')/10) / (Voc * Jsc))  # /10 to convert illumpower in mW/cm2
         self.update({'FF': FF})
         # some printing of the results
-        if not self.silent :
-            print ('Jsc', Jsc)
-            print ('Voc', Voc)
-            print ('FF ', FF)
-            print ('Eff', Eff)
-            print ('MPP', self.getAttribute('MPP'))
-
-
+        if not self.silent:
+            print('Jsc', Jsc)
+            print('Voc', Voc)
+            print('FF ', FF)
+            print('Eff', Eff)
+            print('MPP', self.attr('MPP'))
 
-#Ideal diode equation
-# J (V) = JL - J0 * ( exp( q / (n k T) * V ) - 1 )
 
-#Equation with resistors
-# J (V) = JL - J0 * ( exp( q / (n k T) * (V + J Rs)) - 1 ) - ( V + J Rs) / Rp
+    #Ideal diode equation
+    # J (V) = JL - J0 * ( exp( q / (n k T) * V ) - 1 )
 
+    #Equation with resistors
+    # J (V) = JL - J0 * ( exp( q / (n k T) * (V + J Rs)) - 1 ) - ( V + J Rs) / Rp
 
-    def func_diodeIdealAbsLog10 (self, V, n, Jl, J0) :
-        return np.log10(np.abs(self.func_diodeIdeal (V, n, Jl, J0)))
-    def func_diodeIdealAbsLog (self, V, n, Jl, J0) :
-        return np.log(np.abs(self.func_diodeIdeal (V, n, Jl, J0)))
+    def func_diodeIdealAbsLog10(self, V, n, Jl, J0):
+        return np.log10(np.abs(self.func_diodeIdeal(V, n, Jl, J0)))
+    def func_diodeIdealAbsLog(self, V, n, Jl, J0):
+        return np.log(np.abs(self.func_diodeIdeal(V, n, Jl, J0)))
 
-    def func_diodeIdeal (self, V, n, Jl, J0) :
-        return - (Jl - J0 * (np.exp( self.q / (n * self.k * self.T) * V ) - 1 ))
+    def func_diodeIdeal (self, V, n, Jl, J0):
+        return - (Jl - J0 * (np.exp(self.q / (n * self.k * self.T) * V) - 1))
 
 
 
 
-    def fit_func_diodeResistors_AbsLog (self, V, logJ, n, Jl, J0, Rs, Rp, Vshift=0, sigma=[]) :
+    def fit_func_diodeResistors_AbsLog(self, V, logJ, n, Jl, J0, Rs, Rp, Vshift=0, sigma=[]):
         if sigma == []:
             sigma = [1]*len(V)
         J0, Rs, Rp = np.abs(J0), np.abs(Rs), np.abs(Rp)
         self.fitFixPar = {'Vshift': Vshift, 'Jl': Jl, 'Rs': Rs, 'Rp': Rp}
-        # trick: define fit variable J0shift as J(Vshift) in order to help decoupling the effect of n and J0 in the fit function
+        # trick: define fit variable J0shift as J(Vshift) in order to help
+        # decoupling the effect of n and J0 in the fit function
         # Vshift is where slope of log(V) is highest
         # Change also paramettrization of Rp to get values closer to 1
         J0 = J0 * (np.exp(self.q * Vshift / (n * self.k * self.T)))
         Rp = np.log10(Rp)
         # Fit with n, J0, Rs, Rp
         p0 = np.array([n, J0, Rs, Rp])
         popt, pcov = curve_fit(self.func_diodeResistorsAbsLog10_modParam_red, V, logJ, p0=p0, sigma=sigma)
         [n, J0, Rs, Rp] = popt
         # Jl is never fitted as is computed as to ensure J(V=0) = Jsc
         # restore inital problem parametrization
         Rp = np.power(10, np.abs(Rp))
         Rs = np.abs(Rs)
         J0 = np.abs(J0) / (np.exp(self.q * Vshift / (n * self.k * self.T)))
         # calculation of Jl
-        Jsc = self.getAttribute('Jsc') if self.getAttribute('Jsc') != '' else 0
+        Jsc = self.attr('Jsc') if self.attr('Jsc') != '' else 0
         Jl = self.JlSuchAsJ0VJsc(Jsc, n, J0, Rs, Rp)
         popt = [n, Jl, J0, Rs, Rp]
         return popt, pcov
 
 
-    def func_diodeResistorsAbsLog10_modParam (self, V, n, Jl, J0, Rs, Rp) :
+    def func_diodeResistorsAbsLog10_modParam(self, V, n, Jl, J0, Rs, Rp):
         Vshift = self.fitFixPar['Vshift']
         J0 = J0 / (np.exp(self.q * Vshift / (n * self.k * self.T)))
         Rp = np.power(10, Rp)
-        return np.log10(np.abs(self.func_diodeResistors (V, n, Jl, J0, Rs, Rp)))
+        return np.log10(np.abs(self.func_diodeResistors(V, n, Jl, J0, Rs, Rp)))
 
-    def func_diodeResistorsAbsLog10_modParam_red (self, V, n, J0, Rs, Rp) :
+    def func_diodeResistorsAbsLog10_modParam_red(self, V, n, J0, Rs, Rp):
         Vshift = self.fitFixPar['Vshift']
         Jl = self.fitFixPar['Jl']
         J0 = np.abs(J0) / (np.exp(self.q * Vshift / (n * self.k * self.T)))
         Rp = np.power(10, Rp)
-        return np.log10(np.abs(self.func_diodeResistors (V, n, Jl, J0, Rs, Rp)))
+        return np.log10(np.abs(self.func_diodeResistors(V, n, Jl, J0, Rs, Rp)))
 
-    def func_diodeResistorsAbsLog10 (self, V, n, Jl, J0, Rs, Rp) :
-        return np.log10(np.abs(self.func_diodeResistors (V, n, Jl, J0, Rs, Rp)))
-    def func_diodeResistorsAbsLog (self, V, n, Jl, J0, Rs, Rp) :
-        return np.log(np.abs(self.func_diodeResistors (V, n, Jl, J0, Rs, Rp)))
+    def func_diodeResistorsAbsLog10(self, V, n, Jl, J0, Rs, Rp):
+        return np.log10(np.abs(self.func_diodeResistors(V, n, Jl, J0, Rs, Rp)))
+    def func_diodeResistorsAbsLog(self, V, n, Jl, J0, Rs, Rp):
+        return np.log(np.abs(self.func_diodeResistors(V, n, Jl, J0, Rs, Rp)))
 
     def func_diodeResistors_Jsc(self, V, n, Jl, J0, Rs, Rp):
         if np.isnan(n):
             return [np.nan] * len(V)
 #        return self.func_diodeResistors (V, n, Jl, J0, Rs, Rp)
-        Jsc = self.getAttribute('Jsc') if self.getAttribute('Jsc') != '' else 0
-        return -Jsc + self.func_diodeResistors (V, n, Jl, J0, Rs, Rp)
+        Jsc = self.attr('Jsc') if self.attr('Jsc') != '' else 0
+        return -Jsc + self.func_diodeResistors(V, n, Jl, J0, Rs, Rp)
 
     def JlSuchAsJ0VJsc(self, Jsc, n, J0, Rs, Rp):
         Jl = J0 * (np.exp(self.q / (n * self.k * self.T) * (-Jsc) * Rs) - 1) + ((-Jsc) * Rs) / Rp
         return Jl
 
     def func_diodeResistors (self, V, n, Jl, J0, Rs, Rp) :
         T = self.T
-        Jsc = self.getAttribute('Jsc') if self.getAttribute('Jsc') != '' else 0 # but we need to correct for the J*Rs terms
+        Jsc = self.attr('Jsc') if self.attr('Jsc') != '' else 0  # but we need to correct for the J*Rs terms
         # compute diode equation using the bissection algorithm (slow but robust)
-        Rs = -Rs / 1000 # want kOhm/cm2 as current is given in mA/cm2. Negative value relates to sign convention
-        Rp =  Rp / 1000 # want kOhm/cm2
+        Rs = -Rs / 1000  # want kOhm/cm2 as current is given in mA/cm2. Negative value relates to sign convention
+        Rp =  Rp / 1000  # want kOhm/cm2
         # Jsc was substracted from J, therefore Jl is almost 0
         Jl = self.JlSuchAsJ0VJsc(Jsc, n, J0, Rs, Rp)
         #Jl = J0 * (np.exp(self.q / (n * self.k * T) * (-Jsc) * Rs) - 1) + ((-Jsc) * Rs) / Rp
 
-        def f (J, V, n, Jl, J0, Rs, Rp, Jsc) :
+        def f(J, V, n, Jl, J0, Rs, Rp, Jsc):
             # probe different values of J, with corresponding/unique value of V
             out = - J - (Jl - J0 * (np.exp( self.q / (n * self.k * T) * (V + (J-Jsc) * Rs)) - 1 ) - (V + (J-Jsc) * Rs) / Rp)
-            if np.isinf (out).any() : # do not accept inf values
-                for i in range(len(out)) :
-                    if np.isinf(out[i]) :
+            if np.isinf(out).any():  # do not accept inf values
+                for i in range(len(out)):
+                    if np.isinf(out[i]):
                         out[i] = 1e308 * np.sign(out[i])
             return out
 
         # initial boundary conditions: need 1 J value with positive fuction value, and another with negative value
-        precis = 1e-9 # absolute precision desired on J # for example 1e-7
+        precis = 1e-9  # absolute precision desired on J # for example 1e-7
         Jlow_ = V * 0 - 1e2
         Jhigh = V * 0 + 1e4
-        niter = 1 + (np.log10(np.abs(max(Jhigh - Jlow_))) - np.log10(precis))*3.322 # 15+7 orders of magnitude * 3.322, approx 3.322 iterations to gain x10 in precision
-        flow_ = f (Jlow_, V, n, Jl, J0, Rs, Rp, Jsc)
-        fhigh = f (Jhigh, V, n, Jl, J0, Rs, Rp, Jsc)
+        niter = 1 + (np.log10(np.abs(max(Jhigh - Jlow_))) - np.log10(precis))*3.322  # 15+7 orders of magnitude * 3.322, approx 3.322 iterations to gain x10 in precision
+        flow_ = f(Jlow_, V, n, Jl, J0, Rs, Rp, Jsc)
+        fhigh = f(Jhigh, V, n, Jl, J0, Rs, Rp, Jsc)
         while not (np.sign(flow_) * np.sign(fhigh) < 0).all() and np.abs(Jlow_[0]) < 1e300 :
             Jlow_ = Jlow_ * 1e2
             Jhigh = Jhigh * 1e2
             niter = niter + 2 * 3.322
-            flow_ = f (Jlow_, V, n, Jl, J0, Rs, Rp, Jsc)
-            fhigh = f (Jhigh, V, n, Jl, J0, Rs, Rp, Jsc)
+            flow_ = f(Jlow_, V, n, Jl, J0, Rs, Rp, Jsc)
+            fhigh = f(Jhigh, V, n, Jl, J0, Rs, Rp, Jsc)
 
         # start iterating to find zero of the f function
 #        flow_ = f (Jlow_, V, n, Jl, J0, Rs, Rp)
 #        fhigh = f (Jhigh, V, n, Jl, J0, Rs, Rp)
-        for j in range(int(niter)) : # esti stands for estimator
-            Jesti = (Jlow_ + Jhigh) * 0.5 # bissection. Slow but most robust
-            festi = f (Jesti, V, n, Jl, J0, Rs, Rp, Jsc)
+        for j in range(int(niter)):  # esti stands for estimator
+            Jesti = (Jlow_ + Jhigh) * 0.5  # bissection. Slow but most robust
+            festi = f(Jesti, V, n, Jl, J0, Rs, Rp, Jsc)
             test = (np.sign(festi) == np.sign(flow_))
-            for i in range(len(Jesti)) :
-                if test[i] :
+            for i in range(len(Jesti)):
+                if test[i]:
                     Jlow_[i] = Jesti[i]
                     flow_[i] = festi[i]
-                else :
+                else:
                     Jhigh[i] = Jesti[i]
 #                    fhigh[i] = festi[i] # never actually needed
         # return best result estimate
         return (Jlow_ + Jhigh) * 0.5
 
 
 
 
     def diodeFit_BestGuess(self, V=None, J=None, alsoVShift=True):
         if V is None or J is None:
             V, J = self.cleanDataVJ()
-            Jsc = self.getAttribute('Jsc') if self.getAttribute('Jsc') != '' else 0
+            Jsc = self.attr('Jsc') if self.attr('Jsc') != '' else 0
             J += Jsc
         # compute best guesses
-        Jl = 0 # illumination current is 0 because Jsc takes that into account
+        Jl = 0  # illumination current is 0 because Jsc takes that into account
         # numerical derivative - take care of indexing! -  do not want last point
         dlogJdV = (np.log10(np.abs(J[2:-1])) - np.log10(np.abs(J[0:-3]))) / (V[2:-1] - V[0:-3]) / 2 * (10/np.exp(1)) # (10/np.exp(1)) to convert from log to log10
         idx_maxdlogJdV = len(dlogJdV) - 1
         # to improve
         maxdlogJdV = 0
         for i in np.arange(len(dlogJdV)-1, 0, -1):
-            if dlogJdV[i] > maxdlogJdV :
+            if dlogJdV[i] > maxdlogJdV:
                 idx_maxdlogJdV = i
                 maxdlogJdV = dlogJdV[i]
-            else : # assumed we arrived in low current region -> out of interesting region
-#                print ('end of search for max derivative', V[i+1], J[i+1], dlogJdV[i])
+            else:  # assumed we arrived in low current region -> out of interesting region
+                # print ('end of search for max derivative', V[i+1], J[i+1], dlogJdV[i])
                 break
-            if V[i+1] < 0.15 : # assume the diode behavior should be above 0.15 V
+            if V[i+1] < 0.15:  # assume the diode behavior should be above 0.15 V
                 break
         test = (dlogJdV > 0.9 * maxdlogJdV) * (V[1:-2] > 0.15)
         idx = [i for i in range(len(test)) if test[i]]
         # check is fitting is possible - if there were points with high derivative for V>0.15
-        if len(idx) == 0 :
+        if len(idx) == 0:
             # cell shunted, etc
-            print ('ERROR CurveJV diodeFit: unable to perform fitting (file',self.getAttribute('filename'),').')
+            print('ERROR CurveJV diodeFit: unable to perform fitting (file',self.attr('filename'),').')
             return [np.nan] * (6 if alsoVShift else 5)
         # point with highest numerical derivative
-        idx_maxdlogJdV = int(np.median(idx)) + 1 # indexing correspond to J, V curves#        idx_maxdlogJdV = list(dlogJdV).index(maxdlogJdV) + 1 # indexing correspond to J, V curves
+        idx_maxdlogJdV = int(np.median(idx)) + 1  # indexing correspond to J, V curves#        idx_maxdlogJdV = list(dlogJdV).index(maxdlogJdV) + 1 # indexing correspond to J, V curves
         Vshift = V[idx_maxdlogJdV]
         # Rp: actually no calculation, the standard value is the most robust indicator
-        Rp = self.getAttribute('Rp') # Ohm/cm2
+        Rp = self.getAttribute('Rp')  # Ohm/cm2
         # calculation of n. Starting value between 1 and 2 (* maxV to fit modules)
         maxV = max(1, np.max(V))
         n = self.q / (self.k * self.T * max(0.001, maxdlogJdV)) * 0.75
-        n = min (2 * maxV, max(1, n))
+        n = min(2 * maxV, max(1, n))
 #        Rs = dlogJdV[-1]*0.05  # Ohm/cm2 # rough approximetion, only temporary for I0 estimation! -> not close enough to reality
-        Rs = 0.5 # start with a low value
+        Rs = 0.5  # start with a low value
         # J0: assume Jsc=0, invert diode equation
         i = idx_maxdlogJdV
         J0_init =  np.abs(Jl - J[i] - V[i]/(Rp/1000)) / (np.exp(self.q / (n * self.k * self.T) * (V[i] + J[i] * (-Rs/1000))) - 1)
-        if J0_init == 0: # must prove a sensical starting value
+        if J0_init == 0:  # must prove a sensical starting value
             J0_init = 1e-5
         J0 = J0_init
         # update previous crude value of Rs, by calculation at last point
-        Rs = -1000 * 1/J[-2] * (n*self.k*self.T/self.q * np.log(1 + (J[-2]-Jl)/J0) - V[-2]) # in front for sign convention+units : -1/1000
-        #without Rp. normally good enough Rs_ = -1000 * 1/J[-2] * (n*self.k*self.T/self.q * np.log(1 + (J[-2]-Jl+V[-2]/Rp*1000)/J0) - V[-2]) # in front for sign convention+units : -1/1000
+        Rs = -1000 * 1/J[-2] * (n*self.k*self.T/self.q * np.log(1 + (J[-2]-Jl)/J0) - V[-2])  # in front for sign convention+units : -1/1000
+        # without Rp. normally good enough Rs_ = -1000 * 1/J[-2] * (n*self.k*self.T/self.q * np.log(1 + (J[-2]-Jl+V[-2]/Rp*1000)/J0) - V[-2]) # in front for sign convention+units : -1/1000
         if dlogJdV[-1] > dlogJdV[-2]:
             Rs = 0
         Rs = max(0, Rs)
         if alsoVShift:
             return [n, Jl, J0, Rs, Rp, Vshift]
         return [n, Jl, J0, Rs, Rp]
 
 
 
-    def diodeFit (self, fitRange=None, ifPlot=False, silent=True) :
+    def diodeFit (self, fitRange=None, ifPlot=False, silent=True):
         """ V has to be should be sorted, increasing """
         # select dataset: remove saturated dsatapoints, select according to fitRange
-        diodeFitWeight = self.getAttribute('_fitDiodeWeight') if self.getAttribute('_fitDiodeWeight') != '' else 0
+        diodeFitWeight = self.attr('_fitDiodeWeight') if self.attr('_fitDiodeWeight') != '' else 0
         V, J, Jsc_ = self.selectJVdataForFit(fitRange=fitRange)
-        Jsc = self.getAttribute('Jsc')
-        J_= deepcopy(J)
+        Jsc = self.attr('Jsc')
+        J_ = deepcopy(J)
         J += Jsc
         JLogAbs = np.log10(np.abs(J))
 
         # catch best guess for parameters
         [n, Jl, J0, Rs, Rp, Vshift] = self.diodeFit_BestGuess(V=V, J=J, alsoVShift=True)
         if np.isnan(n):
             self.update({'diodeFit': [np.nan]*5})
             return [np.nan] * 5
 
-        # estimation of noise: minimal noise level, plus relative proportonal to input signal
-        # assuming 8e-3 fluctuations in signal (ie. lamp), and base noise 1e-5*max
-        noise = 1e-5*max(np.abs(J_)) + 8e-3 * np.abs(J_)#J-Jsc
+        # estimation of noise: minimal noise level, plus relative proportonal
+        # to input signal; assuming 8e-3 fluctuations in signal (ie. lamp), and
+        # base noise 1e-5*max
+        noise = 1e-5*max(np.abs(J_)) + 8e-3 * np.abs(J_)  # J-Jsc
         signalToNoise = smooth(np.abs(J_) + 1e-4*max(np.abs(J)) / noise, 5)
         sigma = 1/signalToNoise
 #        sigma = np.power(np.abs(np.log10(np.abs(J+sigma)) - np.log10(np.abs(J))/np.log10(np.abs(J))), 0.25)
         sigma = np.power(np.abs(np.log10(np.abs(J+sigma)) - np.log10(np.abs(J))/np.log10(np.abs(J))), 0.35)
         idx_DiodeRegion = self.idxFitHighSensitivityNJ0(V, derivative(V, np.log10(np.abs(J))))
         if diodeFitWeight != 0:
             for i in idx_DiodeRegion:
                 sigma[i] /= diodeFitWeight
 
-         # perform actual fit
+        # perform actual fit
         try:
-            popt, pcov = self.fit_func_diodeResistors_AbsLog (V, JLogAbs, n, Jl, J0, Rs, Rp, Vshift=Vshift, sigma=sigma)
+            popt, pcov = self.fit_func_diodeResistors_AbsLog(V, JLogAbs, n, Jl, J0, Rs, Rp, Vshift=Vshift, sigma=sigma)
         except RuntimeError as e:
             print('ERROR CurveJV diodeFit:', e)
             return False
 
         # assess fit quality in diode behavior region
-        JfitLogAbs = np.log10(np.abs(self.func_diodeResistors  (V, popt[0], popt[1], popt[2], popt[3], popt[4])))
+        JfitLogAbs = np.log10(np.abs(self.func_diodeResistors(V, popt[0], popt[1], popt[2], popt[3], popt[4])))
         sqResiduals = (JfitLogAbs - JLogAbs) ** 2
         self.diodeFitCheckQuality(sqResiduals[idx_DiodeRegion])
 
-        if not silent :
-            print ('fit diode + resistors')
-            print ('   param, inital, fit')
-            print ('   n ',n,    popt[0], '')
-            print ('   Jl',Jl,   popt[1], 'mA/cm2')
-            print ('   J0',J0,   popt[2], 'mA/cm2')
-            print ('   J0',J0/1000, popt[2]/1000, 'A/cm2')
-            print ('   Rs',Rs,   popt[3], 'Ohmcm2')
-            print ('   Rp',Rp,   popt[4], 'Ohmcm2')
+        if not silent:
+            print('fit diode + resistors')
+            print('   param, inital, fit')
+            print('   n ', n,    popt[0], '')
+            print('   Jl', Jl,   popt[1], 'mA/cm2')
+            print('   J0', J0,   popt[2], 'mA/cm2')
+            print('   J0', J0/1000, popt[2]/1000, 'A/cm2')
+            print('   Rs', Rs,   popt[3], 'Ohmcm2')
+            print('   Rp', Rp,   popt[4], 'Ohmcm2')
 
-        if ifPlot :
+        if ifPlot:
             x = V
-            guess = self.func_diodeResistors (V, n, Jl, J0, Rs, Rp)
-            fit   =self.func_diodeResistors  (x, popt[0], popt[1], popt[2], popt[3], popt[4])
-
-            self.fitFixPar = {'Vshift': Vshift, 'Jl': popt[1], 'Rs': popt[3], 'Rp': popt[4]}
+            guess = self.func_diodeResistors(V, n, Jl, J0, Rs, Rp)
+            fit = self.func_diodeResistors(x, popt[0], popt[1], popt[2], popt[3], popt[4])
 
-            units = self.getAttribute('units')
+            self.fitFixPar = {'Vshift': Vshift, 'Jl': popt[1], 'Rs': popt[3],
+                              'Rp': popt[4]}
 
-            fig,ax = plt.subplots ()
-            ax.plot (V, np.log10(np.abs(J)), 'bx')
- #           ax.plot (V, self.func_diodeIdealAbsLog     (V, n, T, Jl, J0ideal), 'r')
-            ax.plot (V, np.log10(np.abs(guess)), 'r')
-            ax.plot (x, np.log10(np.abs(fit)), 'k')
-#            J0_mod  = popt[2] * (np.exp(self.q * Vshift / (popt[0] * self.k * self.T)))
-#            bestfi_=self.func_diodeResistorsAbsLog10_modParam_red   (x, popt[0]-1, J0_mod*0.6)
-#            ax.plot (x, bestfi_, 'c')
-            ax.set_xlabel ('Bias voltage ['+units[0]+']')
-            ax.set_ylabel ('log(current density ['+units[1]+'])')
+            units = self.attr('units')
 
             fig,ax = plt.subplots ()
-            ax.plot (V, -Jsc + J, 'bx')
-            ax.plot (V, -Jsc + guess, 'r')
-            ax.plot (x, -Jsc + fit, 'k')
-            ax.set_xlabel ('Bias voltage ['+units[0]+']')
-            ax.set_ylabel ('Current density ['+units[1]+']')
+            ax.plot(V, np.log10(np.abs(J)), 'bx')
+            # ax.plot (V, self.func_diodeIdealAbsLog     (V, n, T, Jl, J0ideal), 'r')
+            ax.plot(V, np.log10(np.abs(guess)), 'r')
+            ax.plot(x, np.log10(np.abs(fit)), 'k')
+            #  J0_mod  = popt[2] * (np.exp(self.q * Vshift / (popt[0] * self.k * self.T)))
+            #  bestfi_=self.func_diodeResistorsAbsLog10_modParam_red   (x, popt[0]-1, J0_mod*0.6)
+            #  ax.plot (x, bestfi_, 'c')
+            ax.set_xlabel('Bias voltage ['+units[0]+']')
+            ax.set_ylabel('log(current density ['+units[1]+'])')
+
+            fig, ax = plt.subplots()
+            ax.plot(V, -Jsc + J, 'bx')
+            ax.plot(V, -Jsc + guess, 'r')
+            ax.plot(x, -Jsc + fit, 'k')
+            ax.set_xlabel('Bias voltage ['+units[0]+']')
+            ax.set_ylabel('Current density ['+units[1]+']')
 #            ax.plot (V, sigma, 'c')
 
         self.update({'diodeFit': popt})
         return popt
 
 
     def fit_resampleX(self, Vspacing):
@@ -643,51 +682,53 @@
         if isinstance(Vspacing, list):
             if len(Vspacing) == 3:
                 newV = np.arange(Vspacing[0], Vspacing[1], Vspacing[2])
             else:
                 newV = np.array(Vspacing)
         # if valid input, do something
         if newV != '':
-            self.data = np.array([newV, newV]) # recreate data container, with new x values both in x and y positions. next step it to compute new y values
-            self.updateFitParam(*self.getAttribute('_popt'))
+            # recreate data container, with new x values both in x and y
+            # positions. next step it to compute new y values
+            self.data = np.array([newV, newV])
+            self.updateFitParam(*self.attr('_popt'))
             return 1
         return 'Invalid input.'
 
 
     def calcJsc(self, V=None, J=None):
         # idea: fit 1-degree polynom over 7 points close to V=0
         if V is None:
             V = self.V()
         if J is None:
             J = self.J()
-       # idea: fit 1-degree polynom over 7 points close to V=0
+        # idea: fit 1-degree polynom over 7 points close to V=0
         Vabs = np.abs(V)
         try:
             i = list(Vabs).index(min(Vabs))
-        except ValueError: # if "fake" Curve with a only a single nan inside
+        except ValueError:  # if "fake" Curve with a only a single nan inside
             return np.nan
-        idx = list(range(i-2,i+5) if V[i] < 0 else range (i-3, i+4))
+        idx = list(range(i-2, i+5) if V[i] < 0 else range(i-3, i+4))
         if idx[0] < 0:
             idx = [0, 1, 2, 3, 4, 5]
         idx = [i for i in idx if i >= 0 and i < len(V)]
         z = np.polyfit(V[idx], J[idx], 1, full=True)[0]
         return -z[1]
 
     def calcRp(self, V=None, J=None):
         if V is None:
             V = self.V()
         if J is None:
             J = self.J()
         test = (V > -0.2) * (V < +0.1)
         idx = [i for i in range(len(test)) if test[i]]
-        if idx == [] :
+        if idx == []:
             Vabs = np.abs(V)
             try:
                 i = list(Vabs).index(min(Vabs))
-            except ValueError: # fake JVCurve with only a NaN inside
+            except ValueError:  # fake JVCurve with only a NaN inside
                 return np.nan
             idx = list(range(i-2,i+5) if V[i] < 0 else range (i-3, i+4))
         if idx[0] < 0:
             idx = [0, 1, 2, 3, 4, 5]
         idx = [i_ for i_ in idx if i_ < len(V)]
         z = np.polyfit(V[idx], J[idx], 1, full=True)[0]
         Rp = 1/z[0] * 1000 # *1000 to get in Ohm/cm2 (J is in mA/cm2, so slope fit slope is in kOhm/cm2)
@@ -722,60 +763,68 @@
             J= deepcopy(self.J())
         # remove NaN points
         isnan_ = np.isnan(V) + np.isnan(J)
         V = np.array([V[i] for i in range(len(V)) if not isnan_[i]])
         J = np.array([J[i] for i in range(len(J)) if not isnan_[i]])
         # identify and remove saturated data points
         nSatur = 0
-        for i in np.arange(len(J)-1, 0, -1) :
-            if (J[i] - J[i-1]) / J[i] < 1e-4 :
+        for i in np.arange(len(J)-1, 0, -1):
+            if (J[i] - J[i-1]) / J[i] < 1e-4:
                 nSatur = nSatur + 1
                 J[i] = np.nan
-            else :
+            else:
                 break
         if nSatur > 0 :
             V = V[:-nSatur-1]
             J = J[:-nSatur-1]
         # check if duplicates on V
         if len(np.unique(V)) != len(V):
             print('WARNING CurveJV: duplicate found in V data, unpredictable results!')
+        # check if V is in ascending datapoint order
+        is_sorted = all(a <= b for a, b in zip(V, V[1:]))
+        if not is_sorted:
+            print('Curve JV: input data are not sorted. Presumably ok.')
+            J = np.array([x for _, x in sorted(zip(V, J))])
+            V = np.sort(V)
         return V, J
 
 
     def selectJVdataForFit(self, V=None, J=None, fitRange=None):
         """ Returns dataseet suitable for fitting, taking into account a fit range given by user.
         Saturated datapoints are striped.
         Caution: the value of Jsc return in only computed on the fitRange.
         """
         if V is None:
             V = deepcopy(self.V())
         if J is None:
-            J= deepcopy(self.J())
+            J = deepcopy(self.J())
         # strip saturated datapoints
         V, J = self.cleanDataVJ(V, J)
         # fit range
         idx = self.idxRange(V, fitRange=fitRange)
         Jsc = self.calcJsc(V[idx], J[idx])
         return V[idx], J[idx], Jsc
 
 
     def idxFitHighSensitivityNJ0(self, V, dJLogAbsdV, threshold=0.70, minWidth=None):
-        """ threshold: criterion to select datapoint is that derivative is > threshold*max(deriv)
+        """
+        threshold: criterion to select datapoint is that derivative is > threshold*max(deriv)
         also winimal voltage width for example [-0.05, 0.1]
         """
         if minWidth == None:
             minWidth = [-0.1, 0.1]
 
         # for simplicity rename variable
         dJdV = dJLogAbsdV
 
-        dJdV02V = [dJdV[i] for i in range(len(dJdV)) if V[i] > 0.2] # restrict find maximum to V>0.2, make it more robust
+        # restrict find maximum to V>0.2, make it more robust
+        dJdV02V = [dJdV[i] for i in range(len(dJdV)) if V[i] > 0.2]
         maxDerivIdx = np.where(dJdV == max(dJdV02V))[-1][-1]
-        #print('CurveJV idxFitHighSensitivityNJ0', maxDerivIdx, type(maxDerivIdx))
-        #print('   ',np.where(dJdV == max(dJdV02V)))
+        # print('CurveJV idxFitHighSensitivityNJ0', maxDerivIdx, type(maxDerivIdx))
+        # print('   ',np.where(dJdV == max(dJdV02V)))
         regMaxDerivIdx = [maxDerivIdx]
         flag = True
         for i in range(maxDerivIdx+1, len(V)):
             if dJdV[i] < threshold * dJdV[maxDerivIdx]:
                 flag = False
             if flag or V[i]-V[maxDerivIdx] < minWidth[1]:
                 regMaxDerivIdx.append(i)
@@ -790,21 +839,20 @@
             if not flag and V[i]-V[maxDerivIdx] > minWidth[1]:
                 break
         regMaxDerivIdx = sorted(regMaxDerivIdx)
         return regMaxDerivIdx
 
 
 
-
     def calcResiduals(self, diodeFit=None, ifPlot=False):
         V, J, Jsc = self.selectJVdataForFit(fitRange=[0.1,np.inf])
-        Jsc = self.getAttribute('Jsc') # do not want to use the Jsc calculated with restrictions
+        Jsc = self.getAttribute('Jsc')  # do not want to use the Jsc calculated with restrictions
         J += Jsc
         JLogAbs = np.log10(np.abs(J))
-        dJdV   = derivative (V, JLogAbs)
+        dJdV = derivative (V, JLogAbs)
         d2JdV2 = derivative (V, derivative(V, JLogAbs))
         p = diodeFit if diodeFit is not None else self.getAttribute('diodeFit')
         if p == '':
             p = self.diodeFit()
         Jfit = self.func_diodeResistors(V, p[0], p[1], p[2], p[3], p[4])
         JfitLogAbs = np.log10(np.abs(Jfit))
 
@@ -883,28 +931,69 @@
         if SqResMed > threshold:
             print ('CurveJV diode fit check: probably bad fit of n and I0!\n','   (sq. res.','{:1.4f}'.format(SqResMed),', alert thres.','{:1.4f}'.format(threshold),', fit diode weight','{:1.1f}'.format(diodeFitWeight),')')
             self.update({'_fitDiodeWarning': 'WARNING: n and I0 probably off (sq. res. '+'{:1.4f}'.format(SqResMed)+', threshold '+'{:1.4f}'.format(threshold)+')'})
         else:
             self.update({'_fitDiodeWarning': ''})
 
 
+    def extractJscVoc(self, graph):
+        """
+        Extract Jsc-Voc: extracts Jsc, Voc and T datapoints of selected JV
+        curve, and appends the results to new/existing Curves identified with
+        keywords "_extractJscVoc_Jsc" and "_extractJscVoc_T".
+        """
+        identifierJ = '_extractJscVoc_Jsc'
+        identifierT = '_extractJscVoc_T'
+        if not isinstance(graph, Graph):
+            print('CurveJV.extractJscVoc(): must provide a Graph as parameter')
+            return False
+        self.calcVocJscFFEffMPP()
+        jsc = self.attr('jsc')
+        voc = self.attr('voc')
+        flag = False
+        for c in range(len(graph)):  # store data in suitable curve
+            if graph[c].attr(identifierJ, False):
+                graph[c].appendPoints([voc], [jsc])
+                if (c+1 < len(graph)
+                        and graph[c+1].attr(identifierT, False)
+                        and len(graph[c].x()) == len(graph[c+1].x())+1):
+                    graph[c+1].appendPoints([voc], [self.T])
+                else:
+                    print('WARNING: CurveJV extractJscVoc: could not identify',
+                          'curve to store temperature, or data length',
+                          'mismatch')
+                flag = True
+                break
+        if not flag:
+            attr = {'label': 'Voc-Jsc pair', 'linespec': 'o',
+                    'type': 'scatter', identifierJ: True}
+            curve0 = Curve([[voc], [jsc]], attr)
+            graph.append(curve0)
+            curve1 = Curve([[voc], [self.T]], {identifierT: True,
+                                               'type': 'scatter_c'})
+            graph.append(curve1)
+            graph.castCurve('CurveJscVoc', -2, silentSuccess=True)
+        return True
+
 
     def printHelp(self):
         print('*** *** ***')
         print('CurveJV offer basic treatment of J-V curves of solar cells.')
         print('Input units are [V] and [mA] (or [mA cm-2]).')
         print('Curve transforms:')
-        print(' - Linear: standard is current density [mA cm-2] versus [V].')
-        print(' - Log 10 abs: logarithm of (J-Jsc). Allows visualize Rp, Rs and diode.')
+        print('- Linear: standard is current density [mA cm-2] versus [V].')
+        print('- Log 10 abs: logarithm of (J-Jsc). Allows visualize Rp, Rs and diode.')
         print('Analysis functions:')
-        print(' - Set area: normalize the cell area.')
-        print(' - Voc, Jsc, FF, Eff, MPP: computes the basic cell parameters.')
-        print(' - JV fit: fits the log(JV) curve using a 1 diode + 2 resistors model.')
-        print('   The fit should be assessed visually on the log plot.')
-        print('   J0: good values are typically < 1e-4.')
-        print('   n: is ideality factor. Good values are < 1.7.')
-        print('   Jl: is here the difference of the Jl of the model and Jsc.')
-        print('       it is no fit parameter, but is adjusted so that J(V=0) = Jsc.')
-        print(' - JV curve initial guess: starting point of the JV fit.')
+        print('- Set area: normalize the cell area.')
+        print('- Voc, Jsc, FF, Eff, MPP: computes the basic cell parameters.')
+        print('- JV fit: fits the log(JV) curve using a 1 diode + 2 resistors',
+              'model. The fit quality should be assessed visually on lin and',
+              'log plots.')
+        print('  J0: good values are typically < 1e-4.')
+        print('  n: is ideality factor. Good values are < 1.7.')
+        print('  Jl: is here the difference of the Jl of the model and Jsc.')
+        print('      it is no fit parameter, but is adjusted so that J(V=0) = Jsc.')
+        print('- JV curve initial guess: starting point of the JV fit.')
+        self.printHelpFunc(CurveJV.extractJscVoc)
         print('Further analysis:')
-        print(' - J0 can also be computed from Jsc vs Voc couples with different light intensities.')
+        print('- J0 can also be computed from Jsc vs Voc couples with different light intensities.')
         return True
```

### Comparing `grapa-0.5.4.8/grapa/datatypes/curveMCA.py` & `grapa-0.6.1.0/grapa/datatypes/graphMCA.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,100 +1,93 @@
 # -*- coding: utf-8 -*-
 """
-Created on Tue Sep 13 15:44:58 2016
-
 @author: Romain Carron
-Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain
+Carron
 """
 
-import numpy as np
 from re import findall as refindall
+import numpy as np
 
+from grapa.mathModule import is_number, strToVar
 from grapa.graph import Graph
-from grapa.curve import Curve
-from grapa.mathModule import is_number
+from grapa.datatypes.curveMCA import CurveMCA
 
 
 class GraphMCA(Graph):
-    
+
     FILEIO_GRAPHTYPE = 'XRF MCA raw data'
-    
-    AXISLABELS = [['XRF detector channel', '', ' '], ['Counts per s', '', 'cps']]
+
+    AXISLABELS = [['XRF detector channel', '', ' '],
+                  ['Counts per s', '', 'cps']]
 
     @classmethod
     def isFileReadable(cls, fileName, fileExt, line1='', line2='', line3='', **kwargs):
         if fileExt == '.mca' and line1 == '<<PMCA SPECTRUM>>':
             return True
         return False
-        
+
     def readDataFromFile(self, attributes, **kwargs):
+        def categ(line, old):
+            if line.startswith('<<'):
+                return line.replace('<', '').replace('>', '')
+            return old
+
         # parse file
         y = np.array([])
-        f = open(self.filename, 'r')
         line = ''
-        while line != '<<DATA>>':
-            line = f.readline().strip(' \r\n\t')
-            split = refindall('([^-]+) - ([^-]+)', line)
-            if len(split) > 0 and len(split[0]) > 1:
-                self.sampleInfo[split[0][0]] = split[0][1]
-        flag = True
-        while flag:
-            line = f.readline().strip(' \r\n\t')
-            if is_number(line):
-                y = np.append(y, float(line))
-            else:
-                flag = False
-        while 1:
-            line = f.readline().strip(' \r\n\t')
-            if not line:
-                break
-            split = refindall('([^0-9]+): ([-+]?[0-9]*\.?[0-9]+) *([^0-9]*)', line)
-            if len(split) > 0 and len(split[0]) > 2:
-                tmp = split[0][2]
-                if len(split[0][2]) > 0:
-                    tmp = ' ['+split[0][2]+']'
-                self.sampleInfo[split[0][0]+tmp] = float(split[0][1])
-        f.close()
-        # format data
-        if 'Preset [sec]' not in self.sampleInfo and 'Preset [min]' in self.sampleInfo:
-            self.sampleInfo['Preset [sec]'] = self.sampleInfo['Preset [min]'] * 60
-        if 'Preset [sec]' in self.sampleInfo:
-            attributes.update({'Preset [sec]': self.sampleInfo['Preset [sec]']})
-        self.data.append(CurveMCA(np.append(np.arange(y.size), y).reshape((2, y.size)), attributes))
-        self.update({'muloffset': "1/"+str(self.getAttribute('Preset [sec]'))})
-        # important info, want to store in the curve itself
-        self.headers.update({'collabels': ['Channel [ ]', 'Counts [ ]']})
-        self.graphInfo.update({'xlabel': self.formatAxisLabel(GraphMCA.AXISLABELS[0]),
-                               'ylabel': self.formatAxisLabel(GraphMCA.AXISLABELS[1])})
+        category = ''
+        with open(self.filename, 'r') as file:
+            # first section
+            while line != '<<DATA>>':
+                line = file.readline().strip(' \r\n\t')
+                category = categ(line, category)
+                split = refindall('([^-]+) - ([^-]+)', line)
+                if len(split) > 0 and len(split[0]) > 1:
+                    at = category+'.'+split[0][0]
+                    attributes.update({at: strToVar(split[0][1])})
+            # data
+            flag = True
+            while flag:
+                line = file.readline().strip(' \r\n\t')
+                if is_number(line):
+                    y = np.append(y, float(line))
+                else:
+                    category = categ(line, category)
+                    flag = False
+            # parameters at end
+            while 1:
+                line = file.readline().strip(' \r\n\t')
+                if not line:
+                    break
+                category = categ(line, category)
+                expr = r'([^0-9]+): ([-+]?[0-9]*\.?[0-9]+) *([^0-9]*)'
+                split = refindall(expr, line)
+                if len(split) == 0:
+                    expr = r'([^0-9]+): (\w+)()'
+                    split = refindall(expr, line)
+                if len(split) > 0 and len(split[0]) > 2:
+                    tmp = split[0][2]
+                    if len(split[0][2]) > 0:
+                        tmp = ' ['+split[0][2]+']'
+                    at = category + '.' + split[0][0] + tmp
+                    attributes.update({at: strToVar(split[0][1])})
+                else:
+                    pass  # not interesting input (section title, etc.)
+            # close file at en of with section
+        # format data, create Curve
+        data = np.append(np.arange(y.size), y).reshape((2, y.size))
+        at = 'DPP CONFIGURATION.Preset'
+        if at+' [sec]' not in attributes and at+' [min]' in attributes:
+            attributes[at+' [sec]'] = attributes[at+' [min]'] * 60
+        self.append(CurveMCA(data, attributes))
+        self[-1].update({'muloffset': "1/" + str(self.attr(at+' [sec]'))})
+        if self[-1].attr('sample') == '':
+            self[-1].update({'sample': self[-1].attr('label')})
+        # graph cosmetics
+        self.update({'collabels': ['Channel [ ]', 'Counts [ ]']})
+        self.update({'xlabel': self.formatAxisLabel(GraphMCA.AXISLABELS[0]),
+                     'ylabel': self.formatAxisLabel(GraphMCA.AXISLABELS[1])})
         if y.size == 1024:
-            self.graphInfo.update({'xlim': [0, 1024]})
-        print('Opened MCA raw data file. To know composition, open .html file instead.')
-
-
-
-        
-class CurveMCA(Curve):
-    
-    CURVE = 'Curve MCA'
-    
-    def __init__(self, data, attributes, silent=False):
-        # main constructor
-        Curve.__init__(self, data, attributes, silent=silent)
-        self.update({'Curve': CurveMCA.CURVE})
-        self.update({'_MCA_CtokeV_offset': -3.35, '_MCA_CtokeV_mult': 0.031490109515627})
-
-    # GUI RELATED FUNCTIONS
-    def funcListGUI(self, **kwargs):
-        out = Curve.funcListGUI(self, **kwargs)
-        at = ['_MCA_CtokeV_offset', '_MCA_CtokeV_mult']
-        out.append([self.updateValuesDictkeys, 'Save',
-                    ['keV = (channel +', ') * '],
-                    [self.getAttribute(a) for a in at], {'keys': at}])
-        # format: [func, 'func label', ['input 1', 'input 2', 'input 3', ...]]
-#out.append([self.dataModifySwapChannelkeV, 'change data Channel<->keV', [], []]) # one line per function
-        return out
-    
-    def alterListGUI(self):
-        out = Curve.alterListGUI(self)
-        out += [['Channel <-> keV', ['MCAkeV', ''], '']]
-        return out
-
+            self.update({'xlim': [0, 1024]})
+        print('Opened MCA raw data file. To know composition, open .html file',
+              'instead.')
```

### Comparing `grapa-0.5.4.8/grapa/datatypes/curveSIMS.py` & `grapa-0.6.1.0/grapa/datatypes/curveSIMS.py`

 * *Files 11% similar despite different names*

```diff
@@ -9,36 +9,39 @@
 
 from grapa.curve import Curve
 from grapa.mathModule import roundSignificant
 
 
 def findXAtValuePolynom(datax, datay, target, ifPlot=False):
     if len(datax) < 3 or len(datay) < 3:
-        print('ERROR CurveSIMS findXAtValuePolynom: not enough data to fit 3rd degree polynom, returned 0.')
+        print('ERROR CurveSIMS findXAtValuePolynom: not enough data to fit',
+              '3rd degree polynom, returned 0.')
         return [0, 0]
     z = np.polyfit(datax, datay, 3, full=True)[0]
     roots = np.roots((np.poly1d(z) - target))
     rootsReal = np.real(roots[np.isreal(roots)])
     rootsInROI = rootsReal[(rootsReal >= min(datax)) * (rootsReal <= max(datax))]
     if len(rootsInROI) == 0:
         rootsInROI = rootsReal
     if len(rootsInROI) == 0:
         print('Error findXAtValuePolynom cannot find suitable value.', target, datax, datay)
-    root = np.average(rootsInROI)  # to handle cases where the polynom has several solutions
+    # to handle cases where the polynom has several solutions
+    root = np.average(rootsInROI)
     idx = np.argmin(np.abs(datax - root))
     if ifPlot:
         import matplotlib.pyplot as plt
         plt.figure()
         plt.plot(datax, datay, '.-b')
         plt.plot(datax, np.polyval(z, datax), 'k')
     return [root, idx]
 
-# identify transition from low to high level
-def selectDataEdge(curve, ROI, targetRel=None, threshRel=None,
-                    ifTrailingEdge=False):
+def selectDataEdge(curve, ROI, targetRel=None, threshRel=None, ifTrailingEdge=False):
+    """
+    Identify transition from low to high level
+    """
     if targetRel is None:
         targetRel = 0.5
     if threshRel is None:
         threshRel = [targetRel*0.6, targetRel*0.6+1*0.4]
     y = copy.deepcopy(curve.y(index=ROI))
     iMin, iMax = y.argmin(), y.argmax()
     targetAbs = y[iMin] + targetRel * (y[iMax] - y[iMin])
@@ -60,51 +63,51 @@
 
     CURVE = 'Curve SIMS'
 
     def __init__(self, *args, **opts):
         Curve.__init__(self, *args, **opts)
         self.update({'Curve': CurveSIMS.CURVE})
         # SIMS data files are a bit special, header start with empty cell
-        if self.getAttribute('label') == '' and self.getAttribute('empty0') != '':
-            self.update({'label': self.getAttribute('empty0'), 'empty0': ''})
+        if self.attr('label') == '' and self.attr('empty0') != '':
+            self.update({'label': self.attr('empty0'), 'empty0': ''})
         # some additional attributes, which must not override data saved in the data file
-        add = {'_SIMSelement': self.getAttribute('label'),
-                '_SIMSmsmt': ''.join(self.getAttribute('filename').split('/')[-1].split('\\')[-1].split('.')[:-1]).replace('_',''),
+        add = {'_SIMSelement': self.attr('label'),
+                '_SIMSmsmt': ''.join(self.attr('filename').split('/')[-1].split('\\')[-1].split('.')[:-1]).replace('_',''),
                 '_SIMStotal': 0,
                 '_SIMSYieldCoef': 1}
         for key in add:
-            if self.getAttribute(key) == '':
+            if self.attr(key) == '':
                 self.update({key: add[key]})
         # check and clean first 2 empty lines (total and header lines might have been mistaken)
         if np.isnan(self.x(index=1)) and np.isnan(self.y(index=1)):
             self.update({'_SIMStotal': self.y(index=0)})
             self.data = np.array([self.x()[2:], self.y()[2:]])
 
     # RELATED TO GUI
     def funcListGUI(self, **kwargs):
         from grapa.datatypes.graphSIMS import GraphSIMS
-        msmtIdDict = {'msmtId': self.getAttribute('_SIMSmsmt')}
-        ratios = [k for k in GraphSIMS.KEYWORDS.keys()] + ['other ratio'] #  + ['ratio as ["elem0"],["elem1","elem2"]']
+        msmtIdDict = {'msmtId': self.attr('_SIMSmsmt')}
+        ratios = [k['aliases'][0] for k in GraphSIMS.SHORTCUTS] + ['other ratio'] #  + ['ratio as ["elem0"],["elem1","elem2"]']
         out = Curve.funcListGUI(self, **kwargs)
         # format: [func, 'func label', ['input 1', 'input 2', 'input 3', ...] (, [default1, default2, ...], {'hiddenVar1':value1}) ]
         out.append([self.localizeEdgeFromGUI,
                     'Find edge',
                     ['ROI', 'target', 'threshold', 'edge'],
-                    [[self.x(0), self.x(self.shape(1)-1)], 0.5, [0.3,0.7], 'leading'],
+                    [[self.x(0), self.x(self.shape(1)-1)], 0.5, [0.3 ,0.7], 'leading'],
                     {},
-                    [{},{},{},
-                     {'field':'Combobox', 'values':['leading','trailing'], 'width':7}]])
-        ROI = [self.x(0), self.x(self.shape(1)-1)] if self.getAttribute('_SIMSLayerBoundaries') == '' else self.getAttribute('_SIMSLayerBoundaries')
-        depth = (ROI[1] - ROI[0]) * self.getAttribute('_SIMSdepth_mult') if self.getAttribute('_SIMSdepth_mult') != '' else 2
+                    [{}, {}, {},
+                     {'field': 'Combobox', 'values': ['leading', 'trailing'], 'width': 7}]])
+        ROI = [self.x(0), self.x(self.shape(1)-1)] if self.attr('_SIMSLayerBoundaries') == '' else self.attr('_SIMSLayerBoundaries')
+        depth = (ROI[1] - ROI[0]) * self.attr('_SIMSdepth_mult') if self.attr('_SIMSdepth_mult') != '' else 2
         out.append([GraphSIMS.setLayerBoundariesDepthParametersGUI, 'Calibrate depth', ['Depth', 'ROI'], [depth, roundSignificant(ROI,5)], msmtIdDict])
         labels = ['^113In+']
         if 'graph' in kwargs:
             labels = []
             for c in kwargs['graph'].curves('_SIMSmsmt', msmtIdDict['msmtId']):
-                labels.append(c.getAttribute('_SIMSelement'))
+                labels.append(c.attr('_SIMSelement'))
             if len(labels) == 0:
                 labels = ['^113In+']
         out.append([GraphSIMS.targetRatioSetYieldGUI,
                     'Adjust compos.',
                     ['ROI', 'Ratio', 'Elem.', 'Compos.'],
                     [ROI, 'GGI', ('^113In+' if '^113In+' in labels else labels[0]), 0.35],
                     msmtIdDict,
@@ -117,105 +120,123 @@
         out.append([GraphSIMS.appendReplaceCurveRatioGUISmt,
                     'Create curve ratio',
                     ['Ratio', 'Curve name', 'Smooth S-G w', 'd'],
                     ['GGI', 'GGI', 1, 1],
                     msmtIdDict,
                     [{'field': 'Combobox', 'values': ratios, 'width': 6},
                         {}, {}, {}]])
+        out.append([self.cropDataROI, 'Crop trace inside ROI', ['ROI'], [ROI]])
         out.append([self.printHelp, 'Help!', [], []])
         return out
 
     def alterListGUI(self):
         out = Curve.alterListGUI(self)
         out += [['Semilogy', ['', 'idle'], 'semilogy']]
         out += [['Raw <-> Depth', ['SIMSdepth', ''], 'semilogy']]
         return out
     # alter: s to z, normalized (in toggle switch?)
 
     def setDepthParameters(self, offset, mult):
         self.update({'_SIMSdepth_offset': offset, '_SIMSdepth_mult': mult})
 
     # other methods
-    def localizeEdge(self, ROI, targetRel, threshRel=None, ifTrailingEdge=False,
-                     ROIrefinement=0):
+    def localizeEdge(self, ROI, targetRel, threshRel=None, ifTrailingEdge=False, ROIrefinement=0):
         # check if ROI is a actual range or only extrema
-        if isinstance(ROI, (list, tuple)) and len(ROI) == 2 and np.abs(ROI[1]-ROI[0]) > 1:
+        if (isinstance(ROI, (list, tuple)) and len(ROI) == 2
+                and np.abs(ROI[1]-ROI[0]) > 1):
             ROI.sort()
             ROI = range(int(ROI[0]), int(ROI[1]))
 #            print ('Localize edge ROI correction (', min(ROI), max(ROI), ')')
         else:
             pass
         # first localize max in ROI, then compute max*target and select data subset [max*threshold[0], max*threshold[1]]
         [datax, datay, targetAbs, rangeThresholds] = selectDataEdge(self, ROI, targetRel, ifTrailingEdge=ifTrailingEdge, threshRel=threshRel)
         # then interpolate data subset with polynom, and find intersection with target*max
         [root, idx] = findXAtValuePolynom(datax, datay, targetAbs)
         idx += rangeThresholds[0]
         if ROIrefinement > 0:
             delta = ROIrefinement * (np.array([min(rangeThresholds), max(rangeThresholds)]) - idx)
-            delta[0], delta[1] = idx + min(delta[0], idx-1), idx + max(delta[1], idx+1) # check at least 1 point enlargment
-            delta[0], delta[1] = max(0, delta[0]), min(delta[1], len(self.y())-1) # check indices are valid
-            delta[0], delta[1] = max(min(ROI), delta[0]), min(delta[1], max(ROI)) # do not want a larger ROI than before
-            [root, idx] = self.localizeEdge(range(delta[0], delta[1]), targetRel, threshRel=threshRel, ifTrailingEdge=ifTrailingEdge)
+            # check at least 1 point enlargment
+            delta[0], delta[1] = idx + min(delta[0], idx-1), idx + max(delta[1], idx+1)
+            # check indices are valid
+            delta[0], delta[1] = max(0, delta[0]), min(delta[1], len(self.y())-1)
+            # do not want a larger ROI than before
+            delta[0], delta[1] = max(min(ROI), delta[0]), min(delta[1], max(ROI))
+            [root, idx] = self.localizeEdge(range(delta[0], delta[1]),
+                                            targetRel, threshRel=threshRel,
+                                            ifTrailingEdge=ifTrailingEdge)
         return [root, idx]
 
     def localizeEdgeFromGUI(self, ROI, targetRel, threshRel, ifTrailingEdge):
         # assumes ROI is in the form [sputterTimeMin, sputterTimeMax]
         if ifTrailingEdge == 'trailing':
             ifTrailingEdge = True
         elif ifTrailingEdge == 'leading':
             ifTrailingEdge = False
         if len(list(ROI)) > 2:
             ROI = [min(ROI), max(ROI)]
-        ROI = [np.argmin(np.abs(self.x() - ROI[0])), np.argmin(np.abs(self.x() - ROI[1]))]
-        res = self.localizeEdge(ROI, targetRel, threshRel=threshRel, ifTrailingEdge=ifTrailingEdge)
-        return 'Edge position for curve ' + self.getAttribute('_SIMSelement') + ' at: ' + str(roundSignificant(res[0],5))
+        ROI = [np.argmin(np.abs(self.x() - ROI[0])),
+               np.argmin(np.abs(self.x() - ROI[1]))]
+        res = self.localizeEdge(ROI, targetRel, threshRel=threshRel,
+                                ifTrailingEdge=ifTrailingEdge)
+        return ('Edge position for curve ' + self.attr('_SIMSelement')
+                + ' at: ' + str(roundSignificant(res[0], 5)))
 
     # find indices of
-    def findLayerBorders(self, ROI=None, targetRel=0.5, threshRel=[0.3,0.7],
-                         ROIrefinement=0, returnIdx=True):
+    def findLayerBorders(self, ROI=None, targetRel=0.5, threshRel=[0.3, 0.7], ROIrefinement=0, returnIdx=True):
         # targetRel = None#0.5
         # threshRel = None # [0.3, 0.7]
         if ROI is None:  # [range(0,10), range(10,20)]
             ROI = [range(0, int(self.shape(1)/2)), range(int(self.shape(1)/2), int(self.shape(1)))]
         posInterfGaIn = [np.nan, np.nan]
         for i in range(2):
             [root, idx] = self.localizeEdge(ROI[i], targetRel, threshRel=threshRel, ifTrailingEdge=i, ROIrefinement=ROIrefinement)
             posInterfGaIn[i] = idx if returnIdx else root
         return posInterfGaIn
 
+    def cropDataROI(self, ROI):
+        """
+        Crop trace inside ROI: delete datapoints with x value outside specified
+        range.
+        """
+        x, y = self.x(), self.y()
+        mask = (x >= np.min(ROI)) * (x <= np.max(ROI))
+        self.data = np.array([x[mask], y[mask]])
+
     def printHelp(self):
         from grapa.datatypes.graphSIMS import GraphSIMS
         print('*** *** ***')
         print('CurveSIMS offer some basic processing of SIMS data.')
         print('Each can notably compute ratios of curves, for which a relative yield has to be provided.')
         print('Curves ratios are noted with keywords such as "ggi", or as "[[\'^71Ga+\'],[\'^71Ga+\', \'^113In+\']]". For 1st and 2nd list the curves multiplied by their yield are summed, and the ratio is finally computed. An empty top or bottom list is replaced by 1.')
         print('List of existing keywords:')
-        for key in GraphSIMS.KEYWORDS:
-            print('   ' + key + ':', str(GraphSIMS.KEYWORDS[key]))
+        for short in GraphSIMS.SHORTCUTS:
+            print('   ' + short['aliases'][0] + ':', str(short['short']))
         print('Curve transforms:')
-        print(' - Semilogy, with etching time as default x coordinate,')
-        print(' - Raw <-> Depth: depth as x axis, provided depth was calibrated (see analysis functions).')
+        print('- Semilogy, with etching time as default x coordinate,')
+        print('- Raw <-> Depth: depth as x axis, provided depth was calibrated (see analysis functions).')
         print('Analysis functions:')
-        print(' - Find edge: auto-detect edges in the selected curve. Parameters:')
-        print('   ROI: range of interest, in units of input x data,')
-        print('   Target: default 0.5,')
-        print('   Threshold: default [0.3,0.7]')
-        print('   ifTrailing: 0 if leading edge, 1 if trailing edge.')
-        print(' - Calibrate depth: calibrate depth by linear scaling of input x axis. Parameters:')
-        print('   Depth: know depth of ROI,')
-        print('   ROI: range of interest, in units of input x data.')
-        print(' - Adjust composition: adjust the relative SIMS yield of a curve such that the chosen')
-        print('   curve ratio has the chosen value within the selected range of interest. Parameters:')
-        print('   ROI: range of interest, in units of input x data,')
-        print('   Ratio: which Curve ratio is to be adjusted,')
-        print('   Element: which element the yield has to be adjusted,')
-        print('   Compos: the know composition we want to reach by adjusting the element yield.')
-        print(' - Compute ratio: computes a ratio of curves within a ROI.')
-        print('   ROI: range of interest, in units of input x data,')
-        print('   Ratio: which Curve ratio is to be computed.')
-        print(' - Create curve ratio: creates a Curve computed as a ratio of Curves.')
-        print('   Ratio: which Curve ratio is to be computed,')
-        print('   Curve name: give it a beautiful name.')
-        print('   Smooth S-G w, d: a Savitsky-Golay smoothening can be applied to the elemental traces')
-        print('   prior to combination, using window and degree. No effect if w 1 d 1, possibly w 21 d 3.')
+        print('- Find edge: auto-detect edges in the selected curve. Parameters:')
+        print('  ROI: range of interest, in units of input x data,')
+        print('  Target: default 0.5,')
+        print('  Threshold: default [0.3,0.7]')
+        print('  ifTrailing: 0 if leading edge, 1 if trailing edge.')
+        print('- Calibrate depth: calibrate depth by linear scaling of input x axis. Parameters:')
+        print('  Depth: know depth of ROI,')
+        print('  ROI: range of interest, in units of input x data.')
+        print('- Adjust composition: adjust the relative SIMS yield of a curve such that the chosen')
+        print('  curve ratio has the chosen value within the selected range of interest. Parameters:')
+        print('  ROI: range of interest, in units of input x data,')
+        print('  Ratio: which Curve ratio is to be adjusted,')
+        print('  Element: which element the yield has to be adjusted,')
+        print('  Compos: the know composition we want to reach by adjusting the element yield.')
+        print('- Compute ratio: computes a ratio of curves within a ROI.')
+        print('  ROI: range of interest, in units of input x data,')
+        print('  Ratio: which Curve ratio is to be computed.')
+        print('- Create curve ratio: creates a Curve computed as a ratio of Curves.')
+        print('  Ratio: which Curve ratio is to be computed,')
+        print('  Curve name: give it a beautiful name.')
+        print('  Smooth S-G w, d: a Savitsky-Golay smoothening can be applied to the elemental traces')
+        print('  prior to combination, using window and degree. No effect if w 1 d 1, possibly w 21 d 3.')
+        self.printHelpFunc(self.cropDataROI, leadingstrings=None)
         print('   ')
         return True
```

### Comparing `grapa-0.5.4.8/grapa/datatypes/curveSpectrum.py` & `grapa-0.6.1.0/grapa/datatypes/curveSpectrum.py`

 * *Files 9% similar despite different names*

```diff
@@ -8,110 +8,111 @@
 
 import os
 import numpy as np
 
 from grapa.graph import Graph
 from grapa.curve import Curve
 from grapa.mathModule import is_number
-    
 
 # TODO: better parse perkin elmer Reflectnce/transmittance
 # TODO: substract absorption in substrate
 
 
 class CurveSpectrum(Curve):
     """
     Class handling optical spectra, with notably nm to eV conversion and
     background substraction.
     """
-    
+
     CURVE = 'Curve Spectrum'
     FILE_INSTR_RESP = None
     FILE_SUBSTRATES = None
     LIST_SUBSTRATES = None
-    
+
     def __init__(self, data, attributes, silent=False):
         # main constructor
         Curve.__init__(self, data, attributes, silent=silent)
         # initialize
-        self.update ({'Curve': CurveSpectrum.CURVE})
+        self.update({'Curve': CurveSpectrum.CURVE})
         self.update({'_spectrumGUIoffset': True, '_spectrumGUIdark': True})
         subclass = self.getSubclass()
         if subclass is not None:
             subclass.initialize(self)
-        
 
     # GUI RELATED FUNCTIONS
     def funcListGUI(self, **kwargs):
         out = Curve.funcListGUI(self, **kwargs)
         # format: [func, 'func label', ['input 1', 'input 2', 'input 3', ...]]
         # choice between subclass
         subclass = self.getSubclass()
         # nm <> eV conversion
-        out.append([self.dataModifySwapNmEv, 'change data nm<->eV', [], []]) # one line per function
+        out.append([self.dataModifySwapNmEv, 'change data nm<->eV', [], []])
         # subtype
         choices = ['undefined']
-        choices+= [s.__name__.replace('CurveSpectrum','') for s in self.subclasses]
-        currentsubclass = subclass.__name__.replace('CurveSpectrum','') if subclass is not None else 'undefined'
-        unit = str(self.getAttribute('_spectrumunit'))
+        choices += [s.__name__.replace('CurveSpectrum', '') for s in self.subclasses]
+        currentsubclass = subclass.__name__.replace('CurveSpectrum', '') if subclass is not None else 'undefined'
+        unit = str(self.attr('_spectrumunit'))
         out.append([self.setSubclass, 'Save', ['Spectrum type', 'unit'],
                     [currentsubclass, unit], {},
-                    [{'field': 'Combobox', 'values': choices}, 
+                    [{'field': 'Combobox', 'values': choices},
                      {'field': 'Combobox', 'values': ['(no unit)', '%']}]])
         # offset
-        if self.getAttribute('_spectrumGUIoffset'):
-            out.append([self.addOffset, 'Add offset', ['new offset'], [self.getOffset()]]) # one line per function
+        if self.attr('_spectrumGUIoffset'):
+            out.append([self.addOffset, 'Add offset', ['new offset'],
+                        [self.getOffset()]])  # one line per function
         # dark
-        if self.getAttribute('_spectrumGUIdark'):
+        if self.attr('_spectrumGUIdark'):
             iddark = []
             if 'graph' in kwargs:
                 for c in range(kwargs['graph'].length()):
-                    iddark.append(str(c)+' '+kwargs['graph'].curve(c).getAttribute('label')[:6])
+                    iddark.append(str(c)+' '+kwargs['graph'].curve(c).attr('label')[:6])
             else:
                 print('graph must be provided to funcListGUI')
                 kwargs['graph'] = None
             out.append([self.substractBG, 'Substract dark',
                         ['id dark', '', '', ''],
                         ['0', '1 interpolate both', '1 new curve', '0 ignore offset'],
                         {'graph': kwargs['graph'], 'operator': 'sub'},
-                        [{'field':'Combobox', 'bind':'beforespace', 'width':4, 'values':iddark},
-                         {'field':'Combobox', 'width':13,'values':['1 interpolate both', '2 interpolate dark', '0 element-wise']},
-                         {'field':'Combobox', 'width':8, 'values':['1 new curve', '0 replace']},
-                         {'field':'Combobox', 'width':13,'values':['0 ignore offsets', '1 with offsets']}]])
+                        [{'field': 'Combobox', 'bind': 'beforespace', 'width': 4, 'values': iddark},
+                         {'field': 'Combobox', 'width': 13, 'values': ['1 interpolate both', '2 interpolate dark', '0 element-wise']},
+                         {'field': 'Combobox', 'width': 8, 'values': ['1 new curve', '0 replace']},
+                         {'field': 'Combobox', 'width': 13, 'values': ['0 ignore offsets', '1 with offsets']}]])
         # integration
         try:
             from grapa.datatypes.curveTRPL import CurveTRPL
             from grapa.mathModule import roundSignificantRange
             alter = str(kwargs['graph'].attr('alter')) if 'graph' in kwargs else "['', '']"
             ROI = roundSignificantRange([min(self.x()), max(self.x())], 2)
             out.append([CurveTRPL.integrate, 'Integrate',
-                        ['ROI', 'data transform'], [ROI, alter], {'curve': self},
-                        [{}, {'field':'Combobox','values': ['raw', alter]}]])
+                        ['ROI', 'data transform'], [ROI, alter],
+                        {'curve': self},
+                        [{}, {'field': 'Combobox', 'values': ['raw', alter]}]])
         except ImportError:
             pass
         # other, specific
         if subclass is not None and hasattr(subclass, 'funcListGUISpecific'):
             out += subclass.funcListGUISpecific(self, **kwargs)
         # help
-        out.append([self.printHelp, 'Help!', [], []]) # one line per function
+        out.append([self.printHelp, 'Help!', [], []])  # one line per function
         return out
-    
+
     def alterListGUI(self):
         out = Curve.alterListGUI(self)
         out += [['nm <-> eV', ['nmeV', ''], '']]
         out += [['nm <-> cm-1', ['nmcm-1', ''], '']]
         return out
 
     def getSubclass(self):
         self.subclasses = CurveSpectrum.__subclasses__()
-        val = self.getAttribute('_spectrumSubclass')
+        val = self.attr('_spectrumSubclass')
         for s in self.subclasses:
             if val == s.__name__:
                 return s
         return None
+
     def setSubclass(self, newtype, unit):
         """
         Spectrum type: set the Spectrum spectrum, affecting the GUI actions.
         Parameters:
         - newtype: subclass of CurveSpectrum. Examples:
           'CurveSpectrumReflectance', 'CurveSpectrumTransmittance', etc.
         - unit: empty, or '%' if data are in percent units.
@@ -128,38 +129,40 @@
             for s in CurveSpectrum.__subclasses__():
                 if newtype == s.__name__:
                     self.update({'_spectrumSubclass': newtype})
                     return True
             print('CurveSpectrum.setSubclass: cannot find class', newtype)
             return False
         return True
-    
+
     @classmethod
     def fileInstrResp(cls):
         if CurveSpectrum.FILE_INSTR_RESP is None:
             path = os.path.dirname(os.path.abspath(__file__))
             ref = Graph(os.path.join(path, 'spectrumInstrumentalResponses.txt'))
             CurveSpectrum.FILE_INSTR_RESP = ref
         return CurveSpectrum.FILE_INSTR_RESP
+
     @classmethod
     def fileSubstrates(cls):
         if CurveSpectrum.FILE_SUBSTRATES is None:
             path = os.path.dirname(os.path.abspath(__file__))
             ref = Graph(os.path.join(path, 'spectrumSubstrates.txt'))
             CurveSpectrum.FILE_SUBSTRATES = ref
         return CurveSpectrum.FILE_SUBSTRATES
+
     @classmethod
     def getListSubstrates(cls):
         """
         returns the substrates that have <substrate>+' R' and <substrate>+' T'
         in spectrumSubstrates.txt
         """
         if CurveSpectrum.LIST_SUBSTRATES is None:
             file = cls.fileSubstrates()
-            lbls = [c.getAttribute('label') for c in file.iterCurves()]
+            lbls = [c.attr('label') for c in file.iterCurves()]
             subsdict = {}
             for lbl in lbls:
                 key = lbl[:-2]
                 if key not in subsdict:
                     subsdict.update({key: ''})
                 if lbl.endswith(' T'):
                     subsdict[key] = subsdict[key]+'T'
@@ -167,39 +170,34 @@
                     subsdict[key] = subsdict[key]+'R'
             out = ['nope']
             for key in subsdict:
                 if 'R' in subsdict[key] and 'T' in subsdict[key]:
                     out.append(key)
             CurveSpectrum.LIST_SUBSTRATES = out
         return CurveSpectrum.LIST_SUBSTRATES
-   
 
-        
-    
     def getOffset(self):
-        return self.getAttribute('_spectrumOffset', 0)
+        return self.attr('_spectrumOffset', 0)
+
     def addOffset(self, value):
         """
         Add offset: adds a vertical offset to the data. The data are modified.
         The cumulated data correction is displayed, such that setting it to 0
         retrieves the original data (with some rounding errors)
         """
         if is_number(value):
             self.setY(self.y() + value - self.getOffset())
             self.update({'_spectrumOffset': value})
             return True
         return False
 
-            
     # more "usual" methods
     def dataModifySwapNmEv(self):
         self.setX(self.NMTOEV / self.x())
 
-
-
     def substractBG(self, idDark, interpolate, ifnew, offsets, graph=None, **kwargs):
         """
         Substract dark: substract a curve to the data.
         Parameters:')
         - idDark: index of of the Curve containing the dark spectrum.
         - interpolate:
             0: performs element-wise substraction,
@@ -207,20 +205,22 @@
             2: output on selected Curve x points, interpolate the dark Curve.
         - ifnew: 1: create a new Curve, 0: modify existing data.
         - offsets: 0: ignore offset and muloffset information.
             1: substract data after offset and muloffset operation.
         - graph: Graph object containing the dark Curve referred by idDark
         """
         # clean input from GUI: interpolate
-        if interpolate in [0,1,2, '0','1','2']:
+        if interpolate in [0, 1, 2, '0', '1', '2']:
             interpolate = int(interpolate)
-        elif isinstance(interpolate, str) and len(interpolate) > 0 and interpolate[0] in ['0','1','2']:
+        elif (isinstance(interpolate, str) and len(interpolate) > 0
+                and interpolate[0] in ['0', '1', '2']):
             interpolate = int(interpolate[0])
         else:
             interpolate = 1
+
         # clean input from GUI: ifNew
         def cleanInputBool(in_, default=False):
             if in_ in [0, 1, True, False, '0', '1', 'True', 'False']:
                 if in_ in ['0', 'False']:
                     in_ = False
                 else:
                     in_ = bool(in_)
@@ -229,191 +229,199 @@
             else:
                 in_ = default
             return in_
         # clean input from GUI: ifNew, offsets
         ifnew = cleanInputBool(ifnew, default=True)
         offsets = cleanInputBool(offsets, default=False)
         idDark = min(int(idDark), graph.length()-1)
-        j = None # index of 'curve' in graph
+        j = None  # index of 'curve' in graph
         for c in range(graph.length()):
             if graph.curve(c) == self:
                 j = c
                 break
-        out = self.__add__(graph.curve(idDark), interpolate=interpolate, offsets=offsets, **kwargs)
+        out = self.__add__(graph.curve(idDark), interpolate=interpolate,
+                           offsets=offsets, **kwargs)
         key = '_sub'
-        msg = ('{Curve ' + (str(j) if j is not None else '') +
-               ': ' + self.getAttribute('label') + '} - ' +
-               '{Curve ' + str(idDark) + ': ' + graph.curve(idDark).getAttribute('label') + '}')
+        msg = ('{Curve ' + (str(j) if j is not None else '') + ': '
+               + self.attr('label') + '} - ' + '{Curve '+str(idDark) + ': '
+               + graph.curve(idDark).attr('label')+'}')
         out.update({key: msg})
         if not ifnew:
             if j is not None:
                 graph.replaceCurve(out, j)
                 print('CurveSpectrum.substractBG: modified Curve data.')
                 return True
-            print('CurveSpectrum.substractBG: cannot identify Curve!?! Created a new one instead.')
+            print('CurveSpectrum.substractBG: cannot identify Curve!?! Created',
+                  'a new one instead.')
         print('CurveSpectrum.substractBG: created new Curve.')
         return out
-    
-    
+
     def correctInstrumentalResponse(self, instrresp, *args, **kwargs):
         """
         Correct for the instrumental response, using an instrumental response
         provided in file grapa/datatypes/spectrumInstrumentalResponses.txt
         !! Feel free to adapt the file with curves matching your system !!
         Parameters:
         - instrresp: label of the desired instr. resp. Curve in the file
         """
         file = self.fileInstrResp()
         for curve in file.iterCurves():
-            if curve.getAttribute('label') == instrresp:
+            if curve.attr('label') == instrresp:
                 out = self / curve
-                val = self.getAttribute('_spectrumCorrected')
+                val = self.attr('_spectrumCorrected')
                 out.update({'_spectrumCorrected': val + instrresp + ';',
-                            'label': self.getAttribute('label')+' instr. resp. corr.'})
+                            'label': self.attr('label')+' instr. resp. corr.'})
                 self.update({'linestyle': 'none'})
                 return out
-        return 'Curve Spectrum instrumental response not found (required', instrresp, ', available', ', '.join([c.getAttribute('label') for c in file.iterCurves()]),')'
-        
+        return 'Curve Spectrum instrumental response not found (required', instrresp, ', available', ', '.join([c.attr('label') for c in file.iterCurves()]), ')'
+
     def computeAbsorptance(self, auxcurve, graph=None, **kwargs):
         """
         Compute absorptance: computes an absorptance curve, defined as
             A% = 1 - R% - T%.
         Parameters:
         - auxcurve: index to a transmittance/reflectance curve,
         - graph: a graph containing the curve refered as auxcurve
         """
         out = self.computeAlpha(auxcurve, None, None, alpha=False, graph=graph,
                                 **kwargs)
         out.update({'_spectrumalpha': '',
                     '_spectrumabsorptance': 'args auxcurve'+str(auxcurve)})
         return out
 
-    
     def computeAlpha(self, auxcurve, thickness, substrate, alpha=True, graph=None, **kwargs):
         """
         Estimate alpha: estimates the optical absorption spectrum of a layer,
         using the formula
             alpha[cm-1] = - 1 / d[cm] * ln(T / (1-R)
         This formula is a reasonable approximation, assuming a few assumptions
-        detailed in the manual. Notably, the substrate should be transparent, 
+        detailed in the manual. Notably, the substrate should be transparent,
         and most of the reflections occurs at the air-layer interface. A
         substrate with low refractive index is to be preferred.
         Parameters:
         - auxcurve: index to a transmittance/reflectance curve,
         - thickness: thickness of the layer, in [nm],
         - substrate: a simple model can be used to account for the absorption
           in the substrate. The formula becomes:
             alpha[cm-1] = - 1 / d * ln(T / (1-R) * (1-Rsub) / Tsub).
         - graph: a graph containing the curve refered as auxcurve
         """
         if not isinstance(graph, Graph):
-            print('Curve Spectrum computeAbsorptance, keyword "graph" not provided')
+            print('Curve Spectrum computeAbsorptance, keyword "graph" not',
+                  'provided')
             return False
         if alpha:
             Rsub, Tsub = None, None
             if substrate not in ['', 'none']:
                 filesubs = self.fileSubstrates()
                 Rsub, Tsub = None, None
                 for c in filesubs.iterCurves():
-                    lbl = c.getAttribute('label')
+                    lbl = c.attr('label')
                     if lbl == substrate + ' R':
                         Rsub = c
                     if lbl == substrate + ' T':
                         Tsub = c
                 if Rsub is None or Tsub is None:
-                    print('Curve Spectrum computeAbsorptance (alpha), cannot find substrate curves (',substrate,'), substrate ignored.')
+                    print('Curve Spectrum computeAbsorptance (alpha), cannot',
+                          'find substrate curves (', substrate, '), substrate',
+                          'ignored.')
                     Rsub, Tsub = None, None
         aux = None
         if isinstance(auxcurve, float):
             auxcurve = int(auxcurve)
-            if auxcurve >= 0 and auxcurve < graph.length():
-                aux = graph.curve(auxcurve)
+            if auxcurve >= 0 and auxcurve < len(graph):
+                aux = graph[auxcurve]
         else:
-            for c in range(graph.length()):
-                if auxcurve == str(c)+' '+graph.curve(c).getAttribute('label'): 
-                    aux = graph.curve(c)
+            for c in range(len(graph)):
+                if auxcurve == str(c)+' '+graph[c].attr('label'):
+                    aux = graph[c]
                     break
         if aux is None:
-            print('Curve Spectrum computeAbsorptance, auxiliary curve not found (',auxcurve,')')
+            print('Curve Spectrum computeAbsorptance, auxiliary curve not',
+                  'found (', auxcurve, ')')
             return False
         # determination R or T
-        if (self.getAttribute('_spectrumSubclass') == 'CurveSpectrumTransmittance' or
-             aux.getAttribute('_spectrumSubclass') == 'CurveSpectrumReflectance'):
+        if (self.attr('_spectrumSubclass') == 'CurveSpectrumTransmittance'
+                or aux.attr('_spectrumSubclass') == 'CurveSpectrumReflectance'):
             R, T = aux, self
         else:
             R, T = self, aux
-        multR = 100 if R.getAttribute('_spectrumunit') == '%' else 1
-        multT = 100 if T.getAttribute('_spectrumunit') == '%' else 1
-        if alpha: # alpha
+        multR = 100 if R.attr('_spectrumunit') == '%' else 1
+        multT = 100 if T.attr('_spectrumunit') == '%' else 1
+        if alpha:  # alpha
             out = T/multT / (1 - R/multR)
             if Rsub is not None and Tsub is not None:
                 out *= (1 - Rsub) / Tsub
             out.setY(- 1 / (1e-7 * thickness) * np.log(out.y()))
             out.update({'_spectrumSubclass': ''})
-        else: # absorptance
+        else:  # absorptance
             out = 1 - R / multR - T / multT
             if multR == 100 and multT == 100:
                 out.setY(out.y() * 100)
             out.update({'_spectrumSubclass': 'CurveSpectrumAbsorptance'})
-        lbl = self.getAttribute('label').replace(' instr. resp. corr.','')
-        replacelist = ['Reflectance', 'reflectance', 'R%', 'Transmittance', 'transmittance', 'T%']
+        lbl = self.attr('label').replace(' instr. resp. corr.', '')
+        replacelist = ['Reflectance', 'reflectance', 'R%', 'Transmittance',
+                       'transmittance', 'T%']
         replacement = 'Absorptance' if not alpha else 'alpha [cm$^{-1}$]'
         flag = False
         for r in replacelist:
             if r in lbl:
                 lbl = lbl.replace(r, replacement)
                 flag = True
         if not flag:
             lbl = lbl + ' ' + replacement
         out.update({'label': lbl,
                     '_spectrumalpha': 'args auxcurve'+str(auxcurve)+', thickness'+str(thickness)+', substrate'+str(substrate)})
         return out
-    
+
     def printHelp(self):
         print('*** *** ***')
-        print('CurveSpectrum offers some capabilities to process optical spectrum data.')
+        print('CurveSpectrum offers some capabilities to process optical',
+              'spectrum data.')
         print('Curve transforms:')
-        print(' - nm <-> eV: switch [eV] or [nm] data into the other representation (eV =', self.NMTOEV,'/ nm).')
+        print(' - nm <-> eV: switch [eV] or [nm] data into the other',
+              'representation (eV =', self.NMTOEV, '/ nm).')
         print('Analysis functions')
-        print(' - Change data nm<->eV: changes data from nm to eV or inversely (eV =', self.NMTOEV,'/ nm),')
+        print(' - Change data nm<->eV: changes data from nm to eV or',
+              'inversely (eV =', self.NMTOEV, '/ nm),')
         self.printHelpFunc(CurveSpectrum.setSubclass)
-        if self.getAttribute('_spectrumGUIoffset', True):
+        if self.attr('_spectrumGUIoffset', True):
             self.printHelpFunc(CurveSpectrum.addOffset)
-        if self.getAttribute('_spectrumGUIdark', True):
+        if self.attr('_spectrumGUIdark', True):
             self.printHelpFunc(CurveSpectrum.substractBG)
         sub = self.getSubclass()
         if sub is not None and hasattr(sub, 'printHelp_'):
             sub.printHelp_(self)
         return True
 
 
-
 class CurveSpectrumReflectance(CurveSpectrum):
     def initialize(self):
         self.update({'_spectrumGUIoffset': False, '_spectrumGUIdark': False})
+
     def funcListGUISpecific(self, **kwargs):
         out = []
         file = self.fileInstrResp()
         graph = kwargs['graph'] if 'graph' in kwargs else None
         # instrumental response
-        corr = '(already) ' if self.getAttribute('_spectrumCorrected') else ''
-        lbls = [c.getAttribute('label') for c in file.iterCurves()]
+        corr = '(already done) ' if self.attr('_spectrumCorrected') else ''
+        lbls = [c.attr('label') for c in file.iterCurves()]
         out.append([self.correctInstrumentalResponse,
                     'Correct',
                     [corr+'instrumental response'],
-                    ['Reflectance (specular)'],
+                    [lbls[0]],
                     {},
-                    [{'field': 'Combobox', 'width': 22, 'values': lbls}]])
+                    [{'field': 'Combobox', 'width': 25, 'values': lbls}]])
         # compute absorptance, alpha
         if graph is not None:
             poss = []
             for c in range(graph.length()):
-                if isinstance(graph.curve(c), CurveSpectrum):
-                    if graph.curve(c).getAttribute('_spectrumSubclass') == 'CurveSpectrumTransmittance':
-                        poss.append(str(c)+' '+graph.curve(c).getAttribute('label'))
+                if isinstance(graph[c], CurveSpectrum):
+                    if graph[c].attr('_spectrumSubclass') == 'CurveSpectrumTransmittance':
+                        poss.append(str(c)+' '+graph[c].attr('label'))
             poss_ = poss[0] if len(poss) > 0 else ''
             out.append([self.computeAbsorptance, 'Compute absorptance',
                         ['select transmittance'],
                         [poss_],
                         {'graph': graph},
                         [{'field': 'Combobox', 'width': 20, 'values': poss}]])
             listsubs = self.getListSubstrates()
@@ -421,31 +429,34 @@
                         ['transm.', 'thickness [nm]', 'substrate'],
                         [poss_, 50, 'none'],
                         {'graph': graph},
                         [{'field': 'Combobox', 'width': 12, 'values': poss},
                          {'width': 7},
                          {'field': 'Combobox', 'width': 6, 'values': listsubs}]])
         return out
+
     def printHelp_(self):
-        print('CurveSpectrumReflectance offers 3 additional processing functions.')
+        print('CurveSpectrumReflectance offers 3 additional processing',
+              'functions.')
         self.printHelpFunc(CurveSpectrum.correctInstrumentalResponse)
         self.printHelpFunc(CurveSpectrum.computeAbsorptance)
         self.printHelpFunc(CurveSpectrum.computeAlpha)
-        
+
 
 class CurveSpectrumTransmittance(CurveSpectrum):
     def initialize(self):
         self.update({'_spectrumGUIoffset': False, '_spectrumGUIdark': False})
+
     def funcListGUISpecific(self, **kwargs):
         out = []
         file = self.fileInstrResp()
         graph = kwargs['graph'] if 'graph' in kwargs else None
         # instrumental response
-        corr = '(already) ' if self.getAttribute('_spectrumCorrected') else ''
-        lbls = [c.getAttribute('label') for c in file.iterCurves()]
+        corr = '(already) ' if self.attr('_spectrumCorrected') else ''
+        lbls = [c.attr('label') for c in file.iterCurves()]
         value = 'Transmittance (specular)'
         if value not in lbls:
             if 'Transmittance (diffuse)' in lbls:
                 value = 'Transmittance (diffuse)'
             if corr == '':
                 corr = '(are you sure?) '
         out.append([self.correctInstrumentalResponse,
@@ -453,18 +464,18 @@
                     [corr+'instrumental response'],
                     [value],
                     {},
                     [{'field': 'Combobox', 'width': 22, 'values': lbls}]])
         # compute absorptance, alpha
         if graph is not None:
             poss = []
-            for c in range(graph.length()):
-                if isinstance(graph.curve(c), CurveSpectrum):
-                    if graph.curve(c).getAttribute('_spectrumSubclass') == 'CurveSpectrumReflectance':
-                        poss.append(str(c)+' '+graph.curve(c).getAttribute('label'))
+            for c in range(len(graph)):
+                if isinstance(graph[c], CurveSpectrum):
+                    if graph[c].attr('_spectrumSubclass') == 'CurveSpectrumReflectance':
+                        poss.append(str(c)+' '+graph[c].attr('label'))
             poss_ = poss[0] if len(poss) > 0 else ''
             out.append([self.computeAbsorptance, 'Compute absorptance',
                         ['select reflectance'],
                         [poss_ if len(poss) > 0 else ''],
                         {'graph': graph},
                         [{'field': 'Combobox', 'width': 20, 'values': poss}]])
             listsubs = self.getListSubstrates()
@@ -472,21 +483,19 @@
                         ['refl.', 'thickness [nm]', 'substrate'],
                         [poss_, 50, 'none'],
                         {'graph': graph},
                         [{'field': 'Combobox', 'width': 12, 'values': poss},
                          {'width': 7},
                          {'field': 'Combobox', 'width': 6, 'values': listsubs}]])
         return out
+
     def printHelp_(self):
-        print('CurveSpectrumTransmittance offers 3 additional processing functions.')
+        print('CurveSpectrumTransmittance offers 3 additional processing',
+              'functions.')
         self.printHelpFunc(CurveSpectrum.correctInstrumentalResponse)
         self.printHelpFunc(CurveSpectrum.computeAbsorptance)
         self.printHelpFunc(CurveSpectrum.computeAlpha)
 
-        
-        
+
 class CurveSpectrumAbsorptance(CurveSpectrum):
     def initialize(self):
         self.update({'_spectrumGUIoffset': False, '_spectrumGUIdark': False})
-        
-
-
```

### Comparing `grapa-0.5.4.8/grapa/datatypes/curveTRPL.py` & `grapa-0.6.1.0/grapa/datatypes/curveTRPL.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,89 +1,21 @@
 # -*- coding: utf-8 -*-
 """
-Created on Mon Mar 20 18:08:32 2017
-
 @author: Romain Carron
-Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+Copyright (c) 2023, Empa, Laboratory for Thin Films and Photovoltaics, Romain
+Carron
 """
 
 import numpy as np
-from os import path as ospath
 from copy import deepcopy
 
-from grapa.graph import Graph
-from grapa.graphIO import GraphIO
 from grapa.curve import Curve
 from grapa.mathModule import is_number, roundSignificant, roundSignificantRange
 
 
-
-class GraphTRPL(Graph):
-
-    FILEIO_GRAPHTYPE = 'TRPL decay'
-
-    AXISLABELS = [['Time', 't', 'time'], ['Intensity', '', 'counts']]
-
-    @classmethod
-    def isFileReadable(cls, fileName, fileExt, line1='', line2='', line3='',
-                       **kwargs):
-        if fileExt == '.dat' and line1 == 'Time[ns]	crv[0] [Cnts.]':
-            return True
-        elif (fileExt == '.dat'
-                and line1 == 'Parameters:'
-                and ((      line2.strip().startswith('Sample')
-                        and line3.strip().startswith('Solvent'))
-                     or (   line2.strip().split(' : ')[0] in ['Exc_Wavelength']
-                        and line3.strip().split(' : ')[0] in ['Exc_Bandpass'])
-                     )
-              ):
-            return True
-        return False
-
-    def readDataFromFile(self, attributes, **kwargs):
-        """ Read a TRPL decay. """
-        len0 = self.length()
-        kw = {}
-        if 'line1' in kwargs and kwargs['line1'] == 'Parameters:':
-            kw.update({'delimiterHeaders': ':'})
-        GraphIO.readDataFromFileGeneric(self, attributes, **kw)
-        self.castCurve(CurveTRPL.CURVE, len0, silentSuccess=True)
-        # label management
-        filenam_, fileext = ospath.splitext(self.filename)  # , fileExt
-        #self.curve(len0).update({'label': filenam_.split('/')[-1].split('\\')[-1]})
-        lbl = filenam_.split('/')[-1].split('\\')[-1].replace('_', ' ').split(' ')
-        smp = str(self.curve(len0).attr('sample'))
-        try:
-            if float(int(float(smp))) == float(smp):
-                smp = str(int(float(smp)))
-        except Exception:
-            pass
-        smp = smp.replace('_', ' ').split(' ')
-        new = lbl
-        if len(smp) > 0:
-            new = [l for l in lbl if l not in smp] + smp
-        # print('label', self.attr('label'), [l for l in lbl if l not in smp], smp)
-        self.curve(len0).update({'label': ' '.join(new)})
-        xlabel = self.getAttribute('xlabel').replace('[', ' [').replace('  ', ' ').capitalize() # ] ]
-        if xlabel in ['', ' ']:
-            xlabel = GraphTRPL.AXISLABELS[0]
-        self.update({'typeplot': 'semilogy', 'alter': ['', 'idle'],
-                     'xlabel': self.formatAxisLabel(xlabel),
-                     'ylabel': self.formatAxisLabel(GraphTRPL.AXISLABELS[1])})
-        self.update({'subplots_adjust': [0.2, 0.15]})
-        # cleaning
-        if 'line1' in kwargs and kwargs['line1'] == 'Parameters:':
-            attr = self.curve(len0).getAttributes()
-            keys = list(attr.keys())
-            for key in keys:
-                val = attr[key]
-                if isinstance(val, str) and val.startswith('\t'):
-                    self.curve(len0).update({key: ''})
-
-
 class CurveTRPL(Curve):
     """ Class handling TRPL decays. """
 
     CURVE = 'Curve TRPL'
     SMOOTH_WINDOW = ['flat', 'hanning', 'hamming', 'bartlett', 'blackman']
 
     def __init__(self, data, attributes, silent=False):
@@ -134,41 +66,45 @@
         revert = False if unit is None else True
         if not revert:
             out.append([self.normalize, 'Normalize intensity',
                         ['pulse freq Hz', 'acquis time s', 'bin ps'],
                         [self.attr('_repetfreq_Hz', 1), self.attr('_acquistime_s', 1), self.attr('_binwidth_s', 1)*1e12],
                         {},
                         [{'width': 10}, {'width': 7}, {'width': 6}]])
-        else: # get back cts data
+        else:  # get back cts data
             out.append([self.normalizerevert, 'Restore intensity cts',
                         ['Current intensity unit: '+str(unit)+'. factor'],
                         [self.getFactor()], {}, [{'field': 'Label'}]])
         # fit
         if self.attr('_fitFunc', None) is None or self.attr('_popt', None) is None:
             ROI = roundSignificantRange([20, max(self.x())], 2)
             out.append([self.CurveTRPL_fitExp,
                         'Fit exp',
                         ['Nb exp', 'ROI', 'Fixed values', 'show residuals'],
                         [2, ROI, [0, '', ''], False],
                         {},
                         [{'field': 'Combobox', 'values': ['1', '2', '3']},
                          {}, {}, {'field': 'Combobox', 'values': ['False', 'True']}]])
         else:
-            values = roundSignificant(self.getAttribute('_popt'), 5)
+            values = roundSignificant(self.attr('_popt'), 5)
             params = ['BG']
+            fieldred = {'width': 5} if len(values)-1 > 4 else {}
+            fields = [fieldred]
             while len(values) > len(params)+1:
                 n = '{:1.0f}'.format((len(params)+1)/2)
-                params += ['A'+n, 'tau'+n]
-            out.append([self.updateFitParam, 'Update fit', params, values])
+                params += ['A'+n, "\u03C4"+n]
+                fields += [fieldred, fieldred]
+            out.append([self.updateFitParam, 'Update fit', params, values, {},
+                        fields])
         out.append([self.CurveTRPL_smoothBin, 'Smooth & bin',
                     ['width', 'convolution', 'binning'],
                     ['9', 'hanning', '1'],
                     {},
                     [{}, {'field': 'Combobox', 'values': self.SMOOTH_WINDOW},
-                        {'field': 'Combobox', 'values': ['1','2','4','8','16']}]])
+                        {'field': 'Combobox', 'values': ['1', '2', '4', '8', '16']}]])
         # integration
         alter = str(kwargs['graph'].attr('alter')) if 'graph' in kwargs else "['', '']"
         ROI = roundSignificantRange([min(self.x()), max(self.x())], 2)
         out.append([self.integrate, 'Integrate',
                     ['ROI', 'data transform'], [ROI, alter], {},
                     [{}, {'field': 'Combobox', 'values': ['raw', alter]}]])
         # help
@@ -223,40 +159,46 @@
         Data: (raw+offset) * (1 / (syncfreq * (measstop-meastime) * binwidth))
         """
         try:
             factor = float(1 / (repetfreq_Hz * duration_s * (1e-12*binwidth_ps)))
         except Exception:
             return False
         if factor == 0 or np.isinf(factor):
-            print('CurveTRPL.normlize: non-sensical normalization factor (0 or inf).')
+            print('CurveTRPL.normlize: non-sensical normalization factor (0',
+                  'or inf).')
             return False
-        if self.attr('_unit', None) is not None:  # should not happen if using only the GUI
-            print('CurveTRPL.normalize: data may have been already normalized (Curve labelled as "'+self.attr('_unit')+'", "'+self.attr('_unitfactor')+'").')
+        # should not happen if using only the GUI
+        if self.attr('_unit', None) is not None:
+            print('CurveTRPL.normalize: data may have been already normalized',
+                  '(Curve labelled as "'+self.attr('_unit')+'","',
+                  self.attr('_unitfactor')+'").')
         self.setIntensity(factornew=factor)
         self.update({'_unit': 'cts/Hz/s/s'})
         # overwrite acquisition parameters, if significant deviation from
-        try:
-            if np.abs(self.attr('_repetfreq_Hz',1) - repetfreq_Hz) / repetfreq_Hz > 1e-6:
-                self.update({'_repetfreq_Hz': repetfreq_Hz})
-            if np.abs(self.attr('_acquistime_s') - duration_s) / duration_s > 1e-6:
-                self.update({'_acquistime_s': duration_s})
-            if np.abs(self.attr('_binwidth_s') - (1e-12*binwidth_ps)) / (1e-12*binwidth_ps) > 1e-6:
-                self.update({'_binwidth_s': (1e-12*binwidth_ps)})
-        except Exception:
-            pass
+        # Actually, not. We keep default parameters. User need to change them
+        # manually if he wishes
+        # try:
+        #     if np.abs(self.attr('_repetfreq_Hz', 1) - repetfreq_Hz) / repetfreq_Hz > 1e-6:
+        #         self.update({'_repetfreq_Hz': repetfreq_Hz})
+        #     if np.abs(self.attr('_acquistime_s') - duration_s) / duration_s > 1e-6:
+        #         self.update({'_acquistime_s': duration_s})
+        #     if np.abs(self.attr('_binwidth_s') - (1e-12*binwidth_ps)) / (1e-12*binwidth_ps) > 1e-6:
+        #         self.update({'_binwidth_s': (1e-12*binwidth_ps)})
+        # except Exception:
+        #     pass
         return True
 
     def normalizerevert(self, *args):
         self.setIntensity(factornew=1)
         self.update({'_unit': ''})
         return True
 
     # temporal offset
     def getXOffset(self):
-        return self.getAttribute('_TRPLxOffset', 0)
+        return self.attr('_TRPLxOffset', 0)
 
     def addXOffset(self, value):
         if is_number(value):
             self.setX(self.x() + value - self.getXOffset())
             self.update({'_TRPLxOffset': value})
             return True
         else:
@@ -271,16 +213,15 @@
         target = (v25 + v95) / 2
         iMax = np.argmax(y)
         for i in range(iMax, -1, -1):
             if y[i] < target:
                 return self.x(i)
         return self.x(0)
 
-    def CurveTRPL_fitExp(self, nbExp=2, ROI=None, fixed=None,
-                         showResiduals=False, silent=False):
+    def CurveTRPL_fitExp(self, nbExp=2, ROI=None, fixed=None, showResiduals=False, silent=False):
         """
         Fit exp: fits the data as a constant plus a sum of exponentials.
         Returns a Curve as the best fit to the TRPL decay.
         Formula: y(t) = BG + A1 exp(-t/tau1) + A2 exp(-t/tau2) + ...
         thus y(0) = BG + A1 + A2 + ...
         Parameters:
         - nbExp: The number of exponentials in the fit
@@ -301,17 +242,18 @@
             if showResiduals in ['True', '1']:
                 showResiduals = True
             else:
                 showResiduals = False
         popt = self.fit_fitExp(ROI=ROI, fixed=fixed)
         attr = {'color': 'k', '_ROI': ROI,
                 '_popt': popt, '_fitFunc': 'func_fitExp',
-                'filename': 'fit to '+self.getAttribute('filename').split('/')[-1].split('\\')[-1],
-                'label': 'fit to '+self.getAttribute('label')}
-        attr.update(self.getAttributes(['offset', 'muloffset']))
+                'filename': 'fit to '+self.attr('filename').split('/')[-1].split('\\')[-1],
+                'label': 'fit to '+self.attr('label')}
+        attr.update(self.getAttributes(['offset', 'muloffset', '_repetfreq_Hz',
+                                        '_acquistime_s', '_binwidth_s']))
         mask = self.ROItoMask([0, max(self.x())])
         fitted = CurveTRPL([self.x(mask), self.func_fitExp(self.x(mask), *popt)], attr)
         if showResiduals:
             mask = self.ROItoMask(ROI)
             attrresid = {'color': [0.5, 0.5, 0.5], 'label': 'Residuals'}
             resid = CurveTRPL([self.x(mask), self.func_fitExp(self.x(mask), *popt)-self.y(mask)], attrresid)
             fitted = [fitted, resid]
@@ -321,59 +263,107 @@
                 taus += [str(popt[i])]
             taus = ', '.join(taus)
             print('Fitted with', int(nbExp), 'exponentials: tau', taus, '.')
             print('Params\t', '\t'.join([str(p) for p in popt]))
         return fitted
 
     def fit_fitExp(self, ROI=None, fixed=None):
+        # fixed: has the desired length, to be done by calling function
+        # fixed: e.g. [0, '', 10]
         # check for ROI
         mask = self.ROItoMask(ROI)
         datax = self.x()[mask]
         datay = self.y()[mask]
         # check for fixed params, construct p0
-        p0default = [0, 1e4, 30, 1000, 100]
-        p0default = [(p if p % 2 or p == 0 else np.log(p)) for p in p0default]
-        while len(p0default) < len(fixed):
-            p0default += [p0default[-2] / 2, p0default[-1]*2]
+        p0default = [0, np.max(datay) * 0.5, np.abs(np.max(datax)) * 0.02]
+        while len(p0default) < len(fixed):  # additional: tau*2, A/2
+            p0default += [p0default[-2] / 4, p0default[-1] * 4]
+        # fixed parameters: input value in initial guess, before recondition
+        isFixed = []  # list of booleans
+        for i in range(len(fixed)):
+            isFixed.append(is_number(fixed[i]))
+            if isFixed[i]:
+                p0default[i] = fixed[i]
+        print('p0default', p0default)
+
+        # p0default = [(p if p % 2 or p == 0 else np.log(p)) for p in p0default]
+
+        def recondition(params):
+            # all fitfunc parameters, including fixed variables
+            p_ = params[0:3]
+            for i in range(3, len(params), 2):
+                p_.append(params[i])  # A value
+                p_.append(params[i-1] / params[i+1])  # tau value
+            return p_
+
+        def decondition(params, ifFixed, fixed):
+            # all fitfunc parameters, including fixed variables
+            p_ = params[0:3]
+            for i in range(3, len(params), 2):
+                p_.append(params[i])  # A value
+                p_.append(params[i-1] / params[i+1])  # tau value
+                if isFixed[i+1]:
+                    p_[i+1] = fixed[i+1]  # actual fixed value needed to decondition next variable values
+            return p_
+
+        def mergedvarfixed(params, isFixed, complementary):
+            p = []
+            j, k = 0, 0
+            for i in range(len(isFixed)):
+                if isFixed[i]:
+                    p.append(complementary[k])
+                    k += 1
+                else:
+                    p.append(params[j])
+                    j += 1
+            return p
+
+        # recondition problem: tau are written differently
+        p0default = recondition(p0default)
+        # handle fixed and actual variables
         p0 = []
+        isFixed = []  # list of booleans
         complementary = []
-        isFixed = []
         for i in range(len(fixed)):
             isFixed.append(is_number(fixed[i]))
             if isFixed[i]:
+                # fixed[i] may not == p0default[i] due to recondition
                 complementary.append(fixed[i])
             else:
                 p0.append(p0default[i])
 
         # custom fit function handling fixed and free fit parameters
         def func(datax, *p0):
-            j = 0
-            params = []
-            for i in range(len(isFixed)):
-                if isFixed[i]:
-                    params.append(complementary[i])
-                else:
-                    params.append(p0[j])
-                    j += 1
-            params = [(p if p % 2 or p == 0 else np.exp(p)) for p in params]
+            params = mergedvarfixed(p0, isFixed, complementary)
+            print('func a', params)
+            # during decondition, need to fix again fixed values, e.g. tau1 changed by fit algorithm but tau2 was fixed by used
+            params = decondition(params, isFixed, fixed)
+            print('     b', params)
             return self.func_fitExp(datax, *params)
 
         # actual fitting
+        print('TRPL p0', p0)
         from scipy.optimize import curve_fit
         popt, pcov = curve_fit(func, datax, datay, p0=p0)
+
         # construct output parameters including fixed ones
-        j = 0
-        params = []
-        for i in range(len(isFixed)):
-            if isFixed[i]:
-                params.append(complementary[i])
-            else:
-                params.append(popt[j])
-                j += 1
-        # sort exp by ascending tau: TODO
+        params = mergedvarfixed(popt, isFixed, complementary)
+        # back to standard parametrization
+        params = decondition(params, isFixed, fixed)
+
+        # sort output by ascending tau values
+        if np.sum(isFixed[1:]) == 0:  # only if no fixed parameter
+            pairs = [[params[i], params[i+1]] for i in range(1, len(params), 2)]
+            taus = [pair[1] for pair in pairs]
+            pairs = [x for _, x in sorted(zip(taus, pairs))]
+            p_ = [params[0]]
+            for pair in pairs:
+                p_ += pair
+            params = p_
+
         return params
 
     def func_fitExp(self, t, BG, A1, tau1, *args):
         """
         computes the sum of a cst plus an arbitrary number of exponentials
         """
         out = BG + A1 * np.exp(- t / tau1)
@@ -399,36 +389,40 @@
         binning. Parameters:
         - width (window_len): number of points in the smooth window,
         - convolution (window): the type of window. Possible values: 'hanning',
           'hamming', 'bartlett', 'blackman', or 'flat' (moving average).
         - binning: how many points are merged.
         """
         if not is_number(window_len) or window_len < 1:
-            print('Warning CurveTRPL smoothBin: cannot interpret window_len value (got',window_len,', request int larger than 0.) Set 1.')
+            print('Warning CurveTRPL smoothBin: cannot interpret window_len',
+                  'value (got', window_len, ', request int larger than 0.)',
+                  'Set 1.')
             window_len = 1
         window_len = int(window_len)
         if not is_number(binning) or binning < 1:
-            print('Warning CurveTRPL smoothBin: cannot interpret binning value (got',binning,', request int larger than 0.) Set 1.')
+            print('Warning CurveTRPL smoothBin: cannot interpret binning',
+                  'value (got', binning, ', request int larger than 0.)',
+                  'Set 1.')
             binning = 1
         binning = int(binning)
         from mathModule import smooth
         smt = smooth(self.y(), window_len, window)
         x = self.x()
         le = len(x)
         x_ = np.zeros(int(np.ceil(len(x) / binning)))
         y_ = np.zeros(int(np.ceil(len(x) / binning)))
         for i in range(len(x_)):
-            x_[i] = np.average(  x[i*binning : min(le, (i+1)*binning)])
-            y_[i] = np.average(smt[i*binning : min(le, (i+1)*binning)])
+            x_[i] = np.average(  x[i*binning:min(le, (i+1)*binning)])
+            y_[i] = np.average(smt[i*binning:min(le, (i+1)*binning)])
         attr = deepcopy(self.getAttributes())
-        comment = ('Smoothed curve (' +str(self.getAttribute('label')) +
-                   ') smt ' +str(window_len) + ' ' + str(window) + ' bin ' +
-                   str(binning))
+        comment = ('Smoothed curve (' + str(self.attr('label')) + ') smt '
+                   + str(window_len) + ' ' + str(window) + ' bin '
+                   + str(binning))
         attr.update({'comment': comment})
-        attr.update({'label': str(self.getAttribute('label'))+' '+'smooth'})
+        attr.update({'label': str(self.attr('label'))+' '+'smooth'})
         return CurveTRPL([x_, y_], attr)
 
     def integrate(self, ROI=None, alter=None, curve=None):
         """
         Integrate: returns the integral of the curve, within ROI. Parameters:
         - ROI: example [xmin, xmax]
         - data transform (alter): 'raw', or any Graph 'alter' value including
@@ -446,28 +440,26 @@
             datay = curve.y_offsets(alter=alter[1])[mask]
         else:
             datax = curve.x()[mask]
             datay = curve.y()[mask]
         integral = np.trapz(datay, datax)
         return integral
 
-
-
     def printHelp(self):
         print('*** *** ***')
-        print('CurveTRPL offers some support to fit time-resolved photoluminence (TRPL) spectra.')
+        print('CurveTRPL offers some support to fit time-resolved',
+              'photoluminence (TRPL) spectra.')
         print('The associated functions are:')
         print(' - Add offset: can adjust the background level. Data are\n',
               '   modified. The previous adjustment is shown, and the original\n',
               '   data can be re-computed by setting it to 0.')
         print(' - Time offset: can add a temporal offset, in order to set \n',
               '   peak onset at t=0. This is especially useful as the fit\n',
               '   method considers the decay starts at t=0.\n',
               '   If value is empty, the software tries to autodetect the\n',
               '   leading edge, as the last point below a threshold defined as\n',
               '   the average of the 25% and 95% percentiles.')
         self.printHelpFunc(self.normalize)
         self.printHelpFunc(self.CurveTRPL_fitExp)
         self.printHelpFunc(self.CurveTRPL_smoothBin)
         self.printHelpFunc(self.integrate)
-
         return True
```

### Comparing `grapa-0.5.4.8/grapa/datatypes/EQE_20.4_cell.txt` & `grapa-0.6.1.0/grapa/datatypes/EQE_20.4_cell.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/datatypes/EQE_absorption_CdS.txt` & `grapa-0.6.1.0/grapa/datatypes/EQE_absorption_CdS.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/datatypes/graphEQE_CSU.py` & `grapa-0.6.1.0/grapa/datatypes/graphEQE_CSU.py`

 * *Files 5% similar despite different names*

```diff
@@ -8,60 +8,59 @@
 
 import numpy as np
 from grapa.graph import Graph
 from grapa.datatypes.curveEQE import CurveEQE
 
 
 class GraphEQE_CSU(Graph):
-    
+
     FILEIO_GRAPHTYPE = 'EQE curve'
-    
-    AXISLABELS = [['Wavelength', '\lambda', 'nm'], ['Cell EQE', '', '%']]
-    
+
+    AXISLABELS = [['Wavelength', r'\lambda', 'nm'], ['Cell EQE', '', '%']]
+
     @classmethod
     def isFileReadable(cls, fileName, fileExt, line1='', line3='', **kwargs):
-        if (fileExt == '.txt' and line1 == 'CSU' and
-            line3.startswith('Bias Light')):
+        if (fileExt == '.txt' and line1 == 'CSU'
+                and line3.startswith('Bias Light')):
             return True
         return False
 
     def readDataFromFile(self, attributes, **kwargs):
         attrs = {}
         # interpret headers
         f = open(self.filename, 'r')
         attrs['acquisition location'] = f.readline().strip()
         attrs['sample'] = f.readline().strip()
         attrs['label'] = attrs['sample']
         attrs['acquisition bias light'] = f.readline().replace('Bias Light ','').strip()
         attrs['acquisition cell area'] = float(f.readline().strip())
         attrs['acquisition Eg'] = float(f.readline().strip().replace('Eg = ',''))
-        f.readline() # do nothing with it
+        f.readline()  # do nothing with it
         nlines = int(f.readline().strip())
         attrs['acquisition Jsc'] = float(f.readline().strip())
         attrs['collabels'] = '[' + ', '.join(f.readline().strip().split('\t')) + ']'
         f.close()
-        
+
         # read data
         data = np.array([np.nan, np.nan])
         kw = {'delimiter': '\t', 'invalid_raise': False,
               'skip_header': 9, 'usecols': [0, 1]}
         try:
             data = np.transpose(np.genfromtxt(self.filename, **kw))
         except Exception as e:
             if not self.silent:
                 print('WARNING GraphEQE_CSU cannot read file', self.filename)
                 print(type(e), e)
-        
+
         # create data
         self.append(CurveEQE(data, attributes))
-        self.curve(-1).update(attrs) # file content may override default attributes
+        self.curve(-1).update(attrs)  # file content may override default attributes
         if nlines != len(self.curve(-1).x()):
             print('WARNING GraphEQE_CSU: number of lines differ from expected')
-        
+
         # cosmetics
         if len(data.shape) > 1:
             self.curve(-1).update({'mulOffset': 100})
         # some default settings
         self.update({'ylim': [0, 100], 'xlim': [300, np.nan],
-                 'xlabel': self.formatAxisLabel(GraphEQE_CSU.AXISLABELS[0]),
-                 'ylabel': self.formatAxisLabel(GraphEQE_CSU.AXISLABELS[1])})
-
+                     'xlabel': self.formatAxisLabel(GraphEQE_CSU.AXISLABELS[0]),
+                     'ylabel': self.formatAxisLabel(GraphEQE_CSU.AXISLABELS[1])})
```

### Comparing `grapa-0.5.4.8/grapa/datatypes/graphJV.py` & `grapa-0.6.1.0/grapa/datatypes/graphJV.py`

 * *Files 10% similar despite different names*

```diff
@@ -10,96 +10,121 @@
 
 from grapa.graph import Graph
 from grapa.graphIO import GraphIO
 from grapa.datatypes.curveJV import CurveJV
 
 
 class GraphJV(Graph):
-    
+
     FILEIO_GRAPHTYPE = 'J-V curve'
     FILEIO_GRAPHTYPE_TIV = 'TIV curve'
     FILEIO_GRAPHTYPE_IV_HLS = 'I-V curve (H-L soaking)'
 
     @classmethod
     def isFileReadable(cls, fileName, fileExt, line1='', line2='', line3='', **kwargs):
         if fileExt == '.txt' and line1[-11:] == '_ParamDescr':
-            return True # JV
-        if (fileExt == '.txt' and line1.strip().startswith('Sample name:') and
-            line2.strip().startswith('Cell name:') and 
-            line3.strip().startswith('Cell area [cm')):
-            return True # TIV
-        if fileExt == '.csv' and len(line1) > 40 and line1.strip()[:21] == '"Time";"Temperature [' and line1.strip()[-38:] == '";"Illumination [mV]";"Humidity [%RH]"':
-            return True # J-V from Heat-Light soaking setup
+            return True  # JV
+        if (fileExt == '.txt' and line1.strip().startswith('Sample name:')
+                and line2.strip().startswith('Cell name:')
+                and line3.strip().startswith('Cell area [cm')):
+            return True  # TIV
+        if (fileExt == '.csv' and len(line1) > 40
+                and line1.strip()[:21] == '"Time";"Temperature ['
+                and line1.strip()[-38:] == '";"Illumination [mV]";"Humidity [%RH]"'):
+            return True  # J-V from Heat-Light soaking setup
         return False
-    
+
     def readDataFromFile(self, attributes, **kwargs):
         line1 = kwargs['line1'] if 'line1' in kwargs else ''
         fileName = kwargs['fileName'] if 'fileName' in kwargs else ''
-        if len(line1) > 40 and line1.strip()[:21] == '"Time";"Temperature [' and line1.strip()[-38:] == '";"Illumination [mV]";"Humidity [%RH]"':
+        if (len(line1) > 40 and line1.strip()[:21] == '"Time";"Temperature ['
+                and line1.strip()[-38:] == '";"Illumination [mV]";"Humidity [%RH]"'):
             GraphJV.readDataFromFileIV_HLS(self, attributes)
-        elif line1.strip().startswith('Sample name:') and (not fileName.startswith('I-V_')):
+        elif (line1.strip().startswith('Sample name:')
+                and (not fileName.startswith('I-V_'))):
             GraphJV.readDataFromFileTIV(self, attributes)
         else:
             GraphJV.readDataFromFileJV(self, attributes)
-            
+        # set 'sample' attribute
+        if self[-1].attr('sample') == '':
+            self[-1].update({'sample': self[-1].attr('label')})
+
     def readDataFromFileJV(self, attributes):
-        fileName, fileext = os.path.splitext(self.filename) #, fileExt
-        # extract data analysis from acquisition software - requires a priori knowledge of file structure
-        # especially want to know cell area before creation of the CurveJV object
-        JVsoft = np.genfromtxt(self.filename, skip_header=1, delimiter='\t', usecols=[3], invalid_raise=False)
-        key = ['Acquis soft Voc', 'Acquis soft Jsc', 'Acquis soft FF', 'Acquis soft Eff', 'Acquis soft Cell area', 'Acquis soft Vmpp', 'Acquis soft Jmpp', 'Acquis soft Pmpp', 'Acquis soft Rp', 'Acquis soft Rs', 'Acquis soft datatime', 'Acquis soft Temperature', 'Acquis soft Illumination factor']
+        fileName, fileext = os.path.splitext(self.filename)  # , fileExt
+        # extract data analysis from acquisition software - requires a priori
+        # knowledge of file structure
+        # especially want to know cell area before creation of the CurveJV
+        # object
+        JVsoft = np.genfromtxt(self.filename, skip_header=1, delimiter='\t',
+                               usecols=[3], invalid_raise=False, dtype=str)
+        key = ['Acquis soft Voc', 'Acquis soft Jsc', 'Acquis soft FF',
+               'Acquis soft Eff', 'Acquis soft Cell area', 'Acquis soft Vmpp',
+               'Acquis soft Jmpp', 'Acquis soft Pmpp', 'Acquis soft Rp',
+               'Acquis soft Rs', 'Acquis soft datetime',
+               'Acquis soft Temperature', 'Acquis soft Illumination factor']
         for i in range(len(key)):
-            attributes.update({key[i]: JVsoft[i]})
+            val = JVsoft[i] # .decode('utf-8')
+            try:
+                val = float(val)
+            except ValueError:
+                pass
+            attributes.update({key[i]: val})
         if 'label' in attributes:
             attributes['label'] = attributes['label'].replace('I-V ','').replace('_', ' ')
         # create Curve object
-        self.data.append(CurveJV(np.transpose(np.genfromtxt(self.filename, skip_header=1, delimiter='\t', usecols=[0, 1], invalid_raise=False)), attributes, units=['V', 'mAcm-2'], ifCalc=True, silent=self.silent))
-        self.headers.update({'sample': fileName.split('/')[-1], 'collabels': ['Voltage [V]', 'Current density [mA cm-2]']})
-        self.graphInfo.update({'xlabel': self.formatAxisLabel(['Bias voltage', 'V', 'V']),
-                               'ylabel': self.formatAxisLabel(['Current density', 'J', 'mA cm$^{-2}$'])})
+        data = np.genfromtxt(self.filename, skip_header=1, delimiter='\t',
+                             usecols=[0, 1], invalid_raise=False)
+        self.append(CurveJV(np.transpose(data), attributes,
+                            units=['V', 'mAcm-2'], ifCalc=True,
+                            silent=self.silent))
+        self.update({'collabels': ['Voltage [V]', 'Current density [mA cm-2]']})
+        self.update({'xlabel': self.formatAxisLabel(['Bias voltage', 'V', 'V']),
+                     'ylabel': self.formatAxisLabel(['Current density', 'J', 'mA cm$^{-2}$'])})
         # some cosmetic information
-        self.graphInfo.update({'axhline': [0], 'axvline': [0]})
+        self.update({'axhline': [0], 'axvline': [0]})
 
     def readDataFromFileTIV(self, attributes):
         GraphIO.readDataFromFileGeneric(self, attributes)
-        # check if we can actually read some TIV data, otherwise this might be a processed I-V_ database (summary of cells properties)
+        # check if we can actually read some TIV data, otherwise this might be
+        # a processed I-V_ database (summary of cells properties)
         if self.length() == 0:
             GraphIO.readDataFromFileTxt(self, attributes)
             return
         # back to TIV data reading
         self.update({'collabels': '',
                      'xlabel': self.formatAxisLabel(['Bias voltage', 'V', 'V']),
-                     'ylabel': self.formatAxisLabel(['Current density','J', 'mA cm$^{-2}$'])})
+                     'ylabel': self.formatAxisLabel(['Current density', 'J', 'mA cm$^{-2}$'])})
         # delete columns of temperature in newer versions
-        if self.length() == 3:
-            if self.curve(-1).getAttribute('voltage (v)') == 'T sample (K)':
+        if len(self) == 3:
+            if self[-1].attr('voltage (v)') == 'T sample (K)':
                 self.deleteCurve(-1)
-            if self.curve(-1).getAttribute('voltage (v)') == 'T stage (K)':
+            if self[-1].attr('voltage (v)') == 'T stage (K)':
                 self.deleteCurve(-1)
-        self.curve(0).update({'voltage (v)':''}) # artifact from file reading, want to delete this
+        self[0].update({'voltage (v)': ''})  # artifact from file reading
         filebasename, fileExt = os.path.splitext(os.path.basename(self.filename))
-        self.curve(0).update({'label': filebasename.replace('_', ' ')})
+        self[0].update({'label': filebasename.replace('_', ' ')})
         # rename attributes to match these of JV setup
         key = ['sample name', 'cell name', 'voc (v)', 'jsc (ma/cm2)', 'ff (%)', 'eff (%)', 'cell area [cm2]', 'vmpp (v)', 'jmpp (ma/cm2)', 'pmpp (mw/cm2)', 'rp (ohmcm2)', 'rs (ohmcm2)', 'temperature [k]', 'Acquis soft Illumination factor'] #, 'Acquis soft datatime'
         new = ['sample', 'cell', 'Acquis soft Voc', 'Acquis soft Jsc', 'Acquis soft FF', 'Acquis soft Eff', 'Acquis soft Cell area', 'Acquis soft Vmpp', 'Acquis soft Jmpp', 'Acquis soft Pmpp', 'Acquis soft Rp', 'Acquis soft Rs', 'Acquis soft Temperature', 'Acquis soft Illumination factor'] #,  'Acquis soft datatime'
-        c = self.curve(0)
+        c = self[0]
         for i in range(len(key)):
-            c.update({new[i]: c.getAttribute(key[i])})
+            c.update({new[i]: c.attr(key[i])})
             c.update({key[i]: ''})
-        c.update({'temperature': c.getAttribute('Acquis soft Temperature')})  # we believe this information is trustable
-        c.update({'measId': str(c.getAttribute('temperature'))})
+        # we believe this information is trustable
+        c.update({'temperature': c.attr('Acquis soft Temperature')})
+        c.update({'measId': str(c.attr('temperature'))})
         # recreate curve as a CurveJV
-        self.data[0] = CurveJV(c.data, attributes=c.getAttributes(), silent=True)
+        self.data[0] = CurveJV(c.data, attributes=c.getAttributes(),
+                               silent=True)
         self.update({'meastype': GraphJV.FILEIO_GRAPHTYPE_TIV})
 
     def readDataFromFileIV_HLS(self, attributes):
-        le = self.length()
+        le = len(self)
         GraphIO.readDataFromFileGeneric(self, attributes, delimiter=';')
-        self.curve(le).update({'area': 1.0})
-        if max(abs(self.curve(le).x())) > 10: # want units in [V], not [mV]
-            self.curve(le).setX(self.curve(le).x()*0.001)
-        self.update({'xlabel': self.getAttribute('xlabel').replace('[mv]','[mV]')})
-        self.update({'xlabel': self.formatAxisLabel(self.getAttribute('xlabel')),
-                     'ylabel': self.formatAxisLabel(self.getAttribute('ylabel'))})
+        self[le].update({'area': 1.0})
+        if max(abs(self[le].x())) > 10:  # want units in [V], not [mV]
+            self[le].setX(self[le].x()*0.001)
+        self.update({'xlabel': self.attr('xlabel').replace('[mv]', '[mV]')})
+        self.update({'xlabel': self.formatAxisLabel(self.attr('xlabel')),
+                     'ylabel': self.formatAxisLabel(self.attr('ylabel'))})
         self.castCurve('Curve JV', le, silentSuccess=True)
         self.update({'meastype': GraphJV.FILEIO_GRAPHTYPE_IV_HLS})
-
```

### Comparing `grapa-0.5.4.8/grapa/datatypes/graphJVDarkIllum.py` & `grapa-0.6.1.0/grapa/datatypes/graphJVDarkIllum.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,72 +1,73 @@
 # -*- coding: utf-8 -*-
 """
 Created on Mon Jul 25 19:47:25 2016
 
 @author: Romain Carron
-Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain
+Carron
 """
 
 import numpy as np
 import warnings
 
 
 from grapa.graph import Graph
 from grapa.graphIO import GraphIO
 from grapa.curve import Curve
 from grapa.mathModule import is_number, roundgraphlim
 
 from grapa.datatypes.curveJV import CurveJV
 
 
-
-
 class GraphJVDarkIllum(Graph):
 
     def __init__(self, fileDark, fileIllum, area=np.nan, temperature=273.15+25, complement={}, silent=True, ifPlot=False, **newGraphKwargs):
-        #print ('GraphJVDarkIllum area', area)
-# TODO: give Graph files in constructor. Currently only handle filename (str)
+        # print ('GraphJVDarkIllum area', area)
+        # TODO: give Graph files in constructor. Currently only handle filename (str)
         self.idxDark = -1
-        self.idxIllum= -1
+        self.idxIllum = -1
         # intervert fileIllum and fileDark if able to detect inversion
         swap = -1
         if isinstance(fileIllum, str) and fileIllum.find('dark') > -1:
             swap = 1
-        elif isinstance(fileIllum, Graph) and fileIllum.getAttribute('filename').find('dark') > -1:
+        elif isinstance(fileIllum, Graph) and fileIllum.attr('filename').find('dark') > -1:
             swap = 1
         if isinstance(fileDark, str) and fileDark.find('dark') > -1:
             swap = 0
-        elif isinstance(fileDark, Graph) and fileDark.getAttribute('filename').find('dark') > -1:
+        elif isinstance(fileDark, Graph) and fileDark.attr('filename').find('dark') > -1:
             swap = 0
         if swap == 1:
             swap = fileDark
             fileDark = fileIllum
             fileIllum = swap
 
         # prepare additional attributes
         complement.update({'temperature': temperature})
         if is_number(area):
             complementArea = {'area': area}
         if 'area' in complement:
-            print('WARNING GraphJVDarkIllum: area defined in argument complement, beware that area correction might not function properly!')
+            print('WARNING GraphJVDarkIllum: area defined in argument',
+                  'complement, beware that area correction might not function',
+                  'properly!')
 
         # start opening files, supposedly the dark
         Graph.__init__(self, fileDark, complement=complement, silent=silent, **newGraphKwargs)
         # fit first file
         if self.length() > 0:
             self.curve(-1).update(complementArea)
             self.idxDark = 0
             c = self.curve(-1)
             c.simpleLabel(forceCalc=True)
             # compute fit, create new curve for it
             c.update({'color': 'b'})
             with warnings.catch_warnings():
                 warnings.simplefilter("ignore")
                 newCurve = c.CurveJVFromFit(silent=silent)
-            if not isinstance(newCurve, Curve): # if fit failed
+            if not isinstance(newCurve, Curve):  # if fit failed
                 newCurve = Curve([[0], [np.nan]], {'diodeFit': [np.nan]*5, 'mpp': [np.nan]*3}, silent=True)
             self.append(newCurve)
         else:
             pass
 
         # open illuminated file, supposedly the illum
         graph = Graph(fileIllum, complement=complement, silent=silent, **newGraphKwargs)
@@ -78,31 +79,31 @@
             c = self.curve(-1)
             c.simpleLabel(forceCalc=True)
             # compute fit, create new curve for it
             c.update({'color': 'r'})
             with warnings.catch_warnings():
                 warnings.simplefilter("ignore")
                 newCurve = c.CurveJVFromFit(silent=silent)
-            if not isinstance(newCurve, Curve): # if fit failed
+            if not isinstance(newCurve, Curve):  # if fit failed
                 newCurve = CurveJV([[0], [np.nan]], {'diodeFit': [np.nan]*5, 'mpp': [np.nan]*3}, silent=True)
             self.append(newCurve)
         else:
             pass
 
         # apparent photocurrent: difference between dark and illum
-        if self.length() > 2: # for this the opening of the 2 file must have been successful
+        if self.length() > 2:  # for this the opening of the 2 file must have been successful
             Jsc = self.curve(self.idxIllum).getAttribute('Jsc')
             idx = [self.idxIllum, self.idxDark]
             c = [self.curve(idx[0]), self.curve(idx[1])]
             V = np.sort(np.append(c[0].x(), c[1].x()))
             with warnings.catch_warnings():
                 warnings.simplefilter("ignore")
                 J = c[0].interpJ(V) - c[1].interpJ(V)
             self.append(CurveJV([V, J], {'color': 'g', 'label': 'Apparent photocurrent', 'Jsc': Jsc, 'area': self.curve(self.idxIllum).area()}, ifCalc=False, silent=True))
-            self.curve(-1).update({'linestyle': 'none'}) # by default this curve is not shown
+            self[-1].update({'linestyle': 'none'})  # by default this curve is not shown
         else:
             pass
 
 
 
 
 
@@ -156,70 +157,74 @@
         if self.length() > 2:
             self.plotDiff(filesave, ifSave=ifSave, ifExport=ex, figAx=figAx, ylim=ylim)
             if pltClose:
                 plt.close()
         self.plotLogAbs(filesave, ifSave=ifSave, ifExport=ex, figAx=figAx, ylim=ylimLog)
         if pltClose:
             plt.close()
-        #self.update({'ylim': ylimInit})
+        # self.update({'ylim': ylimInit})
 
 
     def plotStd(self, filesave='', ylim=None, figAx=None, ifSave=True, ifExport=True):
         # normal plot
-        temp = {}
+        restore = {}
         if ylim is not None:
-            temp = self.deleteAttr(['ylim', 'alter'])
+            restore.update(self.delete('ylim'))
             self.update({'ylim': ylim})
-        self.curve(1).update({'linestyle': 'None'})
-        if self.length() > 2:
-            self.curve(3).update({'linestyle': 'None'})
-        Graph.plot(self, filesave=GraphIO.filesave_default(self,filesave) +'lin', figAx=figAx, ifSave=ifSave, ifExport=ifExport)
-        self.curve(1).update({'linestyle': ''})
-        if self.length() > 2:
-            self.curve(3).update({'linestyle': ''})
+        self[1].update({'linestyle': 'None'})
+        if len(self) > 2:
+            self[3].update({'linestyle': 'None'})
+        Graph.plot(self, filesave=GraphIO.filesave_default(self, filesave) +'lin',
+                   figAx=figAx, ifSave=ifSave, ifExport=ifExport)
+        self[1].update({'linestyle': ''})
+        if len(self) > 2:
+            self[3].update({'linestyle': ''})
         # restore initial attributes
-        self.update(temp)
-
+        self.update(restore)
 
     def plotLogAbs(self, filesave='', ylim=None, figAx=None, ifSave=True, ifExport=True):
-        # unset xlim, ylim indications (could also uset the delete() function like for axhline and axvline)
+        # unset xlim, ylim indications
         # change ylabel of the graph
-        temp = self.deleteAttr(['ylim', 'xlim', 'ylabel', 'axhline', 'axvline', 'alter'])
+        keys = ['ylim', 'xlim', 'ylabel', 'axhline', 'axvline', 'alter']
+        restore = {}
+        for key in keys:
+            restore.update(self.delete(key))
         self.update({'ylabel': 'Log current density', 'alter': 'log10abs'})
         if ylim is not None:
             self.update({'ylim': ylim})
-        Graph.plot(self, filesave=GraphIO.filesave_default(self, filesave)+'log', figAx=figAx, ifSave=ifSave, ifExport=ifExport)
-        self.update(temp)
-
+        Graph.plot(self, filesave=GraphIO.filesave_default(self, filesave)+'log',
+                   figAx=figAx, ifSave=ifSave, ifExport=ifExport)
+        self.update(restore)
 
     def plotDiff(self, filesave='', ylim=None, figAx=None, ifSave=True, ifExport=True):
-        temp = self.deleteAttr(['axhline', 'alter'])
-        if self.length() > 2:
-            Jsc = self.curve(self.idxIllum).getAttribute('Jsc')
+        keys = ['axhline', 'alter']
+        restore = {}
+        for key in keys:
+            restore.update(self.delete(key))
+        if len(self) > 2:
+            Jsc = self[self.idxIllum].attr('Jsc')
             if self.idxDark >= 0 and self.idxIllum >= 0:
                 self.update({'axhline': [Jsc, -Jsc]})
             else:
                 self.update({'axhline': [-Jsc]})
-        linestIdx = [i for i in [1, 3, 4] if i < self.length()]
-        linestyle = [self.curve(i).getAttribute('linestyle') for i in linestIdx]
-        if self.length() > 2:
-            self.curve(4).update({'linestyle': ''})
+        linestIdx = [i for i in [1, 3, 4] if i < len(self)]
+        linestyle = [self[i].attr('linestyle') for i in linestIdx]
+        if len(self) > 2:
+            self[4].update({'linestyle': ''})
         if ylim is not None:
-            saveAttr = self.deleteAttr(['ylim'])
+            restore.update(self.delete('ylim'))
             self.update({'ylim': ylim})
 
         Graph.plot(self, filesave=GraphIO.filesave_default(self, filesave) +'diff', figAx=figAx, ifSave=ifSave, ifExport=ifExport)
 
         # restore curve properties
-        if ylim is not None:
-            self.update(saveAttr)
         for i in range(len(linestIdx)):
-            self.curve(linestIdx[i]).update({'linestyle': linestyle[i]})
-        self.update(temp)
+            self[linestIdx[i]].update({'linestyle': linestyle[i]})
+        self.update(restore)
 
     def returnDataCurves(self):
         out = []
-        if self.length() > 0: # first curve
+        if self.length() > 0:  # first curve
             out.append(self.curve(0))
-        if self.length() > 2: # scond curve, ignoring the fit which is in position 1
+        if self.length() > 2:  # scond curve, ignoring the fit which is in position 1
             out.append(self.curve(2))
         return out
```

### Comparing `grapa-0.5.4.8/grapa/datatypes/graphMBElog.py` & `grapa-0.6.1.0/grapa/datatypes/graphMBElog.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,41 +1,41 @@
 # -*- coding: utf-8 -*-
 """
 Created on Sat Mar  4 10:44:14 2017
 
 @author: Romain Carron
-Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain
+Carron
 """
 
 import os
 import numpy as np
 
 
 from grapa.graph import Graph
 from grapa.curve import Curve
 
+
 class GraphMBElog(Graph):
-    
+
     FILEIO_GRAPHTYPE = 'Small MBE log file'
-    
+
     AXISLABELS = [['Time', 't', 'min'], ['Substrate heating', '', 'a.u.']]
-    
+
     @classmethod
     def isFileReadable(cls, fileName, fileExt, line1='', **kwargs):
         if fileExt == '.txt' and line1 == 'Time	Value':
             return True
         return False
 
     def readDataFromFile(self, attributes, **kwargs):
         """ Reads MBE log file. Curve is standard xyCurve. """
         fileName, fileext = os.path.splitext(self.filename)
         sample = (fileName.split('/')[-1]).split('_')[0]
-        data = np.genfromtxt(self.filename, skip_header=1, delimiter='\t', 
+        data = np.genfromtxt(self.filename, skip_header=1, delimiter='\t',
                              usecols=[0, 1], invalid_raise=False)
         self.data.append(Curve(np.transpose(data), attributes))
         self.headers.update({'collabels': ['Time [min]',
                                            'Substrate heating [a.u.]']})
         self.update({'xlabel': self.formatAxisLabel(GraphMBElog.AXISLABELS[0]),
                      'ylabel': self.formatAxisLabel(GraphMBElog.AXISLABELS[1])})
-        self.curve(-1).update({'label': sample})
-
-
+        self.curve(-1).update({'label': sample, 'sample': sample})
```

### Comparing `grapa-0.5.4.8/grapa/datatypes/graphMCAfit.py` & `grapa-0.6.1.0/grapa/datatypes/graphMCAfit.py`

 * *Files 15% similar despite different names*

```diff
@@ -11,21 +11,20 @@
 from re import findall as refindall
 
 
 from grapa.graph import Graph
 from grapa.curve import Curve
 
 
-
 class GraphMCAfit(Graph):
-    
+
     FILEIO_GRAPHTYPE = 'XRF fit areas'
-    
+
     AXISLABELS = [['Data', '', None], ['Value', '', None]]
-    
+
     @classmethod
     def isFileReadable(cls, fileName, fileExt, line1='', **kwargs):
         if fileExt == '.html' and line1[0:24] == '<HTML><HEAD><TITLE>PyMCA':
             return True
         return False
 
     def readDataFromFile(self, attributes, **kwargs):
@@ -33,36 +32,48 @@
         sample = filenam_.split('/')[-1].split('.mca')[0]
         f = open(self.filename, 'r')
         content = f.read()
         f.close()
         tmp = np.array([])
         content = content.replace(' align="left"', '').replace(' align="right"', '').replace(' bgcolor=#E6F0F9', '').replace(' bgcolor=#E6F0F9', '').replace(' bgcolor=#FFFFFF', '').replace(' bgcolor=#FFFACD', '').replace('  ', ' ').replace('<td >', '<td>').replace('<tr', '\n<tr').replace('<TR', '\n<TR').replace('<table', '\n<table').replace('\n\n', '\n')
         split = refindall('<tr><td>Cu</td><td>K</td><td>([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)</td><td>', content)
-        tmp = np.append(tmp, float(split[0][0]))
+        try:
+            tmp = np.append(tmp, float(split[0][0]))
+        except IndexError:
+            tmp = np.append(tmp, np.nan)
         split = refindall('<tr><td>In</td><td>K</td><td>([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)</td><td>', content)
-        tmp = np.append(tmp, float(split[0][0]))
+        try:
+            tmp = np.append(tmp, float(split[0][0]))
+        except IndexError:
+            tmp = np.append(tmp, np.nan)
         split = refindall('<tr><td>Ga</td><td>Ka</td><td>([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)</td><td>', content)
-        tmp = np.append(tmp, float(split[0][0]))
+        try:
+            tmp = np.append(tmp, float(split[0][0]))
+        except IndexError:
+            tmp = np.append(tmp, np.nan)
         split = refindall('<tr><td>Se</td><td>K</td><td>([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)</td><td>', content)
-        tmp = np.append(tmp, float(split[0][0]))
-        tmp = np.append(tmp, 180) # time - assumed here, no value reading
-    ## XRF calibration: MIGHT WANT TO UPDATE THAT!!!
+        try:
+            tmp = np.append(tmp, float(split[0][0]))
+        except IndexError:
+            tmp = np.append(tmp, np.nan)
+        tmp = np.append(tmp, 180)  # time - assumed here, no value reading
+        ##  XRF calibration: MIGHT WANT TO UPDATE THAT!!!
         val_Cu = tmp[0] / 43434 * 22.56
         val_In = tmp[1] / 10992 * 13.66
         val_Ga = tmp[2] / 29578 * 11.41
         val_Se = tmp[3] /195460 * 52.40
-    ## END OF XRF calibration: MIGHT WANT TO UPDATE THAT!!!
+        ##  END OF XRF calibration: MIGHT WANT TO UPDATE THAT!!!
         val_sum = val_Cu + val_In + val_Ga + val_Se
         val_Cu /= val_sum
         val_In /= val_sum
         val_Ga /= val_sum
         val_Se /= val_sum
-        tmp = np.append(tmp, val_Ga / (val_Ga + val_In)) # x calculation
-        tmp = np.append(tmp, val_Cu / (val_Ga + val_In)) # y calculation
-        tmp = np.append(tmp, tmp[0] * 450 / 10000000) # D calculation
+        tmp = np.append(tmp, val_Ga / (val_Ga + val_In))  # x calculation
+        tmp = np.append(tmp, val_Cu / (val_Ga + val_In))  # y calculation
+        tmp = np.append(tmp, tmp[0] * 450 / 10000000)  # D calculation
         self.data.append(Curve(np.append(np.arange(tmp.size), tmp).reshape((2, tmp.size)), {}))
         c = self.curve(-1)
         c.update(attributes)
         c.update({'XRF fit Cu [fitarea/s]': float(tmp[0]) / float(tmp[4])})
         c.update({'XRF fit In [fitarea/s]': float(tmp[1]) / float(tmp[4])})
         c.update({'XRF fit Ga [fitarea/s]': float(tmp[2]) / float(tmp[4])})
         c.update({'XRF fit Se [fitarea/s]': float(tmp[3]) / float(tmp[4])})
```

### Comparing `grapa-0.5.4.8/grapa/datatypes/graphPGZ.py` & `grapa-0.6.1.0/grapa/datatypes/graphPGZ.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,68 +1,70 @@
 # -*- coding: utf-8 -*-
 """
 Created on Fri Jan 26 13:30:22 2018
 
 @author: Romain Carron
-Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain
+Carron
 """
 
 
 import numpy as np
 from grapa.graph import Graph
 from grapa.curve import Curve
 
 
 class GraphPGZ(Graph):
-    
+
     FILEIO_GRAPHTYPE = 'PGZ path file'
-    
+
     AXISLABELS = [['Position x', '', 'mm'], ['Position y', '', 'mm']]
-    
+
     @classmethod
     def isFileReadable(cls, fileName, fileExt, line1='', **kwargs):
         if (fileExt == '.pgz'):
             return True
         return False
 
     def readDataFromFile(self, attributes, **kwargs):
         kw = {'delimiter': '\t', 'invalid_raise': False,
               'skip_header': 0, 'usecols': [0, 1, 2]}
         data = np.genfromtxt(self.filename, **kw)
-        
+
         # transform data format
         x = [[], []]
         y = [[], []]
         previous = -1
         for row in data:
             onOff = 1 if row[2] == 1 else 0
             if row[2] != previous and len(x[1-onOff]) > 0:
                 x[onOff].append(x[1-onOff][-1])
                 y[onOff].append(y[1-onOff][-1])
                 x[1-onOff].append(np.nan)
                 y[1-onOff].append(np.nan)
-                #print('   added from other')
+                #  print('   added from other')
             x[onOff].append(row[0])
             y[onOff].append(row[1])
-            #print('   added to', onOff)
+            # print('   added to', onOff)
             previous = row[2] * 1
-            
+
         self.append(Curve([x[0], y[0]], attributes))
         self.append(Curve([x[1], y[1]], attributes))
-        lbl = self.curve(-2).getAttribute('label')
-        self.curve(-1).update({'label': lbl+' off', 'labelhide': 1, 'alpha':0.20})
-        
-        colors = {'P1': [0.3,0.3,0.3], 'P2': [1,0,0], 'P3': [0,0,1], 'PT':[0,0.6,0.6]}
+        lbl = self[-2].attr('label')
+        self[-1].update({'label': lbl+' off', 'labelhide': 1, 'alpha': 0.20})
+
+        colors = {'P1': [0.3, 0.3, 0.3], 'P2': [1, 0, 0],
+                  'P3': [0, 0, 1], 'PT': [0, 0.6, 0.6]}
         color = ''
         for key in colors:
             if key in lbl:
                 color = colors[key]
                 break
         if color != '':
-            self.curve(-2).update({'color': color})
-            self.curve(-1).update({'color': color})
-            
+            self[-2].update({'color': color})
+            self[-1].update({'color': color})
+
         # some default settings
-        self.update({'figsize':[5,5], 'subplots_adjust': [0.15, 0.15, 0.95, 0.95]})
-        self.update({'xlabel': self.formatAxisLabel(GraphPGZ.AXISLABELS[0]),
+        self.update({'figsize': [5, 5],
+                     'subplots_adjust': [0.15, 0.15, 0.95, 0.95],
+                     'xlabel': self.formatAxisLabel(GraphPGZ.AXISLABELS[0]),
                      'ylabel': self.formatAxisLabel(GraphPGZ.AXISLABELS[1])})
-
```

### Comparing `grapa-0.5.4.8/grapa/datatypes/graphSpectrum.py` & `grapa-0.6.1.0/grapa/datatypes/graphSpectrum.py`

 * *Files 12% similar despite different names*

```diff
@@ -4,36 +4,35 @@
 
 @author: Romain
 """
 
 from os import path as ospath
 import numpy as np
 
-
 from grapa.graph import Graph
 from grapa.graphIO import GraphIO
 from grapa.datatypes.curveSpectrum import CurveSpectrum
 
 
-
 class GraphSpectrum(Graph):
     """
     This is a generic class to open spectrum-like files. The purpose is to
     limit the endless multiplication of files in folder datatypes.
     Each child class of GraphSpectrum are constructed the same way as similar
     classes.
-    Each types of 
+    Each types of
     """
-    
+
     FILEIO_GRAPHTYPE = 'Optical spectrum'
 
-    AXISLABELS = [['Wavelength', '\lambda', 'nm'], ['Intensity', '', 'counts']]
-    
+    AXISLABELS = [['Wavelength', '\lambda', 'nm'],
+                  ['Intensity', '', 'counts']]
+
     WHICHSUBCLASS = []
-    
+
     @classmethod
     def isFileReadable(cls, fileName, fileExt, **kwargs):
         # ask every child class to know if it can open the file
         # if yes, remembers which one can
         GraphSpectrum.WHICHSUBCLASS = []
         for child in GraphSpectrum.__subclasses__():
             if child.isFileReadable(fileName, fileExt, **kwargs):
@@ -41,131 +40,131 @@
         if len(GraphSpectrum.WHICHSUBCLASS) > 0:
             return True
         return False
 
     def readDataFromFile(self, attributes, **kwargs):
         # ask the child class which said they can, to open the file
         # By design readDataFromFile shall be called immediately after
-        # isFileReadable, so the design is ~safe. Maybe we should explicitely 
+        # isFileReadable, so the design is ~safe. Maybe we should explicitely
         # perform the readable test again?
         for child in GraphSpectrum.WHICHSUBCLASS:
             res = child.readDataFromFile(self, attributes, **kwargs)
             if res is None or res != False:
                 return True
         return False
 
-        
-            
-            
+
 class GraphSpectrumSpectraSuite(GraphSpectrum):
     """ Reads a HR2000 file (optical fiber spectrophotometer). """
     @classmethod
     def isFileReadable(cls, fileName, fileExt, line1='', line2='', line3='', **kwargs):
         if fileExt == '.txt' and line1 == 'SpectraSuite Datei':
             return True
+
     def readDataFromFile(self, attributes, **kwargs):
-        filenam_, fileext = ospath.splitext(self.filename) # , fileExt
+        filenam_, fileext = ospath.splitext(self.filename)  # , fileExt
         # TODO:  improve header parsing
         self.append(CurveSpectrum(np.transpose(np.genfromtxt(self.filename, skip_header=17, delimiter='\t', invalid_raise=False)), attributes))
         # BG = 1140 # seems not generally valid
         BG = 0
-        self.curve(-1).setY(self.curve(-1).y() - BG)
-        self.curve(-1).update({'label': filenam_.split('/')[-1]})
+        self[-1].setY(self[-1].y() - BG)
+        self[-1].update({'label': filenam_.split('/')[-1]})
         self.headers.update({'collabels': ['Wavelength [nm]', 'Intensity [counts]']})
         self.update({'xlabel': self.formatAxisLabel(GraphSpectrum.AXISLABELS[0]),
                      'ylabel': self.formatAxisLabel(GraphSpectrum.AXISLABELS[1])})
 
-        
 
 class GraphSpectrumUVVIS(GraphSpectrum):
     """ Reads a ascii file from Shimadzu UVVIS 3600 """
     AXISLABELS = [['Wavelength', '', 'nm'], GraphSpectrum.AXISLABELS[1]]
+
     @classmethod
     def isFileReadable(cls, fileName, fileExt, line1='', line2='', line3='', **kwargs):
         if (fileExt == '.txt'
-            and line1.startswith('"') and line1.endswith('"')
-            and line2.startswith('"Wavelength nm."	"') and line2.endswith('%"')):
+                and line1.startswith('"') and line1.endswith('"')
+                and line2.startswith('"Wavelength nm."	"')
+                and line2.endswith('%"')):
             return True
+
     def readDataFromFile(self, attributes, **kwargs):
         GraphIO.readDataFromFileGeneric(self, attributes)
-        sub = self.curve(-1).getAttribute('"Wavelength nm."')
-        lbl = self.curve(-1).getAttribute('label')
+        sub = self[-1].attr('"Wavelength nm."')
+        lbl = self[-1].attr('label')
         ylabel = GraphSpectrumUVVIS.AXISLABELS[1]
         if sub == 'R%':
             sub = 'CurveSpectrumReflectance'
             ylabel = ['Reflectance', '', '%']
             if lbl.endswith(' R R%'):
                 lbl = lbl[:-3]+'%'
         elif sub == 'T%':
             sub = 'CurveSpectrumTransmittance'
             ylabel = ['Transmittance', '', '%']
             if lbl.endswith(' T T%'):
                 lbl = lbl[:-3]+'%'
         else:
             sub = ''
-        self.curve(-1).update({'_spectrumSubclass': sub, '_spectrumunit': '%'})
-        self.castCurve('Curve Spectrum', self.length()-1, silentSuccess=True)
-        self.curve(-1).update({'label': lbl, '"Wavelength nm."': ''})
+        self[-1].update({'_spectrumSubclass': sub, '_spectrumunit': '%'})
+        self.castCurve('Curve Spectrum', len(self)-1, silentSuccess=True)
+        self[-1].update({'label': lbl, '"Wavelength nm."': ''})
         self.update({'xlabel': self.formatAxisLabel(GraphSpectrumUVVIS.AXISLABELS[0]),
                      'ylabel': self.formatAxisLabel(ylabel)})
-        
-        
-    
 
-        
+
 class GraphSpectrumTRPLsetup(GraphSpectrum):
     """ TRPL setup PL spectrum """
     @classmethod
     def isFileReadable(cls, fileName, fileExt, line1='', line2='', line3='', **kwargs):
         if fileExt == '.dat' and line1[:29] == 'Excitation Wavelength[nm]	crv':
             return True
         return False
+
     def readDataFromFile(self, attributes, **kwargs):
         len0 = self.length()
         GraphIO.readDataFromFileGeneric(self, attributes)
         self.castCurve('Curve Spectrum', len0, silentSuccess=True)
-        self.curve(len0).update({'label': self.curve(len0).getAttribute('label').replace(' crv[0] [Cnts.]','')})
+        self[len0].update({'label': self[len0].attr('label').replace(' crv[0] [Cnts.]', '')})
         self.update({'xlabel': self.formatAxisLabel(GraphSpectrum.AXISLABELS[0]),
                      'ylabel': self.formatAxisLabel(GraphSpectrum.AXISLABELS[1])})
         self.update({'subplots_adjust': [0.2, 0.15]})
 
-        
 
 class GraphSpectrumPerkinElmerASC(GraphSpectrum):
     """
     Opens a kind of Perkin Elmer file.
     This parser is not exhaustive and does not necessary comply with the
     file format specifications. Much more information is contained in the file
     """
-    
+
     AXISLABELS = [GraphSpectrum.AXISLABELS[0], ['Intensity', '', '%']]
-    
+
     @classmethod
     def isFileReadable(cls, fileName, fileExt, line1='', line2='', line3='', **kwargs):
         if fileExt == '.asc' and line3.endswith('.asc'):
             return True
         return False
+
     def readDataFromFile(self, attributes, **kwargs):
         # reads header and count headers lines
         nlines = 0
         headers = []
         with open(self.filename) as fp:
             for line in fp:
                 line = line.strip()
                 nlines += 1
                 # parse a few possibly useful headers lines
                 if len(line) > 0 and ' ' in line:
-                    if line[0] not in ['0','1','2','3','4','5','6','7','8','9']:
+                    if line[0] not in ['0', '1', '2', '3', '4', '5', '6', '7',
+                                       '8', '9']:
                         headers.append(line)
                 if line == '%R':
                     attributes.update({'_spectrumSubclass': 'CurveSpectrumReflectance'})
                 if line == '%T':
                     attributes.update({'_spectrumSubclass': 'CurveSpectrumTransmittance'})
                 if line == '#DATA':
                     break
-        data = np.transpose(np.genfromtxt(self.filename, skip_header=nlines, 
+        data = np.transpose(np.genfromtxt(self.filename, skip_header=nlines,
                                           delimiter='\t', invalid_raise=False))
         self.append(CurveSpectrum(data, attributes))
         for h in range(len(headers)):
-            self.curve(-1).update({'headers'+str(h): headers[h]})
+            self[-1].update({'headers'+str(h): headers[h]})
         self.update({'xlabel': self.formatAxisLabel(GraphSpectrumPerkinElmerASC.AXISLABELS[0]),
                      'ylabel': self.formatAxisLabel(GraphSpectrumPerkinElmerASC.AXISLABELS[1])})
```

### Comparing `grapa-0.5.4.8/grapa/datatypes/graphSquidAdmiral.py` & `grapa-0.6.1.0/grapa/datatypes/graphSquidAdmiral.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,120 +1,121 @@
-# -*- coding: utf-8 -*-
-"""
-Created on Tue Nov 13 14:25:49 2019
-
-@author: Romain Carron
-Copyright (c) 2019, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
-"""
-
-import numpy as np
-import os
-
-from grapa.graph import Graph
-from grapa.curve import Curve
-
-class GraphSquidAdmiral(Graph):
-    """
-    reads CSV exports of the Squid system
-    """
-
-    FILEIO_GRAPHTYPE = 'Admiral Squid data CSV export'
-    
-    AXISLABELS = [['Time', '', 's'], ['Current', '', 'mA']]
-
-    @classmethod
-    def isFileReadable(cls, fileName, fileExt, line1='', **kwargs):
-        if fileExt == '.csv' and line1.startswith('"Step number","Step name","Elapsed'):
-            if 'Constant Current ' in fileName:
-                return True
-            elif 'Cyclic Voltammetry Start ' in fileName:
-                return True
-            elif 'Potentiostatic EIS ' in fileName:
-                return True
-            elif 'Open Circuit Potential ' in fileName:
-                return True
-            elif 'Galvanostatic EIS ' in fileName:
-                return True
-            elif 'Charge_Discharge ' in fileName:
-                return True
-        return False
-        
-    
-        
-    def readDataFromFile(self, attributes, **kwargs):
-        # no headers to parse
-        basename = os.path.basename(self.filename)
-        usecols, labels, data = None, None, None
-        
-        # retieve instructions for openning file
-        if 'Cyclic Voltammetry Start ' in basename:
-            usecols = (3,5)
-        elif 'Potentiostatic EIS ' in basename:
-            usecols = (8,9)
-        elif 'Galvanostatic EIS ' in basename:
-            usecols = (8,9)
-        elif 'Open Circuit Potential ' in basename:
-            usecols = (2,3)
-        elif 'Constant Current ' in basename:
-            try:
-                data = np.genfromtxt(self.filename, skip_header=1,
-                                     delimiter=',', invalid_raise=False)
-            except Exception as e:
-                print('GraphSquidAdmiral Constant Current: actually, cannot read file!?')
-                print(e)
-                return False
-            x, tm = [], data[0,2]
-            y = data[:,4]
-            for line in data: # some quite dirty and innefficient data parsing
-                x.append((x[-1] if len(x)>0 else 0) + (line[2]-tm) * line[5])
-                tm = line[2]
-            if len(x) > 0:
-                self.append(Curve([np.abs(np.array(x))/3600,y], attributes))
-            labels = [['Charge', '', 'mAh'], ['Working Electrode', '', 'V']]
-            data, usecols = 1, 1 # bypass default data opening, ensure algo knows everything ok
-        elif 'Charge_Discharge ' in basename:
-            try:
-                data = np.genfromtxt(self.filename, skip_header=1,
-                                     delimiter=',', invalid_raise=False)
-            except Exception as e:
-                print('GraphSquidAdmiral Charge_Discharge: actually, cannot read file!?')
-                print(e)
-                return False
-            def createCurve(x, y, sign):
-                self.append(Curve([np.abs(np.array(x))/3600,y], attributes))
-                if sign < 0:
-                    self.curve(-1).update({'label': self.curve(-1).getAttribute('label').replace('Charge ', '')})
-                else:
-                    self.curve(-1).update({'label': self.curve(-1).getAttribute('label').replace('Discharge ', '')})
-            x, y, tm, previous = [], [], data[0,2], np.sign(data[0,5])
-            for line in data: # some quite dirty and innefficient data parsing
-                if np.sign(line[5]) != previous: # if change of sign of current -> from charge to discharge or opposite
-                    createCurve(x, y, previous)
-                    x, y = [], []
-                    previous = np.sign(line[5])
-                x.append((x[-1] if len(x)>0 else 0) + (line[2]-tm) * line[5])
-                y.append(line[4])
-                tm = line[2]
-            if len(x) > 0:
-                createCurve(x, y, previous)
-            labels = [['Charge', '', 'mAh'], ['Working Electrode', '', 'V']]
-            data, usecols = 1, 1 # bypass default data opening, ensure algo knows everything ok
-        # open file
-        if usecols is None:
-            print('GraphSquidAdmiral: actually, cannot read file!?')
-            return False
-        # default data file reading
-        if data is None:
-            try:
-                data = np.genfromtxt(self.filename, skip_header=1, delimiter=',',
-                                     usecols=usecols, invalid_raise=False)
-            except Exception as e:
-                    print('WARNING GraphSquidAdmiral cannot read file', self.filename)
-                    print(type(e), e)
-                    return False
-            self.append(Curve(np.transpose(data), attributes))
-        if labels is None:
-            labels = [kwargs['line1'].split(',')[c][1:-2].replace('""',"''") for c in usecols]
-            labels = [[l.split(' (')[0], '', l.split(' (')[-1]] for l in labels]
-        self.update({'xlabel': self.formatAxisLabel(labels[0]),
-                     'ylabel': self.formatAxisLabel(labels[1])})
-                    
+# -*- coding: utf-8 -*-
+"""
+Created on Tue Nov 13 14:25:49 2019
+
+@author: Romain Carron
+Copyright (c) 2019, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+"""
+
+import numpy as np
+import os
+
+from grapa.graph import Graph
+from grapa.curve import Curve
+
+
+class GraphSquidAdmiral(Graph):
+    """
+    reads CSV exports of the Squid system
+    """
+
+    FILEIO_GRAPHTYPE = 'Admiral Squid data CSV export'
+
+    AXISLABELS = [['Time', '', 's'], ['Current', '', 'mA']]
+
+    @classmethod
+    def isFileReadable(cls, fileName, fileExt, line1='', **kwargs):
+        if fileExt == '.csv' and line1.startswith('"Step number","Step name","Elapsed'):
+            if 'Constant Current ' in fileName:
+                return True
+            elif 'Cyclic Voltammetry Start ' in fileName:
+                return True
+            elif 'Potentiostatic EIS ' in fileName:
+                return True
+            elif 'Open Circuit Potential ' in fileName:
+                return True
+            elif 'Galvanostatic EIS ' in fileName:
+                return True
+            elif 'Charge_Discharge ' in fileName:
+                return True
+        return False
+
+    def readDataFromFile(self, attributes, **kwargs):
+        # no headers to parse
+        basename = os.path.basename(self.filename)
+        usecols, labels, data = None, None, None
+
+        # retieve instructions for openning file
+        if 'Cyclic Voltammetry Start ' in basename:
+            usecols = (3, 5)
+        elif 'Potentiostatic EIS ' in basename:
+            usecols = (8, 9)
+        elif 'Galvanostatic EIS ' in basename:
+            usecols = (8, 9)
+        elif 'Open Circuit Potential ' in basename:
+            usecols = (2, 3)
+        elif 'Constant Current ' in basename:
+            try:
+                data = np.genfromtxt(self.filename, skip_header=1,
+                                     delimiter=',', invalid_raise=False)
+            except Exception as e:
+                print('GraphSquidAdmiral Constant Current: actually, cannot',
+                      'read file!?')
+                print(e)
+                return False
+            x, tm = [], data[0, 2]
+            y = data[:, 4]
+            for line in data:  # some quite dirty and innefficient data parsing
+                x.append((x[-1] if len(x) > 0 else 0) + (line[2]-tm) * line[5])
+                tm = line[2]
+            if len(x) > 0:
+                self.append(Curve([np.abs(np.array(x))/3600, y], attributes))
+            labels = [['Charge', '', 'mAh'], ['Working Electrode', '', 'V']]
+            data, usecols = 1, 1  # bypass default data opening, ensure algo knows everything ok
+        elif 'Charge_Discharge ' in basename:
+            try:
+                data = np.genfromtxt(self.filename, skip_header=1,
+                                     delimiter=',', invalid_raise=False)
+            except Exception as e:
+                print('GraphSquidAdmiral Charge_Discharge: actually, cannot read file!?')
+                print(e)
+                return False
+            def createCurve(x, y, sign):
+                self.append(Curve([np.abs(np.array(x))/3600, y], attributes))
+                if sign < 0:
+                    self[-1].update({'label': self[-1].attr('label').replace('Charge ', '')})
+                else:
+                    self[-1].update({'label': self[-1].attr('label').replace('Discharge ', '')})
+            x, y, tm, previous = [], [], data[0, 2], np.sign(data[0, 5])
+            for line in data:  # some quite dirty and innefficient data parsing
+                if np.sign(line[5]) != previous:  # if change of sign of current -> from charge to discharge or opposite
+                    createCurve(x, y, previous)
+                    x, y = [], []
+                    previous = np.sign(line[5])
+                x.append((x[-1] if len(x) > 0 else 0) + (line[2]-tm) * line[5])
+                y.append(line[4])
+                tm = line[2]
+            if len(x) > 0:
+                createCurve(x, y, previous)
+            labels = [['Charge', '', 'mAh'], ['Working Electrode', '', 'V']]
+            data, usecols = 1, 1  # bypass default data opening, ensure algo knows everything ok
+        # open file
+        if usecols is None:
+            print('GraphSquidAdmiral: actually, cannot read file!?')
+            return False
+        # default data file reading
+        if data is None:
+            try:
+                data = np.genfromtxt(self.filename, skip_header=1,
+                                     delimiter=',', usecols=usecols,
+                                     invalid_raise=False)
+            except Exception as e:
+                print('WARNING GraphSquidAdmiral cannot read file',
+                      self.filename)
+                print(type(e), e)
+                return False
+            self.append(Curve(np.transpose(data), attributes))
+        if labels is None:
+            labels = [kwargs['line1'].split(',')[c][1:-2].replace('""', "''") for c in usecols]
+            labels = [[l.split(' (')[0], '', l.split(' (')[-1]] for l in labels]
+        self.update({'xlabel': self.formatAxisLabel(labels[0]),
+                     'ylabel': self.formatAxisLabel(labels[1])})
```

### Comparing `grapa-0.5.4.8/grapa/datatypes/graphXLS.py` & `grapa-0.6.1.0/grapa/datatypes/graphXLS.py`

 * *Files 10% similar despite different names*

```diff
@@ -9,56 +9,56 @@
 
 from grapa.graph import Graph
 from grapa.graphIO import GraphIO
 from grapa.mathModule import is_number
 
 
 class GraphXLS(Graph):
-    
+
     FILEIO_GRAPHTYPE = 'Undetermined measurement type'
-    
+
     @classmethod
     def isFileReadable(cls, fileName, fileExt, **kwargs):
         if fileExt in ['.xls', '.xlsx']:
             return True
         return False
 
     def readDataFromFile(self, attributes, **kwargs):
         try:
             from xlrd import open_workbook
         except ImportError as e:
             print('ImportError: cannot import xlrd. GraphXLS aborted.', e)
             return False
-    
+
         wb = open_workbook(self.filename)
         sheet_id = attributes['complement'] if 'complement' in attributes else 0
         if not isinstance(sheet_id, str) and not is_number(sheet_id):
             sheet_id = attributes['sheetid'] if 'sheetid' in attributes else 0
-        try: # first try by name, then try by index, try first sheet by default
+        try:  # first try by name, then try by index, try first sheet by defaul
             sheet = wb.sheet_by_name(sheet_id)
         except Exception:
             try:
                 sheet = wb.sheet_by_index(sheet_id)
             except Exception:
                 sheet = wb.sheet_by_index(0)
-                print('readDataFromFileXLS: spreadsheet "', sheet_id, '" not found. Opened first sheet by default.')
+                print('readDataFromFileXLS: spreadsheet "', sheet_id, '" not',
+                      'found. Opened first sheet by default.')
         number_of_rows = sheet.nrows
         number_of_columns = sheet.ncols
         items = []
         for row in range(0, number_of_rows):
             values = []
             for col in range(number_of_columns):
-                try: # required to process correctly rows with merged cells
+                try:  # required to process correctly rows with merged cells
                     value = (sheet.cell(row, col).value)
                 except Exception:
                     value = ''
                 try:
                     value = str(float(value))
                 except ValueError:
                     pass
                 finally:
                     values.append(value)
             items.append(values)
         # identify correct way to process data - is it database, or file generic ?
         func = GraphIO._funcReadDataFile(self, items, attributes)
         func(self, attributes, fileContent=items)
-
```

### Comparing `grapa-0.5.4.8/grapa/datatypes/graphXML.py` & `grapa-0.6.1.0/grapa/datatypes/graphXML.py`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/datatypes/graphXPS.py` & `grapa-0.6.1.0/grapa/datatypes/graphXPS.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,41 +1,39 @@
 # -*- coding: utf-8 -*-
 """
 Created on Tue Jan 23 14:25:49 2018
 
 @author: Romain Carron
-Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain
+Carron
 """
 
 # -*- coding: utf-8 -*-
 
 import numpy as np
 
-
 from grapa.graph import Graph
 from grapa.curve import Curve
 
 
-
 class GraphXPS(Graph):
     """
     reads XPS data of system
     """
 
     FILEIO_GRAPHTYPE = 'XPS data'
-    
+
     AXISLABELS = [['Binding energy', '', 'eV'], ['Intensity', '', 'counts/s']]
 
     @classmethod
     def isFileReadable(cls, fileName, fileExt, line1='', **kwargs):
         if fileExt == '.csv' and line1.startswith('Point'):
             return True
         return False
-    
-        
+
     def readDataFromFile(self, attributes, **kwargs):
         # parse headers
         attrs = {}
         f = open(self.filename, 'r')
         attrs['acquisition location'] = f.readline().strip()
         attrs['acquisition sample'] = f.readline().strip()
         attrs['acquisition type'] = f.readline().strip()
@@ -51,16 +49,16 @@
             if not self.silent:
                 print('WARNING GraphXPS cannot read file', self.filename)
                 print(type(e), e)
                 return False
         try:
             self.append(Curve(data, attributes))
         except Exception as e:
-                print('WARNING GraphXPS cannot read file', self.filename)
-                print(type(e), e)
-                return False
-        self.curve(-1).update(attrs) # file content may override default attributes
+            print('WARNING GraphXPS cannot read file', self.filename)
+            print(type(e), e)
+            return False
+        self[-1].update(attrs)  # file content may override default attributes
+        self[-1].update({'sample': self.attr('label')})
         # graph cosmetics
         self.update({'xlabel': self.formatAxisLabel(GraphXPS.AXISLABELS[0]),
                      'ylabel': self.formatAxisLabel(GraphXPS.AXISLABELS[1])})
-        self.update({'xlim': [max(self.curve(-1).x()), min(self.curve(-1).x())]})
-                    
+        self.update({'xlim': [max(self[-1].x()), min(self[-1].x())]})
```

### Comparing `grapa-0.5.4.8/grapa/datatypes/spectrumInstrumentalResponses.txt` & `grapa-0.6.1.0/grapa/datatypes/spectrumInstrumentalResponses.txt`

 * *Files 18% similar despite different names*

```diff
@@ -1,1154 +1,1154 @@
-label	Reflectance (specular)	Reflectance (diffuse)	Transmittance (diffuse)
-details	grating 800nm, detector 900nm	Inverse of certified Spectralon	grating 875nm, detector 875nm
-Wavelength [nm]	instr resp R_spec	instr resp R_diff	instr resp T_diff
-200	0.98000	inf	inf
-202	0.98000		
-204	0.98000		
-206	0.98000		
-208	0.98000		
-210	0.98000		
-212	0.98000		
-214	0.98000		
-216	0.98000		
-218	0.98000		
-220	0.98000		
-222	0.98000		
-224	0.98000		
-226	0.98000		
-228	0.98000		
-230	0.98000		
-232	0.98000		
-234	0.98000		
-236	0.98000		
-238	0.98000		
-240	0.98000		
-242	0.98000		
-244	0.98000		
-246	0.98000		
-248	0.98000		
-250	0.98000	1.058948112	
-252	0.98000	1.05764146	
-254	0.98000	1.05764146	
-256	0.98000	1.056245049	
-258	0.98000	1.055966209	
-260	0.98000	1.05374078	
-262	0.98000	1.052077854	
-264	0.98000	1.049593283	
-266	0.98000	1.049042748	
-268	0.98000	1.047668937	
-270	0.98000	1.047120419	
-272	0.98000	1.046846375	
-274	0.98000	1.044932079	
-276	0.98000	1.04465918	
-278	0.98000	1.043024772	
-280	0.98000	1.042209484	
-282	0.98000	1.041124414	
-284	0.98000	1.037882719	
-286	0.98000	1.038691249	
-288	0.98000	1.035196687	
-290	0.98000	1.034661148	
-292	0.98000	1.033324722	
-294	0.98000	1.032258065	
-296	0.98000	1.030131342	
-298	0.98000	1.02960103	
-300	0.979306776	1.028542042	0.973058113
-302	0.980254025	1.028013364	0.972802941
-304	0.980363806	1.028013364	0.972386036
-306	0.980298122	1.026957638	0.970648845
-308	0.979456232	1.026694045	0.969830937
-310	0.979252083	1.026167265	0.969316126
-312	0.978289444	1.025904078	0.968524256
-314	0.979096431	1.024327785	0.967501292
-316	0.978467785	1.02380343	0.96619551
-318	0.977547102	1.02223358	0.965159017
-320	0.976980231	1.02223358	0.964102198
-322	0.97677353	1.020929045	0.963848068
-324	0.976236432	1.020668538	0.962571366
-326	0.975652869	1.020408163	0.962634891
-328	0.975216651	1.020929045	0.961627938
-330	0.975168728	1.019887812	0.961424961
-332	0.974373142	1.018589254	0.960518045
-334	0.97417624	1.01910828	0.959897917
-336	0.973651929	1.017811705	0.958889526
-338	0.973365514	1.018329939	0.958730818
-340	0.974008368	1.017293998	0.957765845
-342	0.973712669	1.017293998	0.957348724
-344	0.973794841	1.018589254	0.95625749
-346	0.974289877	1.016518424	0.955506952
-348	0.974080662	1.016776817	0.955191287
-350	0.973904702	1.016260163	0.954670373
-352	0.973676366	1.016260163	0.9540068
-354	0.973689266	1.016260163	0.953615741
-356	0.973758966	1.015486164	0.953184184
-358	0.974381913	1.016518424	0.952923738
-360	0.974203358	1.015744033	0.952854137
-362	0.973510859	1.016002032	0.952396259
-364	0.972584076	1.015228426	0.952020192
-366	0.973027163	1.014455998	0.951058938
-368	0.97310342	1.013684744	0.950496731
-370	0.97324216	1.014198783	0.950227782
-372	0.973019456	1.014713343	0.949214841
-374	0.97269136	1.013684744	0.948832576
-376	0.972504757	1.014198783	0.948894033
-378	0.972250436	1.013941698	0.948105292
-380	0.972502777	1.013941698	0.947934329
-382	0.972552688	1.014198783	0.947813533
-384	0.972779111	1.013171226	0.947645277
-386	0.972540816	1.012401924	0.946556139
-388	0.972507776	1.013171226	0.946044881
-390	0.972822685	1.012401924	0.945740318
-392	0.972979767	1.012145749	0.945569365
-394	0.973460822	1.011633789	0.945301685
-396	0.974021404	1.010866818	0.944624688
-398	0.973954354	1.011122346	0.944572578
-400	0.974199152	1.011633789	0.944333124
-402	0.974061755	1.011122346	0.943945789
-404	0.973929158	1.011122346	0.943718215
-406	0.973928281	1.01061142	0.943392663
-408	0.974165857	1.010866818	0.943147816
-410	0.974210794	1.010356151	0.942971415
-412	0.974378002	1.011122346	0.942695028
-414	0.974813239	1.011122346	0.942481243
-416	0.974947192	1.011122346	0.942217776
-418	0.975130464	1.011122346	0.941818467
-420	0.975277202	1.010356151	0.941609025
-422	0.975404435	1.010356151	0.941432454
-424	0.975104002	1.011889704	0.940805077
-426	0.975355291	1.011122346	0.940262911
-428	0.975328843	1.01010101	0.940238821
-430	0.975660965	1.010866818	0.939834446
-432	0.975981751	1.010866818	0.939351032
-434	0.976064675	1.01010101	0.939276213
-436	0.975933491	1.010356151	0.938984203
-438	0.976088884	1.011122346	0.938432619
-440	0.976141753	1.01061142	0.937816363
-442	0.976230918	1.010356151	0.937624221
-444	0.97633349	1.01010101	0.937283457
-446	0.976217909	1.01010101	0.936891708
-448	0.976228214	1.010356151	0.936455608
-450	0.976255699	1.010866818	0.935861171
-452	0.976511923	1.010866818	0.935460636
-454	0.976265982	1.010356151	0.935004569
-456	0.976224556	1.01010101	0.934761593
-458	0.976152274	1.01010101	0.934500126
-460	0.976155083	1.010866818	0.934090931
-462	0.976037553	1.011122346	0.933656913
-464	0.975947949	1.011122346	0.933305555
-466	0.976145299	1.010866818	0.933007938
-468	0.976177796	1.01010101	0.932752394
-470	0.976279334	1.01010101	0.932281329
-472	0.976572568	1.01061142	0.931715245
-474	0.976979018	1.009591116	0.930759289
-476	0.977072171	1.01010101	0.930567254
-478	0.977112639	1.009591116	0.930163697
-480	0.97732022	1.009845998	0.930216005
-482	0.977127377	1.008827238	0.92969041
-484	0.976995895	1.009081736	0.929068932
-486	0.976673352	1.01010101	0.929036034
-488	0.976713698	1.009336361	0.928413735
-490	0.976560122	1.009336361	0.928385081
-492	0.976545978	1.009845998	0.927733401
-494	0.976450963	1.009081736	0.92744909
-496	0.976307425	1.009081736	0.927148305
-498	0.97625835	1.009591116	0.927005398
-500	0.976175016	1.010356151	0.926397888
-502	0.975837786	1.009591116	0.926550623
-504	0.976120221	1.009845998	0.926032048
-506	0.976043568	1.008827238	0.925845922
-508	0.976185699	1.008827238	0.925364563
-510	0.975871515	1.009591116	0.925103155
-512	0.975435103	1.009591116	0.924395948
-514	0.975593576	1.009081736	0.924165218
-516	0.975453996	1.01010101	0.923831198
-518	0.975434635	1.010356151	0.923434405
-520	0.975219592	1.01010101	0.923569623
-522	0.975282119	1.009845998	0.923105415
-524	0.975200803	1.009845998	0.92289682
-526	0.975547828	1.009591116	0.922751759
-528	0.975487653	1.009591116	0.922403069
-530	0.97506907	1.009336361	0.922146626
-532	0.974693943	1.009081736	0.921802924
-534	0.974382622	1.009336361	0.921407177
-536	0.974658791	1.01010101	0.921420775
-538	0.974379855	1.009336361	0.921137126
-540	0.974327356	1.009845998	0.92081974
-542	0.974119663	1.009845998	0.920523201
-544	0.974200455	1.009845998	0.919902719
-546	0.974172864	1.01010101	0.919957772
-548	0.974042016	1.01010101	0.919417579
-550	0.973906959	1.009336361	0.919271441
-552	0.97397761	1.009081736	0.919052073
-554	0.973934673	1.009591116	0.919072479
-556	0.973942377	1.009081736	0.9187057
-558	0.973633127	1.009336361	0.91885406
-560	0.973635096	1.01010101	0.918539581
-562	0.973473984	1.01010101	0.918047165
-564	0.973228943	1.009336361	0.917787291
-566	0.973021622	1.009845998	0.917760579
-568	0.97325266	1.009845998	0.917644126
-570	0.973400748	1.009845998	0.917117384
-572	0.97336744	1.01010101	0.917097953
-574	0.973403821	1.009845998	0.916769399
-576	0.97361869	1.009336361	0.916585482
-578	0.973759485	1.009845998	0.916661536
-580	0.973641801	1.008827238	0.916223232
-582	0.973643846	1.009081736	0.916158275
-584	0.973797992	1.010866818	0.915961964
-586	0.97398689	1.010356151	0.9153424
-588	0.974023163	1.01010101	0.915347078
-590	0.974262867	1.009845998	0.915222701
-592	0.974224785	1.009081736	0.914874175
-594	0.97428458	1.009336361	0.914614951
-596	0.97427531	1.01010101	0.914427768
-598	0.974296178	1.01010101	0.914315672
-600	0.973290155	1.01010101	0.914300538
-602	0.97333706	1.01010101	0.913920365
-604	0.973395189	1.009845998	0.9135752
-606	0.97347264	1.009845998	0.913223869
-608	0.973438654	1.010866818	0.913179675
-610	0.973422114	1.010356151	0.913362452
-612	0.973227339	1.01010101	0.913123716
-614	0.973532049	1.01061142	0.912950901
-616	0.973715264	1.009845998	0.912875184
-618	0.973932773	1.009845998	0.912327553
-620	0.973975754	1.01010101	0.912074441
-622	0.974096023	1.01010101	0.911953044
-624	0.974228947	1.01061142	0.911604087
-626	0.974446466	1.01010101	0.911294365
-628	0.974450118	1.01010101	0.911127461
-630	0.974637698	1.01010101	0.911077032
-632	0.97489277	1.01010101	0.910889952
-634	0.97531931	1.010356151	0.910516315
-636	0.975671189	1.010356151	0.910285531
-638	0.975919863	1.01010101	0.910451528
-640	0.976115187	1.01010101	0.910076824
-642	0.97628836	1.01010101	0.909815933
-644	0.97666621	1.010356151	0.909618293
-646	0.976963716	1.010356151	0.909231668
-648	0.97750896	1.01010101	0.909267791
-650	0.977706984	1.010866818	0.909198045
-652	0.977758878	1.010356151	0.90846783
-654	0.977903541	1.01010101	0.908542928
-656	0.978124702	1.01010101	0.908239437
-658	0.978436414	1.010866818	0.907863492
-660	0.978662823	1.010356151	0.907814375
-662	0.978873169	1.01010101	0.907484711
-664	0.979344981	1.01010101	0.907278018
-666	0.97990398	1.01010101	0.90726233
-668	0.980494499	1.01010101	0.907028883
-670	0.981067692	1.010356151	0.907142884
-672	0.981301247	1.010356151	0.906926253
-674	0.981913351	1.01010101	0.906585253
-676	0.982381945	1.01010101	0.906767269
-678	0.982875219	1.01010101	0.906774699
-680	0.983068435	1.009845998	0.90655182
-682	0.983183309	1.010356151	0.90627955
-684	0.983439632	1.009591116	0.906315601
-686	0.983484138	1.01010101	0.905443883
-688	0.983344733	1.01061142	0.905729926
-690	0.983479289	1.009845998	0.905530463
-692	0.984058217	1.01010101	0.905122156
-694	0.984600965	1.010356151	0.904509859
-696	0.984890648	1.009845998	0.904547991
-698	0.985268151	1.009845998	0.904611762
-700	0.985453081	1.009591116	0.904401429
-702	0.98615885	1.010356151	0.904621676
-704	0.986387619	1.009081736	0.904308853
-706	0.986635076	1.009845998	0.903840024
-708	0.986667904	1.01061142	0.903460833
-710	0.987191338	1.009336361	0.902931084
-712	0.987604775	1.009336361	0.902827455
-714	0.987909849	1.009845998	0.902895246
-716	0.988588868	1.009845998	0.902663905
-718	0.98892485	1.01010101	0.90216506
-720	0.989009441	1.01010101	0.901640517
-722	0.989216702	1.01010101	0.901491941
-724	0.989644304	1.009336361	0.901480383
-726	0.990180659	1.009336361	0.901264173
-728	0.990613617	1.009336361	0.901370335
-730	0.991152573	1.009336361	0.901010897
-732	0.991389133	1.009845998	0.900588435
-734	0.991615915	1.009081736	0.90032622
-736	0.992026142	1.009336361	0.900629584
-738	0.992427043	1.009336361	0.900304209
-740	0.992980645	1.009336361	0.900487652
-742	0.992978978	1.01010101	0.900157304
-744	0.99303011	1.010356151	0.899958331
-746	0.993630702	1.01010101	0.899914978
-748	0.993892535	1.009845998	0.898931243
-750	0.99434508	1.009591116	0.89840517
-752	0.994559502	1.009336361	0.898301368
-754	0.995375897	1.009845998	0.898463654
-756	0.995631374	1.01010101	0.898439725
-758	0.995898559	1.01010101	0.898396394
-760	0.996161498	1.01010101	0.897622295
-762	0.996267277	1.01010101	0.897491724
-764	0.996498003	1.01010101	0.897486469
-766	0.996592985	1.01010101	0.897435433
-768	0.99683387	1.009336361	0.89776356
-770	0.997144996	1.009845998	0.897479229
-772	0.99746543	1.009845998	0.897172776
-774	0.997973071	1.009336361	0.896883555
-776	0.998422315	1.009591116	0.896263504
-778	0.998887309	1.009081736	0.896253084
-780	0.999112063	1.01010101	0.895812578
-782	0.999560545	1.010866818	0.896114332
-784	1.000374994	1.010356151	0.896008532
-786	1.000989269	1.009336361	0.895862166
-788	1.001362848	1.009081736	0.896146935
-790	1.001393985	1.009845998	0.895367817
-792	1.001735981	1.009336361	0.894929053
-794	1.001824836	1.009845998	0.895148454
-796	1.002278694	1.01010101	0.894874213
-798	1.002428656	1.01010101	0.895335587
-800	1.003114082	1.01010101	0.89498965
-802	1.003041905	1.009845998	0.894905982
-804	1.002970151	1.01010101	0.894126192
-806	1.002026671	1.010356151	0.893685943
-808	1.002138455	1.009336361	0.893488237
-810	1.001936552	1.009336361	0.893856355
-812	1.002456133	1.01061142	0.893404324
-814	1.002441674	1.01010101	0.893531392
-816	1.002433906	1.009845998	0.893353777
-818	1.001627122	1.01010101	0.89337616
-820	1.001053795	1.009591116	0.892969675
-822	1.000776396	1.009591116	0.892073128
-824	1.000206797	1.008318629	0.892298369
-826	0.999723469	1.008827238	0.89211531
-828	0.999367212	1.009081736	0.892455054
-830	0.999206078	1.009591116	0.892008384
-832	0.999079795	1.009845998	0.891050265
-834	0.998589016	1.009845998	0.890447072
-836	0.998398224	1.009845998	0.889800061
-838	0.99724642	1.009845998	0.890762204
-840	0.996670015	1.010356151	0.890364839
-842	0.995502024	1.01010101	0.890925018
-844	0.994581596	1.009845998	0.89060856
-846	0.993582114	1.008318629	0.890639624
-848	0.992829874	1.009336361	0.890093866
-850	0.993447149	1.008572869	0.889697495
-852	0.992584305	1.01010101	0.889536776
-854	0.991683076	1.010356151	0.888367932
-856	0.989692147	1.01010101	0.888340483
-858	0.98799241	1.011122346	0.888319891
-860	0.986686539	1.01061142	0.888821884
-862	0.988072974	1.010356151	0.889359959
-864	0.988630345	1.01010101	0.89021472
-866	0.98627489	1.009845998	0.888045484
-868	0.985519587	1.01061142	0.888432091
-870	0.986295629	1.009591116	0.889855277
-872	0.989246984	1.01061142	0.88681099
-874	0.97749359	1.01010101	0.885289392
-876	0.965137393	1.01010101	0.884138111
-878	0.953251589	1.01010101	0.88301684
-880	0.952137826	1.01010101	0.882677279
-882	0.952853274	1.01010101	0.882778528
-884	0.95357345	1.01010101	0.883441222
-886	0.953258354	1.010866818	0.883028014
-888	0.95394444	1.01061142	0.883097165
-890	0.956530809	1.010356151	0.881661949
-892	0.959896358	1.01061142	0.883195045
-894	0.958531681	1.01010101	0.882705718
-896	0.954846639	1.010866818	0.885017895
-898	0.954650457	1.010866818	0.881871002
-900	0.953890209	1.01010101	0.882319321
-902	0.954535722	1.01010101	0.846158589
-904	0.954067175	1.01010101	0.847090201
-906	0.954608098	1.01010101	0.845836119
-908	0.956337928	1.01010101	0.846387601
-910	0.954388658	1.01010101	0.84399581
-912	0.954339347	1.01010101	0.844099539
-914	0.952914973	1.01010101	0.845257718
-916	0.952971004	1.01010101	0.846583259
-918	0.953513235	1.010356151	0.846882445
-920	0.952314808	1.010356151	0.84661938
-922	0.952211611	1.01010101	0.845969565
-924	0.950966826	1.01010101	0.84488876
-926	0.952117441	1.01010101	0.844575528
-928	0.951899291	1.01061142	0.844852823
-930	0.95322173	1.01061142	0.846207684
-932	0.9525647	1.01010101	0.8455751
-934	0.951815061	1.01010101	0.845927326
-936	0.949743479	1.01010101	0.845545428
-938	0.950095254	1.01010101	0.845484234
-940	0.951475957	1.01010101	0.844908501
-942	0.952304614	1.01010101	0.844991646
-944	0.950366194	1.01010101	0.845837972
-946	0.949517074	1.01010101	0.845812011
-948	0.949881008	1.01010101	0.84637876
-950	0.94948966	1.010356151	0.84574774
-952	0.948022202	1.010356151	0.845186372
-954	0.947158184	1.01010101	0.844510443
-956	0.949159857	1.01010101	0.845216885
-958	0.949093164	1.01010101	0.845367505
-960	0.949419144	1.01010101	0.844922866
-962	0.948183578	1.01010101	0.84435922
-964	0.948583871	1.01010101	0.844573417
-966	0.948076244	1.01010101	0.844923286
-968	0.947875378	1.01010101	0.84516363
-970	0.946946474	1.01010101	0.844800488
-972	0.946898077	1.01010101	0.844350984
-974	0.947096085	1.01010101	0.844206156
-976	0.947307217	1.01010101	0.844011883
-978	0.946717623	1.01010101	0.843773345
-980	0.946125551	1.01010101	0.843433281
-982	0.946163126	1.01010101	0.843356001
-984	0.946037353	1.01010101	0.843472322
-986	0.945429972	1.01010101	0.843079026
-988	0.94617874	1.01010101	0.843161533
-990	0.94688603	1.01010101	0.842796016
-992	0.947736611	1.01010101	0.84244365
-994	0.946785278	1.01010101	0.842255338
-996	0.945465379	1.01010101	0.841847371
-998	0.94472749	1.01010101	0.841865332
-1000	0.94512785	1.01010101	0.841513207
-1002	0.945837551	1.01010101	0.841643039
-1004	0.945835392	1.01010101	0.841024995
-1006	0.944736738	1.01010101	0.840817213
-1008	0.944089885	1.009591116	0.840712129
-1010	0.943342418	1.01010101	0.840951127
-1012	0.942823644	1.01010101	0.840927912
-1014	0.942414407	1.01010101	0.840140048
-1016	0.942432569	1.01010101	0.839952416
-1018	0.941701119	1.01010101	0.83932417
-1020	0.941342287	1.01010101	0.839883175
-1022	0.941334926	1.01010101	0.839445739
-1024	0.942285323	1.01010101	0.839465566
-1026	0.942565169	1.01010101	0.83858752
-1028	0.941932136	1.01010101	0.83818796
-1030	0.941479193	1.01010101	0.83775809
-1032	0.941138297	1.01010101	0.837624307
-1034	0.941295399	1.01010101	0.837667092
-1036	0.940820242	1.01010101	0.837406157
-1038	0.939957185	1.01010101	0.837094306
-1040	0.939276546	1.01010101	0.837052497
-1042	0.939246332	1.01010101	0.836930589
-1044	0.938799565	1.01010101	0.837198722
-1046	0.938889996	1.01010101	0.836471019
-1048	0.938905282	1.01010101	0.836299794
-1050	0.938979837	1.01010101	0.836113634
-1052	0.938307894	1.01010101	0.836302159
-1054	0.93789325	1.01010101	0.83643544
-1056	0.938054521	1.01010101	0.835603495
-1058	0.938324026	1.01010101	0.835374952
-1060	0.938130359	1.01010101	0.835109968
-1062	0.937422611	1.01010101	0.835645373
-1064	0.937390723	1.01010101	0.835650025
-1066	0.937330083	1.01010101	0.835627298
-1068	0.937259565	1.01010101	0.835220756
-1070	0.936709988	1.01010101	0.834760954
-1072	0.935997521	1.01010101	0.834374923
-1074	0.93620552	1.01010101	0.834208228
-1076	0.935706823	1.01010101	0.834291139
-1078	0.935321453	1.01010101	0.834174274
-1080	0.934553634	1.01010101	0.834337794
-1082	0.93519583	1.01010101	0.834319667
-1084	0.935203489	1.01010101	0.83405897
-1086	0.93483893	1.01010101	0.833431653
-1088	0.934286827	1.01010101	0.833573667
-1090	0.933879776	1.01010101	0.83362693
-1092	0.934134093	1.01010101	0.833830219
-1094	0.933749861	1.01010101	0.832911624
-1096	0.933444732	1.01010101	0.83291726
-1098	0.933175163	1.01010101	0.832349403
-1100	0.932930066	1.01010101	0.83276705
-1102	0.932966606	1.009845998	0.832382411
-1104	0.932725392	1.009845998	0.832567798
-1106	0.932370735	1.01010101	0.832105448
-1108	0.932243547	1.01010101	0.832276187
-1110	0.932247005	1.01010101	0.832071018
-1112	0.932125373	1.009591116	0.832475638
-1114	0.931832692	1.01010101	0.832157966
-1116	0.931361385	1.01010101	0.831851653
-1118	0.931218813	1.01010101	0.832225232
-1120	0.930941404	1.01010101	0.831985827
-1122	0.930960827	1.01010101	0.832225585
-1124	0.9310834	1.01010101	0.831857773
-1126	0.931330265	1.01010101	0.831992279
-1128	0.931029328	1.01010101	0.831629732
-1130	0.930214922	1.01010101	0.831502973
-1132	0.929683441	1.01010101	0.831796164
-1134	0.92939552	1.01010101	0.831997946
-1136	0.929703351	1.01010101	0.831829607
-1138	0.929521516	1.009845998	0.83190451
-1140	0.929418928	1.009591116	0.832061042
-1142	0.928756465	1.009845998	0.832422887
-1144	0.928177989	1.01010101	0.832675383
-1146	0.927742414	1.01010101	0.833218306
-1148	0.92790494	1.01010101	0.833031418
-1150	0.92811716	1.01010101	0.833185262
-1152	0.928092571	1.01010101	0.833152201
-1154	0.92778277	1.01010101	0.83363238
-1156	0.927471373	1.01010101	0.83352956
-1158	0.926975384	1.01010101	0.833928343
-1160	0.926384189	1.01010101	0.833920679
-1162	0.925866781	1.01010101	0.834098302
-1164	0.925883732	1.01010101	0.834012787
-1166	0.925644034	1.01010101	0.833832602
-1168	0.925352207	1.01010101	0.833563606
-1170	0.924924585	1.01010101	0.833193652
-1172	0.924757843	1.01010101	0.833230648
-1174	0.924701336	1.01010101	0.833368493
-1176	0.924484808	1.010866818	0.833977257
-1178	0.924647031	1.011122346	0.83402272
-1180	0.924629478	1.011122346	0.8335478
-1182	0.924365471	1.011122346	0.833107072
-1184	0.923877829	1.011122346	0.832960663
-1186	0.923896388	1.011122346	0.833544654
-1188	0.923849686	1.011122346	0.833206583
-1190	0.923974426	1.011122346	0.833152282
-1192	0.923582307	1.011122346	0.833019225
-1194	0.922943904	1.011122346	0.832963503
-1196	0.922383454	1.011122346	0.8324976
-1198	0.921829981	1.011122346	0.832316793
-1200	0.922142953	1.011122346	0.832194924
-1202	0.921771437	1.011122346	0.831837165
-1204	0.92147279	1.011122346	0.831476889
-1206	0.921515517	1.011122346	0.831144801
-1208	0.921169773	1.011122346	0.831259118
-1210	0.920988298	1.011122346	0.831135818
-1212	0.920807055	1.011122346	0.831288214
-1214	0.921150671	1.011122346	0.831197178
-1216	0.921263868	1.011122346	0.831342497
-1218	0.920846329	1.011122346	0.831049379
-1220	0.920346789	1.011122346	0.831211774
-1222	0.919832733	1.011122346	0.83063925
-1224	0.919853196	1.011122346	0.830250875
-1226	0.919544037	1.011122346	0.829682721
-1228	0.91965569	1.011122346	0.829780915
-1230	0.919208112	1.011122346	0.829752247
-1232	0.918860455	1.011122346	0.829451015
-1234	0.918846123	1.011122346	0.828871017
-1236	0.918603282	1.011122346	0.828500421
-1238	0.91843669	1.011122346	0.828758345
-1240	0.917577436	1.011122346	0.82876556
-1242	0.916947283	1.011122346	0.828965612
-1244	0.916618106	1.011122346	0.828362768
-1246	0.916313856	1.011122346	0.827908879
-1248	0.916335156	1.011122346	0.828001254
-1250	0.916285732	1.011378003	0.827833255
-1252	0.91631095	1.011633789	0.827929181
-1254	0.916477322	1.011378003	0.827372406
-1256	0.915914482	1.011122346	0.827338578
-1258	0.915806065	1.011122346	0.827316515
-1260	0.91540327	1.011122346	0.827175818
-1262	0.915431562	1.011122346	0.826890223
-1264	0.915002961	1.011122346	0.826623004
-1266	0.91477211	1.011122346	0.826685506
-1268	0.914452489	1.011122346	0.826336892
-1270	0.914063721	1.011122346	0.82597297
-1272	0.913708589	1.011122346	0.825304373
-1274	0.913690673	1.011889704	0.825016272
-1276	0.913629279	1.012145749	0.825448977
-1278	0.913252394	1.012145749	0.825454546
-1280	0.912757912	1.012145749	0.825507538
-1282	0.912382687	1.012145749	0.825620097
-1284	0.91217059	1.012145749	0.825892867
-1286	0.911990936	1.012145749	0.826223658
-1288	0.911837404	1.012145749	0.825819688
-1290	0.911672535	1.012145749	0.82571117
-1292	0.911897346	1.012145749	0.825327391
-1294	0.911709215	1.012145749	0.825452217
-1296	0.91122819	1.012145749	0.825332768
-1298	0.910693851	1.012145749	0.825745727
-1300	0.91026291	1.012145749	0.826099084
-1302	0.909770748	1.012145749	0.82601242
-1304	0.909094548	1.012145749	0.825579753
-1306	0.908991491	1.012145749	0.825143942
-1308	0.908914832	1.012914662	0.825077574
-1310	0.909239529	1.012401924	0.825355645
-1312	0.908980924	1.012401924	0.825617251
-1314	0.908920125	1.012401924	0.826322204
-1316	0.908420861	1.012145749	0.826457248
-1318	0.908234776	1.012145749	0.826532096
-1320	0.90759312	1.012145749	0.826635361
-1322	0.90702255	1.012145749	0.826954451
-1324	0.906837988	1.012145749	0.827424102
-1326	0.906808862	1.012914662	0.828144311
-1328	0.906452796	1.013171226	0.828676768
-1330	0.906186148	1.013171226	0.828535469
-1332	0.906023314	1.013171226	0.828538411
-1334	0.906348212	1.013171226	0.828375654
-1336	0.905624975	1.013171226	0.82878674
-1338	0.905387274	1.013171226	0.828673718
-1340	0.90461709	1.013171226	0.828984811
-1342	0.904274118	1.01342792	0.829106172
-1344	0.90372978	1.01342792	0.82950556
-1346	0.903461881	1.013171226	0.82984633
-1348	0.902896317	1.01342792	0.83031408
-1350	0.902778672	1.01342792	0.830989176
-1352	0.901790574	1.01342792	0.831084019
-1354	0.901500192	1.013941698	0.831264409
-1356	0.900809285	1.013171226	0.831498549
-1358	0.900799723	1.01342792	0.83159813
-1360	0.899971078	1.01342792	0.831313888
-1362	0.89975355	1.013171226	0.83163851
-1364	0.899104731	1.013941698	0.832538079
-1366	0.899302369	1.014198783	0.832919681
-1368	0.898799494	1.014198783	0.83388811
-1370	0.898981831	1.014198783	0.834798434
-1372	0.899141683	1.014198783	0.836198791
-1374	0.898892104	1.01342792	0.837052275
-1376	0.898578348	1.013941698	0.837859423
-1378	0.897234239	1.013684744	0.839248795
-1380	0.896492752	1.013941698	0.84043997
-1382	0.895678655	1.013171226	0.842169059
-1384	0.895480571	1.013941698	0.844102419
-1386	0.894914455	1.014198783	0.845533773
-1388	0.894292225	1.014198783	0.846887932
-1390	0.893532897	1.014198783	0.847243043
-1392	0.893050656	1.014198783	0.848338105
-1394	0.892400983	1.014198783	0.849842142
-1396	0.89201948	1.014198783	0.851920987
-1398	0.891767461	1.014198783	0.853501497
-1400	0.891352533	1.014198783	0.855092127
-1402	0.8901854	1.014198783	0.856433671
-1404	0.889118016	1.014198783	0.857999611
-1406	0.88838302	1.014198783	0.860530137
-1408	0.887919214	1.014198783	0.862670294
-1410	0.886509755	1.014198783	0.865341707
-1412	0.885320363	1.013941698	0.866230398
-1414	0.884648843	1.013941698	0.867124316
-1416	0.884609073	1.014198783	0.868325732
-1418	0.884419554	1.014198783	0.870030762
-1420	0.883291118	1.014198783	0.871305776
-1422	0.88235113	1.014198783	0.871550717
-1424	0.881653059	1.013941698	0.872104063
-1426	0.881386109	1.012658228	0.872967275
-1428	0.880821655	1.013171226	0.874573076
-1430	0.879743147	1.013171226	0.874684308
-1432	0.878944266	1.013171226	0.875583109
-1434	0.877936261	1.013171226	0.875588612
-1436	0.877156268	1.013171226	0.876217235
-1438	0.876449487	1.013171226	0.875635499
-1440	0.876364328	1.013171226	0.876361288
-1442	0.876076023	1.013171226	0.876287223
-1444	0.875538641	1.013171226	0.875872643
-1446	0.874994065	1.013171226	0.876315401
-1448	0.874960432	1.013171226	0.876896449
-1450	0.874594265	1.013171226	0.87714913
-1452	0.874421108	1.013171226	0.875819753
-1454	0.873544788	1.013171226	0.875558084
-1456	0.873094177	1.013171226	0.87545166
-1458	0.872236716	1.013171226	0.875331354
-1460	0.871905816	1.013171226	0.874942251
-1462	0.872118182	1.013171226	0.874524749
-1464	0.871866748	1.013171226	0.874515509
-1466	0.87152167	1.013171226	0.874009722
-1468	0.871304813	1.013171226	0.873010467
-1470	0.871463244	1.013171226	0.872125678
-1472	0.871874885	1.013171226	0.871122642
-1474	0.87090128	1.013171226	0.870598422
-1476	0.8709993	1.013171226	0.869974448
-1478	0.870905234	1.013171226	0.869358121
-1480	0.871202361	1.013171226	0.868772344
-1482	0.87095614	1.013171226	0.867921803
-1484	0.870167908	1.013171226	0.86715337
-1486	0.869390202	1.013171226	0.865630453
-1488	0.869470985	1.013171226	0.864698198
-1490	0.86995558	1.013171226	0.863554667
-1492	0.870719245	1.013171226	0.862696911
-1494	0.870293679	1.013171226	0.861139768
-1496	0.869756862	1.013171226	0.860935239
-1498	0.869514083	1.013171226	0.860934859
-1500	0.868985541	1.013171226	0.860497927
-1502	0.868498926	1.013171226	0.858550812
-1504	0.868360966	1.013171226	0.857138913
-1506	0.86952076	1.013171226	0.856605086
-1508	0.869970426	1.013171226	0.855066539
-1510	0.869572539	1.013171226	0.853929512
-1512	0.868739492	1.013171226	0.852518443
-1514	0.868319644	1.013171226	0.852695714
-1516	0.868337066	1.013171226	0.851802748
-1518	0.86878658	1.013171226	0.850976826
-1520	0.868537393	1.013171226	0.850118535
-1522	0.86922455	1.013171226	0.848543458
-1524	0.868037521	1.013171226	0.84834815
-1526	0.868813051	1.013171226	0.847997983
-1528	0.868065303	1.013171226	0.848837337
-1530	0.867270929	1.013171226	0.847582906
-1532	0.866797414	1.013171226	0.846018973
-1534	0.867372463	1.013171226	0.844631484
-1536	0.867740731	1.013171226	0.844428065
-1538	0.867541103	1.013171226	0.844512274
-1540	0.865788054	1.013171226	0.843914651
-1542	0.86603933	1.013171226	0.843117799
-1544	0.86512782	1.013171226	0.841505646
-1546	0.865184649	1.013171226	0.841033051
-1548	0.864399918	1.013171226	0.840204199
-1550	0.865159911	1.013171226	0.840345979
-1552	0.864796489	1.013171226	0.839696804
-1554	0.864683111	1.013171226	0.839812039
-1556	0.86347615	1.013171226	0.838893798
-1558	0.864036244	1.013171226	0.83864939
-1560	0.863867518	1.013171226	0.837350077
-1562	0.864542753	1.013171226	0.837883509
-1564	0.86412846	1.013171226	0.837162353
-1566	0.863588728	1.013171226	0.837032821
-1568	0.863353098	1.013171226	0.836622122
-1570	0.862758064	1.013171226	0.83602689
-1572	0.862711179	1.013171226	0.835612767
-1574	0.861755876	1.013171226	0.834594336
-1576	0.862489402	1.01342792	0.834026504
-1578	0.8622663	1.01342792	0.832781358
-1580	0.862496194	1.013171226	0.833062373
-1582	0.861218009	1.013171226	0.832833211
-1584	0.861286101	1.013171226	0.833584719
-1586	0.860896837	1.013171226	0.83235398
-1588	0.860811825	1.013941698	0.832383243
-1590	0.861192487	1.01342792	0.832635609
-1592	0.861437988	1.013171226	0.832747679
-1594	0.861342042	1.013941698	0.832657892
-1596	0.85953326	1.013941698	0.831655101
-1598	0.858804195	1.013171226	0.831357196
-1600	0.859290993	1.013171226	0.829535952
-1602	0.859612233	1.013171226	0.829212091
-1604	0.859608685	1.013171226	0.828782721
-1606	0.858817728	1.013171226	0.829702309
-1608	0.858905673	1.013171226	0.829456164
-1610	0.858792014	1.013171226	0.828356574
-1612	0.858205362	1.013941698	0.827956701
-1614	0.858265757	1.014198783	0.827682875
-1616	0.858227317	1.014198783	0.827294489
-1618	0.859502691	1.013941698	0.826468017
-1620	0.859660656	1.013941698	0.826700824
-1622	0.8591956	1.014198783	0.826827335
-1624	0.857563478	1.014198783	0.827082459
-1626	0.85643017	1.01497082	0.827603754
-1628	0.856863822	1.015228426	0.82867559
-1630	0.857749887	1.015228426	0.827466314
-1632	0.85809653	1.015228426	0.826349846
-1634	0.858006894	1.015228426	0.825186793
-1636	0.856851836	1.015228426	0.825429806
-1638	0.85716612	1.015228426	0.827105952
-1640	0.856297219	1.015228426	0.827330574
-1642	0.856120666	1.015228426	0.827580522
-1644	0.85480225	1.015228426	0.825759967
-1646	0.854560042	1.015228426	0.825963319
-1648	0.855425459	1.015228426	0.825196362
-1650	0.85538076	1.015228426	0.825700179
-1652	0.855202048	1.015228426	0.825223529
-1654	0.853512644	1.015228426	0.825196932
-1656	0.853734081	1.015228426	0.824953745
-1658	0.853991938	1.015228426	0.824272586
-1660	0.854579496	1.015228426	0.824969959
-1662	0.854294481	1.015228426	0.823789402
-1664	0.853306667	1.015228426	0.824190915
-1666	0.853726514	1.015744033	0.824499343
-1668	0.853336653	1.015486164	0.824977029
-1670	0.855137987	1.015744033	0.823963598
-1672	0.854041593	1.016260163	0.822580299
-1674	0.853498174	1.016260163	0.82293826
-1676	0.852228843	1.017035342	0.823519075
-1678	0.852935258	1.017293998	0.823873841
-1680	0.854366025	1.017293998	0.823286648
-1682	0.853895887	1.017293998	0.823823335
-1684	0.853033447	1.017293998	0.824194339
-1686	0.852419571	1.017293998	0.823538176
-1688	0.852065093	1.017293998	0.823159921
-1690	0.851331186	1.017293998	0.822849715
-1692	0.850281631	1.017293998	0.823883541
-1694	0.85119037	1.017293998	0.822857033
-1696	0.850902677	1.017293998	0.822012824
-1698	0.850583958	1.017293998	0.821879642
-1700	0.848122932	1.017293998	0.822863427
-1702	0.847776556	1.017293998	0.823568479
-1704	0.847277191	1.017293998	0.822777525
-1706	0.847009287	1.017293998	0.822566596
-1708	0.847568819	1.017293998	0.823150598
-1710	0.846487434	1.017293998	0.823374618
-1712	0.84684694	1.017293998	0.824169658
-1714	0.846119702	1.017293998	0.823489949
-1716	0.846712361	1.017293998	0.822591638
-1718	0.846278617	1.017293998	0.823981209
-1720	0.846072186	1.017293998	0.824634008
-1722	0.845070064	1.017293998	0.825764449
-1724	0.845650119	1.017293998	0.824725042
-1726	0.845368562	1.017293998	0.825923302
-1728	0.84519906	1.017293998	0.827084566
-1730	0.844080327	1.017293998	0.826808276
-1732	0.840692132	1.017293998	0.826459056
-1734	0.840362144	1.017293998	0.826094357
-1736	0.83872177	1.017293998	0.82509527
-1738	0.840106017	1.017293998	0.823800326
-1740	0.840445792	1.017293998	0.824141867
-1742	0.84160005	1.017293998	0.826560505
-1744	0.843226699	1.017293998	0.82931454
-1746	0.842458164	1.017293998	0.830088832
-1748	0.84299681	1.017293998	0.8304914
-1750	0.842295463	1.017293998	0.830142104
-1752	0.841528635	1.017293998	0.83032214
-1754	0.839414895	1.017293998	0.829404888
-1756	0.839381859	1.017293998	0.829691384
-1758	0.838747093	1.017035342	0.830047733
-1760	0.837605129	1.017035342	0.831320538
-1762	0.835418068	1.017293998	0.832367608
-1764	0.834958945	1.017293998	0.832402457
-1766	0.836205158	1.017293998	0.832017596
-1768	0.834418616	1.017293998	0.831676899
-1770	0.834904415	1.017293998	0.834352812
-1772	0.832593231	1.017293998	0.835428473
-1774	0.832658783	1.016776817	0.837138568
-1776	0.831708227	1.017293998	0.834822864
-1778	0.832747703	1.017293998	0.834748435
-1780	0.833354319	1.017293998	0.833115921
-1782	0.833197807	1.017035342	0.835847266
-1784	0.833240799	1.017035342	0.836014252
-1786	0.833720276	1.017293998	0.838793278
-1788	0.832222327	1.017293998	0.838794874
-1790	0.831128645	1.017293998	0.837893594
-1792	0.828559986	1.017293998	0.835503433
-1794	0.830372496	1.017293998	0.832917548
-1796	0.828962351	1.017293998	0.832262572
-1798	0.831383358	1.017293998	0.832751966
-1800	0.828315855	1.017293998	0.833487584
-1802	0.829537908	1.017293998	0.835684008
-1804	0.828479879	1.017293998	0.835673176
-1806	0.830179435	1.017552786	0.835978248
-1808	0.829066233	1.018329939	0.836183303
-1810	0.829248263	1.018329939	0.835181877
-1812	0.829259502	1.018329939	0.835487487
-1814	0.829293229	1.018329939	0.835134143
-1816	0.829681319	1.018329939	0.837088405
-1818	0.830287716	1.018589254	0.836266879
-1820	0.829175648	1.019367992	0.835372355
-1822	0.826901372	1.019367992	0.836025962
-1824	0.826437237	1.020147921	0.837659025
-1826	0.828612099	1.019627836	0.83724437
-1828	0.828947902	1.020147921	0.836886674
-1830	0.82812367	1.020408163	0.836373103
-1832	0.827104889	1.020929045	0.837326118
-1834	0.827831927	1.021189686	0.835015616
-1836	0.828123177	1.02145046	0.83604575
-1838	0.828515063	1.020929045	0.837644588
-1840	0.827622212	1.02145046	0.839105265
-1842	0.826728955	1.02145046	0.838132276
-1844	0.826169361	1.02223358	0.838871422
-1846	0.824378115	1.022494888	0.83871088
-1848	0.824298771	1.022494888	0.840229586
-1850	0.823563371	1.022494888	0.840699928
-1852	0.824781554	1.022494888	0.839547056
-1854	0.824858262	1.022494888	0.841108969
-1856	0.824287898	1.022494888	0.843000179
-1858	0.822588422	1.022494888	0.846175549
-1860	0.821945815	1.022494888	0.848351417
-1862	0.822544113	1.023017903	0.850061311
-1864	0.822662917	1.022756328	0.852393099
-1866	0.819770995	1.022756328	0.855053095
-1868	0.818598032	1.023279611	0.856340674
-1870	0.817522405	1.023541453	0.859347503
-1872	0.8187432	1.023541453	0.865063438
-1874	0.816222504	1.023279611	0.872649806
-1876	0.815681005	1.02406554	0.881819645
-1878	0.816126334	1.02380343	0.888821355
-1880	0.816789716	1.024327785	0.895253343
-1882	0.815536212	1.02406554	0.901750696
-1884	0.810753186	1.02406554	0.906060176
-1886	0.808076598	1.02406554	0.912472874
-1888	0.80579057	1.024327785	0.920171377
-1890	0.806563035	1.024327785	0.928077959
-1892	0.80377486	1.024590164	0.940837846
-1894	0.803304549	1.024327785	0.948861463
-1896	0.801304445	1.023541453	0.956011305
-1898	0.800432785	1.02406554	0.963247635
-1900	0.793400206	1.024327785	0.966905732
-1902	0.790681635	1.025115325	0.974798026
-1904	0.788429567	1.02380343	0.975933637
-1906	0.79217986	1.023541453	0.983567801
-1908	0.790258908	1.024327785	0.993002538
-1910	0.787548342	1.02380343	1.00657427
-1912	0.784985677	1.024327785	1.010998127
-1914	0.782758933	1.024852677	1.016031377
-1916	0.783238243	1.024327785	1.014500007
-1918	0.782388942	1.024590164	1.022966962
-1920	0.781254716	1.02406554	1.026118284
-1922	0.780740521	1.024590164	1.031336157
-1924	0.777527809	1.024590164	1.031400409
-1926	0.778215243	1.025378108	1.036194451
-1928	0.775224781	1.025378108	1.035226978
-1930	0.773743435	1.025378108	1.03935974
-1932	0.770323931	1.025115325	1.041298049
-1934	0.767444602	1.025641026	1.044641989
-1936	0.768295616	1.025641026	1.043566546
-1938	0.769362923	1.025641026	1.038499934
-1940	0.772738069	1.025641026	1.038737867
-1942	0.770704787	1.025641026	1.035879799
-1944	0.770601594	1.025641026	1.037427425
-1946	0.769222782	1.025641026	1.030595864
-1948	0.766707024	1.025641026	1.030954778
-1950	0.763851563	1.026430588	1.029560374
-1952	0.763889083	1.026694045	1.033546252
-1954	0.766323486	1.026694045	1.034423007
-1956	0.766855958	1.026694045	1.028006612
-1958	0.768582246	1.026694045	1.021691113
-1960	0.770742799	1.02748523	1.020318015
-1962	0.770034934	1.027749229	1.019834297
-1964	0.77322272	1.027749229	1.022642313
-1966	0.772311795	1.027749229	1.019582636
-1968	0.776091062	1.027749229	1.015442661
-1970	0.774522397	1.028542042	1.013555577
-1972	0.779362879	1.028542042	1.007854466
-1974	0.779795559	1.028013364	1.007693016
-1976	0.780394921	1.02960103	1.005762082
-1978	0.77368798	1.029866117	1.002620399
-1980	0.772851547	1.029866117	1.000423625
-1982	0.773465772	1.029866117	0.995290023
-1984	0.778855884	1.030131342	0.997624065
-1986	0.783603689	1.030927835	0.992741661
-1988	0.783375781	1.030927835	0.993046209
-1990	0.783564421	1.031193607	0.983158714
-1992	0.782101294	1.032791118	0.980755631
-1994	0.778258065	1.033057851	0.976247147
-1996	0.776219515	1.032791118	0.977745332
-1998	0.776661934	1.032791118	0.979427982
-2000	0.778749489	1.033057851	0.976190196
-2002		1.034126163	
-2004		1.035196687	
-2006		1.035196687	
-2008		1.036001036	
-2010		1.03626943	
-2012		1.037075447	
-2014		1.037344398	
-2016		1.038152089	
-2018		1.039230969	
-2020		1.03950104	
-2022		1.03977125	
-2024		1.041124414	
-2026		1.04139547	
-2028		1.042481105	
-2030		1.042752868	
-2032		1.043296818	
-2034		1.043569006	
-2036		1.044113808	
-2038		1.044932079	
-2040		1.045751634	
-2042		1.045478306	
-2044		1.047120419	
-2046		1.047943411	
-2048		1.047943411	
-2050		1.048767698	
-2052		1.048218029	
-2054		1.048218029	
-2056		1.049868766	
-2058		1.050420168	
-2060		1.050420168	
-2062		1.050420168	
-2064		1.050972149	
-2066		1.052077854	
-2068		1.052631579	
-2070		1.053185887	
-2072		1.052631579	
-2074		1.052631579	
-2076		1.05374078	
-2078		1.054852321	
-2080		1.054852321	
-2082		1.055130572	
-2084		1.055408971	
-2086		1.056524036	
-2088		1.056245049	
-2090		1.057082452	
-2092		1.057082452	
-2094		1.057082452	
-2096		1.058201058	
-2098		1.059322034	
-2100		1.059041567	
-2102		1.059602649	
-2104		1.059883413	
-2106		1.060164325	
-2108		1.061289467	
-2110		1.061289467	
-2112		1.061571125	
-2114		1.060726598	
-2116		1.062981664	
-2118		1.063264221	
-2120		1.063264221	
-2122		1.063829787	
-2124		1.064112796	
-2126		1.064679265	
-2128		1.065814015	
-2130		1.066951187	
-2132		1.067235859	
-2134		1.067235859	
-2136		1.067235859	
-2138		1.066666667	
-2140		1.066666667	
-2142		1.065814015	
-2144		1.065814015	
-2146		1.064679265	
-2148		1.064112796	
-2150		1.064395955	
-2152		1.064395955	
-2154		1.062699256	
-2156		1.061852933	
-2158		1.060445387	
-2160		1.060164325	
-2162		1.059322034	
-2164		1.05764146	
-2166		1.055687516	
-2168		1.054574216	
-2170		1.05374078	
-2172		1.052631579	
-2174		1.051248357	
-2176		1.050420168	
-2178		1.050420168	
-2180		1.049317943	
-2182		1.047943411	
-2184		1.047120419	
-2186		1.046298718	
-2188		1.045751634	
-2190		1.044113808	
-2192		1.043841336	
-2194		1.043569006	
-2196		1.042752868	
-2198		1.042481105	
-2200		1.04139547	
-2202		1.040582726	
-2204		1.040041602	
-2206		1.04139547	
-2208		1.04139547	
-2210		1.040582726	
-2212		1.040582726	
-2214		1.040312094	
-2216		1.039230969	
-2218		1.038691249	
-2220		1.03950104	
-2222		1.03950104	
-2224		1.03950104	
-2226		1.038691249	
-2228		1.038691249	
-2230		1.039230969	
-2232		1.038421599	
-2234		1.038961039	
-2236		1.040041602	
-2238		1.040582726	
-2240		1.040582726	
-2242		1.040582726	
-2244		1.040582726	
-2246		1.04139547	
-2248		1.041666667	
-2250		1.041124414	
-2252		1.040582726	
-2254		1.040582726	
-2256		1.042752868	
-2258		1.042481105	
-2260		1.041938005	
-2262		1.041938005	
-2264		1.043296818	
-2266		1.042752868	
-2268		1.043024772	
-2270		1.043841336	
-2272		1.044386423	
-2274		1.043569006	
-2276		1.044386423	
-2278		1.045751634	
-2280		1.045751634	
-2282		1.045751634	
-2284		1.046298718	
-2286		1.046572475	
-2288		1.046572475	
-2290		1.047120419	
-2292		1.048492792	
-2294		1.048218029	
-2296		1.048492792	
-2298		1.049042748	
-2300		1.051248357	
-2302		1.050972149	
-2304		1.049868766	
-2306		1.051524711	
-2308		1.052077854	
-2310		1.050696086	
-2312		1.052354644	
-2314		1.05180121	
-2316		1.054852321	
-2318		1.055408971	
-2320		1.055130572	
-2322		1.055966209	
-2324		1.055408971	
-2326		1.055130572	
-2328		1.057082452	
-2330		1.058201058	
-2332		1.058761249	
-2334		1.059041567	
-2336		1.060445387	
-2338		1.061571125	
-2340		1.062134891	
-2342		1.061289467	
-2344		1.060726598	
-2346		1.061852933	
-2348		1.062416999	
-2350		1.063264221	
-2352		1.062699256	
-2354		1.064395955	
-2356		1.063829787	
-2358		1.065530101	
-2360		1.066098081	
-2362		1.065246338	
-2364		1.065530101	
-2366		1.066098081	
-2368		1.066951187	
-2370		1.065530101	
-2372		1.066098081	
-2374		1.067805659	
-2376		1.066666667	
-2378		1.066098081	
-2380		1.066382298	
-2382		1.065814015	
-2384		1.066666667	
-2386		1.069232825	
-2388		1.067520683	
-2390		1.068090788	
-2392		1.068947087	
-2394		1.068661501	
-2396		1.069232825	
-2398		1.067520683	
-2400		1.067235859	
-2402		1.068090788	
-2404		1.068661501	
-2406		1.069518717	
-2408		1.069804761	
-2410		1.067520683	
-2412		1.068947087	
-2414		1.071524243	
-2416		1.071237279	
-2418		1.069518717	
-2420		1.069232825	
-2422		1.068090788	
-2424		1.069518717	
-2426		1.069804761	
-2428		1.070377308	
-2430		1.068090788	
-2432		1.069518717	
-2434		1.071237279	
-2436		1.070377308	
-2438		1.070950469	
-2440		1.070377308	
-2442		1.070090958	
-2444		1.069232825	
-2446		1.068947087	
-2448		1.067520683	
-2450		1.066951187	
-2452		1.067235859	
-2454		1.070377308	
-2456		1.069804761	
-2458		1.069232825	
-2460		1.070090958	
-2462		1.069518717	
-2464		1.066951187	
-2466		1.068661501	
-2468		1.067520683	
-2470		1.066951187	
-2472		1.069232825	
-2474		1.069518717	
-2476		1.070090958	
-2478		1.069232825	
-2480		1.071811361	
-2482		1.071524243	
-2484		1.070377308	
-2486		1.071524243	
-2488		1.071811361	
-2490		1.070377308	
-2492		1.070090958	
-2494		1.070950469	
-2496		1.073537305	
-2498		1.075557946	
-2500		1.067615658	
+label	Reflectance (specular) - 800	Reflectance (specular) - 875	Reflectance (diffuse)	Transmittance (diffuse)
+details	grating 800nm, detector 900nm	grating 875nm, detector 875nm	Inverse of certified Spectralon	grating 875nm, detector 875nm
+Wavelength [nm]	instr resp R_spec 800	instr resp R_spec 875	instr resp R_diff	instr resp T_diff
+200	0.98	0.98	inf	inf
+202	0.98	0.98		
+204	0.98	0.98		
+206	0.98	0.98		
+208	0.98	0.98		
+210	0.98	0.98		
+212	0.98	0.98		
+214	0.98	0.98		
+216	0.98	0.98		
+218	0.98	0.98		
+220	0.98	0.98		
+222	0.98	0.98		
+224	0.98	0.98		
+226	0.98	0.98		
+228	0.98	0.98		
+230	0.98	0.98		
+232	0.98	0.98		
+234	0.98	0.98		
+236	0.98	0.98		
+238	0.98	0.98		
+240	0.98	0.98		
+242	0.98	0.98		
+244	0.98	0.98		
+246	0.98	0.98		
+248	0.98	0.98		
+250	0.98	0.98	1.058948112	
+252	0.98	0.98	1.05764146	
+254	0.98	0.98	1.05764146	
+256	0.98	0.98	1.056245049	
+258	0.98	0.98	1.055966209	
+260	0.98	0.98	1.05374078	
+262	0.98	0.98	1.052077854	
+264	0.98	0.98	1.049593283	
+266	0.98	0.98	1.049042748	
+268	0.98	0.98	1.047668937	
+270	0.98	0.98	1.047120419	
+272	0.98	0.98	1.046846375	
+274	0.98	0.98	1.044932079	
+276	0.98	0.98	1.04465918	
+278	0.98	0.98	1.043024772	
+280	0.98	0.98	1.042209484	
+282	0.98	0.98	1.041124414	
+284	0.98	0.98	1.037882719	
+286	0.98	0.98	1.038691249	
+288	0.98	0.98	1.035196687	
+290	0.98	0.98	1.034661148	
+292	0.98	0.98	1.033324722	
+294	0.98	0.98	1.032258065	
+296	0.98	0.98	1.030131342	
+298	0.98	0.98	1.02960103	
+300	0.979306776	0.979306776	1.028542042	0.973058113
+302	0.980254025	0.980254025	1.028013364	0.972802941
+304	0.980363806	0.980363806	1.028013364	0.972386036
+306	0.980298122	0.980298122	1.026957638	0.970648845
+308	0.979456232	0.979456232	1.026694045	0.969830937
+310	0.979252083	0.979252083	1.026167265	0.969316126
+312	0.978289444	0.978289444	1.025904078	0.968524256
+314	0.979096431	0.979096431	1.024327785	0.967501292
+316	0.978467785	0.978467785	1.02380343	0.96619551
+318	0.977547102	0.977547102	1.02223358	0.965159017
+320	0.976980231	0.976980231	1.02223358	0.964102198
+322	0.97677353	0.97677353	1.020929045	0.963848068
+324	0.976236432	0.976236432	1.020668538	0.962571366
+326	0.975652869	0.975652869	1.020408163	0.962634891
+328	0.975216651	0.975216651	1.020929045	0.961627938
+330	0.975168728	0.975168728	1.019887812	0.961424961
+332	0.974373142	0.974373142	1.018589254	0.960518045
+334	0.97417624	0.97417624	1.01910828	0.959897917
+336	0.973651929	0.973651929	1.017811705	0.958889526
+338	0.973365514	0.973365514	1.018329939	0.958730818
+340	0.974008368	0.974008368	1.017293998	0.957765845
+342	0.973712669	0.973712669	1.017293998	0.957348724
+344	0.973794841	0.973794841	1.018589254	0.95625749
+346	0.974289877	0.974289877	1.016518424	0.955506952
+348	0.974080662	0.974080662	1.016776817	0.955191287
+350	0.973904702	0.973904702	1.016260163	0.954670373
+352	0.973676366	0.973676366	1.016260163	0.9540068
+354	0.973689266	0.973689266	1.016260163	0.953615741
+356	0.973758966	0.973758966	1.015486164	0.953184184
+358	0.974381913	0.974381913	1.016518424	0.952923738
+360	0.974203358	0.974203358	1.015744033	0.952854137
+362	0.973510859	0.973510859	1.016002032	0.952396259
+364	0.972584076	0.972584076	1.015228426	0.952020192
+366	0.973027163	0.973027163	1.014455998	0.951058938
+368	0.97310342	0.97310342	1.013684744	0.950496731
+370	0.97324216	0.97324216	1.014198783	0.950227782
+372	0.973019456	0.973019456	1.014713343	0.949214841
+374	0.97269136	0.97269136	1.013684744	0.948832576
+376	0.972504757	0.972504757	1.014198783	0.948894033
+378	0.972250436	0.972250436	1.013941698	0.948105292
+380	0.972502777	0.972502777	1.013941698	0.947934329
+382	0.972552688	0.972552688	1.014198783	0.947813533
+384	0.972779111	0.972779111	1.013171226	0.947645277
+386	0.972540816	0.972540816	1.012401924	0.946556139
+388	0.972507776	0.972507776	1.013171226	0.946044881
+390	0.972822685	0.972822685	1.012401924	0.945740318
+392	0.972979767	0.972979767	1.012145749	0.945569365
+394	0.973460822	0.973460822	1.011633789	0.945301685
+396	0.974021404	0.974021404	1.010866818	0.944624688
+398	0.973954354	0.973954354	1.011122346	0.944572578
+400	0.974199152	0.974199152	1.011633789	0.944333124
+402	0.974061755	0.974061755	1.011122346	0.943945789
+404	0.973929158	0.973929158	1.011122346	0.943718215
+406	0.973928281	0.973928281	1.01061142	0.943392663
+408	0.974165857	0.974165857	1.010866818	0.943147816
+410	0.974210794	0.974210794	1.010356151	0.942971415
+412	0.974378002	0.974378002	1.011122346	0.942695028
+414	0.974813239	0.974813239	1.011122346	0.942481243
+416	0.974947192	0.974947192	1.011122346	0.942217776
+418	0.975130464	0.975130464	1.011122346	0.941818467
+420	0.975277202	0.975277202	1.010356151	0.941609025
+422	0.975404435	0.975404435	1.010356151	0.941432454
+424	0.975104002	0.975104002	1.011889704	0.940805077
+426	0.975355291	0.975355291	1.011122346	0.940262911
+428	0.975328843	0.975328843	1.01010101	0.940238821
+430	0.975660965	0.975660965	1.010866818	0.939834446
+432	0.975981751	0.975981751	1.010866818	0.939351032
+434	0.976064675	0.976064675	1.01010101	0.939276213
+436	0.975933491	0.975933491	1.010356151	0.938984203
+438	0.976088884	0.976088884	1.011122346	0.938432619
+440	0.976141753	0.976141753	1.01061142	0.937816363
+442	0.976230918	0.976230918	1.010356151	0.937624221
+444	0.97633349	0.97633349	1.01010101	0.937283457
+446	0.976217909	0.976217909	1.01010101	0.936891708
+448	0.976228214	0.976228214	1.010356151	0.936455608
+450	0.976255699	0.976255699	1.010866818	0.935861171
+452	0.976511923	0.976511923	1.010866818	0.935460636
+454	0.976265982	0.976265982	1.010356151	0.935004569
+456	0.976224556	0.976224556	1.01010101	0.934761593
+458	0.976152274	0.976152274	1.01010101	0.934500126
+460	0.976155083	0.976155083	1.010866818	0.934090931
+462	0.976037553	0.976037553	1.011122346	0.933656913
+464	0.975947949	0.975947949	1.011122346	0.933305555
+466	0.976145299	0.976145299	1.010866818	0.933007938
+468	0.976177796	0.976177796	1.01010101	0.932752394
+470	0.976279334	0.976279334	1.01010101	0.932281329
+472	0.976572568	0.976572568	1.01061142	0.931715245
+474	0.976979018	0.976979018	1.009591116	0.930759289
+476	0.977072171	0.977072171	1.01010101	0.930567254
+478	0.977112639	0.977112639	1.009591116	0.930163697
+480	0.97732022	0.97732022	1.009845998	0.930216005
+482	0.977127377	0.977127377	1.008827238	0.92969041
+484	0.976995895	0.976995895	1.009081736	0.929068932
+486	0.976673352	0.976673352	1.01010101	0.929036034
+488	0.976713698	0.976713698	1.009336361	0.928413735
+490	0.976560122	0.976560122	1.009336361	0.928385081
+492	0.976545978	0.976545978	1.009845998	0.927733401
+494	0.976450963	0.976450963	1.009081736	0.92744909
+496	0.976307425	0.976307425	1.009081736	0.927148305
+498	0.97625835	0.97625835	1.009591116	0.927005398
+500	0.976175016	0.976175016	1.010356151	0.926397888
+502	0.975837786	0.975837786	1.009591116	0.926550623
+504	0.976120221	0.976120221	1.009845998	0.926032048
+506	0.976043568	0.976043568	1.008827238	0.925845922
+508	0.976185699	0.976185699	1.008827238	0.925364563
+510	0.975871515	0.975871515	1.009591116	0.925103155
+512	0.975435103	0.975435103	1.009591116	0.924395948
+514	0.975593576	0.975593576	1.009081736	0.924165218
+516	0.975453996	0.975453996	1.01010101	0.923831198
+518	0.975434635	0.975434635	1.010356151	0.923434405
+520	0.975219592	0.975219592	1.01010101	0.923569623
+522	0.975282119	0.975282119	1.009845998	0.923105415
+524	0.975200803	0.975200803	1.009845998	0.92289682
+526	0.975547828	0.975547828	1.009591116	0.922751759
+528	0.975487653	0.975487653	1.009591116	0.922403069
+530	0.97506907	0.97506907	1.009336361	0.922146626
+532	0.974693943	0.974693943	1.009081736	0.921802924
+534	0.974382622	0.974382622	1.009336361	0.921407177
+536	0.974658791	0.974658791	1.01010101	0.921420775
+538	0.974379855	0.974379855	1.009336361	0.921137126
+540	0.974327356	0.974327356	1.009845998	0.92081974
+542	0.974119663	0.974119663	1.009845998	0.920523201
+544	0.974200455	0.974200455	1.009845998	0.919902719
+546	0.974172864	0.974172864	1.01010101	0.919957772
+548	0.974042016	0.974042016	1.01010101	0.919417579
+550	0.973906959	0.973906959	1.009336361	0.919271441
+552	0.97397761	0.97397761	1.009081736	0.919052073
+554	0.973934673	0.973934673	1.009591116	0.919072479
+556	0.973942377	0.973942377	1.009081736	0.9187057
+558	0.973633127	0.973633127	1.009336361	0.91885406
+560	0.973635096	0.973635096	1.01010101	0.918539581
+562	0.973473984	0.973473984	1.01010101	0.918047165
+564	0.973228943	0.973228943	1.009336361	0.917787291
+566	0.973021622	0.973021622	1.009845998	0.917760579
+568	0.97325266	0.97325266	1.009845998	0.917644126
+570	0.973400748	0.973400748	1.009845998	0.917117384
+572	0.97336744	0.97336744	1.01010101	0.917097953
+574	0.973403821	0.973403821	1.009845998	0.916769399
+576	0.97361869	0.97361869	1.009336361	0.916585482
+578	0.973759485	0.973759485	1.009845998	0.916661536
+580	0.973641801	0.973641801	1.008827238	0.916223232
+582	0.973643846	0.973643846	1.009081736	0.916158275
+584	0.973797992	0.973797992	1.010866818	0.915961964
+586	0.97398689	0.97398689	1.010356151	0.9153424
+588	0.974023163	0.974023163	1.01010101	0.915347078
+590	0.974262867	0.974262867	1.009845998	0.915222701
+592	0.974224785	0.974224785	1.009081736	0.914874175
+594	0.97428458	0.97428458	1.009336361	0.914614951
+596	0.97427531	0.97427531	1.01010101	0.914427768
+598	0.974296178	0.974296178	1.01010101	0.914315672
+600	0.973290155	0.973290155	1.01010101	0.914300538
+602	0.97333706	0.97333706	1.01010101	0.913920365
+604	0.973395189	0.973395189	1.009845998	0.9135752
+606	0.97347264	0.97347264	1.009845998	0.913223869
+608	0.973438654	0.973438654	1.010866818	0.913179675
+610	0.973422114	0.973422114	1.010356151	0.913362452
+612	0.973227339	0.973227339	1.01010101	0.913123716
+614	0.973532049	0.973532049	1.01061142	0.912950901
+616	0.973715264	0.973715264	1.009845998	0.912875184
+618	0.973932773	0.973932773	1.009845998	0.912327553
+620	0.973975754	0.973975754	1.01010101	0.912074441
+622	0.974096023	0.974096023	1.01010101	0.911953044
+624	0.974228947	0.974228947	1.01061142	0.911604087
+626	0.974446466	0.974446466	1.01010101	0.911294365
+628	0.974450118	0.974450118	1.01010101	0.911127461
+630	0.974637698	0.974637698	1.01010101	0.911077032
+632	0.97489277	0.97489277	1.01010101	0.910889952
+634	0.97531931	0.97531931	1.010356151	0.910516315
+636	0.975671189	0.975671189	1.010356151	0.910285531
+638	0.975919863	0.975919863	1.01010101	0.910451528
+640	0.976115187	0.976115187	1.01010101	0.910076824
+642	0.97628836	0.97628836	1.01010101	0.909815933
+644	0.97666621	0.97666621	1.010356151	0.909618293
+646	0.976963716	0.976963716	1.010356151	0.909231668
+648	0.97750896	0.97750896	1.01010101	0.909267791
+650	0.977706984	0.977706984	1.010866818	0.909198045
+652	0.977758878	0.977758878	1.010356151	0.90846783
+654	0.977903541	0.977903541	1.01010101	0.908542928
+656	0.978124702	0.978124702	1.01010101	0.908239437
+658	0.978436414	0.978436414	1.010866818	0.907863492
+660	0.978662823	0.978662823	1.010356151	0.907814375
+662	0.978873169	0.978873169	1.01010101	0.907484711
+664	0.979344981	0.979344981	1.01010101	0.907278018
+666	0.97990398	0.97990398	1.01010101	0.90726233
+668	0.980494499	0.980494499	1.01010101	0.907028883
+670	0.981067692	0.981067692	1.010356151	0.907142884
+672	0.981301247	0.981301247	1.010356151	0.906926253
+674	0.981913351	0.981913351	1.01010101	0.906585253
+676	0.982381945	0.982381945	1.01010101	0.906767269
+678	0.982875219	0.982875219	1.01010101	0.906774699
+680	0.983068435	0.983068435	1.009845998	0.90655182
+682	0.983183309	0.983183309	1.010356151	0.90627955
+684	0.983439632	0.983439632	1.009591116	0.906315601
+686	0.983484138	0.983484138	1.01010101	0.905443883
+688	0.983344733	0.983344733	1.01061142	0.905729926
+690	0.983479289	0.983479289	1.009845998	0.905530463
+692	0.984058217	0.984058217	1.01010101	0.905122156
+694	0.984600965	0.984600965	1.010356151	0.904509859
+696	0.984890648	0.984890648	1.009845998	0.904547991
+698	0.985268151	0.985268151	1.009845998	0.904611762
+700	0.985453081	0.985453081	1.009591116	0.904401429
+702	0.98615885	0.98615885	1.010356151	0.904621676
+704	0.986387619	0.986387619	1.009081736	0.904308853
+706	0.986635076	0.986635076	1.009845998	0.903840024
+708	0.986667904	0.986667904	1.01061142	0.903460833
+710	0.987191338	0.987191338	1.009336361	0.902931084
+712	0.987604775	0.987604775	1.009336361	0.902827455
+714	0.987909849	0.987909849	1.009845998	0.902895246
+716	0.988588868	0.988588868	1.009845998	0.902663905
+718	0.98892485	0.98892485	1.01010101	0.90216506
+720	0.989009441	0.989009441	1.01010101	0.901640517
+722	0.989216702	0.989216702	1.01010101	0.901491941
+724	0.989644304	0.989644304	1.009336361	0.901480383
+726	0.990180659	0.990180659	1.009336361	0.901264173
+728	0.990613617	0.990613617	1.009336361	0.901370335
+730	0.991152573	0.991152573	1.009336361	0.901010897
+732	0.991389133	0.991389133	1.009845998	0.900588435
+734	0.991615915	0.991615915	1.009081736	0.90032622
+736	0.992026142	0.992026142	1.009336361	0.900629584
+738	0.992427043	0.992427043	1.009336361	0.900304209
+740	0.992980645	0.992980645	1.009336361	0.900487652
+742	0.992978978	0.992978978	1.01010101	0.900157304
+744	0.99303011	0.99303011	1.010356151	0.899958331
+746	0.993630702	0.993630702	1.01010101	0.899914978
+748	0.993892535	0.993892535	1.009845998	0.898931243
+750	0.99434508	0.99434508	1.009591116	0.89840517
+752	0.994559502	0.994559502	1.009336361	0.898301368
+754	0.995375897	0.995375897	1.009845998	0.898463654
+756	0.995631374	0.995631374	1.01010101	0.898439725
+758	0.995898559	0.995898559	1.01010101	0.898396394
+760	0.996161498	0.996161498	1.01010101	0.897622295
+762	0.996267277	0.996267277	1.01010101	0.897491724
+764	0.996498003	0.996498003	1.01010101	0.897486469
+766	0.996592985	0.996592985	1.01010101	0.897435433
+768	0.99683387	0.99683387	1.009336361	0.89776356
+770	0.997144996	0.997144996	1.009845998	0.897479229
+772	0.99746543	0.99746543	1.009845998	0.897172776
+774	0.997973071	0.997973071	1.009336361	0.896883555
+776	0.998422315	0.998422315	1.009591116	0.896263504
+778	0.998887309	0.998887309	1.009081736	0.896253084
+780	0.999112063	0.999112063	1.01010101	0.895812578
+782	0.999560545	0.999560545	1.010866818	0.896114332
+784	1.000374994	1.000374994	1.010356151	0.896008532
+786	1.000989269	1.000989269	1.009336361	0.895862166
+788	1.001362848	1.001362848	1.009081736	0.896146935
+790	1.001393985	1.001393985	1.009845998	0.895367817
+792	1.001735981	1.001735981	1.009336361	0.894929053
+794	1.001824836	1.001824836	1.009845998	0.895148454
+796	1.002278694	1.002278694	1.01010101	0.894874213
+798	1.002428656	1.002428656	1.01010101	0.895335587
+800	0.983114082	1.003114082	1.01010101	0.89498965
+802	0.978041905	1.003041905	1.009845998	0.894905982
+804	0.972970151	1.002970151	1.01010101	0.894126192
+806	0.967026671	1.002026671	1.010356151	0.893685943
+808	0.964638455	1.002138455	1.009336361	0.893488237
+810	0.961936552	1.001936552	1.009336361	0.893856355
+812	0.962456133	1.002456133	1.01061142	0.893404324
+814	0.962441674	1.002441674	1.01010101	0.893531392
+816	0.962433906	1.002433906	1.009845998	0.893353777
+818	0.961627122	1.001627122	1.01010101	0.89337616
+820	0.961053795	1.001053795	1.009591116	0.892969675
+822	0.960776396	1.000776396	1.009591116	0.892073128
+824	0.960206797	1.000206797	1.008318629	0.892298369
+826	0.959723469	0.999723469	1.008827238	0.89211531
+828	0.959367212	0.999367212	1.009081736	0.892455054
+830	0.959206078	0.999206078	1.009591116	0.892008384
+832	0.959079795	0.999079795	1.009845998	0.891050265
+834	0.958589016	0.998589016	1.009845998	0.890447072
+836	0.958398224	0.998398224	1.009845998	0.889800061
+838	0.95724642	0.99724642	1.009845998	0.890762204
+840	0.957670015	0.996670015	1.010356151	0.890364839
+842	0.957502024	0.995502024	1.01010101	0.890925018
+844	0.957581596	0.994581596	1.009845998	0.89060856
+846	0.957582114	0.993582114	1.008318629	0.890639624
+848	0.957829874	0.992829874	1.009336361	0.890093866
+850	0.959447149	0.993447149	1.008572869	0.889697495
+852	0.959584305	0.992584305	1.01010101	0.889536776
+854	0.959683076	0.991683076	1.010356151	0.888367932
+856	0.958692147	0.989692147	1.01010101	0.888340483
+858	0.95799241	0.98799241	1.011122346	0.888319891
+860	0.956686539	0.986686539	1.01061142	0.888821884
+862	0.958072974	0.988072974	1.010356151	0.889359959
+864	0.958630345	0.988630345	1.01010101	0.89021472
+866	0.95627489	0.98627489	1.009845998	0.888045484
+868	0.955519587	0.985519587	1.01061142	0.888432091
+870	0.956295629	0.986295629	1.009591116	0.889855277
+872	0.959246984	0.989246984	1.01061142	0.88681099
+874	0.95749359	0.97749359	1.01010101	0.885289392
+876	0.955137393	0.965137393	1.01010101	0.884138111
+878	0.953251589	0.953251589	1.01010101	0.88301684
+880	0.952137826	0.952137826	1.01010101	0.882677279
+882	0.952853274	0.952853274	1.01010101	0.882778528
+884	0.95357345	0.95357345	1.01010101	0.883441222
+886	0.953258354	0.953258354	1.010866818	0.883028014
+888	0.95394444	0.95394444	1.01061142	0.883097165
+890	0.956530809	0.956530809	1.010356151	0.881661949
+892	0.959896358	0.959896358	1.01061142	0.883195045
+894	0.958531681	0.958531681	1.01010101	0.882705718
+896	0.954846639	0.954846639	1.010866818	0.885017895
+898	0.954650457	0.954650457	1.010866818	0.881871002
+900	0.953890209	0.953890209	1.01010101	0.882319321
+902	0.954535722	0.954535722	1.01010101	0.846158589
+904	0.954067175	0.954067175	1.01010101	0.847090201
+906	0.954608098	0.954608098	1.01010101	0.845836119
+908	0.956337928	0.956337928	1.01010101	0.846387601
+910	0.954388658	0.954388658	1.01010101	0.84399581
+912	0.954339347	0.954339347	1.01010101	0.844099539
+914	0.952914973	0.952914973	1.01010101	0.845257718
+916	0.952971004	0.952971004	1.01010101	0.846583259
+918	0.953513235	0.953513235	1.010356151	0.846882445
+920	0.952314808	0.952314808	1.010356151	0.84661938
+922	0.952211611	0.952211611	1.01010101	0.845969565
+924	0.950966826	0.950966826	1.01010101	0.84488876
+926	0.952117441	0.952117441	1.01010101	0.844575528
+928	0.951899291	0.951899291	1.01061142	0.844852823
+930	0.95322173	0.95322173	1.01061142	0.846207684
+932	0.9525647	0.9525647	1.01010101	0.8455751
+934	0.951815061	0.951815061	1.01010101	0.845927326
+936	0.949743479	0.949743479	1.01010101	0.845545428
+938	0.950095254	0.950095254	1.01010101	0.845484234
+940	0.951475957	0.951475957	1.01010101	0.844908501
+942	0.952304614	0.952304614	1.01010101	0.844991646
+944	0.950366194	0.950366194	1.01010101	0.845837972
+946	0.949517074	0.949517074	1.01010101	0.845812011
+948	0.949881008	0.949881008	1.01010101	0.84637876
+950	0.94948966	0.94948966	1.010356151	0.84574774
+952	0.948022202	0.948022202	1.010356151	0.845186372
+954	0.947158184	0.947158184	1.01010101	0.844510443
+956	0.949159857	0.949159857	1.01010101	0.845216885
+958	0.949093164	0.949093164	1.01010101	0.845367505
+960	0.949419144	0.949419144	1.01010101	0.844922866
+962	0.948183578	0.948183578	1.01010101	0.84435922
+964	0.948583871	0.948583871	1.01010101	0.844573417
+966	0.948076244	0.948076244	1.01010101	0.844923286
+968	0.947875378	0.947875378	1.01010101	0.84516363
+970	0.946946474	0.946946474	1.01010101	0.844800488
+972	0.946898077	0.946898077	1.01010101	0.844350984
+974	0.947096085	0.947096085	1.01010101	0.844206156
+976	0.947307217	0.947307217	1.01010101	0.844011883
+978	0.946717623	0.946717623	1.01010101	0.843773345
+980	0.946125551	0.946125551	1.01010101	0.843433281
+982	0.946163126	0.946163126	1.01010101	0.843356001
+984	0.946037353	0.946037353	1.01010101	0.843472322
+986	0.945429972	0.945429972	1.01010101	0.843079026
+988	0.94617874	0.94617874	1.01010101	0.843161533
+990	0.94688603	0.94688603	1.01010101	0.842796016
+992	0.947736611	0.947736611	1.01010101	0.84244365
+994	0.946785278	0.946785278	1.01010101	0.842255338
+996	0.945465379	0.945465379	1.01010101	0.841847371
+998	0.94472749	0.94472749	1.01010101	0.841865332
+1000	0.94512785	0.94512785	1.01010101	0.841513207
+1002	0.945837551	0.945837551	1.01010101	0.841643039
+1004	0.945835392	0.945835392	1.01010101	0.841024995
+1006	0.944736738	0.944736738	1.01010101	0.840817213
+1008	0.944089885	0.944089885	1.009591116	0.840712129
+1010	0.943342418	0.943342418	1.01010101	0.840951127
+1012	0.942823644	0.942823644	1.01010101	0.840927912
+1014	0.942414407	0.942414407	1.01010101	0.840140048
+1016	0.942432569	0.942432569	1.01010101	0.839952416
+1018	0.941701119	0.941701119	1.01010101	0.83932417
+1020	0.941342287	0.941342287	1.01010101	0.839883175
+1022	0.941334926	0.941334926	1.01010101	0.839445739
+1024	0.942285323	0.942285323	1.01010101	0.839465566
+1026	0.942565169	0.942565169	1.01010101	0.83858752
+1028	0.941932136	0.941932136	1.01010101	0.83818796
+1030	0.941479193	0.941479193	1.01010101	0.83775809
+1032	0.941138297	0.941138297	1.01010101	0.837624307
+1034	0.941295399	0.941295399	1.01010101	0.837667092
+1036	0.940820242	0.940820242	1.01010101	0.837406157
+1038	0.939957185	0.939957185	1.01010101	0.837094306
+1040	0.939276546	0.939276546	1.01010101	0.837052497
+1042	0.939246332	0.939246332	1.01010101	0.836930589
+1044	0.938799565	0.938799565	1.01010101	0.837198722
+1046	0.938889996	0.938889996	1.01010101	0.836471019
+1048	0.938905282	0.938905282	1.01010101	0.836299794
+1050	0.938979837	0.938979837	1.01010101	0.836113634
+1052	0.938307894	0.938307894	1.01010101	0.836302159
+1054	0.93789325	0.93789325	1.01010101	0.83643544
+1056	0.938054521	0.938054521	1.01010101	0.835603495
+1058	0.938324026	0.938324026	1.01010101	0.835374952
+1060	0.938130359	0.938130359	1.01010101	0.835109968
+1062	0.937422611	0.937422611	1.01010101	0.835645373
+1064	0.937390723	0.937390723	1.01010101	0.835650025
+1066	0.937330083	0.937330083	1.01010101	0.835627298
+1068	0.937259565	0.937259565	1.01010101	0.835220756
+1070	0.936709988	0.936709988	1.01010101	0.834760954
+1072	0.935997521	0.935997521	1.01010101	0.834374923
+1074	0.93620552	0.93620552	1.01010101	0.834208228
+1076	0.935706823	0.935706823	1.01010101	0.834291139
+1078	0.935321453	0.935321453	1.01010101	0.834174274
+1080	0.934553634	0.934553634	1.01010101	0.834337794
+1082	0.93519583	0.93519583	1.01010101	0.834319667
+1084	0.935203489	0.935203489	1.01010101	0.83405897
+1086	0.93483893	0.93483893	1.01010101	0.833431653
+1088	0.934286827	0.934286827	1.01010101	0.833573667
+1090	0.933879776	0.933879776	1.01010101	0.83362693
+1092	0.934134093	0.934134093	1.01010101	0.833830219
+1094	0.933749861	0.933749861	1.01010101	0.832911624
+1096	0.933444732	0.933444732	1.01010101	0.83291726
+1098	0.933175163	0.933175163	1.01010101	0.832349403
+1100	0.932930066	0.932930066	1.01010101	0.83276705
+1102	0.932966606	0.932966606	1.009845998	0.832382411
+1104	0.932725392	0.932725392	1.009845998	0.832567798
+1106	0.932370735	0.932370735	1.01010101	0.832105448
+1108	0.932243547	0.932243547	1.01010101	0.832276187
+1110	0.932247005	0.932247005	1.01010101	0.832071018
+1112	0.932125373	0.932125373	1.009591116	0.832475638
+1114	0.931832692	0.931832692	1.01010101	0.832157966
+1116	0.931361385	0.931361385	1.01010101	0.831851653
+1118	0.931218813	0.931218813	1.01010101	0.832225232
+1120	0.930941404	0.930941404	1.01010101	0.831985827
+1122	0.930960827	0.930960827	1.01010101	0.832225585
+1124	0.9310834	0.9310834	1.01010101	0.831857773
+1126	0.931330265	0.931330265	1.01010101	0.831992279
+1128	0.931029328	0.931029328	1.01010101	0.831629732
+1130	0.930214922	0.930214922	1.01010101	0.831502973
+1132	0.929683441	0.929683441	1.01010101	0.831796164
+1134	0.92939552	0.92939552	1.01010101	0.831997946
+1136	0.929703351	0.929703351	1.01010101	0.831829607
+1138	0.929521516	0.929521516	1.009845998	0.83190451
+1140	0.929418928	0.929418928	1.009591116	0.832061042
+1142	0.928756465	0.928756465	1.009845998	0.832422887
+1144	0.928177989	0.928177989	1.01010101	0.832675383
+1146	0.927742414	0.927742414	1.01010101	0.833218306
+1148	0.92790494	0.92790494	1.01010101	0.833031418
+1150	0.92811716	0.92811716	1.01010101	0.833185262
+1152	0.928092571	0.928092571	1.01010101	0.833152201
+1154	0.92778277	0.92778277	1.01010101	0.83363238
+1156	0.927471373	0.927471373	1.01010101	0.83352956
+1158	0.926975384	0.926975384	1.01010101	0.833928343
+1160	0.926384189	0.926384189	1.01010101	0.833920679
+1162	0.925866781	0.925866781	1.01010101	0.834098302
+1164	0.925883732	0.925883732	1.01010101	0.834012787
+1166	0.925644034	0.925644034	1.01010101	0.833832602
+1168	0.925352207	0.925352207	1.01010101	0.833563606
+1170	0.924924585	0.924924585	1.01010101	0.833193652
+1172	0.924757843	0.924757843	1.01010101	0.833230648
+1174	0.924701336	0.924701336	1.01010101	0.833368493
+1176	0.924484808	0.924484808	1.010866818	0.833977257
+1178	0.924647031	0.924647031	1.011122346	0.83402272
+1180	0.924629478	0.924629478	1.011122346	0.8335478
+1182	0.924365471	0.924365471	1.011122346	0.833107072
+1184	0.923877829	0.923877829	1.011122346	0.832960663
+1186	0.923896388	0.923896388	1.011122346	0.833544654
+1188	0.923849686	0.923849686	1.011122346	0.833206583
+1190	0.923974426	0.923974426	1.011122346	0.833152282
+1192	0.923582307	0.923582307	1.011122346	0.833019225
+1194	0.922943904	0.922943904	1.011122346	0.832963503
+1196	0.922383454	0.922383454	1.011122346	0.8324976
+1198	0.921829981	0.921829981	1.011122346	0.832316793
+1200	0.922142953	0.922142953	1.011122346	0.832194924
+1202	0.921771437	0.921771437	1.011122346	0.831837165
+1204	0.92147279	0.92147279	1.011122346	0.831476889
+1206	0.921515517	0.921515517	1.011122346	0.831144801
+1208	0.921169773	0.921169773	1.011122346	0.831259118
+1210	0.920988298	0.920988298	1.011122346	0.831135818
+1212	0.920807055	0.920807055	1.011122346	0.831288214
+1214	0.921150671	0.921150671	1.011122346	0.831197178
+1216	0.921263868	0.921263868	1.011122346	0.831342497
+1218	0.920846329	0.920846329	1.011122346	0.831049379
+1220	0.920346789	0.920346789	1.011122346	0.831211774
+1222	0.919832733	0.919832733	1.011122346	0.83063925
+1224	0.919853196	0.919853196	1.011122346	0.830250875
+1226	0.919544037	0.919544037	1.011122346	0.829682721
+1228	0.91965569	0.91965569	1.011122346	0.829780915
+1230	0.919208112	0.919208112	1.011122346	0.829752247
+1232	0.918860455	0.918860455	1.011122346	0.829451015
+1234	0.918846123	0.918846123	1.011122346	0.828871017
+1236	0.918603282	0.918603282	1.011122346	0.828500421
+1238	0.91843669	0.91843669	1.011122346	0.828758345
+1240	0.917577436	0.917577436	1.011122346	0.82876556
+1242	0.916947283	0.916947283	1.011122346	0.828965612
+1244	0.916618106	0.916618106	1.011122346	0.828362768
+1246	0.916313856	0.916313856	1.011122346	0.827908879
+1248	0.916335156	0.916335156	1.011122346	0.828001254
+1250	0.916285732	0.916285732	1.011378003	0.827833255
+1252	0.91631095	0.91631095	1.011633789	0.827929181
+1254	0.916477322	0.916477322	1.011378003	0.827372406
+1256	0.915914482	0.915914482	1.011122346	0.827338578
+1258	0.915806065	0.915806065	1.011122346	0.827316515
+1260	0.91540327	0.91540327	1.011122346	0.827175818
+1262	0.915431562	0.915431562	1.011122346	0.826890223
+1264	0.915002961	0.915002961	1.011122346	0.826623004
+1266	0.91477211	0.91477211	1.011122346	0.826685506
+1268	0.914452489	0.914452489	1.011122346	0.826336892
+1270	0.914063721	0.914063721	1.011122346	0.82597297
+1272	0.913708589	0.913708589	1.011122346	0.825304373
+1274	0.913690673	0.913690673	1.011889704	0.825016272
+1276	0.913629279	0.913629279	1.012145749	0.825448977
+1278	0.913252394	0.913252394	1.012145749	0.825454546
+1280	0.912757912	0.912757912	1.012145749	0.825507538
+1282	0.912382687	0.912382687	1.012145749	0.825620097
+1284	0.91217059	0.91217059	1.012145749	0.825892867
+1286	0.911990936	0.911990936	1.012145749	0.826223658
+1288	0.911837404	0.911837404	1.012145749	0.825819688
+1290	0.911672535	0.911672535	1.012145749	0.82571117
+1292	0.911897346	0.911897346	1.012145749	0.825327391
+1294	0.911709215	0.911709215	1.012145749	0.825452217
+1296	0.91122819	0.91122819	1.012145749	0.825332768
+1298	0.910693851	0.910693851	1.012145749	0.825745727
+1300	0.91026291	0.91026291	1.012145749	0.826099084
+1302	0.909770748	0.909770748	1.012145749	0.82601242
+1304	0.909094548	0.909094548	1.012145749	0.825579753
+1306	0.908991491	0.908991491	1.012145749	0.825143942
+1308	0.908914832	0.908914832	1.012914662	0.825077574
+1310	0.909239529	0.909239529	1.012401924	0.825355645
+1312	0.908980924	0.908980924	1.012401924	0.825617251
+1314	0.908920125	0.908920125	1.012401924	0.826322204
+1316	0.908420861	0.908420861	1.012145749	0.826457248
+1318	0.908234776	0.908234776	1.012145749	0.826532096
+1320	0.90759312	0.90759312	1.012145749	0.826635361
+1322	0.90702255	0.90702255	1.012145749	0.826954451
+1324	0.906837988	0.906837988	1.012145749	0.827424102
+1326	0.906808862	0.906808862	1.012914662	0.828144311
+1328	0.906452796	0.906452796	1.013171226	0.828676768
+1330	0.906186148	0.906186148	1.013171226	0.828535469
+1332	0.906023314	0.906023314	1.013171226	0.828538411
+1334	0.906348212	0.906348212	1.013171226	0.828375654
+1336	0.905624975	0.905624975	1.013171226	0.82878674
+1338	0.905387274	0.905387274	1.013171226	0.828673718
+1340	0.90461709	0.90461709	1.013171226	0.828984811
+1342	0.904274118	0.904274118	1.01342792	0.829106172
+1344	0.90372978	0.90372978	1.01342792	0.82950556
+1346	0.903461881	0.903461881	1.013171226	0.82984633
+1348	0.902896317	0.902896317	1.01342792	0.83031408
+1350	0.902778672	0.902778672	1.01342792	0.830989176
+1352	0.901790574	0.901790574	1.01342792	0.831084019
+1354	0.901500192	0.901500192	1.013941698	0.831264409
+1356	0.900809285	0.900809285	1.013171226	0.831498549
+1358	0.900799723	0.900799723	1.01342792	0.83159813
+1360	0.899971078	0.899971078	1.01342792	0.831313888
+1362	0.89975355	0.89975355	1.013171226	0.83163851
+1364	0.899104731	0.899104731	1.013941698	0.832538079
+1366	0.899302369	0.899302369	1.014198783	0.832919681
+1368	0.898799494	0.898799494	1.014198783	0.83388811
+1370	0.898981831	0.898981831	1.014198783	0.834798434
+1372	0.899141683	0.899141683	1.014198783	0.836198791
+1374	0.898892104	0.898892104	1.01342792	0.837052275
+1376	0.898578348	0.898578348	1.013941698	0.837859423
+1378	0.897234239	0.897234239	1.013684744	0.839248795
+1380	0.896492752	0.896492752	1.013941698	0.84043997
+1382	0.895678655	0.895678655	1.013171226	0.842169059
+1384	0.895480571	0.895480571	1.013941698	0.844102419
+1386	0.894914455	0.894914455	1.014198783	0.845533773
+1388	0.894292225	0.894292225	1.014198783	0.846887932
+1390	0.893532897	0.893532897	1.014198783	0.847243043
+1392	0.893050656	0.893050656	1.014198783	0.848338105
+1394	0.892400983	0.892400983	1.014198783	0.849842142
+1396	0.89201948	0.89201948	1.014198783	0.851920987
+1398	0.891767461	0.891767461	1.014198783	0.853501497
+1400	0.891352533	0.891352533	1.014198783	0.855092127
+1402	0.8901854	0.8901854	1.014198783	0.856433671
+1404	0.889118016	0.889118016	1.014198783	0.857999611
+1406	0.88838302	0.88838302	1.014198783	0.860530137
+1408	0.887919214	0.887919214	1.014198783	0.862670294
+1410	0.886509755	0.886509755	1.014198783	0.865341707
+1412	0.885320363	0.885320363	1.013941698	0.866230398
+1414	0.884648843	0.884648843	1.013941698	0.867124316
+1416	0.884609073	0.884609073	1.014198783	0.868325732
+1418	0.884419554	0.884419554	1.014198783	0.870030762
+1420	0.883291118	0.883291118	1.014198783	0.871305776
+1422	0.88235113	0.88235113	1.014198783	0.871550717
+1424	0.881653059	0.881653059	1.013941698	0.872104063
+1426	0.881386109	0.881386109	1.012658228	0.872967275
+1428	0.880821655	0.880821655	1.013171226	0.874573076
+1430	0.879743147	0.879743147	1.013171226	0.874684308
+1432	0.878944266	0.878944266	1.013171226	0.875583109
+1434	0.877936261	0.877936261	1.013171226	0.875588612
+1436	0.877156268	0.877156268	1.013171226	0.876217235
+1438	0.876449487	0.876449487	1.013171226	0.875635499
+1440	0.876364328	0.876364328	1.013171226	0.876361288
+1442	0.876076023	0.876076023	1.013171226	0.876287223
+1444	0.875538641	0.875538641	1.013171226	0.875872643
+1446	0.874994065	0.874994065	1.013171226	0.876315401
+1448	0.874960432	0.874960432	1.013171226	0.876896449
+1450	0.874594265	0.874594265	1.013171226	0.87714913
+1452	0.874421108	0.874421108	1.013171226	0.875819753
+1454	0.873544788	0.873544788	1.013171226	0.875558084
+1456	0.873094177	0.873094177	1.013171226	0.87545166
+1458	0.872236716	0.872236716	1.013171226	0.875331354
+1460	0.871905816	0.871905816	1.013171226	0.874942251
+1462	0.872118182	0.872118182	1.013171226	0.874524749
+1464	0.871866748	0.871866748	1.013171226	0.874515509
+1466	0.87152167	0.87152167	1.013171226	0.874009722
+1468	0.871304813	0.871304813	1.013171226	0.873010467
+1470	0.871463244	0.871463244	1.013171226	0.872125678
+1472	0.871874885	0.871874885	1.013171226	0.871122642
+1474	0.87090128	0.87090128	1.013171226	0.870598422
+1476	0.8709993	0.8709993	1.013171226	0.869974448
+1478	0.870905234	0.870905234	1.013171226	0.869358121
+1480	0.871202361	0.871202361	1.013171226	0.868772344
+1482	0.87095614	0.87095614	1.013171226	0.867921803
+1484	0.870167908	0.870167908	1.013171226	0.86715337
+1486	0.869390202	0.869390202	1.013171226	0.865630453
+1488	0.869470985	0.869470985	1.013171226	0.864698198
+1490	0.86995558	0.86995558	1.013171226	0.863554667
+1492	0.870719245	0.870719245	1.013171226	0.862696911
+1494	0.870293679	0.870293679	1.013171226	0.861139768
+1496	0.869756862	0.869756862	1.013171226	0.860935239
+1498	0.869514083	0.869514083	1.013171226	0.860934859
+1500	0.868985541	0.868985541	1.013171226	0.860497927
+1502	0.868498926	0.868498926	1.013171226	0.858550812
+1504	0.868360966	0.868360966	1.013171226	0.857138913
+1506	0.86952076	0.86952076	1.013171226	0.856605086
+1508	0.869970426	0.869970426	1.013171226	0.855066539
+1510	0.869572539	0.869572539	1.013171226	0.853929512
+1512	0.868739492	0.868739492	1.013171226	0.852518443
+1514	0.868319644	0.868319644	1.013171226	0.852695714
+1516	0.868337066	0.868337066	1.013171226	0.851802748
+1518	0.86878658	0.86878658	1.013171226	0.850976826
+1520	0.868537393	0.868537393	1.013171226	0.850118535
+1522	0.86922455	0.86922455	1.013171226	0.848543458
+1524	0.868037521	0.868037521	1.013171226	0.84834815
+1526	0.868813051	0.868813051	1.013171226	0.847997983
+1528	0.868065303	0.868065303	1.013171226	0.848837337
+1530	0.867270929	0.867270929	1.013171226	0.847582906
+1532	0.866797414	0.866797414	1.013171226	0.846018973
+1534	0.867372463	0.867372463	1.013171226	0.844631484
+1536	0.867740731	0.867740731	1.013171226	0.844428065
+1538	0.867541103	0.867541103	1.013171226	0.844512274
+1540	0.865788054	0.865788054	1.013171226	0.843914651
+1542	0.86603933	0.86603933	1.013171226	0.843117799
+1544	0.86512782	0.86512782	1.013171226	0.841505646
+1546	0.865184649	0.865184649	1.013171226	0.841033051
+1548	0.864399918	0.864399918	1.013171226	0.840204199
+1550	0.865159911	0.865159911	1.013171226	0.840345979
+1552	0.864796489	0.864796489	1.013171226	0.839696804
+1554	0.864683111	0.864683111	1.013171226	0.839812039
+1556	0.86347615	0.86347615	1.013171226	0.838893798
+1558	0.864036244	0.864036244	1.013171226	0.83864939
+1560	0.863867518	0.863867518	1.013171226	0.837350077
+1562	0.864542753	0.864542753	1.013171226	0.837883509
+1564	0.86412846	0.86412846	1.013171226	0.837162353
+1566	0.863588728	0.863588728	1.013171226	0.837032821
+1568	0.863353098	0.863353098	1.013171226	0.836622122
+1570	0.862758064	0.862758064	1.013171226	0.83602689
+1572	0.862711179	0.862711179	1.013171226	0.835612767
+1574	0.861755876	0.861755876	1.013171226	0.834594336
+1576	0.862489402	0.862489402	1.01342792	0.834026504
+1578	0.8622663	0.8622663	1.01342792	0.832781358
+1580	0.862496194	0.862496194	1.013171226	0.833062373
+1582	0.861218009	0.861218009	1.013171226	0.832833211
+1584	0.861286101	0.861286101	1.013171226	0.833584719
+1586	0.860896837	0.860896837	1.013171226	0.83235398
+1588	0.860811825	0.860811825	1.013941698	0.832383243
+1590	0.861192487	0.861192487	1.01342792	0.832635609
+1592	0.861437988	0.861437988	1.013171226	0.832747679
+1594	0.861342042	0.861342042	1.013941698	0.832657892
+1596	0.85953326	0.85953326	1.013941698	0.831655101
+1598	0.858804195	0.858804195	1.013171226	0.831357196
+1600	0.859290993	0.859290993	1.013171226	0.829535952
+1602	0.859612233	0.859612233	1.013171226	0.829212091
+1604	0.859608685	0.859608685	1.013171226	0.828782721
+1606	0.858817728	0.858817728	1.013171226	0.829702309
+1608	0.858905673	0.858905673	1.013171226	0.829456164
+1610	0.858792014	0.858792014	1.013171226	0.828356574
+1612	0.858205362	0.858205362	1.013941698	0.827956701
+1614	0.858265757	0.858265757	1.014198783	0.827682875
+1616	0.858227317	0.858227317	1.014198783	0.827294489
+1618	0.859502691	0.859502691	1.013941698	0.826468017
+1620	0.859660656	0.859660656	1.013941698	0.826700824
+1622	0.8591956	0.8591956	1.014198783	0.826827335
+1624	0.857563478	0.857563478	1.014198783	0.827082459
+1626	0.85643017	0.85643017	1.01497082	0.827603754
+1628	0.856863822	0.856863822	1.015228426	0.82867559
+1630	0.857749887	0.857749887	1.015228426	0.827466314
+1632	0.85809653	0.85809653	1.015228426	0.826349846
+1634	0.858006894	0.858006894	1.015228426	0.825186793
+1636	0.856851836	0.856851836	1.015228426	0.825429806
+1638	0.85716612	0.85716612	1.015228426	0.827105952
+1640	0.856297219	0.856297219	1.015228426	0.827330574
+1642	0.856120666	0.856120666	1.015228426	0.827580522
+1644	0.85480225	0.85480225	1.015228426	0.825759967
+1646	0.854560042	0.854560042	1.015228426	0.825963319
+1648	0.855425459	0.855425459	1.015228426	0.825196362
+1650	0.85538076	0.85538076	1.015228426	0.825700179
+1652	0.855202048	0.855202048	1.015228426	0.825223529
+1654	0.853512644	0.853512644	1.015228426	0.825196932
+1656	0.853734081	0.853734081	1.015228426	0.824953745
+1658	0.853991938	0.853991938	1.015228426	0.824272586
+1660	0.854579496	0.854579496	1.015228426	0.824969959
+1662	0.854294481	0.854294481	1.015228426	0.823789402
+1664	0.853306667	0.853306667	1.015228426	0.824190915
+1666	0.853726514	0.853726514	1.015744033	0.824499343
+1668	0.853336653	0.853336653	1.015486164	0.824977029
+1670	0.855137987	0.855137987	1.015744033	0.823963598
+1672	0.854041593	0.854041593	1.016260163	0.822580299
+1674	0.853498174	0.853498174	1.016260163	0.82293826
+1676	0.852228843	0.852228843	1.017035342	0.823519075
+1678	0.852935258	0.852935258	1.017293998	0.823873841
+1680	0.854366025	0.854366025	1.017293998	0.823286648
+1682	0.853895887	0.853895887	1.017293998	0.823823335
+1684	0.853033447	0.853033447	1.017293998	0.824194339
+1686	0.852419571	0.852419571	1.017293998	0.823538176
+1688	0.852065093	0.852065093	1.017293998	0.823159921
+1690	0.851331186	0.851331186	1.017293998	0.822849715
+1692	0.850281631	0.850281631	1.017293998	0.823883541
+1694	0.85119037	0.85119037	1.017293998	0.822857033
+1696	0.850902677	0.850902677	1.017293998	0.822012824
+1698	0.850583958	0.850583958	1.017293998	0.821879642
+1700	0.848122932	0.848122932	1.017293998	0.822863427
+1702	0.847776556	0.847776556	1.017293998	0.823568479
+1704	0.847277191	0.847277191	1.017293998	0.822777525
+1706	0.847009287	0.847009287	1.017293998	0.822566596
+1708	0.847568819	0.847568819	1.017293998	0.823150598
+1710	0.846487434	0.846487434	1.017293998	0.823374618
+1712	0.84684694	0.84684694	1.017293998	0.824169658
+1714	0.846119702	0.846119702	1.017293998	0.823489949
+1716	0.846712361	0.846712361	1.017293998	0.822591638
+1718	0.846278617	0.846278617	1.017293998	0.823981209
+1720	0.846072186	0.846072186	1.017293998	0.824634008
+1722	0.845070064	0.845070064	1.017293998	0.825764449
+1724	0.845650119	0.845650119	1.017293998	0.824725042
+1726	0.845368562	0.845368562	1.017293998	0.825923302
+1728	0.84519906	0.84519906	1.017293998	0.827084566
+1730	0.844080327	0.844080327	1.017293998	0.826808276
+1732	0.840692132	0.840692132	1.017293998	0.826459056
+1734	0.840362144	0.840362144	1.017293998	0.826094357
+1736	0.83872177	0.83872177	1.017293998	0.82509527
+1738	0.840106017	0.840106017	1.017293998	0.823800326
+1740	0.840445792	0.840445792	1.017293998	0.824141867
+1742	0.84160005	0.84160005	1.017293998	0.826560505
+1744	0.843226699	0.843226699	1.017293998	0.82931454
+1746	0.842458164	0.842458164	1.017293998	0.830088832
+1748	0.84299681	0.84299681	1.017293998	0.8304914
+1750	0.842295463	0.842295463	1.017293998	0.830142104
+1752	0.841528635	0.841528635	1.017293998	0.83032214
+1754	0.839414895	0.839414895	1.017293998	0.829404888
+1756	0.839381859	0.839381859	1.017293998	0.829691384
+1758	0.838747093	0.838747093	1.017035342	0.830047733
+1760	0.837605129	0.837605129	1.017035342	0.831320538
+1762	0.835418068	0.835418068	1.017293998	0.832367608
+1764	0.834958945	0.834958945	1.017293998	0.832402457
+1766	0.836205158	0.836205158	1.017293998	0.832017596
+1768	0.834418616	0.834418616	1.017293998	0.831676899
+1770	0.834904415	0.834904415	1.017293998	0.834352812
+1772	0.832593231	0.832593231	1.017293998	0.835428473
+1774	0.832658783	0.832658783	1.016776817	0.837138568
+1776	0.831708227	0.831708227	1.017293998	0.834822864
+1778	0.832747703	0.832747703	1.017293998	0.834748435
+1780	0.833354319	0.833354319	1.017293998	0.833115921
+1782	0.833197807	0.833197807	1.017035342	0.835847266
+1784	0.833240799	0.833240799	1.017035342	0.836014252
+1786	0.833720276	0.833720276	1.017293998	0.838793278
+1788	0.832222327	0.832222327	1.017293998	0.838794874
+1790	0.831128645	0.831128645	1.017293998	0.837893594
+1792	0.828559986	0.828559986	1.017293998	0.835503433
+1794	0.830372496	0.830372496	1.017293998	0.832917548
+1796	0.828962351	0.828962351	1.017293998	0.832262572
+1798	0.831383358	0.831383358	1.017293998	0.832751966
+1800	0.828315855	0.828315855	1.017293998	0.833487584
+1802	0.829537908	0.829537908	1.017293998	0.835684008
+1804	0.828479879	0.828479879	1.017293998	0.835673176
+1806	0.830179435	0.830179435	1.017552786	0.835978248
+1808	0.829066233	0.829066233	1.018329939	0.836183303
+1810	0.829248263	0.829248263	1.018329939	0.835181877
+1812	0.829259502	0.829259502	1.018329939	0.835487487
+1814	0.829293229	0.829293229	1.018329939	0.835134143
+1816	0.829681319	0.829681319	1.018329939	0.837088405
+1818	0.830287716	0.830287716	1.018589254	0.836266879
+1820	0.829175648	0.829175648	1.019367992	0.835372355
+1822	0.826901372	0.826901372	1.019367992	0.836025962
+1824	0.826437237	0.826437237	1.020147921	0.837659025
+1826	0.828612099	0.828612099	1.019627836	0.83724437
+1828	0.828947902	0.828947902	1.020147921	0.836886674
+1830	0.82812367	0.82812367	1.020408163	0.836373103
+1832	0.827104889	0.827104889	1.020929045	0.837326118
+1834	0.827831927	0.827831927	1.021189686	0.835015616
+1836	0.828123177	0.828123177	1.02145046	0.83604575
+1838	0.828515063	0.828515063	1.020929045	0.837644588
+1840	0.827622212	0.827622212	1.02145046	0.839105265
+1842	0.826728955	0.826728955	1.02145046	0.838132276
+1844	0.826169361	0.826169361	1.02223358	0.838871422
+1846	0.824378115	0.824378115	1.022494888	0.83871088
+1848	0.824298771	0.824298771	1.022494888	0.840229586
+1850	0.823563371	0.823563371	1.022494888	0.840699928
+1852	0.824781554	0.824781554	1.022494888	0.839547056
+1854	0.824858262	0.824858262	1.022494888	0.841108969
+1856	0.824287898	0.824287898	1.022494888	0.843000179
+1858	0.822588422	0.822588422	1.022494888	0.846175549
+1860	0.821945815	0.821945815	1.022494888	0.848351417
+1862	0.822544113	0.822544113	1.023017903	0.850061311
+1864	0.822662917	0.822662917	1.022756328	0.852393099
+1866	0.819770995	0.819770995	1.022756328	0.855053095
+1868	0.818598032	0.818598032	1.023279611	0.856340674
+1870	0.817522405	0.817522405	1.023541453	0.859347503
+1872	0.8187432	0.8187432	1.023541453	0.865063438
+1874	0.816222504	0.816222504	1.023279611	0.872649806
+1876	0.815681005	0.815681005	1.02406554	0.881819645
+1878	0.816126334	0.816126334	1.02380343	0.888821355
+1880	0.816789716	0.816789716	1.024327785	0.895253343
+1882	0.815536212	0.815536212	1.02406554	0.901750696
+1884	0.810753186	0.810753186	1.02406554	0.906060176
+1886	0.808076598	0.808076598	1.02406554	0.912472874
+1888	0.80579057	0.80579057	1.024327785	0.920171377
+1890	0.806563035	0.806563035	1.024327785	0.928077959
+1892	0.80377486	0.80377486	1.024590164	0.940837846
+1894	0.803304549	0.803304549	1.024327785	0.948861463
+1896	0.801304445	0.801304445	1.023541453	0.956011305
+1898	0.800432785	0.800432785	1.02406554	0.963247635
+1900	0.793400206	0.793400206	1.024327785	0.966905732
+1902	0.790681635	0.790681635	1.025115325	0.974798026
+1904	0.788429567	0.788429567	1.02380343	0.975933637
+1906	0.79217986	0.79217986	1.023541453	0.983567801
+1908	0.790258908	0.790258908	1.024327785	0.993002538
+1910	0.787548342	0.787548342	1.02380343	1.00657427
+1912	0.784985677	0.784985677	1.024327785	1.010998127
+1914	0.782758933	0.782758933	1.024852677	1.016031377
+1916	0.783238243	0.783238243	1.024327785	1.014500007
+1918	0.782388942	0.782388942	1.024590164	1.022966962
+1920	0.781254716	0.781254716	1.02406554	1.026118284
+1922	0.780740521	0.780740521	1.024590164	1.031336157
+1924	0.777527809	0.777527809	1.024590164	1.031400409
+1926	0.778215243	0.778215243	1.025378108	1.036194451
+1928	0.775224781	0.775224781	1.025378108	1.035226978
+1930	0.773743435	0.773743435	1.025378108	1.03935974
+1932	0.770323931	0.770323931	1.025115325	1.041298049
+1934	0.767444602	0.767444602	1.025641026	1.044641989
+1936	0.768295616	0.768295616	1.025641026	1.043566546
+1938	0.769362923	0.769362923	1.025641026	1.038499934
+1940	0.772738069	0.772738069	1.025641026	1.038737867
+1942	0.770704787	0.770704787	1.025641026	1.035879799
+1944	0.770601594	0.770601594	1.025641026	1.037427425
+1946	0.769222782	0.769222782	1.025641026	1.030595864
+1948	0.766707024	0.766707024	1.025641026	1.030954778
+1950	0.763851563	0.763851563	1.026430588	1.029560374
+1952	0.763889083	0.763889083	1.026694045	1.033546252
+1954	0.766323486	0.766323486	1.026694045	1.034423007
+1956	0.766855958	0.766855958	1.026694045	1.028006612
+1958	0.768582246	0.768582246	1.026694045	1.021691113
+1960	0.770742799	0.770742799	1.02748523	1.020318015
+1962	0.770034934	0.770034934	1.027749229	1.019834297
+1964	0.77322272	0.77322272	1.027749229	1.022642313
+1966	0.772311795	0.772311795	1.027749229	1.019582636
+1968	0.776091062	0.776091062	1.027749229	1.015442661
+1970	0.774522397	0.774522397	1.028542042	1.013555577
+1972	0.779362879	0.779362879	1.028542042	1.007854466
+1974	0.779795559	0.779795559	1.028013364	1.007693016
+1976	0.780394921	0.780394921	1.02960103	1.005762082
+1978	0.77368798	0.77368798	1.029866117	1.002620399
+1980	0.772851547	0.772851547	1.029866117	1.000423625
+1982	0.773465772	0.773465772	1.029866117	0.995290023
+1984	0.778855884	0.778855884	1.030131342	0.997624065
+1986	0.783603689	0.783603689	1.030927835	0.992741661
+1988	0.783375781	0.783375781	1.030927835	0.993046209
+1990	0.783564421	0.783564421	1.031193607	0.983158714
+1992	0.782101294	0.782101294	1.032791118	0.980755631
+1994	0.778258065	0.778258065	1.033057851	0.976247147
+1996	0.776219515	0.776219515	1.032791118	0.977745332
+1998	0.776661934	0.776661934	1.032791118	0.979427982
+2000	0.778749489	0.778749489	1.033057851	0.976190196
+2002			1.034126163	
+2004			1.035196687	
+2006			1.035196687	
+2008			1.036001036	
+2010			1.03626943	
+2012			1.037075447	
+2014			1.037344398	
+2016			1.038152089	
+2018			1.039230969	
+2020			1.03950104	
+2022			1.03977125	
+2024			1.041124414	
+2026			1.04139547	
+2028			1.042481105	
+2030			1.042752868	
+2032			1.043296818	
+2034			1.043569006	
+2036			1.044113808	
+2038			1.044932079	
+2040			1.045751634	
+2042			1.045478306	
+2044			1.047120419	
+2046			1.047943411	
+2048			1.047943411	
+2050			1.048767698	
+2052			1.048218029	
+2054			1.048218029	
+2056			1.049868766	
+2058			1.050420168	
+2060			1.050420168	
+2062			1.050420168	
+2064			1.050972149	
+2066			1.052077854	
+2068			1.052631579	
+2070			1.053185887	
+2072			1.052631579	
+2074			1.052631579	
+2076			1.05374078	
+2078			1.054852321	
+2080			1.054852321	
+2082			1.055130572	
+2084			1.055408971	
+2086			1.056524036	
+2088			1.056245049	
+2090			1.057082452	
+2092			1.057082452	
+2094			1.057082452	
+2096			1.058201058	
+2098			1.059322034	
+2100			1.059041567	
+2102			1.059602649	
+2104			1.059883413	
+2106			1.060164325	
+2108			1.061289467	
+2110			1.061289467	
+2112			1.061571125	
+2114			1.060726598	
+2116			1.062981664	
+2118			1.063264221	
+2120			1.063264221	
+2122			1.063829787	
+2124			1.064112796	
+2126			1.064679265	
+2128			1.065814015	
+2130			1.066951187	
+2132			1.067235859	
+2134			1.067235859	
+2136			1.067235859	
+2138			1.066666667	
+2140			1.066666667	
+2142			1.065814015	
+2144			1.065814015	
+2146			1.064679265	
+2148			1.064112796	
+2150			1.064395955	
+2152			1.064395955	
+2154			1.062699256	
+2156			1.061852933	
+2158			1.060445387	
+2160			1.060164325	
+2162			1.059322034	
+2164			1.05764146	
+2166			1.055687516	
+2168			1.054574216	
+2170			1.05374078	
+2172			1.052631579	
+2174			1.051248357	
+2176			1.050420168	
+2178			1.050420168	
+2180			1.049317943	
+2182			1.047943411	
+2184			1.047120419	
+2186			1.046298718	
+2188			1.045751634	
+2190			1.044113808	
+2192			1.043841336	
+2194			1.043569006	
+2196			1.042752868	
+2198			1.042481105	
+2200			1.04139547	
+2202			1.040582726	
+2204			1.040041602	
+2206			1.04139547	
+2208			1.04139547	
+2210			1.040582726	
+2212			1.040582726	
+2214			1.040312094	
+2216			1.039230969	
+2218			1.038691249	
+2220			1.03950104	
+2222			1.03950104	
+2224			1.03950104	
+2226			1.038691249	
+2228			1.038691249	
+2230			1.039230969	
+2232			1.038421599	
+2234			1.038961039	
+2236			1.040041602	
+2238			1.040582726	
+2240			1.040582726	
+2242			1.040582726	
+2244			1.040582726	
+2246			1.04139547	
+2248			1.041666667	
+2250			1.041124414	
+2252			1.040582726	
+2254			1.040582726	
+2256			1.042752868	
+2258			1.042481105	
+2260			1.041938005	
+2262			1.041938005	
+2264			1.043296818	
+2266			1.042752868	
+2268			1.043024772	
+2270			1.043841336	
+2272			1.044386423	
+2274			1.043569006	
+2276			1.044386423	
+2278			1.045751634	
+2280			1.045751634	
+2282			1.045751634	
+2284			1.046298718	
+2286			1.046572475	
+2288			1.046572475	
+2290			1.047120419	
+2292			1.048492792	
+2294			1.048218029	
+2296			1.048492792	
+2298			1.049042748	
+2300			1.051248357	
+2302			1.050972149	
+2304			1.049868766	
+2306			1.051524711	
+2308			1.052077854	
+2310			1.050696086	
+2312			1.052354644	
+2314			1.05180121	
+2316			1.054852321	
+2318			1.055408971	
+2320			1.055130572	
+2322			1.055966209	
+2324			1.055408971	
+2326			1.055130572	
+2328			1.057082452	
+2330			1.058201058	
+2332			1.058761249	
+2334			1.059041567	
+2336			1.060445387	
+2338			1.061571125	
+2340			1.062134891	
+2342			1.061289467	
+2344			1.060726598	
+2346			1.061852933	
+2348			1.062416999	
+2350			1.063264221	
+2352			1.062699256	
+2354			1.064395955	
+2356			1.063829787	
+2358			1.065530101	
+2360			1.066098081	
+2362			1.065246338	
+2364			1.065530101	
+2366			1.066098081	
+2368			1.066951187	
+2370			1.065530101	
+2372			1.066098081	
+2374			1.067805659	
+2376			1.066666667	
+2378			1.066098081	
+2380			1.066382298	
+2382			1.065814015	
+2384			1.066666667	
+2386			1.069232825	
+2388			1.067520683	
+2390			1.068090788	
+2392			1.068947087	
+2394			1.068661501	
+2396			1.069232825	
+2398			1.067520683	
+2400			1.067235859	
+2402			1.068090788	
+2404			1.068661501	
+2406			1.069518717	
+2408			1.069804761	
+2410			1.067520683	
+2412			1.068947087	
+2414			1.071524243	
+2416			1.071237279	
+2418			1.069518717	
+2420			1.069232825	
+2422			1.068090788	
+2424			1.069518717	
+2426			1.069804761	
+2428			1.070377308	
+2430			1.068090788	
+2432			1.069518717	
+2434			1.071237279	
+2436			1.070377308	
+2438			1.070950469	
+2440			1.070377308	
+2442			1.070090958	
+2444			1.069232825	
+2446			1.068947087	
+2448			1.067520683	
+2450			1.066951187	
+2452			1.067235859	
+2454			1.070377308	
+2456			1.069804761	
+2458			1.069232825	
+2460			1.070090958	
+2462			1.069518717	
+2464			1.066951187	
+2466			1.068661501	
+2468			1.067520683	
+2470			1.066951187	
+2472			1.069232825	
+2474			1.069518717	
+2476			1.070090958	
+2478			1.069232825	
+2480			1.071811361	
+2482			1.071524243	
+2484			1.070377308	
+2486			1.071524243	
+2488			1.071811361	
+2490			1.070377308	
+2492			1.070090958	
+2494			1.070950469	
+2496			1.073537305	
+2498			1.075557946	
+2500			1.067615658
```

### Comparing `grapa-0.5.4.8/grapa/datatypes/spectrumSubstrates.txt` & `grapa-0.6.1.0/grapa/datatypes/spectrumSubstrates.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/boxplot/export_sample_a_summary_illum.txt` & `grapa-0.6.1.0/grapa/examples/boxplot/export_sample_a_summary_illum.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/boxplot/export_sample_b_3layermo_summary_illum.txt` & `grapa-0.6.1.0/grapa/examples/boxplot/export_sample_b_3layermo_summary_illum.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/boxplot/export_sample_b_5layermo_summary_illum.txt` & `grapa-0.6.1.0/grapa/examples/boxplot/export_sample_b_5layermo_summary_illum.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/boxplot/I-V_CA160_Param.txt` & `grapa-0.6.1.0/grapa/examples/boxplot/I-V_CA160_Param.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_123K.txt` & `grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_123K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_133K.txt` & `grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_133K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_143K.txt` & `grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_143K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_153K.txt` & `grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_153K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_163K.txt` & `grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_163K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_173K.txt` & `grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_173K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_183K.txt` & `grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_183K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_193K.txt` & `grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_193K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_203K.txt` & `grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_203K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_213K.txt` & `grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_213K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_223K.txt` & `grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_223K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_233K.txt` & `grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_233K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_243K.txt` & `grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_243K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_253K.txt` & `grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_253K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_263K.txt` & `grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_263K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_273K.txt` & `grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_273K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_283K.txt` & `grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_283K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_293K.txt` & `grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_293K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Cf/C-f_SAMPLE_f1_303K.txt` & `grapa-0.6.1.0/grapa/examples/Cf/C-f_SAMPLE_f1_303K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=123_K.txt` & `grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=123_K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=133_K.txt` & `grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=133_K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=143_K.txt` & `grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=143_K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=153_K.txt` & `grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=153_K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=163_K.txt` & `grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=163_K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=173_K.txt` & `grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=173_K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=183_K.txt` & `grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=183_K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=193_K.txt` & `grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=193_K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=203_K.txt` & `grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=203_K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=213_K.txt` & `grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=213_K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=223_K.txt` & `grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=223_K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=233_K.txt` & `grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=233_K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=243_K.txt` & `grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=243_K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=253_K.txt` & `grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=253_K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=263_K.txt` & `grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=263_K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=273_K.txt` & `grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=273_K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=283_K.txt` & `grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=283_K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=293_K.txt` & `grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=293_K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/CV/C-V_SAMPLE_f1_T=303_K.txt` & `grapa-0.6.1.0/grapa/examples/CV/C-V_SAMPLE_f1_T=303_K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/EQE/1150-8-C3-QE.txt` & `grapa-0.6.1.0/grapa/examples/EQE/1150-8-C3-QE.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/EQE/SAMPLE_A_d1_1.sr` & `grapa-0.6.1.0/grapa/examples/EQE/SAMPLE_A_d1_1.sr`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/EQE/SAMPLE_B_TCObelowMo_d1_1.sr` & `grapa-0.6.1.0/grapa/examples/EQE/SAMPLE_B_TCObelowMo_d1_1.sr`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/EQE/SAMPLE_C_f1_1.sr` & `grapa-0.6.1.0/grapa/examples/EQE/SAMPLE_C_f1_1.sr`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Reference Cell: ISE_08
 Sample Name: Ref
-
+
 SB
 360Hz, 22C, bias light, room lights on, 30dB, beam spot smaller
 01.10.2012 10:55:37
 Ref. Frequency:229
 1:lambda
 2:current
 3:noise
```

### Comparing `grapa-0.5.4.8/grapa/examples/example_datafile.txt` & `grapa-0.6.1.0/grapa/examples/example_datafile.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/example_datafile_withXY1rowcol.txt` & `grapa-0.6.1.0/grapa/examples/example_datafile_withXY1rowcol.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/example_imshow_datafile.txt` & `grapa-0.6.1.0/grapa/examples/example_imshow_datafile.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/example_imshow_datatable.txt` & `grapa-0.6.1.0/grapa/examples/example_imshow_datatable.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/example_imshow_picture.txt` & `grapa-0.6.1.0/grapa/examples/example_imshow_picture.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/fancyAnnotations.txt` & `grapa-0.6.1.0/grapa/examples/fancyAnnotations.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JscVoc/JscVoc_SAMPLE_c2_Values.txt` & `grapa-0.6.1.0/grapa/examples/JscVoc/JscVoc_SAMPLE_c2_Values.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_a2_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_a2_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_a2_02.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_a2_02.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_a2_02_dark.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_a2_02_dark.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_a3_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_a3_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_b2_02_dark.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_C2_02_dark.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_C2_02_dark.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_A/I-V_SAMPLE_A_b2_02_dark.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_a1_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_a1_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_a2_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_a2_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_a3_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_a3_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_b1_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_b1_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_b2_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_b2_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_b3_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_b3_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_c1_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_c1_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_c1_02.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_c1_02.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_c2_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_c2_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_c3_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_c3_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_d1_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_d1_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_d2_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_d2_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_d3_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_d3_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_e1_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_e1_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_e2_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_e2_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_e3_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_e3_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_f1_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_f1_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_f2_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_f2_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_f3_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_f3_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_f3_01_dark.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_f3_01_dark.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_f3_01_new_cont_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_f3_01_new_cont_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_Param.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_3layerMo/I-V_SAMPLE_B_3LayerMo_Param.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_a1_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_a1_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_a2_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_a2_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_a3_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_a3_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_b1_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_b1_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_b2_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_b2_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_b2_01_dark.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_b2_01_dark.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_b3_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_b3_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_c1_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_c1_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_c2_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_c2_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_c3_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_c3_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_d1_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_d1_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_d2_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_d2_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_d3_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_d3_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_e1_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_e1_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_e2_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_e2_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_e3_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_e3_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_f1_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_f1_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_f2_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_f2_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_f3_01.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_f3_01.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_Param.txt` & `grapa-0.6.1.0/grapa/examples/JV/SAMPLE_B_5LayerMo/I-V_SAMPLE_B_5LayerMo_Param.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/SIMS/SAMPLE_CZTS_A_NoNa_1.TXT` & `grapa-0.6.1.0/grapa/examples/SIMS/SAMPLE_CZTS_A_NoNa_1.TXT`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/SIMS/SAMPLE_D_c_1.TXT` & `grapa-0.6.1.0/grapa/examples/SIMS/SAMPLE_D_c_1.TXT`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Spectra/CdS32nm_on_SLG_R.txt` & `grapa-0.6.1.0/grapa/examples/Spectra/CdS32nm_on_SLG_R.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Spectra/CdS32nm_on_SLG_T.txt` & `grapa-0.6.1.0/grapa/examples/Spectra/CdS32nm_on_SLG_T.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Spectra/PLexample_thinCIGSFilmWithInterference.dat` & `grapa-0.6.1.0/grapa/examples/Spectra/PLexample_thinCIGSFilmWithInterference.dat`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/Spectra/rem_Sample1_564_run2_i_TR.Sample.asc` & `grapa-0.6.1.0/grapa/examples/Spectra/rem_Sample1_564_run2_i_TR.Sample.asc`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/subplots_examples.txt` & `grapa-0.6.1.0/grapa/examples/subplots_examples.txt`

 * *Ordering differences only*

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 subplots_adjust	[0.07, 0.05, 0.95, 0.94, 0.25, 0.2]
+fontsize	12.0
 subplotswidth_ratios	[2, 1.2]
 subplotsncols	2.0
-fontsize	12.0
 figsize	[8, 6]
 subplotsid	1.0
 meastype	Graph
 curve	subplot	subplot	subplot	subplot
 filename	From clipboard	From clipboard	From clipboard	From clipboard
 label	subplot a	subplot d data image overlay	subplot c matix data	subplot b picture
 subplotcolspan	1	1	1	1
```

### Comparing `grapa-0.5.4.8/grapa/examples/testRoutine.py` & `grapa-0.6.1.0/grapa/examples/testRoutine.py`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_123K.txt` & `grapa-0.6.1.0/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_123K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_143K.txt` & `grapa-0.6.1.0/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_143K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_163K.txt` & `grapa-0.6.1.0/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_163K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_183K.txt` & `grapa-0.6.1.0/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_183K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_203K.txt` & `grapa-0.6.1.0/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_203K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_223K.txt` & `grapa-0.6.1.0/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_223K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_243K.txt` & `grapa-0.6.1.0/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_243K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_263K.txt` & `grapa-0.6.1.0/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_263K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_283K.txt` & `grapa-0.6.1.0/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_283K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_303K.txt` & `grapa-0.6.1.0/grapa/examples/TIV/dark/dark_SAMPLE_F_a3_303K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_123K.txt` & `grapa-0.6.1.0/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_123K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_143K.txt` & `grapa-0.6.1.0/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_143K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_163K.txt` & `grapa-0.6.1.0/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_163K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_183K.txt` & `grapa-0.6.1.0/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_183K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_203K.txt` & `grapa-0.6.1.0/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_203K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_223K.txt` & `grapa-0.6.1.0/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_223K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_243K.txt` & `grapa-0.6.1.0/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_243K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_264K.txt` & `grapa-0.6.1.0/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_264K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_283K.txt` & `grapa-0.6.1.0/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_283K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_303K.txt` & `grapa-0.6.1.0/grapa/examples/TIV/illum/JV_illuminated_SAMPLE_F_a3_303K.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/TRPL/003.dat` & `grapa-0.6.1.0/grapa/examples/TRPL/003.dat`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/TRPL/522.dat` & `grapa-0.6.1.0/grapa/examples/TRPL/522.dat`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/turtle.jpg` & `grapa-0.6.1.0/grapa/examples/turtle.jpg`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/XPS/Detailed_Vb_A_0.csv` & `grapa-0.6.1.0/grapa/examples/XPS/Detailed_Vb_A_0.csv`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/XPS/Survey_A_0.csv` & `grapa-0.6.1.0/grapa/examples/XPS/Survey_A_0.csv`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/XRF/SAMPLE_G.mca` & `grapa-0.6.1.0/grapa/examples/XRF/SAMPLE_G.mca`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/examples/XRF/SAMPLE_G.mca_1.1.1.1.html` & `grapa-0.6.1.0/grapa/examples/XRF/SAMPLE_G.mca_1.1.1.1.html`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/graph.py` & `grapa-0.6.1.0/grapa/graph.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,22 +1,23 @@
 # -*- coding: utf-8 -*-
 """
 Created on Fri Jul 15 15:46:13 2016
 
 @author: Romain Carron
-Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+Copyright (c) 2023, Empa, Laboratory for Thin Films and Photovoltaics,
+Romain Carron
 """
 import os
 import numpy as np
 from copy import deepcopy
 from re import findall as refindall
 import matplotlib as mpl
 
 from grapa.curve import Curve
-from grapa.mathModule import is_number, stringToVariable
+from grapa.mathModule import is_number, strToVar
 
 
 class Graph:
     """
     Arguments:
     filename: filename to open (str), or list of str. Default ''
     complement: dict, the elements will be stored as graph attributes.
@@ -53,24 +54,26 @@
     replaceCurve(self, newCurve, idx)
     swapCurves(self, idx1, idx2, relative=False)
     duplicateCurve(self, idx1)
     castCurve(self, newType, idx, silentSuccess=False)
 
     update(self, attributes, ifAll=False)
     getAttribute(self, attr, default='')
-	replaceLabels(self, old, new)
+    replaceLabels(self, old, new)
     colorize(self, colorscale, sameIfEmptyLabel=False, avoidWhite=False)
     applyTemplate(self, graph)
 
     formatAxisLabel(self, default)
 
     config(self, key, default='', astype='auto')
 
-    export(self, filesave='', saveAltered=False, ifTemplate=False, ifCompact=True, ifClipboardExport=False)
-    plot(self, filesave='', imgFormat='', figsize=(0, 0), ifSave=True, ifExport=True, figAx=None, ifSubPlot=False)
+    export(self, filesave='', saveAltered=False, ifTemplate=False,
+           ifCompact=True, ifClipboardExport=False)
+    plot(self, filesave='', imgFormat='', figsize=(0, 0), ifSave=True,
+         ifExport=True, figAx=None, ifSubPlot=False)
     """
     # some class constants
     FIGSIZE_DEFAULT = (6.0, 4.0)
     FILEIO_DPI = 80
     DEFAULT = {}
     DEFAULT['subplots_adjust'] = 0.15
     DEFAULT['fontsize'] = mpl.rcParams['font.size']
@@ -79,54 +82,54 @@
     # ['x axis label [unit]', 'y axis label [unit]']
     # [['Quantity x', 'Q', 'unit'], ['Quantity y', 'Q', 'unit']]. Q will be placed in between $ $
     AXISLABELS = ['', '']
 
     CONFIG_FILENAME = None
     CONFIG_GRAPH = None
 
-    headersKeys = ['meastype', 'sample', 'collabels'] + ['savesilent']
+    headersKeys = ['meastype', 'collabels'] + ['savesilent']
     graphInfoKeysData = []
     graphInfoKeysData.append(['== Figure ==', ''])
-    graphInfoKeysData.append(['figsize',         'Figure size (inch).\nExample: "(6.0, 4.0)"'])
+    graphInfoKeysData.append(['figsize',         'Figure size (inch).\nExample: "[6.0, 4.0]"'])
     graphInfoKeysData.append(['subplots_adjust', 'Margins (relative).\nExamples: "0.15" (bottom only), or "[0.125, 0.1, 0.9, 0.9]" left,b,r,top, or "[1,1,5,3.5,\'abs\']"'])
     graphInfoKeysData.append(['dpi',             'Resolution dots-per-inch.\nExample: "300"'])
     graphInfoKeysData.append(['fontsize',        'Font size of titles, annotations, etc.\nExample: "12"'])
     graphInfoKeysData.append(['title',           'Graph title, based on ax.set_title().\nExample: "My data", or "[\'A dataset\', {\'color\':\'r\'}]"'])
     graphInfoKeysData.append(['== Axes ==', ''])
     graphInfoKeysData.append(['xlim',            'Limits of x axis, based on ax.set_xlim().\nExamples: "[2,9]", or "[\'\',4]"'])
     graphInfoKeysData.append(['ylim',            'Limits of y axis, based on ax.set_ylim().\nExamples: "[0,100]", or "[0,\'\']"'])
     graphInfoKeysData.append(['xlabel',          'Label of x axis, based on ax.set_xlabel().\nExample: "Axis x [unit]", "[\'My label\', {\'size\':6, \'color\':\'r\'}]"'])
     graphInfoKeysData.append(['ylabel',          'Label of y axis, based on ax.set_ylabel().\nExample: "Axis y [unit]", "[\'My label\', {\'size\':6, \'color\':\'r\'}]"'])
-    graphInfoKeysData.append(['xticksstep',      'Value difference between ticks on x axis, or ticks positions.\nExample: "0.01", or "[0,1,2]"']) # ax.xaxis.set_ticks
-    graphInfoKeysData.append(['yticksstep',      'Value difference between ticks on y axis, or ticks positions.\nExample: "0.01", or "[0,1,2]"']) # ax.yaxis.set_ticks
-    graphInfoKeysData.append(['xtickslabels',    'Customized ticks. First is a list of values, then a list of labels, then possibly options.\nExamples: "[[0,1],[\'some\',\'value\']]", or "[None, None, {\'rotation\':45, \'size\': 6, \'color\':\'r\'}]"']) # plt.xticks
-    graphInfoKeysData.append(['ytickslabels',    'Customized ticks. First is a list of values, then a list of labels, then possibly options.\nExamples: "[[0,1],[\'some\',\'value\']]", or "[None, None, {\'rotation\':45, \'size\': 6, \'color\':\'r\'}]"']) # plt.yticks
+    graphInfoKeysData.append(['xticksstep',      'Value difference between ticks on x axis, or ticks positions.\nExample: "0.01", or "[0,1,2]"'])  # ax.xaxis.set_ticks
+    graphInfoKeysData.append(['yticksstep',      'Value difference between ticks on y axis, or ticks positions.\nExample: "0.01", or "[0,1,2]"'])  # ax.yaxis.set_ticks
+    graphInfoKeysData.append(['xtickslabels',    'Customized ticks. First is a list of values, then a list of labels, then possibly options.\nExamples: "[[0,1],[\'some\',\'value\']]", or "[None, None, {\'rotation\':45, \'size\': 6, \'color\':\'r\'}]"'])  # plt.xticks
+    graphInfoKeysData.append(['ytickslabels',    'Customized ticks. First is a list of values, then a list of labels, then possibly options.\nExamples: "[[0,1],[\'some\',\'value\']]", or "[None, None, {\'rotation\':45, \'size\': 6, \'color\':\'r\'}]"'])  # plt.yticks
     graphInfoKeysData.append(['xlabel_coords',   'Position of xlabel, based on ax.xaxis.set_label_coords().\nExamples: "-0.1", or "[0.5,-0.15]"'])
     graphInfoKeysData.append(['ylabel_coords',   'Position of ylabel, based on ax.yaxis.set_label_coords().\nExamples: "-0.1", or "[-0.1,0.5]"'])
     graphInfoKeysData.append(['== Legends ==', ''])
-    graphInfoKeysData.append(['legendproperties','Position, or keywords to ax.legend(). Examples: "best", "sw", or\n"{\'bbox_to_anchor\':(0.2,0.8), \'ncol\':2, \'fontsize\':8}"'])
-    graphInfoKeysData.append(['legendtitle',     'Legend title. Example: "Some title", or "[\'Some title\', {\'size\':25}]"']) # messy implementation
+    graphInfoKeysData.append(['legendproperties', 'Position, or keywords to ax.legend(). Examples: "best", "sw", or\n"{\'bbox_to_anchor\':(0.2,0.8), \'ncol\':2, \'fontsize\':8}"'])
+    graphInfoKeysData.append(['legendtitle',     'Legend title. Example: "Some title", or "[\'Some title\', {\'size\':25}]"'])  # messy implementation
     graphInfoKeysData.append(['== Annotations ==', ''])
-    graphInfoKeysData.append(['axhline',         'Horizontal line(s), based on ax.axhline().', ['0', "[1, 1.5, 2, {'color':'r'}]", "[[3, {'xmin':0.4}], [4, {'xmax': 0.6, 'linewidth':2}]]"]])
-    graphInfoKeysData.append(['axvline',         'Vertical line(s), based on ax.axvline().'  , ['0', "[1, 1.5, 2, {'color':'r'}]", "[[3, {'ymin':0.4}], [4, {'ymax': 0.6, 'linewidth':2}]]"]])
+    graphInfoKeysData.append(['axhline',         'Horizontal line(s), based on ax.axhline().', ['0', "[1, 1.5, 2, {'color':'r'}]", "[[3, {'xmin':0.4}], [4, {'xmax': 0.6, 'linewidth':2}]]", "[0, {'linewidth': 0.5}]"]])
+    graphInfoKeysData.append(['axvline',         'Vertical line(s), based on ax.axvline().', ['0', "[1, 1.5, 2, {'color':'r'}]", "[[3, {'ymin':0.4}], [4, {'ymax': 0.6, 'linewidth':2}]]", "[0, {'linewidth': 0.5}]"]])
     graphInfoKeysData.append(['text',            'Annotations, use GUI window if possible. "Some text", or "[\'Here\', \'There\']"'])
     graphInfoKeysData.append(['textxy',          'Use GUI window if possible. "(0.05, 0.95)" , or "[(0.2, 0.3), (0.8, 0.9)]"'])
     graphInfoKeysData.append(['textargs',        'Use GUI window if possible. "{\'fontsize\':15}", or "[{\'horizontalalignment\': \'right\',\n\'xytext\': (0.4, 0.65), \'arrowprops\': {\'shrink\': 0.05}, \'xy\': (0.46, 0.32)}, {}]"'])
     graphInfoKeysData.append(['== Secondary axes ==', ''])
     graphInfoKeysData.append(['twiny_xlabel',    'Secondary x axis label.\nExamples: "Other axis x [unit]", "[\'My label\', {\'size\':6, \'color\':\'r\'}]"'])
     graphInfoKeysData.append(['twinx_ylabel',    'Secondary y axis label.\nExamples: "Other axis x [unit]", "[\'My label\', {\'size\':6, \'color\':\'r\'}]"'])
     graphInfoKeysData.append(['twiny_xlim',      'Secondary x axis limits.\nExamples: "[2,9]", or "[\'\',4]"'])
     graphInfoKeysData.append(['twinx_ylim',      'Secondary y axis limits.\nExamples: "[0,100]", or "[0,\'\']"'])
     graphInfoKeysData.append(['== Misc ==', ''])
     graphInfoKeysData.append(['alter',           'Data transform keyword, specific to the type of manipulated data.\nExamples: "linear", "[\'y\',\'x\']", or "[\'nmeV\', \'tauc\']"'])
     graphInfoKeysData.append(['typeplot',        'General graph plotting instruction, based on ax.set_xscale() and ax.set_yscale().\nExamples: "plot", "semilogx", etc.'])
     graphInfoKeysData.append(['arbitraryfunctions', 'A list of instructions. Each instruction is a list as\n[method of ax, list of arguments, dict of keyword arguments]', ["[[\'xaxis.set_ticks\',[[1.5, 5.5]],{\'minor\':True}], [\'set_xticklabels\',[[\'a\',\'b\']],{\'minor\':True}]]", "[['set_axis_off', [], {}]]", "[['grid', [True], {'axis': 'both'}]]", "[['yaxis.set_major_formatter', ['StrMethodFormatter({x:.2f})'], {}]]", "[['xaxis.set_minor_locator', ['MultipleLocator(0.5)'], {}]]"]])
     graphInfoKeysData_ = np.array([d[0:2] for d in graphInfoKeysData])
-    graphInfoKeys = list(graphInfoKeysData_[:,0])
-    graphInfoKeysExample = list(graphInfoKeysData_[:,1])
+    graphInfoKeys = list(graphInfoKeysData_[:, 0])
+    graphInfoKeysExample = list(graphInfoKeysData_[:, 1])
     graphInfoKeysExalist = []
     for i in range(len(graphInfoKeysData)):
         if len(graphInfoKeysData[i]) < 3:
             split = graphInfoKeysData[i][1].split('"')
             graphInfoKeysExalist.append(['']+split[1::2])
         else:
             graphInfoKeysExalist.append(graphInfoKeysData[i][2])
@@ -151,17 +154,17 @@
     dataInfoKeysGraphData.append(['label',          'Curve label to be shown in legend. Example: "Experiment C"'])
     dataInfoKeysGraphData.append(['== Display ==',  ''])
     dataInfoKeysGraphData.append(['color',          'Curve color. Examples: "r", "purple", or "[0.5,0,0]" (rgb or rgba notations)'])
     dataInfoKeysGraphData.append(['alpha',          'Transparency. Examples. "0.5", "1"'])
     dataInfoKeysGraphData.append(['linewidth',      'Linewidth in points. Example: "1.5"'])
     dataInfoKeysGraphData.append(['marker',         'Examples: "o", "s", "x"'])
     dataInfoKeysGraphData.append(['markersize',     'Size of marker, in points. Example: "2.5"'])
-    dataInfoKeysGraphData.append(['markerfacecolor','Marker inner color. Example: "r", "[0.5,0,0]"'])
-    dataInfoKeysGraphData.append(['markeredgecolor','Marker border color. Example: "r", "[0.5,0,0]"'])
-    dataInfoKeysGraphData.append(['markeredgewidth','Marker border width, in points. Example: "1.5"'])
+    dataInfoKeysGraphData.append(['markerfacecolor', 'Marker inner color. Example: "r", "[0.5,0,0]"'])
+    dataInfoKeysGraphData.append(['markeredgecolor', 'Marker border color. Example: "r", "[0.5,0,0]"'])
+    dataInfoKeysGraphData.append(['markeredgewidth', 'Marker border width, in points. Example: "1.5"'])
     dataInfoKeysGraphData.append(['zorder',         'Determines the drawing order (float), highest is drawn on top.\nExample: "2", "3"'])
     dataInfoKeysGraphData.append(['== Offsets ==',  ''])
     dataInfoKeysGraphData.append(['offset',         'Offset to data. Examples: "-10" (on y values), "[2,\'1/20\']" for (x,y) offset.\nSpecial keywords: "[\'minmax\', \'0max\']" and combinations.'])
     dataInfoKeysGraphData.append(['muloffset',      'Multiplicative offset to data. Examples: "0.01" for y values, or\n"[10, 1e2]" for (x,y) multiplicative offsets'])
     dataInfoKeysGraphData.append(['== For specific curve types ==', ''])
     dataInfoKeysGraphData.append(['facecolor',      'Color of "fill" Curve types. Examples: "r", "[0.5,0,0]"'])
     dataInfoKeysGraphData.append(['cmap',           'Colormap, for Curve types which accept this keyword such as scatter). Examples:\n"afmhot", "inferno", or "[[0.91,0.25,1], [1.09,0.75,1], \'hls\']" (see Colorize options)'])
@@ -171,18 +174,18 @@
     dataInfoKeysGraphData.append(['yerr',           'y error for curve type "errorbar". Example: "1", or "5"'])
     dataInfoKeysGraphData.append(['== Misc ==',     ''])
     dataInfoKeysGraphData.append(['labelhide',      'Use "1" to hide label in the graph'])
     dataInfoKeysGraphData.append(['legend',         'Deprecated. Curve label in legend.'])
     dataInfoKeysGraphData.append(['ax_twinx',       'Plot curve on secondary axis. Example: "True", or anything'])
     dataInfoKeysGraphData.append(['ax_twiny',       'Plot curve on secondary axis. Example: "True", or anything'])
     dataInfoKeysGraphData.append(['linestyle',      'Use "none" to hide a Curve'])
-    dataInfoKeysGraphData.append(["['key', value]", 'User-defined keyword-values pairs. Will be fed to the plotting method if possible.\nExamples: "[\'fillstyle\', \'top\']" for half-filled markers, "[\'comment\', \'a valuable info\']]'])
+    dataInfoKeysGraphData.append(["['key', value]", 'User-defined keyword-values pairs. Will be fed to the plotting method if possible.\nExamples: "[\'fillstyle\', \'top\']" for half-filled markers, "[\'comment\', \'a valuable info\']'])
     dataInfoKeysGraphData_ = np.array([d[0:2] for d in dataInfoKeysGraphData])
-    dataInfoKeysGraph = list(dataInfoKeysGraphData_[:,0])
-    dataInfoKeysGraphExample = list(dataInfoKeysGraphData_[:,1])
+    dataInfoKeysGraph = list(dataInfoKeysGraphData_[:, 0])
+    dataInfoKeysGraphExample = list(dataInfoKeysGraphData_[:, 1])
     dataInfoKeysGraphExalist = []
     for i in range(len(dataInfoKeysGraphData)):
         if len(dataInfoKeysGraphData[i]) < 3:
             split = dataInfoKeysGraphData[i][1].split('"')
             dataInfoKeysGraphExalist.append(['']+split[1::2])
         else:
             dataInfoKeysGraphExalist.append(dataInfoKeysGraphData[i][2])
@@ -196,15 +199,16 @@
         # load preferences
         if config is not None:
             if config == 'config.txt':
                 config = os.path.join(os.path.dirname(os.path.realpath(__file__)), config)
             if Graph.CONFIG_GRAPH is not None and Graph.CONFIG_FILENAME == config:
                 self._config = Graph.CONFIG_GRAPH
             else:
-                self._config = Graph(config, complement={'readas': 'database'}, config=None)
+                self._config = Graph(config, complement={'readas': 'database'},
+                                     config=None)
                 if self.CONFIG_FILENAME is None:
                     Graph.CONFIG_FILENAME = config
                     Graph.CONFIG_GRAPH = self._config
         # actually load the file
         self.reset(filename, complement=complement, silent=silent)
 
     def reset(self, filename, complement='', silent=True):
@@ -219,29 +223,33 @@
         self.sampleInfo = {}
         # try identify and parse the datafile
         if isinstance(filename, str) and filename == '':
             if not self.silent:
                 print('Empty Graph object created')
             return
         if isinstance(filename, str):
-            # if single file was provided - a string, or if filename is the content if the file - complement['isfilecontent'] must be true
+            # if single file was provided - a string, or if filename is the
+            # content if the file - complement['isfilecontent'] must be true
             GraphIO.readDataFile(self, complement=complement)
         else:
-            if len(filename) == 2 and len(filename[0]) == len(filename[1]) and is_number(filename[0][0]):
+            if (len(filename) == 2 and len(filename[0]) == len(filename[1])
+                    and is_number(filename[0][0])):
                 # filename is actually the data, filename is a list
                 if not self.silent:
                     print('Class Graph: interpret "filename" as data content')
                 self.filename = ''
                 GraphIO.dataFromVariable(self, filename, attributes=complement)
             else:
-                # if a list was provided - open first file, then merge the others one by one
+                # if a list was provided - open first file, then merge the
+                # others one by one
                 if not isinstance(complement, list):
                     if complement != '':
-                        print('WARNING class Graph: complement must be a list if filename is a list.')
-                        print('   filename:', len(filename), 'element, complement:', complement)
+                        print('WARNING class Graph: complement must be a list',
+                              'if filename is a list. Filename', len(filename),
+                              'elements, complement:', complement)
                     complement = [complement] * len(filename)
                 self.filename = filename[0]
                 GraphIO.readDataFile(self, complement[0])
                 if len(filename) > 1:
                     for i in range(1, len(filename)):
                         if len(complement) > 1:
                             self.merge(Graph(filename[i], complement=complement[i]))
@@ -250,24 +258,21 @@
         # last: want to have abspath and not relative
         if hasattr(self, 'filename'):
             self.filename = os.path.abspath(self.filename)
 
 # RELATED TO GUI
     def alterListGUI(self):
         out = []
-        out.append(['Linear', ['', ''], '']) # do not want to leave this completely empty (if no curve left)
+        out.append(['no transform', ['', ''], ''])  # default: normal plot
         for c in range(self.length()):
             for j in self.curve(c).alterListGUI():
                 if j not in out:
                     out.append(j)
         return out
 
-
-
-
     # "USUAL" CLASS METHODS
     def __str__(self):
         """ Returns some information about the class instance. """
         out = 'Content of Graph stored in file ' + self.filename + '\n'
         out += 'Content of headers:' + '\n'
         out += str(self.headers)
         out += '\nNumber of Curves: '+str(self.length())
@@ -276,25 +281,25 @@
     # interactions with other Graph objects
     def merge(self, graph):
         """ Add in a Graph object the content of another Graph object """
         # keep previous self.filename
         # copy data
         for x in graph.data:
             self.data.append(x)
-        # copy headers, unless already exists (in this case information is forgotten)
+        # copy headers, unless already exists (is so, info is lost)
         for key in graph.headers:
-            if not key in self.headers:
+            if key not in self.headers:
                 self.headers.update({key: graph.headers[key]})
-        # copy graphInfo, unless already exists (in this case information is forgotten)
+        # copy graphInfo, unless already exists (is so, info is lost)
         for key in graph.graphInfo:
-            if not key in self.graphInfo:
+            if key not in self.graphInfo:
                 self.graphInfo.update({key: graph.graphInfo[key]})
-        # copy sampleInfo, unless already exists (in this case information is forgotten)
+        # copy sampleInfo, unless already exists (is so, info is lost)
         for key in graph.sampleInfo:
-            if not key in self.sampleInfo:
+            if key not in self.sampleInfo:
                 self.sampleInfo.update({key: graph.sampleInfo[key]})
 
     # methods handling the bunch of curves
     def __len__(self):
         """ Returns the number of Curves. """
         return len(self.data)
 
@@ -308,16 +313,17 @@
 
     def length(self):
         """ Returns the number of Curve objects in the list. """
         return len(self.data)
 
     def curve(self, index):
         """ Returns the Curve object at index i in the list. """
-        if index >= self.length() or self.length() == 0:
-            print ('ERROR Class Graph method Curve: cannot find Curve (index',index,', max possible',self.length()-1,')')
+        if index >= len(self) or len(self) == 0:
+            print('ERROR Class Graph method Curve: cannot find Curve (index',
+                  index, ', max possible', len(self), ')')
             return
         return self.data[index]
 
     def curves(self, attr, value, strLower=False, strStartWith=False):
         """
         Returns a list of Curves which attribute attr == value (also same type)
         attr: the attribute to check. By default 'label'.
@@ -332,15 +338,16 @@
                 if strLower:
                     if isinstance(lbl, str):
                         lbl = lbl.lower()
                     if isinstance(value, str):
                         value = value.lower()
                 if lbl == value:
                     out.append(c)
-                elif isinstance(lbl, str) and strStartWith and lbl[:len(value)] == value:
+                elif (isinstance(lbl, str) and strStartWith
+                        and lbl[:len(value)] == value):
                     out.append(c)
         return out
 
     def iterCurves(self):
         """ Returns an iterator over the different Curves """
         for c in range(self.length()):
             yield self.curve(c)
@@ -387,52 +394,56 @@
                 self.deleteCurve(k)
         else:
             le0 = len(self.data)
             if is_number(i) and i < le0:
                 # delete data
                 del self.data[i]
                 # delete in headers
-                if 'collabels' in self.headers and i < len(self.headers['collabels']):
+                if ('collabels' in self.headers
+                        and i < len(self.headers['collabels'])):
                     if len(self.headers['collabels']) == 0:
                         del self.headers['collabels']
                     else:
                         del self.headers['collabels'][i]
-                if 'collabelsdetail' in self.headers: # certainly only useful for "databases"
+                if 'collabelsdetail' in self.headers:
+                    # certainly only useful for "databases"
                     for j in range(len(self.headers['collabelsdetail'])):
                         if i < len(self.headers['collabelsdetail'][j]):
                             del self.headers['collabelsdetail'][j][i]
                 # nothing to delete in graphInfo
                 # nothing to delete in sampleInfo
 
     def replaceCurve(self, newCurve, idx):
         """ Replaces a Curve with another. """
         if isinstance(newCurve, Curve):
             try:
                 self.data[idx] = newCurve
                 return True
             except Exception:
-                print ('Graph.replaceCurve: cannot add Curve at index', idx, '.')
+                print('Graph.replaceCurve: cannot add Curve at index', idx,
+                      '.')
         else:
-            print ('Graph.replaceCurve: newCurve is not a Curve (type', type(newCurve), ')')
+            print('Graph.replaceCurve: newCurve is not a Curve (type',
+                  type(newCurve), ')')
         return False
 
     def swapCurves(self, idx1, idx2, relative=False):
         """
         Exchange the Curves at index idx1 and idx2.
         For example useful to modify the plot order (and order in the legend)
         """
         if idx1 < -self.length() or idx1 >= self.length():
-            print ('Graph.swapCurves: idx1 not valid (value', idx1, ').')
+            print('Graph.swapCurves: idx1 not valid (value', idx1, ').')
             return False
         if relative:
             idx2 = idx1 + idx2
         if idx2 == idx1:  # swap with itself
             return True
         if idx2 < -self.length() or idx2 >= self.length():
-            print ('Graph.swapCurves: idx2 not valid (value', idx2, ').')
+            print('Graph.swapCurves: idx2 not valid (value', idx2, ').')
             return False
         swap = deepcopy(self.curve(idx1))
         self.data[idx1] = self.curve(idx2)
         self.data[idx2] = swap
         return True
 
     def moveCurveToIndex(self, idxsource, idxtarget):
@@ -443,17 +454,19 @@
 
     def reverseCurves(self):
         """ Reverse the order of the Curves. """
         self.data.reverse()
         return True
 
     def duplicateCurve(self, idx1):
-        """ Duplicate (clone) an existing curve and append it in the curves list."""
+        """
+        Duplicate (clone) an existing curve and append it in the curves list.
+        """
         if idx1 < -self.length() or idx1 >= self.length():
-            print ('Graph.duplicateCurve: idx1 not valid (value', idx1, ').')
+            print('Graph.duplicateCurve: idx1 not valid (value', idx1, ').')
             return False
         curve = deepcopy(self.curve(idx1))
         self.data.insert(idx1+1, curve)
 
     # methods handling content of curves
     def getCurveData(self, idx, ifAltered=True):
         if ifAltered:
@@ -473,114 +486,125 @@
         attributed to the 1st Curve object (unless ifAll=True), or if
         forceGraphInfo is True (then the undetermined keys are inserted in
         self.graphInfo)
         """
         for key in attributes:
             k = key.lower().replace('', '')
             try:
-                if   k in self.headersKeys:
+                if k in self.headersKeys:
                     if attributes[key] != '':
                         self.headers.update({k: attributes[key]})
                     elif k in self.headers:
                         del self.headers[k]
-                elif (k in self.graphInfoKeys or forceGraphInfo) or k.startswith('subplots'):
+                elif (k in self.graphInfoKeys or forceGraphInfo
+                        or k.startswith('subplots')):
                     if attributes[key] != '':
                         self.graphInfo.update({k: attributes[key]})
                     elif k in self.graphInfo:
                         del self.graphInfo[k]
-                    # by default nothing in sampleInfo, everything in the curves
+                    # by default nothing in sampleInfo, everything in curves
                 else:
                     if ifAll:
                         for i in range(self.length()):
                             self.curve(i).update({k: attributes[key]})
                     else:
                         self.curve(-1).update({k: attributes[key]})
             except Exception as e:
-                print('Error Graph.update: key', key, ' attributes', attributes, 'exception', e)
+                print('Error Graph.update: key', key, ' attributes',
+                      attributes, 'exception', e)
 
     def updateValuesDictkeys(self, *args, **kwargs):
         """
         Performs update({key1: value1, key2: value2, ...}) with
         arguments value1, value2, ... , (*args) and
         kwargument key=['key1', 'key2', ...]
         """
         if 'keys' not in kwargs:
-            print('Error Graph updateValuesDictkeys: "keys" key must be provided, must be a list of keys corresponding to the values provided in *args.')
+            print('Error Graph updateValuesDictkeys: "keys" key must be',
+                  'provided, must be a list of keys corresponding to the',
+                  'values provided in *args.')
             return False
         if len(kwargs['keys']) != len(args):
-            print('WARNING Graph updateValuesDictkeys: len of list "keys" argument must match the number of provided values (',len(args),' args provided, ',len(kwargs['keys']),' keys).')
+            print('WARNING Graph updateValuesDictkeys: len of list "keys"'
+                  'argument must match the number of provided values (',
+                  len(args), ' args provided, ', len(kwargs['keys']), ' keys)')
         lenmax = min(len(kwargs['keys']), len(args))
         for i in range(lenmax):
             self.update({kwargs['keys'][i]: args[i]})
         return True
 
     def delete(self, key, ifAll=False):
         """
-        Delete an attribute of the Graph if recognized as such, or of the curve.
-        Return the deleted attribute (except for attributes of curves if ifAll=True)
+        Delete an attribute of the Graph.
+        Return the deleted attribute as a dict
         """
         k = key.lower()
-        out = {}
-        if k in self.headersKeys:
-            if k in self.headers:
-                out.update({key: self.headers[k]})
-                del self.headers[k]
-        elif k in self.graphInfoKeys:
-            if k in self.graphInfo:
-                out.update({key: self.graphInfo[k]})
-                del self.graphInfo[k]
-        else:
-            if ifAll:
-                for i in range(self.length()):
-                    # cannot export in this case
-                    self.data[i].delete(key)
-            else:
-                out.update(self.curve(-1).delete(key))
+        out = {k: self.attr(k)}
+        self.update({k: ''})
         return out
+        # if k in self.headersKeys:
+        #     if k in self.headers:
+        #         out.update({key: self.headers[k]})
+        #         del self.headers[k]
+        # elif k in self.graphInfoKeys:
+        #     if k in self.graphInfo:
+        #         out.update({key: self.graphInfo[k]})
+        #         del self.graphInfo[k]
+        # else:
+        #     if ifAll:
+        #         for i in range(self.length()):
+        #             # cannot export in this case
+        #             self.data[i].delete(key)
+        #     else:
+        #         out.update(self.curve(-1).delete(key))
+        # return out
 
-    def attr(self, key, default=''):
-        """ Shorter alias to getAttribute. """
-        return self.getAttribute(key, default=default)
     def getAttribute(self, key, default=''):
+        """ Legacy alias to attr. """
+        return self.attr(key, default=default)
+
+    def attr(self, key, default=''):
         k = key.lower()
         if k in self.headers:
             return self.headers[k]
         if k in self.graphInfo:
             return self.graphInfo[k]
         if k in self.sampleInfo:
             return self.sampleInfo[k]
-        if self.length() > 0:
+        if len(self) > 0:
             return self[0].attr(k, default=default)
-#            return self.curve(0).getAttribute(k, default=default)
         return default
 
-    def deleteAttr(self, attrList):
-        out = {}
-        for key in attrList:
-            out.update({key: self.getAttribute(key)})
-            self.delete(key)
-        return out
+    # certainly useless
+    # def deleteAttr(self, attrList):
+    #     out = {}
+    #     for key in attrList:
+    #         out.update({key: self.attr(key)})
+    #         self.delete(key)
+    #     return out
 
     def castCurve(self, newtype, idx, silentSuccess=False):
         """
         Replace a Curve with another type of Curve with identical data and
         properties.
         """
-        if idx >= - self.length() and idx < self.length():
+        if idx >= - len(self) and idx < len(self):
             newCurve = self.curve(idx).castCurve(newtype)
             if isinstance(newCurve, Curve):
                 flag = self.replaceCurve(newCurve, idx)
                 if flag:
                     if not silentSuccess:
-                        print('Graph.castCurve: new Curve type:', self.curve(idx).classNameGUI() + '.')
+                        print('Graph.castCurve: new Curve type:',
+                              self.curve(idx).classNameGUI() + '.')
                 else:
                     print('Graph.castCurve')
                 return flag
         else:
-            print('Graph.castCurve: idx not in suitable range (', idx,', max', self.length(),').')
+            print('Graph.castCurve: idx not in suitable range (', idx, ', max',
+                  len(self), ').')
         return False
 
     def colorize(self, colorscale, sameIfEmptyLabel=False, avoidWhite=False, curvesselection=None):
         """
         Colorize a graph, by coloring each Curve along a colorscale gradient.
         """
         from grapa.colorscale import Colorscale
@@ -588,37 +612,40 @@
             colorscale = Colorscale(colorscale)
         # determines which curves on want to colorize
         curves = range(self.length())
         if curvesselection is not None:
             try:
                 curves = [int(c) for c in curvesselection]
             except Exception:
-                print('Graph.colorize Exception, please provide list of curves index to colorize')
+                print('Graph.colorize Exception, please provide list of',
+                      'curves index to colorize')
         # special cases
         if len(curves) < 1:
             return
         if len(curves) == 1:
-            self[curves[0]].update({'color': colorscale.valuesToColor(0.0, avoidWhite=avoidWhite)})
+            col = colorscale.valuesToColor(0.0, avoidWhite=avoidWhite)
+            self[curves[0]].update({'color': col})
             return
         # general case
         show = np.arange(len(curves))
-        if sameIfEmptyLabel: # if needs to have several curves with same color
+        if sameIfEmptyLabel:  # if needs to have several curves with same color
             show = np.array([0.0] * len(curves))
             val = 0.0
             for i in range(len(curves)):
                 show[i] = val
-                if self[curves[i]].attr('label') != '' and not self[curves[i]].isHidden():
+                if (self[curves[i]].attr('label') != ''
+                        and not self[curves[i]].isHidden()):
                     val += 1.0
                 elif i > 0:
                     show[i] = show[i-1]
-        cols = colorscale.valuesToColor(show/max(max(show),1.0), avoidWhite=avoidWhite)
+        cols = colorscale.valuesToColor(show/max(max(show), 1.0),
+                                        avoidWhite=avoidWhite)
         for i in range(len(curves)):
             self[curves[i]].update({'color': cols[i]})
 
-
     def applyTemplate(self, graph, alsoCurves=True):
         """
         Apply a template to the Graph object. The template is a Graph object
         which contains:
         - self.getAttributes listed in graphInfoKeys
         - self.curve(i).getAttributes listed in dataInfoKeysGraph
         alsoCurves: True also apply Curves properties, False only apply Graph
@@ -645,93 +672,103 @@
         """
         Modify all labels of the Graph, by replacing 'old' by 'new'
         """
         for c in self.iterCurves():
             c.update({'label': c.getAttribute('label').replace(old, new)})
 
     def checkValidText(self):
-        text = self.getAttribute('text', None)
-        texy = self.getAttribute('textxy', '')
-        targ = self.getAttribute('textargs', {})
+        text = self.attr('text', None)
+        texy = self.attr('textxy', '')
+        targ = self.attr('textargs', {})
         if text is None:
             self.update({'textxy': '', 'textargs': ''})
             return
         onlyfirst = False if isinstance(text, list) else True
         # transform everything into lists
+        text, texy, targ = self._checkValidTextInput(text, texy, targ)
+        if onlyfirst:
+            text, texy, targ = text[0], texy[0], targ[0]
+        if text != self.attr('text'):
+            print('Corrected attribute text', text, '(former',
+                  self.attr('text'), ')')
+        if texy != self.attr('textxy') and self.attr('textxy', None) is not None:
+            print('Corrected attribute textxy', texy, '(former',
+                  self.attr('textxy'), ')')
+        if targ != self.attr('textargs'):
+            print('Corrected attribute textargs', targ, '(former',
+                  self.attr('textargs'), ')')
+        self.update({'text': text, 'textxy': texy, 'textargs': targ})
+
+    def _checkValidTextInput(self, text, texy, targ):
         if not isinstance(text, list):
             text = [text]
         if not isinstance(targ, list):
             targ = [targ]
         if not isinstance(texy, list):
             texy = [texy]
-        if len(texy) == 2 and not isinstance(texy[0], (list, tuple)) and not texy in [['',''], ('','')]:
+        # print('_checkValidTextInput texy', texy, text[0])
+        if (len(texy) == 2 and not isinstance(texy[0], (list, tuple))
+                and texy[0] != '' and texy[1] != ''):
             texy = [texy]  # if texy was like (0.5,0.8)
         for i in range(len(targ)):
             if not isinstance(targ[i], dict):
-                # print('Graph.checkValidText targ set', i, '{} (previous', targ[i], ')')
                 targ[i] = {}
         for i in range(len(texy)):
             if not isinstance(texy[i], (tuple, list)):
-                # print('Graph.checkValidText texy set', i, '\'\' (previous', texy[i], ')')
                 texy[i] = ''
         while len(texy) < len(text):
             texy.append(texy[-1])
         while len(targ) < len(text):
             targ.append(targ[-1])
-        if onlyfirst:
-            text, texy, targ = text[0], texy[0], targ[0]
-        if text != self.getAttribute('text'):
-            print('Corrected attribute text', text, '(former', self.getAttribute('text'),')')
-        if texy != self.getAttribute('textxy') and self.getAttribute('textxy', None) is not None:
-            print('Corrected attribute textxy', texy, '(former', self.getAttribute('textxy'),')')
-        if targ != self.getAttribute('textargs'):
-            print('Corrected attribute textargs', targ, '(former', self.getAttribute('textargs'),')')
-        self.update({'text': text, 'textxy': texy, 'textargs': targ})
+        return text, texy, targ
 
     def addText(self, text, textxy, textargs=None):
         """
         Adds a text to be annotated in the plot, handling the not-so-nice
         internal implementation
+        text, textxy, textargs: as single elements, or as lists (1 item per
+        annotation)
         """
         if textargs is None:
             textargs = {}
         restore = []
-        restore.append({'text':     self.getAttribute('text'),
-                        'textxy':   self.getAttribute('textxy'),
-                        'textargs': self.getAttribute('textargs')})
+        restore.append({'text':     self.attr('text'),
+                        'textxy':   self.attr('textxy'),
+                        'textargs': self.attr('textargs')})
+        text, textxy, textargs = self._checkValidTextInput(text, textxy, textargs)
         attrs = {'text': text, 'textxy': textxy, 'textargs': textargs}
-        # TODO: ensure text, textxy and textargs if list have same length
-        if self.getAttribute('text', None) is None:
+        if self.attr('text', None) is None:
             self.update(attrs)
-        else:
-            if not isinstance(self.getAttribute('text'), list):
-                for key in attrs.keys(): # ensures attributes are list
-                    self.update({key: [self.getAttribute(key, '')]})
-            for key in attrs.keys():
-                self.update({key: self.getAttribute(key) + [attrs[key]]})
+        else:  # need to merge existing with new
+            self.checkValidText()  # makes sure existing info are as lists
+            for key in attrs:
+                self.update({key: self.attr(key) + attrs[key]})
+        self.checkValidText()
         return restore
 
-    def removeText(self):
+    def removeText(self, byId=-1):
+        """
+        By default, removes the last text annotation in the list
+        If byId is provided, removes the annotation with corresponding index
+        """
         restore = []
-        restore.append({'text':     self.getAttribute('text'),
-                        'textxy':   self.getAttribute('textxy'),
-                        'textargs': self.getAttribute('textargs')})
+        restore.append({'text':     self.attr('text'),
+                        'textxy':   self.attr('textxy'),
+                        'textargs': self.attr('textargs')})
         attrs = ['text', 'textxy', 'textargs']
-        if self.getAttribute('text', None) is None:
+        self.checkValidText()
+        if self.attr('text', None) is None:
             pass
         else:
-            if not isinstance(self.getAttribute('text'), list):
-                for key in attrs:  # ensures attributes are list
-                    self.update({key: [self.getAttribute(key, '')]})
             for key in attrs:
-                self.update({key: self.getAttribute(key)[:-1]})
+                tmp = self.attr(key)
+                del tmp[byId]
+                self.update({key: tmp})
         return restore
 
-
-
     # some mathemetical operation on curves
     def curvesAdd(self, idx0, idx1, interpolate=0, **kwargs):
         """ addition operation when only knowing curves indices """
         kwargs.update({'interpolate': interpolate, 'sub': False})
         return self.curve(idx0).__add__(self.curve(idx1), **kwargs)
 
     def curvesSub(self, idx0, idx1, interpolate=0, **kwargs):
@@ -750,48 +787,46 @@
             curve = kwargs['curve']
             m = kwargs['method']
             del kwargs['curve'], kwargs['method']
             return getattr(curve, m)(*args, graph=self, **kwargs)
 
     def _getAlter(self):
         """ returns the formatted alter instruction of self """
-        return self._getAlterToFormat(self.getAttribute('alter'))
+        return self._getAlterToFormat(self.attr('alter'))
 
     @classmethod
     def _getAlterToFormat(cls, alter):
         """ Return a formatted alter instruction """
         if alter == '':
             alter = ['', '']
         if isinstance(alter, str):  # nothing to do if it is dict
             alter = ['', alter]
         return alter
 
-
-
     def formatAxisLabel(self, label):
         """
         Returns a string for label according to user preference.
         'Some quantity [unit]' may become 'Some quantify (unit)'
         Other possible input is ['This is a Quantity', 'Q', 'unit']
         """
         # retrieve user preference
-        symbol= bool(self.config('graph_labels_symbols', False))
+        symbol = bool(self.config('graph_labels_symbols', False))
         units = self.config('graph_labels_units', default='[]', astype=str)
-        units = units.replace('unit', '').replace(' ','')
+        units = units.replace('unit', '').replace(' ', '')
         # format input
         if isinstance(label, str):
             if units != '[]':  # that is default, no need to do anything
-                expr = '^(.* )\[(.*)\](.*)$'
+                expr = r'^(.* )\[(.*)\](.*)$'  # [ ] as characters, not a set
                 if label != '':
                     f = refindall(expr, label)
                     if isinstance(f, list) and len(f) == 1 and len(f[0]) == 3:
                         if units in ['DIN', '/']:
-                            return f[0][0].strip(' ') + ' / ' + f[0][1] + '' + f[0][2]
+                            return f[0][0].strip(' ')+' / '+f[0][1]+''+f[0][2]
                         elif units == '()':
-                            return f[0][0].strip(' ') + '(' + f[0][1] + ')' + f[0][2]
+                            return f[0][0].strip(' ')+'('+f[0][1]+')'+f[0][2]
         elif isinstance(label, list):
             while len(label) < 3:
                 label += ['']
             out = label[0]
             if symbol and len(label[1]) > 0:
                 out += ' $' + label[1] + '$'
             if label[2] not in [None, ' ']:
@@ -810,23 +845,24 @@
         If key is not defined, returns default.
         """
         if hasattr(self, '_config') and self._config.length() > 0:
             out = self._config.curve(0).getAttribute(key, default=default)
             if astype in [str, 'str']:
                 return str(out)
             else:
-                return stringToVariable(out)
+                return strToVar(out)
         return default
 
     def filenamewithpath(self, filename):
         # if relative, join the path of the file with
         if os.path.isabs(filename):
             return filename
         path = ''
-        if hasattr(self, 'filename') and isinstance(self.filename, str) and len(self.filename) > 0:
+        if (hasattr(self, 'filename') and isinstance(self.filename, str)
+                and len(self.filename) > 0):
             path = os.path.dirname(os.path.abspath(self.filename))
         return os.path.join(path, filename)
 
     # For convenience we offer a shortcut to GraphIO.export
     def export(self, filesave='', saveAltered=False, ifTemplate=False,
                ifCompact=True, ifOnlyLabels=False, ifClipboardExport=False):
         """
@@ -868,12 +904,12 @@
             ifSave = False if filesave == '' else True
         if ifExport not in [True, False]:
             ifExport = False if filesave == '' else True
         from grapa.graphIO import GraphIO
         if ifSubPlot not in [True, False]:
             ifSubPlot = False
             if (figAx is not None and isinstance(figAx, list)
-                and len(figAx) > 1 and figAx[1] is not None):
+                    and len(figAx) > 1 and figAx[1] is not None):
                 ifSubPlot = True
-        return GraphIO.plot(self, filesave=filesave, imgFormat=imgFormat, figsize=figsize,
-                            ifSave=ifSave, ifExport=ifExport, figAx=figAx,
-                            ifSubPlot=ifSubPlot)
+        return GraphIO.plot(self, filesave=filesave, imgFormat=imgFormat,
+                            figsize=figsize, ifSave=ifSave, ifExport=ifExport,
+                            figAx=figAx, ifSubPlot=ifSubPlot)
```

### Comparing `grapa-0.5.4.8/grapa/graphIO.py` & `grapa-0.6.1.0/grapa/graphIO.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,37 +1,36 @@
 # -*- coding: utf-8 -*-
 """
 Created on Tue Jun 13 22:38:05 2017
 
 @author: Romain Carron
-Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+Copyright (c) 2023, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
 """
 
 import os
 import sys
 import ast
-import codecs
 import importlib
 import numpy as np
 import warnings
 
 from re import split as resplit, findall as refindall, sub as resub
 from copy import deepcopy
 
 with warnings.catch_warnings():
     warnings.simplefilter('ignore')
     import matplotlib.pyplot as plt
     import matplotlib as mpl
 
 from grapa.graph import Graph
 from grapa.curve import Curve
-from grapa.mathModule import is_number, stringToVariable
+from grapa.mathModule import is_number, strToVar, varToStr, strUnescapeIter
 from grapa.curve_inset import Curve_Inset
 from grapa.curve_subplot import Curve_Subplot
-from grapa.curve_image import Curve_Image # needed for curve casting
+from grapa.curve_image import Curve_Image  # needed for curve casting
 from grapa.graphIO_aux import ParserAxhline, ParserAxvline
 
 
 FILEIO_GRAPHTYPE_DATABASE = 'Database'
 FILEIO_GRAPHTYPE_GRAPH = 'Graph'
 FILEIO_GRAPHTYPE_UNDETERMINED = 'Undetermined data type'
 
@@ -82,15 +81,15 @@
         if cls.childClasses is not None:
             return cls.childClasses
         folder = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'datatypes')
         required = ['FILEIO_GRAPHTYPE', 'isFileReadable', 'readDataFromFile']
         subclasses = []
         for filestart in ['graph', 'curve']:
             for file in os.listdir(folder):
-                fileName , fileExt = os.path.splitext(file)
+                fileName, fileExt = os.path.splitext(file)
                 if (fileExt == '.py' and fileName[:len(filestart)] == filestart
                         and len(fileName) > len(filestart)):
                     end = fileName[len(filestart):]
                     module = importlib.import_module('grapa.datatypes.'+fileName)
                     if not hasattr(module, 'Graph'+end):
                         continue
                     typeM = getattr(module, 'Graph'+end)
@@ -133,17 +132,18 @@
 
     def readDataFile(self, complement=''):
         """
         Reads a file.
         Complement: ...
         Opens file self.filename
         """
-        self.isFileContent = True if (isinstance(complement, dict)
-                                      and 'isfilecontent' in complement
-                                      and complement['isfilecontent']) else False
+        self.isFileContent = False
+        if (isinstance(complement, dict) and 'isfilecontent' in complement
+                and complement['isfilecontent']):
+            self.isFileContent = True
         # reads the file to identify types
         if not self.isFileContent:
             fileName, fileExt = os.path.splitext(self.filename)
             fileExt = fileExt.lower()
         else:
             fileName, fileExt = '', '.txt'
         fileNameBase = fileName.split('/')[-1].split('\\')[-1]
@@ -152,15 +152,15 @@
             if isinstance(complement, dict):
                 for key in complement:
                     attributes.update({key.lower(): complement[key]})
             else:
                 attributes.update({'complement': complement})
         # default attributes of curve
         if 'label' not in attributes:
-            attributes.update({'label': fileName.split('/')[-1].split('\\')[-1].replace('_', ' ').replace('  ',' ')})
+            attributes.update({'label': fileName.split('/')[-1].split('\\')[-1].replace('_', ' ').replace('  ', ' ')})
         # default (mandatory) attributes of Graph
         for key in ['subplots_adjust', 'fontsize']:
             if key in attributes:
                 self.update({key: attributes[key]})
                 del attributes[key]
             else:
                 self.update({key: Graph.DEFAULT[key]})
@@ -205,15 +205,16 @@
         if not loaded:
             childClasses = GraphIO._listGraphChildClasses()
     #        print(childClasses)
             for child in childClasses:
                 if child.isFileReadable(fileNameBase, fileExt, line1=line1, line2=line2, line3=line3):
                     msg = 'opened as ' + child.FILEIO_GRAPHTYPE + '.'
                     self.headers.update({'meastype': child.FILEIO_GRAPHTYPE})
-                    res = child.readDataFromFile(self, attributes, fileName=fileNameBase, line1=line1, line2=line2, line3=line3)
+                    res = child.readDataFromFile(self, attributes, fileName=fileNameBase, line1=line1, line2=line2,
+                                                 line3=line3)
                     if res is None or res != False:
                         loaded = True
                         break
         # if not, then try default methods
         if not loaded:
             # other not readable formats
             if fileExt in ['.pdf']:
@@ -281,61 +282,73 @@
 
     def _readDataIdentifyDelimiter(self, lines):
         # determine data character separator - only useful if reads file,
         # otherwise is supposed to be already separated
         delimiter = '\t'
         nTab = np.sum([line.count('\t') for line in lines])
         threshold = np.ceil(max(1, len(lines)-5) / 2)
-        if nTab < threshold: # if really not enough tabs in the file to be reasonable that data are tab-separated
+        if nTab < threshold:
+            # if really not enough tabs in the file to be reasonable that data
+            # are tab-separated
             delimiters = [',', ';', ' ']
             for s in delimiters:
                 n = np.sum([line.count(s) for line in lines])
                 if n > threshold:
                     delimiter = s
                     print ('Graph file generic: data delimiter identified as "'+s+'".')
                     break
         return delimiter
 
-    def readDataFromFileGeneric(self, attributes, fileContent=None,
-                                ifReplaceCommaByPoint=False, **kwargs):
+    def readDataFromFileGeneric(self, attributes, fileContent=None, ifReplaceCommaByPoint=False, **kwargs):
         """
         Reads the file as a column-organized data file, with some headers
         lines at the beginning.
         kwargs: are handled the following keywords:
         - delimiter: if provided, assumed the values is the text delimiter.
         - delimiterHeaders: same as delimiter, but only for the headers section
+        - lstrip: a lstrip function is applied to each line when parsing they
+          file. Values: True, or '# ' or similar
         """
         # idea:
         # 1/ read headers, store values in headers or in sampleInfo.
         # 2/ read data, identify data structure
         # 3/ look back at headers to fill in dataInfo according to data
         #    structure
         # if fileContent provided, file is not read and fileContent is used
         # instead. Supposed to be a 2-dimensional list [line][col]
 
+        # parsing inputs
+        lstriparg = None
+        if 'lstrip' in kwargs:
+            if kwargs['lstrip'] == True:
+                lstriparg = []
+            elif isinstance(kwargs['lstrip'], str):
+                lstriparg = [kwargs['lstrip']]
         # update default information
         self.data = []
         parsedAttr = {}
-        fileName, fileext = os.path.splitext(self.filename) # , fileExt=
-        self.headers.update({'sample': fileName.split('/')[-1], 'meastype': FILEIO_GRAPHTYPE_UNDETERMINED})
-        singlecurve= False
+        fileName, fileext = os.path.splitext(self.filename)  # , fileExt=
+        self.headers.update({'meastype': FILEIO_GRAPHTYPE_UNDETERMINED})
+        singlecurve = False
         if '_singlecurve' in attributes and attributes['_singlecurve']:
             singlecurve = True
             del attributes['_singlecurve']
 
         skipLines = 0
         skipFooters = 0
         lastSampleInfo = ''  # key of last saved parameter
         lastLine = ''
         colLabels = []
         # load content of file
         if fileContent is None:  # default behavior
             lines = [line.rstrip(':\r\n\t') for line in open(self.filename, 'r')]
             if ifReplaceCommaByPoint:
                 lines = [resub('(?P<a>[0-9]),(?P<b>[0-9])', lambda word: word.group('a')+'.'+word.group('b'), line) for line in lines]
+            if lstriparg is not None:
+                lines = [line.lstrip(*lstriparg) for line in lines]
         else:  # if some content was provided
             lines = fileContent
         # identify data separator (tab, semicolumn, etc.)
         if 'delimiter' in kwargs and isinstance(kwargs['delimiter'], str):
             delimiter = kwargs['delimiter']
         else:
             delimiter = GraphIO._readDataIdentifyDelimiter(self, lines)
@@ -350,36 +363,44 @@
         for line in lines:
             if fileContent is None:
                 couple = splitline(line, delimiter)
             else:
                 couple = line
             # stops looping at first line with numerical values
             if is_number(couple[0]):
-                isLabelDefault = True if 'label' in attributes and 'filename' in attributes and attributes['label'] == '.'.join(attributes['filename'].split('\\')[-1].split('/')[-1].split('.')[:-1]).replace('_',' ') else False
+                isLabelDefault = False
+                if ('label' in attributes and 'filename' in attributes
+                        and attributes['label'] == '.'.join(attributes['filename'].split('\\')[-1].split('/')[-1].split('.')[:-1]).replace('_',' ')):
+                    isLabelDefault = True
                 if len(lastLine) == 1:
                     couple2 = splitline(lastLine[0], delimiter)
                     if len(couple2) > 1:
                         lastLine = couple2
                 if (lastSampleInfo != ''
-                    and ('label' not in attributes
-                        or (isLabelDefault and len(lastLine) > 1
-                            and lastSampleInfo not in self.graphInfoKeys + self.headersKeys + self.dataInfoKeysGraph))):
-                    # if some column names were identified, try to define labels by concatenating filename stripped from numerics with colum name
-                    lbl = attributes['label'].split(' ') if 'label' in attributes else ['']
+                        and ('label' not in attributes
+                             or (isLabelDefault and len(lastLine) > 1
+                             and lastSampleInfo not in self.graphInfoKeys + self.headersKeys + self.dataInfoKeysGraph))):
+                    # if some column names were identified, try to define
+                    # labels by concatenating filename stripped from numerics
+                    # with colum name
+                    lbl = ['']
+                    if 'label' in attributes:
+                        lbl = attributes['label'].split(' ')
                     for i in range(len(lbl)-1, -1, -1):
                         try:
                             float(lbl[i])
                             del lbl[i]
                         except ValueError:
-                            if lbl[i] in['File']:
+                            if lbl[i] in ['File']:
                                 del lbl[i]
                     suff = ' '.join(lbl)
                     if len(suff) > 1:
                         suff += ' '
-                    colLabels = [suff + l.replace('"','') for l in lastLine]
+                    # colLabels
+                    colLabels = [suff + str(l).replace('"', '') for l in lastLine]
                     if 'label' in attributes:
                         del attributes['label']
                 # don't save last couple, intepreted as column name
                 break
             # if not numerical value -> still information
             else:
                 skipLines += 1
@@ -387,80 +408,78 @@
                 if delimiterHeaders is not None and fileContent is None:
                     couple = splitline(line, delimiterHeaders)
                 # interpret data
                 if couple[0] == '':
                     if len(couple) == 1 or len(''.join(couple)) == 0:
                         continue
                     couple[0] = 'empty'+str(numEmpty)
-                    numEmpty+= 1
+                    numEmpty += 1
                 val = couple[0]
                 if len(couple) > 1:
                     val = float(couple[1]) if is_number(couple[1]) else couple[1]
                 # all keywords in lowercase
                 if not is_number(couple[0]):
                     couple[0] = couple[0].lower()
 
-                # conversion from matlab terminology
+                # conversion from matlab terminology, or legacy keywords
                 if couple[0] == 'figuresize':
                     couple[0] = 'figsize'
                     try:
                         if len(ast.literal_eval(val)) == 4:
                             val = ast.literal_eval(val)
                             val = val[2:4]
                             if min(val) > 30:
-                                # assumes units are given in pixels -> convert in inches, assuming FILEIO_DPI screen resolution
+                                # assumes units are given in pixels -> convert
+                                # in inches, assuming FILEIO_DPI screen resolut
                                 val = [x / self.FILEIO_DPI for x in val]
                     except Exception:
-                        print('GraphIO.readDataFromFileGeneric: Error when setting figure size')
-                replace = {'facealpha': 'alpha'}
+                        print('GraphIO.readDataFromFileGeneric: Error when',
+                              'setting figure size')
+                replace = {'facealpha': 'alpha',
+                           'legendlocation': 'legendproperties'}
                 if couple[0] in replace:
                     couple[0] = replace[couple[0]]
-                # other conversion
-                if couple[0] == 'legendlocation':
-                    couple[0] = 'legendproperties'
                 # end of matlab conversion
-
                 # identify headers values
-                if couple[0] in ['sampleInfo', 'meastype']:
-                    self.headers[couple[0]] = val
+                if couple[0] in self.headersKeys:
+                    self.headers[couple[0]] = strToVar(val)
                 # identify graphInfo values
-                elif couple[0] in ['text']:
-                    self.graphInfo[couple[0]] = codecs.decode(val, 'unicode_escape')
-                    tmp = stringToVariable(self.graphInfo[couple[0]].replace('\n','\\n').replace('\\t','\\\\t'))
-                    if isinstance(tmp, list): # only if list, otherwise not want stringToVariable
-                        self.graphInfo[couple[0]] = tmp
-                elif couple[0] in ['legendproperties']:
-                    if not isinstance(val, (int, float)):
-                        val = stringToVariable(val)
-                    self.graphInfo[couple[0]] = val
-                elif couple[0] in self.graphInfoKeys or couple[0].startswith('subplots'): # standard reading for graphinfo parameters
-                    self.graphInfo[couple[0]] = stringToVariable(val)
+                elif (couple[0] in self.graphInfoKeys
+                        or couple[0].startswith('subplots')):
+                    self.graphInfo[couple[0]] = strToVar(val)
                 # send everything else in Curve, leave nothing for sampleInfo
                 else:
-                    couple[0] = couple[0].replace('legend', 'label').replace('','2').replace('xycurve', 'curve')
-                    if couple[0] in ['label']:
-                        couple = [couple[0]] + [cpl.replace('\\n','\n').replace('\t','\\t') for cpl in couple[1:]]
+                    # do not use val
+                    rep = {'legend': 'label', '': '2', 'xycurve': 'curve'}
+                    for key in rep:
+                        couple[0] = couple[0].replace(key, rep[key])
+                    # format values
+                    if couple[0] in ['filename']:  # don't want backslashes
+                        for i in range(1, len(couple)):
+                            couple[i] = couple[i].replace('\\', '/')
+                    # deal with escape sequences
+                    for i in range(1, len(couple)):
+                        if couple[0] in ['label']:
+                            # enforce type str (e.g. label '1' and not 1.00)
+                            couple[i] = strUnescapeIter(couple[i])
+                        else:
+                            couple[i] = strToVar(couple[i])
+                    # store to use later
                     parsedAttr.update({couple[0]: couple})
 
-                if couple[0] in self.graphInfo:
-                    if isinstance(self.graphInfo[couple[0]], str):
-                        self.graphInfo[couple[0]] = self.graphInfo[couple[0]].replace('\\n', '\n')
-                    elif isinstance(self.graphInfo[couple[0]], list):
-                        for i in range(len(self.graphInfo[couple[0]])):
-                            if isinstance(self.graphInfo[couple[0]][i], str):
-                                self.graphInfo[couple[0]][i] = self.graphInfo[couple[0]][i].replace('\\n', '\n')
-
                 lastSampleInfo = couple[0]
                 lastLine = couple
         # check that text input are correct
         self.checkValidText()
+        # print('GraphIO parsedAttr', parsedAttr)
         # if must parse last "header" line nevertheless (first element blank)
         if singlecurve and len(lastLine) > 1 and lastLine[0].startswith('empty'):
             linei = skipLines - 1
-            # retrieve last header line and first content and compare if positions of numeric match
+            # retrieve last header line and first content and compare if
+            # positions of numeric match
             couple1 = []
             if fileContent is None:
                 couple0 = splitline(lines[linei], delimiter)
                 if linei+1 < len(lines):
                     couple1 = splitline(lines[linei+1], delimiter)
             else:
                 couple0 = lines[linei]
@@ -484,24 +503,26 @@
                 self.graphInfo['xlabel'] = colLabels[0]
             if 'ylabel' not in self.graphInfo and len(colLabels) > 1:
                 self.graphInfo['ylabel'] = colLabels[1]
 
         while lines[-1] == '':
             lines.pop()
             skipFooters += 1
-        skipFooters = 0  # do not understand it... genfromtxt can fail when files ends with several \n and this is not set!?
+        # do not understand it... genfromtxt can fail when files ends with
+        # several \n and this is not set!?
+        skipFooters = 0
 
         # look for data in file after headers
         if skipLines < len(lines):
             # default behavior
             if fileContent is None:
-                usecols = range(0,len(lines[skipLines].split(delimiter)))
+                usecols = range(0, len(lines[skipLines].split(delimiter)))
                 dictConverters = {}
                 if ifReplaceCommaByPoint:
-                    lambd = lambda x: float(str(str(x, 'UTF-8')).replace(',','.'))
+                    lambd = lambda x: float(str(str(x, 'UTF-8')).replace(',', '.'))
                     for i in usecols:
                         dictConverters.update({i: lambd})
                 genFromTxtOpt = {}
                 if len(dictConverters) > 0:
                     genFromTxtOpt.update({'converters': dictConverters})
                 data = np.transpose(np.genfromtxt(self.filename, skip_header=skipLines, delimiter=delimiter, invalid_raise=False, usecols=usecols, skip_footer=skipFooters, **genFromTxtOpt))
             else:
@@ -509,71 +530,75 @@
                 for i in range(skipLines, len(fileContent)-skipFooters):
                     for j in range(len(fileContent[i])):
                         fileContent[i][j] = np.float64(fileContent[i][j]) if fileContent[i][j] != '' and is_number(fileContent[i][j]) else np.nan
                 data = np.transpose(np.array(fileContent[skipLines:]))
             colX = 0
             cols = []
 
-            # some checks, and build array test -> know which data column are not empty (returned as nan values)
+            # some checks, and build array test -> know which data column are
+            # not empty (returned as nan values)
             if len(data.shape) < 2 and len(lines) == skipLines + 1:
                 # only 1 data row
                 test = [np.isnan(v) for v in data]
                 data = data.reshape((len(data), 1))
             else:
                 if len(data.shape) < 2 and len(lines) > skipLines + 1:
                     # if only 1 data colum
                     data = np.array([range(len(data)), data])
                     for key in parsedAttr:
                         parsedAttr[key] = [parsedAttr[key][0]] + parsedAttr[key]
-                test = [np.isnan(data[i,:]).all() for i in range(data.shape[0])]
+                test = [np.isnan(data[i, :]).all() for i in range(data.shape[0])]
             # if still cannot define colLabels
             if 'collabels' not in self.headers:
                 self.headers['collabels'] = [''] * len(test)
                 if len(data.shape) < 2:
                     self.headers['collabels'] = [''] * 2
-            # do not fill in 'filename', or 'label' default value if filename is amongst the file parameters
+            # do not fill in 'filename', or 'label' default value if filename
+            # is amongst the file parameters
             for key in parsedAttr:
                 if key in attributes:
                     del attributes[key]
-            if 'label' not in parsedAttr and 'collabels' in self.headers :
+            if 'label' not in parsedAttr and 'collabels' in self.headers:
                 parsedAttr['label'] = self.headers['collabels']
 
             # parse through data
             if singlecurve:
                 self.data.append(Curve(data, attributes))
                 cols.append(1)
             for colY in range(1, len(test)):  # normal column guessing
                 # if nan -> column empty -> start new xy pair
                 if test[colY]:
                     colX = colY + 1
                 elif colY > colX:
                     # removing of nan pairs is performed in the Curve constructor
-                    self.data.append(Curve(np.append(data[colX,:], data[colY,:]).reshape((2, len(data[colY, :]))), attributes))
+                    self.data.append(Curve(np.append(data[colX, :], data[colY, :]).reshape((2, len(data[colY, :]))), attributes))
                     cols.append(colY)
             if len(cols) > 0:
                 # correct parsedAttr to match data structure
                 if len(self.headers['collabels']) <= max(cols):
+                    # print('graphio file', self.filename, 'extend collables',
+                    #       len(self.headers['collabels']),
+                    #       type(self.headers['collabels']),
+                    #       self.headers['collabels'])
                     self.headers['collabels'].extend([''] * max(cols))
                 self.headers['collabels'] = [self.headers['collabels'][i] for i in cols]
                 # apply parsedAttr to different curves
                 for key in parsedAttr:
                     if len(parsedAttr[key]) < max(cols):
                         parsedAttr[key].extend([''] * max(cols))
                     for i in range(len(cols)):
                         try:
                             val = parsedAttr[key][cols[i]]
                         except IndexError:
                             continue
-                        if key not in ['label']:  # for 'label', want to keep as string
-                            val = stringToVariable(val)
                         if val != '':
                             self.curve(i).update({key: val})
                 # cast Curve in child class if required by parameter read
                 for c in range(self.length()):
-                    newtype = self.curve(c).getAttribute('curve')
+                    newtype = self.curve(c).attr('curve')
                     if newtype not in ['', 'curve', 'curvexy']:
                         self.castCurve(newtype, c, silentSuccess=True)
 
     def readDataFromFileDatabase(self, attributes, fileContent=None, **kwargs):
         """
         fileContent: list of lists containing file content (imagine csv file)
         kwargs: useless here
@@ -591,15 +616,16 @@
                     fileContent[i][j] = fileContent[i][j].replace('\\n', '\n')
         # max length of a line
         fileNcols = max([len(fileContent[i]) for i in range(len(fileContent))])
 
         # start processing - identify column names
         self.headers.update({'collabelsdetail': [], 'rowlabels': [], 'rowlabelnums': []})
         # check if further lines as header - must be pure text lines.
-        # we store lines consisting only in a pair of elements. In this case this should not be a column name, instead we will self.update()
+        # we store lines consisting only in a pair of elements. In this case
+        # this should not be a column name, instead we will self.update()
         toUpdate = {}
         for i in range(0, len(fileContent)):
             line = fileContent[i]
             onlyText = True
             nVal = 0
             for val in line:
                 if is_number(val):
@@ -624,115 +650,119 @@
         nLinesHeaders = len(self.headers['collabelsdetail']) + len(toUpdate)
         labels = [''] * (fileNcols-1)
         for i in range(len(self.headers['collabelsdetail'])):
             for j in range(1, len(self.headers['collabelsdetail'][i])):
                 labels[j-1] = labels[j-1] + '\n' + self.headers['collabelsdetail'][i][j]
         for i in range(len(labels)):
             labels[i] = labels[i][1:].strip('\n ')
-        self.headers.update({'collabels': labels[:]}) # want a hard-copy here
+        self.headers.update({'collabels': labels[:]})  # want a hard-copy here
 
         # parsing content
         if len(self.data) > 0:
-            print('Class GraphIO.readDataFromDatabaseFile, data container NOT empty. Content of data deleted, previous data lost.')
+            print('Class GraphIO.readDataFromDatabaseFile, data container NOT'
+                  'empty. Content of data deleted, previous data lost.')
         self.data = []
         # fill the Curve object with list of Curves, still empty at this stage
         for i in range(fileNcols - 1):
-            self.data.append(Curve(np.zeros((2, len(fileContent)-nLinesHeaders)), attributes))
+            self.data.append(Curve(np.zeros((2, len(fileContent)-nLinesHeaders)),
+                                   attributes))
             self.data[-1].update({'label': labels[i]})
 
         # update the header info
         # first change datatype for display purposes
         for key in toUpdate:
             if key in ['color']:
-                toUpdate[key] = stringToVariable(toUpdate[key])
+                toUpdate[key] = strToVar(toUpdate[key])
         self.update(toUpdate, ifAll=True)
 
         # loop over rows
         for i in range(len(fileContent)-nLinesHeaders):
             line = fileContent[i+nLinesHeaders]
             self.headers['rowlabels'].append(line[0])
             try:
-                # self.headers['rowlabelnums'].append(float(''.join(ch for ch in line[0] if ch.isdigit() or ch=='.')))
+                # self.headers['rowlabelnums'].append(float(''.join(ch for ch
+                # in line[0] if ch.isdigit() or ch=='.')))
                 split = refindall('([0-9]*[.]*[0-9]*)', line[0])
                 split = [s for s in split if len(s) > 0]
                 # print (line[0], split)
                 if len(split) > 0:
                     self.headers['rowlabelnums'].append(float(split[0]))
                 else:
                     self.headers['rowlabelnums'].append(np.nan)
             except Exception:
                 self.headers['rowlabelnums'].append(np.nan)
             for j in range(len(line)-1):
                 self.data[j].setX(self.headers['rowlabelnums'][-1], index=i)
                 if is_number(line[j+1]):
                     self.data[j].setY(float(line[j+1]), index=i)
 
-
-
     def filesave_default(self, filesave=''):
         """ (private) default filename when saving. """
         if filesave == '':
             fileName = self.filename.split('\\')[-1].split('/')[-1].replace('.', '_')
             filesave = fileName + '_'
             if self.length() > 0:
-                filesave += self.curve(-1).getAttribute('complement')
+                filesave += self.curve(-1).attr('complement')
             if filesave == '_':
                 filesave = 'graphExport'
             if len(self.data) > 1:
                 filesave = filesave + '_series'
         return filesave
 
-
-    def export(self, filesave='', saveAltered=False, ifTemplate=False,
-               ifCompact=True, ifOnlyLabels=False, ifClipboardExport=False):
+    def export(self, filesave='', saveAltered=False, ifTemplate=False, ifCompact=True, ifOnlyLabels=False, ifClipboardExport=False):
         """
         Exports content of Grah object into a human- and machine- readable
         format.
         """
         if len(filesave) > 4 and filesave[-4:] == '.xml':
-            return GraphIO.exportXML(self, filesave=filesave, saveAltered=saveAltered)
+            return GraphIO.exportXML(self, filesave=filesave,
+                                     saveAltered=saveAltered)
         # retrieve information of data alteration (plotting mode)
-        alter = self.getAttribute('alter')
+        alter = self.attr('alter')
         if alter == '':
             alter = ['', '']
         if isinstance(alter, str):
             alter = ['', alter]
         # handle saving of original data or altered data
         tempAttr = {}
-        if saveAltered:  # if modified parameter, want to save modified data, and not save the alter attribute
-            tempAttr = self.deleteAttr(['alter'])
+        if saveAltered:
+            # if modified parameter, want to save modified data, and not save
+            # the alter attribute
+            tempAttr.update({'alter': self.attr('alter')})
+            self.update({'alter': ''})
         else:
             alter = ['', '']  # want to save original data, and alter atribute
         # preparation
         dataLe1 = 0
         out = ''
         # format general information for graph
-        # template: do not wish any other information than graphInfo -> that looks good
-        if not ifOnlyLabels:  # if ifOnlyLabels: only export label argument
+        # template: do not wish any other information than graphInfo -> ok
+        if not ifOnlyLabels:
+            # ifOnlyLabels: only export label argument
             for key in self.graphInfo:
-                out = out + key + '\t' + str(self.graphInfo[key]).replace('\n', '\\n') + '\n'
+                out = out + key + '\t' + varToStr(self.graphInfo[key]) + '\n'
             if not ifTemplate:
                 keyListHeaders = ['meastype']
                 for key in keyListHeaders:
                     if key in self.headers:
-                        out = out + key + '\t' + str(self.headers[key]).replace('\n', '\\n') + '\n'
+                        out = out + key + '\t' + varToStr(self.headers[key]) + '\n'
         # if compact mode, loop over curves to identify consecutive with identical x axis
         separator = ['\t'] + ['\t\t\t'] * (self.length()-1) + ['\t']
         if ifCompact and not ifTemplate:
             for i in range(self.length()):
-                if i > 0 and np.array_equal(self.curve(i).x(), self.curve(i-1).x()):
+                if i > 0 and np.array_equal(self[i].x(), self[i-1].x()):
                     separator[i] = '\t'
         # format information for graph specific for each curve
-        # first establish list of attributes, then loop over curves to construct export
+        # first establish list of attributes, then loop over curves to
+        # construct export
         keysList = ['label']
         if not ifOnlyLabels:  # if ifOnlyLabels: only export label argument
             for c in range(self.length()):
                 for attr in self.curve(c).getAttributes():
                     if attr not in keysList:
-                        # print ('Graph export', attr, keysList, attr in self.dataInfoKeysGraph, (not ifTemplate))
                         if attr in self.dataInfoKeysGraph or (not ifTemplate):
                             keysList.append(attr)
         # if save altered Curce export curves modified for alterations and
         # offsets, and delete offset and muloffset key
         if saveAltered:
             funcx, funcy = Curve.x_offsets, Curve.y_offsets
             if 'offset' in keysList:
@@ -741,19 +771,19 @@
                 keysList.remove('muloffset')
         else:
             funcx, funcy = Curve.x, Curve.y
         # proceed with file writing
         keysList.sort()
         for key in keysList:
             out = out + key
-            for c in range(self.length()):
-                value = self.curve(c).getAttribute(key)
+            for c in range(len(self)):
+                value = self[c].attr(key)
                 if isinstance(value, np.ndarray):
                     value = list(value)
-                out = out + separator[c] + str(value).replace('\n', '\\n')
+                out = out + separator[c] + varToStr(value)
             out = out.rstrip('\t') + '\n'
         # format data
         for curve in self.data:
             if curve.shape(1) > dataLe1:
                 dataLe1 = curve.shape(1)
         separator[0] = '\t\t\t'
         for i in range(dataLe1):
@@ -783,48 +813,50 @@
         self.update(tempAttr)
         # end: return data, or save file
         if ifClipboardExport:
             return out
         else:
             # output
             filename = GraphIO.filesave_default(self, filesave) + '.txt'
-            if self.getAttribute('saveSilent') != True:
+            if self.attr('saveSilent') != True:
                 print('Graph data saved as', filename.replace('/','\\'))
+            self.fileexport = os.path.normpath(filename)
             f = open(filename, 'w')
             try:
                 f.write(out)
             except UnicodeEncodeError as e:
-                # give some details to the user, otherwise can become quite difficult to identify where the progrem originates from
+                # give some details to the user, otherwise can become quite
+                # difficult to identify where the progrem originates from
                 print('ERROR! Could not save the file!')
-                print('Exception', type(e), 'when exporting the graph. Exception:')
-                print(e)
+                print('Exception', type(e), 'when exporting the graph.',
+                      'Exception:', e)
                 ident = 'in position '
                 errmsg = e.__str__()
                 if ident in errmsg:
                     idx = errmsg.find(ident) + len(ident)
                     from re import findall
                     chari = findall(('[0-9]+'), errmsg[idx:])
                     if len(chari) > 0:
                         chari = int(chari[0])
-                        print('--> surrounding characters:', out[max(0,chari-20):min(len(out),chari+15)].replace('\n','\\n'))
+                        print('--> surrounding characters:', out[max(0, chari-20):min(len(out), chari+15)].replace('\n', '\\n'))
             f.close()
         return filename
 
 
     def exportXML(self, filesave='', **kwargs):
         """
         Exports Graph as .xml file
         NOT implemented:
             saveAltered=False, ifTemplate=False
         Non-sense here:
             ifCompact=True, ifClipboardExport=False
         """
         for key in kwargs:
             print('WARNING GraphIO.exportXML: received keyword', key, ':',
-                  kwargs[key],', don\'t know what to do with it.')
+                  kwargs[key], ", don't know what to do with it.")
         try:
             from lxml import etree
         except ImportError as e:
             print('Exception', type(e), 'in GraphIO.graphToXML:')
             print(e)
             return
         root = etree.Element("graph")
@@ -836,28 +868,28 @@
                     tmp.set(key, str(getattr(self, container)[key]))
         # write curves
         for c in range(self.length()):
             curve = self.curve(c)
             tmp = etree.SubElement(root, 'curve'+str(c))
             attr = etree.SubElement(tmp, 'attributes')
             for key in curve.getAttributes():
-                attr.set(key, str(curve.getAttribute(key)))
+                attr.set(key, str(curve.attr(key)))
             data = etree.SubElement(tmp, 'data')
             x = etree.SubElement(data, 'x')
             y = etree.SubElement(data, 'y')
             x.text = ','.join([str(e) for e in curve.x()])
             y.text = ','.join([str(e) for e in curve.y()])
         # save
         filesave = GraphIO.filesave_default(self, filesave)
         if len(filesave) < 4 or filesave[-4:] != '.xml':
             filesave += '.xml'
         tree = etree.ElementTree(root)
         tree.write(filesave, pretty_print=True, xml_declaration=True, encoding="utf-8")
-        if self.getAttribute('saveSilent') != True:
-            print('Graph data saved as', filesave.replace('/','\\'))
+        if self.attr('saveSilent') != True:
+            print('Graph data saved as', filesave.replace('/', '\\'))
         return filesave
 
 
     def _createSubplotsGridspec(self, figAx=None, ifSubPlot=False):
         """
         Generates a Figure (if not provided) with a gridpec axes matrix
         """
@@ -872,54 +904,56 @@
                 for ax_ in fig.get_axes():
                     if ax_ is not ax:
                         plt.delaxes(ax_)
         else:
             fig = plt.figure()  # create a new figure
             ax = None
         # count number of graphs to be plotted
-        axes = [{'ax': None, 'activenext': True} for c in self.iterCurves()]
-        ncurvesondefault = 0  # if no curve is displayed on default axis, do not create it
+        axes = [{'ax': None, 'activenext': True} for curve in self]
+        ncurvesondefault = 0  # do not create default axis if no curve on it
         ngraphs = 0
-        for curve in range(self.length()):
-            c = self.curve(curve)
-            if isinstance(c, Curve_Inset):
-                axes[curve].update({'ax': 'inset', 'activenext': False})
+        for c in range(len(self)):
+            curve = self[c]
+            if isinstance(curve, Curve_Inset):
+                axes[c].update({'ax': 'inset', 'activenext': False})
                 # default can be overridden if Graph file has length 0
-            elif isinstance(c, Curve_Subplot):
-                rowspan = int(c.getAttribute('subplotrowspan', 1))
-                colspan = int(c.getAttribute('subplotcolspan', 1))
+            elif isinstance(curve, Curve_Subplot):
+                rowspan = int(curve.attr('subplotrowspan', 1))
+                colspan = int(curve.attr('subplotcolspan', 1))
                 ngraphs += rowspan * colspan
             elif ngraphs == 0:
                 ncurvesondefault += 1
                 ngraphs = 1
         ngraphs = max(1, ngraphs)
         # transpose?
-        transpose = self.getAttribute('subplotstranspose', False)
+        transpose = self.attr('subplotstranspose', False)
         # determine axes matrix shape
-        ncols = int(self.getAttribute('subplotsncols', (1 if ngraphs < 2 else 2)))
+        ncols = int(self.attr('subplotsncols', (1 if ngraphs < 2 else 2)))
         nrows = int(np.ceil(ngraphs / ncols))
         # width, heigth ratios?
         gridspeckwargs = {}
-        val = list(self.getAttribute('subplotswidth_ratios', ''))
+        val = list(self.attr('subplotswidth_ratios', ''))
         if len(val) > 0:
             target = ncols if not transpose else nrows
             if len(val) != target:
                 val += [1] * max(0, (target)-len(val))
                 while len(val) > target:
                     del val[-1]
-                print('GraphIO._createSubplotsGridspec: corrected width_ratios to match ncols', ncols, ':', val)
+                print('GraphIO._createSubplotsGridspec: corrected width_ratios'
+                      'to match ncols', ncols, ':', val)
             gridspeckwargs.update({'width_ratios': val})
-        val = list(self.getAttribute('subplotsheight_ratios', ''))
+        val = list(self.attr('subplotsheight_ratios', ''))
         if len(val) > 0:
             target = nrows if not transpose else ncols
             if len(val) != target:
                 val += [1] * max(0, (target)-len(val))
                 while len(val) > target:
                     del val[-1]
-                print('GraphIO._createSubplotsGridspec: corrected height_ratios to match nrows', nrows, ':', val)
+                print('GraphIO._createSubplotsGridspec: corrected',
+                      'height_ratios to match nrows', nrows, ':', val)
             gridspeckwargs.update({'height_ratios': val})
         # generate axes matrix: either gs, either ax is created
         gs, matrix = None, np.array([[]])
         if ax is None:
             if ngraphs == 1:
                 ax = fig.add_subplot(111)
                 ax.ticklabel_format(useOffset=False)
@@ -931,45 +965,50 @@
                 matrix = np.ones((nrows, ncols)) * (-1)
                 if transpose:
                     gs = gridspec.GridSpec(ncols, nrows, **gridspeckwargs)
                 else:
                     gs = gridspec.GridSpec(nrows, ncols, **gridspeckwargs)
 
         # coordinates of the plot id
-        subplotsid = self.getAttribute('subplotsid', False)
-        if (subplotsid is not False and
-            (not isinstance(subplotsid, (list, tuple)) or len(subplotsid) != 2)):
+        subplotsid = self.attr('subplotsid', False)
+        if (subplotsid is not False
+                and (not isinstance(subplotsid, (list, tuple))
+                     or len(subplotsid) != 2)):
             subplotsid = (-0.03, 0.00)
         # misc adjustments to self
         if ngraphs > 1:  # do not want default values if multiple subplots
             self.update({'xlabel': '', 'ylabel': ''})
         # return
         return [fig, ax], gs, matrix, subplotsid, ngraphs
 
 
 
     def _newaxis(self, curve, fig, gs, matrix, subplotsid, subplotscounter, subplotidkwargs):
-        rowspan = int(curve.getAttribute('subplotrowspan', 1))
-        colspan = int(curve.getAttribute('subplotcolspan', 1))
+        rowspan = int(curve.attr('subplotrowspan', 1))
+        colspan = int(curve.attr('subplotcolspan', 1))
         gspos = gs.get_grid_positions(fig)
         flag = False
         for i_ in range(len(matrix)):
             for j_ in range(len(matrix[i_])):
                 if matrix[i_,j_] == -1:
                     # first free spot found: start there
                     if rowspan > matrix.shape[0] - i_:
                         # calculation of number of rows probably faulty
-                        print('WARNING GraphIO.plot: rowspan larger than can handled for subplot', subplotscounter, ', value coerced to', matrix.shape[0] - i_)
+                        print('WARNING GraphIO.plot: rowspan larger than can',
+                              'handled for subplot', subplotscounter,
+                              ', value coerced to', matrix.shape[0] - i_)
                     if colspan > matrix.shape[1] - j_:
                         # either faulty calculation of number of rows,
                         # either that colspan cannot fit in ncols
-                        print('WARNING GraphIO.plot: colspan larger than can handled for subplot', subplotscounter, ', value coerced to', matrix.shape[1] - j_)
+                        print('WARNING GraphIO.plot: colspan larger than can',
+                              'handled for subplot', subplotscounter,
+                              ', value coerced to', matrix.shape[1] - j_)
                     rowspan = min(rowspan, matrix.shape[0] - i_)
                     colspan = min(colspan, matrix.shape[1] - j_)
-                    if self.getAttribute('subplotstranspose', False):
+                    if self.attr('subplotstranspose', False):
                         if subplotsid:
                             coords = (gspos[2][i_]+subplotsid[0], gspos[1][j_]+subplotsid[1])
                             self.addText('('+chr(ord('a')+subplotscounter)+')', coords, subplotidkwargs)
                         ax = plt.subplot(gs[j_:(j_+colspan), i_:(i_+rowspan)])
                     else:
                         if subplotsid:
                             coords = (gspos[2][j_]+subplotsid[0], gspos[1][i_]+subplotsid[1])
@@ -984,80 +1023,100 @@
             print('ERROR GraphIO.plot create subplot: ax is None')
             print('matrix', matrix)
             raise Exception
         ax.ticklabel_format(useOffset=False)
         ax.patch.set_alpha(0.0)
         return ax
 
-
-
-    # creat graph from data with headers additional data
-    def plot(self, filesave='', imgFormat='', figsize=(0, 0), ifSave=True,
-                ifExport=True, figAx=None, ifSubPlot=False, handles=None):
+    # create graph from data with headers additional data
+    def plot(self, filesave='', imgFormat='', figsize=(0, 0), ifSave=True, ifExport=True, figAx=None, ifSubPlot=False, handles=None):
         """
         Plot the content of the object.
         imgFormat: by default image will be .png. Possible format are the ones
             accepted by plt.savefig
         figsize: default figure size is a class consant
         filesave: (optional) filename for the saved graph
         ifExport: if True, reate a human- and machine readable .txt file
             containing all information of the graph
         figAx= [fig, ax] provided. Useful when wish to embedd graph in a GUI.
         ifSubPlot: False, unless fig to be drawn in a subplot. Not handled by
             the GUI, but might be useful in scripts. Prevents deletion of
             existing axes.
         """
+        self._PLOT_PRINTEDERROR_ATTRIBUTE = False
+        self._PLOT_PRINTEDERROR_VALUE = False
+
+        def sca_errorhandled(ax, txt=''):
+            try:
+                plt.sca(ax)
+            except AttributeError:
+                if not self._PLOT_PRINTEDERROR_ATTRIBUTE:
+                    print('WARNING sca(ax)', txt, '. AttributeError catched, cause to investigate...')
+                    self._PLOT_PRINTEDERROR_ATTRIBUTE = True
+            except ValueError:
+                if not self._PLOT_PRINTEDERROR_VALUE:
+                    print('WARNING sca(ax)', txt, '. ValueError catched, cause to investigate...')
+                    self._PLOT_PRINTEDERROR_VALUE = True
+
         # treat filesave, and store info if not already done. required for
         # relative path to subplots or insets
         filename = GraphIO.filesave_default(self, filesave)
         if not hasattr(self, 'filename'):
             self.filename = filename
 
         # store some attributes which might be modified upon execution
         restore = {}
         for attr in ['text', 'textxy', 'textargs']:
-            restore.update({attr: self.getAttribute(attr)})
+            restore.update({attr: self.attr(attr)})
 
-        # retrieve default axis positions subplotAdjustDefault
-        subplotAdjustDefault = {}
+        # retrieve default axis positions subplotAdjustDef
+        subplotAdjustDef = {}
         for key in ['bottom', 'left', 'right', 'top', 'hspace', 'wspace']:
-            subplotAdjustDefault.update({key: mpl.rcParams['figure.subplot.'+key]})
-        subplotColorbar = [0.90, subplotAdjustDefault['bottom'], 0.05, subplotAdjustDefault['top'] - subplotAdjustDefault['bottom']]
+            subplotAdjustDef.update({key: mpl.rcParams['figure.subplot.'+key]})
+        subplotColorbar = [0.90, subplotAdjustDef['bottom'], 0.05,
+                           subplotAdjustDef['top'] - subplotAdjustDef['bottom']]
         # shift fdefault right if there is a colorbar defined in a Curve
-        for c in self.iterCurves():
-            if c.getAttribute('colorbar', None) is not None:
-                subplotAdjustDefault['right'] -= 0.1
+        for c in self:
+            if c.attr('colorbar', None) is not None:
+                subplotAdjustDef['right'] -= 0.1
                 break
 
         # other data we want to retrieve now
-        fontsize = Graph.DEFAULT['fontsize'] if 'fontsize' not in self.graphInfo else self.graphInfo['fontsize']
+        fontsize = Graph.DEFAULT['fontsize']
+        if 'fontsize' in self.graphInfo:
+            fontsize = self.graphInfo['fontsize']
         alter = self._getAlter()
+        if not isinstance(alter, list):
+            # CHECK WITH PRINTOUT. may lead to bug with data copy
+            print('SOMETHING FISHY HERE graphIO alter', alter, type(alter))
         ignoreXLim = True if alter[0] != '' else False
         ignoreYLim = True if alter[1] != '' else False
+
         axTwinX, axTwinY, axTwinXY = None, None, None
 
         # check
         if len(self.data) <= 0:
             if ifSubPlot:
                 pass
             else:
                 print('Warning GraphIO.plot', self.filename, ': no data to plot!')
                 if figAx is not None:
                     fig, ax = figAx[0], figAx[1]
                     if ax is not None:
-                        plt.sca(ax)
+                        sca_errorhandled(ax)
                     plt.cla()
-                #return 1
+                # return 1
 
         # retrieve figure size
-        if figsize == (0, 0): # if figure size not imposed at function call, look for instructions in measurement data
+        if figsize == (0, 0):
+            # if figure size not imposed at function call, look for
+            # instructions in measurement data
+            figsize = self.FIGSIZE_DEFAULT
             if 'figsize' in self.graphInfo:
                 figsize = self.graphInfo['figsize']
-            else:
-                figsize = self.FIGSIZE_DEFAULT
 
         # create graph, initialize axes
         subplotscounter = 0
         [fig, ax], gs, matrix, subplotsid, subplotsngraphs = GraphIO._createSubplotsGridspec(self, figAx, ifSubPlot=ifSubPlot)
         # either ax is None and gs is not None, either the other way around
         subplotsncols, subplotsnrows = matrix.shape
         subplotidkwargs = {'textcoords': 'figure fraction',
@@ -1069,15 +1128,15 @@
             axes.append(ax)
         fig.patch.set_alpha(0.0)
         if not ifSubPlot:  # set figure size if fig is not a subplot
             fig.set_size_inches(*figsize, forward=True)
         colorbar_ax = []
 
         # adjust positions of the axis within the graph (subplots_adjust)
-        subplotAdjust = dict(subplotAdjustDefault)
+        subplotAdjust = dict(subplotAdjustDef)
         if 'subplots_adjust' in self.graphInfo:
             val = deepcopy(self.graphInfo['subplots_adjust'])
             if isinstance(val, dict):
                 subplotAdjust.update(val)
             elif isinstance(val, list):
                 # handles relative in given in absolute
                 if isinstance(val[-1], str) and val[-1] == 'abs':
@@ -1090,109 +1149,108 @@
                     subplotAdjust.update({indic[i]: float(val[i])})
             else:
                 subplotAdjust.update({'bottom': float(val)})
         if fig is not None:
             fig.subplots_adjust(**subplotAdjust)
         if gs is not None:
             gs.update(**subplotAdjust)
-        # auxiliary graph, to be created when new axis, filled with curves and plotted when new axis is created
+        # auxiliary graph, to be created when new axis, filled with curves and
+        # plotted when new axis is created
         graphAux = None  # auxiliary Graph, calling plot() when creating new axis
         graphAuxKw = {'config': self._config.filename}
 
         # plot data
-        type_plot = self.getAttribute('typeplot')
+        type_plot = self.attr('typeplot')
         # set default graph scales (lin, log, etc.)
         if type_plot != '' and gs is None:
             xarg = 'log' if type_plot in ['semilogx', 'loglog'] else 'linear'
             try:
                 ax.set_xscale(xarg)
             except (ValueError, AttributeError):
                 print('Display error, try to go back to linear Transform ?')
             yarg = 'log' if type_plot in ['semilogy', 'loglog'] else 'linear'
             try:
                 ax.set_yscale(yarg)
             except (ValueError, AttributeError):
                 print('Display error, try to go back to linear Transform?')
 
-        boxplot    = {'y':[], 'positions':[], 'labels':[], 'color':[], 'i':0}
-        violinplot = {'y':[], 'positions':[], 'labels':[], 'color':[]}
+        boxplot = {'y': [], 'positions': [], 'labels': [], 'color': [], 'i': 0}
+        violinplot = {'y': [], 'positions': [], 'labels': [], 'color': []}
         violinplotkwargs = {}
 
         ignoreNext = 0
         if handles is None or not isinstance(handles, list):
             handles = []
+        pairsAxCurve = []
         # Start looping on the curves
-        for curve_i in range(self.length()):
+        for curve_i in range(len(self)):
             handle = None
             if ignoreNext > 0:
                 ignoreNext -= 1
                 continue  # ignore this curve, go the next one...
                 # for example if previous curve type was scatter
             curve = self.curve(curve_i)
             attr = curve.getAttributes()
             # if curve is hidden: ignore it
             if curve.isHidden():
                 continue
 
             # Inset: if curve contains information for an inset in the Graph?
             if isinstance(curve, Curve_Inset):
-                val = curve.getAttribute('insetfile')
+                val = curve.attr('insetfile')
                 inset = Graph(self.filenamewithpath(val), **graphAuxKw)
-                coords = list(attr['insetcoords']) if 'insetcoords' in attr else [0.3,0.2,0.4,0.3]
+                coords = list(attr['insetcoords']) if 'insetcoords' in attr else [0.3, 0.2, 0.4, 0.3]
                 if 'insetupdate' in attr and isinstance(attr['insetupdate'], dict):
                     inset.update(attr['insetupdate'])
                 axInset = fig.add_axes(coords)
                 axInset.ticklabel_format(useOffset=False)
                 axInset.patch.set_alpha(0.0)
-                if curve.getAttribute('insetfile') in ['', ' '] or inset.length() == 0:
+                if curve.attr('insetfile') in ['', ' '] or inset.length() == 0:
                     # nothing in provided Graph -> created axis becomes active one
                     if graphAux is not None:
                         # if there was already auxiliary graph: display it, create anew
                         GraphIO.plot(graphAux, ifSave=False, ifExport=False,
                                      figAx=[fig, ax], ifSubPlot=True)
                     graphAux = inset
                     ax = axInset
-                    plt.sca(ax)
+                    sca_errorhandled(ax)
                     axTwinX, axTwinY, axTwinXY = None, None, None
                 else:
                     # found a Graph, place it in inset. Next Curve in existing
                     # axes. No change for graphAux
-                    inset.plot(figAx=[fig, axInset], ifSave=False, ifExport=False,
-                               ifSubPlot=True)
+                    inset.plot(figAx=[fig, axInset], ifSave=False,
+                               ifExport=False, ifSubPlot=True)
                     continue  # go to next Curve
 
             # Subplots: if more than 1 subplot is expected
             if gs is not None:
                 # if required, create the new axis
                 if ax is None or isinstance(curve, Curve_Subplot):
                     if graphAux is not None:
                         GraphIO.plot(graphAux, ifSave=False, ifExport=False,
                                      figAx=[fig, ax], ifSubPlot=True)
                         graphAux = None
                     ax = GraphIO._newaxis(self, curve, fig, gs, matrix, subplotsid, subplotscounter, subplotidkwargs)
-                    try:
-                        plt.sca(ax)
-                    except AttributeError as e:
-                        print('WARNING .plot() plt.sca(ax). AttributeError catched, cause to investigate...')
+                    sca_errorhandled(ax)
                     axTwinX, axTwinY, axTwinXY = None, None, None
                     subplotscounter += 1
                     axes.append(ax)
                 else:  # we go on, not enough information to create subplot
                     pass
             # shall we plot a Graph object instead of a Curve in this new axis?
             if isinstance(curve, Curve_Subplot):
                 # new axes, so create new graphAux (is None by construction)
-                val = curve.getAttribute('subplotfile')
+                val = curve.attr('subplotfile')
                 if val not in [' ', '', None]:
                     graphAux = Graph(self.filenamewithpath(val), **graphAuxKw)
                 else:
                     graphAux = Graph('', **graphAuxKw)
                 upd = {'subplots_adjust': ''}
-                if isinstance(curve.getAttribute('subplotupdate'), dict):
-                    upd.update(curve.getAttribute('subplotupdate'))
+                if isinstance(curve.attr('subplotupdate'), dict):
+                    upd.update(curve.attr('subplotupdate'))
                 graphAux.update(upd)
                 if val not in [' ', '', None]:
                     continue  # go to next Curve
                 # if no file then try to plot data of the Curve
 
             if graphAux is not None:
                 # if active axis is not main one, place Curve in graphAux
@@ -1200,16 +1258,16 @@
                     graphAux.append(Curve(curve.data, curve.getAttributes()))
                 else:
                     graphAux.append(curve)
                 continue
 
             # twin axis: look which axis to use
             ax_ = ax
-            ifTwinX = (curve.getAttribute('ax_twinx') in [True, 1])
-            ifTwinY = (curve.getAttribute('ax_twiny') in [True, 1])
+            ifTwinX = (curve.attr('ax_twinx'))  # if True
+            ifTwinY = (curve.attr('ax_twiny'))
             if ifTwinX and ifTwinY:
                 if axTwinXY is None:
                     axTwinXY = ax.twinx().twiny()
                 ax_ = axTwinXY
             elif ifTwinX:
                 if axTwinX is None:
                     axTwinX = ax.twinx()
@@ -1222,21 +1280,24 @@
             # do the actual plotting
             try:
                 handle, ignoreNext = curve.plot(ax_, graph=self, graph_i=curve_i,
                         type_plot=type_plot, ignoreNext=ignoreNext,
                         boxplot=boxplot,
                         violinplot=violinplot, violinplotkwargs=violinplotkwargs)
             except Exception as e:
-                # need to catch exceptions as we want to proceed with graph generation
-                print(type(e).__name__, 'Exception occured in Curve.plot function, Curve no', curve_i,'. Error message:')
-                print(e)
+                # need to catch exceptions as we want to proceed with graph
+                print(type(e).__name__, 'Exception occured in Curve.plot',
+                      'function, Curve no', curve_i, '. Error message:', e)
                 print(sys.exc_info()[0].__name__, sys.exc_info()[-1].tb_lineno)
 
+            # remind pairs ax - curve
+            pairsAxCurve.append({'ax': ax_, 'curve': curve})
+
             # Add colorbar if required
-            if handle is not None and curve.getAttribute('colorbar', False):
+            if handle is not None and curve.attr('colorbar', False):
                 kwargs = {}
                 if isinstance(attr['colorbar'], dict):
                     kwargs = deepcopy(attr['colorbar'])
                 adjust = deepcopy(subplotColorbar)
                 if 'adjust' in kwargs:
                     adjust = kwargs['adjust']
                     del kwargs['adjust']
@@ -1245,43 +1306,40 @@
                         # coordinates relative to the ax and not to figure
                         axbounds = ax_.get_position().bounds
                         adjust[0] = adjust[0] * axbounds[2] + axbounds[0]
                         adjust[1] = adjust[1] * axbounds[3] + axbounds[1]
                         adjust[2] = adjust[2] * axbounds[2]
                         adjust[3] = adjust[3] * axbounds[3]
                     else:
-                        print('WARNING GraphOI.plot colorbar: cannot interpret last keyword (must be numeric, or \'ax\')')
+                        print('WARNING GraphOI.plot colorbar: cannot',
+                              'interpret last keyword (must be numeric, or',
+                              "'ax'.")
                     del adjust[-1]
-                modifier = []
                 if 'labelsize' in kwargs:
-                    pass
-#                    modifier.append()
-                    # TODO:
-                colorbar_ax.append({'ax': fig.add_axes(adjust), 'adjusted': False})
+                    pass  # TODO
+                colorbar_ax.append({'ax': fig.add_axes(adjust),
+                                    'adjusted': False})
                 colorbar_ax[-1]['cbar'] = fig.colorbar(handle, cax=colorbar_ax[-1]['ax'], **kwargs)
                 try:
                     colorbar_ax[-1]['cbar'].solids.set_rasterized(True)
                     colorbar_ax[-1]['cbar'].solids.set_edgecolor('face')
-                except Exception as e:
+                except Exception:
                     pass
                 subplotColorbar[0] -= 0.11  # default for next colorbar
-                # set again ax_ as the current plt active ax, not the colorbar axis
-                try:
-                    plt.sca(ax_)
-                except AttributeError as e:
-                    print('WARNING .plot() plt.sca(ax_). AttributeError catched, cause to investigate...')
+                # set again ax_ as the current plt active ax, not the colorbar
+                sca_errorhandled(ax_, 'ax_ after colorbar')
 
             # store handle in list
             if handle is not None:
                 if isinstance(handle, list):
                     for h in handle:
                         handles.append({'handle': h})
                 else:
                     handles.append({'handle': handle})
-                    if curve.getAttribute('type') == 'scatter':
+                    if curve.attr('type') == 'scatter':
                         handles[-1].update({'setlegendcolormap': True})
         # end of loop over Curves
 
         # generates boxplot and violinplot, somehow differently than others
         if len(boxplot['y']) > 0:
             bxpltkwargs = {}
             for key in ['widths', 'notch', 'vert']:
@@ -1290,53 +1348,58 @@
             boxplot_dict = ax.boxplot(boxplot['y'], positions=boxplot['positions'], labels=boxplot['labels'], **bxpltkwargs)
             nb_el_boxplot = {'whiskers': 2, 'caps': 2}
             for key in boxplot_dict:
                 for i in range(len(boxplot_dict[key])):
                     j = i if key not in nb_el_boxplot else int(np.floor(i / nb_el_boxplot[key]))
                     if j < len(boxplot['color']) and boxplot['color'][j] != '':
                         boxplot_dict[key][i].set_color(boxplot['color'][j])
+                        if hasattr(boxplot_dict[key][i], 'set_markeredgecolor'):
+                            boxplot_dict[key][i].set_markeredgecolor(boxplot['color'][j])
         if len(violinplot['y']) > 0:
-            violinplot_dict = ax.violinplot(violinplot['y'], positions=violinplot['positions'], **violinplotkwargs)#, labels=violinplot['labels'])
+            violinplot_dict = ax.violinplot(violinplot['y'], positions=violinplot['positions'], **violinplotkwargs)  # , labels=violinplot['labels'])
             for key in violinplot_dict:
                 if isinstance(violinplot_dict[key], list):
                     for i in range(len(violinplot_dict[key])):
                         if violinplot['color'][i] != '':
                             violinplot_dict[key][i].set_color(violinplot['color'][i])
                 else:
-                    violinplot_dict[key].set_color([0,0,0])
+                    violinplot_dict[key].set_color([0, 0, 0])
             # violinplots labels not set automatically like boxplot
             for i in range(len(violinplot['labels'])):
                 xticks = list(ax_.get_xticks())
                 xtklbl = list(ax_.get_xticklabels())
                 xticks.append(violinplot['positions'][i])
                 xtklbl.append(violinplot['labels'][i])
-                ax_.set_xticks     (xticks)
+                ax_.set_xticks(xticks)
                 ax_.set_xticklabels(xtklbl)
 
         # final display of auxiliary axes/graph
         if graphAux is not None:
             GraphIO.plot(graphAux, ifSave=False, ifExport=False,
                          figAx=[fig, ax], ifSubPlot=True)
             graphAux = None
             # main graph: work on initial axis
             ax = axes[0]
-            try:
-                plt.sca(ax)
-            except AttributeError as e:
-                print('WARNING .plot() plt.sca(ax) - 2. AttributeError catched, cause to investigate...')
+            sca_errorhandled(ax, '- 2')
 
         # usual graph cosmetics
-        curvedummy = self.curve(-1) if self.length() > 0 else Curve([[0],[0]],{})
+        curvedummy = self.curve(-1) if len(self) > 0 else Curve([[0], [0]], {})
         fontsizeset = []
 
         def setAxisLabel(method, label):
             out = {'size': False}
-            if isinstance(label, list) and len(label) == 2 and isinstance(label[1], dict):
-                method(label[0], **label[1])
-                if 'size' in label[1] or 'fontsize' in label[1]:
+            if isinstance(label, list) and len(label) == 2 and isinstance(label[-1], dict):
+                method(label[0], **label[-1])
+                if 'size' in label[-1] or 'fontsize' in label[-1]:
+                    out['size'] = True
+            elif isinstance(label, list) and len(label) in [3, 4]:
+                lbl = self.formatAxisLabel(label[0:3])
+                kwargs = label[-1] if isinstance(label[-1], dict) else {}
+                method(lbl, **kwargs)
+                if 'size' in kwargs or 'fontsize' in kwargs:
                     out['size'] = True
             else:
                 method(label)
             return out
 
         if 'title' in self.graphInfo:
             out = setAxisLabel(ax.set_title, self.graphInfo['title'])
@@ -1382,39 +1445,17 @@
                 ax.yaxis.set_label_coords(val[0], val[1])
             else:
                 ax.yaxis.set_label_coords(val, 0.5)
         # other
         if 'axhline' in self.graphInfo:
             lst = ParserAxhline(self.graphInfo['axhline'])
             lst.plot(ax.axhline, curvedummy, alter, type_plot)
-            """
-            if isinstance(self.graphInfo['axhline'], list):
-                for h in self.graphInfo['axhline']:
-                    pos = curvedummy.y(alter=alter[1], xyValue=[1, h], errorIfxyMix=True, neutral=True)
-                    if not pos == 0 or not type_plot in ['semilogy', 'loglog']:
-                        ax.axhline(pos, 0, 1, color='k')
-            else:
-                pos = curvedummy.y(alter=alter[1], xyValue=[1, self.graphInfo['axhline']], errorIfxyMix=True, neutral=True)
-                if not pos == 0 or not type_plot in ['semilogy', 'loglog']:
-                    ax.axhline(pos, 0, 1, color='k')
-            """
         if 'axvline' in self.graphInfo:
             lst = ParserAxvline(self.graphInfo['axvline'])
             lst.plot(ax.axvline, curvedummy, alter, type_plot)
-            """
-            if isinstance(self.graphInfo['axvline'], list):
-                for v in self.graphInfo['axvline']:
-                    pos = curvedummy.x(alter=alter[0], xyValue=[v, 1], errorIfxyMix=True, neutral=True)
-                    if not pos == 0 or not type_plot in ['semilogx', 'loglog']:
-                        ax.axvline(pos, 0, 1, color='k')
-            else:
-                pos = curvedummy.x(alter=alter[0], xyValue=[self.graphInfo['axvline'], 1], errorIfxyMix=True, neutral=True)
-                if not pos == 0 or not type_plot in ['semilogx', 'loglog']:
-                    ax.axvline(pos, 0, 1, color='k')
-           """
         # xlim, ylim. Start with xtickslabels as this guy would override xlim
         if 'xtickslabels' in self.graphInfo and not ignoreXLim:
             val = self.graphInfo['xtickslabels']
             if not isinstance(val, list):
                 val = [val, [], {}]
             ticksloc = val[0]
             if not isinstance(ticksloc, list):
@@ -1434,143 +1475,170 @@
                 ticksloc = ax.yaxis.get_ticklocs()
             ar = [val[1]] if len(val) > 1 and val[1] is not None else []
 #                ticksvals = [a.get_text() for a in ax.yaxis.get_ticklabels()] # don't need to retrieve if do not change them
             kw = val[2] if len(val) > 2 and isinstance(val[2], dict) else {}
             if 'size' in kw:
                 fontsizeset.append('ax.get_yticklabels()')
             plt.yticks(ticksloc, *ar, **kw)
+
         def alterLim(ax, lim, xory):
             limAuto = ax.get_xlim() if xory == 'x' else ax.get_ylim()
-            lim = [l if not isinstance(l, str) else np.inf for l in lim]
+            limInput = [li if not isinstance(li, str) else np.inf for li in lim]
+            lim = list(limInput)
             try:
                 if xory == 'x':
                     fun = ax.set_xlim
                     lim = list(curvedummy.x(alter=alter[0], xyValue=[lim, [0]*len(lim)], errorIfxyMix=True, neutral=True))
                 elif xory == 'y':
                     fun = ax.set_ylim
                     lim = list(curvedummy.y(alter=alter[1], xyValue=[[0]*len(lim), lim], errorIfxyMix=True, neutral=True))
                 else:
                     return False
             except ValueError as e:
                 print('GraphIO set lim ValueError, abort.', e)
                 return False
-            except TypeError as e:
-                print('GraphIO set lim TypeError, comtinue with limAuto', e)
-                lim = limAuto
-            lim = [limAuto[i] if np.isnan(lim[i]) or np.isinf(lim[i]) else lim[i] for i in range(len(lim))]
+            except TypeError:
+                # print('GraphIO set lim TypeError, continue with limAuto', e,
+                #       xory, lim)
+                lim = [np.inf, np.inf]
+            # if inf (e.g. alter transform failed) whereas input was provided,
+            # then take provided value
+            if np.sum(np.isinf(lim)) == 2 and np.sum(np.isinf(limInput)) < 2:
+                lim = limInput
+            else:  # default matplotlib values if not provided
+                lim = [limAuto[i] if np.isnan(lim[i]) or np.isinf(lim[i]) else lim[i] for i in range(len(lim))]
             if lim[0] != lim[1]:
-                fun((lim[0], lim[1]))
+                with warnings.catch_warnings():
+                    warnings.simplefilter('ignore')
+                    fun((lim[0], lim[1]))
         # xlim should be after xtickslabels
         if 'xlim' in self.graphInfo:
             alterLim(ax, deepcopy(self.graphInfo['xlim']), 'x')
         if 'ylim' in self.graphInfo:
             alterLim(ax, deepcopy(self.graphInfo['ylim']), 'y')
         if 'twinx_ylim' in self.graphInfo:
             if axTwinXY is not None:
                 alterLim(axTwinXY, deepcopy(self.graphInfo['twinx_ylim']), 'y')
             if axTwinX is not None:
-                alterLim(axTwinX , deepcopy(self.graphInfo['twinx_ylim']), 'y')
+                alterLim(axTwinX, deepcopy(self.graphInfo['twinx_ylim']), 'y')
         if 'twiny_xlim' in self.graphInfo:
             if axTwinXY is not None:
                 alterLim(axTwinXY, deepcopy(self.graphInfo['twiny_xlim']), 'x')
             if axTwinY is not None:
-                alterLim(axTwinY , deepcopy(self.graphInfo['twiny_xlim']), 'x')
+                alterLim(axTwinY, deepcopy(self.graphInfo['twiny_xlim']), 'x')
         if 'xticksstep' in self.graphInfo and not ignoreXLim:
             val = self.graphInfo['xticksstep']
+            arr = None
             if isinstance(val, (list)):
                 arr = val
-            else:
+            elif val != 0:
                 val = abs(val)
                 axlim = ax.get_xlim()
                 ticks = [t for t in ax.xaxis.get_ticklocs() if t >= min(axlim) and t <= max(axlim)]
                 start, end = min(ticks), max(ticks)
                 while start - val >= min(axlim):
                     start -= val
                 while end + val <= max(axlim):
                     end += val
 #                start, end = ax.get_xlim()
                 arr = np.arange(start, end+end/1e10, val)
-            ax.xaxis.set_ticks(arr)
+            if arr is not None:
+                ax.xaxis.set_ticks(arr)
+            else:
+                print('WARNING xticksstep invalid input', val)
         if 'yticksstep' in self.graphInfo and not ignoreYLim:
             val = self.graphInfo['yticksstep']
+            arr = None
             if isinstance(val, (list)):
                 arr = val
-            else: #start, end = ax.get_ylim()
+            elif val != 0:  # start, end = ax.get_ylim()
                 val = abs(val)
                 axlim = ax.get_ylim()
                 ticks = [t for t in ax.yaxis.get_ticklocs() if t >= min(axlim) and t <= max(axlim)]
                 start, end = min(ticks), max(ticks)
                 while start - val >= min(axlim):
                     start -= val
                 while end + val <= max(axlim):
                     end += val
-                arr = np.arange(start, end+end/1e10, self.graphInfo['yticksstep'])
-            ax.yaxis.set_ticks(arr)
-
+                arr = np.arange(start, end+end/1e10, val)
+            if arr is not None:
+                ax.yaxis.set_ticks(arr)
+            else:
+                print('WARNING yticksstep invalid input', val)
 
         # text annotations
         if 'text' in self.graphInfo:
             textxyDefault = (0.05, 0.95)
-            text = deepcopy(self.getAttribute('text'))
-            texy = deepcopy(self.getAttribute('textxy', None))
-            args = deepcopy(self.getAttribute('textargs'))
+            text = deepcopy(self.attr('text'))
+            texy = deepcopy(self.attr('textxy', None))
+            args = deepcopy(self.attr('textargs'))
             if not isinstance(text, list):
                 text = [text]
             if not isinstance(texy, list):
                 texy = [texy] * len(text)
-            else: # can be for example [0.05,0.95] -> should be duplicated
-                if len(texy) == 2 and not isinstance(texy[0], (list, tuple)) and not isinstance(texy[1], (list, tuple)):
+            else:  # can be for example [0.05,0.95] -> should be duplicated
+                if (len(texy) == 2 and not isinstance(texy[0], (list, tuple))
+                        and not isinstance(texy[1], (list, tuple))):
                     if texy == ['', '']:
                         texy = [None] * len(text)
                     else:
                         texy = [texy] * len(text)
-            while len(texy) < len(text): # duplicate if missing elements
+            while len(texy) < len(text):  # duplicate if missing elements
                 texy.append(texy[-1])
             if not isinstance(args, list):
                 args = [args]
-            args = [deepcopy(a) for a in args] # might be dplicate by construction
+            args = [deepcopy(a) for a in args]  # might be dplicate by construction
             while len(args) < len(text):
                 args.append(deepcopy(args[-1]))
             for i in range(len(text)):
                 if text[i] != '':
-                    if texy[i] != '' and texy[i] is not None and texy[i] not in [['',''], ('','')]:
+                    if texy[i] != '' and texy[i] is not None and texy[i] not in [['', ''], ('', '')]:
                         if 'xytext' in args[i]:
                             print('Graph plot annotate:', text[i], 'textxy', texy[i], 'override', args[i]['xytext'])
                         args[i].update({'xytext': texy[i]})
                     if 'xytext' not in args[i]:
                         if 'xy' in args[i]:
                             args[i].update({'xytext': args[i]['xy']})
                         else:
                             args[i].update({'xytext': textxyDefault})
                     if 'xy' not in args[i]:
-                        args[i].update({'xy': args[i]['xytext']}) # this one exists for sure
+                        args[i].update({'xy': args[i]['xytext']})  # this one exists for sure
                     if 'xycoords' not in args[i] and 'textcoords' in args[i]:
                         args[i].update({'xycoords': args[i]['textcoords']})
                     if 'xycoords' in args[i] and 'textcoords' not in args[i]:
                         args[i].update({'textcoords': args[i]['xycoords']})
                     if 'textcoords' not in args[i]:
                         args[i].update({'textcoords': 'figure fraction'})
                     if 'xycoords' not in args[i]:
                         args[i].update({'xycoords': 'figure fraction'})
                     if 'fontsize' not in args[i] and 'fontsize' in self.graphInfo:
                         args[i].update({'fontsize': self.graphInfo['fontsize']})
-                    #print('Graph plot annotate', text[i], 'args', args[i])
+                    # set_clip_box to draw all that can be show,
+                    # to couple with 'annotation_clip'=False
+                    arrow_set_clip_box = False
+                    if 'arrowprops' in args[i] and 'set_clip_box' in args[i]['arrowprops']:
+                        arrow_set_clip_box = args[i]['arrowprops']['set_clip_box']
+                        del args[i]['arrowprops']['set_clip_box']
+                    # print('Graph plot annotate', text[i], 'args', args[i])
                     try:
-                        ax.annotate(text[i], **args[i])
+                        ann = ax.annotate(text[i], **args[i])
+                        if arrow_set_clip_box:
+                            ann.arrow_patch.set_clip_box(ax.bbox)
                     except Exception as e:
                         print('Exception', type(e), 'during ax.annotate:', text[i], args[i])
                         print(e)
         # legend
-        if gs is None: # create legend on current ax
-            legPropUser = deepcopy(self.getAttribute('legendproperties', default='best'))
+        if gs is None:  # create legend on current ax
+            legPropUser = deepcopy(self.attr('legendproperties', default='best'))
             if not isinstance(legPropUser, dict):
                 legPropUser = {'loc': legPropUser}
             if 'loc' in legPropUser:
                 legPropUser['loc'] = str(legPropUser['loc']).lower()
-                rep = {'best': 0, 'ne': 1, 'nw': 2, 'sw': 3, 'se': 4, 'right': 5, 'w': 6, 'e': 7, 's': 8, 'n': 9, 'center': 10}
+                rep = {'best': 0, 'ne': 1, 'nw': 2, 'sw': 3, 'se': 4,
+                       'right': 5, 'w': 6, 'e': 7, 's': 8, 'n': 9, 'center': 10}
                 if legPropUser['loc'] in rep:
                     legPropUser['loc'] = rep[legPropUser['loc']]
             prop = {} if 'fontsize' not in self.graphInfo else {'size': self.graphInfo['fontsize']}
             if 'prop' in legPropUser:
                 prop.update(legPropUser['prop'])
             legPropUser['prop'] = prop
             if 'fontsize' in legPropUser:
@@ -1580,43 +1648,45 @@
             if 'color' in legPropUser:
                 legLabelColor = legPropUser['color'].lower()
                 del legPropUser['color']
             legProp = {'fancybox': True, 'framealpha': 0.5, 'frameon': False, 'numpoints': 1, 'scatterpoints': 1}
             legProp.update(legPropUser)
             labels = []
             for i in range(len(handles)-1, -1, -1):
-                label = handles[i]['handle'].get_label() if hasattr(handles[i]['handle'], 'get_label') else '' # not legend if dont know how to find it
+                label = handles[i]['handle'].get_label() if hasattr(handles[i]['handle'], 'get_label') else ''  # not legend if dont know how to find it
                 if isinstance(handles[i]['handle'], mpl.image.AxesImage):
                     label = None
                 if label is None or len(label) == 0 or label[0] == '_':
-                    del handles[i] # delete curve handle if no label is to be shown
+                    del handles[i]  # delete curve handle if no label is to be shown
                 else:
                     labels.append(label)
-            leg = ax.legend([h['handle'] for h in handles], labels[::-1], **legProp)# labels is reversed by construction
+            leg = ax.legend([h['handle'] for h in handles], labels[::-1], **legProp)  # labels is reversed by construction
             # color of legend
             if legLabelColor is not None:
-                if legLabelColor == 'curve': # special value: same color for text and lines
+                if legLabelColor == 'curve':
+                    # special value: same color for text and lines
                     lines, texts = leg.get_lines(), leg.get_texts()
-                    if len(texts) > len(lines): # issue with errorbar, notably
+                    if len(texts) > len(lines):  # issue with errorbar, notably
                         lines = []
                         for h in handles:
                             if isinstance(h['handle'], tuple):
                                 lines.append(h['handle'][0])
                             else:
                                 lines.append(h['handle'])
                     for line, text in zip(lines, texts):
                         try:
                             text.set_color(line.get_color())
-                        except:
+                        except Exception:
                             pass
                 else:
                     for text in leg.get_texts():
                         text.set_color(legLabelColor)
             # legend title
-            legTitle = deepcopy(self.getAttribute('legendtitle')) # legendTitle can be of the form ['some title', {'fontsize':24}]
+            legTitle = deepcopy(self.attr('legendtitle'))
+            # legendTitle can be of the form ['some title', {'fontsize':24}]
             if legTitle != '':
                 setfunc = []
                 if isinstance(legTitle, list):
                     for key in ['color', 'position', 'fontsize', 'align']:
                         if key in legTitle[1]:
                             setfunc.append([key, legTitle[1][key]])
                             del legTitle[1][key]
@@ -1626,65 +1696,67 @@
                 for setf in setfunc:
                     if setf[0] == 'align':
                         leg._legend_box.align = setf[1]
                     else:
                         if hasattr(leg.get_title(), 'set_'+setf[0]):
                             getattr(leg.get_title(), 'set_'+setf[0])(setf[1])
                         else:
-                            print('Warning GraphIO do not knwo what to do with keyword',setf[0])
+                            print('Warning GraphIO do not knwo what to do',
+                                  'with keyword', setf[0])
             # in legend, set color of scatter correctly
             for i in range(len(handles)):
                 if 'setlegendcolormap' in handles[i] and handles[i]['setlegendcolormap']:
                     try:
-                        leg.legendHandles[i].set_color(handles[i]['handle'].get_cmap()(.5))#plt.cm.afmhot(.5))
+                        leg.legendHandles[i].set_color(handles[i]['handle'].get_cmap()(.5))  # plt.cm.afmhot(.5))
                     except AttributeError as e:
                         print('error setlegendcolormap', e)
                         pass
 
         # arbitrary functions
         if 'arbitraryfunctions' in self.graphInfo:
             for fun in self.graphInfo['arbitraryfunctions']:
                 try:
-#                    print ('Graph plot arbitrary func', fun, type(fun))
+                    # print ('Graph plot arbitrary func', fun, type(fun))
                     f, arg, opt = fun[0], fun[1], fun[2]
                     fsplit = f.split('.')
-#                    print ('   ', ax, fsplit, len(fsplit))
+                    # print ('   ', ax, fsplit, len(fsplit))
                     obj = ax
                     for subf in fsplit:
                         if hasattr(obj, '__call__'):
                             obj = getattr(obj(), subf)
                         else:
                             obj = getattr(obj, subf)
-#                    print ('   ', obj, type(obj))
+                    # print ('   ', obj, type(obj))
                     # handle ticks locators and formatters, take objects as arguments
                     if fsplit[-1] in ['set_major_locator', 'set_minor_locator', 'set_major_formatter', 'set_minor_formatter']:
                         if len(arg) > 0 and isinstance(arg[0], str):
                             try:
                                 asplit = resplit('[()]', arg[0])
-                                args = [stringToVariable(a) for a in asplit[1:] if a is not '']
+                                args = [strToVar(a) for a in asplit[1:] if a != '']
                                 import matplotlib.ticker as tck
                                 arg = [getattr(tck, asplit[0])(*args)]
-                            except Exception as e:
-                                pass # just continue with unmodified arg
-#                    print('      ',arg)
-                    obj(*arg, **opt) # res = obj(**opt) if len(arg) == 0 else obj(*arg, **opt)
-#                    print(res)
+                            except Exception:
+                                pass  # just continue with unmodified arg
+                    # print('      ',arg)
+                    obj(*arg, **opt)  # res = obj(**opt) if len(arg) == 0 else obj(*arg, **opt)
                 except Exception as e:
-                    print('Exception in function Graph.plot arbitrary functions')
-                    print('Exception', type(e), e)
+                    print('Exception in function Graph.plot arbitrary',
+                          'functions. Exception', type(e), e)
                     pass
 
         # font sizes
         if gs is None:
             listLabels = [ax.title, ax.xaxis.label, ax.yaxis.label]
             if 'ax.get_xticklabels()' not in fontsizeset:
                 listLabels += ax.get_xticklabels()
             if 'ax.get_yticklabels()' not in fontsizeset:
                 listLabels += ax.get_yticklabels()
-            if axTwinX is not None: # maybe an automatic detection of all the axis would be more robust than trying to list all possible existing axis?
+            # maybe an automatic detection of all the axis would be more robust
+            # than trying to list all possible existing axis?
+            if axTwinX is not None:
                 listLabels += [axTwinX.yaxis.label] + axTwinX.get_yticklabels()
             if axTwinY is not None:
                 listLabels += [axTwinY.xaxis.label] + axTwinY.get_xticklabels()
             if axTwinXY is not None:
                 listLabels += [axTwinXY.xaxis.label, axTwinXY.yaxis.label] + axTwinXY.get_xticklabels() + axTwinXY.get_yticklabels()
             for item in (listLabels):
                 if item not in fontsizeset:
@@ -1704,26 +1776,28 @@
         if ifSave:
             if len(imgFormat) == 0:
                 imgFormat = self.config('save_imgformat', '.png')
             if not isinstance(imgFormat, list):
                 imgFormat = [imgFormat]
             for imgForma_ in imgFormat:
                 imgFormatTarget = ''
-                if imgForma_ == '.emf':  # special: we save svg and convert into emf using inkscape
+                if imgForma_ == '.emf':
+                    # special: we save svg and convert into emf using inkscape
                     imgFormatTarget = '.emf'
                     imgForma_ = '.svg'
 
                 filename_ = filename + imgForma_
-                if self.getAttribute('saveSilent') != True:
+                if not self.attr('saveSilent'):
                     print('Graph saved as ' + filename_.replace('/', '\\'))
                 plt.savefig(filename_, transparent=True, dpi=saveDPI)
                 self.filename = filename_
 
                 if imgFormatTarget == '.emf':
-                    GraphIO.convertSVGtoEMF(self, filename_, imgFormat, imgFormatTarget)
+                    GraphIO.convertSVGtoEMF(self, filename_, imgFormat,
+                                            imgFormatTarget)
 
         if ifExport:
             self.export(filesave=(filename+exportFormat))
         return [fig, axes]
 
     def convertSVGtoEMF(self, filename, imgFormat, imgFormatTarget):
         success = False
@@ -1740,16 +1814,19 @@
                 command = '"'+p+'" --without-gui --export-emf="'+fileemf+'" "'+filename+'"'
                 out = subprocess.call(command)
                 if out == 0:
                     print('Graph saved as ' + fileemf.replace('/', '\\'))
                     success = True
                     break
                 else:
-                    print('Graph save as .emf: likely error (return value '+out+')')
+                    print('Graph save as .emf: likely error (return value '
+                          + out + ')')
             except Exception as e:
                 print('Exception during save in .emf format:', e)
                 pass
         if not success:
             print('Could not save image in .emf format. Please check the following:')
             print(' - A version of inkscape is available,')
             print(' - file config.txt in grapa directory,')
-            print(' - in file config.txt a line exists, similar as that, and indicate a valid inkscape executable e.g.: inkscape_path ["C:\Program Files\Inkscape\inkscape.exe"]')
+            print(' - in file config.txt a line exists, similar as that, and',
+                  'indicate a valid inkscape executable e.g.: inkscape_path',
+                  r'["C:\Program Files\Inkscape\inkscape.exe"]')
```

### Comparing `grapa-0.5.4.8/grapa/gui/createToolTip.py` & `grapa-0.6.1.0/grapa/gui/createToolTip.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,21 +12,23 @@
 try:
     # for Python2
     import Tkinter as tk
 except ImportError:
     # for Python3
     import tkinter as tk
 
+
 class CreateToolTip(object):
     """
     create a tooltip for a given widget
     """
+
     def __init__(self, widget, text='widget info', wraplength=180):
-        self.waittime = 350     #miliseconds
-        self.wraplength = wraplength   #pixels
+        self.waittime = 350  # miliseconds
+        self.wraplength = wraplength  # pixels
         self.widget = widget
         self.text = text
         self.widget.bind("<Enter>", self.enter)
         self.widget.bind("<Leave>", self.leave)
         self.widget.bind("<ButtonPress>", self.leave)
         self.id = None
         self.tw = None
@@ -55,25 +57,25 @@
         y += self.widget.winfo_rooty() + 20
         # creates a toplevel window
         self.tw = tk.Toplevel(self.widget)
         # Leaves only the label and removes the app window
         self.tw.wm_overrideredirect(True)
         self.tw.wm_geometry("+%d+%d" % (x, y))
         label = tk.Label(self.tw, text=self.text, justify='left',
-                       background="#ffffff", relief='solid', borderwidth=1,
-                       wraplength = self.wraplength)
+                         background="#ffffff", relief='solid', borderwidth=1,
+                         wraplength=self.wraplength)
         label.pack(ipadx=1)
 
     def hidetip(self):
         tw = self.tw
-        self.tw= None
+        self.tw = None
         if tw:
             tw.destroy()
 
-            
+
 """
 # testing ...
 if __name__ == '__main__':
     root = tk.Tk()
     btn1 = tk.Button(root, text="button 1")
     btn1.pack(padx=10, pady=5)
     button1_ttp = CreateToolTip(btn1, \
@@ -85,8 +87,8 @@
     btn2 = tk.Button(root, text="button 2")
     btn2.pack(padx=10, pady=5)
     button2_ttp = CreateToolTip(btn2, \
     "First thing's first, I'm the realest. Drop this and let the whole world "
     "feel it. And I'm still in the Murda Bizness. I could hold you down, like "
     "I'm givin' lessons in  physics. You should want a bad Vic like this.")
     root.mainloop()
-"""
+"""
```

### Comparing `grapa-0.5.4.8/grapa/gui/GUIdataEditor.py` & `grapa-0.6.1.0/grapa/gui/GUIdataEditor.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,108 +1,106 @@
 # -*- coding: utf-8 -*-
 """
 Created on Sat Jun  9 14:43:32 2018
 
 @author: Romain
 """
 
-import tkinter as tk
-from tkinter import ttk
-
-import numpy as np
-
 import sys
 import os
+import numpy as np
+import tkinter as tk
+
 path = os.path.abspath(os.path.join('.', '..', '..'))
 if path not in sys.path:
     sys.path.append(path)
 
-from grapa.mathModule import stringToVariable
-from grapa.gui.createToolTip import CreateToolTip
-from grapa.gui.GUImisc import EntryVar, LabelVar, CheckbuttonVar, OptionMenuVar, ComboboxVar, ButtonSmall
+# from grapa.mathModule import strToVar
+# from grapa.gui.createToolTip import CreateToolTip
+from grapa.gui.GUImisc import EntryVar, LabelVar, ComboboxVar
 
 
 class GuiDataEditor(tk.Frame):
     """
     This class creates a window to edit data of a Graph
     """
-    
+
     fieldWidth = 55
     fieldHeight = 15
     curveWidth = 2 * fieldWidth + 25
-    
-    
+
     def __init__(self, master, graph, callback, curve_i=0):
         tk.Frame.__init__(self, master)
         self.master = master
         self.graph = graph
         self.callback = callback
-        self._fields = {'idx':[], 'curve':[]}
+        self._fields = {'idx': [], 'curve': []}
         self._fieldsNum = 0
         # fill GUI
-        width = min(800, max(200, self.graph.length() * 200))
-        height = 400
-        
+        # width = min(800, max(200, self.graph.length() * 200))
+        # height = 400
+
         self.initFonts(self.master)
         self.frameHead = tk.Frame(self.master, borderwidth=2, relief='raised')
         self.frameHead.pack(side='top', fill=tk.X)
         frame = tk.Frame(self.master)
         frame.pack(side='top', fill=tk.BOTH, expand=True)
-        
+
         # --- create canvas with scrollbar ---
         def on_configure(event):
             self.canvas.configure(scrollregion=self.canvas.bbox('all'))
             self.canTop.configure(scrollregion=self.canTop.bbox('all'))
             self.canLef.configure(scrollregion=self.canLef.bbox('all'))
+
         def on_clickCanvas(event):
             self.clickCanvas(event)
+
         def scrollx(*args):
             self.canvas.xview(*args)
             self.canTop.xview(*args)
             self.canLef.xview(*args)
+
         def scrolly(*args):
             self.canvas.yview(*args)
             self.canTop.yview(*args)
             self.canLef.yview(*args)
         scrollbarx = tk.Scrollbar(frame, command=scrollx, orient=tk.HORIZONTAL)
         scrollbary = tk.Scrollbar(frame, command=scrolly, orient=tk.VERTICAL)
         self.canvas = tk.Canvas(frame, bg='white')
         self.canTop = tk.Canvas(frame, height=30)
         self.canLef = tk.Canvas(frame, width=45)
         self.canToL = tk.Canvas(frame, width=45, height=30)
-        self.canvas.configure(yscrollcommand = scrollbary.set)
-        self.canvas.configure(xscrollcommand = scrollbarx.set)
-        self.canTop.configure(xscrollcommand = scrollbarx.set)
-        self.canLef.configure(yscrollcommand = scrollbary.set)
-        scrollbarx.grid(row=2, column=1, sticky='we')#pack(side=tk.BOTTOM, fill='x')
-        scrollbary.grid(row=1, column=2, sticky='ns')#pack(side=tk.RIGHT, fill='y')
-        self.canvas.grid(row=1, column=1, sticky='nsew')#side=tk.TOP, fill=tk.BOTH, expand=True)
+        self.canvas.configure(yscrollcommand=scrollbary.set)
+        self.canvas.configure(xscrollcommand=scrollbarx.set)
+        self.canTop.configure(xscrollcommand=scrollbarx.set)
+        self.canLef.configure(yscrollcommand=scrollbary.set)
+        scrollbarx.grid(row=2, column=1, sticky='we')
+        scrollbary.grid(row=1, column=2, sticky='ns')
+        self.canvas.grid(row=1, column=1, sticky='nsew')
         self.canTop.grid(row=0, column=1, sticky='we')
         self.canLef.grid(row=1, column=0, sticky='ns')
         self.canToL.grid(row=0, column=0, sticky='')
         frame.columnconfigure(1, weight=1)
         frame.rowconfigure(1, weight=1)
         # update scrollregion after starting 'mainloop'
         # when all widgets are in canvas
         self.canvas.bind('<Configure>', on_configure)
         self.canTop.bind('<Configure>', on_configure)
         self.canLef.bind('<Configure>', on_configure)
         self.canvas.bind('<Button-1>', on_clickCanvas)
         # populate different canvas
         self.fillUIHead()
         self.fillUICurves()
-        
-        
+
     def initFonts(self, frame):
         import tkinter.font as font
         a = tk.Label(frame, text='')
         self.fontBold = font.Font(font=a['font'])
         self.fontBold.configure(weight='bold')
-        
-    
+
     def clickCanvas(self, event, c=None, i=None):
         if event is not None:
             c = 0
             for c_ in range(len(self._fields['curve'])):
                 if self.canvas.canvasx(event.x) > self._fields['curve'][c_]['dx']:
                     c = c_
             i = int(np.floor((self.canvas.canvasy(event.y) - self._fields['curve'][c]['dy0']) / self.fieldHeight))
@@ -119,39 +117,42 @@
         self._headCurve1.set(str(c))
         self._headCurve3.set(str(i))
         self._headCurve5.set(str(x))
         self._headCurve7.set(str(y))
         self._headCurBo1.set(str(c))
         self._headCurBo3.set(str(i))
 #        print('clicked at ', event.x, event.y, 'curve', c, 'idx', i)
+
     def saveData(self):
         c = int(self._headCurve1.get())
         i = int(self._headCurve3.get())
         x = float(self._headCurve5.get())
         y = float(self._headCurve7.get())
         x_, y_ = self.graph.curve(c).x(), self.graph.curve(c).y()
         x_[i] = x
         y_[i] = y
         self.graph.curve(c).setX(x_)
         self.graph.curve(c).setY(y_)
         self.fillUICurveData(c)
         self.clickCanvas(None, c=c, i=i)
         if self.callback is not None:
             self.callback()
+
     def deletePoint(self):
         c = int(self._headCurve1.get())
         i = int(self._headCurve3.get())
         curve = self.graph.curve(c)
         data = np.delete(curve.getData(), i, axis=1)
         curve.data = data
         self.fillUICurveData(c)
         self.fillUICurvesIndex()
         self.clickCanvas(None, c=c, i=i)
         if self.callback is not None:
             self.callback()
+
     def insertPoint(self):
         c = int(self._headCurBo1.get())
         i = int(self._headCurBo3.get())
         x = float(self._headCurBo5.get())
         y = float(self._headCurBo7.get())
         curve = self.graph.curve(c)
         x_, y_ = curve.x(), curve.y()
@@ -159,111 +160,115 @@
         y_ = np.insert(y_, i, y)
         curve.data = np.array([x_, y_])
         self.fillUICurveData(c)
         self.fillUICurvesIndex()
         self.clickCanvas(None, c=c, i=i)
         if self.callback is not None:
             self.callback()
-        
-        
-
-
 
+    # user interface
     def fillUIHead(self):
         frame = self.frameHead
         frameup = tk.Frame(frame)
         framedw = tk.Frame(frame)
         frameup.pack(side='top', fill='x')
         framedw.pack(side='top', fill='x')
         self.fillUIHeadTop(frameup)
         self.fillUIHeadBot(framedw)
+
     def fillUIHeadTop(self, frame):
         self._headCurve0 = tk.Label(frame, text='Modify data, curve no')
         self._headCurve1 = LabelVar(frame, '')
         self._headCurve2 = tk.Label(frame, text='index')
         self._headCurve3 = LabelVar(frame, '', width=2)
         self._headCurve4 = tk.Label(frame, text='x')
         self._headCurve5 = EntryVar(frame, '', width=10)
         self._headCurve6 = tk.Label(frame, text='y')
         self._headCurve7 = EntryVar(frame, '', width=10)
         self._headCurve8 = tk.Button(frame, text='Save', command=self.saveData)
-        self._headCurve9 = tk.Button(frame, text='Delete Point', command=self.deletePoint)
+        self._headCurve9 = tk.Button(frame, text='Delete Point',
+                                     command=self.deletePoint)
         self._headCurve0.pack(side='left')
         self._headCurve1.pack(side='left')
         self._headCurve2.pack(side='left')
         self._headCurve3.pack(side='left')
         self._headCurve4.pack(side='left')
         self._headCurve5.pack(side='left')
         self._headCurve6.pack(side='left')
         self._headCurve7.pack(side='left')
         self._headCurve8.pack(side='left')
         self._headCurve9.pack(side='left')
+
     def fillUIHeadBot(self, frame):
         self._headCurBo0 = tk.Label(frame, text='New data point, curve no')
         self._headCurBo1 = LabelVar(frame, '0')
         self._headCurBo2 = tk.Label(frame, text='index')
-        self._headCurBo3 = ComboboxVar(frame, [0, '-1', '', 1, 2], default='0', width=3)
+        self._headCurBo3 = ComboboxVar(frame, [0, '-1', '', 1, 2], default='0',
+                                       width=3)
         self._headCurBo4 = tk.Label(frame, text='x')
         self._headCurBo5 = EntryVar(frame, '', width=10)
         self._headCurBo6 = tk.Label(frame, text='y')
         self._headCurBo7 = EntryVar(frame, '', width=10)
-        self._headCurBo8 = tk.Button(frame, text='Save', command=self.insertPoint)
+        self._headCurBo8 = tk.Button(frame, text='Save',
+                                     command=self.insertPoint)
         self._headCurBo0.pack(side='left')
         self._headCurBo1.pack(side='left')
         self._headCurBo2.pack(side='left')
         self._headCurBo3.pack(side='left')
         self._headCurBo4.pack(side='left')
         self._headCurBo5.pack(side='left')
         self._headCurBo6.pack(side='left')
         self._headCurBo7.pack(side='left')
         self._headCurBo8.pack(side='left')
 
-        
-        
     def fillUICurves(self):
         self._fieldsNum = 0
         for c in range(self.graph.length()):
             if self._fieldsNum + len(self.graph.curve(c).x()) > 100000:
-                print('Data editor: too many data, '+('stopped display after curve '+str(c-1) if c>0 else 'did not display anything')+'.')
+                print('Data editor: too many data, '
+                      + ('stopped display after curve '+str(c-1) if c > 0 else 'did not display anything')
+                      + '.')
                 break
             if c >= len(self._fields['curve']):
-                self._fields['curve'].append({'data':[], 'head':[]})
+                self._fields['curve'].append({'data': [], 'head': []})
             self.fillUICurveData(c)
-        # clean possibly useless fields related to nonexistent curves from memory
+        # clean possibly useless fields related to nonexistent curves in memory
         while len(self._fields['curve']) > self.graph.length():
             for column in self._fields['curve'][-1]['data']:
                 for f in column:
                     self.canvas.delete(f)
         self.fillUICurvesIndex()
-    
-    
+
     def fillUICurvesIndex(self):
         maxlen = 0
         for c in range(len(self._fields['curve'])):
             maxlen = max(maxlen, len(self.graph.curve(c).x()))
         if len(self._fields['idx']) > 0:
             for f in self._fields['idx']:
                 self.canLef.delete(f)
-        self.canToL.create_text(0, 0*self.fieldHeight, anchor='nw', font=self.fontBold, text=" Curve")
-        self.canToL.create_text(0, 1*self.fieldHeight, anchor='nw', font=self.fontBold, text=" Label")
+        self.canToL.create_text(0, 0*self.fieldHeight, anchor='nw',
+                                font=self.fontBold, text=" Curve")
+        self.canToL.create_text(0, 1*self.fieldHeight, anchor='nw',
+                                font=self.fontBold, text=" Label")
         for i in range(maxlen):
             self._fields['idx'].append(self.canLef.create_text(0, (i)*self.fieldHeight, anchor='nw', font=self.fontBold, text=' '+str(i)))
         # empty text at far right to ensure same width of different canvas
-        self.canvas.create_text(self.graph.length()*self.curveWidth, 0, anchor='nw', text=' ')
-        self.canTop.create_text(self.graph.length()*self.curveWidth, 0, anchor='nw', text=' ')
-        
-    
+        self.canvas.create_text(self.graph.length()*self.curveWidth, 0,
+                                anchor='nw', text=' ')
+        self.canTop.create_text(self.graph.length()*self.curveWidth, 0,
+                                anchor='nw', text=' ')
+
     def fillUICurveData(self, c):
         # clear memory, explicitely destroy writings (to avoid memory leak)
         for column in self._fields['curve'][c]['data']:
             for f in column:
                 self.canvas.delete(f)
         for f in self._fields['curve'][c]['head']:
             self.canTop.delete(f)
-        self._fields['curve'][c]['data'] = [[],[]]
+        self._fields['curve'][c]['data'] = [[], []]
         self._fields['curve'][c]['head'] = []
         # make new display
         curve = self.graph.curve(c)
         lbl = str(curve.getAttribute('label'))
         if len(lbl) > 25:
             lbl = lbl[:20] + '...'
         x, y = curve.x(), curve.y()
@@ -276,32 +281,25 @@
             dy = (i) * self.fieldHeight
             self._fields['curve'][c]['data'][0].append(self.canvas.create_text(dx, dy, anchor='nw', text=str(x[i])))
             self._fields['curve'][c]['data'][1].append(self.canvas.create_text(dx + self.fieldWidth, dy, anchor='nw', text=str(y[i])))
         # update number of created fields
         self._fieldsNum += len(x)
 
 
-        
-        
 def buildUI():
     import grapa
     from grapa.graph import Graph
     root = tk.Tk()
-    
+
     graph = Graph(r'./../examples/EQE/SAMPLE_A_d1_1.sr')
     curve = graph.curve(0)
     from copy import deepcopy
     for i in range(6):
         graph.append(deepcopy(curve))
 
     app = GuiDataEditor(root, graph, None)
     app.master.title('Grapa software v'+grapa.__version__+' Data editor')
     app.mainloop()
 
-    
+
 if __name__ == "__main__":
     buildUI()
-    
-    
-    
-    
-
```

### Comparing `grapa-0.5.4.8/grapa/gui/GUIgraphManager.py` & `grapa-0.6.1.0/grapa/gui/GUIgraphManager.py`

 * *Files 21% similar despite different names*

```diff
@@ -44,15 +44,18 @@
             self._active = index
 
     def on_close_release(self, event):
         """Called when the button is released over the close button"""
         if not self.instate(['pressed']):
             return
         element = self.identify(event.x, event.y)
-        index = self.index("@%d,%d" % (event.x, event.y))
+        try:
+            index = self.index("@%d,%d" % (event.x, event.y))
+        except Exception:  # mouse was released outside of the Notebook area
+            index = None
         if "close" in element and self._active == index:
             self.forget(index)
             self.event_generate("<<NotebookTabClosed>>")
         self.state(["!pressed"])
         self._active = None
 
     def __initialize_custom_style(self):
@@ -101,315 +104,358 @@
         ])
 
 
 class GraphHandler:
     """
     A container to store a graph as well as "satellite" data.
     Contains:
-    _graph: a Graph object
-    _filename: str
-    _folder: str
-    _title:
-    _child: tobe used by a container
+    _title: title of the tab
+    _child: eg ref to tk.Frame
+    _propdict: a dict, including graph, filename, folder, etc.
     Input:
     strOrGraph: a str, or a Graph object. Graph has precedence over filename.
         In such case, filename is interpreted as title
     title: the title, as a "satellite" information
     """
 
-    def __init__(self, strOrGraph, title=None):
-        """
-        graph has precedence over filename. In such case, filename is
-        interpreted as title
-        """
-        self._filename = ''
-        self._folder = ''
-        self._title = ''
-        self._graph = None
-        self._child = None  # stores info for container, eg ref to tk.Frame
-        self.reset(strOrGraph, title=title)
-        pass
+    DEFAULT_PROPDICT = {}
 
-    def reset(self, strOrGraph, title=None):
-        if isinstance(strOrGraph, Graph):
-            self._graph = strOrGraph
-            self.update(title=title)
-        else:
-            self._graph = Graph(strOrGraph)
-            self.update(filename=strOrGraph, title=title)
-        # in principle do not want empty title
-        if self.title() == '':
-            test = self._graph.attr('title')
-            if test != '':
-                self.update(title=test)
-        if self.title() == '':
-            test = self._graph.attr('legendtitle')
-            if test != '':
-                self.update(title=test)
-        if self.title() == '':
-            self.update(title='no name')
-
-    def update(self, filename=None, folder=None, title=None):
-        """
-        Update "side" properties: filename, folder, title.
-        filename also updates the folder and title (changes are overriden by
-        specific folder and title inputs)
-        No effect if None values are provided.
-        """
-        if filename is not None:
-            self._filename = filename
-            self._folder = os.path.dirname(filename)
-            self._title = os.path.basename(filename)
-            while self._title.endswith('.txt'):
-                self._title = self._title[:-4]
-        if folder is not None:
-            self._folder = folder
-        if title is not None:
-            self._title = title
-
-    def graph(self):
-        return self._graph
+    def __init__(self, title, child, **kwargs):
+        self.reset(title, child, **kwargs)
 
-    def filename(self):
-        return self._filename
+    def reset(self, title, child, **kwargs):
+        self._title = str(title)
+        self._child = child  # stores info for container, eg ref to tk.Frame
+        self._propdict = {}  # other properties
+        self._propdict.update(GraphHandler.DEFAULT_PROPDICT)
+        self.update(**kwargs)
+
+    def update(self, **kwargs):
+        for key in kwargs:
+            if kwargs[key] is not None:
+                # do not want to overwrite something by accident
+                self._propdict.update({key: kwargs[key]})
 
-    def folder(self):
-        return self._folder
-
-    def title(self):
+    def title(self, title=None):
+        if title is not None:
+            self._title = str(title)
+            if len(self._title) > 80:
+                self._title = self._title[:30] + ' ... ' + self._title[-30:]
         return self._title
 
-    def child(self, child):
+    def child(self, child=None):
         if child is not None:
             self._child = child
         return self._child
 
+    def properties(self):
+        return self._propdict
+
+    def property(self, key):
+        return self._propdict[key]
+
 
 class GraphsTabManager:
     """
     Combines a ttk.Notebook with a list of items, 1 item per tab
     Ensures that the content of Notebook and list of items are synchronized
     ._item and ._notebook should not be modified separately
     """
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, defdict=None, **kwargs):
         """
         Create the GraphsTabHandler the same way you would create a
         ttk.Notebook
+        defdict: default values to be provided to ._itemtype.DEFAULT_PROPDICT
         """
         self.observableTabChanged = Observable()
         # hidden properties
         self._notebook = CustomNotebook(*args, **kwargs)
         self._items = []
         self._itemtype = GraphHandler
+        # configure default parameters
+        defaultdict = {'filename': '', 'folder': '', 'graph': None, 'dpi': 72}
+        if isinstance(defdict, dict):
+            defaultdict.update(defdict)
+        self._itemtype.DEFAULT_PROPDICT = defaultdict
+        # bind events
         self._notebook.bind('<<NotebookTabClosed>>', self._popEvent)
         self._notebook.bind('<<NotebookTabChanged>>', self._reactTabChanged)
 
     # to forward tkinter placement methods
     def pack(self, *args, **kwargs):
         self._notebook.pack(*args, **kwargs)
 
     def grid(self, *args, **kwargs):
         self._notebook.grid(*args, **kwargs)
 
+    # handling of Observable
+    def register(self, func):
+        """ Register callbacks for event <<NotebookTabChanged>> """
+        self.observableTabChanged.register(func)
+
+    def _reactTabChanged(self, event):
+        self._checkConsistency()
+        self.observableTabChanged.update_observers(event)
+
     # To know current selected tab
     def index(self):
         return self._notebook.index(self._notebook.select())
 
     def item(self):
         return self._items[self.index()]
 
     # creation or removal of tabs
-    def append(self, itemOrStrOrGraph, title=None, child=None):
+    def appendNew(self, strOrGraph, title=None, child=None, filename=None, folder=None, **kwargs):
         """
-        itemOrStrOrGraph: can be a item (GraphHandler), or a str or a Graph
-            from which an item can be instanciated
-            if itemOrStrOrGraph is GraphHandler, title is ignored
-        if child None, empty Frame will be automatically created
+        strOrGraph: can be a str or a Graph from which an item can be
+            instanciated
+        if child is None, empty Frame will be automatically created
+        if title is None, its value will be guessed
         """
-        item = self._checkItemType(itemOrStrOrGraph, title=title)
         if child is None:
-            child = tk.Frame(self._notebook)  # , background=item.title())
-        item.child(child)
+            child = tk.Frame(self._notebook)
+        title, kwargs = self._process(strOrGraph=strOrGraph, title=title,
+                                      filename=filename, folder=folder,
+                                      **kwargs)
+        # print('appendNew title, kwargs', title, kwargs)
+        if title is None:
+            title = 'no name'
+        item = self._itemtype(title, child)
+        item.update(**kwargs)
+        if 'folder' not in item.properties():
+            item.update(folder=os.getcwd())
+        # add new items to the list and to notebook
         self._items.append(item)
-        self._notebook.add(child, text=item.title())
+        # print('   ', item.title())
+        self._notebook.add(item.child(), text=item.title())
         self._checkConsistency()
     # insert: not yet implemented
 
+    # Handling of dynamic behavior and callbacks
+    def select(self, idx):
+        """
+        Select a given tab in the Notebook. idx between 0 and len-1
+        """
+        # idx = max(0, min(idx, len(self._notebook.tabs())-1))  # no need
+        if idx < 0:
+            idx += len(self._notebook.tabs())
+        return self._notebook.select(idx)
+        # no need for callbackTabChanged,event NotebookTabChanged would follow
+
     def pop(self, idx=None):
         """
         Removes a element from both tab and item list. If None, the selected
         tab is deleted.
         """
-        print('pop')
         if idx is None:
             idx = self.index()
         item = self._items.pop(idx)
         self._notebook.forget(idx)
         self._checkConsistency()
+        self._checkAtLeast1Element()
         return item
         # no need for callbackTabChanged,event NotebookTabChanged would follow
 
-    # Handling of dynamic behavior and callbacks
-    def select(self, idx):
-        """
-        Select a given tab in the Notebook. idx between 0 and len-1
-        """
-        idx = max(0, min(idx, len(self._notebook.tabs())-1))
-        return self._notebook.select(idx)
-        # no need for callbackTabChanged,event NotebookTabChanged would follow
-
     # Technicalities
     def _popEvent(self, event):
-        """ Triggered by mouse-induced tab closure. .forget already done """
-        print('popevent')
+        """
+        Triggered by mouse-induced tab closure.
+        Notebook.forget already done.
+        """
         self._items.pop(self._notebook._active)
         self._checkConsistency()
+        self._checkAtLeast1Element()
         # no need for callbackTabChanged,event NotebookTabChanged would follow
 
-    def _reactTabChanged(self, event):
-        print('reactTabChanged')
-        self._checkConsistency()
-        self.observableTabChanged.update_observers()
+    def _process(self, strOrGraph=None, title=None, filename=None, folder=None, **kwargs):
+        """ Return title, kw{'graph', 'filename', 'folder'} """
+        if 'graph' in kwargs and not isinstance(kwargs['graph'], Graph):
+            print('GraphsTabManager must provide a Graph for keyword graph')
+            del kwargs['graph']
+        kw = {}
+        # graph
+        if isinstance(strOrGraph, Graph):
+            kw['graph'] = strOrGraph
+        elif strOrGraph is not None:
+            kw['graph'] = Graph(strOrGraph)
+            kw['filename'] = strOrGraph
+        elif 'graph' in kwargs:
+            kw['graph'] = kwargs['graph']
+        # else graph will not be in kw
+        # filename
+        if filename is not None:
+            kw['filename'] = filename
+        elif 'filename' not in kw:
+            if 'graph' in kw:
+                if hasattr(kw['graph'], 'fileexport'):
+                    kw['filename'] = strOrGraph.fileexport
+                elif hasattr(kw['graph'], 'filename'):
+                    kw['filename'] = strOrGraph.filename
+            # else filename not in kw
+        # else filename is already in kw
+        # folder
+        if folder is not None:
+            kw['folder'] = folder
+        else:
+            if 'filename' in kw:
+                kw['folder'] = str(os.path.dirname(kw['filename']))
+                # print('folder from filename', kw['folder'])
+        # kwargs
+        kw.update(kwargs)  # add any other keywords provided
+        # title
+        if title is not None:
+            pass  # title = title
+        else:
+            tit = ''
+            if 'filename' in kw:
+                tit = os.path.basename(kw['filename'])
+                split = os.path.splitext(tit)
+                if len(split[0]) > 0:
+                    tit = split[0]
+            if tit == '' and 'graph' in kw:
+                tit = kw['graph'].attr('title')
+                if isinstance(tit, list):
+                    tit = tit[0]  # clear formatting instructions
+                if tit == '':
+                    tit = kw['graph'].attr('legendtitle')
+                if isinstance(tit, list):
+                    tit = tit[0]  # clear formatting instructions
+            if tit != '':
+                title = tit
+        # title may be returned None - for updates. to check when reset and new
+        return title, kw
 
-    def _checkItemType(self, item, title=None):
-        if not isinstance(item, self._itemtype):
-            item = self._itemtype(item, title=title)
-        return item
+    def updateCurrent(self, title=None, filename=None, folder=None, dpi=None, **kwargs):
+        """
+        Update selected tab and corresponding information
+        kwargs: etc.
+        """
+        idx = self.index()
+        title, kw = self._process(title=title, filename=filename,
+                                  folder=folder, dpi=dpi, **kwargs)
+        self._items[idx].title(title)
+        self._items[idx].update(**kw)
+        self._notebook.tab(idx, text=self._items[idx].title())
+
+    def resetCurrent(self, strOrGraph, title=None, filename=None, folder=None, **kwargs):
+        """
+        Resets information conencted to the selected tab
+        - strOrGraph: can be a str (filename) or a Graph
+        - title: overrides the filename or automatic title detection
+        - kwargs: filename, folder, dpi, etc.
+        """
+        idx = self.index()
+        title, kw = self._process(strOrGraph=strOrGraph, title=title,
+                                  filename=filename, folder=folder, **kwargs)
+        if title is None:
+            title = 'no name'
+        self.item[idx].reset(title, tk.Frame(self._notebook), **kw)
+        if 'folder' not in self.item[idx].properties():
+            self.item[idx].update(folder=os.getcwd())
+        self._notebook.tab(idx, text=self._items[idx].title())
+
+    def _checkAtLeast1Element(self):
+        # always at least 1 tab
+        if len(self._items) == 0:
+            self.appendNew(Graph())  # empty element
 
     def _checkConsistency(self):
         """ Checks consistency of tabs and items: identical text/titles """
+        # checks
         tabs = [self._notebook.tab(tab)['text'] for tab in self._notebook.tabs()]
         titles = [item.title() for item in self._items]
         if len(tabs) != len(titles):
-            print('ERROR GraphsTabManager consistency not same length, tab desynchronization')
+            print('ERROR GraphsTabManager consistency not same length, tab',
+                  'desynchronization')
             print('   tabs', len(tabs), tabs)
             print('   titles', len(titles), titles)
             # TODO: automatic repair synchronization of lists
             return False
         for i in range(len(titles)):
             if titles[i] != tabs[i]:
-                print('ERROR GraphsTabManager consistency 2, tab desynchronization')
+                print('ERROR GraphsTabManager consistency 2, tab',
+                      'desynchronization')
                 print(i, tabs[i], titles[i])
                 return False
-        print('   checkConsistency ok')
+        # print('   checkConsistency ok')
         return True
 
     # Return properties of active item. Shortcut notation specific to item type
-    def graph(self):
-        """ Returns current selected Graph """
-        return self.item().graph()
-
-    def title(self):
+    def getTitle(self):
         """ Returns current selected title """
         return self.item().title()
 
-    def filename(self):
-        """ Returns current selected filename """
-        return self.item().filename()
-
-    def folder(self):
-        """ Returns current selected folder """
-        return self.item().folder()
-
-    def child(self):
+    def getChild(self):
         """ Returns current selected child (Frame) """
         return self.item().child()
 
-    def update(self, filename=None, folder=None, title=None):
-        """ Update selected tab and corresponding information """
-        idx = self.index()
-        self._items[idx].update(filename=filename, folder=folder, title=title)
-        self._notebook.tab(idx, text=self._items[idx].title())
+    def getGraph(self):
+        """ Returns current selected Graph """
+        return self.item().property('graph')
 
-    def reset(self, strOrGraph, title=None):
-        """
-        Resets information conencted to the selected tab
-        - strOrGraph: can be a str (filename) or a Graph
-        - title: overrides the filename or automatic title detection
-        """
-        idx = self.index()
-        self._items[idx].reset(strOrGraph, title=title)
-        self._notebook.tab(idx, text=self._items[idx].title())
+    def getFilename(self):
+        """ Returns current selected filename """
+        return self.item().property('filename')
+
+    def getFolder(self):
+        """ Returns current selected folder """
+        return self.item().property('folder')
+
+    def getProperties(self):
+        """ Returns current selected propdict dict of properties """
+        return self.item().properties()
 
 
 def testAll():
     import random
     root = tk.Tk()
     h = GraphsTabManager(root, width=200, height=50)
     h.pack(side="top", fill="x", expand=True)
     for color in ("red", "orange", "green", "blue", "violet"):
-        handler = GraphHandler(Graph(''), title=color)
-        h.append(handler)
+        h.appendNew('', title=color)
 
     def new1():
         colors = ['black', 'magenta', 'cyan', 'yellow']
         random.shuffle(colors)
-        h.append('', title=colors[0], child=tk.Frame(h._notebook, background=colors[0]))
+        h.appendNew('', title=colors[0],
+                    child=tk.Frame(h._notebook, background=colors[0]))
 
     def new2():
         obj = ['./../examples/fancyAnnotations.txt',
                Graph('./../examples/subplots_examples.txt')]
         random.shuffle(obj)
-        h.append(obj[0])
+        h.appendNew(obj[0])
 
     def new3():
-        h.append(Graph('./../examples/fancyAnnotations.txt'), title='my title')
+        h.appendNew(Graph('./../examples/fancyAnnotations.txt'),
+                    title='my title')
 
     def delCurrent():
         h.pop(h.index())
 
     def delFirst():
         h.pop(0)
 
     def changeCurrentText():
-        h.update(title=h.title()+' *')
+        h.updateCurrent(title=h.getTitle()+' *')
 
     def selectNext():
         h.select(h.index() + 1)
 
     def print_():
-        print(h.graph())
+        print(h.getProperties()['graph'])
+
     tk.Button(root, text='New colored', command=new1).pack(side="top", anchor='w')
     tk.Button(root, text='New 2', command=new2).pack(side="top", anchor='w')
     tk.Button(root, text='New with title', command=new3).pack(side="top", anchor='w')
     # tk.Button(root, text='Get active?', command=getActive).pack(side="top", anchor='w')
     tk.Button(root, text='Change text current', command=changeCurrentText).pack(side="top", anchor='w')
     tk.Button(root, text='Del current', command=delCurrent).pack(side="top", anchor='w')
     tk.Button(root, text='Del first', command=delFirst).pack(side="top", anchor='w')
     tk.Button(root, text='Select next', command=selectNext).pack(side="top", anchor='w')
     tk.Button(root, text='print', command=print_).pack(side="top", anchor='w')
     root.mainloop()
 
 
-"""
-def testCustomNotebook():
-    # test CustomNotebook
-    root = tk.Tk()
-    notebook = CustomNotebook(root, width=200, height=50)
-    notebook.pack(side="top", fill="x", expand=True)
-    for color in ("red", "orange", "green", "blue", "violet"):
-        frame = tk.Frame(notebook, background=color)
-        notebook.add(frame, text=color)
-    def getActive():
-        idx = notebook.index(notebook.select())
-        print(idx, notebook.tab(idx)['text'])
-        return idx
-    def new():
-        import random
-        colors = ['black', 'magenta', 'cyan', 'yellow']
-        random.shuffle(colors)
-        frame = tk.Frame(notebook, background=colors[0])
-        notebook.add(frame, text=colors[0])
-    def changeText():
-        idx = getActive()
-        new = str(notebook.tab(idx)['text'])+' *'
-        print(new)
-        notebook.tab(idx, text=new)
-    tk.Button(root, text='New', command=new).pack(side="top", anchor='w')
-    tk.Button(root, text='Get active?', command=getActive).pack(side="top", anchor='w')
-    tk.Button(root, text='change text', command=changeText).pack(side="top", anchor='w')
-    root.mainloop()
-"""
-
 if __name__ == "__main__":
     testAll()
```

### Comparing `grapa-0.5.4.8/grapa/gui/GUImisc.py` & `grapa-0.6.1.0/grapa/gui/GUImisc.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,252 +1,400 @@
 # -*- coding: utf-8 -*-
 """
-Created on Sat Nov 18 15:00:36 2017
-
 @author: Romain Carron
-Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics,
+Romain Carron
 """
 
 
 from tkinter import ttk
 import tkinter as tk
 from tkinter import X, BOTH
 
 
 def bind_tree(widget, event, callback, add=''):
     "Binds an event to a widget and all its descendants."
     widget.bind(event, callback, add)
     for child in widget.children.values():
-        bind_tree(child, event, callback) # , replace_callback
+        bind_tree(child, event, callback)  # , replace_callback
+
+
+class TextWriteable(tk.Text):
+    """
+    New texyt field class, with possibility for write (print in this field)
+    Used for the console output
+    """
+
+    def write(self, string):
+        self.insert(tk.END, string)
+        self.see(tk.END)
+
 
-        
 class OptionMenuVar(tk.OptionMenu):
-    """ replacement for tk.OptionMenu, with embedded tk.Stringvar """
-    def __init__(self, frame, values, default='', func=None, width=None):
+    """
+    Replacement for tk.OptionMenu, with embedded tk.Stringvar
+    func: function that will be called as command()
+    varType: alternative to tk.Stringvar
+    """
+
+    def __init__(self, frame, values, default='', func=None, width=None, varType=None):
         self.values = values
-        self.var = tk.StringVar()
+        if varType is None:
+            self.var = tk.StringVar()
+        else:
+            self.var = varType()
         tk.OptionMenu.__init__(self, frame, self.var, self.values)
         self.resetValues(self.values, default=default, func=func)
         if width is not None:
             self.configure(width=width)
+
     def get(self):
         return self.var.get()
-    def set(self, val):
-        if val in self.values:
+
+    def set(self, val, force=False):
+        if val in self.values or force:
             self.var.set(val)
-    def resetValues(self, values, func=None, default=''):
+
+    def resetValues(self, values, labels=None, func=None, default=''):
+        """
+        - labels: if labels different from values
+        """
         self.values = values
+        if labels is None or len(values) != len(labels):
+            if labels is not None and len(labels) != len(values):
+                print('OptionMenuVar resetValues wrong len', values, labels)
+            labels = values
         self['menu'].delete(0, 'end')
-        for val in values:
+        for i in range(len(values)):
+            val, lbl = values[i], labels[i]
             if func is not None:
-                self['menu'].add_command(label=val, command=lambda v=val: func(v))
+                self['menu'].add_command(label=lbl,
+                                         command=lambda v=val: func(v))
             else:
-                self['menu'].add_command(label=val, command=tk._setit(self.var, val))
-        self.var.set(default if default in self.values else self.values[0])
+                self['menu'].add_command(label=lbl,
+                                         command=tk._setit(self.var, val))
+        if len(values) > 0:
+            # does not change value if default '' and '' not in values
+            if default != '' or (default == '' and default in values):
+                self.var.set(default if default in values else values[0])
 
 
 class EntryVar(tk.Entry):
     """ replacement for tk.Entry, with embedded tk.Stringvar """
-    def __init__(self, frame, value, **kwargs):
-        self.var = tk.StringVar()
+
+    def __init__(self, frame, value, varType=None, **kwargs):
+        if varType is None:
+            self.var = tk.StringVar()
+        else:
+            self.var = varType()
         self.var.set(value)
         tk.Entry.__init__(self, frame, textvariable=self.var, **kwargs)
+
     def get(self):
         return self.var.get()
+
     def set(self, val):
         self.var.set(val)
 
-        
+
 class LabelVar(tk.Label):
     """ replacement for tk.Label, with embedded tk.Stringvar """
+
     def __init__(self, frame, value, **kwargs):
         self.var = tk.StringVar()
         self.var.set(value)
         tk.Label.__init__(self, frame, textvariable=self.var, **kwargs)
+
     def get(self):
         return self.var.get()
+
     def set(self, val):
         self.var.set(val)
 
-        
+
 class ComboboxVar(ttk.Combobox):
     """ replacement for tk.Combobbox, with embedded tk.Stringvar """
+
     def __init__(self, frame, values, default='', **kwargs):
         self.values = values
         self.var = tk.StringVar()
         self.var.set(default)
-        ttk.Combobox.__init__(self, frame, values=self.values, textvariable=self.var, **kwargs)
+        ttk.Combobox.__init__(self, frame, values=self.values,
+                              textvariable=self.var, **kwargs)
+
     def get(self):
         return self.var.get()
+
     def set(self, val):
         self.var.set(val)
 
 
-
 class CheckbuttonVar(tk.Checkbutton):
     """ replacement for tk.Checkbutton, with embedded tk.BooleanVar """
+
     def __init__(self, frame, text, default, **kwargs):
         self.var = tk.BooleanVar()
         self.var.set(default)
-        tk.Checkbutton.__init__(self, frame, text=text, variable=self.var, **kwargs)
+        tk.Checkbutton.__init__(self, frame, text=text, variable=self.var,
+                                **kwargs)
+
     def get(self):
         return self.var.get()
+
     def set(self, value):
         self.var.set(value)
 
-        
-        
+
 class ButtonSmall(tk.Frame):
     """ fabricate a Button with a tunable size """
+
     def __init__(self, frame, text, command, width=16, height=16, **kwargs):
         tk.Frame.__init__(self, frame, width=width, height=height)
         self.propagate(0)
         self._button = tk.Button(self, text=text, command=command, **kwargs)
         self._button.pack(fill=tk.BOTH, expand=True)
-        
-        
-        
-        
+
+
+class FrameScrollable(tk.Frame):
+    """
+    A Frame with a vertical scrollbar on the right
+    Widgets must be placed into .child
+    Special methods:
+    - update_idletasks()
+    """
+
+    def __init__(self, parent, **kwargs):
+        tk.Frame.__init__(self, parent, **kwargs)
+        # elements
+        self.scrollbary = tk.Scrollbar(self, command=self.scrolly,
+                                       orient=tk.VERTICAL)
+        self.canvas = tk.Canvas(self)
+        self.child = tk.Frame(self)
+        # geometry
+        self.scrollbary.grid(row=0, column=1, sticky=tk.N+tk.S+tk.E)
+        self.canvas.grid(row=0, column=0, sticky=tk.N+tk.S+tk.W)
+        self.canvas.create_window(0, 0, window=self.child, anchor='nw')
+        self.columnconfigure(0, weight=1)
+        self.rowconfigure(0, weight=1)
+        # behavior
+        self.canvas.configure(yscrollcommand=self.scrollbary.set)
+        self.canvas.bind('<Configure>', self.on_configure)
+        self.child.bind("<MouseWheel>", self.on_mousewheel)
+        self.bind("<MouseWheel>", self.on_mousewheel)
+        # assign ref to be able to uncind if necessary
+        self._upd_idle = self.child.bind('<Configure>', self.update_idletasks)
+
+    def update_idletasks(self, event=None):
+        """
+        Updates the child Frame and resizes the canvas accordingly.
+        Normally handled by event self.child <Configure>
+        """
+        self.child.update_idletasks()
+        w = self.child.winfo_width()
+        h = self.child.winfo_height()
+        self.canvas.config(width=w, height=h)
+
+    def on_configure(self, event):
+        self.canvas.configure(scrollregion=self.canvas.bbox('all'))
+
+    def scrolly(self, *args):
+        self.canvas.yview(*args)
+
+    def on_mousewheel(self, event):
+        self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")
+
+
 class FrameTitleContentHide(tk.Frame):
-    """ A class to show and hide some content in the user-interface """
+    """
+    A class to show and hide some content in the user-interface
+
+    - createButtons: if False, does not create button AND does not fill Frames
+      _title and _content. Up to the user to do that. Buttons can be created
+      by calling createButtonShow() and createButtonHide()
+    """
+    # some hack. ideally would need to write a simpler version of
+    # FrameTitleContentHide without buttons and make other versions derive
+    # from it
+
     def __init__(self, master, funcFillTitle, funcFillContent,
-                 contentkwargs={}, default='show', layout='vertical',
-                 showHideTitle=False, 
+                 contentkwargs={}, default='show', layout='horizontal',
+                 showHideTitle=False, createButtons=True, horizLineFrame=True,
                  **kwargs):
-        self.setButtonLabels()
         tk.Frame.__init__(self, master, **kwargs)
+        self.setButtonLabels()
         self._visiblecontent = True
         self.showHideTitle = showHideTitle
         self._layout = layout
         self._contentkwargs = contentkwargs
+        self.createButtons = createButtons
+        self.horizLineFrame = horizLineFrame
         # define elements inside
         self._title = None
         self.createWidgets()
         # fill title and content
-        if funcFillTitle is not None and self._title is not None:
-            funcFillTitle(self._title)
-        funcFillContent(self._content)
+        if self.createButtons:
+            if funcFillTitle is not None and self._title is not None:
+                funcFillTitle(self._title)
+            if funcFillContent is not None:
+                funcFillContent(self._content)
         if self._title is not None:
             bind_tree(self._title, '<Button-1>', self.showHide)
         if default == 'hide':
             self.showHide()
+
     @classmethod
     def frameHline(cls, frame):
         return tk.Frame(frame, height=3, background='gainsboro')
+
     def setButtonLabels(self):
         self.btnlbl_in = u"\u25B3"
         self.btnlbl_out = u"\u25BC"
+
+    def createButton(self, frame, symbol='auto', size=None):
+        """
+        size: None: return Button. 'auto': [20, 20]. Or size [x, y]
+        """
+        if symbol == 'auto':
+            symbol = self.btnlbl_in
+        if size == 'auto':
+            size = [20, 20]
+        if size is None:
+            return tk.Button(frame, text=symbol, command=self.showHide)
+        else:
+            fr = tk.Frame(frame, width=size[0], height=size[1])
+            fr.propagate(0)
+            btn = tk.Button(fr, text=symbol, command=self.showHide)
+            btn.pack(side='left', anchor='n', fill=tk.BOTH, expand=1)
+            return fr, btn
+
     def createWidgets(self):
-        up = tk.Frame(self)
-        dwn= tk.Frame(self)
-        up.pack (side='top', anchor='w', fill=X)
+        side, anchor, fill = self.sideAnchorFill()
+        self._up = tk.Frame(self)
+        dwn = tk.Frame(self)
+        self._up.pack(side='top', anchor='w', fill=X)
         dwn.pack(side='top', anchor='w', fill=X)
-        self._title   = tk.Frame(up)
-        self._buttonFrame = tk.Frame(up, width=20, height=20)
-        self._buttonFrame.propagate(0)
-        self._button  = tk.Button(self._buttonFrame, text=self.btnlbl_in,
-                                  command=self.showHide)
-        self._horizLineFrame = self.frameHline(up)
-        self._dummy = tk.Frame(dwn)
+        self._title = tk.Frame(self._up)
+        self._title.pack(side=side, anchor=anchor, fill=fill)
+        if self.createButtons:
+            self._buttonFrame, self._button = self.createButton(self._up,
+                                                                size='auto')
+            self._buttonFrame.pack(side='left', anchor='center', padx=5)
+        if self.horizLineFrame:
+            self._horizLineFrame = self.frameHline(self._up)
+            self._horizLineFrame.pack(side='left', anchor='center', fill=X,
+                                      expand=1, padx=5)
         self._content = tk.Frame(dwn, **self._contentkwargs)
-        self._title.pack(side='left', anchor='n')
-        self._buttonFrame.pack(side='left', anchor='center', padx=5)
-        self._horizLineFrame.pack(side='left', anchor='center', fill=X, expand=1, padx=5)
-        self._button.pack(side='left', anchor='n', fill=BOTH, expand=1)
-        self._dummy.pack(side='top', anchor='w', fill=X)
-        self._content.pack(side='top', anchor='w', fill=X)
+        self._content.pack(side=side, anchor=anchor, fill=fill)
+        self._dummy = tk.Frame(dwn)
+        self._dummy.pack(side=side, anchor=anchor, fill=fill)
+
     def getFrameTitle(self):
         return self._title
+
     def getFrameContent(self):
         return self._content
+
     def getButton(self):
         return self._button
+
     def isvisible(self):
         return self._visiblecontent
-    def showHide(self, *args):
+
+    def sideAnchorFill(self):
         side = 'left' if self._layout == 'horizontal' else 'top'
         anchor = 'center' if self._layout == 'horizontal' else 'w'
+        fill = tk.X if self._layout == 'horizontal' else tk.Y
+        return side, anchor, fill
+
+    def showHide(self, *args):
+        side, anchor, fill = self.sideAnchorFill()
         if self._visiblecontent:
-            self._content.pack_forget()
             if self.showHideTitle:
-                self._title.pack(side=side, anchor=anchor, fill=X)
-            self._button.configure({'text': self.btnlbl_out})
+                self._title.pack(side=side, anchor=anchor, fill=fill)
+                if not self.createButtons and not self.horizLineFrame:
+                    self._up.pack(side=side, anchor=anchor, fill=fill)
+            self._content.pack_forget()
+            if self.createButtons:
+                self._button.configure({'text': self.btnlbl_out})
         else:
-            self._content.pack(side=side, anchor=anchor, fill=X)
+            self._content.pack(side=side, anchor=anchor, fill=fill)
             if self.showHideTitle:
                 self._title.pack_forget()
-            self._button.configure({'text': self.btnlbl_in})
+                if not self.createButtons and not self.horizLineFrame:
+                    self._up.pack_forget()
+            if self.createButtons:
+                self._button.configure({'text': self.btnlbl_in})
         self._visiblecontent = not self._visiblecontent
-            
+
+
 class FrameTitleContentHideHorizontal(FrameTitleContentHide):
     def setButtonLabels(self):
-        self.btnlbl_in  = u"\u25C1"
+        self.btnlbl_in = u"\u25C1"
         self.btnlbl_out = u"\u25B6"
+
     def createWidgets(self):
-        left = tk.Frame(self, height=60, width=30)
+        if self.createButtons:
+            left = tk.Frame(self, width=30)  # height=60,
+            left.pack(side='left', anchor='w')
+            self._buttonFrame, self._button = self.createButton(left,
+                                                                size='auto')
+            self._buttonFrame.pack(side='left', anchor='center', padx=5)
+            # left.propagate(0)  # to reserve space also when hidden
         righ = tk.Frame(self)
-        left.pack(side='left', anchor='w')
         righ.pack(side='left', anchor='w', fill=X)
-        self._buttonFrame = tk.Frame(left, width=20, height=20)
-        self._buttonFrame.pack(side='left', anchor='center', padx=5)
-        self._buttonFrame.propagate(0)
-        left.propagate(0)
-        self._title   = tk.Frame(righ)
+        self._title = tk.Frame(righ)
         self._title.pack(side='left', anchor='center')
         self._dummy = tk.Frame(righ)
         self._dummy.pack(side='left', anchor='n', fill=X)
-        self._button  = tk.Button(self._buttonFrame, text=u"\u25B3",
-                                  command=self.showHide)
-        self._button.pack(side='left', anchor='n', fill=BOTH, expand=1)
         self._content = tk.Frame(righ, **self._contentkwargs)
         self._content.pack(side='top', anchor='w', fill=X)
 
-  
 
-        
 def imageToClipboard(graph):
     """ copy the image output of a Graph to the clipboard - Windows only """
     # save image, because we don't have pixel map at the moment
     print('Copying graph image to clipboard')
     selffilename = graph.filename if hasattr(graph, 'filename') else None
     fileClipboard = '_grapatoclipboard'
     tmp = graph.getAttribute('saveSilent')
     graph.update({'saveSilent': True})
     graph.plot(ifSave=True, ifExport=False, filesave=fileClipboard)
     graph.update({'saveSilent': tmp})
-    if selffilename is not None: # restore self.filename
+    if selffilename is not None:  # restore self.filename
         graph.filename = selffilename
-    
     from io import BytesIO
     from PIL import Image
     try:
         import win32clipboard
     except ImportError as e:
-        print('Module win32clipboard not found, cannot copy to clipboard. Image was created.')
+        print('Module win32clipboard not found, cannot copy to clipboard.',
+              'Image was created.')
         print(e)
         return False
+
     def send_to_clipboard(clip_type, data):
         win32clipboard.OpenClipboard()
         win32clipboard.EmptyClipboard()
         win32clipboard.SetClipboardData(clip_type, data)
         win32clipboard.CloseClipboard()
     # read image -> get pixel map, convert into clipbaord-readable format
     output = BytesIO()
     img = Image.open(fileClipboard+'.png')
     try:
         img = img.convert('RGBA')
     except KeyError:
-        print("Copy to clipboard: RGBA not found. More recent version PIL versions should be able though. Transparency won't be handled correctly.")
+        print('Copy to clipboard: RGBA not found. More recent version PIL',
+              "versions should be able though. Transparency won't be handled",
+              'correctly.')
         img = img.convert('RGB')
     try:
         img.save(output, 'BMP')
     except (IOError, OSError):
-        print("Copy to clipboard: cannot write image as BMP. More recent version PIL versions should be able though. Transparency won't be handled correctly.")
+        print("Copy to clipboard: cannot write image as BMP. More recent"
+              "version PIL versions should be able though. Transparency won't",
+              "be handled correctly.")
         img = img.convert('RGB')
-        img.save(output, 'BMP') # second try
+        img.save(output, 'BMP')  # second try
     data = output.getvalue()[14:]
     output.close()
     send_to_clipboard(win32clipboard.CF_DIB, data)
     return True
-
-
-
```

### Comparing `grapa-0.5.4.8/grapa/gui/GUIpopup.py` & `grapa-0.6.1.0/grapa/gui/GUIpopup.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,79 +1,78 @@
 # -*- coding: utf-8 -*-
 """
 Created on Sat Nov 11 14:18:07 2017
 
 @author: Romain Carron
-Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain
+Carron
 """
 
 import tkinter as tk
 from tkinter import ttk
 from copy import deepcopy
 
 import sys
 import os
 path = os.path.abspath(os.path.join('.', '..', '..'))
 if path not in sys.path:
     sys.path.append(path)
 
-from grapa.mathModule import stringToVariable
+from grapa.mathModule import strToVar, varToStr, strUnescapeIter
 from grapa.gui.createToolTip import CreateToolTip
-from grapa.gui.GUImisc import EntryVar, CheckbuttonVar, OptionMenuVar, ComboboxVar
+from grapa.gui.GUImisc import EntryVar, CheckbuttonVar, OptionMenuVar, ComboboxVar, FrameScrollable
 
 
 class GuiManagerAnnotations(tk.Frame):
     """
     Provides a popup window for quick and easier modification of text
     annotations, legends, legend titles and graph titles.
     """
     # Implementation started with a not-great code for textx, then a more
     # tunable solution was designed for the rest. Previous not modified as it
     # was working
-    
+
     def __init__(self, master, graph, funcupdate):
         self.master = master
         tk.Frame.__init__(self, master)
         self.funcupdate = funcupdate
         self.graph = graph
         # save intial values
         self.oldattr = {}
-        self.oldattr['text']     = deepcopy(graph.getAttribute('text'))
-        self.oldattr['textxy']   = deepcopy(graph.getAttribute('textxy', ['']))
-        self.oldattr['textargs'] = deepcopy(graph.getAttribute('textargs', [{}]))
-        self.oldattr['legendtitle'] = deepcopy(graph.getAttribute('legendtitle'))
+        self.oldattr['text'] = deepcopy(graph.attr('text'))
+        self.oldattr['textxy'] = deepcopy(graph.attr('textxy', ['']))
+        self.oldattr['textargs'] = deepcopy(graph.attr('textargs', [{}]))
+        self.oldattr['legendtitle'] = deepcopy(graph.attr('legendtitle'))
         # prepare
         self.annotations, self.annotationsnew = [], None
         self.configText()
         self.configLegTit()
         self.configLegend()
         # fill GUI
-        self.frame = tk.Frame(self.master)
-        self.initFonts(self.frame)
-        
-        self.fillUIMain(self.frame)
-        self.frame.pack(side='top')
+        self.main = FrameScrollable(self.master)
+        self.initFonts(self.main)
+        self.main.pack(side='top', fill='both', expand=True)
+        self.fillUIMain(self.main.child)
         self.master.bind("<Return>", lambda event: self.go())
 
     def initFonts(self, frame):
         import tkinter.font as font
         a = tk.Label(frame, text='')
         self.fontBold = font.Font(font=a['font'])
         self.fontBold.configure(weight='bold')
-    
 
     def configText(self):
         self.textfields = []
         self.textfields.append({'label': 'visible','field': 'Checkbutton', 'fromkwargs': 'visible', 'tooltip': 'Visible?', 'default': True})
-        self.textfields.append({'label': 'text',        'width': 15,  'tooltip': 'Enter a text'})
+        self.textfields.append({'label': 'text',        'width': 20,  'tooltip': 'Enter a text'})
         self.textfields.append({'label': 'color',       'width': 7,  'fromkwargs': 'color',     'tooltip':'Color. Example: "r", "[1,0,1]", or "pink"', 'field': 'Combobox', 'values': ['r', 'pink', '[1,0,1]']})
         self.textfields.append({'label': 'fontsize',    'width': 7,  'fromkwargs': 'fontsize',  'tooltip':'Fontsize. Example: "16"'})
         self.textfields.append({'label': 'xytext',      'width': 12, 'fromkwargs': 'xytext',    'tooltip':'Position of the text. Example: "(0.2,0.3)"'})
         self.textfields.append({'label': 'textcoords', 'field': 'OptionMenu', 'fromkwargs': 'textcoords','tooltip':'By default "figure fraction". Can also be "axes fraction", "figure pixels", "data", etc.', 'values': ['figure fraction', 'figure pixels', 'figure points', 'axes fraction', 'axes pixels', 'axes points', 'data']})
-        self.textfields.append({'label':'other properties','width': 38,
+        self.textfields.append({'label':'other properties','width': 50,
                                 'tooltip':"kwargs to ax.annotate. Example: \"{'verticalalignment':'center', 'xy':(0.5,0.5), 'xycoords': 'figure fraction', 'rotation': 90, 'arrowprops':{'facecolor':'blue', 'shrink':0.05}}\"\nSee https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.annotate.html",
                                 'default':{}, 'field': 'Combobox',
                                 'values': ["{}",
                                            "{'verticalalignment':'center'}",
                                            "{'xy':(0.5,0.5), 'xycoords': 'figure fraction', 'arrowprops':{'facecolor':'b', 'shrink':0.05}}",
                                            "{'rotation': 90}"]})
         for field in self.textfields:
@@ -85,99 +84,103 @@
                 field['fromkwargs'] = ''
         self.textvars = []
         for field in self.textfields:
             self.textvars.append([])
     def configLegTit(self):
         self.legtitfields = []
         self.legtitfields.append({'label': 'Legend title','width': 0})
-        self.legtitfields.append({'label': 'title',       'width': 15,  'tooltip': 'Enter a title to the legend'})
+        self.legtitfields.append({'label': 'title',       'width': 20,  'tooltip': 'Enter a title to the legend'})
         self.legtitfields.append({'label': 'color',       'width': 7,   'fromkwargs': 'color',    'tooltip':'Color. Example: "r", "[1,0,1]", or "pink"', 'field': 'Combobox', 'values': ['r', 'pink', '[1,0,1]']})
         self.legtitfields.append({'label': 'fontsize',    'width': 7,   'fromkwargs': 'fontsize', 'tooltip':'Numeric, eg. "20"'})
         self.legtitfields.append({'label': 'align', 'field': 'OptionMenu', 'fromkwargs': 'align',    'tooltip':'Horizontal alignment of title. eg. "left", "right".\nFor legendtitle: not a regular matplotlib keyword.', 'values': ['left', 'center', 'right']})
         self.legtitfields.append({'label': 'position (x,y)','width': 10,'fromkwargs': 'position',
                                   'tooltip':'legendtitle: (x,y) position shift in pixels, eg. "(20,0)"\ntitle: (x,y) relative position, eg. "(0,1)"', 'field': 'Combobox', 'values': ['(10,0)', '(-10,20)']})
-        self.legtitfields.append({'label':'other properties','width': 40,'tooltip':'kwargs to legend.set_title()'})
+        self.legtitfields.append({'label':'other properties','width': 50,'tooltip':'kwargs to legend.set_title()'})
         for field in self.legtitfields:
             if 'field' not in field:
                 field['field'] = 'Entry'
             if 'width' not in field:
                 field['width'] = -1
         self.legtitvars = []
         for field in self.legtitfields:
             self.legtitvars.append([])
+
     def configLegend(self):
         self.legendfields = []
         self.legendfields.append({'label': 'Legend',    'width': 0})
         self.legendfields.append({'label': 'color',     'width': 7, 'tooltip':'Color. Example: "r", "[1,0,1]", or "pink"\n"curve" will give same color as trace', 'fromkwargs': 'color', 'field': 'Combobox', 'values': ['r', 'pink', '[1,0,1]', 'curve']})
         self.legendfields.append({'label': 'fontsize',  'width': 7, 'tooltip':'Numeric, eg. "20"', 'fromkwargs': 'fontsize'})
         self.legendfields.append({'label': 'loc',  'field': 'OptionMenu', 'tooltip':'Location, eg. "nw" (north west), "se", "center"', 'fromkwargs': 'loc', 'default': 'best', 'values': ['best', 'nw', 'n', 'ne', 'w', 'center', 'e', 'sw', 's', 'se']})
         self.legendfields.append({'label': 'ncol',      'width': 6, 'tooltip':'Number of columns, eg. "2"', 'fromkwargs': 'ncol', 'casttype': int})
-        self.legendfields.append({'label': 'bbox_to_anchor','width': 12, 'tooltip':'(x,y) shift to base position in axes fraction, eg. "(0.1, 0.2)"', 'fromkwargs': 'bbox_to_anchor', 'field': 'Combobox', 'values': ['(0,0.1)', '(0.1,0.2)']})
-        self.legendfields.append({'label':'other properties','width': 40,
-                                  'tooltip':'kwargs to ax.legend(), see https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.legend.html',
+        self.legendfields.append({'label': 'bbox_to_anchor', 'width': 12, 'tooltip':'(x,y) shift to base position in axes fraction, eg. "(0.1, 0.2)"', 'fromkwargs': 'bbox_to_anchor', 'field': 'Combobox', 'values': ['(0,0.1)', '(0.1,0.2)']})
+        self.legendfields.append({'label': 'other properties', 'width': 55,
+                                  'tooltip': 'kwargs to ax.legend(), see https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.legend.html',
                                   'field': 'Combobox',
-                                  'values': ["{}", "{'frameon': True, 'framealpha':1}", "{'framealpha': 1}", "{'numpoints': 2}"]})
+                                  'values': ["{}", "{'frameon': True, 'framealpha': 1}", "{'framealpha': 1}", "{'numpoints': 2}"]})
         for field in self.legendfields:
             if 'field' not in field:
                 field['field'] = 'Entry'
             if 'width' not in field:
                 field['width'] = -1
         self.legendvars = []
         for field in self.legendfields:
             self.legendvars.append([])
-        
-    
+
     def parseGraph(self):
         # retrieve data from Graph object, ensure formatting is ok
         self.attr = {}
-        self.attr['text']     = deepcopy(self.graph.getAttribute('text'))
-        self.attr['textxy']   = deepcopy(self.graph.getAttribute('textxy', ['']))
-        self.attr['textargs'] = deepcopy(self.graph.getAttribute('textargs', [{}]))
+        self.attr['text'] = deepcopy(self.graph.attr('text'))
+        self.attr['textxy'] = deepcopy(self.graph.attr('textxy', ['']))
+        self.attr['textargs'] = deepcopy(self.graph.attr('textargs', [{}]))
         if not isinstance(self.attr['text'], list):
             self.attr['text'] = [self.attr['text']]
         if not isinstance(self.attr['textxy'], list):
             self.attr['textxy'] = [self.attr['textxy']]
         if not isinstance(self.attr['textargs'], list):
             self.attr['textargs'] = [self.attr['textargs']]
         while len(self.attr['textxy']) < len(self.attr['text']):
             self.attr['textxy'].append('')
         while len(self.attr['textargs']) < len(self.attr['text']):
             self.attr['textargs'].append({})
-        # override xytext in textargs with content of textxy - later can ignore textxy
+        # override xytext in textargs with content of textxy - later can ignore
+        # textxy
         for i in range(len(self.attr['textxy'])):
             if self.attr['textxy'][i] != '':
                 self.attr['textargs'][i].update({'xytext': self.attr['textxy'][i]})
         if self.attr['text'] == ['']:
             self.attr['text'] = []
-        
+
     def fillUIMain(self, frame):
-        self.frameGrid = tk.Frame(frame)
-        self.frameGrid.pack(side='top', anchor='w')
-        self.fillUITextGrid(self.frameGrid)
-        
         self.legendGrid = tk.Frame(frame)
         self.legendGrid.pack(side='top', anchor='w')
         self.fillUILegendGrid(self.legendGrid)
-        
-        self.legTitGrid = tk.Frame(frame)
+
+        self.legTitGrid = tk.Frame(frame, pady=10)
         self.legTitGrid.pack(side='top', anchor='w')
         self.fillUILegendTitleGrid(self.legTitGrid)
-        
+
+        self.frameGrid = tk.Frame(frame)
+        self.frameGrid.pack(side='top', anchor='w')
+        self.fillUITextGrid(self.frameGrid)
+
         frm = tk.Frame(frame)
         frm.pack()
         self.fillUIButtons(frm)
-    
+
     def fillUIButtons(self, frame):
-        self.ButtonRevert = tk.Button(frame, text='Revert to initial', fg='grey', command=self.revert)
+        self.ButtonRevert = tk.Button(frame, text='Revert to initial',
+                                      fg='grey', command=self.revert)
         self.ButtonRevert.pack(side='left')
-        self.ButtonQuit = tk.Button(frame, text='Quit', fg='grey', command=self.close_windows)
+        self.ButtonQuit = tk.Button(frame, text='Quit', fg='grey',
+                                    command=self.close_windows)
         self.ButtonQuit.pack(side='left', padx=10)
-        self.ButtonGo = tk.Button(frame, text='Update graph', command=self.go, font=self.fontBold)
+        self.ButtonGo = tk.Button(frame, text='Update graph', command=self.go,
+                                  font=self.fontBold)
         self.ButtonGo.pack(side='right', padx=30)
-    
+
     def fillUITextGrid(self, frame):
         self.parseGraph()
         # remove previsously created widgets, start afresh
         if self.annotationsnew is not None:
             self.annotationsnew.destroy()
             self.annotationsnew = None
         for row in self.annotations:
@@ -185,98 +188,110 @@
                 if hasattr(field, 'destroy'):
                     field.destroy()
         self.annotations = []
         args = []
         for j in range(len(self.attr['text'])):
             self.annotations.append([''] * len(self.textfields))
             args.append(deepcopy(self.attr['textargs'][j]))
-        self.annotations.append([''] * len(self.textfields)) # for new text
-        args.append({}) # defautl new
+        self.annotations.append([''] * len(self.textfields))  # for new text
+        args.append({})  # defautl new
         for j in range(len(self.textfields)):
             field = self.textfields[j]
             e = tk.Label(frame, text=field['label'])
             e.grid(row=0, column=(j+1))
             if 'tooltip' in field:
                 CreateToolTip(e, field['tooltip'])
             # data fields and new text fields
             kw = field['fromkwargs']
             for i in range(len(self.attr['text'])+1):
                 value = ''
-                if i == len(self.attr['text']): # "new" text field
+                if i == len(self.attr['text']):  # "new" text field
                     value = ''
-                elif field['label'] == 'text': # text: take it from attr['text']
-                    value = self.attr['text'][i].replace('\n', '\\n')
-                else: # otherwise must grab it from the textargs dict
+                elif field['label'] == 'text':  # text: from attr['text']
+                    value = varToStr(self.attr['text'][i])
+                else:  # otherwise must grab it from the textargs dict
                     if kw != '' and kw in args[i]:
                         value = args[i][kw]
                         del args[i][kw]
                     elif j == len(self.textfields) - 1:
-                        value = str(args[i])
+                        value = varToStr(args[i])
                 if value == '' and 'default' in field:
                     value = field['default']
                 e = None
                 if field['field'] == 'OptionMenu':
-                    e = OptionMenuVar(frame, values=field['values'], default=str(value))
+                    e = OptionMenuVar(frame, values=field['values'],
+                                      default=str(value))
                 elif field['field'] == 'Checkbutton':
-                    e = CheckbuttonVar(frame, '', default=(bool(value) if value != '' else False))
+                    defval = bool(value) if value != '' else False
+                    e = CheckbuttonVar(frame, '', default=defval)
                 if field['field'] == 'Combobox':
-                    e = ComboboxVar(frame, field['values'], default=str(value), width=field['width'])
+                    e = ComboboxVar(frame, field['values'], default=str(value),
+                                    width=field['width'])
                 elif field['width'] > 0:
                     e = EntryVar(frame, str(value), width=field['width'])
                 if e is not None:
                     self.annotations[i][j] = e
                     e.grid(column=(j+1), row=(i+1), pady=0, ipady=0, padx=1)
         tk.Label(frame, text='Text', font=self.fontBold).grid(row=0, column=0)
         self.annotationsnew = tk.Label(frame, text='New',  font=self.fontBold)
         self.annotationsnew.grid(row=(len(self.attr['text'])+1), column=0)
         for j in range(len(self.textfields)):
             if self.textfields[j]['label'] == 'xytext':
-                self.annotations[-1][j].set('(0.05,0.95)')
+                self.annotations[-1][j].set('(0.05, 0.95)')
 
     def fillUILegendGrid(self, frame):
         Labels = []
         for j in range(len(self.legendfields)):
             field = self.legendfields[j]
             Labels.append(tk.Label(frame, text=field['label']))
             if field['width'] == 0:
                 Labels[-1].configure(font=self.fontBold)
-            Labels[j].grid(row=(0 if field['width']!=0 else 1), column=j)
+            Labels[j].grid(row=(0 if field['width'] != 0 else 1), column=j)
             if 'tooltip' in field:
                 CreateToolTip(Labels[j], field['tooltip'])
             self.legendvars[j].append(tk.StringVar())
             e = None
             if field['field'] == 'OptionMenu':
-                e = tk.OptionMenu(frame, self.legendvars[j][-1], *field['values'])
+                e = tk.OptionMenu(frame, self.legendvars[j][-1],
+                                  *field['values'])
             if field['field'] == 'Combobox':
-                e = ttk.Combobox(frame, textvariable=self.legendvars[j][-1], values=field['values'], width=field['width'])
+                e = ttk.Combobox(frame, textvariable=self.legendvars[j][-1],
+                                 values=field['values'], width=field['width'])
             elif field['width'] > 0:
-                e = tk.Entry(frame, width=field['width'], textvariable=self.legendvars[j][-1])
+                e = tk.Entry(frame, width=field['width'],
+                             textvariable=self.legendvars[j][-1])
             if e is not None:
                 e.grid(column=j, row=len(self.legendvars[j]), padx=1)
-        self.legendTitleFillValues('legendproperties', self.legendfields, self.legendvars)
+        self.legendTitleFillValues('legendproperties', self.legendfields,
+                                   self.legendvars)
+
     def fillUILegendTitleGrid(self, frame):
         Labels = []
         # legend title
         for j in range(len(self.legtitfields)):
             field = self.legtitfields[j]
             if field['width'] != 0:
                 Labels.append(tk.Label(frame, text=field['label']))
                 Labels[-1].grid(row=0, column=j)
             if 'tooltip' in field:
                 CreateToolTip(Labels[-1], field['tooltip'])
             self.legtitvars[j].append(tk.StringVar())
             e = None
             if field['field'] == 'OptionMenu':
-                e = tk.OptionMenu(frame, self.legtitvars[j][-1], *field['values'])
+                e = tk.OptionMenu(frame, self.legtitvars[j][-1],
+                                  *field['values'])
             if field['field'] == 'Combobox':
-                e = ttk.Combobox(frame, textvariable=self.legtitvars[j][-1], values=field['values'], width=field['width'])
+                e = ttk.Combobox(frame, textvariable=self.legtitvars[j][-1],
+                                 values=field['values'], width=field['width'])
             elif field['width'] > 0:
-                e = tk.Entry(frame, width=field['width'], textvariable=self.legtitvars[j][-1])
+                e = tk.Entry(frame, width=field['width'],
+                             textvariable=self.legtitvars[j][-1])
             if e is not None:
-                e.grid(column=j, row=len(self.legtitvars[j]), ipady=0, pady=0, padx=1)
+                e.grid(column=j, row=len(self.legtitvars[j]), ipady=0, pady=0,
+                       padx=1)
         # graph title
         self.legtitfields[5].update({'values': ["(0,1)", "(0.5, 0.95)"]})
         for j in range(len(self.legtitfields)):
             field = self.legtitfields[j]
             # graph title
             self.legtitvars[j].append(tk.StringVar())
             if 'field' not in field:
@@ -290,16 +305,15 @@
                 e = tk.Entry(frame, width=field['width'], textvariable=self.legtitvars[j][-1])
             if e is not None:
                 e.grid(column=j, row=len(self.legtitvars[j]), ipady=0, pady=0, padx=1)
         tk.Label(frame, text='Legend title', font=self.fontBold).grid(row=1, column=0)
         tk.Label(frame, text='Graph title',  font=self.fontBold).grid(row=2, column=0, sticky='W')
         self.legendTitleFillValues('legendtitle', self.legtitfields, self.legtitvars, row=0)
         self.legendTitleFillValues('title', self.legtitfields, self.legtitvars, row=1)
-            
-        
+
     def legendTitleFillValues(self, attribute, fields, vars_, row=0):
         attr = deepcopy(self.graph.getAttribute(attribute))
         vals = [''] * len(fields)
         vals[-1] = attr
         if attribute in ['title', 'legendtitle']:
             if not isinstance(attr, list):
                 attr = [attr, {}]
@@ -308,102 +322,112 @@
         elif attribute in ['legendproperties']:
             if vals[-1] == '':
                 vals[-1] = {}
         for i in range(len(fields)):
             if 'fromkwargs' in fields[i]:
                 key = fields[i]['fromkwargs']
                 if attribute == 'title' and key == 'align':
-                    key = 'loc' # different keyword for same stuff
+                    key = 'loc'  # different keyword for same stuff
                 if key in vals[-1]:
                     vals[i] = str(vals[-1][key])
                     del vals[-1][key]
             if vals[i] == '' and 'default' in fields[i]:
                 vals[i] = fields[i]['default']
-        vals[1] = vals[1].replace('\n','\\n')
+        vals[1] = vals[1].replace('\n', '\\n')
         for j in range(0, len(vars_)):
             vars_[j][row].set(vals[j])
 
-    
     def go(self):
         # text annotations
         out = {'text': [], 'textxy': [], 'textargs': []}
         i = 0
         for ann in self.annotations:
-            if ann[1].get() is not '':
-                out['text'].append(ann[1].get().replace('\\n', '\n'))
-                args = stringToVariable(ann[-1].get())
+            if ann[1].get() != '':
+                out['text'].append(strUnescapeIter(ann[1].get()))  # as str
+                args = strToVar(ann[-1].get())
                 if not isinstance(args, dict):
-                    print('GuiManagerAnnotations invalid input:', args, 'should be a dict')
+                    print('GuiManagerAnnotations invalid input:', args,
+                          'should be a dict')
                     args = {}
                 for j in range(len(self.textfields)-1):
                     if self.textfields[j]['fromkwargs'] != '':
-                        val = stringToVariable(ann[j].get())
+                        val = strToVar(ann[j].get())
                         if self.textfields[j]['label'] == 'xytext':
                             if not isinstance(val, (list, tuple)):
-                                print('GuiManagerAnnotations invalid input: (xytext)', val, 'should be a tuple or dict with 2 elements (coordinates)')
+                                print('GuiManagerAnnotations invalid input:',
+                                      '(xytext)', val, 'should be a tuple or',
+                                      'dict with 2 elements (coordinates)')
                         if self.textfields[j]['label'] == 'visible?' and val:
                             val = ''
                         if val != '':
                             args.update({self.textfields[j]['fromkwargs']: val})
                 out['textxy'].append('')
                 out['textargs'].append(args)
             i += 1
         # legend title, graph title
         keywords = ['legendtitle', 'title']
         for j in range(len(keywords)):
-            tit = self.legtitvars[1][j].get().replace('\\n','\n')
-            kw = stringToVariable(self.legtitvars[-1][j].get())
+            tit = strUnescapeIter(self.legtitvars[1][j].get())  # as str
+            kw = strToVar(self.legtitvars[-1][j].get())
             if not isinstance(kw, dict):
-                print('GuiManagerAnnotations invalid input:', kw, 'should be a dict (legendtitle)')
+                print('GuiManagerAnnotations invalid input:', kw,
+                      'should be a dict (legendtitle)')
                 kw = {}
             for i in range(len(self.legtitfields)):
                 if 'fromkwargs' in self.legtitfields[i]:
                     if self.legtitvars[i][j].get() != '':
-                        val = stringToVariable(self.legtitvars[i][j].get())
+                        val = strToVar(self.legtitvars[i][j].get())
                         if 'casttype' in self.legtitfields[i]:
                             val = self.legtitfields[i]['casttype'](val)
                         kw.update({self.legtitfields[i]['fromkwargs']: val})
             if keywords[j] == 'title' and 'align' in kw:
                 kw['loc'] = kw['align']
                 del kw['align']
             legtit = tit if kw in ['', {}] else [tit, kw]
             out.update({keywords[j]: legtit})
         # legend properties
-        kw = stringToVariable(self.legendvars[-1][0].get())
+        kw = strToVar(self.legendvars[-1][0].get())
         if not isinstance(kw, dict):
-            print('GuiManagerAnnotations invalid input:', kw, 'should be a dict (legend)')
+            print('GuiManagerAnnotations invalid input:', kw,
+                  'should be a dict (legend)')
             kw = {}
         for i in range(len(self.legendfields)):
             if 'fromkwargs' in self.legendfields[i]:
                 if self.legendvars[i][0].get() != '':
-                    val = stringToVariable(self.legendvars[i][0].get())
+                    val = strToVar(self.legendvars[i][0].get())
                     if 'casttype' in self.legendfields[i]:
                         val = self.legendfields[i]['casttype'](val)
                     kw.update({self.legendfields[i]['fromkwargs']: val})
         out.update({'legendproperties': kw})
         # graph title
-        
         # perform update, finish
-        #print('sent to GUI', out)
+        # print('sent to GUI', out)
         self.funcupdate(out)
         self.refreshUI()
+
     def revert(self):
         self.funcupdate(self.oldattr)
         self.refreshUI()
+
     def refreshUI(self):
         self.fillUITextGrid(self.frameGrid)
-        self.legendTitleFillValues('legendtitle', self.legtitfields, self.legtitvars)
+        self.legendTitleFillValues('legendtitle', self.legtitfields,
+                                   self.legtitvars)
+
     def close_windows(self):
         self.master.destroy()
-    
 
-    
-        
-        
+
 def buildUI():
     from grapa.graph import Graph
     root = tk.Tk()
-    app = GuiManagerAnnotations(root, Graph(r'.\..\examples\fancyAnnotations.txt'), None)
+    graph = Graph(r'.\..\examples\fancyAnnotations.txt')
+
+    def funcupdate(*args):
+        for a in args:
+            graph.update(a)
+    app = GuiManagerAnnotations(root, graph, funcupdate)
     app.mainloop()
 
+
 if __name__ == "__main__":
-    buildUI()
+    buildUI()
```

### Comparing `grapa-0.5.4.8/grapa/GUI.py` & `grapa-0.6.1.0/grapa/gui/GUIMainElements.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,2099 +1,2203 @@
-# -*- coding: utf-8 -*-
+# -*- coding: utf-8 -*-
 """
 @author: Romain Carron
-Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics,
+Romain Carron
 """
-
-print ('Loading matplotlib...')
-import matplotlib
-matplotlib.use("TkAgg")
+import sys
+import os
+import copy
+import numpy as np
+import tkinter as tk
+from tkinter import ttk
+import matplotlib.pyplot as plt
 from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
 try:
     from matplotlib.backends.backend_tkagg import NavigationToolbar2TkAgg as NavigationToolbar2Tk
 except ImportError:
     from matplotlib.backends.backend_tkagg import NavigationToolbar2Tk
-import matplotlib.pyplot as plt
-print('Loading tkinter...')
-import tkinter as tk
-from tkinter import ttk
-from tkinter import BOTH, X, Y
-import tkinter.filedialog
 
-print('Loading os...')
-import os
-print('Loading numpy...')
-import numpy as np
-print('Loading copy')
-import copy
-print('Loading sys...')
-import sys
-import contextlib
-
-print('Loading grapa...')
-path = os.path.normpath(os.path.join(os.path.dirname(os.path.abspath(__file__)), '..'))
+path = os.path.normpath(os.path.join(os.path.dirname(os.path.abspath(__file__)),
+                                     '..', '..'))
 if path not in sys.path:
     sys.path.append(path)
 from grapa.graph import Graph
-from grapa.graphIO import FILEIO_GRAPHTYPE_GRAPH
 from grapa.curve import Curve
-from grapa.mathModule import is_number, stringToVariable, roundSignificant
+from grapa.graphIO import FILEIO_GRAPHTYPE_GRAPH
+from grapa.mathModule import strToVar, varToStr, roundSignificant, is_number, listToString
 from grapa.colorscale import Colorscale, PhotoImageColorscale
-from grapa.observable import Observable, ObserverStringVarMethodOrKey
+from grapa.gui.GUImisc import TextWriteable, bind_tree
+from grapa.gui.GUImisc import imageToClipboard, FrameTitleContentHide, FrameTitleContentHideHorizontal
+from grapa.gui.GUImisc import EntryVar, OptionMenuVar, CheckbuttonVar, ComboboxVar, LabelVar
 from grapa.gui.createToolTip import CreateToolTip
-from grapa.gui.GUImisc import FrameTitleContentHide, FrameTitleContentHideHorizontal
-from grapa.gui.GUImisc import imageToClipboard, EntryVar, OptionMenuVar, CheckbuttonVar, ComboboxVar
-
-# WISHLIST:
-# - config autotemplate for boxplot
-# - B+W preview
-# Stackplot: transparency Alpha ?
-
-# BUG: fit JV, when unit in mV
-# - Add button reverse curve order
-
-# TODO: Write workflow Cf
-# TODO: Write workflow CV
-# TODO: Write workflow JV
-# TODO: Write workflow Jsc Voc
+from grapa.gui.GUIgraphManager import GraphsTabManager
+from grapa.gui.GUIFuncGUI import FuncGUI
 
-# TODO LIST PRIORITY
-# - colorbar: also shortcut for type image?
-
-# TODO: CurveSpectrum: order
-# TODO: test from grapa. impor t Curve, Graph
-# TODO graph handler, for multiple graph tabs
-# TODO: export: figugsize () into list
-
-
-# TODO: folder auto when fileis open
-
-
-# Version 0.5.4.8
-# Modifications
-# - TRPL: the data type TRPL was  modified to properly load files generated using scripts.
-# - Modified loading of preference file. Hopefully a bit faster when opening many files.
-# - CurveJV: added data transform 'Log10 abs (raw)' (abs0), to plot the log of JV curve without Jsc subtraction
-# - scriptJV: also exports a file with a few statistical quantities of JV data (average, mediam, max)
-# - scriptJV: reduced amount of generated files. The individual summary images are not generated anymore as already plotted in combined format. Also, the different cells are exported as images (3x) and only once as text file.
-# - prepare future update of the GUI to support several graphs simultaneously
-# BUGS:
-# - Mitigated bugs with Winpython version 3.9 (issues with matplotlib 3.3.9; hidden curves in grey due to changes in tk)
-
-
-
-# Version 0.5.4.7
-# Modifications
-# - Adjusted width of GUI Curve action fields for CurveSIMS to prevent time-consuming redimensioning of the GUI interface.
-# - The Colorize GUI function can now print its effect in the console
-# Bugs
-# - Solved an issue with twiny ylim values
-
-
-# Version 0.5.4.6
-# - Added Integration function to the CurveTRPL and CurveSpectrum
-# - Fixed a bug with Colorize function with curve selection where the order was not sorted under some conditions.
-
-# Version 0.5.4.5
-# Changes
-# - CurveTRPL: small changes in the handling of TRPL data label and normalization factors
-# - CurveCV: change in labeling for doping extracted at given voltage
-
-"""
-*** *** *** example of config.txt file *** *** ***
-# only keywords (first word) matters: comment line are loaded but never refered
-# to repeating keyword will overwrite content of first instance
-# graph labels default unit presentation: [unit], (unit), / unit, or [], (), /
-graph_labels_units	[]
-# graph labels presence of symbols (ie: $C$ in 'Capacitance $C$ [nF]')
-graph_labels_symbols	False
-# path to inkscape executable, to export in .emf image format. Can be a string, or a list of strings
-inkscape_path	["C:\Program Files\Inkscape\inkscape.exe", "G:\__CommonData\Software\_inkscape_standalone\32bits\App\Inkscape\inkscape.exe"]
-# GUI default colorscales. Each colorscale is represented as a string (matplotlib colorscales), or a list of colors.
-# Each color can be a [r,g,b] triplet, a [r,g,b,a] quadruplet, or a [h,l,s,'hls'] quadruplet. rgb, rgba, hls, hsv colorscape are supported.
-GUI_colorscale00	[[1,0,0], [1,1,0.5], [0,1,0]]
-GUI_colorscale01	[[1,0.3,0], [0.7,0,0.7], [0,0.3,1]]
-GUI_colorscale02	[[1,0.43,0], [0,0,1]]
-GUI_colorscale03	[[0.91,0.25,1], [1.09,0.75,1], 'hls']
-GUI_colorscale04	[[0.70,0.25,1], [0.50,0.75,1], 'hls']
-GUI_colorscale05	[[1,0,1], [1,0.5,1], [0.5,0.75,1], 'hls']
-GUI_colorscale07	'inferno'
-GUI_colorscale10	'gnuplot2'
-GUI_colorscale11	'viridis'
-GUI_colorscale12	'afmhot'
-GUI_colorscale13	'YlGn'
-# default saving image format
-save_imgformat	.png
-*** *** *** end of example *** *** ***
-"""
 
+class GUIFrameCanvasGraph():
+    """
+    Handles the canvas with graph, and the toolbar
+    Contains a Frame, to be embedded in a wider application (.frame.pack())
+    Some methods will call methods of application
+    """
+
+    def __init__(self, master, application, **kwargs):
+        self.frame = tk.Frame(master, **kwargs)
+        self.app = application
+        # store a list of custom canvas event, to easily remove them
+        self.canvasEvents = []
+        # mechanism to fire events only when mouse is pressed
+        self._mousePressed = False
+        self.callback_notifyCanvas_registered = []
+        self.createWidgets(self.frame)
+        self.app.master.bind('<Control-w>', lambda e: self.closeTab())
 
-# new texyt field class, with possibility for write (print in this field)
-# used for the console output
-class TextWriteable(tk.Text):
-    def write(self, string):
-        self.insert(tk.END, string)
-        self.see(tk.END)
-
-
-# to be able to print in something else than default console
-@contextlib.contextmanager
-def stdout_redirect(where):
-    cp = sys.stdout
-    sys.stdout = where
-    try:
-        yield where
-    finally:
-        sys.stdout = cp  # sys.stdout = sys.__stdout__#does not work apparently
-
-
-class Application(tk.Frame):
-
-    def __init__(self, master=None):
-        self.initiated = False
-        # default graph creation arguments
-        self.newGraphKwargs = {'silent': True}
-        # retrieve arguments from command line
+    def updateUI(self):
+        """ Update plot on canvas """
+        # to update before the updateUI() call
+        self.fig.set_dpi(self.app.getTabProperties()['dpi'])
+        # update graph
+#        try:
+        fig, ax = Graph.plot(self.app.graph(), figAx=[self.fig, None])
+        while isinstance(ax, (list, np.ndarray)) and len(ax) > 0:
+            ax = ax[-1]
+        self.fig, self.ax = fig, ax
+        # except ValueError as e:
+        #     print('Exception ValueError during GUI plot canvas update.')
+        #     print('Exception', type(e), e)
+        #     pass
+        # draw canvas
         try:
-            self.newGraphKwargs.update({'config': sys.argv[1]})
-            # argv[1] is the config.txt file to be used in this session
-        except Exception:
+            self.canvas.show()
+        except AttributeError:
+            # handles FigureCanvasTkAgg has no attribute show in later
+            # versions of matplotlib
             pass
-        self.master = master
-        tk.Frame.__init__(self, master)
-        # initialize Graph object to some value
-        self.back_graph = Graph([[1,2,3,4,5,6,7,8], [5,6,1,3,8,9,3,5]], '', **self.newGraphKwargs)
-        # some gaphical configuration
-        self.defaultScreenDpi = 100
-        # start define GUI
-        self.pack(fill=BOTH, expand=True)
-        self.observableCurve = Observable()  # handles some of the changes in the GUI when changing the selected curve
-        self.observableDataPickerCurve = Observable()  # handles some of the changes in the GUI when changing the active curve in the data picker
-        FrameMain = tk.Frame(self)
-        FrameMain.pack(fill=BOTH, expand=True)
-        self.initFonts(FrameMain)
-        self.createWidgets(FrameMain)
-        # open default Graph
-        filename = os.path.join(os.path.dirname(os.path.abspath(__file__)),
-                                'examples', 'subplots_examples.txt')
-        self.file_open_internal(filename)
-
-        self.varScreenDpi.set(75)
-        self.setScreenDpi()
-        # update GUI
-        self.updateUI()
-        self.updateUI()
-        self.varDataPickerCurve.set(0)
-        self.initiated = True
-        self.master.bind('<Control-s>', lambda e: self.saveData())
-        self.master.bind('<Control-Shift-S>', lambda e: self.saveDataAs())
-        self.master.bind('<Control-o>', lambda e: self.file_open())
-        self.master.bind('<Control-Shift-O>', lambda e: self.file_merge())
-        # too larges chances to mess up with that one
-        # self.master.bind('<Control-v>', lambda e: self.clipboardToGraphOpen())
-        self.master.bind('<Control-Shift-V>', lambda e: self.clipboardToGraphMerge())
-        self.master.bind('<Control-Shift-N>', lambda e: self.newCurveMerge())
-        self.master.bind('<Control-r>', lambda e: self.updateUI())
-        self.master.bind('<Control-Shift-C>', lambda e: self.curveDataToClipboard())
-        self.master.bind('<Control-m>', lambda e: self.dataPickerSavePoint())
-        self.master.bind('<Control-h>', lambda e: self.curveShowHideCurve())
-        self.master.bind('<Control-Delete>', lambda e: self.curveDelete())
-
-    def createFrame(self, frame, func, dictArgsInit, dictArgsPack,
-                    argsFunc=None, geometry='pack'):
-        """
-        All frames are generated according to this 3-line pattern
-        1/ creation inside a know frame, 2/ pack, 3/ fill frame by executing a
-        function with frame name as parameter
-        Possible extension is to handle a different geometry manager
-        """
-        newFrame = tk.Frame(frame, **dictArgsInit)
-        if geometry == 'grid':
-            newFrame.grid(**dictArgsPack)
-        else:
-            newFrame.pack(**dictArgsPack)
-        if func is not None:
-            func(newFrame) if argsFunc is None else func(newFrame, *argsFunc)
-        return newFrame
-
-    def initFonts(self, frame):
-        import tkinter.font as font
-        a = tk.Label(frame, text='')
-        self.fontBold = font.Font(font=a['font'])
-        self.fontBold.configure(weight='bold')
+        self.canvas.draw()
 
     def createWidgets(self, frame):
-        # right frame
-        self.createFrame(frame, self.fillUIFrameRight, {'relief': 'raised', 'borderwidth': 2}, {'side': 'right', 'fill': Y, 'pady': 2, 'expand': False})
-        # frame left/graph/console
-        self.createFrame(frame, self.fillUIFrameMain, {},{'side': 'left', 'anchor': 'n', 'fill': BOTH, 'expand': True})
-
-    def fillUIFrameMain(self, frame):
-        # create console, indicators
-        self.createFrame(frame, self.fillUIFrameMainBottom, {}, {'side': 'bottom', 'fill': X})
-        # create graph and left menu
-        self.createFrame(frame, self.fillUIFrameMainTop,    {}, {'side': 'top', 'fill': BOTH, 'expand': True})
-
-    def fillUIFrameMainTop(self, frame):
-        # left frame
-        self.createFrame(frame, self.fillUIFrameLeft,   {'relief': 'raised', 'borderwidth': 2}, {'side': 'left', 'anchor': 'n', 'fill': Y, 'pady':2})
-        # graph + options frame
-        self.createFrame(frame, self.fillUIFrameCenter, {'relief': 'raised', 'borderwidth': 2}, {'side': 'left', 'anchor': 'n', 'fill': BOTH, 'pady':2, 'expand':True})
-
-    def fillUIFrameMainBottom(self, frame):
-        self.back_file = ''
-        self.varLabelFile = tk.StringVar()
-        self.varLabelFile.set('')
-        tk.Label(frame, textvariable=self.varLabelFile).pack(side='top', anchor='w')
-        # current folder
-        self.back_folder = ''
-        self.varLabelFolder = tk.StringVar()
-        self.varLabelFolder.set('')
-        tk.Label(frame, textvariable=self.varLabelFolder).pack(side='top', anchor='w')
-        # console
-        self.Console = TextWriteable(frame, wrap='word', width=100, height=8)
-        self.Console.pack(side='bottom', anchor='w')
+        self.cw_graphSelector(frame)
+        self.cw_canvas(frame)
 
-    def fillUIFrameLeft(self, frame):
-        # top inner frame
-        self.createFrame(frame, self.fillUIFrameLeftTop,   {'relief': 'raised', 'borderwidth': 0}, {'side': 'top', 'fill': X})
-        # middle inner frame
-        tk.Label(frame, text='').pack(side='top')
-        self.createFrame(frame, self.fillUIFrameLeftMiddleTitle, {}, {'side': 'top', 'fill': X})
-        self.createFrame(frame, self.fillUIFrameLeftMiddle,    {'relief': 'raised', 'borderwidth': 0}, {'side': 'top', 'anchor':'n', 'fill': X, 'expand': True})
-        self.createFrame(frame, self.fillUIFrameLeftQuitTitle, {}, {'side': 'top', 'fill': X})
-        self.createFrame(frame, self.fillUIFrameLeftQuit,      {}, {'side': 'top', 'fill': X})
-
-    def fillUIFrameLeftTop(self, frame):
-        # button chooseFile
-        self.createFrame(frame, self.fillUIFrameOpenTitle, {}, {'side': 'top', 'fill': X})
-        self.createFrame(frame, self.fillUIFrameOpen,      {}, {'side': 'top', 'fill': X, 'padx': 10})
-        # open folder
-        self.createFrame(frame, self.fillUIFrameLeftOpenFolder, {}, {'side': 'top', 'fill': X, 'padx':10, 'pady': 5})
-        # save graph
-        tk.Label(frame, text='').pack(side='top')
-        self.createFrame(frame, self.fillUIFrameSaveTitle, {}, {'side': 'top', 'fill': X})
-        self.createFrame(frame, self.fillUIFrameSave,  {}, {'side': 'top', 'fill': X, 'padx': '10'})
-        self.ValCheckbuttonSave = tk.IntVar()
-        self.ValCheckbuttonSave.set(0)
-        self.ValCheckbuttonSaveCompactnot = tk.IntVar()
-        self.ValCheckbuttonSaveCompactnot.set(0)
-        tk.Checkbutton(frame, text='Screen data (better not)', variable=self.ValCheckbuttonSave          ).pack(side='top', anchor='w', padx=5)
-        tk.Checkbutton(frame, text='Keep separated x columns', variable=self.ValCheckbuttonSaveCompactnot).pack(side='top', anchor='w', padx=5)
-
-    def fillUIFrameOpenTitle(self, frame):
-        tk.Label(frame, text='Open or merge files', font=self.fontBold).pack(side='left', anchor='center')
-        hline = FrameTitleContentHide.frameHline(frame)
-        hline.pack(side='left', anchor='center', fill=X, expand=1, padx=5)
-
-    def fillUIFrameOpen(self, frame):
-        tk.Label(frame, text='Open').grid(sticky='w', row=0, column=0)
-        of = tk.Button(frame, text='File  ',  command=self.file_open)
-        oc = tk.Button(frame, text='Clipboard', command=self.clipboardToGraphOpen)
-        of.grid(sticky='w', row=0, column=1, padx=5)
-        oc.grid(sticky='w', row=0, column=2)
-        tk.Label(frame, text='Merge with').grid(sticky='w', column=0, row=1)
-        mf = tk.Button(frame, text='File  ',  command=self.file_merge)
-        mc = tk.Button(frame, text='Clipboard', command=self.clipboardToGraphMerge)
-        mf.grid(sticky='w', column=1, row=1, padx=5)
-        mc.grid(sticky='w', column=2, row=1)
-        CreateToolTip(of, "Ctrl+O")
-        CreateToolTip(mf, "Ctrl+Shift+O")
-        CreateToolTip(mc, "Ctrl+Shift+V")
-
-    def fillUIFrameLeftOpenFolder(self, frame):
-        self.varOpenFolderSubfolders = tk.BooleanVar()
-        u = tk.Button(frame, text='Open all in folder', command=self.folder_plot_combined)
-        u.grid(column=1, row=1, sticky='w')
-        CreateToolTip(u, 'Open all files in a given folder')
-        tk.Checkbutton(frame, text='subfolders', variable=self.varOpenFolderSubfolders).grid(column=2, row=1)
-        # tk.Button(frame, text='Plot all files', command=self.folder_plot_all).pack(side='top', anchor='w', padx=10)
-        u = tk.Button(frame, text='New empty Curve', command=self.appendNewEmptyCurve)
-        u.grid(column=1, row=2, sticky='w', columnspan=2)
-        CreateToolTip(u, 'for creating a new subplot, inset, image etc.')
-
-    def fillUIFrameSaveTitle(self, frame):
-        tk.Label(frame, text='Save data & graph', font=self.fontBold).pack(side='left', anchor='center')
-        hline = FrameTitleContentHide.frameHline(frame)
-        hline.pack(side='left', anchor='center', fill=X, expand=1, padx=5)
-
-    def fillUIFrameLeftMiddleTitle(self, frame):
-        tk.Label(frame, text='Data processing scripts', font=self.fontBold).pack(side='left', anchor='center')
-        hline = FrameTitleContentHide.frameHline(frame)
-        hline.pack(side='left', anchor='center', fill=X, expand=1, padx=5)
-    def fillUIFrameLeftMiddle(self, frame):
-        # button chooseFolder
-        tk.Label (frame, text='JV curves (files in 1 folder):').pack(side='top', anchor='w', padx=10, pady=2)
-        self.createFrame(frame, self.fillUIFrameLeftMiddleFitDiodeWeight,  {}, {'side': 'top', 'fill': X, 'padx': 20})
-        #tk.Label (frame, text='1 neutral, 10 increased weight').pack(side='top', anchor='w', padx=20)
-        tk.Button(frame, text='Fit cell-by-cell', command=self.folder_JV_combined).pack(side='top', anchor='w', padx=20)
-        tk.Button(frame, text='Fit curves separately', command=self.folder_JV_all).pack(side='top', anchor='w', padx=20)
-        tk.Label (frame, text='Operations on JV summaries:').pack(side='top', anchor='w', padx=0, pady=2)
-        tk.Button(frame, text='JV sample maps (1 file)', command=self.folder_JV_sampleMaps).pack(side='top', anchor='w', padx=10)
-        tk.Button(frame, text='JV boxplots (files in 1 folder)', command=self.folder_JV_boxplots).pack(side='top', anchor='w', padx=10)
-        tk.Label (frame, text='C-V, C-f, Jsc-Voc data processing').pack(side='top', anchor='w', padx=0, pady=2)
-        self.createFrame(frame, self.fillUIFrameLeftMiddleCV,    {}, {'side': 'top', 'fill': X, 'padx': 10})
-        tk.Button(frame, text='C-f (1 folder)', command=self.folder_Cf).pack(side='top', anchor='w', padx=10)
-        self.createFrame(frame, self.fillUIFrameLeftMiddleJscVoc,    {}, {'side': 'top', 'fill': X, 'padx': 10})
-#        tk.Label(frame, text='\n').pack(side='top')
-
-    def fillUIFrameLeftQuitTitle(self, frame):
-        tk.Label(frame, text='').pack(side='left', anchor='center')
-        hline = FrameTitleContentHide.frameHline(frame)
-        hline.pack(side='left', anchor='center', fill=X, expand=1, padx=5)
-    def fillUIFrameLeftQuit(self, frame):
-        self.varPrintCommands = CheckbuttonVar(frame, 'Commands in console', False, command=lambda: print('Commands printing is not fully tested yet'))
-        self.varPrintCommands.pack(side='left', anchor='center')
-        self.createFrame(frame, self.FrameLeftMiddleUpdateQuit,  {}, {'side':'right'})#{'side': 'top', 'fill': X})
+    def registerCallback_notifyCanvas(self, func):
+        self.callback_notifyCanvas_registered.append(func)
 
-    def fillUIFrameLeftMiddleCV(self, frame):
-        from grapa.datatypes.curveCV import CurveCV
-        self.varProcessCVROI = tk.StringVar()
-        self.varProcessCVROI.set(self.listToString(CurveCV.CST_MottSchottky_Vlim_def))
-        tk.Button(frame, text='C-V (1 folder)', command=self.folder_CV).pack(side='left', pady=2)
-        tk.Label (frame, text='ROI').pack(side='left', pady=2)
-        tk.Entry (frame, text=self.varProcessCVROI, width=10).pack(side='left', pady=2)
-    def fillUIFrameLeftMiddleJscVoc(self, frame):
-        from grapa.datatypes.curveJscVoc import CurveJscVoc
-        self.varProcessJscVocJscROI = tk.StringVar()
-        self.varProcessJscVocJscROI.set(str(CurveJscVoc.CST_Jsclim0))
-        tk.Button(frame, text='Jsc-Voc (1 file)', command=self.file_JscVoc).pack(side='left', pady=2)
-        lbl = tk.Label (frame, text='Jsc min')
-        lbl.pack(side='left', pady=2)
-        ent = tk.Entry (frame, text=self.varProcessJscVocJscROI, width=6)
-        ent.pack(side='left', pady=2)
-        CreateToolTip(lbl, "fit range of interest (min value or range), in mA/cm2")
-        CreateToolTip(ent, "fit range of interest (min value or range), in mA/cm2")
-
-    def FrameLeftMiddleUpdateQuit(self, frame):
-        #u = tk.Button(frame, text="Refresh GUI", command=self.updateUI)
-        #u.pack(side='left', anchor='n', padx=5, pady=2)
-        tk.Button(frame, text="QUIT", fg="red", command=self._quit).pack(side='right', anchor='n', pady=2, padx=5)
+    def cw_graphSelector(self, frame):
+        fr = tk.Frame(frame)
+        fr.pack(side='top', fill=tk.X)
+        # button close
+        fr1 = tk.Frame(fr, width=20, height=20)
+        fr1.propagate(0)
+        fr1.pack(side='right', anchor='n')
+        btn = tk.Button(fr1, text=u"\u2715", command=self.closeTab)  # 2A2F
+        btn.pack(side='left', anchor='n', fill=tk.BOTH, expand=True)
+        CreateToolTip(btn, 'Close selected tab. Ctrl+W')
+        # tabs
+        defdict = {'dpi': self.app.DEFAULT_SCREENDPI}
+        self.tabs = GraphsTabManager(fr, width=200, height=0, defdict=defdict)
+        self.tabs.pack(side='left', fill=tk.X, expand=True)
 
-
-    def fillUIFrameLeftMiddleFitDiodeWeight (self, frame):
-        lbl = tk.Label(frame, text='Fit weight diode region')
-        lbl.pack(side='left', anchor='n')
-        self.FolderFitDiodeWeight = tk.StringVar()
-        self.FolderFitDiodeWeight.set('5')
-        ent = tk.Entry(frame, text=self.FolderFitDiodeWeight, width=6)
-        ent.pack(side='left', anchor='n')
-        CreateToolTip(lbl, "1 neutral, 10 increased weight")
-        CreateToolTip(ent, "1 neutral, 10 increased weight")
-
-    def fillUIFrameCenter(self, frame):
-        # some container for graph
-        self.createFrame(frame, self.fillUIFrameGraphBelow,{}, {'side':'bottom', 'anchor':'w', 'fill': X})
-        self.createFrame(frame, self.fillUIFrameCenterTop, {}, {'side':'bottom', 'anchor':'w', 'fill':X})
-        self.createFrame(frame, self.fillUIFrameGraphBox,  {}, {'side':'top', 'anchor':'w', 'fill':BOTH, 'expand':True})
-    def fillUIFrameGraphBox(self, frame):
+    def cw_canvas(self, frame):
         # canvas for graph
-        figsize = Graph.FIGSIZE_DEFAULT
-        figsize = [figsize[0], figsize[1]*1.15]
-        self.Graph_fig = plt.figure(figsize=figsize, dpi=self.defaultScreenDpi)
-        self.canvas = FigureCanvasTkAgg(self.Graph_fig, master=frame)
-        self.canvas.get_tk_widget().configure(background='white',
-                                              width =1.03*Graph.FIGSIZE_DEFAULT[0]*self.defaultScreenDpi,
-                                              height=1.03*Graph.FIGSIZE_DEFAULT[1]*self.defaultScreenDpi)
-        #self.canvas.get_tk_widget().pack(side='top', anchor='w') #, fill=tk.BOTH, expand=True)
-        self.canvas.get_tk_widget().pack(side='top', anchor='w', fill=tk.BOTH, expand=True)
-        #Better to  use the resize event of canvas mpl_connect self.canvas.get_tk_widget().bind('<Configure>', self.updateUponResizeWindow)
-        self.callback_eventCanvasPressed = False
-        self.canvas.mpl_connect('resize_event',self.updateUponResizeWindow)
-        self.canvasEvents = []
-        # toolbar
-        self.canvas._tkcanvas.pack(side='top', anchor='w', expand=True, fill=BOTH) #, fill=BOTH, expand=True
-        self.createFrame(frame, self.fillUIFrameGraphBoxToolbar,  {}, {'side': 'top', 'anchor': 'w', 'fill': X})
+        dpi = self.app.DEFAULT_SCREENDPI
+        defsize = Graph.FIGSIZE_DEFAULT
+        figsize = [defsize[0], defsize[1]*1.15]
+        # canvassize = [1.03*defsize[0]*dpi, 1.03*defsize[1]*dpi]
+        self.fig = plt.figure(figsize=figsize, dpi=dpi)
+        self.canvas = FigureCanvasTkAgg(self.fig, master=frame)
+        self.canvas.get_tk_widget().configure(background='white')
+        # possibly also configure width=canvassize[0], height=canvassize[1]
+        self.canvas.get_tk_widget().pack(side='top', anchor='w', fill=tk.BOTH,
+                                         expand=True)
+        self.canvas.mpl_connect('resize_event', self.updateUponResizeWindow)
         try:
             self.canvas.show()
         except AttributeError:
-            pass # handles FigureCanvasTkAgg has no attribute show in later versions of matplotlib
-        self.Graph_ax = self.Graph_fig.add_subplot(111)
+            pass  # changes in later versions of FigureCanvasTkAgg
+        self.ax = self.fig.add_subplot(111)
+
+    def updateUponResizeWindow(self, *args):
+        # updates only when main application is ready
+        if self.app.initiated:
+            # print('updateUponResizeWindow args', args)
+            self.app.frameCentral.updateUI()  # only central part of UI
+
     def enableCanvasCallbacks(self):
+        """ restore suitable list of canvas callbacks, for datapicker """
         def callback_pressCanvas(event):
-            self.callback_eventCanvasPressed = True
+            self._mousePressed = True
             callback_notifyCanvas(event)
+
         def callback_releaseCanvas(event):
-            self.callback_eventCanvasPressed = False
+            self._mousePressed = False
+
         def callback_notifyCanvas(event):
-            if not self.callback_eventCanvasPressed:
+            if not self._mousePressed:
                 return
-            #print('Clicked at', event.xdata, event.ydata, 'curve', self.varDataPickerRestrict.get(), self.varDataPickerCurve.get())
-            xdata, ydata = event.xdata, event.ydata
-            self.varDataPickerIdx = np.nan
-            if event.xdata is not None and self.varDataPickerRestrict.get() and self.varDataPickerCurve.get() > -1:
-                curve = self.back_graph.curve(self.varDataPickerCurve.get())
-                if curve is not None:
-                    xdata, ydata, idx = curve.getPointClosestToXY(xdata, ydata, alter=self.back_graph.getAttribute('alter'))
-                    self.varDataPickerIdx = idx
-            if xdata is not None:
-                self.varDataPickerX.set(xdata)
-            if ydata is not None:
-                self.varDataPickerY.set(ydata)
-            self.callback_updateCrosshair()
+            for func in self.callback_notifyCanvas_registered:
+                func(event)
+            # print('Clicked at', event.xdata, event.ydata, 'curve')
+
         self.disableCanvasCallbacks()
-        self.canvasEvents.append(self.canvas.mpl_connect('button_press_event',callback_pressCanvas))
-        self.canvasEvents.append(self.canvas.mpl_connect('button_release_event',callback_releaseCanvas))
-        self.canvasEvents.append(self.canvas.mpl_connect('motion_notify_event',callback_notifyCanvas))
+        self.canvasEvents.append(self.canvas.mpl_connect('button_press_event', callback_pressCanvas))
+        self.canvasEvents.append(self.canvas.mpl_connect('button_release_event', callback_releaseCanvas))
+        self.canvasEvents.append(self.canvas.mpl_connect('motion_notify_event', callback_notifyCanvas))
+
     def disableCanvasCallbacks(self):
+        """ disable all registered canvas callbacks """
         for cid in self.canvasEvents:
             self.canvas.mpl_disconnect(cid)
+        self.canvasEvents.clear()
 
-    def fillUIFrameGraphBoxToolbar(self, frame):
-        u = tk.Button(frame, text='Refresh GUI', command=self.updateUI)
-        u.pack(side='left', anchor='center', padx=5, pady=2)
-        CreateToolTip(u, 'Ctrl+R')
-        tk.Button(frame, text='Save zoom/subplots', command=self.setLimitsSubplotsToCurrent).pack(side='left', anchor='center', padx=5, pady=2)
+    def closeTab(self):
+        """ Closes current tab """
+        self.tabs.pop()
+
+
+class GUIFrameCentralOptions:
+    """
+    Handles the options within central panel with data tranform, axis limits
+    Contains a Frame, to be embedded in a wider application (.frame.pack())
+    Some methods will call methods of application
+    """
+
+    def __init__(self, master, application, canvas, **kwargs):
+        self.frame = tk.Frame(master, **kwargs)
+        self.app = application
+        self.createWidgets(self.frame, canvas)
+
+    def updateUI(self):
+        graph = self.app.graph()
+        # to be called to update the frame:
+        self.alterListGUI = graph.alterListGUI()
+        # Data transform, plottype
+        [idx, display, alter, typePlot] = self.identifyDataTransform()
+        options = [i[0] for i in self.alterListGUI]
+        self.varAlter.resetValues(options, func=self.updateDataTransform)
+        for a in self.alterListGUI:
+            if a[0] == display:
+                self.varAlter.set(display)
+                break
+        self.varTypeplot.set(typePlot)
+        # labels, limits
+        xlim = graph.attr('xlim', ['', ''])
+        ylim = graph.attr('ylim', ['', ''])
+        xlim = [(x if not isinstance(x, str) and not np.isnan(x) else '') for x in xlim]
+        ylim = [(y if not isinstance(y, str) and not np.isnan(y) else '') for y in ylim]
+        self.varXlabel.set(varToStr(graph.attr('xlabel')))
+        self.varYlabel.set(varToStr(graph.attr('ylabel')))
+        self.varXlim0.set(varToStr(xlim[0]))
+        self.varXlim1.set(varToStr(xlim[1]))
+        self.varYlim0.set(varToStr(ylim[0]))
+        self.varYlim1.set(varToStr(ylim[1]))
+        self._varDPI.set(self.app.getTabProperties()['dpi'])
+
+    def createWidgets(self, frame, canvas):
+        # toolbar
+        fr0 = tk.Frame(frame)
+        fr0.pack(side='top', anchor='w', fill=tk.X)
+        self.cw_toolbar(fr0, canvas)
+        # line 1
+        fr1 = tk.Frame(frame)
+        fr1.pack(side='top', anchor='w', fill=tk.X)
+        self.cw_line1(fr1)
+        # line 2
+        fr2 = tk.Frame(frame)
+        fr2.pack(side='top', anchor='w', fill=tk.X)
+        self.cw_line2(fr2)
+
+    def cw_toolbar(self, frame, canvas):
+        btn0 = tk.Button(frame, text='Refresh GUI', command=self.app.updateUI)
+        btn0.pack(side='left', anchor='center', padx=5, pady=2)
+        CreateToolTip(btn0, 'Ctrl+R')
+        btn1 = tk.Button(frame, text='Save zoom/subplots',
+                         command=self._setLimitsSubplots)
+        btn1.pack(side='left', anchor='center', padx=5, pady=2)
         tk.Label(frame, text="   ").pack(side='left')
-        self.toolbar = NavigationToolbar2Tk(self.canvas, frame)
+        frame2 = tk.Frame(frame)
+        self.toolbar = NavigationToolbar2Tk(canvas, frame)
         self.toolbar.update()
 
-    def fillUIFrameGraphBelow(self, frame):
-        self.createFrame(frame, self.fillUIFrameGraphQuickMods,  {}, {'side': 'top', 'anchor': 'w', 'fill': X})
-        FrameTitleContentHideHorizontal(frame, self.fillUIFrameGraphDataPickerTitle, self.fillUIFrameGraphDataPicker,
-                              default='hide', showHideTitle=True).pack(side='top', fill=X, anchor='w')
-
-    def fillUIFrameGraphDataPickerTitle(self, frame):
-        tk.Label(frame, text='Data picker').pack(side='top')
-    def fillUIFrameGraphDataPicker(self, frame):
-        self.createFrame(frame, self.fillUIFrameGraphDataPickerUp, {}, {'side': 'top', 'anchor': 'w', 'fill': X})
-        self.createFrame(frame, self.fillUIFrameGraphDataPickerDwn,{}, {'side': 'top', 'anchor': 'w', 'fill': X})
-    def fillUIFrameGraphDataPickerUp(self, frame):
-        tk.Label (frame, text='Click on graph').pack(side='left', anchor='c')
-        self.varDataPickerX = tk.DoubleVar()
-        self.varDataPickerY = tk.DoubleVar()
-        self.varDataPickerRestrict = tk.BooleanVar()
-        self.varDataPickerCurve = tk.IntVar()
-        self.varDataPickerCurve.set(0)
-        self.varDataPickerCurve.trace("w", self.callback_dataPickerCurve)
-        self.varDataPickerCrosshair = tk.BooleanVar()
-        self.varDataPickerIdx = np.nan
-        tk.Label (frame, text='x').pack(side='left', anchor='c')
-        tk.Entry(frame, text=self.varDataPickerX, width=10).pack(side='left', anchor='c')
-        tk.Label (frame, text='y').pack(side='left', anchor='c')
-        tk.Entry(frame, text=self.varDataPickerY, width=10).pack(side='left', anchor='c')
-        tk.Checkbutton(frame, text='Restrict to data', variable=self.varDataPickerRestrict).pack(side='left', anchor='c')
-        tk.Label (frame, text='curve').pack(side='left', anchor='c')
-        self.optionmenuDataPickerCurve = tk.OptionMenu(frame, self.varDataPickerCurve, '')
-        self.optionmenuDataPickerCurve.pack(side='left', anchor='c')
-        tk.Checkbutton(frame, text='Crosshair', variable=self.varDataPickerCrosshair, command=self.callback_updateCrosshair).pack(side='left', anchor='c')
-    def fillUIFrameGraphDataPickerDwn(self, frame):
-        tk.Button(frame, text='Create text with coordinates', command=self.dataPickerToTextbox).pack(side='left', anchor='c')
-        tk.Label(frame, text=' or ').pack(side='left')
-        u = tk.Button(frame, text='Save point', command=self.dataPickerSavePoint)
-        u.pack(side='left', anchor='c')
-        CreateToolTip(u, 'Ctrl+M')
-        self.varDataPickerSaveTransform = tk.BooleanVar()
-        self.varDataPickerSaveTransform.set(True)
-        tk.Checkbutton(frame, text='screen data', variable=self.varDataPickerSaveTransform).pack(side='left', anchor='c')
-        self.varDataPickerSaveCurveSpec = tk.BooleanVar()
-        self.varDataPickerSaveCurveSpec.set(False)
-        tk.Checkbutton(frame, text='Curve specific', variable=self.varDataPickerSaveCurveSpec).pack(side='left', anchor='c')
-        # explanatory text for checkbox
-        ObsDataPickerSpecific = ObserverStringVarMethodOrKey(tk.StringVar(), '', 'getDataCustomPickerXY', methodArgs=[0], methodKwargs={'strDescription': True})
-        self.observableDataPickerCurve.register(ObsDataPickerSpecific)
-        tk.Label(frame, textvariable=ObsDataPickerSpecific.var()).pack(side='left')
-
-    def callback_dataPickerCurve(self, *args):
-        # callback get some arguments which we are not using
-        # the observer pattern is an overkill here, but it is slightly cleaner
-        curve = self.varDataPickerCurve.get()
-        self.observableDataPickerCurve.update_observers(self.back_graph.curve(curve) if curve > -1 else None)
-
-
-    def fillUIFrameGraphQuickMods(self, frame):
-        #tk.Label (frame, text='Quick modifs').pack(side='left', anchor='c')
-        self.varQuickModsXlabel = EntryVar(frame, '', width=15)
-        self.varQuickModsYlabel = EntryVar(frame, '', width=15)
-        self.varQuickModsXlim0  = EntryVar(frame, '', width=5)
-        self.varQuickModsXlim1  = EntryVar(frame, '', width=5)
-        self.varQuickModsYlim0  = EntryVar(frame, '', width=5)
-        self.varQuickModsYlim1  = EntryVar(frame, '', width=5)
-        tk.Label (frame, text='xlabel:').pack(side='left', anchor='c')
-        self.varQuickModsXlabel.pack          (side='left', anchor='c')
-        tk.Label (frame, text='   ylabel:').pack(side='left', anchor='c')
-        self.varQuickModsYlabel.pack          (side='left', anchor='c')
-        tk.Label (frame, text='   xlim:').pack(side='left', anchor='c')
-        self.varQuickModsXlim0.pack     (side='left', anchor='c')
-        tk.Label (frame, text='to').pack(side='left', anchor='c')
-        self.varQuickModsXlim1.pack     (side='left', anchor='c')
-        tk.Label (frame, text='   ylim:').pack(side='left', anchor='c')
-        self.varQuickModsYlim0.pack     (side='left', anchor='c')
-        tk.Label (frame, text='to').pack(side='left', anchor='c')
-        self.varQuickModsYlim1.pack     (side='left', anchor='c')
-        tk.Label(frame, text='   ').pack(side='left')
-        tk.Button(frame, text='Save', command=self.quickMods).pack(side='left', anchor='c')
-        tk.Label(frame, text='   ').pack(side='left')
-        self.varQuickModsXlabel.bind('<Return>', lambda event: self.quickMods())
-        self.varQuickModsYlabel.bind('<Return>', lambda event: self.quickMods())
-        self.varQuickModsXlim0.bind ('<Return>', lambda event: self.quickMods())
-        self.varQuickModsXlim1.bind ('<Return>', lambda event: self.quickMods())
-        self.varQuickModsYlim0.bind ('<Return>', lambda event: self.quickMods())
-        self.varQuickModsYlim1.bind ('<Return>', lambda event: self.quickMods())
-        tk.Button(frame, text='Data editor', command=self.popupDataEditor).pack(side='right', anchor='c')
-
-    def fillUIFrameCenterTop(self, frame):
-        tk.Label (frame, text='Data transform').pack(side='left', anchor='n', pady=7)
-        self.alterListGUI = self.back_graph.alterListGUI()
-        [idx, display, alter, typePlot] = self.plotChangeView_identify()
-        self.OMAlter = OptionMenuVar(frame, [i[0] for i in self.alterListGUI],
-                                        default=display, func=self.plotChangeView2)
-        self.OMAlter.pack(side='left', anchor='center')
+    def cw_line1(self, frame):
+        lbl = tk.Label(frame, text='Data transform')
+        lbl.pack(side='left', anchor='n', pady=7)
+        # varAlter initially empty, gets updated frequently
+        self.varAlter = OptionMenuVar(frame, [''], default='')
+        self.varAlter.pack(side='left', anchor='center')
         # button change graph type
-        tk.Label (frame, text='   Plot type').pack(side='left', anchor='n', pady=7)
-        plotTypeList = ['', 'plot', 'plot norm.', 'semilogy', 'semilogy norm.', 'semilogx', 'loglog']
-        self.OMTypePlot = OptionMenuVar(frame, plotTypeList, default='',
-                                           func=self.plotTypePlot)
-        self.OMTypePlot.pack(side='left')
+        lbl = tk.Label(frame, text='   Plot type')
+        lbl.pack(side='left', anchor='n', pady=7)
+        plotTypeList = ['', 'plot', 'plot norm.', 'semilogy', 'semilogy norm.',
+                        'semilogx', 'loglog']
+        self.varTypeplot = OptionMenuVar(frame, plotTypeList, default='',
+                                         func=self.updateTypeplot)
+        self.varTypeplot.pack(side='left')
         # popup to handle text annotations
         tk.Label(frame, text='     ').pack(side='left')
-        tk.Button(frame, text='Annotations, legend and titles', command=self.popupAnnotations).pack(side='left', anchor='n', pady=5)
+        btn = tk.Button(frame, text='Annotations, legend and titles',
+                        command=self.popupAnnotations)
+        btn.pack(side='left', anchor='n', pady=5)
         # screen dpi
-        self.createFrame(frame, self.fillUIFrameCenterTopDPI, {}, {'side': 'right', 'anchor': 'n'})
-
-
-    def fillUIFrameCenterTopDPI(self, frame):
-        self.varScreenDpi = tk.StringVar()
-        self.varScreenDpi.set(self.defaultScreenDpi)
-        tk.Label (frame, text='Screen dpi').pack(side='left', anchor='n', pady=7)
-        self.fieldScreenDPI = tk.Entry (frame, text=self.varScreenDpi, width=5)
-        self.fieldScreenDPI.pack(side='left', anchor='n', pady=8, padx=5)
-        tk.Button(frame, text='Save', command=self.setScreenDpi).pack(side='left', anchor='n', pady=5)
-        self.fieldScreenDPI.bind('<Return>', lambda event: self.setScreenDpi())
-
-
-    def fillUIFrameRight(self, frame):
-        pady = 5
-        # template actions
-        FrameTitleContentHide(frame, self.fillUIFrameRightTemplateColTitle, self.fillUIFrameRightTemplateColorize, default='hide', contentkwargs={'padx':10}).pack(side='top', fill=X, anchor='w', pady=pady)
-        # properties
-        self.previousSelectedCurve = [-1]
-        FrameTitleContentHide(frame, self.fillUIFrameRightTreeTitle, self.fillUIFrameRightTreeContent).pack(side='top', fill=X, anchor='w', pady=pady)
-        # NEW property
-        FrameTitleContentHide(frame, self.fillUIFrameRightNewTitle, self.fillUIFrameRightNew, contentkwargs={'padx':10}).pack(side='top', fill=X, anchor='w', pady=pady)
-        # actions on Curves
-        FrameTitleContentHide(frame, self.fillUIFrameRightActionGenericTitle, self.fillUIFrameRightActionGeneric).pack(side='top', fill=X, anchor='w', pady=pady)
-        # Actions on curves
-        self.fillUIFrameRightActionTitle(frame)
-        self.FrameRActionList = []
-        self.FrameRAction = self.createFrame(frame, self.fillUIFrameRightAction,      {}, {'side':'top', 'fill':X, 'padx':'10', 'anchor':'w', 'pady':pady}, argsFunc=[-1])
-        #list of curves - Listbox choice to user
-        self.ListBoxCurves = tk.Listbox(frame, width=30, height=4) # dont want to delete the object as corresponding code can be useful at some point
-        #self.ListBoxCurves.pack(side='top', anchor='w')
-
-
-    def fillUIFrameRightTreeTitle(self, frame):
-        tk.Label(frame, text='List of properties', font=self.fontBold).pack(side='top', anchor='w')
-    def fillUIFrameRightTreeContent(self, frame):
-        self.createFrame(frame, self.fillUIFrameRightTree, {}, {'side':'top', 'fill':X, 'padx':5})
-        # EDIT property
-        fr = FrameTitleContentHide(frame, self.fillUIFrameRightEditTitle, self.fillUIFrameRightEdit, contentkwargs={'padx':10}, default='hide')
-        #fr.pack(side='top', fill=X, anchor='w')
-
-    def fillUIFrameRightTree(self, frame):
-        # START OF FIX: because of change in tk. Baseically added the following:
-        def fixed_map(option):
-            # Returns the style map for 'option' with any styles starting with
-            # ("!disabled", "!selected", ...) filtered out
-            # style.map() returns an empty list for missing options, so this should
-            # be future-safe
-            return [elm for elm in style.map("Treeview", query_opt=option)
-                    if elm[:2] != ("!disabled", "!selected")]
-        style = ttk.Style()
-        style.map("Treeview", foreground=fixed_map("foreground"), background=fixed_map("background"))
-        # END OF FIX
-        self.Tree = ttk.Treeview(frame, columns=('#1'))
-        self.Tree.pack(side='left', anchor='n')
-        self.Treeysb = ttk.Scrollbar(frame, orient='vertical', command=self.Tree.yview)
-        self.Treeysb.pack(side='right', anchor='n', fill=Y)
-        self.Tree.configure(yscroll=self.Treeysb.set)
-        self.Tree.column ('#0', width=170)
-        self.Tree.heading('#0', text='Name')
-        self.Tree.column ('#1', width=290)
-        self.Tree.heading('#1', text='Value')
-        self.Tree.bind('<<TreeviewSelect>>', self.treeSelectItem)
-
-    def fillUIFrameRightActionGenericTitle(self, frame):
-        tk.Label (frame, text='Actions on Curves', font=self.fontBold).pack(side='left', anchor='n')
-    def fillUIFrameRightActionGeneric(self, frame):
-        self.createFrame(frame, self.fillUIFrameRightAGLeft,  {}, {'side':'left',  'anchor':'n', 'padx':'10'})
-        self.createFrame(frame, self.fillUIFrameRightAGRight, {}, {'side':'right', 'anchor':'n'})
-
-    def fillUIFrameRightAGLeft(self, frame):
-        self.createFrame(frame, self.fillUIFrameRightAGShift,     {}, {'side':'top', 'anchor':'w'})
-        self.createFrame(frame, self.fillUIFrameRightAGDelete,    {}, {'side':'top', 'anchor':'w'})
-        self.createFrame(frame, self.fillUIFrameRightAGDuplicate, {}, {'side':'top', 'anchor':'w'})
-        self.createFrame(frame, self.fillUIFrameRightAGShowHide,  {}, {'side':'top', 'anchor':'w'})
-
-    def fillUIFrameRightAGRight(self, frame):
-        self.createFrame(frame, self.fillUIFrameRightAGClipboard, {}, {'side':'top', 'anchor':'w'})
-        self.createFrame(frame, self.fillUIFrameRightAGCast,      {}, {'side':'top', 'anchor':'w'})
-        self.createFrame(frame, self.fillUIFrameRightAGQuickAttr, {}, {'side':'top', 'anchor':'w'})
-        self.createFrame(frame, self.fillUIFrameRightAGLabelReplace,{},{'side':'top','anchor':'w'})
-
-    def fillUIFrameRightAGDelete(self, frame):
-        tk.Label (frame, text='Delete Curve').pack(side='left')
-        de = tk.Button(frame, text='Curve', command=self.curveDelete)
-        de.pack(side='left', padx=3)
-        tk.Button(frame, text='All hidden', command=self.curveDeleteAllHidden).pack(side='left')
-        CreateToolTip(de, "Ctrl+Delete")
-
-
-    def fillUIFrameRightAGDuplicate(self, frame):
-        tk.Label (frame, text='Duplicate Curve').pack(side='left')
-        tk.Button(frame, text='Duplicate', command=self.curveDuplicate).pack(side='left')
-
-    def fillUIFrameRightAGClipboard(self, frame):
-        tk.Label (frame, text='Copy to clipboard').pack(side='left')
-        tk.Button(frame, text='Curve', command=self.curveDataToClipboard).pack(side='left', padx='5')
-        tk.Button(frame, text='Graph', command=self.graphDataToClipboard).pack(side='left')
-        vals = ['raw', 'with properties', 'screen data', 'screen data, prop.']
-        self.OptMenuToClipboardAttr = OptionMenuVar(frame, vals, default='options', width=6)
-        self.OptMenuToClipboardAttr.pack(side='left')
-#        self.ChkBtnToClipboardAttr = CheckbuttonVar(frame, 'props', False)
-#        self.ChkBtnToClipboardAttr.pack(side='left')
-#        self.ChkBtnToClipboardAlter = CheckbuttonVar(frame, 'screen data', False)
-#        self.ChkBtnToClipboardAlter.pack(side='left')
-
-    def fillUIFrameRightAGShowHide(self, frame):
-        ObsShowHideCurve = ObserverStringVarMethodOrKey(tk.StringVar(), 'Select Curve', 'isHidden', valuesDict={True: 'Show Curve', False: 'Hide Curve'})
-        self.observableCurve.register(ObsShowHideCurve)
-        sh = tk.Button(frame, textvariable=ObsShowHideCurve.var(), command=self.curveShowHideCurve)
-        sh.pack(side='left')
-        tk.Button(frame, text='All',    command=self.curveShowHideAll).pack(side='left', padx='5')
-        tk.Button(frame, text='Invert', command=self.curveShowHideInvert).pack(side='left')
-        CreateToolTip(sh, "Ctrl+H")
-
-
-    def fillUIFrameRightAGShift(self, frame):
-        tk.Label (frame, text='Reorder').pack(side='left')
-        tk.Button(frame, text=u"\u21E7",      command=self.curveShiftTop ).pack(side='left', padx=1)
-        tk.Button(frame, text=u"\u21D1 Up",   command=self.curveShiftUp  ).pack(side='left', padx=1)
-        tk.Button(frame, text=u"\u21D3 Down", command=self.curveShiftDown).pack(side='left', padx=1)
-        tk.Button(frame, text=u"\u21E9",      command=self.curveShiftBott).pack(side='left', padx=1)
-
-    def fillUIFrameRightAGCast(self, frame):
-        tk.Label(frame, text='Change Curve type').pack(side='left')
-        self.castCurveList = []
-        self.varCastCurve = tk.StringVar()
-        self.varCastCurve.set('')
-        self.MenuCastCurve = tk.OptionMenu(frame, self.varCastCurve, '')
-        self.MenuCastCurve.pack(side='left', padx='2')
-        tk.Button(frame, text='Save', command=self.castCurve).pack(side='left')
+        btn = tk.Button(frame, text='Save', command=self.setScreenDPIFromEntry)
+        btn.pack(side='right', anchor='n', pady=5)
+        self._varDPI = EntryVar(frame, value=self.app.DEFAULT_SCREENDPI,
+                                width=5)
+        self._varDPI.pack(side='right', anchor='n', pady=8, padx=5)
+        self._varDPI.bind('<Return>',
+                          lambda event: self.setScreenDPIFromEntry())
+        lbl = tk.Label(frame, text='Screen dpi')
+        lbl.pack(side='right', anchor='n', pady=7)
+
+    def cw_line2(self, frame):
+        self.varXlabel = EntryVar(frame, '', width=20)
+        self.varYlabel = EntryVar(frame, '', width=20)
+        self.varXlim0 = EntryVar(frame, '', width=8)
+        self.varXlim1 = EntryVar(frame, '', width=8)
+        self.varYlim0 = EntryVar(frame, '', width=8)
+        self.varYlim1 = EntryVar(frame, '', width=8)
+        tk.Label(frame, text='xlabel:').pack(side='left', anchor='c')
+        self.varXlabel.pack(side='left', anchor='c')
+        tk.Label(frame, text='   ylabel:').pack(side='left', anchor='c')
+        self.varYlabel.pack(side='left', anchor='c')
+        tk.Label(frame, text='   xlim:').pack(side='left', anchor='c')
+        self.varXlim0.pack(side='left', anchor='c')
+        tk.Label(frame, text='to').pack(side='left', anchor='c')
+        self.varXlim1.pack(side='left', anchor='c')
+        tk.Label(frame, text='   ylim:').pack(side='left', anchor='c')
+        self.varYlim0.pack(side='left', anchor='c')
+        tk.Label(frame, text='to').pack(side='left', anchor='c')
+        self.varYlim1.pack(side='left', anchor='c')
+        tk.Label(frame, text='   ').pack(side='left')
+        btn = tk.Button(frame, text='Save', command=self.updateAttributes)
+        btn.pack(side='left', anchor='c')
+        tk.Label(frame, text='   ').pack(side='left')
+        self.varXlabel.bind('<Return>', lambda event: self.updateAttributes())
+        self.varYlabel.bind('<Return>', lambda event: self.updateAttributes())
+        self.varXlim0.bind('<Return>', lambda event: self.updateAttributes())
+        self.varXlim1.bind('<Return>', lambda event: self.updateAttributes())
+        self.varYlim0.bind('<Return>', lambda event: self.updateAttributes())
+        self.varYlim1.bind('<Return>', lambda event: self.updateAttributes())
+        bt = tk.Button(frame, text='Data editor', command=self.popupDataEditor)
+        bt.pack(side='right', anchor='c')
+
+    def _setLimitsSubplots(self):
+        self.app.storeSelectedCurves()  # before modifs, to prepare updateUI
+        ax = self.app.getAx()
+        xlim = list(ax.get_xlim())
+        ylim = list(ax.get_ylim())
+        a = ['left', 'bottom', 'right', 'top', 'wspace', 'hspace']
+        subplots = [getattr(self.app.getFig().subplotpars, key) for key in a]
+        self.app.callGraphMethod('update', {'xlim': xlim, 'ylim': ylim,
+                                            'subplots_adjust': subplots})
+        self.app.updateUI()
+
+    def updateTypeplot(self, new):
+        self.app.storeSelectedCurves()  # before modifs, to prepare updateUI
+        self.varTypeplot.set(new)
+        self.app.callGraphMethod('update', {'typeplot': new})
+        self.app.updateUI()
+
+    def setScreenDPIFromEntry(self):
+        """ Updates the DPI according to the value stored in the GUI Entry """
+        self.app.storeSelectedCurves()  # before modifs, to prepare updateUI
+        try:
+            self.app.getTabProperties(dpi=float(self._varDPI.get()))
+            self.checkValidScreenDPI()
+        except Exception:  # float() conversion may have failed
+            pass
+        if self.app.initiated:
+            self.app.updateUI()
 
-    def chooseColor(self):
-        from tkinter.colorchooser import askcolor
-        curve = self.getActiveCurve(multiple=False)
-        if curve != -1:
-            from matplotlib.colors import hex2color, rgb2hex
-            try:
-                colorcurrent = rgb2hex(stringToVariable(self.VarRAGQAColor.get()))
-            except Exception:
-                colorcurrent = None
-            ans = askcolor(color=colorcurrent)
-            if ans[0] is not None:
-                self.ObsRAGQAColor.set(self.listToString([np.round(a,3) for a in hex2color(ans[1])])) # [np.round(val/256,3) for val in ans[0]]
-    def fillUIFrameRightAGQuickAttr(self, frame):
-        VarRAGQALabel = tk.StringVar()
-        self.VarRAGQAColor = tk.StringVar()
-        self.ObsRAGQALabel = ObserverStringVarMethodOrKey(VarRAGQALabel, '', 'label')
-        self.ObsRAGQAColor = ObserverStringVarMethodOrKey(self.VarRAGQAColor, '', 'color')
-        self.observableCurve.register(self.ObsRAGQALabel)
-        self.observableCurve.register(self.ObsRAGQAColor)
-        tk.Label(frame, text='Label').pack(side='left')
-        a = tk.Entry(frame, text=VarRAGQALabel, width=15)
-        a.pack(side='left')
-        tk.Label(frame, text='Color').pack(side='left')
-        tk.Button(frame, text='Pick', command=self.chooseColor).pack(side='left')
-        b = tk.Entry(frame, text=self.VarRAGQAColor, width=8)
-        b.pack(side='left')
-        tk.Button(frame, text='Save', command=self.AGQuickAttrSet).pack(side='left')
-        a.bind('<Return>', lambda event: self.AGQuickAttrSet())
-        b.bind('<Return>', lambda event: self.AGQuickAttrSet())
-    def AGQuickAttrSet(self):
-        curves = self.getActiveCurve()
-        if len(curves) > 0:
-            self.updateProperty(curves, 'label', self.ObsRAGQALabel.get(), ifUpdate=False, varType=str)
-            self.updateProperty(curves, 'color', self.ObsRAGQAColor.get(), ifUpdate=False)
-            self.updateUI()
-    def fillUIFrameRightAGLabelReplace(self, frame):
-        self.varReplaceLabelsOld = tk.StringVar()
-        self.varReplaceLabelsOld.set('old string')
-        self.varReplaceLabelsNew = tk.StringVar()
-        self.varReplaceLabelsNew.set('new string')
-        tk.Label (frame, text='Replace in labels').pack(side='left')
-        a = tk.Entry (frame, textvariable=self.varReplaceLabelsOld, width=10)
-        a.pack(side='left')
-        b = tk.Entry (frame, textvariable=self.varReplaceLabelsNew, width=10)
-        b.pack(side='left')
-        tk.Button(frame, text='Replace',  command=self.graphReplaceLabels).pack(side='left')
-        a.bind('<Return>', lambda event: self.graphReplaceLabels())
-        b.bind('<Return>', lambda event: self.graphReplaceLabels())
-
-    def fillUIFrameRightTemplateColTitle(self, frame):
-        tk.Label(frame, text='Template & Colorize', font=self.fontBold).pack(side='left')
-
-    def fillUIFrameRightTemplateColorize(self, frame):
-        self.createFrame(frame, self.fillUIFrameRightTemplate,         {}, {'side': 'top', 'anchor':'w', 'fill': X})
-        self.createFrame(frame, self.fillUIFrameRightAGColorizeTop,    {}, {'side': 'top', 'anchor':'w'})
-        self.createFrame(frame, self.fillUIFrameRightAGColorizeMiddle, {}, {'side': 'top', 'anchor':'w'})
-        self.createFrame(frame, self.fillUIFrameRightAGColorizeBottom, {}, {'side': 'top', 'anchor':'w'})
-    def fillUIFrameRightAGColorizeTop(self, frame):
-        self.varRColEmpty = tk.IntVar()
-        self.varRColEmpty.set(0)
-        self.varRColInvert = tk.IntVar()
-        self.varRColInvert.set(0)
-        self.varRColAvoidWhite = tk.IntVar()
-        self.varRColAvoidWhite.set(1)
-        self.varRColCurvesList = tk.IntVar()
-        self.varRColCurvesList.set(0)
-        tk.Button     (frame, text='Colorize',    command=self.colorizeGraph).pack(side='left')
-        tk.Checkbutton(frame, text='repeat if no label  ', variable=self.varRColEmpty).pack(side='left')
-        tk.Checkbutton(frame, text='invert',      variable=self.varRColInvert).pack(side='left')
-        tk.Checkbutton(frame, text='avoid white', variable=self.varRColAvoidWhite).pack(side='left')
-        tk.Checkbutton(frame, text='curve selection', variable=self.varRColCurvesList).pack(side='left')
-    def fillUIFrameRightAGColorizeMiddle(self, frame):
-        self.varRColChoice = tk.StringVar()
-        self.varRColChoice.set('')
-        tk.Entry(frame, text=self.varRColChoice, width=50).pack(side='left')
-    def fillUIFrameRightAGColorizeBottom(self, frame):
-        nbPerLine = 12
-        self.colList = Colorscale.GUIdefaults(**self.newGraphKwargs)
-        RColColorscale = [None] * len(self.colList)
-        self.RColPhoto = [None] * len(self.colList) # self. as we need to keep a reference to the images after the method ends its execution
-        width, height = 30, 15
-        for i in range(len(self.colList)):
-            self.RColPhoto[i] = PhotoImageColorscale(width=width, height=height)
-            try:
-                self.RColPhoto[i].fillColorscale(self.colList[i])
-            except ValueError as e:
-                # somehow this version of python does not recognize the desired keyword (e.g. inferno, viridis, etc.)
-                self.RColPhoto[i] = None # back to uninitialized state
-            if self.RColPhoto[i] is not None:
-                RColColorscale[i] = tk.Button(frame, image=self.RColPhoto[i], command=lambda i_=i:self.colorizeGraphSetScale(i_))
-                RColColorscale[i].grid(column=int(i%nbPerLine), row=int(np.floor(i/nbPerLine)))
-
-    def fillUIFrameRightTemplate(self, frame):
-        self.varRTplCurves = tk.IntVar()
-        self.varRTplCurves.set(1)
-        tk.Button(frame, text='Load & apply template',    command=self.file_loadTemplate).pack(side='left',  anchor='n', pady='5')
-        tk.Checkbutton(frame, text='also Curves properties', variable=self.varRTplCurves).pack(side='left')
-        tk.Button(frame, text='Save template',            command=self.saveTemplate     ).pack(side='right', anchor='n', pady='5')
 
-    def fillUIFrameSave(self, frame):
-        s_ = tk.Button(frame, text='Save', command=self.saveData)
-        s_.pack(side='left', anchor='n')
-        sa = tk.Button(frame, text='Save as...', command=self.saveDataAs)
-        sa.pack(side='left', anchor='n', padx='7')
-        sc = tk.Button(frame, text='Copy image', command=self.imageToClipboard)
-        sc.pack(side='left', anchor='n')
-        CreateToolTip(s_, "Ctrl+S")
-        CreateToolTip(sa, "Ctrl+Shift+S")
+    def checkValidScreenDPI(self):
+        """ Checks that the DPI value stored in tab is reasonable """
+        new = strToVar(self.app.getTabProperties()['dpi'])
+        # print('checkValidScreenDPI', new)
+        if new == '':
+            new = self.app.DEFAULT_SCREENDPI
+        if not is_number(new):
+            return False
+        fig = self.app.getFig()
+        figSize = np.array(fig.get_size_inches())
+        minMaxPx = np.array([[10, 10], [1000, 1000]])
+        newMinMax = np.array([max(minMaxPx[0] / figSize),
+                              min(2*minMaxPx[1] / figSize)])
+        new = min(max(new, newMinMax[0]), newMinMax[1])
+        new = roundSignificant(new, 2)
+        # print('Set screen DPI to '+str(new)+'.')
+        # print('   ', new)
+        self.app.getTabProperties(dpi=new)
 
+    def setAutoScreenDPI(self):
+        """ Provides a best guess for screen DPI """
+        wh = [self.app.getCanvas().get_tk_widget().winfo_width(),
+              self.app.getCanvas().get_tk_widget().winfo_height()]
+        figsize = self.app.graph().attr('figsize', Graph.FIGSIZE_DEFAULT)
+        dpimax = min([wh[i] / figsize[i] for i in range(2)])
+        dpi = self.app.getTabProperties()['dpi']
+        new = None
+        # print('setAutoScreenDPI', dpi, dpimax, figsize, 'wh', wh)
+        if dpi > dpimax * 1.02:  # shall reduce screen dpi
+            new = np.max([10, np.round(2*(dpimax-3), -1)/2])
+        elif dpi < dpimax * 0.8 and dpi < 100:  # maybe can zoom in
+            new = np.min([100, np.round(2*(dpimax-3), -1)/2])
+        # print('   ', new)
+        if new is not None and new != dpi:
+            self.app.getTabProperties(dpi=new)
+            self.app.blinkWidget(self._varDPI, 5)
+            self._varDPI.set(new)  # a bit useless, done at next updateUI...
 
-    def fillUIFrameRightEditTitle(self, frame):
-        tk.Label(frame, text='Edit property', font=self.fontBold).pack(side='top', anchor='w')
-    def fillUIFrameRightEdit(self, frame):
-        self.createFrame(frame, self.fillUIFrameRightEditH,  {}, {'side':'top', 'anchor':'w', 'fill': X})
-        self.EditPropExample = tk.StringVar()
-        self.EditPropExample.set('')
-        tk.Label(frame, text='\n').pack(side='left', anchor='n', padx=0)
-        tk.Label(frame, textvariable=self.EditPropExample, justify='left').pack(side='left', anchor='n')
-    def fillUIFrameRightEditH(self, frame):
-        self.varEditPropProp = tk.StringVar()
-        self.varEditPropProp.set('Property')
-        self.varEditPropVal = tk.StringVar()
-        self.varEditPropVal.set('')
-        tk.Label(frame, textvariable=self.varEditPropProp).pack(side='left')
-        entry = tk.Entry(frame, text=self.varEditPropVal, width=35)
-        entry.pack(side='left')
-        tk.Button(frame, text='Save', command=self.editProperty).pack(side='right')
-        entry.bind('<Return>', lambda event: self.editProperty())
-
-    def fillUIFrameRightNewTitle(self, frame):
-        tk.Label(frame, text='Property editor', font=self.fontBold).pack(side='top', anchor='w')
-    def fillUIFrameRightNew(self, frame):
-        self.createFrame(frame, self.fillUIFrameRightNewH,  {}, {'side':'top', 'anchor':'w', 'fill': X})
-        self.NewPropExample = tk.StringVar()
-        self.NewPropExample.set('')
-        tk.Label(frame, text='\n').pack(side='left', anchor='n', padx=0)
-        tk.Label(frame, textvariable=self.NewPropExample, justify='left').pack(side='left', anchor='n')
-    def fillUIFrameRightNewH(self, frame):
-        self.varNewPropProp = tk.StringVar()
-        self.varNewPropProp.set('')
-        self.varNewPropProp.trace('w', self.newPropertySelect)
-        self.varNewPropVal = tk.StringVar()
-        self.varNewPropVal.set('')
-        self.varNewPropValPrevious = self.varNewPropVal.get()
-        tk.Label(frame, text='Property:').pack(side='left')
-        self.OptionmenuNewProp = tk.OptionMenu(frame, self.varNewPropProp, '')
-        self.OptionmenuNewProp.pack(side='left')
-        # self.EntryNewProp = tk.Entry (frame, text=self.varNewPropVal, width=30)
-        self.EntryNewProp = ttk.Combobox(frame, textvariable=self.varNewPropVal,
-                                         values=[], width=30)
-        self.EntryNewProp.pack(side='left')
-        self.EntryNewProp.bind('<Return>', lambda event: self.newPropertySet())
-        tk.Button(frame, text='Save', command=self.newPropertySet).pack(side='right')
-
-    def fillUIFrameRightActionTitle(self, frame):
-        self.createFrame(frame, self.fillUIFrameRightActionTitle2,  {}, {'side':'top', 'anchor':'w', 'fill': X})
-
-    def fillUIFrameRightActionTitle2(self, frame):
-        tk.Label(frame, text='Actions specific to selected Curve', font=self.fontBold).pack(side='left', anchor='center')
-        hline = FrameTitleContentHide.frameHline(frame)
-        hline.pack(side='left', anchor='center', fill=X, expand=1, padx=5)
-
-    def fillUIFrameRightAction(self, frame, curve):
-        for action in self.FrameRActionList:
-            for field in action:
-                if isinstance(field, list):
-                    for var in field:
-                        del var
-                else:
-                    field.destroy()
-        self.FrameRActionList = []
-        if curve != -1:
-            # print('funcListGUI', self.back_graph.curve(curve).funcListGUI())
-            tmp = []
-            funcList = self.back_graph.curve(curve).funcListGUI(graph=self.back_graph, graph_i=curve)
-            for j in range(len(funcList)):
-                act = funcList[j]
-                # clean input
-                if len(act) == 3:
-                    act.append([''] * len(act[2]))
-                try:
-                    len(act[3])
-                except TypeError:  # as e:
-                    act[3] = [''] * len(act[2])
-                for i in range(len(act[3])):  # default values
-                    if isinstance(act[3][i], (list, np.ndarray)):
-                        act[3][i] = self.listToString(act[3][i])
-                    # act[3][i] = '"'+str(act[3][i])+'"'
-                tmp.append([])
-                tmp[-1].append([])  # index 0 is list
-                tmp[-1][0].append(act[0])  # Validation button
-                for i in range(len(act[2])):  # for field in act[2]:
-                    tmp[-1][0].append(tk.StringVar())
-                    tmp[-1][0][-1].set(act[3][i])
-                if len(act) >= 5:         # hidden variables
-                    tmp[-1][0].append(act[4])
-                tmp[-1].append(tk.Frame(frame))
-                tmp[-1][-1].pack(side='top', anchor='w', fill=X)
-                if funcList[j][0] is None:
-                    tmp[-1].append(tk.Label(tmp[-1][1], text=act[1]))
-                else:
-                    tmp[-1].append(tk.Button(tmp[-1][1], text=act[1], command=lambda j_=j:self.curveAction(j_)))  #self.curveAjction(curve, funcList[j][0], tmp[j][0], j))
-                tmp[-1][-1].pack(side='left', anchor='w')
-                for i in range(len(act[2])):  # list of Entries
-                    fieldprop = copy.deepcopy(act[5][i]) if len(act) > 5 else {}
-                    fieldtype = tk.Entry
-                    if 'field' in fieldprop:
-                        if fieldprop['field'] == 'Combobox':
-                            fieldtype = ttk.Combobox
-                            if 'width' not in fieldprop:
-                                fieldprop.update({'width': int(1.1*max([len(t) for t in fieldprop['values']]))})
-                        else:
-                            fieldtype = getattr(tk, fieldprop['field'])
-                        del fieldprop['field']
-                    bind = None
-                    if 'bind' in fieldprop:
-                        bind = fieldprop['bind']
-                        del fieldprop['bind']
-                    tmp[-1].append(tk.Label(tmp[-1][1], text=act[2][i]))
-                    tmp[-1][-1].pack(side='left', anchor='w')
-                    if fieldtype == tk.Entry and 'width' not in fieldprop:
-                        width = int(max(8, (40 - len(act[2][i])/3 - len(act[1])/2)/len(act[2])))
-                        if len(tmp[-1][0][i+1].get()) < 2:
-                            width = int(0.3 * width + 0.7)
-                        fieldprop.update({'width': width})
-                    if fieldtype == tk.Checkbutton:
-                        fieldprop.update({'variable': tmp[-1][0][i+1]})
-                    else:
-                        fieldprop.update({'textvariable': tmp[-1][0][i+1]})
-                    field = fieldtype(tmp[-1][1], **fieldprop)
-                    if bind is not None:
-                        if bind == 'beforespace':
-                            bind = lambda event: event.widget.set(event.widget.get().split(' ')[0])
-                        field.bind('<<ComboboxSelected>>', bind)
-                    tmp[-1].append(field) #textvariable=tmp[-1][0][i+1]
-                    tmp[-1][-1].pack(side='left', anchor='w')
-                    tmp[-1][-1].bind('<Return>', lambda event, j_=j: self.curveAction(j_))
-            self.FrameRActionList = tmp
-        if self.FrameRActionList == []:
-            self.FrameRActionList.append([tk.Label(frame, text='No possible action.')])
-            self.FrameRActionList[0][-1].pack(side='top', anchor='w')
+    def updateDataTransform(self, new):
+        [idx, display, alter, typePlot] = self.identifyDataTransform()
+        if display == new:
+            return True  # no change
+        for a in self.alterListGUI:
+            if new == a[0]:
+                self.app.storeSelectedCurves()  # before modifs, to prepare updateUI
+                self.varAlter.set(new)
+                self.varTypeplot.set(a[2])
+                self.app.callGraphMethod('update', {'alter': a[1],
+                                                    'typeplot': a[2]})
+                self.app.updateUI()
+        return False
 
-    def plotChangeView_identify(self):
+    def identifyDataTransform(self):
         # retrieve current alter
-        alter = self.back_graph.getAttribute('alter')
+        graph = self.app.graph()
+        alter = graph.attr('alter')
         if alter == '':
             alter = self.alterListGUI[0][1]
+        typePlot = graph.attr('typeplot')
         # find index in list of allowed alterations
         for i in range(len(self.alterListGUI)):
             if alter == self.alterListGUI[i][1]:
-                return [i] + self.alterListGUI[i]
-        typePlot = self.back_graph.getAttribute('typeplot')
+                return [i] + self.alterListGUI[i][0:2] + [typePlot]
         return [np.nan, 'File-defined', alter, typePlot]
 
-    def plotChangeView2(self, new):
-        [idx, display, alter, typePlot] = self.plotChangeView_identify()
-        if display == new:
-            return  # no change
-        for a in self.alterListGUI:
-            if new == a[0]:
-                self.OMAlter.set(new)
-                self.OMTypePlot.set(a[2])
-                self.back_graph.update({'alter': a[1], 'typeplot': a[2]})
-                new = None
-                break
-        if new is None:
-            self.updateUI()
+    def updateAttributes(self):
+        """ update the quick modifs, located below the graph """
+        self.app.storeSelectedCurves()  # before modifs, to prepare updateUI
+        xlim = [strToVar(self.varXlim0.get()), strToVar(self.varXlim1.get())]
+        ylim = [strToVar(self.varYlim0.get()), strToVar(self.varYlim1.get())]
+        xlabel = strToVar(self.varXlabel.get())
+        ylabel = strToVar(self.varYlabel.get())
+        self.app.callGraphMethod('update', {'xlabel': xlabel, 'ylabel': ylabel,
+                                            'xlim': xlim, 'ylim': ylim})
+        self.app.updateUI()
 
-    def plotTypePlot(self, new):
-        self.OMTypePlot.set(new)
-        self.back_graph.update({'typeplot': new})
-        self.updateUI()
+    def popupAnnotations(self):
+        """ Open window for annotation manager """
+        from gui.GUIpopup import GuiManagerAnnotations
+        win = tk.Toplevel(self.app.master)
+        GuiManagerAnnotations(win, self.app.graph(), self.catchAnnotations)
 
+    def catchAnnotations(self, dictupdate):
+        self.app.storeSelectedCurves()  # before modifs, to prepare updateUI
+        self.app.graph().update(dictupdate)
+        self.app.updateUI()
 
+    def popupDataEditor(self):
+        """ Open window for data edition """
+        # opens manager
+        from gui.GUIdataEditor import GuiDataEditor
+        win = tk.Toplevel(self.app.master)
+        GuiDataEditor(win, self.app.graph(), self.catchDataEditor)
 
-    def setScreenDpi(self):
-        new = stringToVariable(self.varScreenDpi.get())
-        if new == '':
-            new = self.defaultScreenDpi
-        if not is_number(new):
-            return False
-        figSize = np.array(self.Graph_fig.get_size_inches())
-        minMaxPx = np.array([[10, 10], [1000, 1000]])
-        newMinMax = np.array([max(minMaxPx[0] / figSize), min(2 * minMaxPx[1] / figSize)])
-        new = min(max(new, newMinMax[0]), newMinMax[1])
-        new = roundSignificant(new, 2)
-        self.varScreenDpi.set(new)
-        print('Set screen DPI to '+str(new)+'.')
-        self.Graph_fig.set_dpi(new)
-        if self.initiated:
-            self.updateUI()
+    def catchDataEditor(self):
+        # modification of the Curve are performed within popup. Little to do
+        self.app.updateUI()
 
 
-    def curveAction(self, j):
-        curve = self.getActiveCurve(multiple=False)
-        args = self.FrameRActionList[j][0]
-        # retrieve function to call
-        func = args[0]
-        # hidden arguments
-        hidden = {}
-        if isinstance(args[-1], dict):
-            hidden = args[-1]
-            del args[-1]
-        # user-adjustable parameters
-        args = args[1:]
-        args = [stringToVariable(a.get()) for a in args]
-        # check if func is method of Graph object and not of the Curve
-        if not hasattr(func, '__self__'):
-            args = [self.back_graph] + args
+class GUIFrameDataPicker:
+    """
+    Handles the data picker
+    Contains a Frame, to be embedded in a wider application (.frame.pack())
+    Some methods will call methods of application
+    """
+
+    def __init__(self, master, application, **kwargs):
+        self.frame = tk.Frame(master, **kwargs)
+        self.app = application
+        self.varIdx = np.nan  # datapoint index on curve
+        self.varCurvePreviousLabels = []
+        self.createWidgets(self.frame)
+        self.app.master.bind('<Control-m>', lambda e: self.savePoint())
 
-        def executeFunc(curve, func, args, kwargs):
-            # execute curve action
-            res = func(*args, **hidden)
-            if self.varPrintCommands.get():
-                try:
-                    subject = func.__module__
-                    if 'graph' in subject:
-                        subject = 'graph'
-                    elif 'curve' in subject:
-                        subject = 'graph.curve('+str(curve)+')'
-                    else:
-                        print('WARNING curveAction print commands: subject not determined (', subject, func.__name__, j, ')')
-                    p = [("'" + a + "'" if isinstance(a, str) else str(a)) for a in args]
-                    p +=[(a + "='" + hidden[a] + "'" if isinstance(hidden[a], str) else a + "=" + str(hidden[a])) for a in hidden]
-                    print('res = ' + subject + '.' + func.__name__ + '(' + ', '.join(p) + ')')
-                except Exception:
-                    pass  # error while doing useless output does not really matter
-            # where to place new Curves
-            idx = curve + 1
-            while idx < self.back_graph.length():
-                type_ = self.back_graph.curve(idx).getAttribute('type')
-                if not type_.startswith('scatter') and not type_.startswith('errorbar'):
+    def updateUI(self):
+        # drop-down curve list
+        graph = self.app.graph()
+        orderLbl = ['label', 'sample', 'filename']
+        values, labels = [], []
+        for i in range(len(graph)):
+            values.append(i)
+            lbl = str(i)+' (no label)'
+            for test in orderLbl:
+                tmp = graph[i].attr(test)
+                if tmp != '':
+                    lbl = str(i)+' '+str(tmp).replace("'", '\'')
                     break
-                idx += 1
-            if isinstance(res, Curve):
-                self.back_graph.append(res, idx=idx)
-                if self.varPrintCommands.get():
-                    print("graph.append(res" + ('' if idx == self.back_graph.length() else ', idx=' + str(idx)) + ")")
-            elif isinstance(res, list) and np.array([isinstance(c, Curve) for c in res]).all():
-                self.back_graph.append(res, idx=idx)
-                if self.varPrintCommands.get():
-                    print("graph.append(res" + ('' if idx == self.back_graph.length() else ', idx=' + str(idx)) + ")")
-            elif res:
-                if res == True:
-                    pass
-                else:
-                    # print ('Curve action output:')
-                    print(res)
-            else:
-                print('Curve action output:')
-                print(res)
+            labels.append(lbl)
+        if labels != self.varCurvePreviousLabels:
+            self.varCurvePreviousLabels = labels
+            default = self.varCurve.get()
+            self.varCurve.resetValues(values, labels=labels, default=default)
+        # crosshair
+        self.updateCrosshair(draw=False)
 
-        # handling actions on multiple Curves
-        toExecute = {curve: func}
-        curves = self.getActiveCurve(multiple=True)
-        if len(curves) > 1:
-            funcListRef = self.back_graph.curve(curve).funcListGUI(graph=self.back_graph, graph_i=curve)
-            for c in curves:
-                if c != curve:
-                    funcListOth = self.back_graph.curve(c).funcListGUI(graph=self.back_graph, graph_i=c)
-                    if len(funcListOth) > j:
-                        if (funcListOth[j][0].__name__ == funcListRef[j][0].__name__ and
-                            funcListOth[j][1] == funcListRef[j][1] and
-                            funcListOth[j][2] == funcListRef[j][2]):
-                            toExecute.update({c: funcListOth[j][0]})
-        keys = list(toExecute.keys())
-        keys.sort(reverse=True)
-        for c in keys:
-            if len(keys) > 1:
-                lbl = self.back_graph.curve(c).getAttribute('label', '')
-                print('Action on Curve', c, (('(' + lbl + ')') if len(lbl) > 0 else ''))
-            executeFunc(c, toExecute[c], args, hidden)
-        # after execution
-        self.updateUI()
-
-    def castCurve(self):
-        curves = self.getActiveCurve()
-        newType = self.varCastCurve.get()
-        for curve in curves:
-            if curve > -1 and curve < self.back_graph.length():
-                test = self.executeGraphMethod('castCurve', newType, curve)
-                # test = self.back_graph.castCurve(newType, curve)
-                if test != True:
-                    print('castCurve impossible.')
-            else:
-                print('castCurve impossible (', newType, curve, ')')
-        self.updateUI()
-
-    def curveShift(self, upDown, relative=True):
-        curves_ = self.getActiveCurve()
-        curves = list(curves_)
-        curves.sort(reverse=(True if (upDown > 0) else False))
-        selected = []
-        for curve in curves:
-            idx2 = upDown
-            if curve == 0:
-                idx2 = max(idx2, 0)
-            if curve == self.back_graph.length()-1 and relative:
-                idx2 = min(idx2, 0)
-            if relative:
-                self.executeGraphMethod('swapCurves', curve, idx2, relative=True)
-                selected.append(curve+idx2)
-            else:
-                self.executeGraphMethod('moveCurveToIndex', curve, idx2)
-                selected.append(idx2)
-                # print('moveCurve', curve, idx2, upDown)
-                if idx2 < curve or (idx2 == curve and curve == 0):
-                    upDown += 1
-                elif idx2 > curve or (idx2 == curve and curve >= self.back_graph.length()-1):
-                    upDown -= 1
-            # self.back_graph.swapCurves(curve, upDown, relative=True)
-        for i in range(len(selected)):
-            selected[i] = max(0, min(self.back_graph.length()-1, selected[i]))
-        self.previousSelectedCurve = selected
-        self.updateUI()
-
-    def curveShiftDown(self):
-        self.curveShift(1)
-
-    def curveShiftUp(self):
-        self.curveShift(-1)
-
-    def curveShiftTop(self):
-        self.curveShift(0, relative=False)
-
-    def curveShiftBott(self):
-        self.curveShift(self.back_graph.length()-1, relative=False)
+    def createWidgets(self, frame):
+        fr = FrameTitleContentHideHorizontal(frame, self.cw_title,
+                        self.cw_datapicker, default='hide', showHideTitle=True)
+        fr.pack(side='top', fill=tk.X, anchor='w')
 
-    def curveShowHideCurve(self):
-        curves = self.getActiveCurve()
-        for curve in curves:
-            if curve > -1 and curve < self.back_graph.length():
-                self.executeGraphCurveMethod(curve, 'swapShowHide')
-                #self.back_graph.curve(curve).swapShowHide()
-        self.updateUI()
-    def curveShowHideAll(self):
-        if self.back_graph.length() > 0:
-            new = '' if self.back_graph.curve(0).isHidden() else 'none'
-            for curve in self.back_graph.iterCurves():
-                curve.update({'linestyle': new})
-            if self.varPrintCommands.get():
-                print("for curve in graph.iterCurves():")
-                print("    curve.update({'linestyle': '"+new+"'})")
-            self.updateUI()
-    def curveShowHideInvert(self):
-        for curve in self.back_graph.iterCurves():
-            curve.swapShowHide()
-        if self.varPrintCommands.get():
-            print("for curve in graph.iterCurves():")
-            print("    curve.swapShowHide()")
-        self.updateUI()
+    def cw_title(self, frame):
+        tk.Label(frame, text='Data picker').pack(side='top')
 
-    def colorizeGraph(self):
-        col = stringToVariable(self.varRColChoice.get())
-        if len(col) == 0:
-            col = self.colList[0].getColorScale()
-            self.colorizeGraphSetScale(0)
-        invert = self.varRColInvert.get()
-        kwargs = {'avoidWhite': self.varRColAvoidWhite.get(),
-                  'sameIfEmptyLabel':  self.varRColEmpty.get()}
-        if self.varRColCurvesList.get():
-            curves = self.getActiveCurve()
-            if len(curves) > 0 and curves[0] >= 0:
-                # if no curve is selected, colorize all curves
-                kwargs.update({'curvesselection': curves})
+    def cw_datapicker(self, frame):
+        fr0 = tk.Frame(frame)
+        fr0.pack(side='top', anchor='w', fill=tk.X)
+        self.cw_datapickerUp(fr0)
+        fr1 = tk.Frame(frame)
+        fr1.pack(side='top', anchor='w', fill=tk.X)
+        self.cw_datapickerDown(fr1)
+
+    def cw_datapickerUp(self, frame):
+        tk.Label(frame, text='Click on graph').pack(side='left', anchor='c')
+        tk.Label(frame, text='x').pack(side='left', anchor='c')
+        self.varX = EntryVar(frame, 0, width=10, varType=tk.DoubleVar)
+        self.varX.pack(side='left', anchor='c')
+        tk.Label(frame, text='y').pack(side='left', anchor='c')
+        self.varY = EntryVar(frame, 0, width=10, varType=tk.DoubleVar)
+        self.varY.pack(side='left', anchor='c')
+        self.varRestrict = CheckbuttonVar(frame, 'Restrict to data', False)
+        self.varRestrict.pack(side='left', anchor='c')
+        tk.Label(frame, text='curve').pack(side='left', anchor='c')
+        self.varCurve = OptionMenuVar(frame, [0], 0, varType=tk.IntVar)
+        self.varCurve.pack(side='left', anchor='c')
         try:
-            self.back_graph.colorize(Colorscale(col, invert=invert), **kwargs)
-        except ValueError as e:
-            # error to be printed in GUI console, and not hidden in terminal
-            print('ValueError:', e)
-        if self.varPrintCommands.get():
-            print('graph.colorize(Colorscale(' + str(col) + ', invert='
-                  + str(invert) + '), '
-                  + ', '.join(['{}={!r}'.format(k, v) for k, v in kwargs.items()])
-                  + ')')
-        self.updateUI()
+            self.varCurve.var.trace_add("write", self.selectCurve)
+        except AttributeError:  # IntVar has no attribute 'trace_add'
+            self.varCurve.var.trace("w", self.selectCurve)
+        self.varCrosshair = CheckbuttonVar(frame, 'Crosshair', False,
+                                           command=self.updateCrosshair)
+        self.varCrosshair.pack(side='left', anchor='c')
+
+    def cw_datapickerDown(self, frame):
+        btn0 = tk.Button(frame, text='Create text with coordinates',
+                         command=self.createTextbox)
+        btn0.pack(side='left', anchor='c')
+        tk.Label(frame, text=' or ').pack(side='left')
+        btn1 = tk.Button(frame, text='Save point', command=self.savePoint)
+        btn1.pack(side='left', anchor='c')
+        CreateToolTip(btn1, 'Ctrl+M')
+        self.varIfTransform = CheckbuttonVar(frame, 'screen data', True)
+        self.varIfTransform.pack(side='left', anchor='c')
+        self.varIfCurveSpec = CheckbuttonVar(frame, 'Curve specific', False)
+        self.varIfCurveSpec.pack(side='left', anchor='c')
+        # explanatory text for checkbox
+        self.varExplain = LabelVar(frame, '')
+        self.varExplain.pack(side='left', anchor='c')
 
-    def colorizeGraphSetScale(self, i):
-        # reads variable (Colorscale object), extract colors (np.array), converts into string
-        if isinstance(self.colList[i].getColorScale(), str):
-            scale = self.colList[i].getColorScale()
-        else:
-            scale = '[' + ', '.join([('['+ ','.join(str(nb if not nb.is_integer() else int(nb)) for nb in elem)+']') if not isinstance(elem,str) else ("'"+elem+"'") for elem in self.colList[i].getColorScale()]) + ']'
-        self.varRColChoice.set(scale)
+    def selectCurve(self, *args):
+        """ Called when user selects another Curve in data picker """
+        c = self.varCurve.get()
+        lbl = self.app.graph()[c].getDataCustomPickerXY(0, strDescription=True)
+        self.varExplain.set(lbl)
 
-    def dataPickerGetPoint(self):
+    def getXY(self):
+        """ retrieve (and transform) data in x and y Entry. """
         # default is data in datapicker textbox
-        x = self.varDataPickerX.get()
-        y = self.varDataPickerY.get()
+        x = self.varX.get()
+        y = self.varY.get()
         attrUpd = {}
-        if self.varDataPickerRestrict.get(): # if datapicker was restricted to existing data point
-            curve = self.varDataPickerCurve.get()
-            if curve >= 0:
-                idx = self.varDataPickerIdx
-                alter = self.back_graph.getAttribute('alter')
+        if self.varRestrict.get():
+            # if datapicker was restricted to existing data point
+            graph = self.app.graph()
+            c = self.varCurve.get()
+            print('getXY c', type(c), c)
+            if c >= 0:
+                idx = self.varIdx
+                alter = graph.attr('alter')
                 # if user want data transform instead if raw data
-                if self.varDataPickerSaveTransform.get():
+                if self.varIfTransform.get():
                     # raw data is displayed in checkbox, need transform
                     if isinstance(alter, str):
                         alter = ['', alter]
-                    x = self.back_graph.curve(curve).x_offsets(index=idx, alter=alter[0])[0]
-                    y = self.back_graph.curve(curve).y_offsets(index=idx, alter=alter[1])[0]
+                    x = graph[c].x_offsets(index=idx, alter=alter[0])[0]
+                    y = graph[c].y_offsets(index=idx, alter=alter[1])[0]
                 # if user want curve-specific data picker
-                if self.varDataPickerSaveCurveSpec.get():
+                if self.varIfCurveSpec.get():
                     # default will be transformed & offset modified data
-                    # maybe the Curve object overrides the default method?
+                    # maybe the Curve object overrides the default method ?
                     # case for CurveCf at least
-                    x, y, attrUpd = self.back_graph.curve(curve).getDataCustomPickerXY(idx, alter=alter)
+                    x, y, attrUpd = graph[c].getDataCustomPickerXY(idx,
+                                                                   alter=alter)
         return x, y, attrUpd
 
-    def dataPickerSavePoint(self):
+    def createTextbox(self):
+        """ Create a new text annotation on Graph """
+        self.app.storeSelectedCurves()  # before modifs, to prepare updateUI
+        x, y, attrUpd = self.getXY()
+        text = ('x: ' + str(roundSignificant(x, 5))
+                + '\ny: ' + str(roundSignificant(y, 5)))
+        textxy = ''
+        textargs = {'textcoords': 'data', 'xytext': [x, y], 'fontsize': 8}
+        self.app.callGraphMethod('addText', text, textxy, textargs=textargs)
+        if not self.app.ifPrintCommands():
+            print('New text annotation:', text.replace('\n', '\\n'))
+        self.app.updateUI()
+
+    def savePoint(self):
+        self.app.storeSelectedCurves()  # before modifs, to prepare updateUI
         attr = {'linespec': 'x', 'color': 'k', '_dataPicker': True}
-        x, y, attrUpd = self.dataPickerGetPoint()
+        x, y, attrUpd = self.getXY()
         attr.update(attrUpd)
         # implement in curve results
-        c = self.back_graph.curves('_dataPicker', True)
+        graph = self.app.graph()
+        c = graph.curves('_dataPicker', True)
         if len(c) == 0:
             # must create datapicker Curve
             curve = Curve(np.array([[x], [y]]), attr)
-            if curve.getAttribute('Curve', None) is not None:
-                casted = curve.castCurve(curve.getAttribute('Curve'))
+            if curve.attr('Curve', None) is not None:
+                casted = curve.castCurve(curve.attr('Curve'))
                 if casted is not False:
                     curve = casted
-            self.back_graph.append(curve)
+            graph.append(curve)
         else:
             # datapicker Curve exists already
             c[0].appendPoints([x], [y])
-        self.updateUI()
+        self.app.updateUI()
 
-    def dataPickerToTextbox(self):
-        x, y, attrUpd = self.dataPickerGetPoint()
-        text = 'x: ' + str(roundSignificant(x, 5)) + '\ny: ' + str(roundSignificant(y, 5))
-        textxy = ''
-        textargs = {'textcoords': 'data', 'xytext': [x, y], 'fontsize': 8}
-        self.executeGraphMethod('addText', text, textxy, textargs=textargs)
-        if not self.varPrintCommands.get():
-            print('New text annotation:', text.replace('\n', '\\n'))
-        self.updateUI()
-
-
-    # manager for text annotations
-    def popupAnnotations(self):
-        # opens manager
-        from gui.GUIpopup import GuiManagerAnnotations
-        self.windowAnnotate = tk.Toplevel(self.master)
-        self.test = GuiManagerAnnotations(self.windowAnnotate, self.back_graph, self.popupAnnotationsCatch)
+    def updateCrosshair(self, draw=True):
+        """
+        draw the canvas including crosshair, except if called from updateUI
+        which handles draw() by itself
+        """
+        # first, delete existing crosshair
+        try:
+            self.crosshairx.remove()
+            del self.crosshairx
+        except Exception:
+            pass
+        try:  # first delete existing crosshair
+            self.crosshairy.remove()
+            del self.crosshairy
+        except Exception:
+            pass
+        # then makes new ones
+        if self.varCrosshair.get():
+            self.app.enableCanvasCallbacks()
+            xdata = self.varX.get()
+            ydata = self.varY.get()
+            curve = self.varCurve.get()
+            restrict = self.varRestrict.get()
+            idx = self.varIdx
+            graph = self.app.graph()
+            alter = graph.attr('alter')
+            if curve >= 0 and curve >= len(graph):
+                curve = len(graph) - 1
+                self.varCurve.set(curve)
+            if isinstance(alter, str):
+                alter = ['', alter]
+            posx, posy = xdata, ydata
+            if restrict and curve >= 0 and not np.isnan(idx):
+                posx = graph[curve].x_offsets(index=idx, alter=alter[0])
+                posy = graph[curve].y_offsets(index=idx, alter=alter[1])
+                # print('crosshair', xdata, ydata, posx, posy)
+            ax = self.app.getAx()
+            self.crosshairx = ax.axvline(posx, 0, 1, color=[0.5, 0.5, 0.5])
+            self.crosshairy = ax.axhline(posy, 0, 1, color=[0.5, 0.5, 0.5])
+        else:
+            self.app.disableCanvasCallbacks()
+        if draw:
+            self.app.getCanvas().draw()
 
-    def popupAnnotationsCatch(self, dictupdate):
-        self.back_graph.update(dictupdate)
-        self.updateUI()
+    def eventMouseMotion(self, event):
+        xdata, ydata = event.xdata, event.ydata
+        self.varIdx = np.nan
+        if (event.xdata is not None and self.varRestrict.get()
+                and self.varCurve.get() > -1):
+            graph = self.app.graph()
+            curve = graph[self.varCurve.get()]
+            if curve is not None:
+                xdata, ydata, idx = curve.getPointClosestToXY(xdata, ydata, alter=graph.attr('alter'))
+                self.varIdx = idx
+        if xdata is not None:
+            self.varX.set(xdata)
+        if ydata is not None:
+            self.varY.set(ydata)
+        self.updateCrosshair()
+
+
+class GUIFrameCentral():
+    """
+    Handles the central panel with graph, axis limits, and datapicker
+    Contains a Frame, to be embedded in a wider application (.frame.pack())
+    Some methods will call methods of application
+    """
+
+    def __init__(self, master, application, **kwargs):
+        self.frame = tk.Frame(master, **kwargs)
+        self.app = application
+        self.createWidgets(self.frame)
+        self.frameGraph.registerCallback_notifyCanvas(self.frameDataPicker.eventMouseMotion)
 
-    # manager for data edition
-    def popupDataEditor(self):
-        # opens manager
-        from gui.GUIdataEditor import GuiDataEditor
-        self.windowDataEditor = tk.Toplevel(self.master)
-        self.test = GuiDataEditor(self.windowDataEditor, self.back_graph, self.popupDataEditorCatch)
+    def updateUI(self):
+        self.frameGraph.updateUI()
+        self.frameOptions.updateUI()
+        self.frameDataPicker.updateUI()
 
-    def popupDataEditorCatch(self):
-        # modification of the Curve are performed within popup. Little to do
-        self.updateUI()
+    def createWidgets(self, frame):
+        fr = tk.Frame(frame)
+        fr.pack(side='bottom', fill=tk.X)
+        # Canvas dor Graph
+        self.frameGraph = GUIFrameCanvasGraph(frame, self.app)
+        self.frameGraph.frame.pack(side='top', fill=tk.BOTH, expand=True)
+        canvas = self.frameGraph.canvas
+        # Datatransform, annotations, labels, limits
+        self.frameOptions = GUIFrameCentralOptions(fr, self.app, canvas)
+        self.frameOptions.frame.pack(side='top', fill=tk.X)
+        # Datapicker
+        self.frameDataPicker = GUIFrameDataPicker(fr, self.app)
+        self.frameDataPicker.frame.pack(side='top', fill=tk.X)
+
+
+class GUIFrameConsole():
+    """
+    Handles the display of current file/folder, and the output console
+    Contains a Frame, to be embedded in a wider application (.frame.pack())
+    Some methods will call methods of application
+    """
+
+    def __init__(self, master, application, **kwargs):
+        self._consoleHeightRoll = [8, 20, 0]
+
+        self.app = application
+        self.frame = tk.Frame(master, **kwargs)
+        self.createWidgets(self.frame)
 
     def updateUI(self):
-        # self.updateUI_graph()
-        try:
-            self.updateUI_graph()
-        except Exception as e:
-            print('Exception during update of the GUI Graph panel.')
-            print('Exception', type(e), e)
-            print('Error on line {}'.format(sys.exc_info()[-1].tb_lineno))
-        # self.updateUI_plot()
-        try:
-            self.updateUI_plot()
-        except Exception as e:
-            print('Exception during update of the GUI plot.')
-            print('Exception', type(e), e)
-            print('Error on line {}'.format(sys.exc_info()[-1].tb_lineno), type(e).__name__, e)
+        self.varFile.set(self._shorten(self.app.getFile()))
+        self.varFolder.set(self._shorten(self.app.getFolder()))
 
-    def updateUI_plot(self):
-        try:
-            fig, ax = Graph.plot(self.back_graph, figAx=[self.Graph_fig, None])
-            while isinstance(ax, (list, np.ndarray)) and len(ax) > 0:
-                ax = ax[-1]
-            self.Graph_fig, self.Graph_ax = fig, ax
-        except ValueError as e:
-            print('Exception ValueError during GUI plot update.')
-            print('Exception', e)
-            pass
-        self.callback_updateCrosshair(draw=False)
+    def createWidgets(self, frame):
+        # fr = FrameTitleContentHide(frame, self.cw_linefile, self.cw_frconsole,
+        #                            default='show', horizLineFrame=True,
+        #                            contentpackkwargs={'expand': True})
+        # fr.pack(side='top', fill=tk.X, anchor='w')
+        title = tk.Frame(frame)
+        self.cw_linefile(title)
+        title.pack(side='top', fill=tk.X, anchor='w')
+        self.content = tk.Frame(frame)
+        self.cw_frconsole(self.content)
+        self.content.pack(side='top', fill=tk.X, anchor='w')
+
+    def cw_linefile(self, frame):
+        # current file
+        self.varFile = LabelVar(frame, value='')
+        self.varFile.pack(side='left', anchor='center')
+        # current folder
+        self.varFolder = LabelVar(frame, value='')
+        # self.varFolder.pack(side='top', anchor='w')  # DO NOT DISPLAY
+        # button, horizontal line
+        fr = tk.Frame(frame, width=20, height=20)
+        fr.propagate(0)
+        btn = tk.Button(fr, text='\u21F3')
+        btn.pack(side='left', anchor='n', fill=tk.BOTH, expand=1)
+        fr.pack(side='left', anchor='center')
+        line = FrameTitleContentHide.frameHline(frame)
+        line.pack(side='left', anchor='center', fill=tk.X, expand=1, padx=5)
+        bind_tree(frame, '<Button-1>', self._changeTextHeight)
+
+    def _changeTextHeight(self, *args):
+        old = int(self._consoleHeight)
         try:
-            self.canvas.show()
-        except AttributeError:
-            pass # handles FigureCanvasTkAgg has no attribute show in later
-            # versions of matplotlib
-        self.canvas.draw()
+            idx = self._consoleHeightRoll.index(self._consoleHeight) + 1
+            if idx == len(self._consoleHeightRoll):
+                idx = 0
+        except ValueError:
+            idx = 0
+        self._consoleHeight = self._consoleHeightRoll[idx]
+        self.console.configure(height=self._consoleHeight)
+        if self._consoleHeight == 0:
+            self.content.pack_forget()
+        elif old == 0:  # if was hidden, need to .pack() it again
+            self.content.pack(side='top', fill=tk.X, anchor='w')  # expand=True, fill=tk.X)
 
+    def cw_frconsole(self, frame):
+        frame.columnconfigure(0, weight=1)
+        # console
+        self._consoleHeight = self._consoleHeightRoll[0]
+        self.console = TextWriteable(frame, wrap='word',
+                                     height=self._consoleHeight)
+        scroll_y = tk.Scrollbar(frame, orient="vertical",
+                                command=self.console.yview)
+        scroll_y.grid(row=0, column=1, sticky=tk.E+tk.N+tk.S)
+        self.console.grid(row=0, column=0, sticky=tk.W+tk.E)
+        self.console.configure(yscrollcommand=scroll_y.set)
+
+    def _shorten(self, string):
+        if len(string) > 150:
+            string = string[:60] + ' ... ' + string[-60:]
+        return string
+
+
+class GUIFrameMenuMain():
+    """
+    Handles the main menu (on the left of the application)
+    Contains a Frame, to be embedded in a wider application (.frame.pack())
+    Some methods will call methods of application
+    """
+
+    def __init__(self, master, application, **kwargs):
+        self.frame = tk.Frame(master, **kwargs)
+        self.app = application
+        self.createWidgets(self.frame)
+        self.bindKeystrokes()
+
+    def bindKeystrokes(self):
+        """ Bind keystrokes to the behavior of the main application """
+        frame = self.app.master
+        frame.bind('<Control-s>', lambda e: self.saveGraph())
+        frame.bind('<Control-Shift-S>', lambda e: self.saveGraphAs())
+        frame.bind('<Control-o>', lambda e: self.openFile())
+        frame.bind('<Control-Shift-O>', lambda e: self.mergeFile())
+        # too larges chances to mess up with that one
+        # self.master.bind('<Control-v>', lambda e: self.openClipboard())
+        frame.bind('<Control-Shift-V>', lambda e: self.mergeClipboard())
+        frame.bind('<Control-Shift-N>', lambda e: self.appendCurveEmpty())
 
-    def updateUI_graph_addTreeBranch(self, idx, attr, tree):
-        keyList = []
-        for key in attr:
-            keyList.append(key)
-        keyList.sort()
-        for key in keyList:
-            val = attr[key]
-            if isinstance(val, list) or isinstance(val, np.ndarray):
-                val = '"' + self.listToString(val).replace('"', '\\"') + '"'
-            elif isinstance(val, str):
-                val = '"' + val.replace('\\n', '\\\\n').replace('\n', '\\\\n').replace('"', '\\"') + '"'
-            else:
-                val = '"' + str(val) + '"'
-            val = val.replace('\n', '\\\\n').replace('\\', '\\\\')
-            try:
-                tree.insert(idx, 'end', text=key, values=val, tag=key)  # idxLast =
-            except Exception as e:
-                print('Exception AddTreeBranch key', key, ', val', val, type(e), e)
+    def createWidgets(self, frame):
+        self.showHide = FrameTitleContentHide(frame, None, None,
+                        default='show', layout='vertical', showHideTitle=True,
+                        createButtons=False, horizLineFrame=False)
+        self.showHide.pack(side='top', fill=tk.BOTH, expand=True)
+        self.cw_allHide(self.showHide.getFrameTitle())
+        self.cw_allShow(self.showHide.getFrameContent())
+        self.showHide.getFrameTitle().pack_forget()
+
+    def cw_allHide(self, frame):
+        fr, _ = self.showHide.createButton(frame, symbol=u"\u25B6",
+                                           size='auto')
+        fr.pack(side='top', anchor='w')
+        canvas = tk.Canvas(frame, width=20, height=40)
+        canvas.pack(side='top', anchor='w')
+        canvas.create_text(6, 40, text="Menu", angle=90, anchor="w",
+                           font=self.app.fonts['bold'])
 
-    def updateUI_graph(self):
-        graph = self.back_graph
-        self.alterListGUI = graph.alterListGUI()
-        # clear displayed content
-        self.Tree.delete(*self.Tree.get_children())
-        self.ListBoxCurves.delete(0, tk.END)
-        self.optionmenuDataPickerCurve['menu'].delete(0, 'end')
-        # tree: update graphinfo
-        attr = graph.graphInfo
-        idx0 = self.Tree.insert('', 'end', text='Graph', tag='-1', values=(''))
-        self.updateUI_graph_addTreeBranch(idx0, attr, self.Tree)
-        # tree: update headers & sampleinfo
-        attr = copy.deepcopy(graph.headers)
-        attr.update(graph.sampleInfo)
-        if len(attr) > 0 :
-            idx = self.Tree.insert('', 'end', text='Misc.', tag='-1', values=(''))
-            self.updateUI_graph_addTreeBranch(idx, attr, self.Tree)
-        # tree & list of curves
-        toSelect = [idx0]
-        toSelectDefault = True
+    def cw_allShow(self, frame):
+        # top inner frame
+        self.cw_openMerge(frame)
+        self.cw_save(frame)
+        fr = tk.Frame(frame)
+        fr.pack(side='bottom', fill='both', expand=True)
+        self.cw_scripts(fr)
+        self.cw_bottom(fr)
+
+    def cw_sectionTitle(self, frame, title):
+        fr = tk.Frame(frame)
+        fr.pack(side='top', fill=tk.X)
+        lbl = tk.Label(fr, text=title, font=self.app.fonts['bold'])
+        lbl.pack(side='left', anchor='center')
+        hline = FrameTitleContentHide.frameHline(fr)
+        hline.pack(side='left', anchor='center', fill=tk.X, expand=1, padx=5)
+        return fr
+
+    def cw_openMerge(self, frame):
+        # Section open & merge
+        fr = self.cw_sectionTitle(frame, 'Open or merge files')
+        fr_, _ = self.showHide.createButton(fr, symbol=u"\u25C1", size='auto')
+        fr_.pack(side='right', anchor='center')
+        # buttons
+        fr = tk.Frame(frame)
+        fr.pack(side='top', fill=tk.X, padx=10)
+        tk.Label(fr, text='Open').grid(sticky='w', row=0, column=0)
+        of = tk.Button(fr, text='File  ',  command=self.openFile)
+        oc = tk.Button(fr, text='Clipboard', command=self.openClipboard)
+        of.grid(sticky='w', row=0, column=1, padx=5)
+        oc.grid(sticky='w', row=0, column=2)
+        tk.Label(fr, text='Merge with').grid(sticky='w', column=0, row=1)
+        mf = tk.Button(fr, text='File  ',  command=self.mergeFile)
+        mc = tk.Button(fr, text='Clipboard', command=self.mergeClipboard)
+        mf.grid(sticky='w', column=1, row=1, padx=5)
+        mc.grid(sticky='w', column=2, row=1)
+        CreateToolTip(of, "Ctrl+O")
+        CreateToolTip(mf, "Ctrl+Shift+O")
+        CreateToolTip(mc, "Ctrl+Shift+V")
+        # Misc - open folders, etc
+        fr = tk.Frame(frame)
+        fr.pack(side='top', fill=tk.X, padx=10)
+        u = tk.Button(fr, text='Open all in folder', command=self.openFolder)
+        # u.grid(column=1, row=1, sticky='w')
+        u.pack(side='left')
+        self.varOpenSubfolders = CheckbuttonVar(fr, 'subfolders', 0)
+        # self.varOpenSubfolders.grid(column=2, row=1)
+        self.varOpenSubfolders.pack(side='left')
+        # new curve, close
+        fr = tk.Frame(frame)
+        fr.pack(side='top', fill=tk.X, padx=10)
+        v = tk.Button(fr, text='New empty Curve',
+                      command=self.appendCurveEmpty)
+        # v.grid(column=1, row=2, sticky='w')
+        v.pack(side='left')
+        explain = 'For creating a new subplot, inset, image etc. Ctrl+Shift+N'
+        CreateToolTip(u, 'Open all files in a given folder')
+        CreateToolTip(v, explain)
 
-        for i in range(graph.length()):
-            # listBox
-            orderLbl = ['label', 'sample', 'filename']
-            lbl = '(no label)'
-            for test in orderLbl:
-                tmp = graph.curve(i).getAttribute(test)
-                if tmp != '':
-                    lbl = str(tmp)
-                    break
-            self.ListBoxCurves.insert(i, str(i) + ' ' + lbl)
-            self.optionmenuDataPickerCurve['menu'].add_command(label=str(i)+' '+lbl.replace("'",'\''), command=tk._setit(self.varDataPickerCurve, i))
-            # tree
-            attr = graph.curve(i).getAttributes()
-            idx = self.Tree.insert('', 'end', text='Curve '+str(i)+' '+lbl.replace('\n', '\\n'), tag=str(i), values=(''))
-            self.Tree.tag_configure(str(i), foreground=('grey' if graph.curve(i).isHidden() else 'black'))
-            self.updateUI_graph_addTreeBranch(idx, attr, self.Tree)
-            if i in self.previousSelectedCurve:
-                if toSelectDefault:
-                    toSelect = [copy.deepcopy(idx)]
-                    toSelectDefault = False
-                else:
-                    toSelect.append(copy.deepcopy(idx))
-        self.Tree.focus(toSelect[0])
-        self.Tree.selection_set(tuple(toSelect))
-        # check data picker Curve selection
-        if self.varDataPickerCurve.get() >= graph.length():
-            self.varDataPickerCurve.set(graph.length()-1)
-        # quick modifs
-        xlim = self.back_graph.getAttribute('xlim', ['', ''])
-        ylim = self.back_graph.getAttribute('ylim', ['', ''])
-        xlim = [(x if not isinstance(x, str) and not np.isnan(x) else '') for x in xlim]
-        ylim = [(y if not isinstance(y, str) and not np.isnan(y) else '') for y in ylim]
-        self.varQuickModsXlabel.set(str(self.back_graph.getAttribute('xlabel')).replace('\n','\\n'))
-        self.varQuickModsYlabel.set(str(self.back_graph.getAttribute('ylabel')).replace('\n','\\n'))
-        self.varQuickModsXlim0.set(str(xlim[0]))
-        self.varQuickModsXlim1.set(str(xlim[1]))
-        self.varQuickModsYlim0.set(str(ylim[0]))
-        self.varQuickModsYlim1.set(str(ylim[1]))
-        # OptionMenu Curve transform (alter)
-        [idx, display, alter, typePlot] = self.plotChangeView_identify()
-        self.OMAlter.resetValues([i[0] for i in self.alterListGUI],
-                                 default=display, func=self.plotChangeView2)
-        # checks
-        sel = [e for e in self.previousSelectedCurve if (e >= 0 and e < graph.length())]
-        if len(sel) == 0:
-            sel = [-1]
-        self.previousSelectedCurve = sel
-        # current filename
-        val = self.back_graph.filename if hasattr(self.back_graph, 'filename') else ''
-        self.back_file = val
-        self.varLabelFile.set(val)
+    def cw_save(self, frame):
+        fr = tk.Label(frame, text='')
+        fr.pack(side='top')
+        # Section Save title
+        self.cw_sectionTitle(frame, 'Save data & graph')
+        # Buttons
+        fr = tk.Frame(frame)
+        fr.pack(side='top', fill=tk.X, padx=10)
+        s_ = tk.Button(fr, text='Save', command=self.saveGraph)
+        s_.pack(side='left', anchor='n')
+        sa = tk.Button(fr, text='Save as...', command=self.saveGraphAs)
+        sa.pack(side='left', anchor='n', padx=5)
+        sc = tk.Button(fr, text='Copy image',
+                       command=self.saveImageToClipboard)
+        sc.pack(side='left', anchor='n')
+        CreateToolTip(s_, "Ctrl+S")
+        CreateToolTip(sa, "Ctrl+Shift+S")
+        # options
+        fr = tk.Frame(frame)
+        fr.pack(side='top', fill=tk.X, padx=10)
+        self.varSaveScreen = CheckbuttonVar(fr, 'Screen data (better not)', 0)
+        self.varSaveScreen.pack(side='top', anchor='w', padx=5)
+        self.varSaveSepara = CheckbuttonVar(fr, 'Keep separated x columns', 0)
+        self.varSaveSepara.pack(side='top', anchor='w', padx=5)
+
+    def cw_scripts(self, frame):
+        # Section Scripts
+        fr = tk.Label(frame, text='')
+        fr.pack(side='top')
+        self.cw_sectionTitle(frame, 'Data processing scripts')
+        self.cw_scripts_JVfit(frame)
+        self.cw_scripts_JVsummary(frame)
+        self.cw_scripts_CVCdJscVoc(frame)
+
+    def cw_scripts_JVfit(self, frame):
+        # Section Scripts JV
+        lbl = tk.Label(frame, text='JV curves (files in 1 folder):')
+        lbl.pack(side='top', anchor='w', padx=0, pady=2)
+        # diode weights
+        fr = tk.Frame(frame)
+        fr.pack(side='top', fill=tk.X, padx=10)
+        lbl = tk.Label(fr, text='Fit weight diode region')
+        lbl.pack(side='left', anchor='n')
+        self.varJVDiodeweight = EntryVar(fr, '5', width=6)
+        self.varJVDiodeweight.pack(side='left', anchor='n')
+        CreateToolTip(lbl, "1 neutral, 10 increased weight")
+        CreateToolTip(self.varJVDiodeweight, "1 neutral, 10 increased weight")
+        # buttons
+        btn0 = tk.Button(frame, text='Fit cell-by-cell',
+                         command=self.scriptFitJVCombined)
+        btn1 = tk.Button(frame, text='Fit curves separately',
+                         command=self.scriptFitJVAll)
+        btn0.pack(side='top', anchor='w', padx=10)
+        btn1.pack(side='top', anchor='w', padx=10)
+
+    def cw_scripts_JVsummary(self, frame):
+        lbl = tk.Label(frame, text='Operations on JV summaries:')
+        btn0 = tk.Button(frame, text='JV sample maps (1 file)',
+                         command=self.scriptJVSampleMaps)
+        btn1 = tk.Button(frame, text='JV boxplots (files in 1 folder)',
+                         command=self.scriptJVBoxplots)
+        lbl.pack(side='top', anchor='w', padx=0, pady=2)
+        btn0.pack(side='top', anchor='w', padx=10)
+        btn1.pack(side='top', anchor='w', padx=10)
+
+    def cw_scripts_CVCdJscVoc(self, frame):
+        lbl = tk.Label(frame, text='C-V, C-f, Jsc-Voc data processing')
+        lbl.pack(side='top', anchor='w', padx=0, pady=2)
+        # CV
+        fr = tk.Frame(frame)
+        fr.pack(side='top', fill=tk.X, padx=10)
+        btn = tk.Button(fr, text='C-V (1 folder)', command=self.scriptCV)
+        btn.pack(side='left', pady=2)
+        lbl = tk.Label(fr, text='ROI')
+        lbl.pack(side='left', pady=2)
+        from grapa.datatypes.curveCV import CurveCV
+        valuedefCV = listToString(CurveCV.CST_MottSchottky_Vlim_def)
+        self.varCVROI = EntryVar(fr, valuedefCV, width=10)
+        self.varCVROI.pack(side='left', pady=2)
+        # Cf
+        btn0 = tk.Button(frame, text='C-f (1 folder)', command=self.scriptCf)
+        btn0.pack(side='top', anchor='w', padx=10)
+        # Jsc-Voc
+        fr = tk.Frame(frame)
+        fr.pack(side='top', fill=tk.X, padx=10)
+        btn = tk.Button(fr, text='Jsc-Voc (1 file)', command=self.scriptJscVoc)
+        btn.pack(side='left', pady=2)
+        lbl = tk.Label(fr, text='Jsc min')
+        lbl.pack(side='left', pady=2)
+        from grapa.datatypes.curveJscVoc import CurveJscVoc
+        valuedefVocJsc = str(CurveJscVoc.CST_Jsclim0)
+        self.varJscVocROI = EntryVar(fr, valuedefVocJsc, width=6)
+        self.varJscVocROI.pack(side='left', pady=2)
+        tooltiplbl = "fit range of interest (min value or range), in mA/cm2"
+        CreateToolTip(lbl, tooltiplbl)
+        CreateToolTip(self.varJscVocROI, tooltiplbl)
+
+    def cw_bottom(self, frame):
+        fr0 = tk.Frame(frame)
+        fr0.pack(side='bottom', fill=tk.X)
+        # bottom section
+        self.cw_sectionTitle(fr0, '')
+        # contentkwargs
+        fr = tk.Frame(fr0)
+        fr.pack(side='top', fill=tk.X)
+        self.varPrintCommands = CheckbuttonVar(fr, 'Commands in console', False, command=lambda: print('Commands printing is not fully tested yet'))
+        self.varPrintCommands.pack(side='left', anchor='center')
+        btn = tk.Button(fr, text="QUIT", fg="red", command=self.quitMain)
+        btn.pack(side='right', anchor='n', pady=2, padx=5)
 
+    # methods
+    def openFile(self):
+        """ Open a file chosen by user """
+        file = self.app.promptFile(multiple=True)
+        if file != '' and file is not None:
+            self.app.openFile(file)
+
+    def mergeFile(self):
+        """ Merge data with file chosen by user """
+        file = self.app.promptFile(multiple=True)
+        if file != '' and file is not None:
+            self.app.mergeGraph(file)
+
+    def openFolder(self):
+        """ Open all files in a folder given by user """
+        folder = self.app.promptFolder()
+        if folder is not None and folder != '':
+            files = self._listFilesinFolder(folder)
+            self.app.openFile(files)
+
+    def openClipboard(self):
+        """ Retrieve the content of clipboard and create a graph with it """
+        folder = self.app.getFolder()
+        dpi = self.app.getTabProperties()['dpi']
+        tmp = self.app.getClipboard()
+        graph = Graph(tmp, {'isfilecontent': True}, **self.app.newGraphKwargs)
+        print('Import data from clipboard ('+str(len(graph))+' Curves found).')
+        self.app.graph(graph, title='from clipboard', folder=folder, dpi=dpi)
+        # updateUI will be triggered by change in tabs
+
+    def mergeClipboard(self):
+        """ Retrieves the content of clipboard, and appends it to the graph """
+        tmp = self.app.getClipboard()
+        graph = Graph(tmp, {'isfilecontent': True})
+        print('Import data from clipboard ('+str(len(graph))+' Curves found).')
+        self.app.mergeGraph(graph)
 
-    def updateUponResizeWindow(self, *args):
-        # check if GUI is created for the first time, to avoid updates when
-        # windows is not ready
-        if hasattr(self, 'initiated') and self.initiated:
-            # self.canvas.resize(*args) if event fired from canvas configure event
-            self.updateUI_plot()
-
-    def callback_updateCrosshair(self, draw=True):
-        # normally draw the canvas, except if called from updateUI which
-        # handles draw() by itself
-        if hasattr(self, 'crosshairx'):
-            try:  # first delete existing crosshair
-                self.crosshairx.remove()
-                del self.crosshairx
-            except ValueError:
-                pass
-        if hasattr(self, 'crosshairy'):
-            try: # first delete existing crosshair
-                self.crosshairy.remove()
-                del self.crosshairy
-            except ValueError:
-                pass
-        if self.varDataPickerCrosshair.get():
-            self.enableCanvasCallbacks()
-            xdata = self.varDataPickerX.get()
-            ydata = self.varDataPickerY.get()
-            idx   = self.varDataPickerIdx
-            curve = self.varDataPickerCurve.get()
-            alter = self.back_graph.getAttribute('alter')
-            if curve >= 0 and curve >= self.back_graph.length():
-                curve = self.back_graph.length() - 1
-                self.varDataPickerCurve.set(curve)
-            if isinstance(alter, str):
-                alter = ['', alter]
-            restrict = self.varDataPickerRestrict.get()
-            posx, posy = xdata, ydata
-            if restrict and curve >= 0 and not np.isnan(idx):
-                posx = self.back_graph.curve(curve).x_offsets(index=idx, alter=alter[0])
-                posy = self.back_graph.curve(curve).y_offsets(index=idx, alter=alter[1])
-                # print('crosshair', xdata, ydata, posx, posy)
-            self.crosshairx = self.Graph_ax.axvline(posx, 0, 1, color=[0.5, 0.5, 0.5])
-            self.crosshairy = self.Graph_ax.axhline(posy, 0, 1, color=[0.5, 0.5, 0.5])
+    def saveGraph(self, filename=''):
+        """ Saves the graph (image & data) with same filename as last time """
+        if self.app.graph().attr('meastype') not in ['', FILEIO_GRAPHTYPE_GRAPH]:
+            print('ERROR when saving data: are you sure you are not',
+                  'overwriting a graph file?')
+            print('Click on Save As... to save the current graph (or delete',
+                  'attribute "meastype").')
+            self.saveGraphAs(filesave='')
         else:
-            self.disableCanvasCallbacks()
-        if draw:
-            self.canvas.draw()
+            filesave = self.app.getFile()
+            self.saveGraphAs(filesave=filesave)
 
-    def treeActiveCurve(self, curItem):
-        # handle several selected items
-        if isinstance(curItem, tuple):
-            out = [self.treeActiveCurve(item) for item in curItem]
-            out = tuple(set(out))  # remove duplicates
-            out = tuple(sorted(list(out)))
-            return out
-        # handle single element
-        itemP = self.Tree.parent(curItem)
-        itemList = self.Tree.item(curItem)
-        tags = itemList['tags']
-        if itemP != '':
-            it = self.Tree.item(itemP)
-            tags = it['tags']
-        if isinstance(tags, list):
-            tags = tags[0]
-        return tags
-
-    def treeSelectItem(self, a):
-        curItem = self.Tree.focus()
-        curve = self.treeActiveCurve(curItem)
-        self.previousSelectedCurve = [curve]
-        if curve == -1:
-            keyList = Graph.graphInfoKeys
-            valList = Graph.graphInfoKeysExample
-        else:
-            keyList = Graph.dataInfoKeysGraph
-            valList = Graph.dataInfoKeysGraphExample
-        # update GUI Edit property
-        itemList = self.Tree.item(curItem)
-        if self.Tree.parent(curItem) == '':
-            self.varEditPropProp.set('Property')
-            self.varEditPropVal.set('')
-            self.EditPropExample.set('')
-        else:
-            prop = itemList['text']
-            value = itemList['values'][0]
-            self.varEditPropProp.set(prop)
-            self.varEditPropVal.set(value)
+    def saveGraphAs(self, filesave=''):
+        """ saves the graph to image + data file, asks for a new filename """
+        # TODO
+        defext = ''
+        if filesave == '':
+            defext = copy.copy(self.app.graph().config('save_imgformat', '.png'))
+            if isinstance(defext, list):
+                defext = defext[0]
+            filesave = self.app.promptFile(type='save', defaultextension=defext)
+        if filesave is None or filesave == '':
+            # asksaveasfile return `None` if dialog closed with "cancel".
+            return
+        # retrive info from GUI
+        saveAltered = self.varSaveScreen.get()
+        ifCompact = not self.varSaveSepara.get()
+        # some checks to avoid erasig something important
+        filesave, fileext = os.path.splitext(filesave)
+        fileext = fileext.lower()
+        forbiddenExt = ['py', 'txt', '.py', '.txt']
+        for ext in forbiddenExt:
+            fileext = fileext.replace(ext, '')
+        if fileext == defext:
+            fileext = ''
+        self.app.saveGraph(filesave, fileext=fileext, saveAltered=saveAltered,
+                           ifCompact=ifCompact)
+
+    def _listFilesinFolder(self, folder):
+        # returns a list with all files in folder. Look for subfolders status
+        subfolders = self.varOpenSubfolders.get()
+        nMax = 1000
+        out = []
+        if subfolders:
+            for root, subdirs, files in os.walk(folder):
+                for file in files:
+                    fileName, fileExt = os.path.splitext(file)
+                    if len(out) < nMax:
+                        out.append(str(os.path.join(root, file)))
+        else:  # not subfolders
+            for file in os.listdir(folder):
+                fileName, fileExt = os.path.splitext(file)
+                if (os.path.isfile(os.path.join(folder, file))
+                        and len(out) < nMax):
+                    out.append(str(os.path.join(folder, file)))
+        return out
+
+    def appendCurveEmpty(self):
+        """ Append an empty Curve in current Graph """
+        curve = Curve([[0], [np.nan]], {})
+        self.app.appendCurveToGraph(curve)
+
+    def saveImageToClipboard(self):
+        """ Copy an image of current graph into the clipboard """
+        return imageToClipboard(self.app.graph())
+
+    def scriptFitJVCombined(self, groupCell=True):
+        """
+        Script JV process, grouped by cells
+        - groupCell: True to group results by cell, False for independent
+          processing for each cell
+        """
+        from grapa.scripts.script_processJV import processJVfolder
+        folder = self.app.promptFolder()
+        if folder != '':
+            print('... Processing folder ...')
+            weight = strToVar(self.varJVDiodeweight.get())
+            ngkw = self.app.newGraphKwargs
+            graph = processJVfolder(folder, ylim=(-np.inf, np.inf),
+                                    groupCell=groupCell, fitDiodeWeight=weight,
+                                    newGraphKwargs=ngkw)
+            self.app.openFile(graph)
+
+    def scriptFitJVAll(self):
+        """ Script JV process, each file indepedently """
+        self.scriptFitJVCombined(groupCell=False)
+
+    def scriptJVSampleMaps(self):
+        """ Script JV sample maps """
+        from grapa.scripts.script_processJV import processSampleCellsMap
+        file = self.app.promptFile()
+        if file is not None and file != '':
+            print('...creating sample maps...')
+            ngkw = self.app.newGraphKwargs
+            filelist = processSampleCellsMap(file, newGraphKwargs=ngkw)
+            if len(filelist) > 0:
+                graph = Graph(filelist[-1])
+                self.app.openFile(graph)
+
+    def scriptJVBoxplots(self):
+        """ Script boxplots """
+        from grapa.scripts.script_JVSummaryToBoxPlots import JVSummaryToBoxPlots
+        folder = self.app.promptFolder()
+        if folder is not None and folder != '':
+            print('...creating boxplots...')
+            tmp = JVSummaryToBoxPlots(folder=folder, exportPrefix='boxplots_',
+                                      replace=[], silent=True,
+                                      newGraphKwargs=self.app.newGraphKwargs)
+            self.app.openFile(tmp)
+
+    def scriptJscVoc(self):
+        """ Script JscVoc """
+        from grapa.scripts.script_processJscVoc import script_processJscVoc
+        file = self.app.promptFile()
+        if file is not None and file != '':
+            ROIJsclim = strToVar(self.varJscVocROI.get())
+            ngkw = self.app.newGraphKwargs
+            graph = script_processJscVoc(file, ROIJsclim=ROIJsclim,
+                                         newGraphKwargs=ngkw)
+            self.app.openFile(graph)
+
+    def scriptCV(self):
+        """ Script CV """
+        from grapa.scripts.script_processCVCf import script_processCV
+        folder = self.app.promptFolder()
+        if folder is not None and folder != '':
+            ROIfit = strToVar(self.varCVROI.get())
+            graph = script_processCV(folder, ROIfit=ROIfit,
+                                     newGraphKwargs=self.app.newGraphKwargs)
+            self.app.openFile(graph)
+
+    def scriptCf(self):
+        """ Script Cf """
+        from grapa.scripts.script_processCVCf import script_processCf
+        folder = self.app.promptFolder()
+        if folder is not None and folder != '':
+            ngkw = self.app.newGraphKwargs
+            graph = script_processCf(folder, newGraphKwargs=ngkw)
+            self.app.openFile(graph)
+
+    def quitMain(self):
+        """ Quits main application """
+        self.app.quit()
+
+
+class GUIFrameTemplateColorize():
+    """
+    Handles the templates and colorization features
+    Contains a Frame, to be embedded in a wider application (.frame.pack())
+    Some methods will call methods of application
+    """
+
+    def __init__(self, master, application, **kwargs):
+        self.frame = tk.Frame(master, **kwargs)
+        self.app = application
+        self.createWidgets(self.frame)
+
+    def updateUI(self):
+        pass
+
+    def createWidgets(self, frame):
+        fr = FrameTitleContentHide(frame, self.cw_title, self.cw_content,
+                                   default='hide', contentkwargs={'padx': 10})
+        fr.pack(side='top', fill=tk.X, anchor='w')
+
+    def cw_title(self, frame):
+        lbl = tk.Label(frame, text='Template & Colorize',
+                       font=self.app.fonts['bold'])
+        lbl.pack(side='left')
+
+    def cw_content(self, frame):
+        self.cw_content_template(frame)
+        self.cw_content_colors(frame)
+
+    def cw_content_template(self, frame):
+        # templates
+        fr = tk.Frame(frame)
+        fr.pack(side='top', fill=tk.X, anchor='w', pady=5)
+        btn0 = tk.Button(fr, text='Load & apply template',
+                         command=self.loadTemplate)
+        btn0.pack(side='left', anchor='n')
+        self.varTplCrvProp = CheckbuttonVar(fr, 'also Curves properties', 1)
+        self.varTplCrvProp.pack(side='left')
+        btn1 = tk.Button(fr, text='Save template', command=self.saveTemplate)
+        btn1.pack(side='right', anchor='n')
+
+    def cw_content_colors(self, frame):
+        # line 1
+        fr = tk.Frame(frame)
+        fr.pack(side='top', fill=tk.X, anchor='w')
+        btn0 = tk.Button(fr, text='Colorize', command=self.colorizeGraph)
+        btn0.pack(side='left')
+        self.varColEmpty = CheckbuttonVar(fr, 'repeat if no label  ', False)
+        self.varColEmpty.pack(side='left')
+        self.varColInvert = CheckbuttonVar(fr, 'invert', False)
+        self.varColInvert.pack(side='left')
+        self.varColAvoidWhite = CheckbuttonVar(fr, 'avoid white', False)
+        self.varColAvoidWhite.pack(side='left')
+        self.varColCurveSelect = CheckbuttonVar(fr, 'curve selection', False)
+        self.varColCurveSelect.pack(side='left')
+        # line 2
+        fr = tk.Frame(frame)
+        fr.pack(side='top', anchor='w')
+        self.varColChoice = EntryVar(fr, '', width=70)
+        self.varColChoice.pack(side='left')
+        # line 3
+        fr = tk.Frame(frame)
+        fr.pack(side='top', anchor='w')
+        self.cw_content_colSamples(fr)
+
+    def cw_content_colSamples(self, frame):
+        nPerLine = 12
+        self.colorList = Colorscale.GUIdefaults(**self.app.newGraphKwargs)
+        # need to keep reference of images, otherwise tk.Button loose it
+        self._colImgs = [None] * len(self.colorList)
+        width, height = 30, 15
+        j = 0  # for display purpose, number of widgets actually created
+        for i in range(len(self.colorList)):
+            self._colImgs[i] = PhotoImageColorscale(width=width, height=height)
             try:
-                i = keyList.index(prop)
-                self.EditPropExample.set(valList[i])
+                self._colImgs[i].fillColorscale(self.colorList[i])
             except ValueError:
-                self.EditPropExample.set('')
-        # update GUI New property
-        # do not want legend in the list
-        new_choices = tuple(Graph.graphInfoKeys) if curve == -1 else tuple(Graph.dataInfoKeysGraph)
-        new_choices = tuple(x for x in new_choices if x not in ['legend', ''])
-        self.OptionmenuNewProp['menu'].delete(0, 'end')
-        for choice in new_choices:
-            self.OptionmenuNewProp['menu'].add_command(label=choice, command=tk._setit(self.varNewPropProp, choice))
-        if len(new_choices) > 0:
-            # change selection if specific keyword was selected in tree
-            if self.Tree.parent(curItem) != '':
-                self.varNewPropProp.set(itemList['text'])
-                self.newPropertySelect()
-            else:  # former case: selecting keywork in tree does not change new Property
-                if self.varNewPropProp.get() not in new_choices:
-                    self.varNewPropProp.set(new_choices[0])
-                self.newPropertySelect()
-        # do not want to erase the value field
-        # update GUI curve actions
-        self.fillUIFrameRightAction(self.FrameRAction, curve)
-        # update observable related to selected curve
-        self.observableCurve.update_observers(self.back_graph.curve(curve) if curve > -1 and curve < self.back_graph.length() else curve)
-        # update GUI cast action
-        self.MenuCastCurve['menu'].delete(0, 'end')
-        self.varCastCurve.set('')
-        if curve < 0:
-            self.castCurveList = []
-        else:
-            self.castCurveList = self.back_graph.curve(curve).castCurveListGUI(onlyDifferent=False)
-            for cast in self.castCurveList:
-                self.MenuCastCurve['menu'].add_command(label=cast[0], command=tk._setit(self.varCastCurve, cast[0]))
-            self.varCastCurve.set(self.back_graph.curve(curve).classNameGUI())
+                # if python does not recognize values (e.g. inferno, viridis)
+                continue  # does NOT create widget
+            widget = tk.Button(frame, image=self._colImgs[i],
+                               command=lambda i_=i: self._setColChoice(i_))
+            widget.grid(column=int(j % nPerLine),
+                        row=int(np.floor(j / nPerLine)))
+            j += 1
+
+    def loadTemplate(self):
+        """ load and apply template on current Graph """
+        file = self.app.promptFile()
+        if file != '' and file is not None:
+            print('Open template file:', file)
+            self.app.storeSelectedCurves()  # before modifs to prepare updateUI
+            template = Graph(file, complement={'label': ''})
+            alsoCurves = self.varTplCrvProp.get()
+            self.app.graph().applyTemplate(template, alsoCurves=alsoCurves)
+            self.app.updateUI()
 
+    def saveTemplate(self):
+        """ save template file from current Graph """
+        file = self.app.promptFile(type='save', defaultextension='.txt')
+        if file is not None and file != '':
+            file, fileext = os.path.splitext(file)
+            fileext = fileext.replace('py', '')
+            self.app.graph().export(filesave=file, ifTemplate=True)
+            # no need to refresh UI
 
-    def newPropertySelect(self, *args):
-        curve = self.getActiveCurve(multiple=False)
-        prop = self.varNewPropProp.get()
-        if curve == -1:
-            keyList = Graph.graphInfoKeys
-            valList = Graph.graphInfoKeysExample
-            exaList = Graph.graphInfoKeysExalist
-        else:
-            keyList = Graph.dataInfoKeysGraph
-            valList = Graph.dataInfoKeysGraphExample
-            exaList = Graph.dataInfoKeysGraphExalist
-        # replace content of Entry/Combobox field if a) is empty, or
-        # b) match the previous automatically set value
-        if self.varNewPropVal.get() == '' or (self.varNewPropVal.get() == self.varNewPropValPrevious):
-            existingVal = self.back_graph.getAttribute(prop) if curve == -1 else self.back_graph.curve(curve).getAttribute(prop)
-            self.varNewPropVal.set(str(existingVal))
-            self.varNewPropValPrevious = self.varNewPropVal.get()
+    def colorizeGraph(self):
+        self.app.storeSelectedCurves()  # before modifs, to prepare updateUI
+        col = strToVar(self.varColChoice.get())
+        if len(col) == 0:
+            col = self.colorList[0].getColorScale()
+            self._setColChoice(0)
+        invert = self.varColInvert.get()
+        kwargs = {'avoidWhite': self.varColAvoidWhite.get(),
+                  'sameIfEmptyLabel':  self.varColEmpty.get()}
+        if self.varColCurveSelect.get():
+            curves = self.app.getSelectedCurves(multiple=True)
+            if len(curves) > 0 and curves[0] >= 0:
+                # if no curve is selected, colorize all curves
+                kwargs.update({'curvesselection': curves})
         try:
-            # set example, and populate Combobox values field
-            i = keyList.index(prop)
-            self.NewPropExample.set(str(valList[i]))
-            self.EntryNewProp['values'] = exaList[i]
-        except ValueError:
-            self.NewPropExample.set('')
-            self.EntryNewProp['values'] = []
-        # Entry field grey if unvalid choice
-        if prop.startswith('=='):
-            self.EntryNewProp.configure(state='disabled')
+            colorscale = Colorscale(col, invert=invert)
+            self.app.graph().colorize(colorscale, **kwargs)
+        except ValueError as e:
+            # error to be printed in GUI console, and not hidden in terminal
+            print('ValueError colorizeGraph:', e)
+        if self.app.ifPrintCommands():  # to explicit creation of colorscale
+            print('colorscale = Colorscale(' + str(col) + ', invert='
+                  + str(invert) + ')')
+            print('graph.colorize(colorscale, '
+                  + ', '.join(['{}={!r}'.format(k, v) for k, v in kwargs.items()])
+                  + ')')
+        self.app.updateUI()
+
+    def _setColChoice(self, i):
+        # reads variable (Colorscale object), extract colors (np.array),
+        # converts into string
+        # print('_setColChoice', i, self.colorList[i].getColorScale())
+        if isinstance(self.colorList[i].getColorScale(), str):
+            scale = self.colorList[i].getColorScale()  # eg. viridis
         else:
-            self.EntryNewProp.configure(state='normal')
+            lst = []
+            for elem in self.colorList[i].getColorScale():
+                if not isinstance(elem, str):
+                    toStr = [str(nb if not nb.is_integer() else int(nb)) for nb in elem]
+                    lst.append('[' + ','.join(toStr) + ']')
+                    print('_setColChoice, elem,', elem)
+                else:
+                    lst.append("'" + elem + "'")
+            scale = '[' + ', '.join(lst) + ']'
+        self.varColChoice.set(scale)
+
+
+class GUIFrameActionsGeneric():
+    """
+    Handles the panel Actions on Curves
+    Contains a Frame, to be embedded in a wider application (.frame.pack())
+    Some methods will call methods of application
+    """
+
+    CASTCURVERENAMEGUI = {'Fit Arrhenius': 'Fit'}
+
+    def __init__(self, master, application, **kwargs):
+        self.frame = tk.Frame(master, **kwargs)
+        self.app = application
+        self.createWidgets(self.frame)
+        # bind keys
+        self.app.master.bind('<Control-Delete>', lambda e: self.deleteCurve())
+        self.app.master.bind('<Control-Shift-C>', lambda e: self.copyCurveToClipboard())
+        self.app.master.bind('<Control-h>', lambda e: self.showHideCurve())
 
+    def updateUI(self):
+        # ShowHide: handled by Observable
+        # cast curve optionmenu: handled by Observable
+        pass
 
-    def getActiveCurve(self, multiple=True):
-        if not multiple:
-            out = self.treeActiveCurve(self.Tree.focus())
-            self.previousSelectedCurve = [out]
-        else:
-            out = self.treeActiveCurve(self.Tree.selection())
-            self.previousSelectedCurve = out
-        return out
+    def createWidgets(self, frame):
+        fr = FrameTitleContentHide(frame, self.cw_title, self.cw_content)
+        fr.pack(side='top', fill=tk.X, anchor='w')
 
+    def cw_title(self, frame):
+        lbl = tk.Label(frame, text='Actions on Curves',
+                       font=self.app.fonts['bold'])
+        lbl.pack(side='left', anchor='n')
 
-    def updateProperty(self, curve, key, val, ifUpdate=True, varType='auto'):
-        """
-        perform curve(curve).update({key: stringToVariable(val)})
-        curve -1: update() on self.back_graph
-        ifUpdate: by default update the GUI- if False, does not. Assumes the
-            update will be performed only once, later
-        varType: changes type of val into varType. Otherwise try best guess.
-        """
-        if key == 'Property' or key.startswith('--'):
-            return
-        # print ('Property edition: curve',curve,', key', key,', value', val, '(',type(val),')')
-        # possibly force variable type
-        cases = [str, int, float, list, dict]
-        if varType in cases:
-            val = varType(val)
-        else:
-            val = stringToVariable(val)
-        # handling of newlines
-        if isinstance(val, list):
-            for i in range(len(val)):
-                if isinstance(val[i], str):
-                    val[i] = val[i].replace('\\n', '\n')
-        elif isinstance(val, str):
-            val = val.replace('\\n', '\n')
-        # curve identification
-        if not isinstance(curve, tuple):
-            curve = tuple([curve])
-        for c_ in curve:
-            try:
-                c = int(c_)
-            except Exception:
-                print('Cannot edit property: curve',c_,', key',key,', value',val)
-                return
-            if c < 0:
-                self.back_graph.update({key: val})
-                if self.varPrintCommands.get():
-                    valstr = str(val) if not isinstance(val, str) else "'"+val+"'"
-                    print('graph.update({\''+key+'\': '+valstr+'})')
+    def cw_content(self, frame):
+        def toGrid(row, column, func, **kwargs):
+            kw = {'sticky': 'w'}
+            kw.update(kwargs)
+            fr = tk.Frame(frame)
+            fr.grid(row=row, column=column, **kw)
+            func(fr)
+        toGrid(0, 0, self.cw_reorder, padx=5)
+        toGrid(1, 0, self.cw_delete, padx=5)
+        toGrid(2, 0, self.cw_duplicate, padx=5)
+        toGrid(3, 0, self.cw_showHide, padx=5)
+        toGrid(0, 1, self.cw_clipboard)
+        toGrid(1, 1, self.cw_cast)
+        toGrid(2, 1, self.cw_quickAttr)
+        toGrid(3, 1, self.cw_labelReplace)
+
+    def cw_reorder(self, frame):
+        tk.Label(frame, text='Reorder').pack(side='left')
+        b0 = tk.Button(frame, text=u"\u21E7", command=self.shiftCurveTop)
+        b0.pack(side='left', padx=1)
+        b1 = tk.Button(frame, text=u"\u21D1 Up", command=self.shiftCurveUp)
+        b1.pack(side='left', padx=1)
+        b2 = tk.Button(frame, text=u"\u21D3 Down", command=self.shiftCurveDown)
+        b2.pack(side='left', padx=1)
+        b3 = tk.Button(frame, text=u"\u21E9", command=self.shiftCurveBottom)
+        b3.pack(side='left', padx=1)
+
+    def cw_delete(self, frame):
+        tk.Label(frame, text='Delete Curve').pack(side='left')
+        b0 = tk.Button(frame, text='Curve', command=self.deleteCurve)
+        b0.pack(side='left', padx=3)
+        b1 = tk.Button(frame, text='All hidden', command=self.deleteCurvesHidd)
+        b1.pack(side='left')
+        CreateToolTip(b0, "Ctrl+Delete")
+
+    def cw_duplicate(self, frame):
+        tk.Label(frame, text='Duplicate Curve').pack(side='left')
+        btn = tk.Button(frame, text='Duplicate', command=self.duplicateCurve)
+        btn.pack(side='left')
+
+    def cw_showHide(self, frame):
+        def updateVarSH(curve, key):
+            if not isinstance(curve, Curve):
+                val = 'Show Curve'  # -1 if no curve selected
             else:
-                self.back_graph.curve(c).update({key: val})
-                if self.varPrintCommands.get():
-                    valstr = str(val) if not isinstance(val, str) else "'"+val+"'"
-                    valstr = valstr.replace('\n', '\\n')
-                    print('graph.curve('+str(c)+').update({\''+key+'\': '+valstr+'})')
-        if ifUpdate:
-            self.updateUI()
+                val = 'Show Curve' if curve.isHidden() else 'Hide Curve'
+            self.varShowHide.set(val)
 
-    def executeGraphMethod(self, method, *args, **kwargs):
-        out = getattr(self.back_graph, method)(*args, **kwargs)
+        self.app.observables['focusTree'].register(updateVarSH)
+        self.varShowHide = tk.StringVar()
+        self.varShowHide.set('Show Curve')
+        b0 = tk.Button(frame, textvariable=self.varShowHide,
+                       command=self.showHideCurve)
+        b0.pack(side='left')
+        b1 = tk.Button(frame, text='All', command=self.showHideAll)
+        b1.pack(side='left', padx='5')
+        b2 = tk.Button(frame, text='Invert', command=self.showHideInvert)
+        b2.pack(side='left')
+        CreateToolTip(b0, "Ctrl+H")
+
+    def cw_clipboard(self, frame):
+        tk.Label(frame, text='Copy to clipboard').pack(side='left')
+        b0 = tk.Button(frame, text='Curve', command=self.copyCurveToClipboard)
+        b0.pack(side='left', padx='5')
+        b1 = tk.Button(frame, text='Graph', command=self.copyGraphToClipboard)
+        b1.pack(side='left')
+        vals = ['raw', 'with properties', 'screen data', 'screen data, prop.']
+        self.varClipboardOpts = OptionMenuVar(frame, vals, default='options',
+                                              width=6)
+        self.varClipboardOpts.pack(side='left')
+        CreateToolTip(b0, 'Ctrl+Shift+C')
+
+    def cw_cast(self, frame):
+        def updateVarCast(curve, key):
+            # update GUI cast action: empy menu and refill it
+            self.varCastCurve['menu'].delete(0, 'end')
+            self.varCastCurve.set('')
+            castList = []
+            if isinstance(curve, Curve):
+                castList = curve.castCurveListGUI(onlyDifferent=False)
+                values = [cast[0] for cast in castList]
+                default = curve.classNameGUI()
+                for key in self.CASTCURVERENAMEGUI:
+                    values = [v.replace(key, self.CASTCURVERENAMEGUI[key]) for v in values]
+                    if default == key:
+                        default = self.CASTCURVERENAMEGUI[key]
+                self.varCastCurve.resetValues(values, default=default)
 
-        def toStr(a):
-            if isinstance(a, str):
-                return "'" + a.replace('\n', '\\n') + "'"
-            elif isinstance(a, Graph):
-                return 'graph'
-            elif isinstance(a, Curve):
-                return 'curve'
-            return str(a)
-
-        if self.varPrintCommands.get():
-            p = [toStr(a) for a in args]
-            p += [(a + "='" + toStr(kwargs[a])) for a in kwargs]
-            print('graph.' + method + '(' + ', '.join(p) + ')')
-        return out
-    def executeGraphCurveMethod(self, curve, method, *args, **kwargs):
-        out = getattr(self.back_graph.curve(curve), method)(*args, **kwargs)
-        if self.varPrintCommands.get():
-            p = [("'"+a.replace('\n','\\n')+"'" if isinstance(a, str) else str(a)) for a in args]
-            p +=[(a+"='"+kwargs[a].replace('\n','\\n')+"'" if isinstance(kwargs[a], str) else a+"="+str(kwargs[a])) for a in kwargs]
-            print('graph.curve('+str(curve)+').'+method+'('+', '.join(p)+')')
-        return out
+        self.app.observables['focusTree'].register(updateVarCast)
+        tk.Label(frame, text='Change Curve type').pack(side='left')
+        self.varCastCurve = OptionMenuVar(frame, [''], '')
+        self.varCastCurve.pack(side='left', padx='2')
+        tk.Button(frame, text='Save', command=self.castCurve).pack(side='left')
 
-    def quickMods(self):
-        """ update the quick modifs, located below the graph """
-        xlim = [stringToVariable(self.varQuickModsXlim0.get()),
-                stringToVariable(self.varQuickModsXlim1.get())]
-        ylim = [stringToVariable(self.varQuickModsYlim0.get()),
-                stringToVariable(self.varQuickModsYlim1.get())]
-        self.updateProperty(-1, 'xlabel', self.varQuickModsXlabel.get(), ifUpdate=False)
-        self.updateProperty(-1, 'ylabel', self.varQuickModsYlabel.get(), ifUpdate=False)
-        self.updateProperty(-1, 'xlim',   xlim, ifUpdate=False)
-        self.updateProperty(-1, 'ylim',   ylim, ifUpdate=False)
-        self.updateUI()
-
-
-    def editProperty(self):
-        """ Edit current curve property: catch values, send to dedicated function. """
-        curves = self.getActiveCurve()
-        key = self.varEditPropProp.get()
-        val = self.varEditPropVal.get()
-        self.updateProperty(curves, key, val)
-
-    def newPropertySet(self):
-        """ New property on current curve: catch values, send to dedicated function. """
-        curves = self.getActiveCurve()
-        key = self.varNewPropProp.get()
-        val = self.varNewPropVal.get()
-        if key == "['key', value]":
-            val = stringToVariable(val)
-            if not isinstance(val, (list, tuple)) or len(val) < 2:
-                print('ERROR GUI.newPropertySet. Input must be a list or a tuple with 2 elements (', val, type(val), ')')
-                return
-            key, val = val[0], val[1]
-        self.updateProperty(curves, key, val)
-        self.varNewPropVal.set('')
-        self.varNewPropProp.set(key)
+    def cw_quickAttr(self, frame):
+        def updateQA(curve, key):
+            if isinstance(curve, Curve):
+                self.varQALabel.set(varToStr(curve.attr('label')))
+                self.varQAColor.set(varToStr(curve.attr('color')))
 
-    def curveDelete(self):
+        self.app.observables['focusTree'].register(updateQA)
+        tk.Label(frame, text='Label').pack(side='left')
+        self.varQALabel = EntryVar(frame, '', width=15)
+        self.varQALabel.pack(side='left')
+        tk.Label(frame, text='Color').pack(side='left')
+        btn0 = tk.Button(frame, text='Pick', command=self.chooseColor)
+        btn0.pack(side='left')
+        self.varQAColor = EntryVar(frame, '', width=8)
+        self.varQAColor.pack(side='left')
+        btn1 = tk.Button(frame, text='Save', command=self.setQuickAttr)
+        btn1.pack(side='left')
+        self.varQALabel.bind('<Return>', lambda event: self.setQuickAttr())
+        self.varQAColor.bind('<Return>', lambda event: self.setQuickAttr())
+
+    def cw_labelReplace(self, frame):
+        tk.Label(frame, text='Replace in labels').pack(side='left')
+        self.varLabelOld = EntryVar(frame, 'old string', width=10)
+        self.varLabelOld.pack(side='left')
+        self.varLabelNew = EntryVar(frame, 'new string', width=10)
+        self.varLabelNew.pack(side='left')
+        btn = tk.Button(frame, text='Replace', command=self.replaceLabels)
+        btn.pack(side='left')
+        self.varLabelOld.bind('<Return>', lambda event: self.replaceLabels())
+        self.varLabelNew.bind('<Return>', lambda event: self.replaceLabels())
+
+    def shiftCurve(self, upDown, relative=True):
+        curves = self.app.getSelectedCurves(multiple=True)
+        curves.sort(reverse=(True if (upDown > 0) else False))
+        selected = []
+        graph = self.app.graph()
+        for curve in curves:
+            idx2 = upDown
+            if curve == 0:
+                idx2 = max(idx2, 0)
+            if curve == len(graph)-1 and relative:
+                idx2 = min(idx2, 0)
+            if relative:
+                self.app.callGraphMethod('swapCurves', curve, idx2,
+                                         relative=True)
+                selected.append(curve+idx2)
+            else:
+                self.app.callGraphMethod('moveCurveToIndex', curve, idx2)
+                selected.append(idx2)
+                # print('moveCurve', curve, idx2, upDown)
+                if idx2 < curve or (idx2 == curve and curve == 0):
+                    upDown += 1
+                elif idx2 > curve or (idx2 == curve and curve >= len(graph)-1):
+                    upDown -= 1
+        for i in range(len(selected)):
+            selected[i] = max(0, min(len(graph)-1, selected[i]))
+        if len(selected) > 0:
+            sel = [graph[c] for c in selected]
+            keys = [''] * len(sel)
+            self.app.getTabProperties(selectionCurvesKeys=(sel, keys),
+                                      focusCurvesKeys=([sel[0]], ['']))
+        print(self.app.getTabProperties())
+        self.app.updateUI()
+
+    def shiftCurveDown(self):
+        self.shiftCurve(1)
+
+    def shiftCurveUp(self):
+        self.shiftCurve(-1)
+
+    def shiftCurveTop(self):
+        self.shiftCurve(0, relative=False)
+
+    def shiftCurveBottom(self):
+        self.shiftCurve(len(self.app.graph())-1, relative=False)
+
+    def deleteCurve(self):
         """ Delete the currently selected curve. """
-        curves = list(self.getActiveCurve())
+        self.app.storeSelectedCurves()  # before modifs, to prepare updateUI
+        curves = list(self.app.getSelectedCurves(multiple=True))
         curves.sort(reverse=True)
         for curve in curves:
             if not is_number(curve):
                 break
                 # can happen if someone presses the delete button twice in arow
             elif curve > -1:
-                self.executeGraphMethod('deleteCurve', curve)
-                # self.back_graph.deleteCurve(curve)
-        self.previousSelectedCurve = [self.previousSelectedCurve[0]]
-        self.updateUI()
+                self.app.callGraphMethod('deleteCurve', curve)
+        self.app.updateUI()
 
-    def curveDeleteAllHidden(self):
-        """ deletes all the hidden curves. """
+    def deleteCurvesHidd(self):
+        """ Delete all the hidden curves. """
+        self.app.storeSelectedCurves()  # before modifs, to prepare updateUI
         toDel = []
-        for c in range(self.back_graph.length()):
-            if self.back_graph.curve(c).isHidden():
+        graph = self.app.graph()
+        for c in range(len(graph)):
+            if graph[c].isHidden():
                 toDel.append(c)
         toDel.sort(reverse=True)
         for c in toDel:
-            self.executeGraphMethod('deleteCurve', c)
-            # self.back_graph.deleteCurve(c)
-        self.updateUI()
+            self.app.callGraphMethod('deleteCurve', c)
+        self.app.updateUI()
 
-    def curveDuplicate(self):
+    def duplicateCurve(self):
         """ Duplicate the currently selected curve. """
-        curves = list(self.getActiveCurve())
+        self.app.storeSelectedCurves()  # before modifs, to prepare updateUI
+        curves = list(self.app.getSelectedCurves(multiple=True))
         curves.sort(reverse=True)
         selected = []
         for curve in curves:
             if not is_number(curve):
                 # can happen if someone presses the delete button twice in arow
                 break
             if curve > -1:
-                self.executeGraphMethod('duplicateCurve', curve)
-                # self.back_graph.duplicateCurve(curve)
+                self.app.callGraphMethod('duplicateCurve', curve)
                 selected = [s+1 for s in selected]
                 selected.append(curve)
-        self.previousSelectedCurve = selected
-        self.updateUI()
+        self.app.updateUI()
 
-    def graphReplaceLabels(self):
-        old = self.varReplaceLabelsOld.get()
-        new = self.varReplaceLabelsNew.get()
-        #self.back_graph.replaceLabels(old, new)
-        self.executeGraphMethod('replaceLabels', old, new)
-        self.varReplaceLabelsOld.set('')
-        self.varReplaceLabelsNew.set('')
-        self.updateUI()
-
-
-    def sendToClipboard(self, data):
-        self.master.clipboard_clear()
-        self.master.clipboard_append(data)
+    def showHideCurve(self):
+        self.app.storeSelectedCurves()
+        curves = self.app.getSelectedCurves(multiple=True)
+        for curve in curves:
+            if curve > -1 and curve < len(self.app.graph()):
+                self.app.callCurveMethod(curve, 'swapShowHide')
+        self.app.updateUI()
+
+    def showHideAll(self):
+        graph = self.app.graph()
+        if len(graph) > 0:
+            self.app.storeSelectedCurves()  # before modifs to prepare updateUI
+            new = '' if graph[0].isHidden() else 'none'
+            for curve in graph:
+                curve.update({'linestyle': new})
+            if self.app.ifPrintCommands():
+                print("for curve in graph:")
+                print("    curve.update({'linestyle': '"+new+"'})")
+            self.app.updateUI()
+
+    def showHideInvert(self):
+        self.app.storeSelectedCurves()  # before modifs, to prepare updateUI
+        for curve in self.app.graph():
+            curve.swapShowHide()
+        if self.app.ifPrintCommands():
+            print("for curve in graph:")
+            print("    curve.swapShowHide()")
+        self.app.updateUI()
 
-    def curveDataToClipboard(self):
-        curves = self.getActiveCurve()
+    def copyCurveToClipboard(self):
+        graph = self.app.graph()
+        curves = self.app.getSelectedCurves(multiple=True)
+        if len(curves) == 0:
+            return
         content = ''
-        opts = self.OptMenuToClipboardAttr.get()
-        ifAttrs = 'prop' in opts
-        ifTrans = 'screen' in opts
+        opts = self.varClipboardOpts.get()
+        ifAttrs = ('prop' in opts)
+        ifTrans = ('screen' in opts)
+        print('opts', opts, ifAttrs, ifTrans)
         if not ifAttrs:
-            labels = [self.back_graph.curve(c).getAttribute('label').replace('\n', '\\n') for c in curves]
+            labels = [varToStr(graph[c].attr('label')) for c in curves]
             content += ('\t' + '\t\t\t'.join(labels) + '\n')
         else:
             keys = []
             for c in curves:
-                for key in self.back_graph.curve(c).getAttributes():
+                for key in graph[c].getAttributes():
                     if key not in keys:
                         keys.append(key)
             keys.sort()
             for key in keys:
-                labels = [str(self.back_graph.curve(c).getAttribute(key)).replace('\n','\\n') for c in curves]
+                labels = [varToStr(graph[c].attr(key)) for c in curves]
                 content += (key+'\t' + '\t\t\t'.join(labels) + '\n')
-        data = [self.back_graph.getCurveData(c, ifAltered=ifTrans) for c in curves]
+        data = [graph.getCurveData(c, ifAltered=ifTrans) for c in curves]
         length = max([d.shape[1] for d in data])
-        for l in range(length):
+        for le in range(length):
             tmp = []
             for d in data:
-                if l < d.shape[1]:
-                    tmp.append('\t'.join([str(e) for e in d[:,l]]))
+                if le < d.shape[1]:
+                    tmp.append('\t'.join([str(e) for e in d[:, le]]))
                 else:
                     tmp.append('\t'.join([''] * d.shape[0]))
             content += '\t\t'.join(tmp) + '\n'
-        self.sendToClipboard(content)
+        self.app.setClipboard(content)
 
-    def graphDataToClipboard(self):
-        opts = self.OptMenuToClipboardAttr.get()
-        ifAttrs = 'prop' in opts
-        ifTrans = 'screen' in opts
-        data = self.back_graph.export(ifClipboardExport=True, ifOnlyLabels=(not ifAttrs), saveAltered=ifTrans)
-        self.sendToClipboard(data)
+    def copyGraphToClipboard(self):
+        opts = self.varClipboardOpts.get()
+        ifAttrs = ('prop' in opts)
+        ifTrans = ('screen' in opts)
+        graph = self.app.graph()
+        data = graph.export(ifClipboardExport=True, ifOnlyLabels=(not ifAttrs),
+                            saveAltered=ifTrans)
+        self.app.setClipboard(data)
 
-    def clipboardToGraphMerge(self):
-        tmp = self.master.clipboard_get()
-        graph = Graph(tmp, {'isfilecontent': True})
-        print('Import data from clipboard ('+str(graph.length())+' Curves found).')
-        self.back_graph.merge(graph)
-        self.updateUI()
-    def clipboardToGraphOpen(self):
-        tmp = self.master.clipboard_get()
-        self.back_graph = Graph(tmp, {'isfilecontent': True}, **self.newGraphKwargs)
-        print('Import data from clipboard ('+str(self.back_graph.length())+' Curves found).')
-        self.updateUI()
-
-    def newCurveMerge(self):
-        curve = Curve([[0],[np.nan]], {})
-        self.back_graph.append(curve)
-        self.updateUI()
+    def castCurve(self):
+        graph = self.app.graph()
+        curves = self.app.getSelectedCurves(multiple=True)
+        newType = self.varCastCurve.get()
+        for key in self.CASTCURVERENAMEGUI:
+            if newType == self.CASTCURVERENAMEGUI[key]:
+                newType = key
+        selected = []
+        for curve in curves:
+            if curve > -1 and curve < len(graph):
+                test = self.app.callGraphMethod('castCurve', newType, curve)
+                selected.append(curve)
+                if not test:
+                    print('castCurve impossible.')
+            else:
+                print('castCurve impossible (', newType, curve, ')')
+        if len(selected) > 0:
+            sel = [graph[c] for c in selected]
+            keys = [''] * len(sel)
+            self.app.getTabProperties(selectionCurvesKeys=(sel, keys),
+                                      focusCurvesKeys=([sel[0]], ['']))
+        self.app.updateUI()
 
-    def setAutoScreenDPI(self):
-        wh = [self.canvas.get_tk_widget().winfo_width(),
-              self.canvas.get_tk_widget().winfo_height()]
-        figsize = self.back_graph.getAttribute('figsize', Graph.FIGSIZE_DEFAULT)
-        dpimax = min([wh[i] / figsize[i] for i in range(2)])
-        dpi = float(self.varScreenDpi.get())
-        new = None
-        if dpi > dpimax * 1.02:  # shall reduce screen dpi
-            new = np.max([10, np.round(2*(dpimax-3), -1)/2])
-        elif dpi < dpimax * 0.8 and dpi < 100:  # maybe can zoom in
-            new = np.min([100, np.round(2*(dpimax-3), -1)/2])
-        if new is not None and new != dpi:
-            self.varScreenDpi.set(new)
-            self.setScreenDpi()
-            self.blinkWidget(self.fieldScreenDPI, 5)
-
-    def setLimitsSubplotsToCurrent(self):
-        xlim = self.Graph_ax.get_xlim()
-        ylim = self.Graph_ax.get_ylim()
-        a = ['left', 'bottom', 'right', 'top', 'wspace', 'hspace']
-        subplots = [getattr(self.Graph_fig.subplotpars, key) for key in a]
-        self.executeGraphMethod('update', {'xlim': xlim, 'ylim': ylim,
-                                           'subplots_adjust': subplots})
-        self.updateUI()
+    def chooseColor(self):
+        from tkinter.colorchooser import askcolor
+        curves = self.app.getSelectedCurves(multiple=False)
+        if curves[0] != -1:
+            from matplotlib.colors import hex2color, rgb2hex
+            try:
+                colorcurrent = rgb2hex(strToVar(self.varQAColor.get()))
+            except Exception:
+                colorcurrent = None
+            ans = askcolor(color=colorcurrent)
+            if ans[0] is not None:
+                self.varQAColor.set(listToString([np.round(a, 3) for a in hex2color(ans[1])]))  # [np.round(val/256,3) for val in ans[0]]
+
+    def setQuickAttr(self):
+        self.app.storeSelectedCurves()
+        curves = self.app.getSelectedCurves(multiple=True)
+        for c in curves:
+            arg = {'label': strToVar(self.varQALabel.get()),
+                   'color': strToVar(self.varQAColor.get())}
+            self.app.callCurveMethod(c, 'update', arg)
+        self.app.updateUI()
+
+    def replaceLabels(self):
+        self.app.storeSelectedCurves()  # before modifs, to prepare updateUI
+        old = self.varLabelOld.get()
+        new = self.varLabelNew.get()
+        self.app.callGraphMethod('replaceLabels', old, new)
+        self.varLabelOld.set('')
+        self.varLabelNew.set('')
+        self.app.updateUI()
+
+
+class GUIFramePropertyEditor:
+    """
+    Handles the panel Property edit
+    Contains a Frame, to be embedded in a wider application (.frame.pack())
+    Some methods will call methods of application
+    """
+
+    VARVALUEWIDTH = 30
+
+    def __init__(self, master, application, **kwargs):
+        self.frame = tk.Frame(master, **kwargs)
+        self.app = application
+        self.createWidgets(self.frame)
+
+    def updateUI(self):
+        pass
+
+    def createWidgets(self, frame):
+        fr = FrameTitleContentHide(frame, self.cw_title, self.cw_content)
+        fr.pack(side='top', fill=tk.X, anchor='w')
 
+    def cw_title(self, frame):
+        lbl = tk.Label(frame, text='Property editor',
+                       font=self.app.fonts['bold'])
+        lbl.pack(side='top', anchor='w')
+
+    def cw_content(self, frame):
+        fr = tk.Frame(frame)
+        fr.pack(side='top', anchor='w', fill=tk.X, padx=5)
+        self.cw_contentEdit(fr)
+        tk.Label(frame, text='\n').pack(side='left', anchor='w', padx=5)
+        # self.NewPropExample = tk.StringVar()
+        # self.NewPropExample.set('')
+        self.varExample = LabelVar(frame, '', justify='left')
+        self.varExample.pack(side='left', anchor='w')
 
-    def folderSaveGet(self):
-        folderSave = self.varLabelFolder.get()
-        return folderSave if folderSave != '' else os.getcwd()
-
-    def saveData(self):
-        if self.back_graph.getAttribute('meastype') not in ['', FILEIO_GRAPHTYPE_GRAPH]:
-            print ('ERROR when saving data: are you sure you are not overwriting a graph file?')
-            print ('Click on Save As... to save the current graph (or delete attribute "meastype").')
-            self.saveDataAs(filesave='')
+    def cw_contentEdit(self, frame):
+        tk.Label(frame, text='Property:').pack(side='left')
+        self.varKey = OptionMenuVar(frame, [], '')
+        self.varKey.pack(side='left')
+        self.varKey.var.trace('w', self.selectKey)
+        self.app.observables['focusTree'].register(self.imposeKey)
+        self.varValue = ComboboxVar(frame, [], '', width=self.VARVALUEWIDTH)
+        self.varValue.pack(side='left')
+        self.varValue.bind('<Return>', lambda event: self.saveKeyValue())
+
+        btn = tk.Button(frame, text='Save', command=self.saveKeyValue)
+        btn.pack(side='right')
+
+    def imposeKey(self, curve, key):
+        """ triggers by observable when user selects a property in the Tree """
+        # print('imposekey curve', curve, 'key', key)
+        if curve == -1:
+            keyList = Graph.graphInfoKeys
         else:
-            self.saveDataAs(self.back_file)
+            keyList = Graph.dataInfoKeysGraph
+        self.varKey.resetValues(keyList)
+        if key != '':
+            self.varKey.set(key, force=True)
+            # set() triggers .selectKey() that updates varExamples and varValue
+        else:
+            # keep same key, try to refresh in case user selected another curve
+            self.varKey.set(self.varKey.get(), force=True)
 
-    def saveDataAs(self, filesave=''):
-        defext = ''
-        if filesave == '':
-            folderSave = self.folderSaveGet()
-            defaultextension = self.back_graph.config('save_imgformat', '.png')
-            defext = defaultextension[0] if isinstance(defaultextension, list) else defaultextension
-            filesave = tk.filedialog.asksaveasfilename(defaultextension=defext, initialdir=folderSave)
-        if filesave is None or filesave == '' : # asksaveasfile return `None` if dialog closed with "cancel".
-            return
-        filesave, fileext = os.path.splitext(filesave)
-        fileext = fileext.lower()
-        forbiddenExt = ['py', 'txt', '.py', '.txt']
-        for ext in forbiddenExt:
-            fileext = fileext.replace(ext, '')
-        if fileext == defext:
-            fileext = defaultextension
-        saveAltered = self.ValCheckbuttonSave.get()
-        ifCompact = not self.ValCheckbuttonSaveCompactnot.get()
-        if self.back_graph.getAttribute('meastype') == '':
-            self.back_graph.update({'meastype': FILEIO_GRAPHTYPE_GRAPH})
+    def selectKey(self, *args, **kwargs):
+        """ User selects a item on the drop-down menu """
+        # print('selectKey args', args, 'kwargs', kwargs)
+        key = self.varKey.get()
+        curves = self.app.getSelectedCurves(multiple=False)
+        if len(curves) == 0:
+            curve = -1
+        else:
+            curve = curves[0]
+        if curve == -1:
+            keyList = Graph.graphInfoKeys
+            example = Graph.graphInfoKeysExample
+            exaList = Graph.graphInfoKeysExalist
+            currentVal = self.app.graph().attr(key)
+        else:
+            keyList = Graph.dataInfoKeysGraph
+            example = Graph.dataInfoKeysGraphExample
+            exaList = Graph.dataInfoKeysGraphExalist
+            currentVal = self.app.graph()[curve].attr(key)
         try:
-            fig, ax = self.back_graph.plot(filesave=filesave, imgFormat=fileext,
-                                           ifExport=False, figAx=[self.Graph_fig, None])
-            while isinstance(ax, (list, np.ndarray)) and len(ax) > 0:
-                ax = ax[0]
-            self.Graph_fig, self.Graph_ax = fig, ax
-        except Exception as e:
-            print('ERROR: Exception during plotting of the Graph.')
-            print(type(e), e)
-        if fileext in ['.xml']:
-            filesave += fileext
-        self.back_graph.export(filesave=filesave, saveAltered=saveAltered, ifCompact=ifCompact)
-        if self.varPrintCommands.get():
-            print("graph.plot(filesave='"+filesave+"', imgFormat='"+fileext+"', ifExport=False))")
-            print("graph.export(filesave='"+filesave+"', saveAltered='"+str(saveAltered)+"', ifCompact='"+str(ifCompact)+"')")
-        self.updateUI()
+            # set example, and populate Combobox values field
+            i = keyList.index(key)
+            self.varValue['values'] = exaList[i]
+            self.varExample.set(example[i])
+        except ValueError:
+            self.varValue['values'] = []
+            self.varExample.set('')
+        # set values, cosmetics
+        self.varValue.set(varToStr(currentVal))
+        state = 'disabled' if key.startswith('==') else 'normal'
+        self.varValue.configure(state=state)
+        width = self.VARVALUEWIDTH
+        if len(key) > 20:  # reduce widget's width to try prevent window resize
+            width = max(int(self.VARVALUEWIDTH/2),
+                        int(self.VARVALUEWIDTH-(len(key)-20)*2/3))
+        self.varValue.configure(width=width)
 
-    def saveTemplate(self):
-        folder = self.folderSaveGet()
-        f = tk.filedialog.asksaveasfilename(defaultextension='.txt', initialdir=folder)
-        if f is None or f == '' :  # asksaveasfile return `None` if dialog closed with "cancel".
+    def saveKeyValue(self):
+        """
+        New property on current curve: catch values, send to dedicated function
+        Handles interface. Calls updateProperty to act on graph
+        """
+        curves = self.app.getSelectedCurves(multiple=True)
+        key = self.varKey.get()
+        val = self.varValue.get()  # here .get(), strToVar done later
+        if key == "['key', value]":
+            val = strToVar(val)
+            if not isinstance(val, (list, tuple)) or len(val) < 2:
+                print('ERROR GUI.GUIFramePropertyEditor.saveKeyValue. Input',
+                      'must be a list or a tuple with 2 elements (', val,
+                      type(val), ')')
+                return
+            key, val = val[0], val[1]
+        self._updateKey(curves, key, val)  # triggers updateUI
+        # Tree may be still stuck on another key. Triggers change of varValue
+        # and varExample
+        self.varKey.set(key, force=True)
+
+    def _updateKey(self, curve, key, val, ifUpdate=True, varType='auto'):
+        """
+        Input was filtered by setPropValue()
+        perform curve(curve).update({key: strToVar(val)})
+        curve -1: update() on graph
+        ifUpdate: by default update the GUI- if False, does not. Assumes the
+            update will be performed only once, later
+        varType: changes type of val into varType. Otherwise try best guess.
+        """
+        if key == 'Property' or key.startswith('--') or key.startswith('=='):
             return
-        f, fileext = os.path.splitext(f)
-        fileext = fileext.replace('py', '')
-        self.back_graph.export(filesave=f, ifTemplate=True)
-
-    def imageToClipboard(self):
-        return imageToClipboard(self.back_graph)
-
-    def _quit(self):
-        plt.close(self.Graph_fig) #fig.canvas.get_tk_widget().focus_force()
-        self.master.quit()
-        self.master.destroy()
-
-
-    def file_loadTemplate(self):
-        folder = ''
-        if self.back_file != '':
-            folder = os.path.dirname(os.path.abspath(self.back_file))
-        file = tk.filedialog.askopenfilename(initialdir=folder)
-        if file != '':
-            print('Open template file:', file)
-            template = Graph(file, complement={'label': ''})
-            alsoCurves = self.varRTplCurves.get()
-            self.back_graph.applyTemplate(template, alsoCurves=alsoCurves)
-        self.updateUI()
-
-
-    def file_open_internal(self, file):
-        print('Open file:', file.replace('/', '\\'))
-        self.back_file = file
-        self.varLabelFile.set(file)
-        self.back_graph = Graph(file, **self.newGraphKwargs)
-        self.setAutoScreenDPI()
-        folder = os.path.dirname(file)
-        self.varLabelFolder.set(folder)
-        self.alterListGUI = self.back_graph.alterListGUI()
-        [idx, display, alter, typePlot] = self.plotChangeView_identify()
-        self.OMAlter.set(idx)
-        self.callback_dataPickerCurve() # update help data picker Curve specifics
-        if self.varPrintCommands.get():
-            print("graph = Graph('"+file+"')")
-
-
-    def file_open(self):
-        folder = ''
-        if self.back_file != '':
-            folder = os.path.dirname(os.path.abspath(self.back_file))
-        file = tk.filedialog.askopenfilename(initialdir=folder)
-        if file != '':
-            self.file_open_internal(file)
-        self.updateUI()
-
-    def file_merge(self):
-        folder = ''
-        if self.back_file != '':
-            folder = os.path.dirname(os.path.abspath(self.back_file))
-        file = tk.filedialog.askopenfilename(initialdir=folder)
-        if file is not None or file != '':
-            print('Merge with file:', file)
-            self.varLabelFile.set(file)
-            self.back_graph.merge(Graph(file))
-            # change default save folder only if was empty
-            if self.varLabelFolder.get() == '':
-                folder = os.path.dirname(file)
-                self.varLabelFolder.set(folder)
-            if self.varPrintCommands.get():
-                print("graph.merge(Graph('"+file+"'))")
-        self.updateUI()
-
-    def ask_folder(self, initialdir='.'):
-        folder = tk.filedialog.askdirectory(initialdir=initialdir)
-        print('Selected folder', folder)
-        self.back_folder = folder
-        self.varLabelFolder.set(folder)
+        self.app.storeSelectedCurves()  # before modifs, to prepare updateUI
+        # print ('Property edition: curve',curve,', key', key,', value', val,
+        #        '(',type(val),')')
+        # possibly force variable type
+        if varType in [str, int, float, list, dict]:
+            val = varType(val)
+        else:
+            val = strToVar(val)
+        # curve identification
+        if not isinstance(curve, list):
+            curve = [curve]
+        for c_ in curve:
+            try:
+                c = int(c_)
+            except Exception:
+                print('Cannot edit property: curve', c_, ', key', key,
+                      ', value', val)
+                return
+            if c < 0:
+                self.app.callGraphMethod('update', {key: val})
+            else:
+                self.app.callCurveMethod(c, 'update', {key: val})
+        if ifUpdate:
+            self.app.updateUI()
 
 
-    def listFilesinFolder(self, folder):
-        subfolders = self.varOpenFolderSubfolders.get()
-        nMax = 1000
-        filename = []
-        if subfolders:
-            for root, subdirs, files in os.walk(self.back_folder):
-                for file in files :
-                    fileName, fileExt = os.path.splitext(file)
-                    if len(filename) < nMax:
-                        filename.append(str(os.path.join(root, file)))
-        else:
-            for file in os.listdir(self.back_folder):
-                fileName, fileExt = os.path.splitext(file)
-                if (os.path.isfile(os.path.join(self.back_folder, file))
-                   and len(filename) < nMax):
-                    filename.append(str(os.path.join(self.back_folder, file)))
-        return filename
-
-    def folder_plot_combined(self):
-        self.ask_folder(self.back_folder)
-        if self.back_folder != '':
-            print('...processing folder...')
-            filenames = self.listFilesinFolder(self.back_folder)
-            self.back_graph = Graph(filenames, **self.newGraphKwargs)
-        self.updateUI()
-
-    def folder_plot_all(self):
-        self.ask_folder(self.back_folder)
-        if self.back_folder != '':
-            print('...processing folder...')
-            filenames = self.listFilesinFolder(self.back_folder)
-            for file in filenames:
-                self.back_graph = Graph(file, **self.newGraphKwargs)
-                self.back_graph.plot(ifExport=True, ifSave=True)
-        self.updateUI()
+class GUIFrameTree:
+    """
+    Handles the panel box with the Tree displaying all properties
+    Contains a Frame, to be embedded in a wider application (.frame.pack())
+    Some methods will call methods of application
+    """
+
+    def __init__(self, master, application, **kwargs):
+        self.frame = tk.Frame(master, **kwargs)
+        self.app = application
+        self.createWidgets(self.frame)
+        # self.prevTreeSelect = [-1]  # to be used upon refresh
 
-    def folder_JV_combined(self):
-        from grapa.scripts.script_processJV import processJVfolder
-        self.ask_folder(self.back_folder)
-        if self.back_folder != '':
-            print('...processing folder...')
-            fitDiodeWeight = stringToVariable(self.FolderFitDiodeWeight.get())
-            self.back_graph = processJVfolder(self.back_folder, ylim=(-np.inf, np.inf), groupCell=True, fitDiodeWeight=fitDiodeWeight, newGraphKwargs=self.newGraphKwargs) # for y axis adapted to data
-        self.updateUI()
+    def updateUI(self):
+        """ Update content of Treeview """
+        graph = self.app.graph()
+        select = {'toFocus': [], 'toSelect': []}
+        try:
+            props = self.app.getTabProperties()
+            select['focus'] = props['focusCurvesKeys']
+            select['selec'] = props['selectionCurvesKeys']
+        except KeyError:  # expected at initialisation
+            select['focus'] = ([], [])
+            select['selec'] = ([], [])
+        # print('updateUI prepare selection', select)
+        # clear displayed content
+        self.Tree.delete(*self.Tree.get_children())
+        # tree: update graphinfo
+        attr = graph.graphInfo
+        idx0 = self.Tree.insert('', 'end', text='Graph', tag='-1', values=(''))
+        self._updateUI_checkSelect(idx0, -1, '', select)
+        self._updateUI_addTreeBranch(idx0, attr, -1, select)
+        # tree: update headers & sampleinfo
+        attr = dict(graph.headers)
+        attr.update(graph.sampleInfo)
+        if len(attr) > 0:
+            idx = self.Tree.insert('', 'end', text='Misc.', tag='-1',
+                                   values=(''))
+            self._updateUI_addTreeBranch(idx, attr, -1, select)
+        # tree & list of curves
+        orderLbl = ['label', 'sample', 'filename']
+        for i in range(len(graph)):
+            curve = graph[i]
+            # decide for label
+            lbl = '(no label)'
+            for test in orderLbl:
+                tmp = curve.attr(test)
+                if tmp != '':
+                    lbl = varToStr(tmp)
+                    break
+            # tree
+            tx = 'Curve '+str(i)+' '+lbl
+            idx = self.Tree.insert('', 'end', tag=str(i), values=(''), text=tx)
+            self._updateUI_checkSelect(idx, curve, '', select)
+            color = 'grey' if curve.isHidden() else 'black'
+            self.Tree.tag_configure(str(i), foreground=color)
+            # attributes
+            attr = curve.getAttributes()
+            self._updateUI_addTreeBranch(idx, attr, curve, select)
+        # set focus and selection to previously selected element
+        if len(select['toSelect']) > 0:
+            # print('UpdateUI selection_set', tuple(select['toSelect']))
+            self.Tree.selection_set(tuple(select['toSelect']))
+            for iid in select['toSelect']:
+                self.Tree.see(iid)
+        if len(select['toFocus']) > 0:
+            # print('UpdateUI focus', select['toFocus'][0])
+            self.Tree.focus(select['toFocus'][0])
+            self.Tree.see(select['toFocus'][0])
+        self.forgetSelectedCurves()
+
+    def _updateUI_checkSelect(self, id, curve, key, select):
+        for i in range(len(select['focus'][0])):
+            if select['focus'][0][i] == curve and select['focus'][1][i] == key:
+                select['toFocus'].append(id)
+        for i in range(len(select['selec'][0])):
+            if select['selec'][0][i] == curve and select['selec'][1][i] == key:
+                select['toSelect'].append(id)
 
-    def folder_JV_all(self):
-        from grapa.scripts.script_processJV import processJVfolder
-        self.ask_folder(self.back_folder)
-        if self.back_folder != '':
-            print('...processing folder...')
-            fitDiodeWeight = stringToVariable(self.FolderFitDiodeWeight.get())
-            self.back_graph = processJVfolder(self.back_folder, ylim=(-np.inf, np.inf), groupCell=False, fitDiodeWeight=fitDiodeWeight, newGraphKwargs=self.newGraphKwargs) # for y axis adapted to data
-        self.updateUI()
+    def _updateUI_addTreeBranch(self, idx, attr, curve, select):
+        # select: TODO
+        keyList = []
+        for key in attr:
+            keyList.append(key)
+        keyList.sort()
+        for key in keyList:
+            val = varToStr(attr[key])
+            # val = varToStr(val)  # echap a second time to go to Treeview
+            try:
+                id = self.Tree.insert(idx, 'end', text=key, values=(val,),
+                                      tag=key)
+                self._updateUI_checkSelect(id, curve, key, select)
+            except Exception as e:
+                print('Exception _updateUI_addTreeBranch key', key, 'values:')
+                print('   ', type(attr[key]), attr[key])
+                print('   ', type(varToStr(attr[key])), varToStr(attr[key]))
+                print('   ', type(val), val)
+                # for v in val:
+                #     print('   ', v)
+                print(type(e), e)
 
-    def folder_JV_sampleMaps(self):
-        from grapa.scripts.script_processJV import processSampleCellsMap
-        folder = ''
-        if self.back_file != '':
-            folder = os.path.dirname(os.path.abspath(self.back_file))
-        file = tk.filedialog.askopenfilename(initialdir=folder)
-        print('...creating sample maps...')
-        if file is not None and file != '':
-            filelist = processSampleCellsMap(file, newGraphKwargs=self.newGraphKwargs)
-            if len(filelist) > 0:
-                self.file_open_internal(filelist[-1])
-        self.updateUI()
+    def createWidgets(self, frame):
+        fr = FrameTitleContentHide(frame, self.cw_title, self.cw_content)
+        fr.pack(side='top', fill=tk.X, anchor='w')
 
-    def file_JscVoc(self):
-        from grapa.scripts.script_processJscVoc import script_processJscVoc
-        folder = ''
-        if self.back_file != '':
-            folder = os.path.dirname(os.path.abspath(self.back_file))
-        file = tk.filedialog.askopenfilename(initialdir=folder)
-        ROIJsclim = stringToVariable(self.varProcessJscVocJscROI.get())
-        self.back_graph = script_processJscVoc(file, newGraphKwargs=self.newGraphKwargs,
-                                               ROIJsclim=ROIJsclim)
-        self.updateUI()
+    def cw_title(self, frame):
+        lbl = tk.Label(frame, text='List of properties',
+                       font=self.app.fonts['bold'])
+        lbl.pack(side='top', anchor='w')
 
-    def folder_CV(self):
-        from grapa.scripts.script_processCVCf import script_processCV
-        ROIfit = stringToVariable(self.varProcessCVROI.get())
-        self.ask_folder(self.back_folder)
-        if self.back_folder != '':
-            self.back_graph = script_processCV(self.back_folder, ROIfit=ROIfit, newGraphKwargs=self.newGraphKwargs)
-        self.updateUI()
+    def cw_content(self, frame):
+        # START OF FIX: because of change in tk. Baseically added the following
+        def fixed_map(option):
+            # Returns the style map for 'option' with any styles starting with
+            # ("!disabled", "!selected", ...) filtered out
+            # style.map() returns an empty list for missing options, so this
+            # should be future-safe
+            return [elm for elm in style.map("Treeview", query_opt=option)
+                    if elm[:2] != ("!disabled", "!selected")]
+        style = ttk.Style()
+        style.map("Treeview", foreground=fixed_map("foreground"),
+                  background=fixed_map("background"))
+        # END OF FIX
+        self.Tree = ttk.Treeview(frame, columns=('#1'))
+        self.Tree.pack(side='left', anchor='n')
+        self.Treeysb = ttk.Scrollbar(frame, orient='vertical',
+                                     command=self.Tree.yview)
+        self.Treeysb.pack(side='right', anchor='n', fill=tk.Y)
+        self.Tree.configure(yscroll=self.Treeysb.set)
+        self.Tree.column('#0', width=170)
+        self.Tree.heading('#0', text='Name')
+        self.Tree.column('#1', width=290)
+        self.Tree.heading('#1', text='Value')
+        self.Tree.bind('<<TreeviewSelect>>', self._selectTreeItem)
 
-    def folder_Cf(self):
-        from grapa.scripts.script_processCVCf import script_processCf
-        self.ask_folder(self.back_folder)
-        if self.back_folder != '':
-            self.back_graph = script_processCf(self.back_folder, newGraphKwargs=self.newGraphKwargs)
-        self.updateUI()
+    def getTreeActiveCurve(self, multiple=True):
+        """
+        Return 2 lists with following structure:
+        [idx0, idx1, ...], [key0, key1, ...]
+        Each element corresponds to a selected line in the Treeview.
+        idx: curve index, -1 for header
+        key: selected attribute
+        multiple=False: only info related to the line returned by .focus()
+            is returned, not to the .selection()
+        """
+        interest = self.Tree.focus()
+        if multiple:
+            interest = self.Tree.selection()
+        idxs, keys = self._getTreeItemIdKey(interest)
+        return idxs, keys
+
+    def _selectTreeItem(self, a):
+        idxs, keys = self.getTreeActiveCurve(multiple=False)
+        #  self.prevTreeSelect = sorted(list(set(idxs)))  # remove duplicates
+        # update observable related to selected curve
+        if len(idxs) > 0:
+            # provides - Curve if possible, index otherwise
+            graph = self.app.graph()
+            curve = idxs[0]
+            if curve > -1 and curve < len(graph):
+                curve = graph[curve]
+            # print('observable focustree', curve, keys[0])
+            self.app.observables['focusTree'].update_observers(curve, keys[0])
 
-    def folder_JV_boxplots(self):
-        from grapa.scripts.script_JVSummaryToBoxPlots import JVSummaryToBoxPlots
-        self.ask_folder(self.back_folder)
-        print ('...creating boxplots...')
-        if self.back_folder != '':
-            tmp = JVSummaryToBoxPlots(folder=self.back_folder, exportPrefix='boxplots_', replace=[], silent=True, newGraphKwargs=self.newGraphKwargs)
-            self.back_graph = tmp
-        self.updateUI()
-
-    def appendNewEmptyCurve(self):
-        self.back_graph.append('empty')
-        self.updateUI()
-
-    def blinkWidget(self, field, niter,
-                    delay=500, property_='background', values=['white', 'red']):
-        field.config(**{property_: values[niter % len(values)]})
-        if niter > 0:
-            kwargs = {'property_': property_, 'values': values, 'delay': delay}
-            func = lambda: self.blinkWidget(field, niter-1, **kwargs)
-            self.master.after(delay, func)
-
-
-    def listToString(self, val):
-        return '[' + ', '.join([str(element) if not isinstance(element, str) else '\''+element+'\'' for element in val]) + ']'
-
-
-
-
-def printLastRelease():
-    file = 'versionNotes.txt'
-    file = os.path.join(os.path.dirname(os.path.realpath(__file__)), file)
-    try:
-        f = open(file, 'r')
-    except Exception:
-        # print('Exception file open', e)
-        return
-    out = ''
-    line = ''
-    flag = True
-    while flag:
-        last = line
-        line = f.readline()
-        if "Release" in line:
-            out = last + line
-            flag = False
-    if line == '':
-        print('Not found string "Release"')
-        return # not found release
-    date = line[len('Release'):].replace(' ', '')
-    if date[0] == 'd':
-        date = date[1:]
-    from dateutil import parser
-    from datetime import datetime
-    try:
-        daysSinceLast = datetime.now() - parser.parse(date)
-    except ValueError as e:
-        print('Exception in PrintLastRelease, date', date, type(e), e)
-    line = ''
-    if daysSinceLast.days < 5:
-        flag = True
-        while flag:
-            last = line
-            line = f.readline()
-            if "Release" in line or 'Version' in line:
-                flag = False
-            if flag and last.strip() != '':
-                out += last
-        print(out)
-    f.close()
-    return
-
-
-def buildUI():
-    root = tk.Tk()
-    try:
-        root.iconbitmap('datareading.ico')
-    except Exception:
-        pass
-    app = Application(master=root)
-    from grapa import __version__
-    app.master.title('Grapa software v'+__version__)
-    # starts runnning programm
-    with stdout_redirect(app.Console):
-        # retrieve content of last release
-        try:
-            printLastRelease()
-        except Exception:
+    def _getTreeItemIdKey(self, item=None):
+        # handle several selected items
+        if item is None:
+            item = self.Tree.focus()
+        if isinstance(item, tuple):
+            idxs, keys = [], []
+            for it in item:
+                idx, key = self._getTreeItemIdKey(it)
+                if len(idx) > 0:
+                    idxs.append(idx[0])
+                    keys.append(key[0])
+            # print('_getTreeItemIdKey multiple', idxs, keys)
+            return idxs, keys
+        # handle single element
+        if len(item) == 0:
+            return [], []
+        selected = self.Tree.item(item)
+        parentId = self.Tree.parent(item)
+        if parentId == '':  # selected a main line (with no parentId)-> no attr
+            idx = selected['tags']
+            key = ''
+        else:  # selected a line presenting an attribute
+            parent = self.Tree.item(parentId)
+            idx = parent['tags']
+            key = selected['text']
+            if not parent['open']:
+                # print('wont select that one, parent not open', parentId)
+                return [], []
+        if isinstance(key, list):
+            key = key[0]
+        if isinstance(idx, list):
+            idx = idx[0]
+        return [idx], [key]
+
+    def storeSelectedCurves(self):
+        """ Store selected Curves and attributes to restore upon updateUI """
+        # store Curve instead of indices, because indices can change
+        graph = self.app.graph()
+        idxs, keys = self.getTreeActiveCurve(multiple=False)
+        for i in range(len(idxs)):
+            # print('storeSelectedCurves false', idxs[i], '.', keys[i], '.')
+            if idxs[i] >= 0 and idxs[i] < len(graph):
+                idxs[i] = graph[idxs[i]]
+        self.app.getTabProperties(focusCurvesKeys=(idxs, keys))
+        idxs, keys = self.getTreeActiveCurve(multiple=True)
+        for i in range(len(idxs)):
+            # print('storeSelectedCurves true', idxs[i], '.', keys[i], '.')
+            if idxs[i] >= 0 and idxs[i] < len(graph):
+                idxs[i] = graph[idxs[i]]
+        self.app.getTabProperties(selectionCurvesKeys=(idxs, keys))
+
+    def forgetSelectedCurves(self):
+        self.app.getTabProperties(focusCurvesKeys=([], []),
+                                  selectionCurvesKeys=([], []))
+
+
+class GUIFrameActionsCurves():
+    """
+    Handles part with actions specific to curves
+    Contains a Frame, to be embedded in a wider application (.frame.pack())
+    Some methods will call methods of application
+    """
+
+    def __init__(self, master, application, **kwargs):
+        self.frame = tk.Frame(master, **kwargs)
+        self.app = application
+        self.createWidgets(self.frame)
+        self.previous = {'curve': None, 'type': None, 'le': None}
+        self.app.observables['focusTree'].register(self.cw_frameAction)
+
+    def updateUI(self):
+        curve = self.app.getSelectedCurves(multiple=False)
+        if len(curve) > 0 and curve[0] > -1:
+            curve = self.app.graph()[curve[0]]
+        self.cw_frameAction(curve, force=True)
+
+    def createWidgets(self, frame):
+        # title frame
+        fr = tk.Frame(frame)
+        fr.pack(side='top', anchor='w', fill=tk.X)
+        lbl = tk.Label(fr, text='Actions specific to selected Curve',
+                       font=self.app.fonts['bold'])
+        lbl.pack(side='left', anchor='center')
+        hline = FrameTitleContentHide.frameHline(fr)
+        hline.pack(side='left', anchor='center', fill=tk.X, expand=1, padx=5)
+        # content
+        self.listCallinfos = []
+        self.listWidgets = []
+        self.frameAction = tk.Frame(frame)
+        self.frameAction.pack(side='top', fill=tk.X, padx=5)
+        # argsFunc=[-1])
+
+    def cw_frameAction(self, curve, *args, force=False):
+        # identify index of active curve
+        graph = self.app.graph()
+        graph_i = None
+        for c in range(len(graph)):
+            if graph[c] == curve:
+                graph_i = c
+                break
+        # retrieve list of actions
+        funcList = []
+        if graph_i is not None:
+            funcList = curve.funcListGUI(graph=graph, graph_i=graph_i)
+        # args: specific attribute selected. Useless here
+        if (not force and curve == self.previous['curve']
+                and type(curve) == self.previous['type']
+                and len(funcList) == self.previous['le']):
+            # no need to change anything, do not update anything
+            # print('GUIFrameActionsCurves: can think to not update actions')
             pass
-        # start execution
-        app.mainloop()
+        self.previous = {'curve': curve, 'type': type(curve),
+                         'le': len(funcList)}
+        # destroy all existing widgets
+        for line in self.listWidgets:  # widgets
+            for widget in line:
+                widget.destroy()
+        self.listCallinfos = []
+        self.listWidgets = []
+        # create new widgets
+        for j in range(len(funcList)):
+            line = funcList[j]
+            if not isinstance(line, FuncGUI):
+                line = FuncGUI(None, None).initLegacy(line)
+            # create widgets
+            callinfo, widgets = line.create_widgets(self.frameAction,
+                                                    self.callAction, j)
+            self.listCallinfos.append(callinfo)
+            self.listWidgets.append(widgets)
+        if len(self.listCallinfos) == 0:
+            widget = tk.Label(self.frameAction, text='No possible action.')
+            widget.pack(side='top', anchor='w')
+            self.listWidgets.append([widget])
+
+    def callAction(self, j):
+        """ when user validates his input for curve action """
+        self.app.storeSelectedCurves()
+        curve = self.app.getSelectedCurves(multiple=False)[0]
+        graph = self.app.graph()
+        info = self.listCallinfos[j]
+        # retrieve function to call
+        func, args, kwargs = info['func'], info['args'], dict(info['kwargs'])
+        # retrieve values of user-adjustable parameters
+        args = [strToVar(a.get()) for a in args]
+        for key in kwargs:
+            if isinstance(kwargs[key], tk.StringVar):
+                kwargs[key] = strToVar(kwargs[key].get())
+            # else: hiddenvars
+        # check if func is method of Graph object and not of the Curve
+        if not hasattr(func, '__self__'):
+            args = [self.app.graph()] + args
+            # to get call as Graph.func(graph, *args)
 
+        def executeFunc(curve, func, args, kwargs):
+            # execute curve action
+            graph = self.app.graph()
+            res = func(*args, **kwargs)
+            if self.app.ifPrintCommands():
+                try:
+                    subject = func.__module__
+                    if 'graph' in subject:
+                        subject = 'graph'
+                    elif 'curve' in subject:
+                        subject = 'graph['+str(curve)+']'
+                    else:
+                        print('WARNING callAction print commands: subject not',
+                              'determined (', subject, func.__name__, j, ')')
+                    print('curve = ' + subject + '.' + func.__name__ + '('
+                          + self.app.argsToStr(*args, **kwargs) + ')')
+                except Exception:
+                    pass  # error while doing useless output does not matter
+            # where to place new Curves
+            idx = curve + 1
+            while idx < len(graph):  # increments idx in specific cases
+                type_ = graph[idx].attr('type')
+                if (not type_.startswith('scatter')
+                        and not type_.startswith('errorbar')):
+                    break
+                idx += 1
+            # TODO: USE self.app.callGraphMethod
+            if isinstance(res, Curve):
+                self.app.callGraphMethod('append', res, idx=idx)
+            elif (isinstance(res, list)  # if list of Curves
+                    and np.array([isinstance(c, Curve) for c in res]).all()):
+                self.app.callGraphMethod('append', res, idx=idx)
+            elif res != True:
+                print('Curve action output:')
+                print(res)
+            # TO CHECK: if want to print anything if True, etc.
 
-if __name__ == "__main__":
-    buildUI()
+        # handling actions on multiple Curves
+        toExecute = {curve: func}
+        curves = self.app.getSelectedCurves(multiple=True)
+        if len(curves) > 1:
+            funcGUI0 = graph[curve].funcListGUI(graph=graph, graph_i=curve)[j]
+            if not isinstance(funcGUI0, FuncGUI):
+                funcGUI0 = FuncGUI(None, None).initLegacy(funcGUI0)
+            for c in curves:
+                if c != curve:
+                    # check that function is offered by other selected curves
+                    list1 = graph[c].funcListGUI(graph=graph, graph_i=c)
+                    if len(list1) > j:
+                        funcGUI1 = list1[j]
+                        if not isinstance(funcGUI1, FuncGUI):
+                            funcGUI1 = FuncGUI(None, None).initLegacy(funcGUI1)
+                        if funcGUI0.isSimilar(funcGUI1):
+                            toExecute.update({c: funcGUI1.func})
+        keys = list(toExecute.keys())
+        keys.sort(reverse=True)
+        # start execution by last one - to handle new curves
+        for c in keys:
+            if len(keys) > 1:
+                lbl = graph[c].attr('label', '')
+                if len(lbl) > 0:
+                    lbl = '(' + lbl + ')'
+                print('Action on Curve', c, lbl)
+            executeFunc(c, toExecute[c], args, kwargs)
+        # after execution
+        self.app.updateUI()
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `grapa-0.5.4.8/grapa/manual/curveMycurve.py` & `grapa-0.6.1.0/grapa/manual/curveMycurve.py`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/manual/example_sinx_x.txt` & `grapa-0.6.1.0/grapa/manual/example_sinx_x.txt`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/manual/graphMydata.py` & `grapa-0.6.1.0/grapa/manual/graphMydata.py`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/manual/manual.pdf` & `grapa-0.6.1.0/grapa/manual/manual.pdf`

 * *Files identical despite different names*

### Comparing `grapa-0.5.4.8/grapa/observable.py` & `grapa-0.6.1.0/grapa/observable.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,132 +1,136 @@
 # -*- coding: utf-8 -*-
 """
 Created on Wed Jan 25 23:30:21 2017
 
 @author: Romain Carron
-Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+Copyright (c) 2023, Empa, Laboratory for Thin Films and Photovoltaics, Romain
+Carron
 """
 
-from abc import ABCMeta, abstractmethod
+# from abc import ABCMeta, abstractmethod
 
 
- 
-
 class Observable(object):
- 
+
     def __init__(self):
         self.observers = []
- 
+
     def register(self, observer):
-        if not observer in self.observers:
+        if observer not in self.observers:
             self.observers.append(observer)
- 
+
     def unregister(self, observer):
         if observer in self.observers:
             self.observers.remove(observer)
- 
+
     def unregister_all(self):
         if self.observers:
             del self.observers[:]
- 
+
     def update_observers(self, *args, **kwargs):
         for observer in self.observers:
-            observer.update(*args, **kwargs)
-
-
-
-            
-class Observer(object):
-    __metaclass__ = ABCMeta
- 
-    @abstractmethod
-    def update(self, *args, **kwargs):
-        pass
-
-
-    
-class ObserverStringVar(Observer):
-    """
-    subclass of an Observer, which contains a StringVar (or Intvar) given as an
-    argument. Can set and get the contact of the Var.
-    """
-    def __init__(self, var, valueInit):
-        """ var is a stringvar (or a intvar, not tested yet) """
-        self._var = var
-        self._var.set(valueInit)
-        self._valueInit = valueInit
-    def get(self):
-        return self._var.get()
-    def set(self, value):
-        return self._var.set(value)
-    def update(self, *args, **kwargs):
-        """ simply set the value to that of the first provided arg """
-        for arg in args:
-            self._var.set(arg)
-            return True
-    def var(self):
-        return self._var
-
-
-
-class ObserverStringVarMethodOrKey(ObserverStringVar):
-    def __init__(self, var, valueInit, methodOrKey, valuesDict=None, methodArgs=None, methodKwargs={}):
-        """
-        methodOrKey: a method to call, or an attribute of the object feeded
-            to the updater
-        methodArgs: a list of argument to be feeded to method methodOrKey
-        methodKwargs: a dict of argument to be feeded to method methodOrKey
-        valuesDict: a dict, which keys correspond to the values of the
-            methodOrKey attribute or result of method call.
-        """
-        ObserverStringVar.__init__(self, var, valueInit)
-        self.methodOrKey = methodOrKey
-        self.valuesDict = valuesDict # expected ['valueIfTrue', valueIfFalse']
-        self.methodArgs = methodArgs if methodArgs is not None else []
-        self.methodKwargs = methodKwargs
-    def update(self, *args, **kwargs):
-        """
-        Subclass of an observer, which contains a tkinter variable var
-        By default sets the value of var to valueInit.
-        The update process is as follows.
-        It receives a list of arg. For each arg, it does the following:
-            if arg.methodOrKey() exists, then
-                value = arg.methodOrKey(*methodArgs, **methodKwargs)
-            else if arg as attribute value, sets value to arg.value
-            esle sets value to valueInit
-            
-            if valuesDict is set and valuesDict[value] exists, put that in var
-            otherwise sets the variable to value
-        """
-        for arg in args:
-            # retrieve the value of interest
-            if hasattr(arg, self.methodOrKey) and callable(getattr(arg, self.methodOrKey)):
-                # if is method of arg
-                fun = getattr(arg, self.methodOrKey)
-                try:
-                    value = fun(*self.methodArgs, **self.methodKwargs)
-                except Exception as e:
-                    print('Exception', type(e), 'when updating ObserverStringVarMethodOrKey: ',
-                          self.methodOrKey,'(', self.methodArgs, self.methodKwargs, ')')
-                    print(e)
-                    value = self._valueInit
-            elif hasattr(arg, 'getAttribute'):
-                # if can getAttribute(methodOrKey)
-                value = arg.getAttribute(self.methodOrKey)
-            else: # else back to default
-                value = self._valueInit
-            # formatting
-            if isinstance(value, tuple):
-                value = list(value)
-            if isinstance(value, list):
-                value = '[' + ', '.join([str(elem) if not isinstance(elem, str) else '\''+elem+'\'' for elem in value]) + ']'
-            if isinstance(value, str):
-                value = value.replace('\n', '\\n')
-            # update internal stringvar, possibly via a key of valuesDict
-            if isinstance(self.valuesDict, dict) and value in self.valuesDict:
-                self.set(self.valuesDict[value])
+            if hasattr(observer, 'update'):
+                observer.update(*args, **kwargs)
+            elif callable(observer):
+                observer(*args, **kwargs)
             else:
-                self.set(value)
-#                if self.valuesDict is not None:
-#                    print('Observer StringVarTest update: cannot find key', value, 'in dict', self.valuesDict)
-            return True
+                print('WARNING Observable.update_observers, dont know what to',
+                      'do', observer, 'args:', *args, **kwargs)
+
 
+# class Observer(object):
+#     __metaclass__ = ABCMeta
+#
+#     @abstractmethod
+#     def update(self, *args, **kwargs):
+#         pass
+#
+#
+# class ObserverStringVar(Observer):
+#     """
+#     subclass of an Observer, which contains a StringVar (or Intvar) given as an
+#     argument. Can set and get the contact of the Var.
+#     """
+#
+#     def __init__(self, var, valueInit):
+#         """ var is a stringvar (or a intvar, not tested yet) """
+#         self._var = var
+#         self._var.set(valueInit)
+#         self._valueInit = valueInit
+#
+#     def get(self):
+#         return self._var.get()
+#
+#     def set(self, value):
+#         return self._var.set(value)
+#
+#     def update(self, *args, **kwargs):
+#         """ simply set the value to that of the first provided arg """
+#         for arg in args:
+#             self._var.set(arg)
+#             return True
+#
+#     def var(self):
+#         return self._var
+#
+#
+# class ObserverStringVarMethodOrKey(ObserverStringVar):
+#     def __init__(self, var, valueInit, methodOrKey, valuesDict=None, methodArgs=None, methodKwargs={}):
+#         """
+#         methodOrKey: a method to call, or an attribute of the object feeded
+#             to the updater
+#         methodArgs: a list of argument to be feeded to method methodOrKey
+#         methodKwargs: a dict of argument to be feeded to method methodOrKey
+#         valuesDict: a dict, which keys correspond to the values of the
+#             methodOrKey attribute or result of method call.
+#         """
+#         ObserverStringVar.__init__(self, var, valueInit)
+#         self.methodOrKey = methodOrKey
+#         self.valuesDict = valuesDict  # expected ['valueIfTrue', valueIfFalse']
+#         self.methodArgs = methodArgs if methodArgs is not None else []
+#         self.methodKwargs = methodKwargs
+#
+#     def update(self, *args, **kwargs):
+#         """
+#         Subclass of an observer, which contains a tkinter variable var
+#         By default sets the value of var to valueInit.
+#         The update process is as follows.
+#         It receives a list of arg. For each arg, it does the following:
+#             if arg.methodOrKey() exists, then
+#                 value = arg.methodOrKey(*methodArgs, **methodKwargs)
+#             else if arg as attribute value, sets value to arg.value
+#             esle sets value to valueInit
+#
+#             if valuesDict is set and valuesDict[value] exists, put that in var
+#             otherwise sets the variable to value
+#         """
+#         for arg in args:
+#             # retrieve the value of interest
+#             if hasattr(arg, self.methodOrKey) and callable(getattr(arg, self.methodOrKey)):
+#                 # if is method of arg
+#                 fun = getattr(arg, self.methodOrKey)
+#                 try:
+#                     value = fun(*self.methodArgs, **self.methodKwargs)
+#                 except Exception as e:
+#                     print('Exception', type(e), 'when updating ObserverStringVarMethodOrKey: ',
+#                           self.methodOrKey,'(', self.methodArgs, self.methodKwargs, ')')
+#                     print(e)
+#                     value = self._valueInit
+#             elif hasattr(arg, 'attr'):
+#                 # if can getAttribute(methodOrKey)
+#                 value = arg.attr(self.methodOrKey)
+#             else:  # else back to default
+#                 value = self._valueInit
+#             # formatting
+#             if isinstance(value, tuple):
+#                 value = list(value)
+#             if isinstance(value, list):
+#                 value = '[' + ', '.join([str(elem) if not isinstance(elem, str) else '\''+elem+'\'' for elem in value]) + ']'
+#             if isinstance(value, str):
+#                 value = value.replace('\n', '\\n')
+#             # update internal stringvar, possibly via a key of valuesDict
+#             if isinstance(self.valuesDict, dict) and value in self.valuesDict:
+#                 self.set(self.valuesDict[value])
+#             else:
+#                 self.set(value)
+#             return True
```

### Comparing `grapa-0.5.4.8/grapa/scripts/script_JVSummaryToBoxPlots.py` & `grapa-0.6.1.0/grapa/scripts/script_JVSummaryToBoxPlots.py`

 * *Files 23% similar despite different names*

```diff
@@ -21,15 +21,14 @@
 from grapa.curve import Curve
 try:
     from grapa.scripts.script_processJV import writeFileAvgMax
 except ImportError:
     pass
 
 
-
 def replaceLabels(graph, label):
     print('label', label)
     if label in ['Voc [V]']:
         label = graph.formatAxisLabel(['Voc', '', 'V'])
     elif label in ['Jsc [mA/cm2]']:
         label = graph.formatAxisLabel(['Jsc', '', 'mA cm$^{-2}$'])
     elif label in ['FF [%]']:
@@ -42,203 +41,208 @@
         label = graph.formatAxisLabel(['Rs', '', 'Ohm cm$^2$'])
     elif label in ['n']:
         label = graph.formatAxisLabel(['n', '', ' '])
     elif label in ['J0 [A/cm2]']:
         label = graph.formatAxisLabel(['J$_0$', '', 'A cm$^{-2}$'])
     return label
 
+
 def labelFromGraph(graph, silent=False, file=''):
     # label will be per priority:
     # 1. if a 'label' field is present at beginning of file (so all curve labels are identical)
-    # 2. a 'sample' field of 'sample name' field at beginning of file 
+    # 2. a 'sample' field of 'sample name' field at beginning of file
     # 3. processed filename
-    
+
     # if label set at beginning of the file -> same label for each curve
-    lbl = graph.curve(0).getAttribute('label')
-    for c in range(graph.length()):
-        if graph.curve(c).getAttribute('label') != lbl:
+    lbl = graph[0].attr('label')
+    for c in range(len(graph)):
+        if graph[c].attr('label') != lbl:
             lbl = None
             break
     if lbl is not None:
         if not silent:
-            print('label:', lbl, '(\'label\' attribute in file header, or unexpected input)')
+            print('label:', lbl, '(\'label\' attribute in file header, or',
+                  'unexpected input)')
     if lbl is None:
-        # if not every labels are identical: look for 'sample' and 'sample name' fields
-        # overrides if find 'sample' keyword in the headers of the file
-        if graph.curve(0).getAttribute('sample name') != '':
-            lbl = graph.curve(0).getAttribute('sample name')
+        # if not every labels are identical: look for 'sample' and 'sample
+        # name' fields overrides if find 'sample' keyword in the file headers
+        if graph[0].attr('sample name') != '':
+            lbl = graph[0].attr('sample name')
             if isinstance(lbl, list):
                 lbl = lbl[0]
-                for c in range(graph.length()): # clean a bit the mess
-                    if isinstance(graph.curve(c).getAttribute('sample name'), list):
-                        graph.curve(c).update({'sample name': graph.curve(c).getAttribute('sample name')[0]})
+                for c in range(len(graph)):  # clean a bit the mess
+                    if isinstance(graph[c].attr('sample name'), list):
+                        graph[c].update({'sample name': graph[c].attr('sample name')[0]})
             if not silent:
                 print('label:', lbl, '(\'sample name\' attribute in file header)')
-        elif graph.getAttribute('sample') != '':
-            lbl = graph.getAttribute('sample')
+        elif graph.attr('sample') != '':
+            lbl = graph.attr('sample')
             if not silent:
                 print('label:', lbl, '(\'sample\' attribute in file header)')
     if lbl is None:
         lbl = os.path.basename(file).replace('export','').replace('summary','').replace('_',' ').replace('  ',' ')
         if not silent:
             print('label:', lbl, '(from file name - no \'label\', \'sample\' or \'sample name\' attribute found in file header)')
     return lbl
 
-    
-    
-    
+
+
+
 def JVSummaryToBoxPlots(folder='.', exportPrefix='boxplot_', replace=None, plotkwargs={}, silent=False, pltClose=True, newGraphKwargs={}):
     if replace is None:
-        replace = [] # possible input: [['Oct1143\n', ''], ['\nafterLS','']]
-    newGraphKwargs =  copy.deepcopy(newGraphKwargs)
+        replace = []  # possible input: [['Oct1143\n', ''], ['\nafterLS','']]
+    newGraphKwargs = copy.deepcopy(newGraphKwargs)
     newGraphKwargs.update({'silent': silent})
-    
+
     # establish list of files
     path = os.path.join(folder, '*.txt')
     fileList = sorted(glob.glob(path))
     files = []
     for file in fileList:
         filename = os.path.basename(file)
         # do notwant to open previously created export files
         if len(exportPrefix) > 0 and filename[:len(exportPrefix)] != exportPrefix:
             files += [file]
     if len(files) == 0:
         return None
-    
+
     # default mode: every column is shown, grouped by columns
     mode = 'all'
     # test if JV mode: only a subset is shown, and some cosmetics is performed
     isJV = True
     graph = Graph(files[0], **newGraphKwargs)
-    collabels = graph.getAttribute('collabels')
+    collabels = graph.attr('collabels')
     if len(collabels) < 8:
         isJV = False
     else:
-        collabels = graph.getAttribute('collabels')
-        cols = [0, 1, 2, 3, 8, 9] # required columns
+        collabels = graph.attr('collabels')
+        cols = [0, 1, 2, 3, 8, 9]  # required columns
         titles = [['Voc'], ['Jsc'], ['FF'], ['Eff'], ['Rp'], ['Rs']]
         for c in range(len(cols)):
             flag = False
             for tmp in titles[c]:
                 if tmp in collabels[cols[c]]:
                     flag = True
                     break
             if not flag:
                 isJV = False
     if isJV:
         mode = 'JV'
-        JVcols = [0, 1, 2, 3, 8, 9, 10, 11] # all columns of interest
-        JVtitles = [['Voc'], ['Jsc'], ['FF'], ['Eff'], ['Rp'], ['Rs'], ['n'], ['J0','I0']]
+        JVcols = [0, 1, 2, 3, 8, 9, 10, 11]  # all columns of interest
+        JVtitles = [['Voc'], ['Jsc'], ['FF'], ['Eff'], ['Rp'], ['Rs'], ['n'], ['J0', 'I0']]
         JVupdates = [{}] * len(JVcols)
-        JVupdates[-1] = {'typeplot': 'semilogy'} # J0
+        JVupdates[-1] = {'typeplot': 'semilogy'}  # J0
 
     graphs = []
     titles = []
-    
+
     nbCarriageReturnLabel = 0
     strStatistics = ''
-    
-    for file in files :
+
+    for file in files:
         # open the file corresponding to 1 given sample
         if not silent:
-            print ('open file',file)
+            print('open file', file)
         graph = Graph(file, **newGraphKwargs)
         if graph.length() == 0:
             print('Cannot interpret file data. Go to next one.')
             continue
-        
-        complement = copy.deepcopy(graph.curve(0).getAttributes())
+
+        complement = copy.deepcopy(graph[0].getAttributes())
         complement.update({'type': 'boxplot'})
-        
+
         if mode == 'JV':
             # gather statisics data to be placed in a text file
             try:
-                strStatistics += writeFileAvgMax(graph, withHeader=(True if len(strStatistics) == 0 else False), colSample=True, filesave=None)
+                add = writeFileAvgMax(graph, colSample=True, filesave=None,
+                                      ifPrint=False,
+                                      withHeader=(True if len(strStatistics) == 0 else False))
+                if isinstance(add, str):
+                    strStatistics += add
+                # print('strStatistics increment', len(strStatistics))
             except Exception as e:
                 print('Exception += ', type(e), e)
                 pass
-        
+
         label = labelFromGraph(graph, silent=silent, file=file)
         # "clean" label according to replacement pairs provided by user
         for rep in replace:
             label = label.replace(rep[0], rep[1])
         complement.update({'label': label})
-        
+
         # needed to estimate the graph height
         nbCarriageReturnLabel = max(nbCarriageReturnLabel, label.count('\n'))
-    
+
         # construct one column of each box plot
-        collabels = graph.getAttribute('collabels')
-        curvesOfInterest = JVcols if mode == 'JV' else range(graph.length())
+        collabels = graph.attr('collabels')
+        curvesOfInterest = JVcols if mode == 'JV' else range(len(graph))
         for i in range(len(curvesOfInterest)):
             c = curvesOfInterest[i]
             data = graph.curve(c).getData()
-            
+
             # prepare graph title
             while i >= len(titles):
                 titles.append('')
             title = collabels[c] if titles[i] == '' else ''
-                
+
             # if input not match JV file, discard it
             if mode == 'JV':
                 flag = False
                 if c < len(collabels):
                     for tit in JVtitles[i]:
                         if collabels[c].startswith(tit):
                             flag = True
                             break
                 if not flag:
-                    print('Wrong column name, no data plotted, file', file, 'i', i, 'column', c)
+                    print('Wrong column name, no data plotted, file', file,
+                          'i', i, 'column', c)
                     data = [[np.nan], [np.nan]]
                     title = ''
-                title = title.replace('Voc_V','Voc [V]').replace('Jsc_mApcm2','Jsc [mA/cm2]').replace('FF_pc','FF [%]').replace('Eff_pc','Eff. [%]').replace('_Ohmcm2',' [Ohmcm2]')
-                title = title.replace('A/cm2', 'A cm$^{-2}$').replace('J0 ','J$_0$ ').replace('Ohmcm2', '$\Omega$ cm$^2$')
-            
+                title = title.replace('Voc_V', 'Voc [V]').replace('Jsc_mApcm2', 'Jsc [mA/cm2]').replace('FF_pc', 'FF [%]').replace('Eff_pc', 'Eff. [%]').replace('_Ohmcm2', ' [Ohmcm2]')
+                title = title.replace('A/cm2', 'A cm$^{-2}$').replace('J0 ', 'J$_0$ ').replace('Ohmcm2', '$\Omega$ cm$^2$')
+
             # prepare graph
-            if title is not '':
+            if title != '':
                 titles[i] = graph.formatAxisLabel(title)
             while i >= len(graphs):
                 graphs.append(Graph('', **newGraphKwargs))
             graphs[i].append(Curve(data, complement))
         # go to next file
-        
+
     # cosmetics, then save plots
     figSize = (1 + 0.9*len(files), 4)
     for i in range(len(graphs)):
         graph = graphs[i]
-        if graph.length() > 0:
+        if len(graph) > 0:
             # counts number of non-NaN element in each curve, only plot if is > 0
-            num = sum([sum(~np.isnan(c.x())) for c in graph.iterCurves()])
+            num = sum([sum(~np.isnan(c.x())) for c in graph])
             if num > 0:
-                graph.update({'figsize': figSize, 'subplots_adjust': [1.1 / figSize[1], (nbCarriageReturnLabel+2)*0.06]})
-                #graph.update({'title': titles[i]})
-                graph.update({'ylabel': titles[i]})
+                graph.update({'figsize': figSize, 'ylabel': titles[i],
+                              'subplots_adjust': [1.1 / figSize[1], (nbCarriageReturnLabel+2)*0.06]})
                 filesave = os.path.join(folder, exportPrefix + str(i))
                 if mode == 'JV':
                     if JVupdates[i] is not {}:
                         graph.update(JVupdates[i])
                     tit = titles[i]
-                    filesave = os.path.join(folder, exportPrefix + tit.split(' ')[0].replace('$','').replace('.','').replace('_',''))
+                    filesave = os.path.join(folder, exportPrefix + tit.split(' ')[0].replace('$', '').replace('.', '').replace('_', ''))
                 graph.plot(filesave=filesave, **plotkwargs)
                 if pltClose:
                     plt.close()
-    
+
     # print and save statistics
     if len(strStatistics) > 0:
         print(strStatistics)
         filesave = os.path.join(folder, exportPrefix + 'statistics.txt')
         print('filesave', filesave)
-        f = open(filesave, 'w')
-        f.write(strStatistics)
-        f.close()
+        with open(filesave, 'w') as f:
+            f.write(strStatistics)
 
     # return last plot
     print('JVSummaryToBoxPlots completed.')
     return graphs[0]
 
 
 if __name__ == "__main__":
     folder = './../examples/boxplot/'
 #    folder = './../examples/boxplot/notJVspecific/'
     JVSummaryToBoxPlots(folder=folder, exportPrefix='boxplots_', pltClose=False, silent=True)
     plt.show()
-
```

### Comparing `grapa-0.5.4.8/grapa/scripts/script_processCVCf.py` & `grapa-0.6.1.0/grapa/scripts/script_processCVCf.py`

 * *Files 5% similar despite different names*

```diff
@@ -7,68 +7,75 @@
 """
 
 import os
 import numpy as np
 import copy
 import matplotlib.pyplot as plt
 import sys
+import warnings
 
 path = os.path.normpath(os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', '..'))
 if path not in sys.path:
     sys.path.append(path)
 
 from grapa.graph import Graph
 from grapa.graphIO import GraphIO
 from grapa.curve import Curve
 from grapa.colorscale import Colorscale
 from grapa.curve_image import Curve_Image
 from grapa.mathModule import roundSignificant
 
-from grapa.datatypes.curveCf import GraphCf
-from grapa.datatypes.curveCV import GraphCV, CurveCV
+from grapa.datatypes.graphCf import GraphCf
+from grapa.datatypes.graphCV import GraphCV
+from grapa.datatypes.curveCV import  CurveCV
 from grapa.datatypes.curveArrhenius import CurveArrheniusExtrapolToZero
 
 
 
 def maskUndesiredLegends(graph, legend):
     """
     mask undesired legends in Graph object
     legend: possible values: 'no', 'minmax', 'all'
     """
     if legend == 'all':
         pass
     elif legend == 'none':
-        for c in range(0, graph.length()):
-            graph.curve(c).update({'labelhide': 1})
-    else: # legend == 'minmax':
-        for c in range(1, graph.length()-1):
-            graph.curve(c).update({'labelhide': 1})
+        for c in range(0, len(graph)):
+            graph[c].update({'labelhide': 1})
+    else:  # legend == 'minmax':
+        for c in range(1, len(graph)-1):
+            graph[c].update({'labelhide': 1})
+
 
 def setXlim(graph, keyword='tight'):
     if keyword != 'tight':
         print('processCV Cf setXlim unknown keyword')
     xlim = [np.inf, -np.inf]
     for c in graph.iterCurves():
         xlim = [min(xlim[0], min(c.x())), max(xlim[1], max(c.x()))]
     graph.update({'xlim': xlim})
 
-    
 
-def script_processCV(folder, legend='minmax', ROIfit=None, ROIsmart=None, pltClose=True, newGraphKwargs={}):
+
+def script_processCV(folder, legend='auto', ROIfit=None, ROIsmart=None, pltClose=True, newGraphKwargs={}):
     """
     """
+    DEFAULT_T = 300
+
+    WARNINGS = []
+
     newGraphKwargs = copy.deepcopy(newGraphKwargs)
     newGraphKwargs.update({'silent': True})
-    
+
     print('Script process C-V')
     if ROIfit is None:
         ROIfit = CurveCV.CST_MottSchottky_Vlim_def
     if ROIsmart is None:
         ROIsmart = CurveCV.CST_MottSchottky_Vlim_adaptative
-    
+
     graph      = Graph('', **newGraphKwargs)
     graphPhase = Graph('', **newGraphKwargs)
     graphVbi   = Graph('', **newGraphKwargs)
     # list possible files
     listdir = []
     for file in os.listdir(folder):
         if os.path.isfile(os.path.join(folder, file)):
@@ -80,68 +87,86 @@
     if len(listdir) == 0:
         print('Found no suitable file in folder', folder)
         return Graph('', **newGraphKwargs)
     listdir.sort()
     # open all data files
     for file in listdir:
         print(file)
-        graphTmp = Graph(os.path.join(folder, file), complement={'_CVLoadPhase': True}, **newGraphKwargs)
-        if graph.length() == 0:
+#        with warnings.catch_warnings():
+        with warnings.catch_warnings(record=True) as w:
+            graphTmp = Graph(os.path.join(folder, file), complement={'_CVLoadPhase': True}, **newGraphKwargs)
+        if len(w) > 0:
+            for _ in w:
+                WARNINGS.append(str(_.message))
+        if len(graph) == 0:
             graph = graphTmp
-            while graph.length() > 1:
+            while len(graph) > 1:
                 graph.deleteCurve(1)
         else:
-            graph.append(graphTmp.curve(0))
-        if graphTmp.length() > 1:
-            graphPhase.append(graphTmp.curve(1))
-    graph.colorize(Colorscale(np.array([[1,0.43,0], [0,0,1]]), invert=True)) # ThW admittance colorscale
-    graphPhase.colorize(Colorscale(np.array([[1,0.43,0], [0,0,1]]), invert=True)) # ThW admittance colorscale
-    lbl = graph.curve(-1).getAttribute('label').replace(' K','K').split(' ')
+            graph.append(graphTmp[0])
+        if len(graphTmp) > 1:
+            graphPhase.append(graphTmp[1])
+        else:
+            graphPhase.append(Curve([[0], [0]], {}))
+    graph.colorize(Colorscale(np.array([[1, 0.43, 0], [0, 0, 1]]), invert=True))  # ThW admittance colorscale
+    graphPhase.colorize(Colorscale(np.array([[1, 0.43, 0], [0, 0, 1]]), invert=True))  # ThW admittance colorscale
+    lbl = graph[-1].attr('label').replace(' K','K').split(' ')
+    lb0 = graph[0].attr('label').replace(' K','K').split(' ')
+    joined = ' '.join(lbl[:-1])
+    joine0 = ' '.join(lb0[:-1])
+    legendifauto = 'all' if joined != joine0 else 'minmax'
     if len(lbl) > 1:
-        graph.update({'title': ' '.join(lbl[:-1])})
-        graph.replaceLabels(' '.join(lbl[:-1]), '')
-        graphPhase.update({'title': ' '.join(lbl[:-1])})
-        graphPhase.replaceLabels(' '.join(lbl[:-1]), '')
-    graphPhase.update({'xlabel': graph.getAttribute('xlabel'),
+        graph.update(     {'title': joined})
+        graphPhase.update({'title': joined})
+        if legendifauto == '':  # later, will also remove most text of legend
+            graph.replaceLabels(joined, '')
+            graphPhase.replaceLabels(joined, '')
+    graphPhase.update({'xlabel': graph.attr('xlabel'),
                        'ylabel': graph.formatAxisLabel('Impedance angle []')})
     # mask undesired legends
+    if legend == 'auto':
+        legend = legendifauto
     maskUndesiredLegends(graph, legend)
     maskUndesiredLegends(graphPhase, legend)
     # set xlim
     setXlim(graph, 'tight')
     setXlim(graphPhase, 'tight')
-    
-    labels = graph.getAttribute('xlabel'),  graph.getAttribute('ylabel')
+
+    labels = graph.attr('xlabel'),  graph.attr('ylabel')
     presets = {}
     presets.update({'default': {'ylim': [0, np.nan], 'alter': '',
                                 'typeplot': '',
-                                'xlabel': labels[0], 'ylabel': labels[1]}})
+                                'xlabel': labels[0], 'ylabel': labels[1],
+                                'subplots_adjust': [0.16, 0.15]}})
     presets.update({'MS': {'ylim': '', 'alter': ['', 'CurveCV.y_ym2'],
                            'typeplot': '',
-                           'ylabel': graph.formatAxisLabel(['1 / C^2', '', 'nF$^{-2}$ cm$^{4}$']),
+                           'ylabel': graph.formatAxisLabel(['1 / C$^2$', '', 'nF$^{-2}$ cm$^{4}$']),
                            'xlabel': labels[0]}})
     presets.update({'NV': {'ylim': [0, np.nan],
                            'typeplot': '',
                            'alter': ['', 'CurveCV.y_CV_Napparent'],
                            'ylabel': graph.formatAxisLabel(['Apparent doping density', 'N_{CV}', 'cm$^{-3}$']),
                            'xlabel': labels[0]}})
     presets.update({'NVlog': copy.deepcopy(presets['NV'])})
     presets['NVlog'].update({'ylim': '', 'typeplot': 'semilogy'})
-    presets.update({'Nx': {'ylim': [0, np.nan],
+    presets.update({'Nx': {'ylim': [0, np.nan], 'xlim': '',
                            'alter': ['CurveCV.x_CVdepth_nm', 'CurveCV.y_CV_Napparent'],
                            'typeplot': '',
                            'ylabel': graph.formatAxisLabel(['Apparent doping density', 'N_{CV}', 'cm$^{-3}$']),
                            'xlabel': graph.formatAxisLabel(['Apparent depth', 'd', 'nm'])}})
     presets.update({'Nxlog': copy.deepcopy(presets['Nx'])})
     presets['Nxlog'].update({'ylim': '', 'typeplot': 'semilogy'})
 
+    graphVbi.update({'subplots_adjust': [0.16, 0.15]})
+    graphPhase.update({'subplots_adjust': [0.16, 0.15]})
+
     # save
-    filesave = os.path.join(folder, graph.getAttribute('title').replace(' ','_')+'_') # graphIO.filesave_default(self)
-    plotargs = {} # {'ifExport': False, 'ifSave': False}
-    #plotargs = {}
+    filesave = os.path.join(folder, graph.attr('title').replace(' ','_')+'_')  # graphIO.filesave_default(self)
+    plotargs = {}  # {'ifExport': False, 'ifSave': False}
+    # plotargs = {}
     # default graph: C vs log(f)
     graph.update(presets['default'])
     graph.plot(filesave=filesave+'CV', **plotargs)
     if pltClose:
         plt.close()
     # graph 2: Mott Schottky
     graph.update(presets['MS'])
@@ -158,14 +183,23 @@
     if pltClose:
         plt.close()
 
     # graph 4: N vs depth
     # add doping V=0
     curves = []
     for curve in graph:
+        # check that temperature is set
+        if curve.attr('temperature [k]') == '':
+            msg = ('WARNING processCV file '
+                   + os.path.basename(curve.attr('filename'))
+                   +' temperature [k] not found, set to '+str(DEFAULT_T)+' K.')
+            print(msg)
+            WARNINGS.append(msg)
+            curve.update({'temperature [k]': DEFAULT_T})
+        # do required stuff
         tmp = curve.CurveCV_0V()
         if tmp is not False:
             tmp.update({'label': tmp.attr('label')+' Ncv @ 0V'})
             curves.append(tmp)
     graph.append(curves)
     graph.update(presets['Nx'])
     graph.plot(filesave=filesave+'Ndepth', **plotargs)
@@ -181,49 +215,49 @@
         N = curve.y(alter=presets['Nxlog']['alter'][1])
         N0V_T.append(curve.attr('temperature [k]'))
         N0V_N.append(N[2])
     N0V = Curve([N0V_T, N0V_N], {'label': 'N$_\mathrm{CV}$ (0V)', 'linestyle': 'none', 'linespec':'s', 'markeredgewidth':0, 'color':'b'})
     for c in range(len(graph)-1, -1, -1): # remove unnecessary curves
         if graph[c] in curves:
             graph.deleteCurve(c)
-        
+
     # Fit Mott-Schottky curves
     Ncvminmax0 = [np.inf, -np.inf]
     Ncvminmax1 = [np.inf, -np.inf]
     graphVbi.append(Curve([[], []], CurveArrheniusExtrapolToZero.attr))
     graphVbi.append(Curve([[], []], {'linestyle': 'none'}))
     graphVbi.append(Curve([[], []], CurveArrheniusExtrapolToZero.attr))
     graphVbi.append(Curve([[], []], {'linestyle': 'none'}))
     graphVbi.append(N0V)
     graphSmart = Graph('', **newGraphKwargs)
     numCurves = graph.length()
-    for curve in range(numCurves):
+    for curve in range(numCurves): # number of Curves in graph will change
         c = graph.curve(curve)
         c.update({'linewidth': 0.25})
         new   = c.CurveCV_fitVbiN(ROIfit, silent=True)
         smart = c.CurveCV_fitVbiN(c.smartVlim_MottSchottky(Vlim=ROIsmart), silent=True)
         if isinstance(new, CurveCV):
             graph.append(new)
-            graph.curve(-1).update({'linespec': '--', 'color': c.getAttribute('color')})
-            Vbi, Ncv = new.getAttribute('_popt')[0], new.getAttribute('_popt')[1]
-            graphVbi.curve(0).appendPoints([c.getAttribute('temperature [k]')], [Vbi])
-            graphVbi.curve(1).appendPoints([c.getAttribute('temperature [k]')], [Ncv])
+            graph[-1].update({'linespec': '--', 'color': c.attr('color')})
+            Vbi, Ncv = new.attr('_popt')[0], new.attr('_popt')[1]
+            graphVbi[0].appendPoints([c.attr('temperature [k]')], [Vbi])
+            graphVbi[1].appendPoints([c.attr('temperature [k]')], [Ncv])
             Ncvminmax0 = [min(Ncvminmax0[0], Ncv), max(Ncvminmax0[1], Ncv)]
         if isinstance(smart, CurveCV):
             graphSmart.append(smart)
-            graphSmart.curve(-1).update({'linespec': '--', 'color': c.getAttribute('color')})
-            Vbi, Ncv = smart.getAttribute('_popt')[0], smart.getAttribute('_popt')[1]
-            graphVbi.curve(2).appendPoints([c.getAttribute('temperature [k]')], [Vbi])
-            graphVbi.curve(3).appendPoints([c.getAttribute('temperature [k]')], [Ncv])
+            graphSmart[-1].update({'linespec': '--', 'color': c.attr('color')})
+            Vbi, Ncv = smart.attr('_popt')[0], smart.attr('_popt')[1]
+            graphVbi[2].appendPoints([c.attr('temperature [k]')], [Vbi])
+            graphVbi[3].appendPoints([c.attr('temperature [k]')], [Ncv])
             Ncvminmax1 = [min(Ncvminmax1[0], Ncv), max(Ncvminmax1[1], Ncv)]
     graphVbi.update({'legendtitle': 'Mott-Schottky fit'})
-    graphVbi.curve(0).update({'linespec': 'o', 'color': 'k', 'label': 'Built-in voltage (same Vlim)', 'markeredgewidth': 0, })
-    graphVbi.curve(1).update({'linespec': 'x', 'color': 'k', 'label': 'N$_\mathrm{CV}$ (same Vlim)'})
-    graphVbi.curve(2).update({'linespec': 'o', 'color': 'r', 'label': 'Built-in voltage (adaptative Vlim)', 'markeredgewidth': 0})
-    graphVbi.curve(3).update({'linespec': 'x', 'color': 'r', 'label': 'N$_\mathrm{CV}$ (adaptative Vlim)'})
+    graphVbi[0].update({'linespec': 'o', 'color': 'k', 'label': 'Built-in voltage (same Vlim)', 'markeredgewidth': 0})
+    graphVbi[1].update({'linespec': 'x', 'color': 'k', 'label': 'N$_\mathrm{CV}$ (same Vlim)'})
+    graphVbi[2].update({'linespec': 'o', 'color': 'r', 'label': 'Built-in voltage (adaptative Vlim)', 'markeredgewidth': 0})
+    graphVbi[3].update({'linespec': 'x', 'color': 'r', 'label': 'N$_\mathrm{CV}$ (adaptative Vlim)'})
     graphVbi.update({'xlabel': graphVbi.formatAxisLabel(['Temperature', 'T', 'K']),
                      'ylabel': graphVbi.formatAxisLabel(['Built-in voltage', 'V_{bi}', 'V'])})
     graphVbi.plot(filesave=filesave+'VbiT', **plotargs)
     if pltClose:
         plt.close()
     for curve in graphVbi.iterCurves():
         curve.swapShowHide()
@@ -260,24 +294,29 @@
     if pltClose:
         plt.close()
     graph.update({'legendtitle': '', 'ylim': [0.5*Ncvminmax1[0], 5*Ncvminmax1[1]]})
 
     # graph phase
     graphPhase.update({'alter': '', 'ylim': [0, 90]})
     f = graphPhase.curve(0).x()
-#    graphPhase.append(Curve([[min(f), max(f), max(f), min(f)], [0, 0, 20, 20]], {'type': 'fill', 'facecolor': [1,0,0,0.5], 'linewidth': 0}))
+    #    graphPhase.append(Curve([[min(f), max(f), max(f), min(f)], [0, 0, 20, 20]], {'type': 'fill', 'facecolor': [1,0,0,0.5], 'linewidth': 0}))
     graphPhase.append(Curve([[min(f), max(f)], [20, 20]], {'color': [1,0,0], 'linewidth': 2, 'linespec': '--'}))
     graphPhase.plot(filesave=filesave+'phase', **plotargs)
     if pltClose:
         plt.close()
-    
-    print('End of process C-V.')
+
+    if len(WARNINGS) > 0:
+        print('Enf of process C-V. Got some warnings along the way... see above or summary')
+        for msg in WARNINGS:
+            print(msg)
+    else:
+        print('End of process C-V, successful.')
     return graph
-    
-    
+
+
 def script_processCf(folder, legend='minmax', pltClose=True, newGraphKwargs={}):
     """
     legend: possible values: 'no', 'minmax', 'all'
     """
     print('Script process C-f')
     newGraphKwargs = copy.deepcopy(newGraphKwargs)
     newGraphKwargs.update({'silent': True})
@@ -301,50 +340,50 @@
         print(file)
         graphTmp = Graph(os.path.join(folder, file), complement={'_CfLoadPhase': True, '_CfLoadNyquist': True}, **newGraphKwargs)
         if graph.length() == 0:
             graph.update(graphTmp.graphInfo)
         graph.append(graphTmp.curve(0)) # append C-f
         if graphTmp.length() > 1:
             for c in graphTmp.iterCurves():
-                if c.getAttribute('_CfPhase', False):
+                if c.attr('_CfPhase', False):
                     graphPhase.append(c)
-                if c.getAttribute('_CfNyquist', False):
+                if c.attr('_CfNyquist', False):
                     graphNyqui.append(c)
     graph.colorize     (Colorscale(np.array([[1,0.43,0], [0,0,1]]), invert=True)) # ThW admittance colorscale
     graphPhase.colorize(Colorscale(np.array([[1,0.43,0], [0,0,1]]), invert=True)) # ThW admittance colorscale
     graphNyqui.colorize(Colorscale(np.array([[1,0.43,0], [0,0,1]]), invert=True)) # ThW admittance colorscale
-    lbl = graph.curve(-1).getAttribute('label').replace(' K','K').split(' ')
+    lbl = graph.curve(-1).attr('label').replace(' K','K').split(' ')
     if len(lbl) > 1:
         graph.update     ({'title': ' '.join(lbl[:-1])})
         graphPhase.update({'title': ' '.join(lbl[:-1])})
         graphNyqui.update({'title': ' '.join(lbl[:-1])})
         graph.replaceLabels     (' '.join(lbl[:-1]), '')
         graphPhase.replaceLabels(' '.join(lbl[:-1]), '')
         graphNyqui.replaceLabels(' '.join(lbl[:-1]), '')
-    graphPhase.update({'xlabel': graph.getAttribute('xlabel'),
+    graphPhase.update({'xlabel': graph.attr('xlabel'),
                        'ylabel': graphPhase.formatAxisLabel('Impedance angle []')})
-    graphNyqui.update({'xlabel': graph.getAttribute('xlabel'),
+    graphNyqui.update({'xlabel': graph.attr('xlabel'),
                        'ylabel': graphNyqui.formatAxisLabel('Impedance angle []')})
     graphNyqui.update({'xlabel': graphNyqui.formatAxisLabel(GraphCf.AXISLABELSNYQUIST[0]),
                        'ylabel': graphNyqui.formatAxisLabel(GraphCf.AXISLABELSNYQUIST[1])})
     # mask undesired legends
     maskUndesiredLegends(graph, legend)
     maskUndesiredLegends(graphPhase, legend)
     maskUndesiredLegends(graphNyqui, legend)
     # set xlim
     setXlim(graph, 'tight')
     setXlim(graphPhase, 'tight')
     setXlim(graphNyqui, 'tight')
-    
+
     # save
-    filesave = os.path.join(folder, graph.getAttribute('title').replace(' ','_')+'_') # graphIO.filesave_default(self)
+    filesave = os.path.join(folder, graph.attr('title').replace(' ','_')+'_') # graphIO.filesave_default(self)
     plotargs = {} # {'ifExport': False, 'ifSave': False}
     graphattr = {}
     for attr in ['alter', 'typeplot', 'xlim', 'ylim', 'xlabel', 'ylabel']:
-        graphattr.update({attr: graph.getAttribute(attr)})
+        graphattr.update({attr: graph.attr(attr)})
     # default graph: C vs log(f)
     graph.update({'ylim': [0, np.nan]})
     graph.plot(filesave=filesave+'Clogf', **plotargs)
     if pltClose:
         plt.close()
     # graph 2: derivative
     graph.update({'alter': ['', 'CurveCf.y_mdCdlnf'], 'typeplot': 'semilogx'})
@@ -377,25 +416,27 @@
         plt.close()
     # graph 6: image derivative, T vs f
     graphImage = Graph()
     flag = True
     x = [0] + list(graph.curve(0).x())
     Tmin, Tmax = np.inf, -np.inf
     for c in graph.iterCurves():
-        T = c.getAttribute('temperature', None)
+        T = c.attr('temperature', None)
         if T is None:
-            T = c.getAttribute('temperature [k]', None)
+            T = c.attr('temperature [k]', None)
         if T is None:
-            print('Script Cf, image, cannot identify Temperature', c.getAttributes())
+            print('Script Cf, image, cannot identify Temperature',
+                  c.getAttributes())
             flag = False
         else:
             Tmin, Tmax = min(Tmin, T),  max(Tmax, T)
         y = [T] + list(c.y(alter='CurveCf.y_mdCdlnf'))
         if len(x) != len(y):
-            print('WARNING data curve', T, 'not consistent number of points throughout the input files!', c.getAttribute('filename'))
+            print('WARNING data curve', T, 'not consistent number of points',
+                  'throughout the input files!', c.attr('filename'))
             continue
         graphImage.append(Curve_Image([x, y], {}))
     if flag:
         # levels -> int value does not seem to work (matplotlib version?)
         m, M = np.inf, -np.inf
         for c in graphImage.iterCurves():
             m = min(m, np.min(c.y()[1:]))
@@ -416,46 +457,45 @@
             fdelta = (np.log10(fmax) - np.log10(fmin))
             subadj = [0.8, 0.5, 0.8+fdelta, 0.5+Tdelta, 'abs']
             graphImage.update({'subplots_adjust': subadj,
                                'figsize': [2+fdelta, 1+Tdelta]})
         else:
             print('script Cf, image, Warning T delta <=0, cannot properly scale image.')
         graphImage.update({'typeplot': 'semilogx',
-                           'xlabel': graph.getAttribute('xlabel'),
+                           'xlabel': graph.attr('xlabel'),
                            'ylabel': graphImage.formatAxisLabel(['Temperature', '', 'K'])})
         graphImage.curve(0).update({'datafile_xy1rowcol': 1,
                                     'cmap': 'afmhot',
                                     'type': 'contourf',
-                                    'colorbar': {'label': graph.getAttribute('ylabel'),#'-dC / dln(f)',
+                                    'colorbar': {'label': graph.attr('ylabel'),  #'-dC / dln(f)',
                                                  'adjust': [1.05, 0, 0.05, 1, 'ax']},
                                     'vmin': 0,
                                     'levels': levels})
         # 'cmap': [[0.91, 0.25, 1], [1.09, 0.75, 1], 'hls']
         graphImage.plot(filesave=filesave+'image', **plotargs)
         if pltClose:
             plt.close()
     # graph 7: f vs apparent doping
     graph.update({'alter': ['CurveCV.x_CVdepth_nm', 'x'], 'typeplot': 'semilogy'})
     graph.update({'xlabel': graph.formatAxisLabel(['Apparent depth', 'd', 'nm']),
                   'ylabel': graph.formatAxisLabel(['Frequency', 'f', 'Hz']),
-                  'xlim':'', 'ylim':''})
+                  'xlim': '', 'ylim': ''})
     graph.plot(filesave=filesave+'apparentDepth', **plotargs)
     if pltClose:
         plt.close()
-    
-    graph.update(graphattr) # restore initial graph
+
+    graph.update(graphattr)  # restore initial graph
     print('Tip for next step: pick inflection points for different T, then the fit activation energy.')
     print('End of process C-f.')
     return graph
 
-    
+
 if __name__ == "__main__":
 
     folder = './../examples/Cf/'
     #graph = script_processCf(folder, pltClose=False)
 
 
     folder = './../examples/CV/'
     graph = script_processCV(folder, ROIfit=[0.15,0.3], pltClose=True)
 
     plt.show()
-
```

### Comparing `grapa-0.5.4.8/grapa/scripts/script_processJscVoc.py` & `grapa-0.6.1.0/grapa/scripts/script_processJscVoc.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 # -*- coding: utf-8 -*-
 """
 Created on Tue Feb 11 23:02:34 2020
 
 @author: Romain Carron
-Copyright (c) 2020, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+Copyright (c) 2020, Empa, Laboratory for Thin Films and Photovoltaics,
+Romain Carron
 """
 
-
 import os
 import numpy as np
 import copy
 import matplotlib.pyplot as plt
 import sys
 
 path = os.path.normpath(os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', '..'))
@@ -19,139 +19,134 @@
 
 from grapa.graph import Graph
 from grapa.mathModule import roundSignificantRange, roundSignificant, is_number
 
 from grapa.datatypes.curveJscVoc import GraphJscVoc, CurveJscVoc
 
 
-
-
-    
-
 def script_processJscVoc(file, pltClose=True, newGraphKwargs={},
                          ROIJsclim=None, ROIVoclim=None, ROITlim=None):
     """
-    
     TO IMPLEMENT PARAMETERS:
         Jo, A fit: JSC LIM, VOC LIM
         Voc vs T: K range below max
     """
     newGraphKwargs = copy.deepcopy(newGraphKwargs)
     newGraphKwargs.update({'silent': True})
-    
+
     print('Script process Jsc-Voc')
-    
+
     graph = Graph(file, **newGraphKwargs)
-    
-    print('WARNING: Cell area assumed to be', graph.curve(0).getArea(), 'cm-2.')
-    
-    lbl = graph.curve(0).getAttribute('label')
+
+    print('WARNING: Cell area assumed to be', graph[0].getArea(), 'cm-2.')
+
+    lbl = graph[0].attr('label')
     if len(lbl) > 1:
         graph.update({'title': lbl})
 
     labelT = graph.formatAxisLabel(['Temperature', 'T', 'K'])
     labelA = graph.formatAxisLabel(['Diode ideality factor', 'A', ''])
     label1000AT = graph.formatAxisLabel(['1000 / (A*Temperature)', '', 'K$^{-1}$'])
     labellnJ0 = graph.formatAxisLabel(['ln(J$_0$)', '', 'mAcm$^{-2}$'])
     labelVoc = graph.formatAxisLabel(['Voc', '', 'V'])
-    
+
     presets = {}
     presets.update({'default': {'ylim': '', 'xlim': '', 'alter': '',
                                 'typeplot': 'semilogy',
-                                'xlabel': graph.getAttribute('xlabel'),
-                                'ylabel': graph.getAttribute('ylabel')}})
+                                'xlabel': graph.attr('xlabel'),
+                                'ylabel': graph.attr('ylabel')}})
     presets.update({'ideality': {'ylim': '', 'xlim': '', 'alter': '',
-                                'typeplot': '',
-                                'xlabel': labelT,
-                                'ylabel': labelA}})
+                                 'typeplot': '',
+                                 'xlabel': labelT,
+                                 'ylabel': labelA}})
     presets.update({'J0vsAT': {'ylim': '', 'xlim': '',  'typeplot': '',
                                'alter': ['CurveArrhenius.x_1000overK', 'CurveArrhenius.y_Arrhenius'],
-                                'xlabel': label1000AT,
-                                'ylabel': labellnJ0}})
+                               'xlabel': label1000AT,
+                               'ylabel': labellnJ0}})
     presets.update({'VocvsT': {'ylim': '', 'xlim': [0, ''],  'typeplot': '',
                                'alter': '',
-                                'xlabel': labelT,
-                                'ylabel': labelVoc}})
+                               'xlabel': labelT,
+                               'ylabel': labelVoc}})
     # save
     folder = os.path.dirname(file)
-    filesave = os.path.join(folder, 'JscVoc_'+graph.getAttribute('title').replace(' ','_')+'_') # graphIO.filesave_default(self)
+    filesave = os.path.join(folder, 'JscVoc_'+graph.attr('title').replace(' ','_')+'_') # graphIO.filesave_default(self)
     print('filesave', filesave)
-    plotargs = {} # {'ifExport': False, 'ifSave': False}
+    plotargs = {}  # {'ifExport': False, 'ifSave': False}
     grap2 = copy.deepcopy(graph)
     # default graph: with fits
     graph.update(presets['default'])
-    Voclim = roundSignificantRange([0,   max(graph.curve(0).x())*1.01], 3)
-    Jsclim = roundSignificantRange([CurveJscVoc.CST_Jsclim0, max(graph.curve(0).y())*1.1],  2)
+    Voclim = roundSignificantRange([0,   max(graph[0].x())*1.01], 3)
+    Jsclim = roundSignificantRange([CurveJscVoc.CST_Jsclim0, max(graph[0].y())*1.1],  2)
     if ROIJsclim is not None:
         if isinstance(ROIJsclim, list):
             Jsclim = ROIJsclim
         elif is_number(ROIJsclim):
             Jsclim[0] = ROIJsclim
     if ROIVoclim is not None:
         if isinstance(ROIVoclim, list):
             Voclim = ROIVoclim
         elif is_number(ROIVoclim):
             Voclim[0] = ROIVoclim
     print('Fit J0, A: Voc limits', ', '.join(['{:.3f}'.format(v) for v in Voclim]), 'V')
     print('Fit J0, A: Jsc limits', ', '.join(['{:.2e}'.format(v) for v in Jsclim]), 'mAcm-2')
     for curve in GraphJscVoc.CurveJscVoc_fitNJ0(graph, Voclim, Jsclim, 3, True,
-                                                curve=graph.curve(0), silent=True):
+                                                curve=graph[0], silent=True):
         graph.append(curve)
     graph.plot(filesave=filesave+'fits', **plotargs)
     if pltClose:
         plt.close()
     # Graph ideality factor vs T
     grap2.update(presets['ideality'])
-    grap2.append(graph.curve(-3))
-    for c in range(grap2.length()):
-        grap2.curve(c).swapShowHide()
+    grap2.append(graph[-3])
+    for c in range(len(grap2)):
+        grap2[c].swapShowHide()
     grap2.plot(filesave=filesave+'IdealityvsT', **plotargs)
     if pltClose:
         plt.close()
     # Graph ideality factor vs T
     grap2.update(presets['J0vsAT'])
     grap2.deleteCurve(-1)
-    curve = graph.curve(-1)
+    curve = graph[-1]
     grap2.append(curve)
     curve.swapShowHide()
     ROI = list(roundSignificant([min(curve.x_1000overK())*0.95,
                                   1.05*max(curve.x_1000overK())], 4))
-    grap2.append(graph.curve(-1).CurveArrhenius_fit(ROI, silent=True))
-    Ea = grap2.curve(-1).getAttribute('_popt')[0]
-    grap2.curve(-1).update({'label': 'E$_a$ '+'{:1.3f}'.format(Ea)+' eV'})
+    grap2.append(graph[-1].CurveArrhenius_fit(ROI, silent=True))
+    Ea = grap2[-1].attr('_popt')[0]
+    grap2[-1].update({'label': 'E$_a$ '+'{:1.3f}'.format(Ea)+' eV'})
     grap2.plot(filesave=filesave+'J0vsAT', **plotargs)
     if pltClose:
         plt.close()
     # Voc vs T
     grap2.update(presets['VocvsT'])
-    grap2.deleteCurve(-1) # previous fit
-    grap2.deleteCurve(-1) # ln(Jo) vs A*T
+    grap2.deleteCurve(-1)  # previous fit
+    grap2.deleteCurve(-1)  # ln(Jo) vs A*T
     curve = grap2.curve(0)
     Tlim = [0.99*np.min(graph.curve(1).y()), 1.01*np.max(graph.curve(1).y())]
-    Tlim[0] = max(Tlim[0], Tlim[1] - 80) # restrict fit to highest 100K
+    Tlim[0] = max(Tlim[0], Tlim[1] - 80)  # restrict fit to highest 100K
     if ROITlim is not None:
         if isinstance(ROITlim, list):
             Tlim = ROITlim
         elif is_number(ROITlim):
             Tlim[0] = ROITlim
     print('Voc vs T: fit range restricted to', ', '.join(['{:.1f}'.format(T) for T in Tlim]), 'K')
     res = GraphJscVoc.splitIllumination(grap2, 3.0, True, Tlim, True, curve=curve, silent=True)
     grap2.append(res, idx=2)
     grap2.plot(filesave=filesave+'VocvsT', **plotargs)
     if pltClose:
         plt.close()
-    
+
     graph.curve(-1).swapShowHide()
     graph.curve(-3).swapShowHide()
-    print('WARNING: fits limits are chosen automatically. It is YOUR responsibility to check for the goodness of fit, and manually decide for the limits!')
+    print('WARNING: fits limits are chosen automatically. It is YOUR',
+          'responsibility to check for the goodness of fit, and manually',
+          'decide for the limits!')
     print('End of process Jsc-Voc.')
     return graph
-    
 
-    
+
 if __name__ == "__main__":
 
     file = './../examples/JscVoc/JscVoc_SAMPLE_c2_Values.txt'
     graph = script_processJscVoc(file, pltClose=False)
 
     plt.show()
-
```

### Comparing `grapa-0.5.4.8/grapa/scripts/script_processJV.py` & `grapa-0.6.1.0/grapa/scripts/script_processJV.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 # -*- coding: utf-8 -*-
 """
 @author: Romain Carron
-Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics, Romain Carron
+Copyright (c) 2018, Empa, Laboratory for Thin Films and Photovoltaics,
+Romain Carron
 """
 
 import numpy as np
 import os
 import sys
 
 import glob
@@ -16,183 +17,206 @@
 path = os.path.normpath(os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', '..'))
 if path not in sys.path:
     sys.path.append(path)
 
 from grapa.graph import Graph
 from grapa.graphIO import GraphIO
 from grapa.database import Database
-from grapa.mathModule import is_number, roundSignificant, stringToVariable
+from grapa.mathModule import is_number, roundSignificant, strToVar
 from grapa.colorscale import Colorscale
 from grapa.curve import Curve
 from grapa.curve_subplot import Curve_Subplot
 
 from grapa.datatypes.graphJV import GraphJV
 from grapa.datatypes.graphJVDarkIllum import GraphJVDarkIllum
 
 
 # prompt for folder
-def promptForFolder ():
+def promptForFolder():
     # Start->Execute, cmd, type "pip install tkinter"
     from tkinter.filedialog import askdirectory
     path = askdirectory()
     return path
 
 
-
 # auxiliary function
-def dictToListSorted (d) :
-    l = []
-    for key in d :
-        l.append(key)
-    l.sort()
-    return l
-
-# auxiliary class - add some useful tools to the database class
-class areaDB (Database) :
-    def __init__ (self, folder, sample) :
+def dictToListSorted(d):
+    lst = []
+    for key in d:
+        lst.append(key)
+    lst.sort()
+    return lst
+
+
+class areaDBHandler:
+    def __init__(self):
+        self._dict = {}
+
+    def get(self, p1, p2):
+        print('areaDBHandler', p1, p2)
+        if p1 not in self._dict:
+            self._dict.update({p1: {}})
+        if p2 not in self._dict[p1]:
+            self._dict[p1].update({p2: areaDB(p1, p2)})
+        return self._dict[p1][p2]
+
+
+#  auxiliary class - add some useful tools to the database class
+class areaDB(Database):
+
+    _NOTEXIST = []
+
+    def __init__(self, folder, sample):
         self.colIdx = 0
         self.folder = folder
         self.sample = sample
         # different possible names for area databases
         test = []
         test.append([os.path.join(folder, sample+'.txt'), ''])
         test.append([os.path.join(folder, sample+'_area.txt'), ''])
         test.append([os.path.join(folder, sample+'_areas.txt'), ''])
         test.append([os.path.join(folder, 'area.txt'), ''])
         test.append([os.path.join(folder, 'area.xlsx'), sample])
         test.append([os.path.join(folder, 'areas.txt'), ''])
         test.append([os.path.join(folder, 'areas.xlsx'), sample])
         self.flag = False
         self.flagCheat = False
-        for t in test :
-            print ('Area database: look in file ',t[0])
+        for t in test:
+            if t[0] in self._NOTEXIST:
+                continue
+            print('Area database: look in file ', t[0])
             graph = Graph(t[0], complement=t[1], silent=True, config=None)
-            if graph.length() == 0 :
+            if len(graph) == 0:
+                self._NOTEXIST.append(t[0])
                 continue
-            else :
-                try :
+            else:
+                try:
                     # try convert it in database
-                    Database.__init__ (self, graph)
+                    Database.__init__(self, graph)
                     # identify suitable column
-                    for col in self.colLabels :
-                        if col.find ('area') > -1 :
+                    for col in self.colLabels:
+                        if col.find('area') > -1:
                             self.colIdx = col
                     self.flag = True
-                    print ('   database file parsed and area identified.')
+                    print('   database file parsed and area identified.')
                 except Exception:
-                    print ('   database file data could not be interpreted correctly.')
-#                    print (e)
+                    print('   database file data could not be interpreted',
+                          'correctly.')
+                    self._NOTEXIST.append(t[0])
                     continue
-                break # break if success
-        if not self.flag :
-            print ('areaDB: cannot find area database file.')
+                break  # break if success
+        if not self.flag:
+            print('areaDB: cannot find area database file.')
 
-    def getArea (self, cell):
-        if not self.flag : # if database could not be opened
+    def getArea(self, cell):
+        if not self.flag:  # if database could not be opened
             if self.flagCheat:
                 if cell in self.data:
                     return self.data[cell]
             return np.nan
-        out = self.value (self.colIdx, cell)
-        if np.isnan (out) :
-            out = self.value (self.colIdx, self.sample+' '+cell)
-        if np.isnan (out) :
-            print ('areaDB getArea: row "', cell, '"not found (', self.rowLabels,')')
+        out = self.value(self.colIdx, cell)
+        if np.isnan(out):
+            out = self.value(self.colIdx, self.sample+' '+cell)
+        if np.isnan(out):
+            print('areaDB getArea: row "', cell, '"not found (',
+                  self.rowLabels, ')')
 #        print ('area cell',cell,':', out, '(',self.sample,')')
         return out
 
-    def setArea (self, cell, value):
+    def setArea(self, cell, value):
         if self.flag:
             self.setValue(self.colIdx, cell, value, silent=True)
         else:
             self.flagCheat = True
             if not hasattr(self, 'data'):
                 self.data = {}
             self.data.update({cell: value})
 
 
-
 # main function
-def processJVfolder (folder, ylim=[-50,150], sampleName='', fitDiodeWeight=0, groupCell=True, figAx=None, pltClose=True, newGraphKwargs={}):
-    print('Script processJV folder initiated. Data processing can last a few seconds.')
+def processJVfolder(folder, ylim=[-50,150], sampleName='', fitDiodeWeight=0, groupCell=True, figAx=None, pltClose=True, newGraphKwargs={}):
+    print('Script processJV folder initiated. Data processing can last a few',
+          'seconds.')
     newGraphKwargs = deepcopy(newGraphKwargs)
     newGraphKwargs.update({'silent': True})
     if figAx is not None:
         pltClose = False
     path = os.path.join(folder, '*.txt')
 
     cellDict = {}
     sampleAreaDict = {}
     outFlag = True
     out0 = ''
 
-    graph = Graph('', **newGraphKwargs)
-    graphAllJV = Graph('', **newGraphKwargs)
-
     for file in glob.glob(path):
         fileName, fileExt = os.path.splitext(file)
         fileExt = fileExt.lower()
         line1, line2, line3 = GraphIO.readDataFileLine123(filename=file)
-        if GraphJV.isFileReadable(fileName, fileExt, line1=line1, line2=line2, line3=line3):
+        if GraphJV.isFileReadable(fileName, fileExt, line1=line1, line2=line2,
+                                  line3=line3):
             try:
                 graphTmp = Graph(file, **newGraphKwargs)
-            except IndexError as e:
-                continue # next file
+            except IndexError:
+                continue  # next file
         else:
             continue
         try:
-            sample = graphTmp.curve(-1).sample()
-            cell   = graphTmp.curve(-1).cell()
-            dark   = graphTmp.curve(-1).darkOrIllum (ifText=True)
-            measId = graphTmp.curve(-1).measId()
+            sample = graphTmp[-1].sample()
+            cell = graphTmp[-1].cell()
+            dark = graphTmp[-1].darkOrIllum(ifText=True)
+            measId = graphTmp[-1].measId()
         except Exception:
-            continue # go to next file
+            continue  # go to next file
 
-        print ('File', os.path.basename(file))
+        print('File', os.path.basename(file))
         if sample == '' or cell == '':
-            print('WARNING: cannot identify sample (', sample, ') or cell (', cell, ').')
+            print('WARNING: cannot identify sample (', sample, ') or cell (',
+                  cell, ').')
 
-        if sample != '' and cell != '' :
+        areaHandler = areaDBHandler()
+        if sample != '' and cell != '':
             if sample not in cellDict:
-                cellDict.update ({sample: {}})
+                cellDict.update({sample: {}})
             if cell not in cellDict[sample]:
-                cellDict[sample].update ({cell: {}})
+                cellDict[sample].update({cell: {}})
             if dark not in cellDict[sample][cell]:
-                cellDict[sample][cell].update ({dark: {}})
+                cellDict[sample][cell].update({dark: {}})
             if sample not in sampleAreaDict:
-                sampleAreaDict.update ({sample: areaDB(folder, sample)})
+                sampleAreaDict.update({sample: areaHandler.get(folder, sample)})
             # open JV file again to correct for cell area
             area = sampleAreaDict[sample].getArea(cell)
-            if np.isnan(area) and is_number(graphTmp.curve(0).getAttribute('Acquis soft Cell area')) and not np.isnan(graphTmp.curve(0).getAttribute('Acquis soft Cell area')):
-                sampleAreaDict[sample].setArea(cell, graphTmp.curve(0).getAttribute('Acquis soft Cell area'))
+            if np.isnan(area) and is_number(graphTmp[0].attr('Acquis soft Cell area')) and not np.isnan(graphTmp[0].attr('Acquis soft Cell area')):
+                sampleAreaDict[sample].setArea(cell, graphTmp[0].attr('Acquis soft Cell area'))
                 area = sampleAreaDict[sample].getArea(cell)
             cellDict[sample][cell][dark].update({measId: file})
-            print (sample, 'cell', cell, 'area', area, 'cm2 (acquired as', graphTmp.curve(0).getAttribute('Acquis soft Cell area'), ')')
+            print('   ', sample, 'cell', cell, 'area', area, 'cm2 (acquired',
+                  'as', graphTmp[0].attr('Acquis soft Cell area'), ')')
 
-        if outFlag :
-            out0 = out0 + graphTmp.curve(-1).printShort(header=True)
+        if outFlag:
+            out0 = out0 + graphTmp[-1].printShort(header=True)
             outFlag = False
 
-
     # sweep through files, identify pairs
     listSample = dictToListSorted(cellDict)
-    for s in listSample :
+    for s in listSample:
+        graphAllJV = Graph('', **newGraphKwargs)
+
         s_str = 'Sample '+str(s) if is_number(s) else str(s)
         out      = 'Sample\t' + s_str + '\n' + 'label\t' + s_str.replace('_','\\n') + '\n' + deepcopy(out0)
         outIllum = 'Sample\t' + s_str + '\n' + 'label\t' + s_str.replace('_','\\n') + '\n' + deepcopy(out0)
         outDark  = 'Sample\t' + s_str + '\n' + 'label\t' + s_str.replace('_','\\n') + '\n' + deepcopy(out0)
         listCell = dictToListSorted(cellDict[s])
-        for c in listCell :
+        for c in listCell:
             listDarkIllum = dictToListSorted(cellDict[s][c])
             # if want to process each emasureemnt independently
             if not groupCell:
                 for d in listDarkIllum:
                     listGraph = dictToListSorted(cellDict[s][c][d])
                     for m in listGraph:
-                        filesave = 'export_' + s + '_' + c + '_' + m + ('_'+d).replace('_illum','')
+                        filesave = 'export_'+s+'_'+c+'_'+m+('_'+d).replace('_illum','')
                         print('Graph saved as', filesave)
                         graph = GraphJVDarkIllum(cellDict[s][c][d][m], '', area=sampleAreaDict[s].getArea(c), complement={'ylim':ylim, 'saveSilent': True, '_fitDiodeWeight': fitDiodeWeight}, **newGraphKwargs)
                         out = out + graph.printShort()
                         filesave = os.path.join(folder, filesave)
                         graph.plot(filesave, figAx=figAx, pltClose=pltClose)
                         graphAllJV.append(graph.returnDataCurves())
             else:
@@ -200,35 +224,36 @@
                 if len(listDarkIllum) > 2:
                     print('test WARNING sorting JV files.')
                 # only dark on only illum measurement
                 if len(listDarkIllum) == 1:
                     d = listDarkIllum[0]
                     listGraph = dictToListSorted(cellDict[s][c][d])
                     m = listGraph[0]
-                    filesave = 'export_' + s + '_' + c + '_' + m + ('_'+d).replace('_illum', '')
+                    filesave = 'export_'+s+'_'+c+'_'+m+('_'+d).replace('_illum', '')
                     print('Graph saved as', filesave)
                     fileDark = cellDict[s][c][d][m] if listDarkIllum[0] == 'dark'  else ''
-                    fileIllum= cellDict[s][c][d][m] if listDarkIllum[0] == 'illum' else ''
+                    fileIllum = cellDict[s][c][d][m] if listDarkIllum[0] == 'illum' else ''
                     # create Graph file
                     graph = GraphJVDarkIllum(fileDark, fileIllum, area=sampleAreaDict[s].getArea(c), complement={'ylim':ylim, 'saveSilent': True, '_fitDiodeWeight': fitDiodeWeight}, **newGraphKwargs)
                     filesave = os.path.join(folder, filesave)
-                    graph.plot(filesave=filesave, figAx=figAx, pltClose=pltClose)
+                    graph.plot(filesave=filesave, figAx=figAx,
+                               pltClose=pltClose)
                     # prepare output summary files
                     out = out + graph.printShort()
                     if listDarkIllum[0] == 'dark':
-                        outDark  = outDark  + graph.printShort()
-                    else :
+                        outDark = outDark  + graph.printShort()
+                    else:
                         outIllum = outIllum + graph.printShort()
-                    #if len(listGraph) > 1 :
+                    # if len(listGraph) > 1 :
                     #    msg = '.'.join([cellDict[s][c][d][m2] for m2 in cellDict[s][c][d]][1:])
                     #    print ('test WARNING: other files ignored (,',msg,')')
                     graphAllJV.append(graph.returnDataCurves())
 
                 # can identify pair of dark-illum files
-                if len(listDarkIllum) == 2 :
+                if len(listDarkIllum) == 2:
                     listGraph = dictToListSorted(cellDict[s][c][listDarkIllum[0]])
                     filesave = 'export_' + s + '_' + c + '_' + listGraph[0]
                     fileDark = cellDict[s][c][listDarkIllum[0]][listGraph[0]]
 
                     listGraph = dictToListSorted(cellDict[s][c][listDarkIllum[1]])
                     filesave = filesave + '-' + listGraph[0]
                     fileIllum = cellDict[s][c][listDarkIllum[1]][listGraph[0]]
@@ -252,65 +277,62 @@
             plt.close()
         # print sample summary
         filesave = 'export_' + s + '_summary' + '.txt'
         filesave = os.path.join(folder, filesave)
         # print('End of JV curves processing, showing summary file...')
         # print(out)
         print('Summary saved in file', filesave, '.')
-        f = open(filesave, 'w')
-        f.write(out)
-        f.close()
+        with open(filesave, 'w') as f:
+            f.write(out)
         if groupCell:
             filesave = 'export_' + s + '_summary_dark' + '.txt'
             filesave = os.path.join(folder, filesave)
-            f = open(filesave, 'w')
-            f.write(outDark)
-            f.close()
+            with open(filesave, 'w') as f:
+                f.write(outDark)
             processSampleCellsMap(filesave, figAx=figAx, pltClose=pltClose)
             filesave = 'export_' + s + '_summary_illum' + '.txt'
             filesave = os.path.join(folder, filesave)
-            f = open(filesave, 'w')
-            f.write(outIllum)
-            f.close()
+            with open(filesave, 'w') as f:
+                f.write(outIllum)
             processSampleCellsMap(filesave, figAx=figAx, pltClose=pltClose)
             writeFileAvgMax(filesave, filesave=True, ifPrint=True)
     print('Script processJV folder done.')
-    # print(type(graph), graph)
+    # print('return graph', type(graph), graph)
     # Graph.plot(graph, os.path.join(folder, 'export_test'))
     return graph
 
 
 def writeFileAvgMax(fileOrContent, filesave=False, withHeader=True, colSample=True, ifPrint=True):
     colOfInterest = ['Voc', 'Jsc', 'FF', 'Eff']
     if isinstance(fileOrContent, Graph):
         content = fileOrContent
-        filename = content.getAttribute('sample').replace('\n', '')
+        filename = content.attr('sample').replace('\n', '')
         if filename == '':
-            filename = content.getAttribute('label')
+            filename = content.attr('label')
     else:
         content = Graph(fileOrContent)
         filename = fileOrContent
 #    print(content)
     # identify columns of interest
-    colLbl = content.getAttribute('collabels')
+    colLbl = content.attr('collabels')
     cols = []
     idxs = []
     for c in colOfInterest:
         cols.append([np.nan])
         idxs.append(np.nan)
         for i in range(len(colLbl)):
             if c in colLbl[i]:
-                cols[-1] = content.curve(i).y()
+                cols[-1] = content[i].y()
                 idxs[-1] = i
     # start to compile output in variable out
     out = ''
     if withHeader:
         if not colSample:
             out += 'filename\t' + filename + '\n'
-            out += 'Sample\t' + content.getAttribute('sample') + '\n'
+            out += 'Sample\t' + content.attr('sample') + '\n'
         if colSample:
             out += '\t'
         # column headers
         out += 'Best cell (eff.)' + '\t'*len(colOfInterest)
         out += 'Parameter average' + '\t'*len(colOfInterest)
         out += 'Parameter median' + '\t'*len(colOfInterest)
         out += '\n'
@@ -319,27 +341,30 @@
             out += 'Sample\t'
         for i in range(3):
             for c in idxs:
                 out += (colLbl[c] if c is not np.isnan(c) else '') + '\t'
         out += '\n'
     # sample name
     if colSample:
-        samplename = 'SOMETHING'
+        samplename = 'DEFAULT'
         if 'sample' in content.headers:
             samplename = content.headers['sample']
-        elif content.curve(-1).getAttribute('sample name', None) is not None:
-            samplename = content.curve(-1).getAttribute('sample name')
-            if isinstance(samplename, list):
-                samplename = str(samplename[0])
+        elif content[-1].attr('sample name', None) is not None:
+            samplename = content[-1].attr('sample name')
+        elif content[-1].attr('label', None) is not None:
+            samplename = content[-1].attr('label')
+        if isinstance(samplename, list):
+            samplename = str(samplename[0])
+        samplename = samplename.replace('\n', ' ')
         out += samplename + '\t'
     # best cell
     eff = None
     for i in range(len(colLbl)):
         if 'Eff' in colLbl[i]:
-            eff = content.curve(i).y()
+            eff = content[i].y()
     if eff is not None:
         idx = np.argmax(eff)
         for c in cols:
             out += str(c[idx]) + '\t'
     else:
         print('Could not find column Eff')
     # averages
@@ -349,37 +374,37 @@
     for c in cols:
         out += str(np.median(c)) + '\t'
     # new line
     out += '\n'
     # maybe save result in a file
     if isinstance(filename, str) and filesave is True:
         fname = filename.replace('.txt', '_avgmax.txt')
-        f = open(fname, 'w')
-        f.write(out)
-        f.close()
+        with open(fname, 'w') as f:
+            f.write(out)
     if ifPrint:
         print(out)
+    return out
 
 
 def processSampleCellsMap(file, colorscale=None, figAx=None, pltClose=True, newGraphKwargs={}):
     newGraphKwargs = deepcopy(newGraphKwargs)
     newGraphKwargs.update({'silent': True})
 
     content = Graph(file, **newGraphKwargs)
     colToPlot = ['Voc', 'Jsc', 'FF', 'Eff', 'Rp', 'Rs', 'n', 'J0']
     inveScale = [False, False, False, False, False, True, True, True]  # inverted color scale
-    cols = content.getAttribute('collabels')
-    rows = content.getAttribute('rowlabels')
+    cols = content.attr('collabels')
+    rows = content.attr('rowlabels')
     if not isinstance(cols, list):
         print('Error processSampleCellsMap: cols is not a list (value', cols, ')')
     if colorscale is None:
-        if content.getAttribute('colorscale', None) is not None:
-            colorscale = content.getAttribute('colorscale')
-        if content.getAttribute('cmap', None) is not None:
-            colorscale = content.getAttribute('cmap')
+        if content.attr('colorscale', None) is not None:
+            colorscale = content.attr('colorscale')
+        if content.attr('cmap', None) is not None:
+            colorscale = content.attr('cmap')
     filelist = []
     # combined plot
     graphs = [Graph('', **newGraphKwargs), Graph('', **newGraphKwargs)]
     axisheights = [[], []]
     # main loop
     for i in range(len(colToPlot)):
         look = colToPlot[i]
@@ -388,108 +413,119 @@
             c = cols[j]
             if c[:len(look)] == look and (len(c) <= len(look) or c[len(look)] in [' ','_','-','.','[',']','(',')']):
                 c = c.replace('_', ' [').replace('(', '[')
                 if '[' in c and ']' not in c:
                     c += ']'
                 c = c.replace('[pc]', '[%]').replace('mApcm2', 'mA/cm2')
                 # sort somehow identical cells?
-                vals = content.curve(j).y()
+                vals = content[j].y()
                 filesave = '.'.join(file.split('.')[:-1]) + '_' + look
                 filelist.append(filesave + '.txt')
 
                 res = plotSampleCellsMap(rows, vals, c, colorscale=colorscale, filesave=filesave, figAx=figAx, inverseScale=inveScale[i], pltClose=pltClose)
 
-                if isinstance(res, Graph) and res.length() > 0:
+                if isinstance(res, Graph) and len(res) > 0:
                     AB = 0 if i < 4 else 1
-                    graphs[AB].append(Curve_Subplot([[0],[0]], {'subplotfile': res.getAttribute('filesave')+'.txt'}))
-                    figsize = res.getAttribute('figsize', [6,4])
-                    sadjust = res.getAttribute('subplots_adjust', [0.1,0.1,0.9,0.9])
-                    graphs[AB].update({'figsize': figsize, 'subplots_adjust': sadjust})
+                    graphs[AB].append(Curve_Subplot([[0], [0]], {'subplotfile': res.attr('filesave')+'.txt'}))
+                    figsize = res.attr('figsize', [6, 4])
+                    sadjust = res.attr('subplots_adjust', [0.1, 0.1, 0.9, 0.9])
+                    graphs[AB].update({'figsize': figsize,
+                                       'subplots_adjust': sadjust})
                     axisheights[AB].append(figsize[1] * (sadjust[3]-sadjust[1]))
                 colFound = True
                 break
         if not colFound:
-            print('Warning processSampleCellsMap: column not found (',look,' or similar)')
+            print('Warning processSampleCellsMap: column not found (', look,
+                  ' or similar)')
     # set correct graph size for compiled graph
     bottom, top, hspace = 0.5, 0.5, 0.5
     totalh = [(sum(tmp) + (len(tmp)-1)*hspace + bottom + top) for tmp in axisheights]
     for i in range(2):
-        figsize = graphs[i].getAttribute('figsize', None)
-        sadjust = graphs[i].getAttribute('subplots_adjust')
+        figsize = graphs[i].attr('figsize', None)
+        sadjust = graphs[i].attr('subplots_adjust')
         if figsize is not None:  # if not already set means nothing to show
             attr = {'figsize': [figsize[0], totalh[i]]}
-            attr.update({'subplots_adjust': [sadjust[0], bottom/totalh[i], sadjust[2], 1-top/totalh[i], 0, hspace/axisheights[i][0]]})
-            attr.update({'subplotsncols': 1, 'subplotsheight_ratios': axisheights[i]})
+            attr.update({'subplots_adjust': [sadjust[0], bottom/totalh[i], sadjust[2], 1-top/totalh[i], 0, hspace/axisheights[i][0]],
+                         'subplotsncols': 1,
+                         'subplotsheight_ratios': axisheights[i]})
             graphs[i].update(attr)
-            filesave = '.'.join(file.split('.')[:-1]) + '_' + ['basic','diode'][i]
+            filesave = '.'.join(file.split('.')[:-1]) + '_' + ['basic', 'diode'][i]
             graphs[i].filename = filesave
             graphs[i].plot(filesave=filesave, figAx=figAx)
     return filelist
 
 
 def plotSampleCellsMap(cells, values, title, colorscale=None, filesave='', figAx=None, inverseScale=False, pltClose=True, newGraphKwargs={}):
     sizeCell = np.array([0.6, 0.6])
-    margin   = np.array([0.4, 0.4])
+    margin = np.array([0.4, 0.4])
 
     newGraphKwargs = deepcopy(newGraphKwargs)
     newGraphKwargs.update({'silent': True})
 
     if len(values) == 0:
         return False
 
     # check cells are with correct form, i.e. 'a1'
     x, y, val = [], [], []
     split = [research(r'([a-zA-Z])([0-9]*)', c).groups() for c in cells]
     for i in range(len(split)):
         if len(split[i]) == 2:
             x.append(float(ord(split[i][0].lower())-96))
             y.append(float(split[i][1]))
-            val.append(values[i])  # prefer to work on a copy and not modifying the list values
+            # prefer to work on a copy and not modifying the list values
+            val.append(values[i])
     x, y, val = np.array(x), np.array(y), np.array(val)
     if title == 'Voc [V]':
         title = 'Voc [mV]'
         val *= 1000
-    title = title.replace('Voc_V','Voc [V]').replace('Jsc_mApcm2','Jsc [mA/cm2]').replace('FF_pc','FF [%]').replace('Eff_pc','Eff. [%]').replace('_Ohmcm2',' [Ohmcm2]')
-    title = title.replace('A/cm2', 'A cm$^{-2}$').replace('J0 ','J$_0$ ').replace('Ohmcm2', '$\Omega$ cm$^2$')
+    title = title.replace('Voc_V', 'Voc [V]').replace('Jsc_mApcm2', 'Jsc [mA/cm2]').replace('FF_pc', 'FF [%]').replace('Eff_pc', 'Eff. [%]').replace('_Ohmcm2', ' [Ohmcm2]')
+    title = title.replace('A/cm2', 'A cm$^{-2}$').replace('J0 ', 'J$_0$ ').replace('Ohmcm2', '$\Omega$ cm$^2$')
 
     valNorm = val if not (val==0).all() and not len(val)==1 else [0.5]*len(val)
     if isinstance(colorscale, Colorscale):
         colorscale = colorscale.getColorScale()
-    if isinstance(colorscale, str): # 'autumn' is a string, but a color list might not have been recognized as a list
-        colorscale = stringToVariable(colorscale)
+    if isinstance(colorscale, str):  # 'autumn' is a string, but a color list might not have been recognized as a list
+        colorscale = strToVar(colorscale)
     if colorscale is None:
-        colorscale = [[1,0,0], [1,1,0.5], [0,1,0]]
+        colorscale = [[1, 0, 0], [1, 1, 0.5], [0, 1, 0]]
     if inverseScale and isinstance(colorscale, list):
         colorscale = colorscale[::-1]
 
-    xticks = np.arange(0,max(x)+1, 1) # if max(x) > 6 else np.arange(0,max(x)+1,1)
-    yticks = np.arange(0,max(y)+1, 1)
+    xticks = np.arange(0, max(x)+1, 1)  # if max(x) > 6 else np.arange(0,max(x)+1,1)
+    yticks = np.arange(0, max(y)+1, 1)
     axSize = np.array([sizeCell[0]*(max(xticks)-min(xticks)), sizeCell[1]*(max(yticks)-min(yticks))])
     figSize = axSize + 2 * margin[1]
     marg = margin / figSize
     txtCoords = np.transpose([(x - 0.5 - min(xticks)) / (max(xticks) - min(xticks)), (y - 0.5 - min(yticks)) / (max(yticks) - min(yticks))])
     toPrint = [roundSignificant(v, 3) for v in val]
     if np.average(val) > 1e2:
         toPrint = ['{:1.0f}'.format(v) for v in toPrint]
     if np.average(val) < 1e-3:
-        toPrint = ['{:.1E}'.format(v).replace('E-0','E-') for v in toPrint]
+        toPrint = ['{:.1E}'.format(v).replace('E-0', 'E-') for v in toPrint]
     graph = Graph('', **newGraphKwargs)
     texttxt = []
     textarg = []
     for i in range(len(val)):
         texttxt.append(toPrint[i])
-        textarg.append({'xytext': list(txtCoords[i]), 'xycoords': 'axes fraction', 'horizontalalignment':'center', 'verticalalignment':'center'})
-    graph.append(Curve([x-0.5, y-0.5], {'type': 'scatter', 'marker': 's', 'markersize': (sizeCell[0]*72)**2, 'markeredgewidth': 0, 'cmap': colorscale}))#cmapParam
+        textarg.append({'xytext': list(txtCoords[i]),
+                        'xycoords': 'axes fraction',
+                        'horizontalalignment': 'center',
+                        'verticalalignment': 'center'})
+    graph.append(Curve([x-0.5, y-0.5], {'type': 'scatter', 'marker': 's',
+                                        'markersize': (sizeCell[0]*72)**2,
+                                        'markeredgewidth': 0,
+                                        'cmap': colorscale}))
     graph.append(Curve([x-0.5, valNorm], {'type': 'scatter_c'}))
 
-    graph.update({'subplots_adjust':[marg[0], marg[1], 1-marg[0], 1-marg[1]]})
-    graph.update({'figSize': list(figSize)})
-    graph.update({'text': texttxt, 'textargs': textarg})
-    graph.update({'title': graph.formatAxisLabel(title)})
-    graph.update({'xlim': [min(xticks), max(xticks)], 'ylim': [min(yticks), max(yticks)]})
+    graph.update({'subplots_adjust': [marg[0], marg[1], 1-marg[0], 1-marg[1]],
+                  'figSize': list(figSize),
+                  'text': texttxt, 'textargs': textarg,
+                  'title': graph.formatAxisLabel(title),
+                  'xlim': [min(xticks), max(xticks)],
+                  'ylim': [min(yticks), max(yticks)]})
     fct = []
     fct.append(['set_xticks', [list(xticks)], {}])
     fct.append(['set_yticks', [list(yticks)], {}])
     fct.append(['set_xticklabels', [[]], {}])
     fct.append(['set_yticklabels', [[]], {}])
     fct.append(['set_xticks', [list(xticks[1:]-0.5)], {'minor':True}])
     fct.append(['set_yticks', [list(yticks[1:]-0.5)], {'minor':True}])
@@ -513,11 +549,10 @@
 if __name__ == "__main__":
     # go through files, store files content in order to later select pairs
     folder = './../examples/JV/SAMPLE_A/'
     processJVfolder(folder, fitDiodeWeight=5, pltClose=True,  groupCell=True)
 #    processJVfolder(folder, groupCell=True, fitDiodeWeight=5, pltClose=False)
 
 
-
     file = r'./../examples/JV\SAMPLE_B_3layerMo\export_sample_b_3layermo_summary_illum.txt'
 #    processSampleCellsMap(file, pltClose=False)
 #    writeFileAvgMax(file)
```

### Comparing `grapa-0.5.4.8/grapa/versionNotes.txt` & `grapa-0.6.1.0/grapa/versionNotes.txt`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,56 @@
 TFPV data reading software
 GRAPA: GRAphing and Photovoltaics Analysis
 
+KNOWND BUGS
+- A few are there for sure, please feel free to announce them.
 
-WISH LIST
 
-- BB extract CdS thickness from EQE
-- RC set police fonts
-- RC create class for curve action, able to configure withs of individual fields and remove complexity from GUI
-- RC continue with documentation
 
-KNOWN BUGS
-- Conversion warning when opening HR2000 files -> does not seem to cause problem
+Version 0.6.1.0 (current development)
+Released 19.04.2023
+Features
+- GUI: it is not possible to open several files at once (finally!)
+- Axis labels and graph title can now be entered as ['Quantity', 'symbol', 'unit'], with optional formatting additional dict element
+- File format: grapa can now open JV files from Ossila sofware, rather primitive data parser.
+- File format: grapa can now extract data from a certain .spe file format containing XRF data. The data parser is very primitive.
+- Curve EQE current integration: added a checkbox to show the cumulative current sum.
+- Curve Math: can now assemble a new Curve based on user-selected x and y data series of same length available within current Graph object.
+- Curve JV: the code should now be insensitive to sorting of input data (extraction of parameters is done on a sorted copy of the data)
+- Curve TRPL fit procedure: recondition the fitting problem, the fitting should be more robust and less prone to reaching max iterations
+- Curve XRF MCA: retro-compatiblity of element labelling features
+- Curve XRF: does not anymore overwrite spectral calibration if already set
+General
+- Ensured forward compatibility up to Winpython 3.10.40
+Bugs correction
+- Curve JV, can read date time.
+
+
+
+Version 0.6.0.0
+Released 20.05.2022
+Additions
+- Main GUI now handles several graphs at the same time, thanks to a tab mechanism. Hope this will be useful!
+- Change in handling of escape sequences: \n, \t, etc. Should be compatible with some special characters with different charsets (e.g. alt+230 "" in both ascii and utf-8 file encoding) and latex commands with 2 backslashes (e.g. "\\alpha"). "\alpha" would fail due to the escaped "\a" special character, but "\gamma" should succeed). Possible loss of compatiblity with previous graphs, esp. with latex symbols - hence, new major version number.
+- Axis limits: when axes limits cannot be computed with data transforms, the user input is used to set the axis limit. It is now possible to define axes limit values, when previously this could not be done. The default behavior remains that the user input for axis limits are transformed the same way as the plotted data.
+- Popup Annotations: added a vertical scrollbar, changed the order of displayed elements
+- scriptCV: The warnings are collected and reported at the end. Also, more robust processing of input files with slightly different formatting.
+- CurveSpectrum: added correction function instrumental response 800nm
+- CurveEQE: added an additional reference EQE spectrum (Empa PI 20.8%). The data loading mechanisms is modified and new reference spectra are now easy to add - see file datatypes/EQE_referenceSpectra.
+- CurveXRF: added an annotation function to place labels for peak intensities according to the database https://xdb.lbl.gov/Section1/Table_1-3.pdf.
+- CurveXRF: improved the loading of experiemntal parameters. The data are now stored inthe Curve where they belong
+- CurveSIMS: add function to crop data inside ROI
+- CurveTRPL: fitted curves can now be normalized with same parameters as the input data
+- CurveArrhenius: added possibility to fit using a power law
+- GUI: a major rework of the organisation of the GUI code. Possibilities to hide different panels. Little visible changes, but many possibilities for new bugs. Please let me know if you notice any!
+Bugs
+- Solved a certain number of those. Did not keep track.
+- scriptJV: solved a bug with _JVall when processing several samples simultaneously
+- Certainly added quite a few new bugs. Enjoy, my pleasure
+
 
 
 Version 0.5.4.8
 Released 24.03.2021
 Modifications
 - TRPL: the data type TRPL was  modified to properly load files generated using
   scripts.
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `grapa-0.5.4.8/LICENSE` & `grapa-0.6.1.0/LICENSE`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 MIT License
 
-Copyright (c) 2018 Romain Carron (Empa, Laboratory for Thin Films and Photovoltaics)
+Copyright (c) 2023 Romain Carron (Empa, Laboratory for Thin Films and Photovoltaics)
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
```

### Comparing `grapa-0.5.4.8/setup.py` & `grapa-0.6.1.0/setup.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 from setuptools import setup
 
 setup(
     name='grapa',
-    version='0.5.4.8',
+    version='0.6.1.0',
     description='Grapa - graphing and photovoltaics analysis',
     author='Romain Carron',
     author_email='carron.romain@gmail.com',
     install_requires=[
         'numpy',
         'matplotlib',
         'scipy',
```

