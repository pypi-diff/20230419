# Comparing `tmp/pulumi_akamai-4.4.0a1680909501.tar.gz` & `tmp/pulumi_akamai-4.4.0a1681843117.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "pulumi_akamai-4.4.0a1680909501.tar", last modified: Fri Apr  7 23:29:15 2023, max compression
+gzip compressed data, was "pulumi_akamai-4.4.0a1681843117.tar", last modified: Tue Apr 18 18:43:52 2023, max compression
```

## Comparing `pulumi_akamai-4.4.0a1680909501.tar` & `pulumi_akamai-4.4.0a1681843117.tar`

### file list

```diff
@@ -1,240 +1,243 @@
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 23:29:15.454178 pulumi_akamai-4.4.0a1680909501/
--rw-r--r--   0 runner    (1001) docker     (123)     2462 2023-04-07 23:29:15.454178 pulumi_akamai-4.4.0a1680909501/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)     2119 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/README.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 23:29:15.450178 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/
--rw-r--r--   0 runner    (1001) docker     (123)    26786 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)   428597 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/_inputs.py
--rw-r--r--   0 runner    (1001) docker     (123)     8081 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/_utilities.py
--rw-r--r--   0 runner    (1001) docker     (123)    32659 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_activations.py
--rw-r--r--   0 runner    (1001) docker     (123)    14617 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_advanced_settings_evasive_path_match.py
--rw-r--r--   0 runner    (1001) docker     (123)    14661 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_advanced_settings_logging.py
--rw-r--r--   0 runner    (1001) docker     (123)    16407 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_advanced_settings_pragma_header.py
--rw-r--r--   0 runner    (1001) docker     (123)    22097 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_advanced_settings_prefetch.py
--rw-r--r--   0 runner    (1001) docker     (123)    13130 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_api_constraints_protection.py
--rw-r--r--   0 runner    (1001) docker     (123)    16126 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_api_request_constraints.py
--rw-r--r--   0 runner    (1001) docker     (123)    20044 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_attack_group.py
--rw-r--r--   0 runner    (1001) docker     (123)    14031 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_by_pass_network_list.py
--rw-r--r--   0 runner    (1001) docker     (123)    25223 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_configuration.py
--rw-r--r--   0 runner    (1001) docker     (123)    11425 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_configuration_rename.py
--rw-r--r--   0 runner    (1001) docker     (123)    11413 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_custom_deny.py
--rw-r--r--   0 runner    (1001) docker     (123)    11369 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_custom_rule.py
--rw-r--r--   0 runner    (1001) docker     (123)    16897 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_custom_rule_action.py
--rw-r--r--   0 runner    (1001) docker     (123)    28244 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_eval.py
--rw-r--r--   0 runner    (1001) docker     (123)    19048 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_eval_group.py
--rw-r--r--   0 runner    (1001) docker     (123)    18394 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_eval_penalty_box.py
--rw-r--r--   0 runner    (1001) docker     (123)    19353 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_eval_rule.py
--rw-r--r--   0 runner    (1001) docker     (123)    25312 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_ip_geo.py
--rw-r--r--   0 runner    (1001) docker     (123)    14349 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_ip_geo_protection.py
--rw-r--r--   0 runner    (1001) docker     (123)    13207 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_malware_policy.py
--rw-r--r--   0 runner    (1001) docker     (123)    21247 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_malware_policy_action.py
--rw-r--r--   0 runner    (1001) docker     (123)    15499 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_malware_policy_actions.py
--rw-r--r--   0 runner    (1001) docker     (123)    14147 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_malware_protection.py
--rw-r--r--   0 runner    (1001) docker     (123)    11391 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_match_target.py
--rw-r--r--   0 runner    (1001) docker     (123)    12689 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_match_target_sequence.py
--rw-r--r--   0 runner    (1001) docker     (123)    17667 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_penalty_box.py
--rw-r--r--   0 runner    (1001) docker     (123)    11734 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_rate_policy.py
--rw-r--r--   0 runner    (1001) docker     (123)    21193 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_rate_policy_action.py
--rw-r--r--   0 runner    (1001) docker     (123)    13945 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_rate_protection.py
--rw-r--r--   0 runner    (1001) docker     (123)    12697 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_reputation_profile.py
--rw-r--r--   0 runner    (1001) docker     (123)    17334 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_reputation_profile_action.py
--rw-r--r--   0 runner    (1001) docker     (123)    17706 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_reputation_profile_analysis.py
--rw-r--r--   0 runner    (1001) docker     (123)    14893 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_reputation_protection.py
--rw-r--r--   0 runner    (1001) docker     (123)    18806 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_rule.py
--rw-r--r--   0 runner    (1001) docker     (123)    17928 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_rule_upgrade.py
--rw-r--r--   0 runner    (1001) docker     (123)    21191 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_security_policy.py
--rw-r--r--   0 runner    (1001) docker     (123)    11690 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_security_policy_rename.py
--rw-r--r--   0 runner    (1001) docker     (123)    14931 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_selected_hostnames.py
--rw-r--r--   0 runner    (1001) docker     (123)    22148 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_siem_settings.py
--rw-r--r--   0 runner    (1001) docker     (123)    22801 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_slow_post.py
--rw-r--r--   0 runner    (1001) docker     (123)    14503 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_slow_post_protection.py
--rw-r--r--   0 runner    (1001) docker     (123)    13336 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_threat_intel.py
--rw-r--r--   0 runner    (1001) docker     (123)    11301 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_version_nodes.py
--rw-r--r--   0 runner    (1001) docker     (123)    20065 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_waf_mode.py
--rw-r--r--   0 runner    (1001) docker     (123)    13947 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_waf_protection.py
--rw-r--r--   0 runner    (1001) docker     (123)    14736 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_wap_selected_hostnames.py
--rw-r--r--   0 runner    (1001) docker     (123)    15891 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/appsec_advanced_settings_attack_payload_logging.py
--rw-r--r--   0 runner    (1001) docker     (123)    26607 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/cloudlets_application_load_balancer.py
--rw-r--r--   0 runner    (1001) docker     (123)    15424 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/cloudlets_application_load_balancer_activation.py
--rw-r--r--   0 runner    (1001) docker     (123)    26019 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/cloudlets_policy.py
--rw-r--r--   0 runner    (1001) docker     (123)    18930 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/cloudlets_policy_activation.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 23:29:15.450178 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/config/
--rw-r--r--   0 runner    (1001) docker     (123)      285 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/config/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    11104 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/config/outputs.py
--rw-r--r--   0 runner    (1001) docker     (123)     2081 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/config/vars.py
--rw-r--r--   0 runner    (1001) docker     (123)    23282 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/cp_code.py
--rw-r--r--   0 runner    (1001) docker     (123)    71166 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/cps_dv_enrollment.py
--rw-r--r--   0 runner    (1001) docker     (123)    11449 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/cps_dv_validation.py
--rw-r--r--   0 runner    (1001) docker     (123)    66298 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/cps_third_party_enrollment.py
--rw-r--r--   0 runner    (1001) docker     (123)    33358 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/cps_upload_certificate.py
--rw-r--r--   0 runner    (1001) docker     (123)    84268 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/datastream.py
--rw-r--r--   0 runner    (1001) docker     (123)    78637 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/dns_record.py
--rw-r--r--   0 runner    (1001) docker     (123)    28087 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/dns_zone.py
--rw-r--r--   0 runner    (1001) docker     (123)    35406 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/edge_host_name.py
--rw-r--r--   0 runner    (1001) docker     (123)    23849 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/edge_kv.py
--rw-r--r--   0 runner    (1001) docker     (123)    17508 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/edge_worker.py
--rw-r--r--   0 runner    (1001) docker     (123)    13373 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/edge_workers_activation.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 23:29:15.450178 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/edgedns/
--rw-r--r--   0 runner    (1001) docker     (123)      433 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/edgedns/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1832 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/edgedns/_inputs.py
--rw-r--r--   0 runner    (1001) docker     (123)    78833 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/edgedns/dns_record.py
--rw-r--r--   0 runner    (1001) docker     (123)    28273 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/edgedns/dns_zone.py
--rw-r--r--   0 runner    (1001) docker     (123)     4243 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/edgedns/get_authorities_set.py
--rw-r--r--   0 runner    (1001) docker     (123)     4328 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/edgedns/get_dns_record_set.py
--rw-r--r--   0 runner    (1001) docker     (123)     1372 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/edgedns/outputs.py
--rw-r--r--   0 runner    (1001) docker     (123)     8269 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_advanced_settings_evasive_path_match.py
--rw-r--r--   0 runner    (1001) docker     (123)     8240 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_advanced_settings_logging.py
--rw-r--r--   0 runner    (1001) docker     (123)     8401 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_advanced_settings_pragma_header.py
--rw-r--r--   0 runner    (1001) docker     (123)     6411 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_advanced_settings_prefetch.py
--rw-r--r--   0 runner    (1001) docker     (123)     7807 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_api_endpoints.py
--rw-r--r--   0 runner    (1001) docker     (123)     8479 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_api_request_constraints.py
--rw-r--r--   0 runner    (1001) docker     (123)    10803 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_attack_groups.py
--rw-r--r--   0 runner    (1001) docker     (123)     8104 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_bypass_network_lists.py
--rw-r--r--   0 runner    (1001) docker     (123)     5264 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_configuration.py
--rw-r--r--   0 runner    (1001) docker     (123)     5925 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_configuration_version.py
--rw-r--r--   0 runner    (1001) docker     (123)     8407 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_contracts_groups.py
--rw-r--r--   0 runner    (1001) docker     (123)     7189 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_custom_deny.py
--rw-r--r--   0 runner    (1001) docker     (123)     7590 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_custom_rule_actions.py
--rw-r--r--   0 runner    (1001) docker     (123)     7491 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_custom_rules.py
--rw-r--r--   0 runner    (1001) docker     (123)     3663 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_eval.py
--rw-r--r--   0 runner    (1001) docker     (123)     6727 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_eval_groups.py
--rw-r--r--   0 runner    (1001) docker     (123)     8726 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_eval_penalty_box.py
--rw-r--r--   0 runner    (1001) docker     (123)    10241 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_eval_rules.py
--rw-r--r--   0 runner    (1001) docker     (123)     7768 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_export_configuration.py
--rw-r--r--   0 runner    (1001) docker     (123)     6297 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_failover_hostnames.py
--rw-r--r--   0 runner    (1001) docker     (123)     3488 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_hostname_coverage.py
--rw-r--r--   0 runner    (1001) docker     (123)     6648 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_hostname_coverage_match_targets.py
--rw-r--r--   0 runner    (1001) docker     (123)     6565 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_hostname_coverage_overlapping.py
--rw-r--r--   0 runner    (1001) docker     (123)    10055 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_ip_geo.py
--rw-r--r--   0 runner    (1001) docker     (123)     5603 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_malware_content_types.py
--rw-r--r--   0 runner    (1001) docker     (123)     7264 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_malware_policies.py
--rw-r--r--   0 runner    (1001) docker     (123)     7737 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_malware_policy_actions.py
--rw-r--r--   0 runner    (1001) docker     (123)     7152 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_match_targets.py
--rw-r--r--   0 runner    (1001) docker     (123)     8269 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_penalty_box.py
--rw-r--r--   0 runner    (1001) docker     (123)     7415 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_rate_policies.py
--rw-r--r--   0 runner    (1001) docker     (123)     7820 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_rate_policy_actions.py
--rw-r--r--   0 runner    (1001) docker     (123)    10299 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_reputation_profile_actions.py
--rw-r--r--   0 runner    (1001) docker     (123)     7762 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_reputation_profile_analysis.py
--rw-r--r--   0 runner    (1001) docker     (123)     8204 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_reputation_profiles.py
--rw-r--r--   0 runner    (1001) docker     (123)     7164 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_rule_upgrade_details.py
--rw-r--r--   0 runner    (1001) docker     (123)     6286 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_rules.py
--rw-r--r--   0 runner    (1001) docker     (123)     6126 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_security_policy.py
--rw-r--r--   0 runner    (1001) docker     (123)    15115 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_security_policy_protections.py
--rw-r--r--   0 runner    (1001) docker     (123)    13092 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_selectable_hostnames.py
--rw-r--r--   0 runner    (1001) docker     (123)     6713 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_selected_hostnames.py
--rw-r--r--   0 runner    (1001) docker     (123)     6355 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_siem_definitions.py
--rw-r--r--   0 runner    (1001) docker     (123)     5516 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_siem_settings.py
--rw-r--r--   0 runner    (1001) docker     (123)     7873 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_slow_post.py
--rw-r--r--   0 runner    (1001) docker     (123)     7826 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_threat_intel.py
--rw-r--r--   0 runner    (1001) docker     (123)    12114 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_tuning_recommendations.py
--rw-r--r--   0 runner    (1001) docker     (123)     5450 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_version_notes.py
--rw-r--r--   0 runner    (1001) docker     (123)    11347 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_waf_mode.py
--rw-r--r--   0 runner    (1001) docker     (123)     9421 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_wap_selected_hostnames.py
--rw-r--r--   0 runner    (1001) docker     (123)     8513 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_appsec_advanced_settings_attack_payload_logging.py
--rw-r--r--   0 runner    (1001) docker     (123)     3804 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_authorities_set.py
--rw-r--r--   0 runner    (1001) docker     (123)     4978 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_cloudlets_api_prioritization_match_rule.py
--rw-r--r--   0 runner    (1001) docker     (123)    19839 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_cloudlets_application_load_balancer.py
--rw-r--r--   0 runner    (1001) docker     (123)     5163 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_cloudlets_application_load_balancer_match_rule.py
--rw-r--r--   0 runner    (1001) docker     (123)     5065 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_cloudlets_audience_segmentation_match_rule.py
--rw-r--r--   0 runner    (1001) docker     (123)     4891 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_cloudlets_edge_redirector_match_rule.py
--rw-r--r--   0 runner    (1001) docker     (123)     6625 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_cloudlets_forward_rewrite_match_rule.py
--rw-r--r--   0 runner    (1001) docker     (123)     4862 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_cloudlets_phased_release_match_rule.py
--rw-r--r--   0 runner    (1001) docker     (123)    18256 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_cloudlets_policy.py
--rw-r--r--   0 runner    (1001) docker     (123)     4891 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_cloudlets_request_control_match_rule.py
--rw-r--r--   0 runner    (1001) docker     (123)     6652 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_cloudlets_visitor_prioritization_match_rule.py
--rw-r--r--   0 runner    (1001) docker     (123)     4604 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_contract.py
--rw-r--r--   0 runner    (1001) docker     (123)     3016 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_contracts.py
--rw-r--r--   0 runner    (1001) docker     (123)     6170 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_cp_code.py
--rw-r--r--   0 runner    (1001) docker     (123)     5263 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_cps_csr.py
--rw-r--r--   0 runner    (1001) docker     (123)     9171 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_cps_deployments.py
--rw-r--r--   0 runner    (1001) docker     (123)    25643 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_cps_enrollment.py
--rw-r--r--   0 runner    (1001) docker     (123)    16744 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_cps_enrollments.py
--rw-r--r--   0 runner    (1001) docker     (123)     3122 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_cps_warnings.py
--rw-r--r--   0 runner    (1001) docker     (123)     5410 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_datastream_activation_history.py
--rw-r--r--   0 runner    (1001) docker     (123)     5675 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_datastream_dataset_fields.py
--rw-r--r--   0 runner    (1001) docker     (123)     7631 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_datastreams.py
--rw-r--r--   0 runner    (1001) docker     (123)     3903 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_dns_record_set.py
--rw-r--r--   0 runner    (1001) docker     (123)     7665 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_edge_worker.py
--rw-r--r--   0 runner    (1001) docker     (123)     5477 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_edge_worker_activation.py
--rw-r--r--   0 runner    (1001) docker     (123)     3336 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_edge_workers_property_rules.py
--rw-r--r--   0 runner    (1001) docker     (123)     5588 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_edge_workers_resource_tier.py
--rw-r--r--   0 runner    (1001) docker     (123)     6273 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_group.py
--rw-r--r--   0 runner    (1001) docker     (123)     2805 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_groups.py
--rw-r--r--   0 runner    (1001) docker     (123)     4833 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_gtm_default_datacenter.py
--rw-r--r--   0 runner    (1001) docker     (123)     2727 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_iam_contact_types.py
--rw-r--r--   0 runner    (1001) docker     (123)     2586 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_iam_countries.py
--rw-r--r--   0 runner    (1001) docker     (123)     3077 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_iam_grantable_roles.py
--rw-r--r--   0 runner    (1001) docker     (123)     2611 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_iam_roles.py
--rw-r--r--   0 runner    (1001) docker     (123)     4022 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_iam_states.py
--rw-r--r--   0 runner    (1001) docker     (123)     2771 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_iam_supported_langs.py
--rw-r--r--   0 runner    (1001) docker     (123)     2833 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_iam_timeout_policies.py
--rw-r--r--   0 runner    (1001) docker     (123)     2734 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_iam_timezones.py
--rw-r--r--   0 runner    (1001) docker     (123)     8609 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_network_lists.py
--rw-r--r--   0 runner    (1001) docker     (123)     5060 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_properties.py
--rw-r--r--   0 runner    (1001) docker     (123)     5080 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_properties_search.py
--rw-r--r--   0 runner    (1001) docker     (123)     4703 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_property.py
--rw-r--r--   0 runner    (1001) docker     (123)     9651 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_property_hostnames.py
--rw-r--r--   0 runner    (1001) docker     (123)     8793 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_property_include.py
--rw-r--r--   0 runner    (1001) docker     (123)     7775 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_property_include_activation.py
--rw-r--r--   0 runner    (1001) docker     (123)     7791 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_property_include_parents.py
--rw-r--r--   0 runner    (1001) docker     (123)    10603 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_property_include_rules.py
--rw-r--r--   0 runner    (1001) docker     (123)     8705 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_property_includes.py
--rw-r--r--   0 runner    (1001) docker     (123)     4561 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_property_products.py
--rw-r--r--   0 runner    (1001) docker     (123)     2913 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_property_rule_formats.py
--rw-r--r--   0 runner    (1001) docker     (123)     8642 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_property_rules.py
--rw-r--r--   0 runner    (1001) docker     (123)    11704 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_property_rules_template.py
--rw-r--r--   0 runner    (1001) docker     (123)    18409 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/gtm_asmap.py
--rw-r--r--   0 runner    (1001) docker     (123)    18915 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/gtm_cidrmap.py
--rw-r--r--   0 runner    (1001) docker     (123)    44683 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/gtm_datacenter.py
--rw-r--r--   0 runner    (1001) docker     (123)    60478 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/gtm_domain.py
--rw-r--r--   0 runner    (1001) docker     (123)    18394 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/gtm_geomap.py
--rw-r--r--   0 runner    (1001) docker     (123)    88149 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/gtm_property.py
--rw-r--r--   0 runner    (1001) docker     (123)    41043 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/gtm_resource.py
--rw-r--r--   0 runner    (1001) docker     (123)    12796 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/iam_blocked_user_properties.py
--rw-r--r--   0 runner    (1001) docker     (123)    10124 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/iam_group.py
--rw-r--r--   0 runner    (1001) docker     (123)    13424 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/iam_role.py
--rw-r--r--   0 runner    (1001) docker     (123)    50677 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/iam_user.py
--rw-r--r--   0 runner    (1001) docker     (123)    23858 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/network_list.py
--rw-r--r--   0 runner    (1001) docker     (123)    19289 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/network_list_activations.py
--rw-r--r--   0 runner    (1001) docker     (123)    10570 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/network_list_description.py
--rw-r--r--   0 runner    (1001) docker     (123)    10799 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/network_list_subscription.py
--rw-r--r--   0 runner    (1001) docker     (123)   436075 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/outputs.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 23:29:15.454178 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/properties/
--rw-r--r--   0 runner    (1001) docker     (123)      545 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/properties/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    21615 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/properties/_inputs.py
--rw-r--r--   0 runner    (1001) docker     (123)    23482 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/properties/cp_code.py
--rw-r--r--   0 runner    (1001) docker     (123)    35636 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/properties/edge_host_name.py
--rw-r--r--   0 runner    (1001) docker     (123)     9926 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/properties/get_activation.py
--rw-r--r--   0 runner    (1001) docker     (123)     6557 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/properties/get_cp_code.py
--rw-r--r--   0 runner    (1001) docker     (123)     5104 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/properties/get_property.py
--rw-r--r--   0 runner    (1001) docker     (123)     9085 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/properties/get_property_rules.py
--rw-r--r--   0 runner    (1001) docker     (123)    19821 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/properties/outputs.py
--rw-r--r--   0 runner    (1001) docker     (123)    58205 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/properties/property.py
--rw-r--r--   0 runner    (1001) docker     (123)    39040 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/properties/property_activation.py
--rw-r--r--   0 runner    (1001) docker     (123)    57945 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/property.py
--rw-r--r--   0 runner    (1001) docker     (123)    38790 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/property_activation.py
--rw-r--r--   0 runner    (1001) docker     (123)    27956 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/property_include.py
--rw-r--r--   0 runner    (1001) docker     (123)    26641 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/property_include_activation.py
--rw-r--r--   0 runner    (1001) docker     (123)    21345 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/provider.py
--rw-r--r--   0 runner    (1001) docker     (123)       43 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/pulumi-plugin.json
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/py.typed
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 23:29:15.454178 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/trafficmanagement/
--rw-r--r--   0 runner    (1001) docker     (123)      547 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/trafficmanagement/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    42784 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/trafficmanagement/_inputs.py
--rw-r--r--   0 runner    (1001) docker     (123)     5362 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/trafficmanagement/get_gtm_default_datacenter.py
--rw-r--r--   0 runner    (1001) docker     (123)    18630 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/trafficmanagement/gtm_a_smap.py
--rw-r--r--   0 runner    (1001) docker     (123)    19146 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/trafficmanagement/gtm_cidrmap.py
--rw-r--r--   0 runner    (1001) docker     (123)    44929 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/trafficmanagement/gtm_datacenter.py
--rw-r--r--   0 runner    (1001) docker     (123)    60704 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/trafficmanagement/gtm_domain.py
--rw-r--r--   0 runner    (1001) docker     (123)    18620 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/trafficmanagement/gtm_geomap.py
--rw-r--r--   0 runner    (1001) docker     (123)    88385 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/trafficmanagement/gtm_property.py
--rw-r--r--   0 runner    (1001) docker     (123)    41279 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/trafficmanagement/gtm_resource.py
--rw-r--r--   0 runner    (1001) docker     (123)    40139 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai/trafficmanagement/outputs.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 23:29:15.450178 pulumi_akamai-4.4.0a1680909501/pulumi_akamai.egg-info/
--rw-r--r--   0 runner    (1001) docker     (123)     2462 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)     9555 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai.egg-info/not-zip-safe
--rw-r--r--   0 runner    (1001) docker     (123)       49 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (123)       14 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/pulumi_akamai.egg-info/top_level.txt
--rw-r--r--   0 runner    (1001) docker     (123)       38 2023-04-07 23:29:15.454178 pulumi_akamai-4.4.0a1680909501/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (123)     2124 2023-04-07 23:29:15.000000 pulumi_akamai-4.4.0a1680909501/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 18:43:52.786340 pulumi_akamai-4.4.0a1681843117/
+-rw-r--r--   0 runner    (1001) docker     (123)     2462 2023-04-18 18:43:52.786340 pulumi_akamai-4.4.0a1681843117/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     2119 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 18:43:52.782340 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/
+-rw-r--r--   0 runner    (1001) docker     (123)    27184 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)  1553949 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/_inputs.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8081 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/_utilities.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21333 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_activations.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10773 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_advanced_settings_evasive_path_match.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10295 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_advanced_settings_logging.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10856 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_advanced_settings_pragma_header.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15113 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_advanced_settings_prefetch.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11236 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_api_constraints_protection.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12592 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_api_request_constraints.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14951 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_attack_group.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11212 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_by_pass_network_list.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20518 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_configuration.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9676 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_configuration_rename.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9205 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_custom_deny.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8682 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_custom_rule.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12783 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_custom_rule_action.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17001 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_eval.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15103 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_eval_group.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13089 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_eval_penalty_box.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14538 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_eval_rule.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17481 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_ip_geo.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10975 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_ip_geo_protection.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9253 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_malware_policy.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14854 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_malware_policy_action.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10858 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_malware_policy_actions.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11026 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_malware_protection.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9079 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_match_target.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8618 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_match_target_sequence.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12987 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_penalty_box.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8992 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_rate_policy.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14508 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_rate_policy_action.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10433 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_rate_protection.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9601 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_reputation_profile.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12618 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_reputation_profile_action.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14387 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_reputation_profile_analysis.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11113 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_reputation_protection.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14063 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_rule.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13718 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_rule_upgrade.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17082 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_security_policy.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10613 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_security_policy_rename.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10263 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_selected_hostnames.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17536 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_siem_settings.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19373 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_slow_post.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11062 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_slow_post_protection.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10243 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_threat_intel.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9060 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_version_nodes.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15899 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_waf_mode.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10910 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_waf_protection.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13004 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_wap_selected_hostnames.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11169 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/appsec_advanced_settings_attack_payload_logging.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11290 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/appsec_advanced_settings_request_body.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19609 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/cloudlets_application_load_balancer.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11677 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/cloudlets_application_load_balancer_activation.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19277 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/cloudlets_policy.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13766 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/cloudlets_policy_activation.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 18:43:52.782340 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/config/
+-rw-r--r--   0 runner    (1001) docker     (123)      285 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/config/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11104 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/config/outputs.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2298 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/config/vars.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14717 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/cp_code.py
+-rw-r--r--   0 runner    (1001) docker     (123)    47004 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/cps_dv_enrollment.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8567 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/cps_dv_validation.py
+-rw-r--r--   0 runner    (1001) docker     (123)    44892 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/cps_third_party_enrollment.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27347 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/cps_upload_certificate.py
+-rw-r--r--   0 runner    (1001) docker     (123)    58490 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/datastream.py
+-rw-r--r--   0 runner    (1001) docker     (123)    78637 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/dns_record.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21162 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/dns_zone.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22811 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/edge_host_name.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17395 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/edge_kv.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15813 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/edge_worker.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10763 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/edge_workers_activation.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 18:43:52.782340 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/edgedns/
+-rw-r--r--   0 runner    (1001) docker     (123)      433 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/edgedns/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1432 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/edgedns/_inputs.py
+-rw-r--r--   0 runner    (1001) docker     (123)    78833 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/edgedns/dns_record.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21348 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/edgedns/dns_zone.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3417 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/edgedns/get_authorities_set.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4328 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/edgedns/get_dns_record_set.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1014 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/edgedns/outputs.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4660 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_advanced_settings_evasive_path_match.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4444 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_advanced_settings_logging.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4563 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_advanced_settings_pragma_header.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3683 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_advanced_settings_prefetch.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5183 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_api_endpoints.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4955 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_api_request_constraints.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5893 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_attack_groups.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4870 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_bypass_network_lists.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4916 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_configuration.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5285 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_configuration_version.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5079 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_contracts_groups.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4081 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_custom_deny.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4668 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_custom_rule_actions.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4103 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_custom_rules.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3663 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_eval.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5845 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_eval_groups.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4614 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_eval_penalty_box.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5697 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_eval_rules.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4748 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_export_configuration.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3933 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_failover_hostnames.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2580 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_hostname_coverage.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4360 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_hostname_coverage_match_targets.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4329 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_hostname_coverage_overlapping.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5673 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_ip_geo.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3583 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_malware_content_types.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4242 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_malware_policies.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4791 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_malware_policy_actions.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4142 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_match_targets.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4517 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_penalty_box.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4125 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_rate_policies.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4668 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_rate_policy_actions.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5629 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_reputation_profile_actions.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4468 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_reputation_profile_analysis.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4376 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_reputation_profiles.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4314 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_rule_upgrade_details.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5526 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_rules.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5396 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_security_policy.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9257 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_security_policy_protections.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6896 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_selectable_hostnames.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4075 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_selected_hostnames.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3701 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_siem_definitions.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3436 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_siem_settings.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4085 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_slow_post.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4592 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_threat_intel.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5903 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_tuning_recommendations.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3436 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_version_notes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6281 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_waf_mode.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6275 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_wap_selected_hostnames.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4739 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_appsec_advanced_settings_attack_payload_logging.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4532 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_appsec_advanced_settings_request_body.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2978 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_authorities_set.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3682 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cloudlets_api_prioritization_match_rule.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8855 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cloudlets_application_load_balancer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3827 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cloudlets_application_load_balancer_match_rule.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3751 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cloudlets_audience_segmentation_match_rule.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3613 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cloudlets_edge_redirector_match_rule.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3613 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cloudlets_forward_rewrite_match_rule.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3590 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cloudlets_phased_release_match_rule.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8784 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cloudlets_policy.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3613 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cloudlets_request_control_match_rule.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3774 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cloudlets_visitor_prioritization_match_rule.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3768 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_contract.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2091 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_contracts.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5414 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cp_code.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3275 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cps_csr.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6129 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cps_deployments.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11639 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cps_enrollment.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3106 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cps_enrollments.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2058 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cps_warnings.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3352 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_datastream_activation_history.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3291 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_datastream_dataset_fields.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2953 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_datastreams.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3903 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_dns_record_set.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5671 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_edge_worker.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4139 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_edge_worker_activation.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3196 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_edge_workers_property_rules.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4056 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_edge_workers_resource_tier.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4487 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_group.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2007 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_groups.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4087 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_gtm_default_datacenter.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2193 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_iam_contact_types.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2080 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_iam_countries.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2315 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_iam_grantable_roles.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2026 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_iam_roles.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2802 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_iam_states.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2152 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_iam_supported_langs.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2158 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_iam_timeout_policies.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2138 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_iam_timezones.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5566 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_network_lists.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3548 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_properties.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3486 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_properties_search.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3235 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_property.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4681 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_property_hostnames.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5911 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_property_include.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6073 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_property_include_activation.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4413 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_property_include_parents.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6763 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_property_include_rules.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5051 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_property_includes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3109 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_property_products.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2236 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_property_rule_formats.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5630 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_property_rules.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3804 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_property_rules_builder.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6236 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_property_rules_template.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11604 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/gtm_asmap.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11692 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/gtm_cidrmap.py
+-rw-r--r--   0 runner    (1001) docker     (123)    29745 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/gtm_datacenter.py
+-rw-r--r--   0 runner    (1001) docker     (123)    44869 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/gtm_domain.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11648 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/gtm_geomap.py
+-rw-r--r--   0 runner    (1001) docker     (123)    55296 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/gtm_property.py
+-rw-r--r--   0 runner    (1001) docker     (123)    26762 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/gtm_resource.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10813 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/iam_blocked_user_properties.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8532 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/iam_group.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11783 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/iam_role.py
+-rw-r--r--   0 runner    (1001) docker     (123)    48065 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/iam_user.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20282 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/network_list.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18214 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/network_list_activations.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8037 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/network_list_description.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7300 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/network_list_subscription.py
+-rw-r--r--   0 runner    (1001) docker     (123)  1210373 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/outputs.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 18:43:52.786340 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/properties/
+-rw-r--r--   0 runner    (1001) docker     (123)      545 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/properties/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    23565 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/properties/_inputs.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14907 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/properties/cp_code.py
+-rw-r--r--   0 runner    (1001) docker     (123)    23031 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/properties/edge_host_name.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5829 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/properties/get_activation.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5801 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/properties/get_cp_code.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3636 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/properties/get_property.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6073 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/properties/get_property_rules.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21783 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/properties/outputs.py
+-rw-r--r--   0 runner    (1001) docker     (123)    42254 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/properties/property.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27517 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/properties/property_activation.py
+-rw-r--r--   0 runner    (1001) docker     (123)    42054 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/property.py
+-rw-r--r--   0 runner    (1001) docker     (123)    27267 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/property_activation.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22902 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/property_include.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24971 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/property_include_activation.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22466 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/provider.py
+-rw-r--r--   0 runner    (1001) docker     (123)       43 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/pulumi-plugin.json
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/py.typed
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 18:43:52.786340 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/trafficmanagement/
+-rw-r--r--   0 runner    (1001) docker     (123)      547 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/trafficmanagement/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    28358 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/trafficmanagement/_inputs.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4616 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/trafficmanagement/get_gtm_default_datacenter.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11825 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/trafficmanagement/gtm_a_smap.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11923 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/trafficmanagement/gtm_cidrmap.py
+-rw-r--r--   0 runner    (1001) docker     (123)    29991 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/trafficmanagement/gtm_datacenter.py
+-rw-r--r--   0 runner    (1001) docker     (123)    45095 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/trafficmanagement/gtm_domain.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11874 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/trafficmanagement/gtm_geomap.py
+-rw-r--r--   0 runner    (1001) docker     (123)    55532 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/trafficmanagement/gtm_property.py
+-rw-r--r--   0 runner    (1001) docker     (123)    26998 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/trafficmanagement/gtm_resource.py
+-rw-r--r--   0 runner    (1001) docker     (123)    26637 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai/trafficmanagement/outputs.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-18 18:43:52.782340 pulumi_akamai-4.4.0a1681843117/pulumi_akamai.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     2462 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     9713 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai.egg-info/not-zip-safe
+-rw-r--r--   0 runner    (1001) docker     (123)       49 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       14 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/pulumi_akamai.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-04-18 18:43:52.790340 pulumi_akamai-4.4.0a1681843117/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     2124 2023-04-18 18:43:52.000000 pulumi_akamai-4.4.0a1681843117/setup.py
```

### Comparing `pulumi_akamai-4.4.0a1680909501/PKG-INFO` & `pulumi_akamai-4.4.0a1681843117/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pulumi_akamai
-Version: 4.4.0a1680909501
+Version: 4.4.0a1681843117
 Summary: A Pulumi package for creating and managing akamai cloud resources.
 Home-page: https://pulumi.io
 License: Apache-2.0
 Project-URL: Repository, https://github.com/pulumi/pulumi-akamai
 Keywords: pulumi akamai
 Platform: UNKNOWN
 Description-Content-Type: text/markdown
```

### Comparing `pulumi_akamai-4.4.0a1680909501/README.md` & `pulumi_akamai-4.4.0a1681843117/README.md`

 * *Files identical despite different names*

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/__init__.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -49,14 +49,15 @@
 from .app_sec_slow_post_protection import *
 from .app_sec_threat_intel import *
 from .app_sec_version_nodes import *
 from .app_sec_waf_mode import *
 from .app_sec_waf_protection import *
 from .app_sec_wap_selected_hostnames import *
 from .appsec_advanced_settings_attack_payload_logging import *
+from .appsec_advanced_settings_request_body import *
 from .cloudlets_application_load_balancer import *
 from .cloudlets_application_load_balancer_activation import *
 from .cloudlets_policy import *
 from .cloudlets_policy_activation import *
 from .cp_code import *
 from .cps_dv_enrollment import *
 from .cps_dv_validation import *
@@ -114,14 +115,15 @@
 from .get_app_sec_slow_post import *
 from .get_app_sec_threat_intel import *
 from .get_app_sec_tuning_recommendations import *
 from .get_app_sec_version_notes import *
 from .get_app_sec_waf_mode import *
 from .get_app_sec_wap_selected_hostnames import *
 from .get_appsec_advanced_settings_attack_payload_logging import *
+from .get_appsec_advanced_settings_request_body import *
 from .get_authorities_set import *
 from .get_cloudlets_api_prioritization_match_rule import *
 from .get_cloudlets_application_load_balancer import *
 from .get_cloudlets_application_load_balancer_match_rule import *
 from .get_cloudlets_audience_segmentation_match_rule import *
 from .get_cloudlets_edge_redirector_match_rule import *
 from .get_cloudlets_forward_rewrite_match_rule import *
@@ -165,14 +167,15 @@
 from .get_property_include_activation import *
 from .get_property_include_parents import *
 from .get_property_include_rules import *
 from .get_property_includes import *
 from .get_property_products import *
 from .get_property_rule_formats import *
 from .get_property_rules import *
+from .get_property_rules_builder import *
 from .get_property_rules_template import *
 from .gtm_asmap import *
 from .gtm_cidrmap import *
 from .gtm_datacenter import *
 from .gtm_domain import *
 from .gtm_geomap import *
 from .gtm_property import *
@@ -610,14 +613,22 @@
   "fqn": "pulumi_akamai",
   "classes": {
    "akamai:index/appsecAdvancedSettingsAttackPayloadLogging:AppsecAdvancedSettingsAttackPayloadLogging": "AppsecAdvancedSettingsAttackPayloadLogging"
   }
  },
  {
   "pkg": "akamai",
+  "mod": "index/appsecAdvancedSettingsRequestBody",
+  "fqn": "pulumi_akamai",
+  "classes": {
+   "akamai:index/appsecAdvancedSettingsRequestBody:AppsecAdvancedSettingsRequestBody": "AppsecAdvancedSettingsRequestBody"
+  }
+ },
+ {
+  "pkg": "akamai",
   "mod": "index/cloudletsApplicationLoadBalancer",
   "fqn": "pulumi_akamai",
   "classes": {
    "akamai:index/cloudletsApplicationLoadBalancer:CloudletsApplicationLoadBalancer": "CloudletsApplicationLoadBalancer"
   }
  },
  {
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/_utilities.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/_utilities.py`

 * *Files identical despite different names*

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_advanced_settings_evasive_path_match.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_advanced_settings_evasive_path_match.py`

 * *Files 24% similar despite different names*

```diff
@@ -15,52 +15,52 @@
 class AppSecAdvancedSettingsEvasivePathMatchArgs:
     def __init__(__self__, *,
                  config_id: pulumi.Input[int],
                  enable_path_match: pulumi.Input[bool],
                  security_policy_id: Optional[pulumi.Input[str]] = None):
         """
         The set of arguments for constructing a AppSecAdvancedSettingsEvasivePathMatch resource.
-        :param pulumi.Input[int] config_id: The ID of the security configuration to use.
-        :param pulumi.Input[bool] enable_path_match: Whether to enable path match.
-        :param pulumi.Input[str] security_policy_id: The ID of a specific security policy to which the evasive path match setting should be applied. If not supplied, the indicated setting will be applied to all policies within the configuration.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enable_path_match: Whether to enable the evasive path match setting
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         pulumi.set(__self__, "config_id", config_id)
         pulumi.set(__self__, "enable_path_match", enable_path_match)
         if security_policy_id is not None:
             pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Input[int]:
         """
-        The ID of the security configuration to use.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter(name="enablePathMatch")
     def enable_path_match(self) -> pulumi.Input[bool]:
         """
-        Whether to enable path match.
+        Whether to enable the evasive path match setting
         """
         return pulumi.get(self, "enable_path_match")
 
     @enable_path_match.setter
     def enable_path_match(self, value: pulumi.Input[bool]):
         pulumi.set(self, "enable_path_match", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> Optional[pulumi.Input[str]]:
         """
-        The ID of a specific security policy to which the evasive path match setting should be applied. If not supplied, the indicated setting will be applied to all policies within the configuration.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "security_policy_id", value)
 
@@ -69,54 +69,54 @@
 class _AppSecAdvancedSettingsEvasivePathMatchState:
     def __init__(__self__, *,
                  config_id: Optional[pulumi.Input[int]] = None,
                  enable_path_match: Optional[pulumi.Input[bool]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering AppSecAdvancedSettingsEvasivePathMatch resources.
-        :param pulumi.Input[int] config_id: The ID of the security configuration to use.
-        :param pulumi.Input[bool] enable_path_match: Whether to enable path match.
-        :param pulumi.Input[str] security_policy_id: The ID of a specific security policy to which the evasive path match setting should be applied. If not supplied, the indicated setting will be applied to all policies within the configuration.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enable_path_match: Whether to enable the evasive path match setting
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
         if enable_path_match is not None:
             pulumi.set(__self__, "enable_path_match", enable_path_match)
         if security_policy_id is not None:
             pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        The ID of the security configuration to use.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter(name="enablePathMatch")
     def enable_path_match(self) -> Optional[pulumi.Input[bool]]:
         """
-        Whether to enable path match.
+        Whether to enable the evasive path match setting
         """
         return pulumi.get(self, "enable_path_match")
 
     @enable_path_match.setter
     def enable_path_match(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "enable_path_match", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> Optional[pulumi.Input[str]]:
         """
-        The ID of a specific security policy to which the evasive path match setting should be applied. If not supplied, the indicated setting will be applied to all policies within the configuration.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "security_policy_id", value)
 
@@ -127,83 +127,29 @@
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
                  enable_path_match: Optional[pulumi.Input[bool]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Security configuration; security policy
-
-        The `resource_akamai_appsec_advanced_settings_evasive_path_match` resource allows you to enable, disable, or update the evasive path match setting for a configuration.
-        This setting determines whether fuzzy matching is used to make URL matching more inclusive.
-        This operation applies at the configuration level, and therefore applies to all policies within a configuration.
-        You may override this setting for a particular policy by specifying the policy using the security_policy_id parameter.
-
-        **Related API Endpoints**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/advanced-settings/evasive-path-match](https://techdocs.akamai.com/application-security/reference/put-evasive-path-match)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name=var["security_configuration"])
-        config_evasive_path_match = akamai.AppSecAdvancedSettingsEvasivePathMatch("configEvasivePathMatch",
-            config_id=configuration.config_id,
-            enable_path_match=True)
-        # USE CASE: user wants to override the evasive path match setting for a security policy
-        policy_override = akamai.AppSecAdvancedSettingsEvasivePathMatch("policyOverride",
-            config_id=configuration.config_id,
-            security_policy_id=var["security_policy_id"],
-            enable_path_match=True)
-        ```
-
+        Create a AppSecAdvancedSettingsEvasivePathMatch resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: The ID of the security configuration to use.
-        :param pulumi.Input[bool] enable_path_match: Whether to enable path match.
-        :param pulumi.Input[str] security_policy_id: The ID of a specific security policy to which the evasive path match setting should be applied. If not supplied, the indicated setting will be applied to all policies within the configuration.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enable_path_match: Whether to enable the evasive path match setting
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: AppSecAdvancedSettingsEvasivePathMatchArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Security configuration; security policy
-
-        The `resource_akamai_appsec_advanced_settings_evasive_path_match` resource allows you to enable, disable, or update the evasive path match setting for a configuration.
-        This setting determines whether fuzzy matching is used to make URL matching more inclusive.
-        This operation applies at the configuration level, and therefore applies to all policies within a configuration.
-        You may override this setting for a particular policy by specifying the policy using the security_policy_id parameter.
-
-        **Related API Endpoints**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/advanced-settings/evasive-path-match](https://techdocs.akamai.com/application-security/reference/put-evasive-path-match)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name=var["security_configuration"])
-        config_evasive_path_match = akamai.AppSecAdvancedSettingsEvasivePathMatch("configEvasivePathMatch",
-            config_id=configuration.config_id,
-            enable_path_match=True)
-        # USE CASE: user wants to override the evasive path match setting for a security policy
-        policy_override = akamai.AppSecAdvancedSettingsEvasivePathMatch("policyOverride",
-            config_id=configuration.config_id,
-            security_policy_id=var["security_policy_id"],
-            enable_path_match=True)
-        ```
-
+        Create a AppSecAdvancedSettingsEvasivePathMatch resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param AppSecAdvancedSettingsEvasivePathMatchArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(AppSecAdvancedSettingsEvasivePathMatchArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -250,44 +196,44 @@
         """
         Get an existing AppSecAdvancedSettingsEvasivePathMatch resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: The ID of the security configuration to use.
-        :param pulumi.Input[bool] enable_path_match: Whether to enable path match.
-        :param pulumi.Input[str] security_policy_id: The ID of a specific security policy to which the evasive path match setting should be applied. If not supplied, the indicated setting will be applied to all policies within the configuration.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enable_path_match: Whether to enable the evasive path match setting
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _AppSecAdvancedSettingsEvasivePathMatchState.__new__(_AppSecAdvancedSettingsEvasivePathMatchState)
 
         __props__.__dict__["config_id"] = config_id
         __props__.__dict__["enable_path_match"] = enable_path_match
         __props__.__dict__["security_policy_id"] = security_policy_id
         return AppSecAdvancedSettingsEvasivePathMatch(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Output[int]:
         """
-        The ID of the security configuration to use.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @property
     @pulumi.getter(name="enablePathMatch")
     def enable_path_match(self) -> pulumi.Output[bool]:
         """
-        Whether to enable path match.
+        Whether to enable the evasive path match setting
         """
         return pulumi.get(self, "enable_path_match")
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Output[Optional[str]]:
         """
-        The ID of a specific security policy to which the evasive path match setting should be applied. If not supplied, the indicated setting will be applied to all policies within the configuration.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_advanced_settings_logging.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_rule_upgrade.py`

 * *Files 21% similar despite different names*

```diff
@@ -5,287 +5,319 @@
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
-__all__ = ['AppSecAdvancedSettingsLoggingArgs', 'AppSecAdvancedSettingsLogging']
+__all__ = ['AppSecRuleUpgradeArgs', 'AppSecRuleUpgrade']
 
 @pulumi.input_type
-class AppSecAdvancedSettingsLoggingArgs:
+class AppSecRuleUpgradeArgs:
     def __init__(__self__, *,
                  config_id: pulumi.Input[int],
-                 logging: pulumi.Input[str],
-                 security_policy_id: Optional[pulumi.Input[str]] = None):
+                 security_policy_id: pulumi.Input[str],
+                 upgrade_mode: Optional[pulumi.Input[str]] = None):
         """
-        The set of arguments for constructing a AppSecAdvancedSettingsLogging resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration containing the logging settings being modified.
-        :param pulumi.Input[str] logging: . Path to a JSON file containing the logging settings to be configured.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policies whose settings are being modified. If not included, the logging settings are modified at the configuration scope and, as a result, apply to all the security policies associated with the configuration.
+        The set of arguments for constructing a AppSecRuleUpgrade resource.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
+        :param pulumi.Input[str] upgrade_mode: Modifies the upgrade type for organizations running the ASE beta (ASE_AUTO or ASE_MANUAL)
         """
         pulumi.set(__self__, "config_id", config_id)
-        pulumi.set(__self__, "logging", logging)
-        if security_policy_id is not None:
-            pulumi.set(__self__, "security_policy_id", security_policy_id)
+        pulumi.set(__self__, "security_policy_id", security_policy_id)
+        if upgrade_mode is not None:
+            pulumi.set(__self__, "upgrade_mode", upgrade_mode)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuration containing the logging settings being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "config_id", value)
 
     @property
-    @pulumi.getter
-    def logging(self) -> pulumi.Input[str]:
+    @pulumi.getter(name="securityPolicyId")
+    def security_policy_id(self) -> pulumi.Input[str]:
         """
-        . Path to a JSON file containing the logging settings to be configured.
+        Unique identifier of the security policy
         """
-        return pulumi.get(self, "logging")
+        return pulumi.get(self, "security_policy_id")
 
-    @logging.setter
-    def logging(self, value: pulumi.Input[str]):
-        pulumi.set(self, "logging", value)
+    @security_policy_id.setter
+    def security_policy_id(self, value: pulumi.Input[str]):
+        pulumi.set(self, "security_policy_id", value)
 
     @property
-    @pulumi.getter(name="securityPolicyId")
-    def security_policy_id(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="upgradeMode")
+    def upgrade_mode(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the security policies whose settings are being modified. If not included, the logging settings are modified at the configuration scope and, as a result, apply to all the security policies associated with the configuration.
+        Modifies the upgrade type for organizations running the ASE beta (ASE_AUTO or ASE_MANUAL)
         """
-        return pulumi.get(self, "security_policy_id")
+        return pulumi.get(self, "upgrade_mode")
 
-    @security_policy_id.setter
-    def security_policy_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "security_policy_id", value)
+    @upgrade_mode.setter
+    def upgrade_mode(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "upgrade_mode", value)
 
 
 @pulumi.input_type
-class _AppSecAdvancedSettingsLoggingState:
+class _AppSecRuleUpgradeState:
     def __init__(__self__, *,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 logging: Optional[pulumi.Input[str]] = None,
-                 security_policy_id: Optional[pulumi.Input[str]] = None):
+                 current_ruleset: Optional[pulumi.Input[str]] = None,
+                 eval_status: Optional[pulumi.Input[str]] = None,
+                 mode: Optional[pulumi.Input[str]] = None,
+                 security_policy_id: Optional[pulumi.Input[str]] = None,
+                 upgrade_mode: Optional[pulumi.Input[str]] = None):
         """
-        Input properties used for looking up and filtering AppSecAdvancedSettingsLogging resources.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration containing the logging settings being modified.
-        :param pulumi.Input[str] logging: . Path to a JSON file containing the logging settings to be configured.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policies whose settings are being modified. If not included, the logging settings are modified at the configuration scope and, as a result, apply to all the security policies associated with the configuration.
+        Input properties used for looking up and filtering AppSecRuleUpgrade resources.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] current_ruleset: Versioning information for the current KRS rule set
+        :param pulumi.Input[str] eval_status: Whether an evaluation is currently in progress
+        :param pulumi.Input[str] mode: Upgrade mode (KRS, AAG, ASE_MANUAL or ASE_AUTO)
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
+        :param pulumi.Input[str] upgrade_mode: Modifies the upgrade type for organizations running the ASE beta (ASE_AUTO or ASE_MANUAL)
         """
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
-        if logging is not None:
-            pulumi.set(__self__, "logging", logging)
+        if current_ruleset is not None:
+            pulumi.set(__self__, "current_ruleset", current_ruleset)
+        if eval_status is not None:
+            pulumi.set(__self__, "eval_status", eval_status)
+        if mode is not None:
+            pulumi.set(__self__, "mode", mode)
         if security_policy_id is not None:
             pulumi.set(__self__, "security_policy_id", security_policy_id)
+        if upgrade_mode is not None:
+            pulumi.set(__self__, "upgrade_mode", upgrade_mode)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security configuration containing the logging settings being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "config_id", value)
 
     @property
+    @pulumi.getter(name="currentRuleset")
+    def current_ruleset(self) -> Optional[pulumi.Input[str]]:
+        """
+        Versioning information for the current KRS rule set
+        """
+        return pulumi.get(self, "current_ruleset")
+
+    @current_ruleset.setter
+    def current_ruleset(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "current_ruleset", value)
+
+    @property
+    @pulumi.getter(name="evalStatus")
+    def eval_status(self) -> Optional[pulumi.Input[str]]:
+        """
+        Whether an evaluation is currently in progress
+        """
+        return pulumi.get(self, "eval_status")
+
+    @eval_status.setter
+    def eval_status(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "eval_status", value)
+
+    @property
     @pulumi.getter
-    def logging(self) -> Optional[pulumi.Input[str]]:
+    def mode(self) -> Optional[pulumi.Input[str]]:
         """
-        . Path to a JSON file containing the logging settings to be configured.
+        Upgrade mode (KRS, AAG, ASE_MANUAL or ASE_AUTO)
         """
-        return pulumi.get(self, "logging")
+        return pulumi.get(self, "mode")
 
-    @logging.setter
-    def logging(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "logging", value)
+    @mode.setter
+    def mode(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "mode", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the security policies whose settings are being modified. If not included, the logging settings are modified at the configuration scope and, as a result, apply to all the security policies associated with the configuration.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "security_policy_id", value)
 
+    @property
+    @pulumi.getter(name="upgradeMode")
+    def upgrade_mode(self) -> Optional[pulumi.Input[str]]:
+        """
+        Modifies the upgrade type for organizations running the ASE beta (ASE_AUTO or ASE_MANUAL)
+        """
+        return pulumi.get(self, "upgrade_mode")
+
+    @upgrade_mode.setter
+    def upgrade_mode(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "upgrade_mode", value)
+
 
-class AppSecAdvancedSettingsLogging(pulumi.CustomResource):
+class AppSecRuleUpgrade(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 logging: Optional[pulumi.Input[str]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
+                 upgrade_mode: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Security configuration; security policy
-
-        Enables, disables, or updates HTTP header logging settings.
-        By default, this operation applies at the configuration level, which means that it applies to all the security policies within that configuration.
-        However, by using the `security_policy_id` parameter you can specify custom settings for an individual security policy.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/logging](https://techdocs.akamai.com/application-security/reference/put-policies-logging)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        logging = akamai.AppSecAdvancedSettingsLogging("logging",
-            config_id=configuration.config_id,
-            logging=(lambda path: open(path).read())(f"{path['module']}/logging.json"))
-        # USE CASE: User wants to configure logging settings for a security policy.
-        policy_logging = akamai.AppSecAdvancedSettingsLogging("policyLogging",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            logging=(lambda path: open(path).read())(f"{path['module']}/logging.json"))
-        ```
-
+        Create a AppSecRuleUpgrade resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration containing the logging settings being modified.
-        :param pulumi.Input[str] logging: . Path to a JSON file containing the logging settings to be configured.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policies whose settings are being modified. If not included, the logging settings are modified at the configuration scope and, as a result, apply to all the security policies associated with the configuration.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
+        :param pulumi.Input[str] upgrade_mode: Modifies the upgrade type for organizations running the ASE beta (ASE_AUTO or ASE_MANUAL)
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: AppSecAdvancedSettingsLoggingArgs,
+                 args: AppSecRuleUpgradeArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Security configuration; security policy
-
-        Enables, disables, or updates HTTP header logging settings.
-        By default, this operation applies at the configuration level, which means that it applies to all the security policies within that configuration.
-        However, by using the `security_policy_id` parameter you can specify custom settings for an individual security policy.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/logging](https://techdocs.akamai.com/application-security/reference/put-policies-logging)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        logging = akamai.AppSecAdvancedSettingsLogging("logging",
-            config_id=configuration.config_id,
-            logging=(lambda path: open(path).read())(f"{path['module']}/logging.json"))
-        # USE CASE: User wants to configure logging settings for a security policy.
-        policy_logging = akamai.AppSecAdvancedSettingsLogging("policyLogging",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            logging=(lambda path: open(path).read())(f"{path['module']}/logging.json"))
-        ```
-
+        Create a AppSecRuleUpgrade resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param AppSecAdvancedSettingsLoggingArgs args: The arguments to use to populate this resource's properties.
+        :param AppSecRuleUpgradeArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(AppSecAdvancedSettingsLoggingArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(AppSecRuleUpgradeArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 logging: Optional[pulumi.Input[str]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
+                 upgrade_mode: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = AppSecAdvancedSettingsLoggingArgs.__new__(AppSecAdvancedSettingsLoggingArgs)
+            __props__ = AppSecRuleUpgradeArgs.__new__(AppSecRuleUpgradeArgs)
 
             if config_id is None and not opts.urn:
                 raise TypeError("Missing required property 'config_id'")
             __props__.__dict__["config_id"] = config_id
-            if logging is None and not opts.urn:
-                raise TypeError("Missing required property 'logging'")
-            __props__.__dict__["logging"] = logging
+            if security_policy_id is None and not opts.urn:
+                raise TypeError("Missing required property 'security_policy_id'")
             __props__.__dict__["security_policy_id"] = security_policy_id
-        super(AppSecAdvancedSettingsLogging, __self__).__init__(
-            'akamai:index/appSecAdvancedSettingsLogging:AppSecAdvancedSettingsLogging',
+            __props__.__dict__["upgrade_mode"] = upgrade_mode
+            __props__.__dict__["current_ruleset"] = None
+            __props__.__dict__["eval_status"] = None
+            __props__.__dict__["mode"] = None
+        super(AppSecRuleUpgrade, __self__).__init__(
+            'akamai:index/appSecRuleUpgrade:AppSecRuleUpgrade',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
             config_id: Optional[pulumi.Input[int]] = None,
-            logging: Optional[pulumi.Input[str]] = None,
-            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecAdvancedSettingsLogging':
+            current_ruleset: Optional[pulumi.Input[str]] = None,
+            eval_status: Optional[pulumi.Input[str]] = None,
+            mode: Optional[pulumi.Input[str]] = None,
+            security_policy_id: Optional[pulumi.Input[str]] = None,
+            upgrade_mode: Optional[pulumi.Input[str]] = None) -> 'AppSecRuleUpgrade':
         """
-        Get an existing AppSecAdvancedSettingsLogging resource's state with the given name, id, and optional extra
+        Get an existing AppSecRuleUpgrade resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration containing the logging settings being modified.
-        :param pulumi.Input[str] logging: . Path to a JSON file containing the logging settings to be configured.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policies whose settings are being modified. If not included, the logging settings are modified at the configuration scope and, as a result, apply to all the security policies associated with the configuration.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] current_ruleset: Versioning information for the current KRS rule set
+        :param pulumi.Input[str] eval_status: Whether an evaluation is currently in progress
+        :param pulumi.Input[str] mode: Upgrade mode (KRS, AAG, ASE_MANUAL or ASE_AUTO)
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
+        :param pulumi.Input[str] upgrade_mode: Modifies the upgrade type for organizations running the ASE beta (ASE_AUTO or ASE_MANUAL)
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _AppSecAdvancedSettingsLoggingState.__new__(_AppSecAdvancedSettingsLoggingState)
+        __props__ = _AppSecRuleUpgradeState.__new__(_AppSecRuleUpgradeState)
 
         __props__.__dict__["config_id"] = config_id
-        __props__.__dict__["logging"] = logging
+        __props__.__dict__["current_ruleset"] = current_ruleset
+        __props__.__dict__["eval_status"] = eval_status
+        __props__.__dict__["mode"] = mode
         __props__.__dict__["security_policy_id"] = security_policy_id
-        return AppSecAdvancedSettingsLogging(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["upgrade_mode"] = upgrade_mode
+        return AppSecRuleUpgrade(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Output[int]:
         """
-        . Unique identifier of the security configuration containing the logging settings being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @property
+    @pulumi.getter(name="currentRuleset")
+    def current_ruleset(self) -> pulumi.Output[str]:
+        """
+        Versioning information for the current KRS rule set
+        """
+        return pulumi.get(self, "current_ruleset")
+
+    @property
+    @pulumi.getter(name="evalStatus")
+    def eval_status(self) -> pulumi.Output[str]:
+        """
+        Whether an evaluation is currently in progress
+        """
+        return pulumi.get(self, "eval_status")
+
+    @property
     @pulumi.getter
-    def logging(self) -> pulumi.Output[str]:
+    def mode(self) -> pulumi.Output[str]:
         """
-        . Path to a JSON file containing the logging settings to be configured.
+        Upgrade mode (KRS, AAG, ASE_MANUAL or ASE_AUTO)
         """
-        return pulumi.get(self, "logging")
+        return pulumi.get(self, "mode")
 
     @property
     @pulumi.getter(name="securityPolicyId")
-    def security_policy_id(self) -> pulumi.Output[Optional[str]]:
+    def security_policy_id(self) -> pulumi.Output[str]:
         """
-        . Unique identifier of the security policies whose settings are being modified. If not included, the logging settings are modified at the configuration scope and, as a result, apply to all the security policies associated with the configuration.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
+    @property
+    @pulumi.getter(name="upgradeMode")
+    def upgrade_mode(self) -> pulumi.Output[Optional[str]]:
+        """
+        Modifies the upgrade type for organizations running the ASE beta (ASE_AUTO or ASE_MANUAL)
+        """
+        return pulumi.get(self, "upgrade_mode")
+
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_api_constraints_protection.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_api_constraints_protection.py`

 * *Files 4% similar despite different names*

```diff
@@ -142,79 +142,29 @@
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
                  enabled: Optional[pulumi.Input[bool]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Security policy
-
-        Enables or disables API constraints protection. These constraints specify the action to be taken when designated API endpoints are invoked.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/put-policy-protections)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        protection = akamai.AppSecApiConstraintsProtection("protection",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            enabled=True)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `output_text`. Tabular report showing the current protection settings.
-
+        Create a AppSecApiConstraintsProtection resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
         :param pulumi.Input[int] config_id: Unique identifier of the security configuration
         :param pulumi.Input[bool] enabled: Whether to enable API constraints protection
         :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: AppSecApiConstraintsProtectionArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Security policy
-
-        Enables or disables API constraints protection. These constraints specify the action to be taken when designated API endpoints are invoked.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/put-policy-protections)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        protection = akamai.AppSecApiConstraintsProtection("protection",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            enabled=True)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `output_text`. Tabular report showing the current protection settings.
-
+        Create a AppSecApiConstraintsProtection resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param AppSecApiConstraintsProtectionArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(AppSecApiConstraintsProtectionArgs, pulumi.ResourceOptions, *args, **kwargs)
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_attack_group.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_slow_post.py`

 * *Files 22% similar despite different names*

```diff
@@ -5,403 +5,384 @@
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
-__all__ = ['AppSecAttackGroupArgs', 'AppSecAttackGroup']
+__all__ = ['AppSecSlowPostArgs', 'AppSecSlowPost']
 
 @pulumi.input_type
-class AppSecAttackGroupArgs:
+class AppSecSlowPostArgs:
     def __init__(__self__, *,
-                 attack_group: pulumi.Input[str],
-                 attack_group_action: pulumi.Input[str],
                  config_id: pulumi.Input[int],
                  security_policy_id: pulumi.Input[str],
-                 condition_exception: Optional[pulumi.Input[str]] = None):
+                 slow_rate_action: pulumi.Input[str],
+                 duration_threshold_timeout: Optional[pulumi.Input[int]] = None,
+                 slow_rate_threshold_period: Optional[pulumi.Input[int]] = None,
+                 slow_rate_threshold_rate: Optional[pulumi.Input[int]] = None):
+        """
+        The set of arguments for constructing a AppSecSlowPost resource.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
+        :param pulumi.Input[str] slow_rate_action: Action to be taken when slow POST protection is triggered
+        :param pulumi.Input[int] duration_threshold_timeout: Maximum amount of time (in seconds) within which the first 8KB of the POST body must be received to avoid triggering the
+               specified action
+        :param pulumi.Input[int] slow_rate_threshold_period: Amount of time (in seconds) that the server should allow a request before marking the request as being too slow
+        :param pulumi.Input[int] slow_rate_threshold_rate: Average rate (in bytes per second over the specified time period) allowed before the specified action is triggered
         """
-        The set of arguments for constructing a AppSecAttackGroup resource.
-        :param pulumi.Input[str] attack_group: . Unique name of the attack group being modified.
-        :param pulumi.Input[str] attack_group_action: . Action taken any time the attack group is triggered. Allowed values are:
-               - **alert**. Record information about the request.
-               - **deny**. Block the request,
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the attack group being modified.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the attack group being modified.
-        :param pulumi.Input[str] condition_exception: . Path to a JSON file containing the conditions and exceptions to be assigned to the attack group.
-        """
-        pulumi.set(__self__, "attack_group", attack_group)
-        pulumi.set(__self__, "attack_group_action", attack_group_action)
         pulumi.set(__self__, "config_id", config_id)
         pulumi.set(__self__, "security_policy_id", security_policy_id)
-        if condition_exception is not None:
-            pulumi.set(__self__, "condition_exception", condition_exception)
-
-    @property
-    @pulumi.getter(name="attackGroup")
-    def attack_group(self) -> pulumi.Input[str]:
-        """
-        . Unique name of the attack group being modified.
-        """
-        return pulumi.get(self, "attack_group")
-
-    @attack_group.setter
-    def attack_group(self, value: pulumi.Input[str]):
-        pulumi.set(self, "attack_group", value)
-
-    @property
-    @pulumi.getter(name="attackGroupAction")
-    def attack_group_action(self) -> pulumi.Input[str]:
-        """
-        . Action taken any time the attack group is triggered. Allowed values are:
-        - **alert**. Record information about the request.
-        - **deny**. Block the request,
-        - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-        - **none**. Take no action.
-        """
-        return pulumi.get(self, "attack_group_action")
-
-    @attack_group_action.setter
-    def attack_group_action(self, value: pulumi.Input[str]):
-        pulumi.set(self, "attack_group_action", value)
+        pulumi.set(__self__, "slow_rate_action", slow_rate_action)
+        if duration_threshold_timeout is not None:
+            pulumi.set(__self__, "duration_threshold_timeout", duration_threshold_timeout)
+        if slow_rate_threshold_period is not None:
+            pulumi.set(__self__, "slow_rate_threshold_period", slow_rate_threshold_period)
+        if slow_rate_threshold_rate is not None:
+            pulumi.set(__self__, "slow_rate_threshold_rate", slow_rate_threshold_rate)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuration associated with the attack group being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Input[str]:
         """
-        . Unique identifier of the security policy associated with the attack group being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "security_policy_id", value)
 
     @property
-    @pulumi.getter(name="conditionException")
-    def condition_exception(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="slowRateAction")
+    def slow_rate_action(self) -> pulumi.Input[str]:
         """
-        . Path to a JSON file containing the conditions and exceptions to be assigned to the attack group.
+        Action to be taken when slow POST protection is triggered
         """
-        return pulumi.get(self, "condition_exception")
+        return pulumi.get(self, "slow_rate_action")
 
-    @condition_exception.setter
-    def condition_exception(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "condition_exception", value)
-
-
-@pulumi.input_type
-class _AppSecAttackGroupState:
-    def __init__(__self__, *,
-                 attack_group: Optional[pulumi.Input[str]] = None,
-                 attack_group_action: Optional[pulumi.Input[str]] = None,
-                 condition_exception: Optional[pulumi.Input[str]] = None,
-                 config_id: Optional[pulumi.Input[int]] = None,
-                 security_policy_id: Optional[pulumi.Input[str]] = None):
-        """
-        Input properties used for looking up and filtering AppSecAttackGroup resources.
-        :param pulumi.Input[str] attack_group: . Unique name of the attack group being modified.
-        :param pulumi.Input[str] attack_group_action: . Action taken any time the attack group is triggered. Allowed values are:
-               - **alert**. Record information about the request.
-               - **deny**. Block the request,
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action.
-        :param pulumi.Input[str] condition_exception: . Path to a JSON file containing the conditions and exceptions to be assigned to the attack group.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the attack group being modified.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the attack group being modified.
-        """
-        if attack_group is not None:
-            pulumi.set(__self__, "attack_group", attack_group)
-        if attack_group_action is not None:
-            pulumi.set(__self__, "attack_group_action", attack_group_action)
-        if condition_exception is not None:
-            pulumi.set(__self__, "condition_exception", condition_exception)
-        if config_id is not None:
-            pulumi.set(__self__, "config_id", config_id)
-        if security_policy_id is not None:
-            pulumi.set(__self__, "security_policy_id", security_policy_id)
+    @slow_rate_action.setter
+    def slow_rate_action(self, value: pulumi.Input[str]):
+        pulumi.set(self, "slow_rate_action", value)
 
     @property
-    @pulumi.getter(name="attackGroup")
-    def attack_group(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="durationThresholdTimeout")
+    def duration_threshold_timeout(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique name of the attack group being modified.
+        Maximum amount of time (in seconds) within which the first 8KB of the POST body must be received to avoid triggering the
+        specified action
         """
-        return pulumi.get(self, "attack_group")
+        return pulumi.get(self, "duration_threshold_timeout")
 
-    @attack_group.setter
-    def attack_group(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "attack_group", value)
+    @duration_threshold_timeout.setter
+    def duration_threshold_timeout(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "duration_threshold_timeout", value)
 
     @property
-    @pulumi.getter(name="attackGroupAction")
-    def attack_group_action(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="slowRateThresholdPeriod")
+    def slow_rate_threshold_period(self) -> Optional[pulumi.Input[int]]:
         """
-        . Action taken any time the attack group is triggered. Allowed values are:
-        - **alert**. Record information about the request.
-        - **deny**. Block the request,
-        - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-        - **none**. Take no action.
+        Amount of time (in seconds) that the server should allow a request before marking the request as being too slow
         """
-        return pulumi.get(self, "attack_group_action")
+        return pulumi.get(self, "slow_rate_threshold_period")
 
-    @attack_group_action.setter
-    def attack_group_action(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "attack_group_action", value)
+    @slow_rate_threshold_period.setter
+    def slow_rate_threshold_period(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "slow_rate_threshold_period", value)
 
     @property
-    @pulumi.getter(name="conditionException")
-    def condition_exception(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="slowRateThresholdRate")
+    def slow_rate_threshold_rate(self) -> Optional[pulumi.Input[int]]:
         """
-        . Path to a JSON file containing the conditions and exceptions to be assigned to the attack group.
+        Average rate (in bytes per second over the specified time period) allowed before the specified action is triggered
         """
-        return pulumi.get(self, "condition_exception")
+        return pulumi.get(self, "slow_rate_threshold_rate")
 
-    @condition_exception.setter
-    def condition_exception(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "condition_exception", value)
+    @slow_rate_threshold_rate.setter
+    def slow_rate_threshold_rate(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "slow_rate_threshold_rate", value)
+
+
+@pulumi.input_type
+class _AppSecSlowPostState:
+    def __init__(__self__, *,
+                 config_id: Optional[pulumi.Input[int]] = None,
+                 duration_threshold_timeout: Optional[pulumi.Input[int]] = None,
+                 security_policy_id: Optional[pulumi.Input[str]] = None,
+                 slow_rate_action: Optional[pulumi.Input[str]] = None,
+                 slow_rate_threshold_period: Optional[pulumi.Input[int]] = None,
+                 slow_rate_threshold_rate: Optional[pulumi.Input[int]] = None):
+        """
+        Input properties used for looking up and filtering AppSecSlowPost resources.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[int] duration_threshold_timeout: Maximum amount of time (in seconds) within which the first 8KB of the POST body must be received to avoid triggering the
+               specified action
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
+        :param pulumi.Input[str] slow_rate_action: Action to be taken when slow POST protection is triggered
+        :param pulumi.Input[int] slow_rate_threshold_period: Amount of time (in seconds) that the server should allow a request before marking the request as being too slow
+        :param pulumi.Input[int] slow_rate_threshold_rate: Average rate (in bytes per second over the specified time period) allowed before the specified action is triggered
+        """
+        if config_id is not None:
+            pulumi.set(__self__, "config_id", config_id)
+        if duration_threshold_timeout is not None:
+            pulumi.set(__self__, "duration_threshold_timeout", duration_threshold_timeout)
+        if security_policy_id is not None:
+            pulumi.set(__self__, "security_policy_id", security_policy_id)
+        if slow_rate_action is not None:
+            pulumi.set(__self__, "slow_rate_action", slow_rate_action)
+        if slow_rate_threshold_period is not None:
+            pulumi.set(__self__, "slow_rate_threshold_period", slow_rate_threshold_period)
+        if slow_rate_threshold_rate is not None:
+            pulumi.set(__self__, "slow_rate_threshold_rate", slow_rate_threshold_rate)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security configuration associated with the attack group being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "config_id", value)
 
     @property
+    @pulumi.getter(name="durationThresholdTimeout")
+    def duration_threshold_timeout(self) -> Optional[pulumi.Input[int]]:
+        """
+        Maximum amount of time (in seconds) within which the first 8KB of the POST body must be received to avoid triggering the
+        specified action
+        """
+        return pulumi.get(self, "duration_threshold_timeout")
+
+    @duration_threshold_timeout.setter
+    def duration_threshold_timeout(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "duration_threshold_timeout", value)
+
+    @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the security policy associated with the attack group being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "security_policy_id", value)
 
+    @property
+    @pulumi.getter(name="slowRateAction")
+    def slow_rate_action(self) -> Optional[pulumi.Input[str]]:
+        """
+        Action to be taken when slow POST protection is triggered
+        """
+        return pulumi.get(self, "slow_rate_action")
+
+    @slow_rate_action.setter
+    def slow_rate_action(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "slow_rate_action", value)
 
-class AppSecAttackGroup(pulumi.CustomResource):
+    @property
+    @pulumi.getter(name="slowRateThresholdPeriod")
+    def slow_rate_threshold_period(self) -> Optional[pulumi.Input[int]]:
+        """
+        Amount of time (in seconds) that the server should allow a request before marking the request as being too slow
+        """
+        return pulumi.get(self, "slow_rate_threshold_period")
+
+    @slow_rate_threshold_period.setter
+    def slow_rate_threshold_period(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "slow_rate_threshold_period", value)
+
+    @property
+    @pulumi.getter(name="slowRateThresholdRate")
+    def slow_rate_threshold_rate(self) -> Optional[pulumi.Input[int]]:
+        """
+        Average rate (in bytes per second over the specified time period) allowed before the specified action is triggered
+        """
+        return pulumi.get(self, "slow_rate_threshold_rate")
+
+    @slow_rate_threshold_rate.setter
+    def slow_rate_threshold_rate(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "slow_rate_threshold_rate", value)
+
+
+class AppSecSlowPost(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 attack_group: Optional[pulumi.Input[str]] = None,
-                 attack_group_action: Optional[pulumi.Input[str]] = None,
-                 condition_exception: Optional[pulumi.Input[str]] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
+                 duration_threshold_timeout: Optional[pulumi.Input[int]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
+                 slow_rate_action: Optional[pulumi.Input[str]] = None,
+                 slow_rate_threshold_period: Optional[pulumi.Input[int]] = None,
+                 slow_rate_threshold_rate: Optional[pulumi.Input[int]] = None,
                  __props__=None):
         """
-        **Scopes**: Attack group
-
-        Modify an attack group's action, conditions, and exceptions. Attack groups are collections of Kona Rule Set rules used to streamline the management of website protections.
-
-        **Related API Endpoints**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/attack-groups/{attackGroupId}](https://techdocs.akamai.com/application-security/reference/put-attack-group-condition-exception) *and* [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/attack-groups/{attackGroupId}/condition-exception](https://techdocs.akamai.com/application-security/reference/put-attack-group-condition-exception)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        attack_group = akamai.AppSecAttackGroup("attackGroup",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            attack_group="SQL",
-            attack_group_action="deny",
-            condition_exception=(lambda path: open(path).read())(f"{path['module']}/condition_exception.json"))
-        ```
-
+        Create a AppSecSlowPost resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] attack_group: . Unique name of the attack group being modified.
-        :param pulumi.Input[str] attack_group_action: . Action taken any time the attack group is triggered. Allowed values are:
-               - **alert**. Record information about the request.
-               - **deny**. Block the request,
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action.
-        :param pulumi.Input[str] condition_exception: . Path to a JSON file containing the conditions and exceptions to be assigned to the attack group.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the attack group being modified.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the attack group being modified.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[int] duration_threshold_timeout: Maximum amount of time (in seconds) within which the first 8KB of the POST body must be received to avoid triggering the
+               specified action
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
+        :param pulumi.Input[str] slow_rate_action: Action to be taken when slow POST protection is triggered
+        :param pulumi.Input[int] slow_rate_threshold_period: Amount of time (in seconds) that the server should allow a request before marking the request as being too slow
+        :param pulumi.Input[int] slow_rate_threshold_rate: Average rate (in bytes per second over the specified time period) allowed before the specified action is triggered
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: AppSecAttackGroupArgs,
+                 args: AppSecSlowPostArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Attack group
-
-        Modify an attack group's action, conditions, and exceptions. Attack groups are collections of Kona Rule Set rules used to streamline the management of website protections.
-
-        **Related API Endpoints**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/attack-groups/{attackGroupId}](https://techdocs.akamai.com/application-security/reference/put-attack-group-condition-exception) *and* [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/attack-groups/{attackGroupId}/condition-exception](https://techdocs.akamai.com/application-security/reference/put-attack-group-condition-exception)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        attack_group = akamai.AppSecAttackGroup("attackGroup",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            attack_group="SQL",
-            attack_group_action="deny",
-            condition_exception=(lambda path: open(path).read())(f"{path['module']}/condition_exception.json"))
-        ```
-
+        Create a AppSecSlowPost resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param AppSecAttackGroupArgs args: The arguments to use to populate this resource's properties.
+        :param AppSecSlowPostArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(AppSecAttackGroupArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(AppSecSlowPostArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 attack_group: Optional[pulumi.Input[str]] = None,
-                 attack_group_action: Optional[pulumi.Input[str]] = None,
-                 condition_exception: Optional[pulumi.Input[str]] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
+                 duration_threshold_timeout: Optional[pulumi.Input[int]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
+                 slow_rate_action: Optional[pulumi.Input[str]] = None,
+                 slow_rate_threshold_period: Optional[pulumi.Input[int]] = None,
+                 slow_rate_threshold_rate: Optional[pulumi.Input[int]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = AppSecAttackGroupArgs.__new__(AppSecAttackGroupArgs)
+            __props__ = AppSecSlowPostArgs.__new__(AppSecSlowPostArgs)
 
-            if attack_group is None and not opts.urn:
-                raise TypeError("Missing required property 'attack_group'")
-            __props__.__dict__["attack_group"] = attack_group
-            if attack_group_action is None and not opts.urn:
-                raise TypeError("Missing required property 'attack_group_action'")
-            __props__.__dict__["attack_group_action"] = attack_group_action
-            __props__.__dict__["condition_exception"] = condition_exception
             if config_id is None and not opts.urn:
                 raise TypeError("Missing required property 'config_id'")
             __props__.__dict__["config_id"] = config_id
+            __props__.__dict__["duration_threshold_timeout"] = duration_threshold_timeout
             if security_policy_id is None and not opts.urn:
                 raise TypeError("Missing required property 'security_policy_id'")
             __props__.__dict__["security_policy_id"] = security_policy_id
-        super(AppSecAttackGroup, __self__).__init__(
-            'akamai:index/appSecAttackGroup:AppSecAttackGroup',
+            if slow_rate_action is None and not opts.urn:
+                raise TypeError("Missing required property 'slow_rate_action'")
+            __props__.__dict__["slow_rate_action"] = slow_rate_action
+            __props__.__dict__["slow_rate_threshold_period"] = slow_rate_threshold_period
+            __props__.__dict__["slow_rate_threshold_rate"] = slow_rate_threshold_rate
+        super(AppSecSlowPost, __self__).__init__(
+            'akamai:index/appSecSlowPost:AppSecSlowPost',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
-            attack_group: Optional[pulumi.Input[str]] = None,
-            attack_group_action: Optional[pulumi.Input[str]] = None,
-            condition_exception: Optional[pulumi.Input[str]] = None,
             config_id: Optional[pulumi.Input[int]] = None,
-            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecAttackGroup':
+            duration_threshold_timeout: Optional[pulumi.Input[int]] = None,
+            security_policy_id: Optional[pulumi.Input[str]] = None,
+            slow_rate_action: Optional[pulumi.Input[str]] = None,
+            slow_rate_threshold_period: Optional[pulumi.Input[int]] = None,
+            slow_rate_threshold_rate: Optional[pulumi.Input[int]] = None) -> 'AppSecSlowPost':
         """
-        Get an existing AppSecAttackGroup resource's state with the given name, id, and optional extra
+        Get an existing AppSecSlowPost resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] attack_group: . Unique name of the attack group being modified.
-        :param pulumi.Input[str] attack_group_action: . Action taken any time the attack group is triggered. Allowed values are:
-               - **alert**. Record information about the request.
-               - **deny**. Block the request,
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action.
-        :param pulumi.Input[str] condition_exception: . Path to a JSON file containing the conditions and exceptions to be assigned to the attack group.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the attack group being modified.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the attack group being modified.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[int] duration_threshold_timeout: Maximum amount of time (in seconds) within which the first 8KB of the POST body must be received to avoid triggering the
+               specified action
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
+        :param pulumi.Input[str] slow_rate_action: Action to be taken when slow POST protection is triggered
+        :param pulumi.Input[int] slow_rate_threshold_period: Amount of time (in seconds) that the server should allow a request before marking the request as being too slow
+        :param pulumi.Input[int] slow_rate_threshold_rate: Average rate (in bytes per second over the specified time period) allowed before the specified action is triggered
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _AppSecAttackGroupState.__new__(_AppSecAttackGroupState)
+        __props__ = _AppSecSlowPostState.__new__(_AppSecSlowPostState)
 
-        __props__.__dict__["attack_group"] = attack_group
-        __props__.__dict__["attack_group_action"] = attack_group_action
-        __props__.__dict__["condition_exception"] = condition_exception
         __props__.__dict__["config_id"] = config_id
+        __props__.__dict__["duration_threshold_timeout"] = duration_threshold_timeout
         __props__.__dict__["security_policy_id"] = security_policy_id
-        return AppSecAttackGroup(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["slow_rate_action"] = slow_rate_action
+        __props__.__dict__["slow_rate_threshold_period"] = slow_rate_threshold_period
+        __props__.__dict__["slow_rate_threshold_rate"] = slow_rate_threshold_rate
+        return AppSecSlowPost(resource_name, opts=opts, __props__=__props__)
+
+    @property
+    @pulumi.getter(name="configId")
+    def config_id(self) -> pulumi.Output[int]:
+        """
+        Unique identifier of the security configuration
+        """
+        return pulumi.get(self, "config_id")
 
     @property
-    @pulumi.getter(name="attackGroup")
-    def attack_group(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="durationThresholdTimeout")
+    def duration_threshold_timeout(self) -> pulumi.Output[Optional[int]]:
         """
-        . Unique name of the attack group being modified.
+        Maximum amount of time (in seconds) within which the first 8KB of the POST body must be received to avoid triggering the
+        specified action
         """
-        return pulumi.get(self, "attack_group")
+        return pulumi.get(self, "duration_threshold_timeout")
 
     @property
-    @pulumi.getter(name="attackGroupAction")
-    def attack_group_action(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="securityPolicyId")
+    def security_policy_id(self) -> pulumi.Output[str]:
         """
-        . Action taken any time the attack group is triggered. Allowed values are:
-        - **alert**. Record information about the request.
-        - **deny**. Block the request,
-        - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-        - **none**. Take no action.
+        Unique identifier of the security policy
         """
-        return pulumi.get(self, "attack_group_action")
+        return pulumi.get(self, "security_policy_id")
 
     @property
-    @pulumi.getter(name="conditionException")
-    def condition_exception(self) -> pulumi.Output[Optional[str]]:
+    @pulumi.getter(name="slowRateAction")
+    def slow_rate_action(self) -> pulumi.Output[str]:
         """
-        . Path to a JSON file containing the conditions and exceptions to be assigned to the attack group.
+        Action to be taken when slow POST protection is triggered
         """
-        return pulumi.get(self, "condition_exception")
+        return pulumi.get(self, "slow_rate_action")
 
     @property
-    @pulumi.getter(name="configId")
-    def config_id(self) -> pulumi.Output[int]:
+    @pulumi.getter(name="slowRateThresholdPeriod")
+    def slow_rate_threshold_period(self) -> pulumi.Output[Optional[int]]:
         """
-        . Unique identifier of the security configuration associated with the attack group being modified.
+        Amount of time (in seconds) that the server should allow a request before marking the request as being too slow
         """
-        return pulumi.get(self, "config_id")
+        return pulumi.get(self, "slow_rate_threshold_period")
 
     @property
-    @pulumi.getter(name="securityPolicyId")
-    def security_policy_id(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="slowRateThresholdRate")
+    def slow_rate_threshold_rate(self) -> pulumi.Output[Optional[int]]:
         """
-        . Unique identifier of the security policy associated with the attack group being modified.
+        Average rate (in bytes per second over the specified time period) allowed before the specified action is triggered
         """
-        return pulumi.get(self, "security_policy_id")
+        return pulumi.get(self, "slow_rate_threshold_rate")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_by_pass_network_list.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/cloudlets_policy_activation.py`

 * *Files 19% similar despite different names*

```diff
@@ -5,296 +5,312 @@
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
-__all__ = ['AppSecByPassNetworkListArgs', 'AppSecByPassNetworkList']
+__all__ = ['CloudletsPolicyActivationArgs', 'CloudletsPolicyActivation']
 
 @pulumi.input_type
-class AppSecByPassNetworkListArgs:
+class CloudletsPolicyActivationArgs:
     def __init__(__self__, *,
-                 bypass_network_lists: pulumi.Input[Sequence[pulumi.Input[str]]],
-                 config_id: pulumi.Input[int],
-                 security_policy_id: pulumi.Input[str]):
+                 associated_properties: pulumi.Input[Sequence[pulumi.Input[str]]],
+                 network: pulumi.Input[str],
+                 policy_id: pulumi.Input[int],
+                 version: pulumi.Input[int]):
+        """
+        The set of arguments for constructing a CloudletsPolicyActivation resource.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] associated_properties: Set of property IDs to link to this Cloudlets policy
+        :param pulumi.Input[str] network: The network you want to activate the policy version on (options are Staging and Production)
+        :param pulumi.Input[int] policy_id: ID of the Cloudlets policy you want to activate
+        :param pulumi.Input[int] version: Cloudlets policy version you want to activate
+        """
+        pulumi.set(__self__, "associated_properties", associated_properties)
+        pulumi.set(__self__, "network", network)
+        pulumi.set(__self__, "policy_id", policy_id)
+        pulumi.set(__self__, "version", version)
+
+    @property
+    @pulumi.getter(name="associatedProperties")
+    def associated_properties(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
         """
-        The set of arguments for constructing a AppSecByPassNetworkList resource.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] bypass_network_lists: . JSON array of network IDs that comprise the bypass list.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the bypass network lists being modified.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the bypass network lists.
+        Set of property IDs to link to this Cloudlets policy
         """
-        pulumi.set(__self__, "bypass_network_lists", bypass_network_lists)
-        pulumi.set(__self__, "config_id", config_id)
-        pulumi.set(__self__, "security_policy_id", security_policy_id)
+        return pulumi.get(self, "associated_properties")
+
+    @associated_properties.setter
+    def associated_properties(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
+        pulumi.set(self, "associated_properties", value)
 
     @property
-    @pulumi.getter(name="bypassNetworkLists")
-    def bypass_network_lists(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
+    @pulumi.getter
+    def network(self) -> pulumi.Input[str]:
         """
-        . JSON array of network IDs that comprise the bypass list.
+        The network you want to activate the policy version on (options are Staging and Production)
         """
-        return pulumi.get(self, "bypass_network_lists")
+        return pulumi.get(self, "network")
 
-    @bypass_network_lists.setter
-    def bypass_network_lists(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
-        pulumi.set(self, "bypass_network_lists", value)
+    @network.setter
+    def network(self, value: pulumi.Input[str]):
+        pulumi.set(self, "network", value)
 
     @property
-    @pulumi.getter(name="configId")
-    def config_id(self) -> pulumi.Input[int]:
+    @pulumi.getter(name="policyId")
+    def policy_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuration associated with the bypass network lists being modified.
+        ID of the Cloudlets policy you want to activate
         """
-        return pulumi.get(self, "config_id")
+        return pulumi.get(self, "policy_id")
 
-    @config_id.setter
-    def config_id(self, value: pulumi.Input[int]):
-        pulumi.set(self, "config_id", value)
+    @policy_id.setter
+    def policy_id(self, value: pulumi.Input[int]):
+        pulumi.set(self, "policy_id", value)
 
     @property
-    @pulumi.getter(name="securityPolicyId")
-    def security_policy_id(self) -> pulumi.Input[str]:
+    @pulumi.getter
+    def version(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security policy associated with the bypass network lists.
+        Cloudlets policy version you want to activate
         """
-        return pulumi.get(self, "security_policy_id")
+        return pulumi.get(self, "version")
 
-    @security_policy_id.setter
-    def security_policy_id(self, value: pulumi.Input[str]):
-        pulumi.set(self, "security_policy_id", value)
+    @version.setter
+    def version(self, value: pulumi.Input[int]):
+        pulumi.set(self, "version", value)
 
 
 @pulumi.input_type
-class _AppSecByPassNetworkListState:
+class _CloudletsPolicyActivationState:
     def __init__(__self__, *,
-                 bypass_network_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 config_id: Optional[pulumi.Input[int]] = None,
-                 security_policy_id: Optional[pulumi.Input[str]] = None):
+                 associated_properties: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 network: Optional[pulumi.Input[str]] = None,
+                 policy_id: Optional[pulumi.Input[int]] = None,
+                 status: Optional[pulumi.Input[str]] = None,
+                 version: Optional[pulumi.Input[int]] = None):
+        """
+        Input properties used for looking up and filtering CloudletsPolicyActivation resources.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] associated_properties: Set of property IDs to link to this Cloudlets policy
+        :param pulumi.Input[str] network: The network you want to activate the policy version on (options are Staging and Production)
+        :param pulumi.Input[int] policy_id: ID of the Cloudlets policy you want to activate
+        :param pulumi.Input[str] status: Activation status for this Cloudlets policy
+        :param pulumi.Input[int] version: Cloudlets policy version you want to activate
+        """
+        if associated_properties is not None:
+            pulumi.set(__self__, "associated_properties", associated_properties)
+        if network is not None:
+            pulumi.set(__self__, "network", network)
+        if policy_id is not None:
+            pulumi.set(__self__, "policy_id", policy_id)
+        if status is not None:
+            pulumi.set(__self__, "status", status)
+        if version is not None:
+            pulumi.set(__self__, "version", version)
+
+    @property
+    @pulumi.getter(name="associatedProperties")
+    def associated_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
+        """
+        Set of property IDs to link to this Cloudlets policy
+        """
+        return pulumi.get(self, "associated_properties")
+
+    @associated_properties.setter
+    def associated_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
+        pulumi.set(self, "associated_properties", value)
+
+    @property
+    @pulumi.getter
+    def network(self) -> Optional[pulumi.Input[str]]:
         """
-        Input properties used for looking up and filtering AppSecByPassNetworkList resources.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] bypass_network_lists: . JSON array of network IDs that comprise the bypass list.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the bypass network lists being modified.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the bypass network lists.
+        The network you want to activate the policy version on (options are Staging and Production)
         """
-        if bypass_network_lists is not None:
-            pulumi.set(__self__, "bypass_network_lists", bypass_network_lists)
-        if config_id is not None:
-            pulumi.set(__self__, "config_id", config_id)
-        if security_policy_id is not None:
-            pulumi.set(__self__, "security_policy_id", security_policy_id)
+        return pulumi.get(self, "network")
+
+    @network.setter
+    def network(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "network", value)
 
     @property
-    @pulumi.getter(name="bypassNetworkLists")
-    def bypass_network_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
+    @pulumi.getter(name="policyId")
+    def policy_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . JSON array of network IDs that comprise the bypass list.
+        ID of the Cloudlets policy you want to activate
         """
-        return pulumi.get(self, "bypass_network_lists")
+        return pulumi.get(self, "policy_id")
 
-    @bypass_network_lists.setter
-    def bypass_network_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
-        pulumi.set(self, "bypass_network_lists", value)
+    @policy_id.setter
+    def policy_id(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "policy_id", value)
 
     @property
-    @pulumi.getter(name="configId")
-    def config_id(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter
+    def status(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the security configuration associated with the bypass network lists being modified.
+        Activation status for this Cloudlets policy
         """
-        return pulumi.get(self, "config_id")
+        return pulumi.get(self, "status")
 
-    @config_id.setter
-    def config_id(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "config_id", value)
+    @status.setter
+    def status(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "status", value)
 
     @property
-    @pulumi.getter(name="securityPolicyId")
-    def security_policy_id(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter
+    def version(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security policy associated with the bypass network lists.
+        Cloudlets policy version you want to activate
         """
-        return pulumi.get(self, "security_policy_id")
+        return pulumi.get(self, "version")
 
-    @security_policy_id.setter
-    def security_policy_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "security_policy_id", value)
+    @version.setter
+    def version(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "version", value)
 
 
-class AppSecByPassNetworkList(pulumi.CustomResource):
+class CloudletsPolicyActivation(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 bypass_network_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 config_id: Optional[pulumi.Input[int]] = None,
-                 security_policy_id: Optional[pulumi.Input[str]] = None,
+                 associated_properties: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 network: Optional[pulumi.Input[str]] = None,
+                 policy_id: Optional[pulumi.Input[int]] = None,
+                 version: Optional[pulumi.Input[int]] = None,
                  __props__=None):
         """
-        **Scopes**: Security configuration
-
-        Specifies the networks that appear on the bypass network list. Networks on this list are allowed to bypass the Web Application Firewall.
-
-        Note that this resource is only applicable to WAP (Web Application Protector) configurations.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/bypass-network-lists](https://techdocs.akamai.com/application-security/reference/put-bypass-network-lists)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        bypass_network_lists = akamai.AppSecByPassNetworkList("bypassNetworkLists",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            bypass_network_lists=[
-                "DocumentationNetworkList",
-                "TrainingNetworkList",
-            ])
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `output_text`. Tabular report showing the updated list of bypass network IDs.
-
+        Create a CloudletsPolicyActivation resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] bypass_network_lists: . JSON array of network IDs that comprise the bypass list.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the bypass network lists being modified.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the bypass network lists.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] associated_properties: Set of property IDs to link to this Cloudlets policy
+        :param pulumi.Input[str] network: The network you want to activate the policy version on (options are Staging and Production)
+        :param pulumi.Input[int] policy_id: ID of the Cloudlets policy you want to activate
+        :param pulumi.Input[int] version: Cloudlets policy version you want to activate
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: AppSecByPassNetworkListArgs,
+                 args: CloudletsPolicyActivationArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Security configuration
-
-        Specifies the networks that appear on the bypass network list. Networks on this list are allowed to bypass the Web Application Firewall.
-
-        Note that this resource is only applicable to WAP (Web Application Protector) configurations.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/bypass-network-lists](https://techdocs.akamai.com/application-security/reference/put-bypass-network-lists)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        bypass_network_lists = akamai.AppSecByPassNetworkList("bypassNetworkLists",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            bypass_network_lists=[
-                "DocumentationNetworkList",
-                "TrainingNetworkList",
-            ])
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `output_text`. Tabular report showing the updated list of bypass network IDs.
-
+        Create a CloudletsPolicyActivation resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param AppSecByPassNetworkListArgs args: The arguments to use to populate this resource's properties.
+        :param CloudletsPolicyActivationArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(AppSecByPassNetworkListArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(CloudletsPolicyActivationArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 bypass_network_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 config_id: Optional[pulumi.Input[int]] = None,
-                 security_policy_id: Optional[pulumi.Input[str]] = None,
+                 associated_properties: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 network: Optional[pulumi.Input[str]] = None,
+                 policy_id: Optional[pulumi.Input[int]] = None,
+                 version: Optional[pulumi.Input[int]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = AppSecByPassNetworkListArgs.__new__(AppSecByPassNetworkListArgs)
+            __props__ = CloudletsPolicyActivationArgs.__new__(CloudletsPolicyActivationArgs)
 
-            if bypass_network_lists is None and not opts.urn:
-                raise TypeError("Missing required property 'bypass_network_lists'")
-            __props__.__dict__["bypass_network_lists"] = bypass_network_lists
-            if config_id is None and not opts.urn:
-                raise TypeError("Missing required property 'config_id'")
-            __props__.__dict__["config_id"] = config_id
-            if security_policy_id is None and not opts.urn:
-                raise TypeError("Missing required property 'security_policy_id'")
-            __props__.__dict__["security_policy_id"] = security_policy_id
-        super(AppSecByPassNetworkList, __self__).__init__(
-            'akamai:index/appSecByPassNetworkList:AppSecByPassNetworkList',
+            if associated_properties is None and not opts.urn:
+                raise TypeError("Missing required property 'associated_properties'")
+            __props__.__dict__["associated_properties"] = associated_properties
+            if network is None and not opts.urn:
+                raise TypeError("Missing required property 'network'")
+            __props__.__dict__["network"] = network
+            if policy_id is None and not opts.urn:
+                raise TypeError("Missing required property 'policy_id'")
+            __props__.__dict__["policy_id"] = policy_id
+            if version is None and not opts.urn:
+                raise TypeError("Missing required property 'version'")
+            __props__.__dict__["version"] = version
+            __props__.__dict__["status"] = None
+        super(CloudletsPolicyActivation, __self__).__init__(
+            'akamai:index/cloudletsPolicyActivation:CloudletsPolicyActivation',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
-            bypass_network_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-            config_id: Optional[pulumi.Input[int]] = None,
-            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecByPassNetworkList':
+            associated_properties: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+            network: Optional[pulumi.Input[str]] = None,
+            policy_id: Optional[pulumi.Input[int]] = None,
+            status: Optional[pulumi.Input[str]] = None,
+            version: Optional[pulumi.Input[int]] = None) -> 'CloudletsPolicyActivation':
         """
-        Get an existing AppSecByPassNetworkList resource's state with the given name, id, and optional extra
+        Get an existing CloudletsPolicyActivation resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] bypass_network_lists: . JSON array of network IDs that comprise the bypass list.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the bypass network lists being modified.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the bypass network lists.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] associated_properties: Set of property IDs to link to this Cloudlets policy
+        :param pulumi.Input[str] network: The network you want to activate the policy version on (options are Staging and Production)
+        :param pulumi.Input[int] policy_id: ID of the Cloudlets policy you want to activate
+        :param pulumi.Input[str] status: Activation status for this Cloudlets policy
+        :param pulumi.Input[int] version: Cloudlets policy version you want to activate
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _AppSecByPassNetworkListState.__new__(_AppSecByPassNetworkListState)
+        __props__ = _CloudletsPolicyActivationState.__new__(_CloudletsPolicyActivationState)
+
+        __props__.__dict__["associated_properties"] = associated_properties
+        __props__.__dict__["network"] = network
+        __props__.__dict__["policy_id"] = policy_id
+        __props__.__dict__["status"] = status
+        __props__.__dict__["version"] = version
+        return CloudletsPolicyActivation(resource_name, opts=opts, __props__=__props__)
 
-        __props__.__dict__["bypass_network_lists"] = bypass_network_lists
-        __props__.__dict__["config_id"] = config_id
-        __props__.__dict__["security_policy_id"] = security_policy_id
-        return AppSecByPassNetworkList(resource_name, opts=opts, __props__=__props__)
+    @property
+    @pulumi.getter(name="associatedProperties")
+    def associated_properties(self) -> pulumi.Output[Sequence[str]]:
+        """
+        Set of property IDs to link to this Cloudlets policy
+        """
+        return pulumi.get(self, "associated_properties")
+
+    @property
+    @pulumi.getter
+    def network(self) -> pulumi.Output[str]:
+        """
+        The network you want to activate the policy version on (options are Staging and Production)
+        """
+        return pulumi.get(self, "network")
 
     @property
-    @pulumi.getter(name="bypassNetworkLists")
-    def bypass_network_lists(self) -> pulumi.Output[Sequence[str]]:
+    @pulumi.getter(name="policyId")
+    def policy_id(self) -> pulumi.Output[int]:
         """
-        . JSON array of network IDs that comprise the bypass list.
+        ID of the Cloudlets policy you want to activate
         """
-        return pulumi.get(self, "bypass_network_lists")
+        return pulumi.get(self, "policy_id")
 
     @property
-    @pulumi.getter(name="configId")
-    def config_id(self) -> pulumi.Output[int]:
+    @pulumi.getter
+    def status(self) -> pulumi.Output[str]:
         """
-        . Unique identifier of the security configuration associated with the bypass network lists being modified.
+        Activation status for this Cloudlets policy
         """
-        return pulumi.get(self, "config_id")
+        return pulumi.get(self, "status")
 
     @property
-    @pulumi.getter(name="securityPolicyId")
-    def security_policy_id(self) -> pulumi.Output[str]:
+    @pulumi.getter
+    def version(self) -> pulumi.Output[int]:
         """
-        . Unique identifier of the security policy associated with the bypass network lists.
+        Cloudlets policy version you want to activate
         """
-        return pulumi.get(self, "security_policy_id")
+        return pulumi.get(self, "version")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_configuration.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/property_include_activation.py`

 * *Files 19% similar despite different names*

```diff
@@ -4,534 +4,552 @@
 
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
+from . import outputs
+from ._inputs import *
 
-__all__ = ['AppSecConfigurationArgs', 'AppSecConfiguration']
+__all__ = ['PropertyIncludeActivationArgs', 'PropertyIncludeActivation']
 
 @pulumi.input_type
-class AppSecConfigurationArgs:
+class PropertyIncludeActivationArgs:
     def __init__(__self__, *,
                  contract_id: pulumi.Input[str],
-                 description: pulumi.Input[str],
-                 group_id: pulumi.Input[int],
-                 host_names: pulumi.Input[Sequence[pulumi.Input[str]]],
-                 create_from_config_id: Optional[pulumi.Input[int]] = None,
-                 create_from_version: Optional[pulumi.Input[int]] = None,
-                 name: Optional[pulumi.Input[str]] = None):
-        """
-        The set of arguments for constructing a AppSecConfiguration resource.
-        :param pulumi.Input[str] contract_id: . Unique identifier of the Akamai contract associated with the new configuration.
-        :param pulumi.Input[str] description: . Brief description of the new configuration.
-        :param pulumi.Input[int] group_id: . Unique identifier of the contract group associated with the new configuration.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] host_names: . JSON array containing the hostnames to be protected by the new configuration. You must specify at least one hostname in order to create a new configuration.
-        :param pulumi.Input[int] create_from_config_id: . Unique identifier of the existing configuration being cloned in order to create the new configuration.
-        :param pulumi.Input[int] create_from_version: . Version number of the security configuration being cloned.
-        :param pulumi.Input[str] name: . Name of the new configuration.
+                 group_id: pulumi.Input[str],
+                 include_id: pulumi.Input[str],
+                 network: pulumi.Input[str],
+                 notify_emails: pulumi.Input[Sequence[pulumi.Input[str]]],
+                 version: pulumi.Input[int],
+                 auto_acknowledge_rule_warnings: Optional[pulumi.Input[bool]] = None,
+                 compliance_record: Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordArgs']] = None,
+                 note: Optional[pulumi.Input[str]] = None):
+        """
+        The set of arguments for constructing a PropertyIncludeActivation resource.
+        :param pulumi.Input[str] contract_id: The contract under which the include is activated
+        :param pulumi.Input[str] group_id: The group under which the include is activated
+        :param pulumi.Input[str] include_id: The unique identifier of the include
+        :param pulumi.Input[str] network: The network for which the activation will be performed
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notify_emails: The list of email addresses to notify about an activation status
+        :param pulumi.Input[int] version: The unique identifier of the include
+        :param pulumi.Input[bool] auto_acknowledge_rule_warnings: Automatically acknowledge all rule warnings for activation and continue
+        :param pulumi.Input['PropertyIncludeActivationComplianceRecordArgs'] compliance_record: Provides an audit record when activating on a production network
+        :param pulumi.Input[str] note: The note to assign to a log message of the activation request
         """
         pulumi.set(__self__, "contract_id", contract_id)
-        pulumi.set(__self__, "description", description)
         pulumi.set(__self__, "group_id", group_id)
-        pulumi.set(__self__, "host_names", host_names)
-        if create_from_config_id is not None:
-            pulumi.set(__self__, "create_from_config_id", create_from_config_id)
-        if create_from_version is not None:
-            pulumi.set(__self__, "create_from_version", create_from_version)
-        if name is not None:
-            pulumi.set(__self__, "name", name)
+        pulumi.set(__self__, "include_id", include_id)
+        pulumi.set(__self__, "network", network)
+        pulumi.set(__self__, "notify_emails", notify_emails)
+        pulumi.set(__self__, "version", version)
+        if auto_acknowledge_rule_warnings is not None:
+            pulumi.set(__self__, "auto_acknowledge_rule_warnings", auto_acknowledge_rule_warnings)
+        if compliance_record is not None:
+            pulumi.set(__self__, "compliance_record", compliance_record)
+        if note is not None:
+            pulumi.set(__self__, "note", note)
 
     @property
     @pulumi.getter(name="contractId")
     def contract_id(self) -> pulumi.Input[str]:
         """
-        . Unique identifier of the Akamai contract associated with the new configuration.
+        The contract under which the include is activated
         """
         return pulumi.get(self, "contract_id")
 
     @contract_id.setter
     def contract_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "contract_id", value)
 
     @property
+    @pulumi.getter(name="groupId")
+    def group_id(self) -> pulumi.Input[str]:
+        """
+        The group under which the include is activated
+        """
+        return pulumi.get(self, "group_id")
+
+    @group_id.setter
+    def group_id(self, value: pulumi.Input[str]):
+        pulumi.set(self, "group_id", value)
+
+    @property
+    @pulumi.getter(name="includeId")
+    def include_id(self) -> pulumi.Input[str]:
+        """
+        The unique identifier of the include
+        """
+        return pulumi.get(self, "include_id")
+
+    @include_id.setter
+    def include_id(self, value: pulumi.Input[str]):
+        pulumi.set(self, "include_id", value)
+
+    @property
     @pulumi.getter
-    def description(self) -> pulumi.Input[str]:
+    def network(self) -> pulumi.Input[str]:
         """
-        . Brief description of the new configuration.
+        The network for which the activation will be performed
         """
-        return pulumi.get(self, "description")
+        return pulumi.get(self, "network")
 
-    @description.setter
-    def description(self, value: pulumi.Input[str]):
-        pulumi.set(self, "description", value)
+    @network.setter
+    def network(self, value: pulumi.Input[str]):
+        pulumi.set(self, "network", value)
 
     @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> pulumi.Input[int]:
+    @pulumi.getter(name="notifyEmails")
+    def notify_emails(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
         """
-        . Unique identifier of the contract group associated with the new configuration.
+        The list of email addresses to notify about an activation status
         """
-        return pulumi.get(self, "group_id")
+        return pulumi.get(self, "notify_emails")
 
-    @group_id.setter
-    def group_id(self, value: pulumi.Input[int]):
-        pulumi.set(self, "group_id", value)
+    @notify_emails.setter
+    def notify_emails(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
+        pulumi.set(self, "notify_emails", value)
 
     @property
-    @pulumi.getter(name="hostNames")
-    def host_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
+    @pulumi.getter
+    def version(self) -> pulumi.Input[int]:
         """
-        . JSON array containing the hostnames to be protected by the new configuration. You must specify at least one hostname in order to create a new configuration.
+        The unique identifier of the include
         """
-        return pulumi.get(self, "host_names")
+        return pulumi.get(self, "version")
 
-    @host_names.setter
-    def host_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
-        pulumi.set(self, "host_names", value)
+    @version.setter
+    def version(self, value: pulumi.Input[int]):
+        pulumi.set(self, "version", value)
 
     @property
-    @pulumi.getter(name="createFromConfigId")
-    def create_from_config_id(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="autoAcknowledgeRuleWarnings")
+    def auto_acknowledge_rule_warnings(self) -> Optional[pulumi.Input[bool]]:
         """
-        . Unique identifier of the existing configuration being cloned in order to create the new configuration.
+        Automatically acknowledge all rule warnings for activation and continue
         """
-        return pulumi.get(self, "create_from_config_id")
+        return pulumi.get(self, "auto_acknowledge_rule_warnings")
 
-    @create_from_config_id.setter
-    def create_from_config_id(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "create_from_config_id", value)
+    @auto_acknowledge_rule_warnings.setter
+    def auto_acknowledge_rule_warnings(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "auto_acknowledge_rule_warnings", value)
 
     @property
-    @pulumi.getter(name="createFromVersion")
-    def create_from_version(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="complianceRecord")
+    def compliance_record(self) -> Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordArgs']]:
         """
-        . Version number of the security configuration being cloned.
+        Provides an audit record when activating on a production network
         """
-        return pulumi.get(self, "create_from_version")
+        return pulumi.get(self, "compliance_record")
 
-    @create_from_version.setter
-    def create_from_version(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "create_from_version", value)
+    @compliance_record.setter
+    def compliance_record(self, value: Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordArgs']]):
+        pulumi.set(self, "compliance_record", value)
 
     @property
     @pulumi.getter
-    def name(self) -> Optional[pulumi.Input[str]]:
+    def note(self) -> Optional[pulumi.Input[str]]:
         """
-        . Name of the new configuration.
+        The note to assign to a log message of the activation request
         """
-        return pulumi.get(self, "name")
+        return pulumi.get(self, "note")
 
-    @name.setter
-    def name(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "name", value)
+    @note.setter
+    def note(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "note", value)
 
 
 @pulumi.input_type
-class _AppSecConfigurationState:
+class _PropertyIncludeActivationState:
     def __init__(__self__, *,
-                 config_id: Optional[pulumi.Input[int]] = None,
+                 auto_acknowledge_rule_warnings: Optional[pulumi.Input[bool]] = None,
+                 compliance_record: Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordArgs']] = None,
                  contract_id: Optional[pulumi.Input[str]] = None,
-                 create_from_config_id: Optional[pulumi.Input[int]] = None,
-                 create_from_version: Optional[pulumi.Input[int]] = None,
-                 description: Optional[pulumi.Input[str]] = None,
-                 group_id: Optional[pulumi.Input[int]] = None,
-                 host_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 name: Optional[pulumi.Input[str]] = None):
-        """
-        Input properties used for looking up and filtering AppSecConfiguration resources.
-        :param pulumi.Input[int] config_id: Unique identifier of the new security configuration
-        :param pulumi.Input[str] contract_id: . Unique identifier of the Akamai contract associated with the new configuration.
-        :param pulumi.Input[int] create_from_config_id: . Unique identifier of the existing configuration being cloned in order to create the new configuration.
-        :param pulumi.Input[int] create_from_version: . Version number of the security configuration being cloned.
-        :param pulumi.Input[str] description: . Brief description of the new configuration.
-        :param pulumi.Input[int] group_id: . Unique identifier of the contract group associated with the new configuration.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] host_names: . JSON array containing the hostnames to be protected by the new configuration. You must specify at least one hostname in order to create a new configuration.
-        :param pulumi.Input[str] name: . Name of the new configuration.
-        """
-        if config_id is not None:
-            pulumi.set(__self__, "config_id", config_id)
+                 group_id: Optional[pulumi.Input[str]] = None,
+                 include_id: Optional[pulumi.Input[str]] = None,
+                 network: Optional[pulumi.Input[str]] = None,
+                 note: Optional[pulumi.Input[str]] = None,
+                 notify_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 validations: Optional[pulumi.Input[str]] = None,
+                 version: Optional[pulumi.Input[int]] = None):
+        """
+        Input properties used for looking up and filtering PropertyIncludeActivation resources.
+        :param pulumi.Input[bool] auto_acknowledge_rule_warnings: Automatically acknowledge all rule warnings for activation and continue
+        :param pulumi.Input['PropertyIncludeActivationComplianceRecordArgs'] compliance_record: Provides an audit record when activating on a production network
+        :param pulumi.Input[str] contract_id: The contract under which the include is activated
+        :param pulumi.Input[str] group_id: The group under which the include is activated
+        :param pulumi.Input[str] include_id: The unique identifier of the include
+        :param pulumi.Input[str] network: The network for which the activation will be performed
+        :param pulumi.Input[str] note: The note to assign to a log message of the activation request
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notify_emails: The list of email addresses to notify about an activation status
+        :param pulumi.Input[str] validations: The validation information in JSON format
+        :param pulumi.Input[int] version: The unique identifier of the include
+        """
+        if auto_acknowledge_rule_warnings is not None:
+            pulumi.set(__self__, "auto_acknowledge_rule_warnings", auto_acknowledge_rule_warnings)
+        if compliance_record is not None:
+            pulumi.set(__self__, "compliance_record", compliance_record)
         if contract_id is not None:
             pulumi.set(__self__, "contract_id", contract_id)
-        if create_from_config_id is not None:
-            pulumi.set(__self__, "create_from_config_id", create_from_config_id)
-        if create_from_version is not None:
-            pulumi.set(__self__, "create_from_version", create_from_version)
-        if description is not None:
-            pulumi.set(__self__, "description", description)
         if group_id is not None:
             pulumi.set(__self__, "group_id", group_id)
-        if host_names is not None:
-            pulumi.set(__self__, "host_names", host_names)
-        if name is not None:
-            pulumi.set(__self__, "name", name)
+        if include_id is not None:
+            pulumi.set(__self__, "include_id", include_id)
+        if network is not None:
+            pulumi.set(__self__, "network", network)
+        if note is not None:
+            pulumi.set(__self__, "note", note)
+        if notify_emails is not None:
+            pulumi.set(__self__, "notify_emails", notify_emails)
+        if validations is not None:
+            pulumi.set(__self__, "validations", validations)
+        if version is not None:
+            pulumi.set(__self__, "version", version)
 
     @property
-    @pulumi.getter(name="configId")
-    def config_id(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="autoAcknowledgeRuleWarnings")
+    def auto_acknowledge_rule_warnings(self) -> Optional[pulumi.Input[bool]]:
         """
-        Unique identifier of the new security configuration
+        Automatically acknowledge all rule warnings for activation and continue
         """
-        return pulumi.get(self, "config_id")
+        return pulumi.get(self, "auto_acknowledge_rule_warnings")
 
-    @config_id.setter
-    def config_id(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "config_id", value)
+    @auto_acknowledge_rule_warnings.setter
+    def auto_acknowledge_rule_warnings(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "auto_acknowledge_rule_warnings", value)
+
+    @property
+    @pulumi.getter(name="complianceRecord")
+    def compliance_record(self) -> Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordArgs']]:
+        """
+        Provides an audit record when activating on a production network
+        """
+        return pulumi.get(self, "compliance_record")
+
+    @compliance_record.setter
+    def compliance_record(self, value: Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordArgs']]):
+        pulumi.set(self, "compliance_record", value)
 
     @property
     @pulumi.getter(name="contractId")
     def contract_id(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the Akamai contract associated with the new configuration.
+        The contract under which the include is activated
         """
         return pulumi.get(self, "contract_id")
 
     @contract_id.setter
     def contract_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "contract_id", value)
 
     @property
-    @pulumi.getter(name="createFromConfigId")
-    def create_from_config_id(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="groupId")
+    def group_id(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the existing configuration being cloned in order to create the new configuration.
+        The group under which the include is activated
         """
-        return pulumi.get(self, "create_from_config_id")
+        return pulumi.get(self, "group_id")
 
-    @create_from_config_id.setter
-    def create_from_config_id(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "create_from_config_id", value)
+    @group_id.setter
+    def group_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "group_id", value)
 
     @property
-    @pulumi.getter(name="createFromVersion")
-    def create_from_version(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="includeId")
+    def include_id(self) -> Optional[pulumi.Input[str]]:
         """
-        . Version number of the security configuration being cloned.
+        The unique identifier of the include
         """
-        return pulumi.get(self, "create_from_version")
+        return pulumi.get(self, "include_id")
 
-    @create_from_version.setter
-    def create_from_version(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "create_from_version", value)
+    @include_id.setter
+    def include_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "include_id", value)
 
     @property
     @pulumi.getter
-    def description(self) -> Optional[pulumi.Input[str]]:
+    def network(self) -> Optional[pulumi.Input[str]]:
         """
-        . Brief description of the new configuration.
+        The network for which the activation will be performed
         """
-        return pulumi.get(self, "description")
+        return pulumi.get(self, "network")
 
-    @description.setter
-    def description(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "description", value)
+    @network.setter
+    def network(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "network", value)
 
     @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter
+    def note(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the contract group associated with the new configuration.
+        The note to assign to a log message of the activation request
         """
-        return pulumi.get(self, "group_id")
+        return pulumi.get(self, "note")
 
-    @group_id.setter
-    def group_id(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "group_id", value)
+    @note.setter
+    def note(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "note", value)
 
     @property
-    @pulumi.getter(name="hostNames")
-    def host_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
+    @pulumi.getter(name="notifyEmails")
+    def notify_emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        . JSON array containing the hostnames to be protected by the new configuration. You must specify at least one hostname in order to create a new configuration.
+        The list of email addresses to notify about an activation status
         """
-        return pulumi.get(self, "host_names")
+        return pulumi.get(self, "notify_emails")
 
-    @host_names.setter
-    def host_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
-        pulumi.set(self, "host_names", value)
+    @notify_emails.setter
+    def notify_emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
+        pulumi.set(self, "notify_emails", value)
 
     @property
     @pulumi.getter
-    def name(self) -> Optional[pulumi.Input[str]]:
+    def validations(self) -> Optional[pulumi.Input[str]]:
         """
-        . Name of the new configuration.
+        The validation information in JSON format
         """
-        return pulumi.get(self, "name")
+        return pulumi.get(self, "validations")
 
-    @name.setter
-    def name(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "name", value)
+    @validations.setter
+    def validations(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "validations", value)
 
+    @property
+    @pulumi.getter
+    def version(self) -> Optional[pulumi.Input[int]]:
+        """
+        The unique identifier of the include
+        """
+        return pulumi.get(self, "version")
+
+    @version.setter
+    def version(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "version", value)
 
-class AppSecConfiguration(pulumi.CustomResource):
+
+class PropertyIncludeActivation(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
+                 auto_acknowledge_rule_warnings: Optional[pulumi.Input[bool]] = None,
+                 compliance_record: Optional[pulumi.Input[pulumi.InputType['PropertyIncludeActivationComplianceRecordArgs']]] = None,
                  contract_id: Optional[pulumi.Input[str]] = None,
-                 create_from_config_id: Optional[pulumi.Input[int]] = None,
-                 create_from_version: Optional[pulumi.Input[int]] = None,
-                 description: Optional[pulumi.Input[str]] = None,
-                 group_id: Optional[pulumi.Input[int]] = None,
-                 host_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 name: Optional[pulumi.Input[str]] = None,
+                 group_id: Optional[pulumi.Input[str]] = None,
+                 include_id: Optional[pulumi.Input[str]] = None,
+                 network: Optional[pulumi.Input[str]] = None,
+                 note: Optional[pulumi.Input[str]] = None,
+                 notify_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 version: Optional[pulumi.Input[int]] = None,
                  __props__=None):
         """
-        **Scopes**: Contract and group
-
-        Creates a new WAP (Web Application Protector) or KSD (Kona Site Defender) security configuration. KSD security configurations start out empty (i.e., unconfigured), while WAP configurations are created using preset values. The contract referenced in the request body determines the type of configuration you can create.
-
-        In addition to manually creating a new configuration, you can use the `create_from_config_id` argument to clone an existing configuration.
-
-        **Related API Endpoint**: [/appsec/v1/configs](https://techdocs.akamai.com/application-security/reference/post-config)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        selectable_hostnames = akamai.get_app_sec_selectable_hostnames(config_id="Documentation")
-        create_config = akamai.AppSecConfiguration("createConfig",
-            description="This configuration is used as a testing environment for the documentation team.",
-            contract_id="5-2WA382",
-            group_id=12198,
-            host_names=[
-                "documentation.akamai.com",
-                "training.akamai.com",
-            ])
-        pulumi.export("createConfigId", create_config.config_id)
-        clone_config = akamai.AppSecConfiguration("cloneConfig",
-            description="This configuration is used as a testing environment for the documentation team.",
-            create_from_config_id=data["akamai_appsec_configuration"]["configuration"]["config_id"],
-            create_from_version=data["akamai_appsec_configuration"]["configuration"]["latest_version"],
-            contract_id="5-2WA382",
-            group_id=12198,
-            host_names=selectable_hostnames.hostnames)
-        pulumi.export("cloneConfigId", clone_config.config_id)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `config_id`. ID of the new security configuration.
-
+        Create a PropertyIncludeActivation resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] contract_id: . Unique identifier of the Akamai contract associated with the new configuration.
-        :param pulumi.Input[int] create_from_config_id: . Unique identifier of the existing configuration being cloned in order to create the new configuration.
-        :param pulumi.Input[int] create_from_version: . Version number of the security configuration being cloned.
-        :param pulumi.Input[str] description: . Brief description of the new configuration.
-        :param pulumi.Input[int] group_id: . Unique identifier of the contract group associated with the new configuration.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] host_names: . JSON array containing the hostnames to be protected by the new configuration. You must specify at least one hostname in order to create a new configuration.
-        :param pulumi.Input[str] name: . Name of the new configuration.
+        :param pulumi.Input[bool] auto_acknowledge_rule_warnings: Automatically acknowledge all rule warnings for activation and continue
+        :param pulumi.Input[pulumi.InputType['PropertyIncludeActivationComplianceRecordArgs']] compliance_record: Provides an audit record when activating on a production network
+        :param pulumi.Input[str] contract_id: The contract under which the include is activated
+        :param pulumi.Input[str] group_id: The group under which the include is activated
+        :param pulumi.Input[str] include_id: The unique identifier of the include
+        :param pulumi.Input[str] network: The network for which the activation will be performed
+        :param pulumi.Input[str] note: The note to assign to a log message of the activation request
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notify_emails: The list of email addresses to notify about an activation status
+        :param pulumi.Input[int] version: The unique identifier of the include
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: AppSecConfigurationArgs,
+                 args: PropertyIncludeActivationArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Contract and group
-
-        Creates a new WAP (Web Application Protector) or KSD (Kona Site Defender) security configuration. KSD security configurations start out empty (i.e., unconfigured), while WAP configurations are created using preset values. The contract referenced in the request body determines the type of configuration you can create.
-
-        In addition to manually creating a new configuration, you can use the `create_from_config_id` argument to clone an existing configuration.
-
-        **Related API Endpoint**: [/appsec/v1/configs](https://techdocs.akamai.com/application-security/reference/post-config)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        selectable_hostnames = akamai.get_app_sec_selectable_hostnames(config_id="Documentation")
-        create_config = akamai.AppSecConfiguration("createConfig",
-            description="This configuration is used as a testing environment for the documentation team.",
-            contract_id="5-2WA382",
-            group_id=12198,
-            host_names=[
-                "documentation.akamai.com",
-                "training.akamai.com",
-            ])
-        pulumi.export("createConfigId", create_config.config_id)
-        clone_config = akamai.AppSecConfiguration("cloneConfig",
-            description="This configuration is used as a testing environment for the documentation team.",
-            create_from_config_id=data["akamai_appsec_configuration"]["configuration"]["config_id"],
-            create_from_version=data["akamai_appsec_configuration"]["configuration"]["latest_version"],
-            contract_id="5-2WA382",
-            group_id=12198,
-            host_names=selectable_hostnames.hostnames)
-        pulumi.export("cloneConfigId", clone_config.config_id)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `config_id`. ID of the new security configuration.
-
+        Create a PropertyIncludeActivation resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param AppSecConfigurationArgs args: The arguments to use to populate this resource's properties.
+        :param PropertyIncludeActivationArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(AppSecConfigurationArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(PropertyIncludeActivationArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
+                 auto_acknowledge_rule_warnings: Optional[pulumi.Input[bool]] = None,
+                 compliance_record: Optional[pulumi.Input[pulumi.InputType['PropertyIncludeActivationComplianceRecordArgs']]] = None,
                  contract_id: Optional[pulumi.Input[str]] = None,
-                 create_from_config_id: Optional[pulumi.Input[int]] = None,
-                 create_from_version: Optional[pulumi.Input[int]] = None,
-                 description: Optional[pulumi.Input[str]] = None,
-                 group_id: Optional[pulumi.Input[int]] = None,
-                 host_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 name: Optional[pulumi.Input[str]] = None,
+                 group_id: Optional[pulumi.Input[str]] = None,
+                 include_id: Optional[pulumi.Input[str]] = None,
+                 network: Optional[pulumi.Input[str]] = None,
+                 note: Optional[pulumi.Input[str]] = None,
+                 notify_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 version: Optional[pulumi.Input[int]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = AppSecConfigurationArgs.__new__(AppSecConfigurationArgs)
+            __props__ = PropertyIncludeActivationArgs.__new__(PropertyIncludeActivationArgs)
 
+            __props__.__dict__["auto_acknowledge_rule_warnings"] = auto_acknowledge_rule_warnings
+            __props__.__dict__["compliance_record"] = compliance_record
             if contract_id is None and not opts.urn:
                 raise TypeError("Missing required property 'contract_id'")
             __props__.__dict__["contract_id"] = contract_id
-            __props__.__dict__["create_from_config_id"] = create_from_config_id
-            __props__.__dict__["create_from_version"] = create_from_version
-            if description is None and not opts.urn:
-                raise TypeError("Missing required property 'description'")
-            __props__.__dict__["description"] = description
             if group_id is None and not opts.urn:
                 raise TypeError("Missing required property 'group_id'")
             __props__.__dict__["group_id"] = group_id
-            if host_names is None and not opts.urn:
-                raise TypeError("Missing required property 'host_names'")
-            __props__.__dict__["host_names"] = host_names
-            __props__.__dict__["name"] = name
-            __props__.__dict__["config_id"] = None
-        super(AppSecConfiguration, __self__).__init__(
-            'akamai:index/appSecConfiguration:AppSecConfiguration',
+            if include_id is None and not opts.urn:
+                raise TypeError("Missing required property 'include_id'")
+            __props__.__dict__["include_id"] = include_id
+            if network is None and not opts.urn:
+                raise TypeError("Missing required property 'network'")
+            __props__.__dict__["network"] = network
+            __props__.__dict__["note"] = note
+            if notify_emails is None and not opts.urn:
+                raise TypeError("Missing required property 'notify_emails'")
+            __props__.__dict__["notify_emails"] = notify_emails
+            if version is None and not opts.urn:
+                raise TypeError("Missing required property 'version'")
+            __props__.__dict__["version"] = version
+            __props__.__dict__["validations"] = None
+        super(PropertyIncludeActivation, __self__).__init__(
+            'akamai:index/propertyIncludeActivation:PropertyIncludeActivation',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
-            config_id: Optional[pulumi.Input[int]] = None,
+            auto_acknowledge_rule_warnings: Optional[pulumi.Input[bool]] = None,
+            compliance_record: Optional[pulumi.Input[pulumi.InputType['PropertyIncludeActivationComplianceRecordArgs']]] = None,
             contract_id: Optional[pulumi.Input[str]] = None,
-            create_from_config_id: Optional[pulumi.Input[int]] = None,
-            create_from_version: Optional[pulumi.Input[int]] = None,
-            description: Optional[pulumi.Input[str]] = None,
-            group_id: Optional[pulumi.Input[int]] = None,
-            host_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-            name: Optional[pulumi.Input[str]] = None) -> 'AppSecConfiguration':
+            group_id: Optional[pulumi.Input[str]] = None,
+            include_id: Optional[pulumi.Input[str]] = None,
+            network: Optional[pulumi.Input[str]] = None,
+            note: Optional[pulumi.Input[str]] = None,
+            notify_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+            validations: Optional[pulumi.Input[str]] = None,
+            version: Optional[pulumi.Input[int]] = None) -> 'PropertyIncludeActivation':
         """
-        Get an existing AppSecConfiguration resource's state with the given name, id, and optional extra
+        Get an existing PropertyIncludeActivation resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: Unique identifier of the new security configuration
-        :param pulumi.Input[str] contract_id: . Unique identifier of the Akamai contract associated with the new configuration.
-        :param pulumi.Input[int] create_from_config_id: . Unique identifier of the existing configuration being cloned in order to create the new configuration.
-        :param pulumi.Input[int] create_from_version: . Version number of the security configuration being cloned.
-        :param pulumi.Input[str] description: . Brief description of the new configuration.
-        :param pulumi.Input[int] group_id: . Unique identifier of the contract group associated with the new configuration.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] host_names: . JSON array containing the hostnames to be protected by the new configuration. You must specify at least one hostname in order to create a new configuration.
-        :param pulumi.Input[str] name: . Name of the new configuration.
+        :param pulumi.Input[bool] auto_acknowledge_rule_warnings: Automatically acknowledge all rule warnings for activation and continue
+        :param pulumi.Input[pulumi.InputType['PropertyIncludeActivationComplianceRecordArgs']] compliance_record: Provides an audit record when activating on a production network
+        :param pulumi.Input[str] contract_id: The contract under which the include is activated
+        :param pulumi.Input[str] group_id: The group under which the include is activated
+        :param pulumi.Input[str] include_id: The unique identifier of the include
+        :param pulumi.Input[str] network: The network for which the activation will be performed
+        :param pulumi.Input[str] note: The note to assign to a log message of the activation request
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notify_emails: The list of email addresses to notify about an activation status
+        :param pulumi.Input[str] validations: The validation information in JSON format
+        :param pulumi.Input[int] version: The unique identifier of the include
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _AppSecConfigurationState.__new__(_AppSecConfigurationState)
+        __props__ = _PropertyIncludeActivationState.__new__(_PropertyIncludeActivationState)
 
-        __props__.__dict__["config_id"] = config_id
+        __props__.__dict__["auto_acknowledge_rule_warnings"] = auto_acknowledge_rule_warnings
+        __props__.__dict__["compliance_record"] = compliance_record
         __props__.__dict__["contract_id"] = contract_id
-        __props__.__dict__["create_from_config_id"] = create_from_config_id
-        __props__.__dict__["create_from_version"] = create_from_version
-        __props__.__dict__["description"] = description
         __props__.__dict__["group_id"] = group_id
-        __props__.__dict__["host_names"] = host_names
-        __props__.__dict__["name"] = name
-        return AppSecConfiguration(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["include_id"] = include_id
+        __props__.__dict__["network"] = network
+        __props__.__dict__["note"] = note
+        __props__.__dict__["notify_emails"] = notify_emails
+        __props__.__dict__["validations"] = validations
+        __props__.__dict__["version"] = version
+        return PropertyIncludeActivation(resource_name, opts=opts, __props__=__props__)
 
     @property
-    @pulumi.getter(name="configId")
-    def config_id(self) -> pulumi.Output[int]:
+    @pulumi.getter(name="autoAcknowledgeRuleWarnings")
+    def auto_acknowledge_rule_warnings(self) -> pulumi.Output[Optional[bool]]:
         """
-        Unique identifier of the new security configuration
+        Automatically acknowledge all rule warnings for activation and continue
         """
-        return pulumi.get(self, "config_id")
+        return pulumi.get(self, "auto_acknowledge_rule_warnings")
+
+    @property
+    @pulumi.getter(name="complianceRecord")
+    def compliance_record(self) -> pulumi.Output[Optional['outputs.PropertyIncludeActivationComplianceRecord']]:
+        """
+        Provides an audit record when activating on a production network
+        """
+        return pulumi.get(self, "compliance_record")
 
     @property
     @pulumi.getter(name="contractId")
     def contract_id(self) -> pulumi.Output[str]:
         """
-        . Unique identifier of the Akamai contract associated with the new configuration.
+        The contract under which the include is activated
         """
         return pulumi.get(self, "contract_id")
 
     @property
-    @pulumi.getter(name="createFromConfigId")
-    def create_from_config_id(self) -> pulumi.Output[Optional[int]]:
+    @pulumi.getter(name="groupId")
+    def group_id(self) -> pulumi.Output[str]:
         """
-        . Unique identifier of the existing configuration being cloned in order to create the new configuration.
+        The group under which the include is activated
         """
-        return pulumi.get(self, "create_from_config_id")
+        return pulumi.get(self, "group_id")
 
     @property
-    @pulumi.getter(name="createFromVersion")
-    def create_from_version(self) -> pulumi.Output[Optional[int]]:
+    @pulumi.getter(name="includeId")
+    def include_id(self) -> pulumi.Output[str]:
         """
-        . Version number of the security configuration being cloned.
+        The unique identifier of the include
         """
-        return pulumi.get(self, "create_from_version")
+        return pulumi.get(self, "include_id")
 
     @property
     @pulumi.getter
-    def description(self) -> pulumi.Output[str]:
+    def network(self) -> pulumi.Output[str]:
         """
-        . Brief description of the new configuration.
+        The network for which the activation will be performed
         """
-        return pulumi.get(self, "description")
+        return pulumi.get(self, "network")
 
     @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> pulumi.Output[int]:
+    @pulumi.getter
+    def note(self) -> pulumi.Output[Optional[str]]:
         """
-        . Unique identifier of the contract group associated with the new configuration.
+        The note to assign to a log message of the activation request
         """
-        return pulumi.get(self, "group_id")
+        return pulumi.get(self, "note")
+
+    @property
+    @pulumi.getter(name="notifyEmails")
+    def notify_emails(self) -> pulumi.Output[Sequence[str]]:
+        """
+        The list of email addresses to notify about an activation status
+        """
+        return pulumi.get(self, "notify_emails")
 
     @property
-    @pulumi.getter(name="hostNames")
-    def host_names(self) -> pulumi.Output[Sequence[str]]:
+    @pulumi.getter
+    def validations(self) -> pulumi.Output[str]:
         """
-        . JSON array containing the hostnames to be protected by the new configuration. You must specify at least one hostname in order to create a new configuration.
+        The validation information in JSON format
         """
-        return pulumi.get(self, "host_names")
+        return pulumi.get(self, "validations")
 
     @property
     @pulumi.getter
-    def name(self) -> pulumi.Output[str]:
+    def version(self) -> pulumi.Output[int]:
         """
-        . Name of the new configuration.
+        The unique identifier of the include
         """
-        return pulumi.get(self, "name")
+        return pulumi.get(self, "version")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_configuration_rename.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_configuration_rename.py`

 * *Files 15% similar despite different names*

```diff
@@ -15,52 +15,52 @@
 class AppSecConfigurationRenameArgs:
     def __init__(__self__, *,
                  config_id: pulumi.Input[int],
                  description: pulumi.Input[str],
                  name: Optional[pulumi.Input[str]] = None):
         """
         The set of arguments for constructing a AppSecConfigurationRename resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuring being renamed.
-        :param pulumi.Input[str] description: . Brief description of the security configuration.
-        :param pulumi.Input[str] name: . New name for the security configuration.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] description: Brief description of the security configuration
+        :param pulumi.Input[str] name: New name for the security configuration
         """
         pulumi.set(__self__, "config_id", config_id)
         pulumi.set(__self__, "description", description)
         if name is not None:
             pulumi.set(__self__, "name", name)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuring being renamed.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter
     def description(self) -> pulumi.Input[str]:
         """
-        . Brief description of the security configuration.
+        Brief description of the security configuration
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: pulumi.Input[str]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        . New name for the security configuration.
+        New name for the security configuration
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
@@ -69,54 +69,54 @@
 class _AppSecConfigurationRenameState:
     def __init__(__self__, *,
                  config_id: Optional[pulumi.Input[int]] = None,
                  description: Optional[pulumi.Input[str]] = None,
                  name: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering AppSecConfigurationRename resources.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuring being renamed.
-        :param pulumi.Input[str] description: . Brief description of the security configuration.
-        :param pulumi.Input[str] name: . New name for the security configuration.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] description: Brief description of the security configuration
+        :param pulumi.Input[str] name: New name for the security configuration
         """
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
         if description is not None:
             pulumi.set(__self__, "description", description)
         if name is not None:
             pulumi.set(__self__, "name", name)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security configuring being renamed.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        . Brief description of the security configuration.
+        Brief description of the security configuration
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        . New name for the security configuration.
+        New name for the security configuration
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
@@ -127,69 +127,29 @@
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
                  description: Optional[pulumi.Input[str]] = None,
                  name: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Security configuration
-
-        Renames an existing security configuration.
-        Note that you can change only the configuration name. You can't modify the ID assigned to a security configuration.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}](https://techdocs.akamai.com/application-security/reference/put-config)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration_app_sec_configuration = akamai.get_app_sec_configuration(name="Documentation")
-        configuration_app_sec_configuration_rename = akamai.AppSecConfigurationRename("configurationAppSecConfigurationRename",
-            config_id=configuration_app_sec_configuration.config_id,
-            description="This configuration is by both the documentation team and the training team.")
-        ```
-
+        Create a AppSecConfigurationRename resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuring being renamed.
-        :param pulumi.Input[str] description: . Brief description of the security configuration.
-        :param pulumi.Input[str] name: . New name for the security configuration.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] description: Brief description of the security configuration
+        :param pulumi.Input[str] name: New name for the security configuration
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: AppSecConfigurationRenameArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Security configuration
-
-        Renames an existing security configuration.
-        Note that you can change only the configuration name. You can't modify the ID assigned to a security configuration.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}](https://techdocs.akamai.com/application-security/reference/put-config)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration_app_sec_configuration = akamai.get_app_sec_configuration(name="Documentation")
-        configuration_app_sec_configuration_rename = akamai.AppSecConfigurationRename("configurationAppSecConfigurationRename",
-            config_id=configuration_app_sec_configuration.config_id,
-            description="This configuration is by both the documentation team and the training team.")
-        ```
-
+        Create a AppSecConfigurationRename resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param AppSecConfigurationRenameArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(AppSecConfigurationRenameArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -236,44 +196,44 @@
         """
         Get an existing AppSecConfigurationRename resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuring being renamed.
-        :param pulumi.Input[str] description: . Brief description of the security configuration.
-        :param pulumi.Input[str] name: . New name for the security configuration.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] description: Brief description of the security configuration
+        :param pulumi.Input[str] name: New name for the security configuration
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _AppSecConfigurationRenameState.__new__(_AppSecConfigurationRenameState)
 
         __props__.__dict__["config_id"] = config_id
         __props__.__dict__["description"] = description
         __props__.__dict__["name"] = name
         return AppSecConfigurationRename(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Output[int]:
         """
-        . Unique identifier of the security configuring being renamed.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @property
     @pulumi.getter
     def description(self) -> pulumi.Output[str]:
         """
-        . Brief description of the security configuration.
+        Brief description of the security configuration
         """
         return pulumi.get(self, "description")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        . New name for the security configuration.
+        New name for the security configuration
         """
         return pulumi.get(self, "name")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_custom_deny.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_custom_deny.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,37 +14,37 @@
 @pulumi.input_type
 class AppSecCustomDenyArgs:
     def __init__(__self__, *,
                  config_id: pulumi.Input[int],
                  custom_deny: pulumi.Input[str]):
         """
         The set of arguments for constructing a AppSecCustomDeny resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the custom deny.
-        :param pulumi.Input[str] custom_deny: . Path to a JSON file containing properties and property values for the custom deny.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] custom_deny: JSON-formatted information about the properties and property values for the custom deny
         """
         pulumi.set(__self__, "config_id", config_id)
         pulumi.set(__self__, "custom_deny", custom_deny)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuration associated with the custom deny.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter(name="customDeny")
     def custom_deny(self) -> pulumi.Input[str]:
         """
-        . Path to a JSON file containing properties and property values for the custom deny.
+        JSON-formatted information about the properties and property values for the custom deny
         """
         return pulumi.get(self, "custom_deny")
 
     @custom_deny.setter
     def custom_deny(self, value: pulumi.Input[str]):
         pulumi.set(self, "custom_deny", value)
 
@@ -53,42 +53,42 @@
 class _AppSecCustomDenyState:
     def __init__(__self__, *,
                  config_id: Optional[pulumi.Input[int]] = None,
                  custom_deny: Optional[pulumi.Input[str]] = None,
                  custom_deny_id: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering AppSecCustomDeny resources.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the custom deny.
-        :param pulumi.Input[str] custom_deny: . Path to a JSON file containing properties and property values for the custom deny.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] custom_deny: JSON-formatted information about the properties and property values for the custom deny
         :param pulumi.Input[str] custom_deny_id: custom_deny_id
         """
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
         if custom_deny is not None:
             pulumi.set(__self__, "custom_deny", custom_deny)
         if custom_deny_id is not None:
             pulumi.set(__self__, "custom_deny_id", custom_deny_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security configuration associated with the custom deny.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter(name="customDeny")
     def custom_deny(self) -> Optional[pulumi.Input[str]]:
         """
-        . Path to a JSON file containing properties and property values for the custom deny.
+        JSON-formatted information about the properties and property values for the custom deny
         """
         return pulumi.get(self, "custom_deny")
 
     @custom_deny.setter
     def custom_deny(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "custom_deny", value)
 
@@ -110,78 +110,28 @@
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
                  custom_deny: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Custom deny
-
-        Modifies a custom deny action. Custom denies enable you to craft your own error message or redirect pages for use when HTTP requests are denied.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/custom-deny](https://techdocs.akamai.com/application-security/reference/get-custom-deny-actions)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        custom_deny = akamai.AppSecCustomDeny("customDeny",
-            config_id=configuration.config_id,
-            custom_deny=(lambda path: open(path).read())(f"{path['module']}/custom_deny.json"))
-        pulumi.export("customDenyId", custom_deny.custom_deny_id)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `custom_deny_id`. ID of the new custom deny action.
-
+        Create a AppSecCustomDeny resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the custom deny.
-        :param pulumi.Input[str] custom_deny: . Path to a JSON file containing properties and property values for the custom deny.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] custom_deny: JSON-formatted information about the properties and property values for the custom deny
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: AppSecCustomDenyArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Custom deny
-
-        Modifies a custom deny action. Custom denies enable you to craft your own error message or redirect pages for use when HTTP requests are denied.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/custom-deny](https://techdocs.akamai.com/application-security/reference/get-custom-deny-actions)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        custom_deny = akamai.AppSecCustomDeny("customDeny",
-            config_id=configuration.config_id,
-            custom_deny=(lambda path: open(path).read())(f"{path['module']}/custom_deny.json"))
-        pulumi.export("customDenyId", custom_deny.custom_deny_id)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `custom_deny_id`. ID of the new custom deny action.
-
+        Create a AppSecCustomDeny resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param AppSecCustomDenyArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(AppSecCustomDenyArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -227,16 +177,16 @@
         """
         Get an existing AppSecCustomDeny resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the custom deny.
-        :param pulumi.Input[str] custom_deny: . Path to a JSON file containing properties and property values for the custom deny.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] custom_deny: JSON-formatted information about the properties and property values for the custom deny
         :param pulumi.Input[str] custom_deny_id: custom_deny_id
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _AppSecCustomDenyState.__new__(_AppSecCustomDenyState)
 
         __props__.__dict__["config_id"] = config_id
@@ -244,23 +194,23 @@
         __props__.__dict__["custom_deny_id"] = custom_deny_id
         return AppSecCustomDeny(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Output[int]:
         """
-        . Unique identifier of the security configuration associated with the custom deny.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @property
     @pulumi.getter(name="customDeny")
     def custom_deny(self) -> pulumi.Output[str]:
         """
-        . Path to a JSON file containing properties and property values for the custom deny.
+        JSON-formatted information about the properties and property values for the custom deny
         """
         return pulumi.get(self, "custom_deny")
 
     @property
     @pulumi.getter(name="customDenyId")
     def custom_deny_id(self) -> pulumi.Output[str]:
         """
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_custom_rule.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_waf_protection.py`

 * *Files 20% similar despite different names*

```diff
@@ -5,226 +5,264 @@
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
-__all__ = ['AppSecCustomRuleArgs', 'AppSecCustomRule']
+__all__ = ['AppSecWafProtectionArgs', 'AppSecWafProtection']
 
 @pulumi.input_type
-class AppSecCustomRuleArgs:
+class AppSecWafProtectionArgs:
     def __init__(__self__, *,
                  config_id: pulumi.Input[int],
-                 custom_rule: pulumi.Input[str]):
+                 enabled: pulumi.Input[bool],
+                 security_policy_id: pulumi.Input[str]):
         """
-        The set of arguments for constructing a AppSecCustomRule resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the custom rule being modified.
-        :param pulumi.Input[str] custom_rule: . Path to a JSON file containing the custom rule definition. To view a sample JSON file, see the [Create a custom rule](https://techdocs.akamai.com/application-security/reference/post-config-custom-rules) section of the Application Security API documentation.
+        The set of arguments for constructing a AppSecWafProtection resource.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enabled: Whether to enable WAF protection
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         pulumi.set(__self__, "config_id", config_id)
-        pulumi.set(__self__, "custom_rule", custom_rule)
+        pulumi.set(__self__, "enabled", enabled)
+        pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuration associated with the custom rule being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "config_id", value)
 
     @property
-    @pulumi.getter(name="customRule")
-    def custom_rule(self) -> pulumi.Input[str]:
+    @pulumi.getter
+    def enabled(self) -> pulumi.Input[bool]:
         """
-        . Path to a JSON file containing the custom rule definition. To view a sample JSON file, see the [Create a custom rule](https://techdocs.akamai.com/application-security/reference/post-config-custom-rules) section of the Application Security API documentation.
+        Whether to enable WAF protection
         """
-        return pulumi.get(self, "custom_rule")
+        return pulumi.get(self, "enabled")
 
-    @custom_rule.setter
-    def custom_rule(self, value: pulumi.Input[str]):
-        pulumi.set(self, "custom_rule", value)
+    @enabled.setter
+    def enabled(self, value: pulumi.Input[bool]):
+        pulumi.set(self, "enabled", value)
+
+    @property
+    @pulumi.getter(name="securityPolicyId")
+    def security_policy_id(self) -> pulumi.Input[str]:
+        """
+        Unique identifier of the security policy
+        """
+        return pulumi.get(self, "security_policy_id")
+
+    @security_policy_id.setter
+    def security_policy_id(self, value: pulumi.Input[str]):
+        pulumi.set(self, "security_policy_id", value)
 
 
 @pulumi.input_type
-class _AppSecCustomRuleState:
+class _AppSecWafProtectionState:
     def __init__(__self__, *,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 custom_rule: Optional[pulumi.Input[str]] = None,
-                 custom_rule_id: Optional[pulumi.Input[int]] = None):
-        """
-        Input properties used for looking up and filtering AppSecCustomRule resources.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the custom rule being modified.
-        :param pulumi.Input[str] custom_rule: . Path to a JSON file containing the custom rule definition. To view a sample JSON file, see the [Create a custom rule](https://techdocs.akamai.com/application-security/reference/post-config-custom-rules) section of the Application Security API documentation.
-        :param pulumi.Input[int] custom_rule_id: . ID of the new custom rule.
+                 enabled: Optional[pulumi.Input[bool]] = None,
+                 output_text: Optional[pulumi.Input[str]] = None,
+                 security_policy_id: Optional[pulumi.Input[str]] = None):
+        """
+        Input properties used for looking up and filtering AppSecWafProtection resources.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enabled: Whether to enable WAF protection
+        :param pulumi.Input[str] output_text: Text representation
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
-        if custom_rule is not None:
-            pulumi.set(__self__, "custom_rule", custom_rule)
-        if custom_rule_id is not None:
-            pulumi.set(__self__, "custom_rule_id", custom_rule_id)
+        if enabled is not None:
+            pulumi.set(__self__, "enabled", enabled)
+        if output_text is not None:
+            pulumi.set(__self__, "output_text", output_text)
+        if security_policy_id is not None:
+            pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security configuration associated with the custom rule being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "config_id", value)
 
     @property
-    @pulumi.getter(name="customRule")
-    def custom_rule(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter
+    def enabled(self) -> Optional[pulumi.Input[bool]]:
+        """
+        Whether to enable WAF protection
+        """
+        return pulumi.get(self, "enabled")
+
+    @enabled.setter
+    def enabled(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "enabled", value)
+
+    @property
+    @pulumi.getter(name="outputText")
+    def output_text(self) -> Optional[pulumi.Input[str]]:
         """
-        . Path to a JSON file containing the custom rule definition. To view a sample JSON file, see the [Create a custom rule](https://techdocs.akamai.com/application-security/reference/post-config-custom-rules) section of the Application Security API documentation.
+        Text representation
         """
-        return pulumi.get(self, "custom_rule")
+        return pulumi.get(self, "output_text")
 
-    @custom_rule.setter
-    def custom_rule(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "custom_rule", value)
+    @output_text.setter
+    def output_text(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "output_text", value)
 
     @property
-    @pulumi.getter(name="customRuleId")
-    def custom_rule_id(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="securityPolicyId")
+    def security_policy_id(self) -> Optional[pulumi.Input[str]]:
         """
-        . ID of the new custom rule.
+        Unique identifier of the security policy
         """
-        return pulumi.get(self, "custom_rule_id")
+        return pulumi.get(self, "security_policy_id")
 
-    @custom_rule_id.setter
-    def custom_rule_id(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "custom_rule_id", value)
+    @security_policy_id.setter
+    def security_policy_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "security_policy_id", value)
 
 
-class AppSecCustomRule(pulumi.CustomResource):
+class AppSecWafProtection(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 custom_rule: Optional[pulumi.Input[str]] = None,
+                 enabled: Optional[pulumi.Input[bool]] = None,
+                 security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Security configuration
-
-        Creates a custom rule associated with a security configuration. Custom rules are rules that you define yourself and are not part of the Kona Rule Set.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/custom-rules]https://techdocs.akamai.com/application-security/reference/get-configs-custom-rules)
-
+        Create a AppSecWafProtection resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the custom rule being modified.
-        :param pulumi.Input[str] custom_rule: . Path to a JSON file containing the custom rule definition. To view a sample JSON file, see the [Create a custom rule](https://techdocs.akamai.com/application-security/reference/post-config-custom-rules) section of the Application Security API documentation.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enabled: Whether to enable WAF protection
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: AppSecCustomRuleArgs,
+                 args: AppSecWafProtectionArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Security configuration
-
-        Creates a custom rule associated with a security configuration. Custom rules are rules that you define yourself and are not part of the Kona Rule Set.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/custom-rules]https://techdocs.akamai.com/application-security/reference/get-configs-custom-rules)
-
+        Create a AppSecWafProtection resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param AppSecCustomRuleArgs args: The arguments to use to populate this resource's properties.
+        :param AppSecWafProtectionArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(AppSecCustomRuleArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(AppSecWafProtectionArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 custom_rule: Optional[pulumi.Input[str]] = None,
+                 enabled: Optional[pulumi.Input[bool]] = None,
+                 security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = AppSecCustomRuleArgs.__new__(AppSecCustomRuleArgs)
+            __props__ = AppSecWafProtectionArgs.__new__(AppSecWafProtectionArgs)
 
             if config_id is None and not opts.urn:
                 raise TypeError("Missing required property 'config_id'")
             __props__.__dict__["config_id"] = config_id
-            if custom_rule is None and not opts.urn:
-                raise TypeError("Missing required property 'custom_rule'")
-            __props__.__dict__["custom_rule"] = custom_rule
-            __props__.__dict__["custom_rule_id"] = None
-        super(AppSecCustomRule, __self__).__init__(
-            'akamai:index/appSecCustomRule:AppSecCustomRule',
+            if enabled is None and not opts.urn:
+                raise TypeError("Missing required property 'enabled'")
+            __props__.__dict__["enabled"] = enabled
+            if security_policy_id is None and not opts.urn:
+                raise TypeError("Missing required property 'security_policy_id'")
+            __props__.__dict__["security_policy_id"] = security_policy_id
+            __props__.__dict__["output_text"] = None
+        super(AppSecWafProtection, __self__).__init__(
+            'akamai:index/appSecWafProtection:AppSecWafProtection',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
             config_id: Optional[pulumi.Input[int]] = None,
-            custom_rule: Optional[pulumi.Input[str]] = None,
-            custom_rule_id: Optional[pulumi.Input[int]] = None) -> 'AppSecCustomRule':
+            enabled: Optional[pulumi.Input[bool]] = None,
+            output_text: Optional[pulumi.Input[str]] = None,
+            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecWafProtection':
         """
-        Get an existing AppSecCustomRule resource's state with the given name, id, and optional extra
+        Get an existing AppSecWafProtection resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the custom rule being modified.
-        :param pulumi.Input[str] custom_rule: . Path to a JSON file containing the custom rule definition. To view a sample JSON file, see the [Create a custom rule](https://techdocs.akamai.com/application-security/reference/post-config-custom-rules) section of the Application Security API documentation.
-        :param pulumi.Input[int] custom_rule_id: . ID of the new custom rule.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enabled: Whether to enable WAF protection
+        :param pulumi.Input[str] output_text: Text representation
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _AppSecCustomRuleState.__new__(_AppSecCustomRuleState)
+        __props__ = _AppSecWafProtectionState.__new__(_AppSecWafProtectionState)
 
         __props__.__dict__["config_id"] = config_id
-        __props__.__dict__["custom_rule"] = custom_rule
-        __props__.__dict__["custom_rule_id"] = custom_rule_id
-        return AppSecCustomRule(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["enabled"] = enabled
+        __props__.__dict__["output_text"] = output_text
+        __props__.__dict__["security_policy_id"] = security_policy_id
+        return AppSecWafProtection(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Output[int]:
         """
-        . Unique identifier of the security configuration associated with the custom rule being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @property
-    @pulumi.getter(name="customRule")
-    def custom_rule(self) -> pulumi.Output[str]:
+    @pulumi.getter
+    def enabled(self) -> pulumi.Output[bool]:
+        """
+        Whether to enable WAF protection
+        """
+        return pulumi.get(self, "enabled")
+
+    @property
+    @pulumi.getter(name="outputText")
+    def output_text(self) -> pulumi.Output[str]:
         """
-        . Path to a JSON file containing the custom rule definition. To view a sample JSON file, see the [Create a custom rule](https://techdocs.akamai.com/application-security/reference/post-config-custom-rules) section of the Application Security API documentation.
+        Text representation
         """
-        return pulumi.get(self, "custom_rule")
+        return pulumi.get(self, "output_text")
 
     @property
-    @pulumi.getter(name="customRuleId")
-    def custom_rule_id(self) -> pulumi.Output[int]:
+    @pulumi.getter(name="securityPolicyId")
+    def security_policy_id(self) -> pulumi.Output[str]:
         """
-        . ID of the new custom rule.
+        Unique identifier of the security policy
         """
-        return pulumi.get(self, "custom_rule_id")
+        return pulumi.get(self, "security_policy_id")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_custom_rule_action.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_attack_group.py`

 * *Files 24% similar despite different names*

```diff
@@ -5,356 +5,331 @@
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
-__all__ = ['AppSecCustomRuleActionArgs', 'AppSecCustomRuleAction']
+__all__ = ['AppSecAttackGroupArgs', 'AppSecAttackGroup']
 
 @pulumi.input_type
-class AppSecCustomRuleActionArgs:
+class AppSecAttackGroupArgs:
     def __init__(__self__, *,
+                 attack_group: pulumi.Input[str],
+                 attack_group_action: pulumi.Input[str],
                  config_id: pulumi.Input[int],
-                 custom_rule_action: pulumi.Input[str],
-                 custom_rule_id: pulumi.Input[int],
-                 security_policy_id: pulumi.Input[str]):
-        """
-        The set of arguments for constructing a AppSecCustomRuleAction resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the custom rule action being modified.
-        :param pulumi.Input[str] custom_rule_action: . Action to be taken when the custom rule is invoked. Allowed values are:
-               - **alert**. Record the event.
-               - **deny**. Block the request.
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action.
-        :param pulumi.Input[int] custom_rule_id: . Unique identifier of the custom rule whose action is being modified.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the custom rule action being modified.
+                 security_policy_id: pulumi.Input[str],
+                 condition_exception: Optional[pulumi.Input[str]] = None):
         """
+        The set of arguments for constructing a AppSecAttackGroup resource.
+        :param pulumi.Input[str] attack_group: Unique name of the attack group to be modified
+        :param pulumi.Input[str] attack_group_action: Action to be taken when the attack group is triggered
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
+        :param pulumi.Input[str] condition_exception: JSON-formatted condition and exception information for the attack group
+        """
+        pulumi.set(__self__, "attack_group", attack_group)
+        pulumi.set(__self__, "attack_group_action", attack_group_action)
         pulumi.set(__self__, "config_id", config_id)
-        pulumi.set(__self__, "custom_rule_action", custom_rule_action)
-        pulumi.set(__self__, "custom_rule_id", custom_rule_id)
         pulumi.set(__self__, "security_policy_id", security_policy_id)
+        if condition_exception is not None:
+            pulumi.set(__self__, "condition_exception", condition_exception)
 
     @property
-    @pulumi.getter(name="configId")
-    def config_id(self) -> pulumi.Input[int]:
+    @pulumi.getter(name="attackGroup")
+    def attack_group(self) -> pulumi.Input[str]:
         """
-        . Unique identifier of the security configuration associated with the custom rule action being modified.
+        Unique name of the attack group to be modified
         """
-        return pulumi.get(self, "config_id")
+        return pulumi.get(self, "attack_group")
 
-    @config_id.setter
-    def config_id(self, value: pulumi.Input[int]):
-        pulumi.set(self, "config_id", value)
+    @attack_group.setter
+    def attack_group(self, value: pulumi.Input[str]):
+        pulumi.set(self, "attack_group", value)
 
     @property
-    @pulumi.getter(name="customRuleAction")
-    def custom_rule_action(self) -> pulumi.Input[str]:
+    @pulumi.getter(name="attackGroupAction")
+    def attack_group_action(self) -> pulumi.Input[str]:
         """
-        . Action to be taken when the custom rule is invoked. Allowed values are:
-        - **alert**. Record the event.
-        - **deny**. Block the request.
-        - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-        - **none**. Take no action.
+        Action to be taken when the attack group is triggered
         """
-        return pulumi.get(self, "custom_rule_action")
+        return pulumi.get(self, "attack_group_action")
 
-    @custom_rule_action.setter
-    def custom_rule_action(self, value: pulumi.Input[str]):
-        pulumi.set(self, "custom_rule_action", value)
+    @attack_group_action.setter
+    def attack_group_action(self, value: pulumi.Input[str]):
+        pulumi.set(self, "attack_group_action", value)
 
     @property
-    @pulumi.getter(name="customRuleId")
-    def custom_rule_id(self) -> pulumi.Input[int]:
+    @pulumi.getter(name="configId")
+    def config_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the custom rule whose action is being modified.
+        Unique identifier of the security configuration
         """
-        return pulumi.get(self, "custom_rule_id")
+        return pulumi.get(self, "config_id")
 
-    @custom_rule_id.setter
-    def custom_rule_id(self, value: pulumi.Input[int]):
-        pulumi.set(self, "custom_rule_id", value)
+    @config_id.setter
+    def config_id(self, value: pulumi.Input[int]):
+        pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Input[str]:
         """
-        . Unique identifier of the security policy associated with the custom rule action being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "security_policy_id", value)
 
+    @property
+    @pulumi.getter(name="conditionException")
+    def condition_exception(self) -> Optional[pulumi.Input[str]]:
+        """
+        JSON-formatted condition and exception information for the attack group
+        """
+        return pulumi.get(self, "condition_exception")
+
+    @condition_exception.setter
+    def condition_exception(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "condition_exception", value)
+
 
 @pulumi.input_type
-class _AppSecCustomRuleActionState:
+class _AppSecAttackGroupState:
     def __init__(__self__, *,
+                 attack_group: Optional[pulumi.Input[str]] = None,
+                 attack_group_action: Optional[pulumi.Input[str]] = None,
+                 condition_exception: Optional[pulumi.Input[str]] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 custom_rule_action: Optional[pulumi.Input[str]] = None,
-                 custom_rule_id: Optional[pulumi.Input[int]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None):
         """
-        Input properties used for looking up and filtering AppSecCustomRuleAction resources.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the custom rule action being modified.
-        :param pulumi.Input[str] custom_rule_action: . Action to be taken when the custom rule is invoked. Allowed values are:
-               - **alert**. Record the event.
-               - **deny**. Block the request.
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action.
-        :param pulumi.Input[int] custom_rule_id: . Unique identifier of the custom rule whose action is being modified.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the custom rule action being modified.
-        """
+        Input properties used for looking up and filtering AppSecAttackGroup resources.
+        :param pulumi.Input[str] attack_group: Unique name of the attack group to be modified
+        :param pulumi.Input[str] attack_group_action: Action to be taken when the attack group is triggered
+        :param pulumi.Input[str] condition_exception: JSON-formatted condition and exception information for the attack group
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
+        """
+        if attack_group is not None:
+            pulumi.set(__self__, "attack_group", attack_group)
+        if attack_group_action is not None:
+            pulumi.set(__self__, "attack_group_action", attack_group_action)
+        if condition_exception is not None:
+            pulumi.set(__self__, "condition_exception", condition_exception)
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
-        if custom_rule_action is not None:
-            pulumi.set(__self__, "custom_rule_action", custom_rule_action)
-        if custom_rule_id is not None:
-            pulumi.set(__self__, "custom_rule_id", custom_rule_id)
         if security_policy_id is not None:
             pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
-    @pulumi.getter(name="configId")
-    def config_id(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="attackGroup")
+    def attack_group(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the security configuration associated with the custom rule action being modified.
+        Unique name of the attack group to be modified
         """
-        return pulumi.get(self, "config_id")
+        return pulumi.get(self, "attack_group")
 
-    @config_id.setter
-    def config_id(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "config_id", value)
+    @attack_group.setter
+    def attack_group(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "attack_group", value)
+
+    @property
+    @pulumi.getter(name="attackGroupAction")
+    def attack_group_action(self) -> Optional[pulumi.Input[str]]:
+        """
+        Action to be taken when the attack group is triggered
+        """
+        return pulumi.get(self, "attack_group_action")
+
+    @attack_group_action.setter
+    def attack_group_action(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "attack_group_action", value)
 
     @property
-    @pulumi.getter(name="customRuleAction")
-    def custom_rule_action(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="conditionException")
+    def condition_exception(self) -> Optional[pulumi.Input[str]]:
         """
-        . Action to be taken when the custom rule is invoked. Allowed values are:
-        - **alert**. Record the event.
-        - **deny**. Block the request.
-        - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-        - **none**. Take no action.
+        JSON-formatted condition and exception information for the attack group
         """
-        return pulumi.get(self, "custom_rule_action")
+        return pulumi.get(self, "condition_exception")
 
-    @custom_rule_action.setter
-    def custom_rule_action(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "custom_rule_action", value)
+    @condition_exception.setter
+    def condition_exception(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "condition_exception", value)
 
     @property
-    @pulumi.getter(name="customRuleId")
-    def custom_rule_id(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="configId")
+    def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the custom rule whose action is being modified.
+        Unique identifier of the security configuration
         """
-        return pulumi.get(self, "custom_rule_id")
+        return pulumi.get(self, "config_id")
 
-    @custom_rule_id.setter
-    def custom_rule_id(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "custom_rule_id", value)
+    @config_id.setter
+    def config_id(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the security policy associated with the custom rule action being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "security_policy_id", value)
 
 
-class AppSecCustomRuleAction(pulumi.CustomResource):
+class AppSecAttackGroup(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
+                 attack_group: Optional[pulumi.Input[str]] = None,
+                 attack_group_action: Optional[pulumi.Input[str]] = None,
+                 condition_exception: Optional[pulumi.Input[str]] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 custom_rule_action: Optional[pulumi.Input[str]] = None,
-                 custom_rule_id: Optional[pulumi.Input[int]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Custom rule
-
-        Associates an action with a custom rule. Custom rules are rules that you define yourself and are not part of the Kona Rule Set.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/custom-rules](https://techdocs.akamai.com/application-security/reference/get-configs-custom-rules)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        create_custom_rule_action = akamai.AppSecCustomRuleAction("createCustomRuleAction",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            custom_rule_id=12345,
-            custom_rule_action="alert")
-        pulumi.export("customRuleId", create_custom_rule_action.custom_rule_id)
-        ```
-
+        Create a AppSecAttackGroup resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the custom rule action being modified.
-        :param pulumi.Input[str] custom_rule_action: . Action to be taken when the custom rule is invoked. Allowed values are:
-               - **alert**. Record the event.
-               - **deny**. Block the request.
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action.
-        :param pulumi.Input[int] custom_rule_id: . Unique identifier of the custom rule whose action is being modified.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the custom rule action being modified.
+        :param pulumi.Input[str] attack_group: Unique name of the attack group to be modified
+        :param pulumi.Input[str] attack_group_action: Action to be taken when the attack group is triggered
+        :param pulumi.Input[str] condition_exception: JSON-formatted condition and exception information for the attack group
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: AppSecCustomRuleActionArgs,
+                 args: AppSecAttackGroupArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Custom rule
-
-        Associates an action with a custom rule. Custom rules are rules that you define yourself and are not part of the Kona Rule Set.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/custom-rules](https://techdocs.akamai.com/application-security/reference/get-configs-custom-rules)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        create_custom_rule_action = akamai.AppSecCustomRuleAction("createCustomRuleAction",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            custom_rule_id=12345,
-            custom_rule_action="alert")
-        pulumi.export("customRuleId", create_custom_rule_action.custom_rule_id)
-        ```
-
+        Create a AppSecAttackGroup resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param AppSecCustomRuleActionArgs args: The arguments to use to populate this resource's properties.
+        :param AppSecAttackGroupArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(AppSecCustomRuleActionArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(AppSecAttackGroupArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
+                 attack_group: Optional[pulumi.Input[str]] = None,
+                 attack_group_action: Optional[pulumi.Input[str]] = None,
+                 condition_exception: Optional[pulumi.Input[str]] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 custom_rule_action: Optional[pulumi.Input[str]] = None,
-                 custom_rule_id: Optional[pulumi.Input[int]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = AppSecCustomRuleActionArgs.__new__(AppSecCustomRuleActionArgs)
+            __props__ = AppSecAttackGroupArgs.__new__(AppSecAttackGroupArgs)
 
+            if attack_group is None and not opts.urn:
+                raise TypeError("Missing required property 'attack_group'")
+            __props__.__dict__["attack_group"] = attack_group
+            if attack_group_action is None and not opts.urn:
+                raise TypeError("Missing required property 'attack_group_action'")
+            __props__.__dict__["attack_group_action"] = attack_group_action
+            __props__.__dict__["condition_exception"] = condition_exception
             if config_id is None and not opts.urn:
                 raise TypeError("Missing required property 'config_id'")
             __props__.__dict__["config_id"] = config_id
-            if custom_rule_action is None and not opts.urn:
-                raise TypeError("Missing required property 'custom_rule_action'")
-            __props__.__dict__["custom_rule_action"] = custom_rule_action
-            if custom_rule_id is None and not opts.urn:
-                raise TypeError("Missing required property 'custom_rule_id'")
-            __props__.__dict__["custom_rule_id"] = custom_rule_id
             if security_policy_id is None and not opts.urn:
                 raise TypeError("Missing required property 'security_policy_id'")
             __props__.__dict__["security_policy_id"] = security_policy_id
-        super(AppSecCustomRuleAction, __self__).__init__(
-            'akamai:index/appSecCustomRuleAction:AppSecCustomRuleAction',
+        super(AppSecAttackGroup, __self__).__init__(
+            'akamai:index/appSecAttackGroup:AppSecAttackGroup',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
+            attack_group: Optional[pulumi.Input[str]] = None,
+            attack_group_action: Optional[pulumi.Input[str]] = None,
+            condition_exception: Optional[pulumi.Input[str]] = None,
             config_id: Optional[pulumi.Input[int]] = None,
-            custom_rule_action: Optional[pulumi.Input[str]] = None,
-            custom_rule_id: Optional[pulumi.Input[int]] = None,
-            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecCustomRuleAction':
+            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecAttackGroup':
         """
-        Get an existing AppSecCustomRuleAction resource's state with the given name, id, and optional extra
+        Get an existing AppSecAttackGroup resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the custom rule action being modified.
-        :param pulumi.Input[str] custom_rule_action: . Action to be taken when the custom rule is invoked. Allowed values are:
-               - **alert**. Record the event.
-               - **deny**. Block the request.
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action.
-        :param pulumi.Input[int] custom_rule_id: . Unique identifier of the custom rule whose action is being modified.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the custom rule action being modified.
+        :param pulumi.Input[str] attack_group: Unique name of the attack group to be modified
+        :param pulumi.Input[str] attack_group_action: Action to be taken when the attack group is triggered
+        :param pulumi.Input[str] condition_exception: JSON-formatted condition and exception information for the attack group
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _AppSecCustomRuleActionState.__new__(_AppSecCustomRuleActionState)
+        __props__ = _AppSecAttackGroupState.__new__(_AppSecAttackGroupState)
 
+        __props__.__dict__["attack_group"] = attack_group
+        __props__.__dict__["attack_group_action"] = attack_group_action
+        __props__.__dict__["condition_exception"] = condition_exception
         __props__.__dict__["config_id"] = config_id
-        __props__.__dict__["custom_rule_action"] = custom_rule_action
-        __props__.__dict__["custom_rule_id"] = custom_rule_id
         __props__.__dict__["security_policy_id"] = security_policy_id
-        return AppSecCustomRuleAction(resource_name, opts=opts, __props__=__props__)
+        return AppSecAttackGroup(resource_name, opts=opts, __props__=__props__)
 
     @property
-    @pulumi.getter(name="configId")
-    def config_id(self) -> pulumi.Output[int]:
+    @pulumi.getter(name="attackGroup")
+    def attack_group(self) -> pulumi.Output[str]:
         """
-        . Unique identifier of the security configuration associated with the custom rule action being modified.
+        Unique name of the attack group to be modified
         """
-        return pulumi.get(self, "config_id")
+        return pulumi.get(self, "attack_group")
 
     @property
-    @pulumi.getter(name="customRuleAction")
-    def custom_rule_action(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="attackGroupAction")
+    def attack_group_action(self) -> pulumi.Output[str]:
         """
-        . Action to be taken when the custom rule is invoked. Allowed values are:
-        - **alert**. Record the event.
-        - **deny**. Block the request.
-        - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-        - **none**. Take no action.
+        Action to be taken when the attack group is triggered
         """
-        return pulumi.get(self, "custom_rule_action")
+        return pulumi.get(self, "attack_group_action")
 
     @property
-    @pulumi.getter(name="customRuleId")
-    def custom_rule_id(self) -> pulumi.Output[int]:
+    @pulumi.getter(name="conditionException")
+    def condition_exception(self) -> pulumi.Output[Optional[str]]:
         """
-        . Unique identifier of the custom rule whose action is being modified.
+        JSON-formatted condition and exception information for the attack group
         """
-        return pulumi.get(self, "custom_rule_id")
+        return pulumi.get(self, "condition_exception")
+
+    @property
+    @pulumi.getter(name="configId")
+    def config_id(self) -> pulumi.Output[int]:
+        """
+        Unique identifier of the security configuration
+        """
+        return pulumi.get(self, "config_id")
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Output[str]:
         """
-        . Unique identifier of the security policy associated with the custom rule action being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_eval_penalty_box.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_penalty_box.py`

 * *Files 24% similar despite different names*

```diff
@@ -5,256 +5,190 @@
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
-__all__ = ['AppSecEvalPenaltyBoxArgs', 'AppSecEvalPenaltyBox']
+__all__ = ['AppSecPenaltyBoxArgs', 'AppSecPenaltyBox']
 
 @pulumi.input_type
-class AppSecEvalPenaltyBoxArgs:
+class AppSecPenaltyBoxArgs:
     def __init__(__self__, *,
                  config_id: pulumi.Input[int],
                  penalty_box_action: pulumi.Input[str],
                  penalty_box_protection: pulumi.Input[bool],
                  security_policy_id: pulumi.Input[str]):
         """
-        The set of arguments for constructing a AppSecEvalPenaltyBox resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the evaluation penalty box settings being modified.
-        :param pulumi.Input[str] penalty_box_action: . Action taken any time evaluation penalty box protection is triggered. Allowed values are:
-               - **alert**. Record the event.
-               - **deny**. Block the request.
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action.
-        :param pulumi.Input[bool] penalty_box_protection: . Set to **true** to enable evaluation penalty box protection; set to **false** to disable evaluation penalty box protection.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the evaluation penalty box settings being modified.
+        The set of arguments for constructing a AppSecPenaltyBox resource.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] penalty_box_action: The action to be taken when the penalty box is triggered
+        :param pulumi.Input[bool] penalty_box_protection: Whether to enable the penalty box for the specified security policy
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         pulumi.set(__self__, "config_id", config_id)
         pulumi.set(__self__, "penalty_box_action", penalty_box_action)
         pulumi.set(__self__, "penalty_box_protection", penalty_box_protection)
         pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuration associated with the evaluation penalty box settings being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter(name="penaltyBoxAction")
     def penalty_box_action(self) -> pulumi.Input[str]:
         """
-        . Action taken any time evaluation penalty box protection is triggered. Allowed values are:
-        - **alert**. Record the event.
-        - **deny**. Block the request.
-        - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-        - **none**. Take no action.
+        The action to be taken when the penalty box is triggered
         """
         return pulumi.get(self, "penalty_box_action")
 
     @penalty_box_action.setter
     def penalty_box_action(self, value: pulumi.Input[str]):
         pulumi.set(self, "penalty_box_action", value)
 
     @property
     @pulumi.getter(name="penaltyBoxProtection")
     def penalty_box_protection(self) -> pulumi.Input[bool]:
         """
-        . Set to **true** to enable evaluation penalty box protection; set to **false** to disable evaluation penalty box protection.
+        Whether to enable the penalty box for the specified security policy
         """
         return pulumi.get(self, "penalty_box_protection")
 
     @penalty_box_protection.setter
     def penalty_box_protection(self, value: pulumi.Input[bool]):
         pulumi.set(self, "penalty_box_protection", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Input[str]:
         """
-        . Unique identifier of the security policy associated with the evaluation penalty box settings being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "security_policy_id", value)
 
 
 @pulumi.input_type
-class _AppSecEvalPenaltyBoxState:
+class _AppSecPenaltyBoxState:
     def __init__(__self__, *,
                  config_id: Optional[pulumi.Input[int]] = None,
                  penalty_box_action: Optional[pulumi.Input[str]] = None,
                  penalty_box_protection: Optional[pulumi.Input[bool]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None):
         """
-        Input properties used for looking up and filtering AppSecEvalPenaltyBox resources.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the evaluation penalty box settings being modified.
-        :param pulumi.Input[str] penalty_box_action: . Action taken any time evaluation penalty box protection is triggered. Allowed values are:
-               - **alert**. Record the event.
-               - **deny**. Block the request.
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action.
-        :param pulumi.Input[bool] penalty_box_protection: . Set to **true** to enable evaluation penalty box protection; set to **false** to disable evaluation penalty box protection.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the evaluation penalty box settings being modified.
+        Input properties used for looking up and filtering AppSecPenaltyBox resources.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] penalty_box_action: The action to be taken when the penalty box is triggered
+        :param pulumi.Input[bool] penalty_box_protection: Whether to enable the penalty box for the specified security policy
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
         if penalty_box_action is not None:
             pulumi.set(__self__, "penalty_box_action", penalty_box_action)
         if penalty_box_protection is not None:
             pulumi.set(__self__, "penalty_box_protection", penalty_box_protection)
         if security_policy_id is not None:
             pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security configuration associated with the evaluation penalty box settings being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter(name="penaltyBoxAction")
     def penalty_box_action(self) -> Optional[pulumi.Input[str]]:
         """
-        . Action taken any time evaluation penalty box protection is triggered. Allowed values are:
-        - **alert**. Record the event.
-        - **deny**. Block the request.
-        - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-        - **none**. Take no action.
+        The action to be taken when the penalty box is triggered
         """
         return pulumi.get(self, "penalty_box_action")
 
     @penalty_box_action.setter
     def penalty_box_action(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "penalty_box_action", value)
 
     @property
     @pulumi.getter(name="penaltyBoxProtection")
     def penalty_box_protection(self) -> Optional[pulumi.Input[bool]]:
         """
-        . Set to **true** to enable evaluation penalty box protection; set to **false** to disable evaluation penalty box protection.
+        Whether to enable the penalty box for the specified security policy
         """
         return pulumi.get(self, "penalty_box_protection")
 
     @penalty_box_protection.setter
     def penalty_box_protection(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "penalty_box_protection", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the security policy associated with the evaluation penalty box settings being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "security_policy_id", value)
 
 
-class AppSecEvalPenaltyBox(pulumi.CustomResource):
+class AppSecPenaltyBox(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
                  penalty_box_action: Optional[pulumi.Input[str]] = None,
                  penalty_box_protection: Optional[pulumi.Input[bool]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Security policy
-
-         __ASE_Beta__.:
-        Modifies the penalty box settings for a security policy in evaluation mode - evaluation penalty box.
-        When the penalty box is enabled for a policy in evaluation mode, clients that trigger a WAF Deny action are placed in the penalty box.
-        There, the action you select for the penalty box (either Alert or Deny) continues to apply to any requests from that client for the next 10 minutes.
-
-        **Related API Endpoint**:  [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/eval_penalty-box](https://techdocs.akamai.com/application-security/reference/put-policy-eval_penalty-box)
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        eval_penalty_box = akamai.AppSecEvalPenaltyBox("evalPenaltyBox",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            penalty_box_protection=True,
-            penalty_box_action="deny")
-        ```
-
+        Create a AppSecPenaltyBox resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the evaluation penalty box settings being modified.
-        :param pulumi.Input[str] penalty_box_action: . Action taken any time evaluation penalty box protection is triggered. Allowed values are:
-               - **alert**. Record the event.
-               - **deny**. Block the request.
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action.
-        :param pulumi.Input[bool] penalty_box_protection: . Set to **true** to enable evaluation penalty box protection; set to **false** to disable evaluation penalty box protection.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the evaluation penalty box settings being modified.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] penalty_box_action: The action to be taken when the penalty box is triggered
+        :param pulumi.Input[bool] penalty_box_protection: Whether to enable the penalty box for the specified security policy
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: AppSecEvalPenaltyBoxArgs,
+                 args: AppSecPenaltyBoxArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Security policy
-
-         __ASE_Beta__.:
-        Modifies the penalty box settings for a security policy in evaluation mode - evaluation penalty box.
-        When the penalty box is enabled for a policy in evaluation mode, clients that trigger a WAF Deny action are placed in the penalty box.
-        There, the action you select for the penalty box (either Alert or Deny) continues to apply to any requests from that client for the next 10 minutes.
-
-        **Related API Endpoint**:  [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/eval_penalty-box](https://techdocs.akamai.com/application-security/reference/put-policy-eval_penalty-box)
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        eval_penalty_box = akamai.AppSecEvalPenaltyBox("evalPenaltyBox",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            penalty_box_protection=True,
-            penalty_box_action="deny")
-        ```
-
+        Create a AppSecPenaltyBox resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param AppSecEvalPenaltyBoxArgs args: The arguments to use to populate this resource's properties.
+        :param AppSecPenaltyBoxArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(AppSecEvalPenaltyBoxArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(AppSecPenaltyBoxArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
@@ -266,97 +200,89 @@
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = AppSecEvalPenaltyBoxArgs.__new__(AppSecEvalPenaltyBoxArgs)
+            __props__ = AppSecPenaltyBoxArgs.__new__(AppSecPenaltyBoxArgs)
 
             if config_id is None and not opts.urn:
                 raise TypeError("Missing required property 'config_id'")
             __props__.__dict__["config_id"] = config_id
             if penalty_box_action is None and not opts.urn:
                 raise TypeError("Missing required property 'penalty_box_action'")
             __props__.__dict__["penalty_box_action"] = penalty_box_action
             if penalty_box_protection is None and not opts.urn:
                 raise TypeError("Missing required property 'penalty_box_protection'")
             __props__.__dict__["penalty_box_protection"] = penalty_box_protection
             if security_policy_id is None and not opts.urn:
                 raise TypeError("Missing required property 'security_policy_id'")
             __props__.__dict__["security_policy_id"] = security_policy_id
-        super(AppSecEvalPenaltyBox, __self__).__init__(
-            'akamai:index/appSecEvalPenaltyBox:AppSecEvalPenaltyBox',
+        super(AppSecPenaltyBox, __self__).__init__(
+            'akamai:index/appSecPenaltyBox:AppSecPenaltyBox',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
             config_id: Optional[pulumi.Input[int]] = None,
             penalty_box_action: Optional[pulumi.Input[str]] = None,
             penalty_box_protection: Optional[pulumi.Input[bool]] = None,
-            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecEvalPenaltyBox':
+            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecPenaltyBox':
         """
-        Get an existing AppSecEvalPenaltyBox resource's state with the given name, id, and optional extra
+        Get an existing AppSecPenaltyBox resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the evaluation penalty box settings being modified.
-        :param pulumi.Input[str] penalty_box_action: . Action taken any time evaluation penalty box protection is triggered. Allowed values are:
-               - **alert**. Record the event.
-               - **deny**. Block the request.
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action.
-        :param pulumi.Input[bool] penalty_box_protection: . Set to **true** to enable evaluation penalty box protection; set to **false** to disable evaluation penalty box protection.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the evaluation penalty box settings being modified.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] penalty_box_action: The action to be taken when the penalty box is triggered
+        :param pulumi.Input[bool] penalty_box_protection: Whether to enable the penalty box for the specified security policy
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _AppSecEvalPenaltyBoxState.__new__(_AppSecEvalPenaltyBoxState)
+        __props__ = _AppSecPenaltyBoxState.__new__(_AppSecPenaltyBoxState)
 
         __props__.__dict__["config_id"] = config_id
         __props__.__dict__["penalty_box_action"] = penalty_box_action
         __props__.__dict__["penalty_box_protection"] = penalty_box_protection
         __props__.__dict__["security_policy_id"] = security_policy_id
-        return AppSecEvalPenaltyBox(resource_name, opts=opts, __props__=__props__)
+        return AppSecPenaltyBox(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Output[int]:
         """
-        . Unique identifier of the security configuration associated with the evaluation penalty box settings being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @property
     @pulumi.getter(name="penaltyBoxAction")
     def penalty_box_action(self) -> pulumi.Output[str]:
         """
-        . Action taken any time evaluation penalty box protection is triggered. Allowed values are:
-        - **alert**. Record the event.
-        - **deny**. Block the request.
-        - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-        - **none**. Take no action.
+        The action to be taken when the penalty box is triggered
         """
         return pulumi.get(self, "penalty_box_action")
 
     @property
     @pulumi.getter(name="penaltyBoxProtection")
     def penalty_box_protection(self) -> pulumi.Output[bool]:
         """
-        . Set to **true** to enable evaluation penalty box protection; set to **false** to disable evaluation penalty box protection.
+        Whether to enable the penalty box for the specified security policy
         """
         return pulumi.get(self, "penalty_box_protection")
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Output[str]:
         """
-        . Unique identifier of the security policy associated with the evaluation penalty box settings being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_ip_geo_protection.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_slow_post_protection.py`

 * *Files 16% similar despite different names*

```diff
@@ -5,109 +5,109 @@
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
-__all__ = ['AppSecIPGeoProtectionArgs', 'AppSecIPGeoProtection']
+__all__ = ['AppSecSlowPostProtectionArgs', 'AppSecSlowPostProtection']
 
 @pulumi.input_type
-class AppSecIPGeoProtectionArgs:
+class AppSecSlowPostProtectionArgs:
     def __init__(__self__, *,
                  config_id: pulumi.Input[int],
                  enabled: pulumi.Input[bool],
                  security_policy_id: pulumi.Input[str]):
         """
-        The set of arguments for constructing a AppSecIPGeoProtection resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the IP/Geo protection settings being modified.
-        :param pulumi.Input[bool] enabled: . Set to **true** to enable IP/Geo protection; set to **false** to disable IP/Geo protection.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the IP/Geo protection settings being modified.
+        The set of arguments for constructing a AppSecSlowPostProtection resource.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enabled: Whether to enable slow POST protection
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         pulumi.set(__self__, "config_id", config_id)
         pulumi.set(__self__, "enabled", enabled)
         pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuration associated with the IP/Geo protection settings being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter
     def enabled(self) -> pulumi.Input[bool]:
         """
-        . Set to **true** to enable IP/Geo protection; set to **false** to disable IP/Geo protection.
+        Whether to enable slow POST protection
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: pulumi.Input[bool]):
         pulumi.set(self, "enabled", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Input[str]:
         """
-        . Unique identifier of the security policy associated with the IP/Geo protection settings being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "security_policy_id", value)
 
 
 @pulumi.input_type
-class _AppSecIPGeoProtectionState:
+class _AppSecSlowPostProtectionState:
     def __init__(__self__, *,
                  config_id: Optional[pulumi.Input[int]] = None,
                  enabled: Optional[pulumi.Input[bool]] = None,
                  output_text: Optional[pulumi.Input[str]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None):
         """
-        Input properties used for looking up and filtering AppSecIPGeoProtection resources.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the IP/Geo protection settings being modified.
-        :param pulumi.Input[bool] enabled: . Set to **true** to enable IP/Geo protection; set to **false** to disable IP/Geo protection.
+        Input properties used for looking up and filtering AppSecSlowPostProtection resources.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enabled: Whether to enable slow POST protection
         :param pulumi.Input[str] output_text: Text representation
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the IP/Geo protection settings being modified.
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
         if enabled is not None:
             pulumi.set(__self__, "enabled", enabled)
         if output_text is not None:
             pulumi.set(__self__, "output_text", output_text)
         if security_policy_id is not None:
             pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security configuration associated with the IP/Geo protection settings being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter
     def enabled(self) -> Optional[pulumi.Input[bool]]:
         """
-        . Set to **true** to enable IP/Geo protection; set to **false** to disable IP/Geo protection.
+        Whether to enable slow POST protection
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "enabled", value)
 
@@ -123,105 +123,55 @@
     def output_text(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "output_text", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the security policy associated with the IP/Geo protection settings being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "security_policy_id", value)
 
 
-class AppSecIPGeoProtection(pulumi.CustomResource):
+class AppSecSlowPostProtection(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
                  enabled: Optional[pulumi.Input[bool]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Security policy
-
-        Enables or disables IP/Geo protection for the specified configuration and security policy. When enabled, this allows your firewall to allow (or to block) clients based on their IP address or their geographic location.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/ip-geo-firewall](https://techdocs.akamai.com/application-security/reference/put-policy-protections)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        protection = akamai.AppSecIPGeoProtection("protection",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            enabled=True)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `output_text`. Tabular report showing the current protection settings.
-
+        Create a AppSecSlowPostProtection resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the IP/Geo protection settings being modified.
-        :param pulumi.Input[bool] enabled: . Set to **true** to enable IP/Geo protection; set to **false** to disable IP/Geo protection.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the IP/Geo protection settings being modified.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enabled: Whether to enable slow POST protection
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: AppSecIPGeoProtectionArgs,
+                 args: AppSecSlowPostProtectionArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Security policy
-
-        Enables or disables IP/Geo protection for the specified configuration and security policy. When enabled, this allows your firewall to allow (or to block) clients based on their IP address or their geographic location.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/ip-geo-firewall](https://techdocs.akamai.com/application-security/reference/put-policy-protections)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        protection = akamai.AppSecIPGeoProtection("protection",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            enabled=True)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `output_text`. Tabular report showing the current protection settings.
-
+        Create a AppSecSlowPostProtection resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param AppSecIPGeoProtectionArgs args: The arguments to use to populate this resource's properties.
+        :param AppSecSlowPostProtectionArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(AppSecIPGeoProtectionArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(AppSecSlowPostProtectionArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
@@ -232,75 +182,75 @@
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = AppSecIPGeoProtectionArgs.__new__(AppSecIPGeoProtectionArgs)
+            __props__ = AppSecSlowPostProtectionArgs.__new__(AppSecSlowPostProtectionArgs)
 
             if config_id is None and not opts.urn:
                 raise TypeError("Missing required property 'config_id'")
             __props__.__dict__["config_id"] = config_id
             if enabled is None and not opts.urn:
                 raise TypeError("Missing required property 'enabled'")
             __props__.__dict__["enabled"] = enabled
             if security_policy_id is None and not opts.urn:
                 raise TypeError("Missing required property 'security_policy_id'")
             __props__.__dict__["security_policy_id"] = security_policy_id
             __props__.__dict__["output_text"] = None
-        super(AppSecIPGeoProtection, __self__).__init__(
-            'akamai:index/appSecIPGeoProtection:AppSecIPGeoProtection',
+        super(AppSecSlowPostProtection, __self__).__init__(
+            'akamai:index/appSecSlowPostProtection:AppSecSlowPostProtection',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
             config_id: Optional[pulumi.Input[int]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             output_text: Optional[pulumi.Input[str]] = None,
-            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecIPGeoProtection':
+            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecSlowPostProtection':
         """
-        Get an existing AppSecIPGeoProtection resource's state with the given name, id, and optional extra
+        Get an existing AppSecSlowPostProtection resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the IP/Geo protection settings being modified.
-        :param pulumi.Input[bool] enabled: . Set to **true** to enable IP/Geo protection; set to **false** to disable IP/Geo protection.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enabled: Whether to enable slow POST protection
         :param pulumi.Input[str] output_text: Text representation
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the IP/Geo protection settings being modified.
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _AppSecIPGeoProtectionState.__new__(_AppSecIPGeoProtectionState)
+        __props__ = _AppSecSlowPostProtectionState.__new__(_AppSecSlowPostProtectionState)
 
         __props__.__dict__["config_id"] = config_id
         __props__.__dict__["enabled"] = enabled
         __props__.__dict__["output_text"] = output_text
         __props__.__dict__["security_policy_id"] = security_policy_id
-        return AppSecIPGeoProtection(resource_name, opts=opts, __props__=__props__)
+        return AppSecSlowPostProtection(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Output[int]:
         """
-        . Unique identifier of the security configuration associated with the IP/Geo protection settings being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @property
     @pulumi.getter
     def enabled(self) -> pulumi.Output[bool]:
         """
-        . Set to **true** to enable IP/Geo protection; set to **false** to disable IP/Geo protection.
+        Whether to enable slow POST protection
         """
         return pulumi.get(self, "enabled")
 
     @property
     @pulumi.getter(name="outputText")
     def output_text(self) -> pulumi.Output[str]:
         """
@@ -308,11 +258,11 @@
         """
         return pulumi.get(self, "output_text")
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Output[str]:
         """
-        . Unique identifier of the security policy associated with the IP/Geo protection settings being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_malware_policy.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_malware_protection.py`

 * *Files 25% similar despite different names*

```diff
@@ -5,262 +5,264 @@
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
-__all__ = ['AppSecMalwarePolicyArgs', 'AppSecMalwarePolicy']
+__all__ = ['AppSecMalwareProtectionArgs', 'AppSecMalwareProtection']
 
 @pulumi.input_type
-class AppSecMalwarePolicyArgs:
+class AppSecMalwareProtectionArgs:
     def __init__(__self__, *,
                  config_id: pulumi.Input[int],
-                 malware_policy: pulumi.Input[str]):
+                 enabled: pulumi.Input[bool],
+                 security_policy_id: pulumi.Input[str]):
         """
-        The set of arguments for constructing a AppSecMalwarePolicy resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the malware policy being modified.
-        :param pulumi.Input[str] malware_policy: . Path to a JSON file containing a malware policy definition. You can view a sample malware policy JSON file in the [MalwarePolicy](https://developer.akamai.com/api/cloud_security/application_security/v1.html#malwarepolicy) section of the Application Security API documentation.
+        The set of arguments for constructing a AppSecMalwareProtection resource.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enabled: Whether to enable malware protection
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         pulumi.set(__self__, "config_id", config_id)
-        pulumi.set(__self__, "malware_policy", malware_policy)
+        pulumi.set(__self__, "enabled", enabled)
+        pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuration associated with the malware policy being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "config_id", value)
 
     @property
-    @pulumi.getter(name="malwarePolicy")
-    def malware_policy(self) -> pulumi.Input[str]:
+    @pulumi.getter
+    def enabled(self) -> pulumi.Input[bool]:
         """
-        . Path to a JSON file containing a malware policy definition. You can view a sample malware policy JSON file in the [MalwarePolicy](https://developer.akamai.com/api/cloud_security/application_security/v1.html#malwarepolicy) section of the Application Security API documentation.
+        Whether to enable malware protection
         """
-        return pulumi.get(self, "malware_policy")
+        return pulumi.get(self, "enabled")
 
-    @malware_policy.setter
-    def malware_policy(self, value: pulumi.Input[str]):
-        pulumi.set(self, "malware_policy", value)
+    @enabled.setter
+    def enabled(self, value: pulumi.Input[bool]):
+        pulumi.set(self, "enabled", value)
+
+    @property
+    @pulumi.getter(name="securityPolicyId")
+    def security_policy_id(self) -> pulumi.Input[str]:
+        """
+        Unique identifier of the security policy
+        """
+        return pulumi.get(self, "security_policy_id")
+
+    @security_policy_id.setter
+    def security_policy_id(self, value: pulumi.Input[str]):
+        pulumi.set(self, "security_policy_id", value)
 
 
 @pulumi.input_type
-class _AppSecMalwarePolicyState:
+class _AppSecMalwareProtectionState:
     def __init__(__self__, *,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 malware_policy: Optional[pulumi.Input[str]] = None,
-                 malware_policy_id: Optional[pulumi.Input[int]] = None):
-        """
-        Input properties used for looking up and filtering AppSecMalwarePolicy resources.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the malware policy being modified.
-        :param pulumi.Input[str] malware_policy: . Path to a JSON file containing a malware policy definition. You can view a sample malware policy JSON file in the [MalwarePolicy](https://developer.akamai.com/api/cloud_security/application_security/v1.html#malwarepolicy) section of the Application Security API documentation.
-        :param pulumi.Input[int] malware_policy_id: Unique identifier of the malware policy
+                 enabled: Optional[pulumi.Input[bool]] = None,
+                 output_text: Optional[pulumi.Input[str]] = None,
+                 security_policy_id: Optional[pulumi.Input[str]] = None):
+        """
+        Input properties used for looking up and filtering AppSecMalwareProtection resources.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enabled: Whether to enable malware protection
+        :param pulumi.Input[str] output_text: Text representation
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
-        if malware_policy is not None:
-            pulumi.set(__self__, "malware_policy", malware_policy)
-        if malware_policy_id is not None:
-            pulumi.set(__self__, "malware_policy_id", malware_policy_id)
+        if enabled is not None:
+            pulumi.set(__self__, "enabled", enabled)
+        if output_text is not None:
+            pulumi.set(__self__, "output_text", output_text)
+        if security_policy_id is not None:
+            pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security configuration associated with the malware policy being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "config_id", value)
 
     @property
-    @pulumi.getter(name="malwarePolicy")
-    def malware_policy(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter
+    def enabled(self) -> Optional[pulumi.Input[bool]]:
+        """
+        Whether to enable malware protection
+        """
+        return pulumi.get(self, "enabled")
+
+    @enabled.setter
+    def enabled(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "enabled", value)
+
+    @property
+    @pulumi.getter(name="outputText")
+    def output_text(self) -> Optional[pulumi.Input[str]]:
         """
-        . Path to a JSON file containing a malware policy definition. You can view a sample malware policy JSON file in the [MalwarePolicy](https://developer.akamai.com/api/cloud_security/application_security/v1.html#malwarepolicy) section of the Application Security API documentation.
+        Text representation
         """
-        return pulumi.get(self, "malware_policy")
+        return pulumi.get(self, "output_text")
 
-    @malware_policy.setter
-    def malware_policy(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "malware_policy", value)
+    @output_text.setter
+    def output_text(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "output_text", value)
 
     @property
-    @pulumi.getter(name="malwarePolicyId")
-    def malware_policy_id(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="securityPolicyId")
+    def security_policy_id(self) -> Optional[pulumi.Input[str]]:
         """
-        Unique identifier of the malware policy
+        Unique identifier of the security policy
         """
-        return pulumi.get(self, "malware_policy_id")
+        return pulumi.get(self, "security_policy_id")
 
-    @malware_policy_id.setter
-    def malware_policy_id(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "malware_policy_id", value)
+    @security_policy_id.setter
+    def security_policy_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "security_policy_id", value)
 
 
-class AppSecMalwarePolicy(pulumi.CustomResource):
+class AppSecMalwareProtection(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 malware_policy: Optional[pulumi.Input[str]] = None,
+                 enabled: Optional[pulumi.Input[bool]] = None,
+                 security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Security configuration; malware protection
-
-        Creates, modifies, or deletes malware policies. Malware polices help you control what happens when a request is made to upload files of various types. These policies help you control how your website is protected from malicious uploads.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        malware_policy = akamai.AppSecMalwarePolicy("malwarePolicy",
-            config_id=configuration.config_id,
-            malware_policy=(lambda path: open(path).read())(f"{path['module']}/malware_policy.json"))
-        pulumi.export("malwarePolicyId", malware_policy.malware_policy_id)
-        ```
-        ## Output Options
-
-        The following option can be used to determine the information returned, and how that returned information is formatted:
-
-        - `malware_policy_id`. Unique identifier of the modified or newly-created malware policy.
-
+        Create a AppSecMalwareProtection resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the malware policy being modified.
-        :param pulumi.Input[str] malware_policy: . Path to a JSON file containing a malware policy definition. You can view a sample malware policy JSON file in the [MalwarePolicy](https://developer.akamai.com/api/cloud_security/application_security/v1.html#malwarepolicy) section of the Application Security API documentation.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enabled: Whether to enable malware protection
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: AppSecMalwarePolicyArgs,
+                 args: AppSecMalwareProtectionArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Security configuration; malware protection
-
-        Creates, modifies, or deletes malware policies. Malware polices help you control what happens when a request is made to upload files of various types. These policies help you control how your website is protected from malicious uploads.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        malware_policy = akamai.AppSecMalwarePolicy("malwarePolicy",
-            config_id=configuration.config_id,
-            malware_policy=(lambda path: open(path).read())(f"{path['module']}/malware_policy.json"))
-        pulumi.export("malwarePolicyId", malware_policy.malware_policy_id)
-        ```
-        ## Output Options
-
-        The following option can be used to determine the information returned, and how that returned information is formatted:
-
-        - `malware_policy_id`. Unique identifier of the modified or newly-created malware policy.
-
+        Create a AppSecMalwareProtection resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param AppSecMalwarePolicyArgs args: The arguments to use to populate this resource's properties.
+        :param AppSecMalwareProtectionArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(AppSecMalwarePolicyArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(AppSecMalwareProtectionArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 malware_policy: Optional[pulumi.Input[str]] = None,
+                 enabled: Optional[pulumi.Input[bool]] = None,
+                 security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = AppSecMalwarePolicyArgs.__new__(AppSecMalwarePolicyArgs)
+            __props__ = AppSecMalwareProtectionArgs.__new__(AppSecMalwareProtectionArgs)
 
             if config_id is None and not opts.urn:
                 raise TypeError("Missing required property 'config_id'")
             __props__.__dict__["config_id"] = config_id
-            if malware_policy is None and not opts.urn:
-                raise TypeError("Missing required property 'malware_policy'")
-            __props__.__dict__["malware_policy"] = malware_policy
-            __props__.__dict__["malware_policy_id"] = None
-        super(AppSecMalwarePolicy, __self__).__init__(
-            'akamai:index/appSecMalwarePolicy:AppSecMalwarePolicy',
+            if enabled is None and not opts.urn:
+                raise TypeError("Missing required property 'enabled'")
+            __props__.__dict__["enabled"] = enabled
+            if security_policy_id is None and not opts.urn:
+                raise TypeError("Missing required property 'security_policy_id'")
+            __props__.__dict__["security_policy_id"] = security_policy_id
+            __props__.__dict__["output_text"] = None
+        super(AppSecMalwareProtection, __self__).__init__(
+            'akamai:index/appSecMalwareProtection:AppSecMalwareProtection',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
             config_id: Optional[pulumi.Input[int]] = None,
-            malware_policy: Optional[pulumi.Input[str]] = None,
-            malware_policy_id: Optional[pulumi.Input[int]] = None) -> 'AppSecMalwarePolicy':
+            enabled: Optional[pulumi.Input[bool]] = None,
+            output_text: Optional[pulumi.Input[str]] = None,
+            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecMalwareProtection':
         """
-        Get an existing AppSecMalwarePolicy resource's state with the given name, id, and optional extra
+        Get an existing AppSecMalwareProtection resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the malware policy being modified.
-        :param pulumi.Input[str] malware_policy: . Path to a JSON file containing a malware policy definition. You can view a sample malware policy JSON file in the [MalwarePolicy](https://developer.akamai.com/api/cloud_security/application_security/v1.html#malwarepolicy) section of the Application Security API documentation.
-        :param pulumi.Input[int] malware_policy_id: Unique identifier of the malware policy
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enabled: Whether to enable malware protection
+        :param pulumi.Input[str] output_text: Text representation
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _AppSecMalwarePolicyState.__new__(_AppSecMalwarePolicyState)
+        __props__ = _AppSecMalwareProtectionState.__new__(_AppSecMalwareProtectionState)
 
         __props__.__dict__["config_id"] = config_id
-        __props__.__dict__["malware_policy"] = malware_policy
-        __props__.__dict__["malware_policy_id"] = malware_policy_id
-        return AppSecMalwarePolicy(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["enabled"] = enabled
+        __props__.__dict__["output_text"] = output_text
+        __props__.__dict__["security_policy_id"] = security_policy_id
+        return AppSecMalwareProtection(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Output[int]:
         """
-        . Unique identifier of the security configuration associated with the malware policy being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @property
-    @pulumi.getter(name="malwarePolicy")
-    def malware_policy(self) -> pulumi.Output[str]:
+    @pulumi.getter
+    def enabled(self) -> pulumi.Output[bool]:
+        """
+        Whether to enable malware protection
+        """
+        return pulumi.get(self, "enabled")
+
+    @property
+    @pulumi.getter(name="outputText")
+    def output_text(self) -> pulumi.Output[str]:
         """
-        . Path to a JSON file containing a malware policy definition. You can view a sample malware policy JSON file in the [MalwarePolicy](https://developer.akamai.com/api/cloud_security/application_security/v1.html#malwarepolicy) section of the Application Security API documentation.
+        Text representation
         """
-        return pulumi.get(self, "malware_policy")
+        return pulumi.get(self, "output_text")
 
     @property
-    @pulumi.getter(name="malwarePolicyId")
-    def malware_policy_id(self) -> pulumi.Output[int]:
+    @pulumi.getter(name="securityPolicyId")
+    def security_policy_id(self) -> pulumi.Output[str]:
         """
-        Unique identifier of the malware policy
+        Unique identifier of the security policy
         """
-        return pulumi.get(self, "malware_policy_id")
+        return pulumi.get(self, "security_policy_id")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_malware_policy_actions.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_reputation_profile_analysis.py`

 * *Files 24% similar despite different names*

```diff
@@ -5,282 +5,284 @@
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
-__all__ = ['AppSecMalwarePolicyActionsArgs', 'AppSecMalwarePolicyActions']
+__all__ = ['AppSecReputationProfileAnalysisArgs', 'AppSecReputationProfileAnalysis']
 
 @pulumi.input_type
-class AppSecMalwarePolicyActionsArgs:
+class AppSecReputationProfileAnalysisArgs:
     def __init__(__self__, *,
                  config_id: pulumi.Input[int],
-                 malware_policy_actions: pulumi.Input[str],
+                 forward_shared_ip_to_http_header_siem: pulumi.Input[bool],
+                 forward_to_http_header: pulumi.Input[bool],
                  security_policy_id: pulumi.Input[str]):
         """
-        The set of arguments for constructing a AppSecMalwarePolicyActions resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the malware policy action being modified.
-        :param pulumi.Input[str] malware_policy_actions: . Path to a JSON file containing the malware policy IDs and their respective actions. A sample JSON file can be found in the [Modify malware policy actions for a security policy](https://techdocs.akamai.com/application-security/reference/put-policy) section of the Application Security API documentation.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the malware policy whose action is being modified.
+        The set of arguments for constructing a AppSecReputationProfileAnalysis resource.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] forward_shared_ip_to_http_header_siem: Whether to add a value indicating that shared IPs are included in HTTP header and SIEM integration
+        :param pulumi.Input[bool] forward_to_http_header: Whether to add client reputation details to requests forwarded to the origin server
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         pulumi.set(__self__, "config_id", config_id)
-        pulumi.set(__self__, "malware_policy_actions", malware_policy_actions)
+        pulumi.set(__self__, "forward_shared_ip_to_http_header_siem", forward_shared_ip_to_http_header_siem)
+        pulumi.set(__self__, "forward_to_http_header", forward_to_http_header)
         pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuration associated with the malware policy action being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "config_id", value)
 
     @property
-    @pulumi.getter(name="malwarePolicyActions")
-    def malware_policy_actions(self) -> pulumi.Input[str]:
+    @pulumi.getter(name="forwardSharedIpToHttpHeaderSiem")
+    def forward_shared_ip_to_http_header_siem(self) -> pulumi.Input[bool]:
         """
-        . Path to a JSON file containing the malware policy IDs and their respective actions. A sample JSON file can be found in the [Modify malware policy actions for a security policy](https://techdocs.akamai.com/application-security/reference/put-policy) section of the Application Security API documentation.
+        Whether to add a value indicating that shared IPs are included in HTTP header and SIEM integration
         """
-        return pulumi.get(self, "malware_policy_actions")
+        return pulumi.get(self, "forward_shared_ip_to_http_header_siem")
 
-    @malware_policy_actions.setter
-    def malware_policy_actions(self, value: pulumi.Input[str]):
-        pulumi.set(self, "malware_policy_actions", value)
+    @forward_shared_ip_to_http_header_siem.setter
+    def forward_shared_ip_to_http_header_siem(self, value: pulumi.Input[bool]):
+        pulumi.set(self, "forward_shared_ip_to_http_header_siem", value)
+
+    @property
+    @pulumi.getter(name="forwardToHttpHeader")
+    def forward_to_http_header(self) -> pulumi.Input[bool]:
+        """
+        Whether to add client reputation details to requests forwarded to the origin server
+        """
+        return pulumi.get(self, "forward_to_http_header")
+
+    @forward_to_http_header.setter
+    def forward_to_http_header(self, value: pulumi.Input[bool]):
+        pulumi.set(self, "forward_to_http_header", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Input[str]:
         """
-        . Unique identifier of the security policy associated with the malware policy whose action is being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "security_policy_id", value)
 
 
 @pulumi.input_type
-class _AppSecMalwarePolicyActionsState:
+class _AppSecReputationProfileAnalysisState:
     def __init__(__self__, *,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 malware_policy_actions: Optional[pulumi.Input[str]] = None,
+                 forward_shared_ip_to_http_header_siem: Optional[pulumi.Input[bool]] = None,
+                 forward_to_http_header: Optional[pulumi.Input[bool]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None):
         """
-        Input properties used for looking up and filtering AppSecMalwarePolicyActions resources.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the malware policy action being modified.
-        :param pulumi.Input[str] malware_policy_actions: . Path to a JSON file containing the malware policy IDs and their respective actions. A sample JSON file can be found in the [Modify malware policy actions for a security policy](https://techdocs.akamai.com/application-security/reference/put-policy) section of the Application Security API documentation.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the malware policy whose action is being modified.
+        Input properties used for looking up and filtering AppSecReputationProfileAnalysis resources.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] forward_shared_ip_to_http_header_siem: Whether to add a value indicating that shared IPs are included in HTTP header and SIEM integration
+        :param pulumi.Input[bool] forward_to_http_header: Whether to add client reputation details to requests forwarded to the origin server
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
-        if malware_policy_actions is not None:
-            pulumi.set(__self__, "malware_policy_actions", malware_policy_actions)
+        if forward_shared_ip_to_http_header_siem is not None:
+            pulumi.set(__self__, "forward_shared_ip_to_http_header_siem", forward_shared_ip_to_http_header_siem)
+        if forward_to_http_header is not None:
+            pulumi.set(__self__, "forward_to_http_header", forward_to_http_header)
         if security_policy_id is not None:
             pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security configuration associated with the malware policy action being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "config_id", value)
 
     @property
-    @pulumi.getter(name="malwarePolicyActions")
-    def malware_policy_actions(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="forwardSharedIpToHttpHeaderSiem")
+    def forward_shared_ip_to_http_header_siem(self) -> Optional[pulumi.Input[bool]]:
+        """
+        Whether to add a value indicating that shared IPs are included in HTTP header and SIEM integration
+        """
+        return pulumi.get(self, "forward_shared_ip_to_http_header_siem")
+
+    @forward_shared_ip_to_http_header_siem.setter
+    def forward_shared_ip_to_http_header_siem(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "forward_shared_ip_to_http_header_siem", value)
+
+    @property
+    @pulumi.getter(name="forwardToHttpHeader")
+    def forward_to_http_header(self) -> Optional[pulumi.Input[bool]]:
         """
-        . Path to a JSON file containing the malware policy IDs and their respective actions. A sample JSON file can be found in the [Modify malware policy actions for a security policy](https://techdocs.akamai.com/application-security/reference/put-policy) section of the Application Security API documentation.
+        Whether to add client reputation details to requests forwarded to the origin server
         """
-        return pulumi.get(self, "malware_policy_actions")
+        return pulumi.get(self, "forward_to_http_header")
 
-    @malware_policy_actions.setter
-    def malware_policy_actions(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "malware_policy_actions", value)
+    @forward_to_http_header.setter
+    def forward_to_http_header(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "forward_to_http_header", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the security policy associated with the malware policy whose action is being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "security_policy_id", value)
 
 
-class AppSecMalwarePolicyActions(pulumi.CustomResource):
+class AppSecReputationProfileAnalysis(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 malware_policy_actions: Optional[pulumi.Input[str]] = None,
+                 forward_shared_ip_to_http_header_siem: Optional[pulumi.Input[bool]] = None,
+                 forward_to_http_header: Optional[pulumi.Input[bool]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Malware protection
-
-        Creates, modifies, or deletes the actions associated with one or more policies within a given security policy.
-        By default, malware policies take no action when triggered.
-        Note that you must set separate actions for requests that are scanned according to the specified malware policy and those that are unscanned.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        appsec_malware_policy = akamai.AppSecMalwarePolicy("appsecMalwarePolicy",
-            config_id=configuration.config_id,
-            malware_policy=(lambda path: open(path).read())(f"{path['module']}/malware_policy.json"))
-        appsec_malware_policy_actions = akamai.AppSecMalwarePolicyActions("appsecMalwarePolicyActions",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            malware_policy_actions=(lambda path: open(path).read())(f"{path['module']}/malware_policy_actions.json"))
-        ```
-
+        Create a AppSecReputationProfileAnalysis resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the malware policy action being modified.
-        :param pulumi.Input[str] malware_policy_actions: . Path to a JSON file containing the malware policy IDs and their respective actions. A sample JSON file can be found in the [Modify malware policy actions for a security policy](https://techdocs.akamai.com/application-security/reference/put-policy) section of the Application Security API documentation.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the malware policy whose action is being modified.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] forward_shared_ip_to_http_header_siem: Whether to add a value indicating that shared IPs are included in HTTP header and SIEM integration
+        :param pulumi.Input[bool] forward_to_http_header: Whether to add client reputation details to requests forwarded to the origin server
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: AppSecMalwarePolicyActionsArgs,
+                 args: AppSecReputationProfileAnalysisArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Malware protection
-
-        Creates, modifies, or deletes the actions associated with one or more policies within a given security policy.
-        By default, malware policies take no action when triggered.
-        Note that you must set separate actions for requests that are scanned according to the specified malware policy and those that are unscanned.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        appsec_malware_policy = akamai.AppSecMalwarePolicy("appsecMalwarePolicy",
-            config_id=configuration.config_id,
-            malware_policy=(lambda path: open(path).read())(f"{path['module']}/malware_policy.json"))
-        appsec_malware_policy_actions = akamai.AppSecMalwarePolicyActions("appsecMalwarePolicyActions",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            malware_policy_actions=(lambda path: open(path).read())(f"{path['module']}/malware_policy_actions.json"))
-        ```
-
+        Create a AppSecReputationProfileAnalysis resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param AppSecMalwarePolicyActionsArgs args: The arguments to use to populate this resource's properties.
+        :param AppSecReputationProfileAnalysisArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(AppSecMalwarePolicyActionsArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(AppSecReputationProfileAnalysisArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 malware_policy_actions: Optional[pulumi.Input[str]] = None,
+                 forward_shared_ip_to_http_header_siem: Optional[pulumi.Input[bool]] = None,
+                 forward_to_http_header: Optional[pulumi.Input[bool]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = AppSecMalwarePolicyActionsArgs.__new__(AppSecMalwarePolicyActionsArgs)
+            __props__ = AppSecReputationProfileAnalysisArgs.__new__(AppSecReputationProfileAnalysisArgs)
 
             if config_id is None and not opts.urn:
                 raise TypeError("Missing required property 'config_id'")
             __props__.__dict__["config_id"] = config_id
-            if malware_policy_actions is None and not opts.urn:
-                raise TypeError("Missing required property 'malware_policy_actions'")
-            __props__.__dict__["malware_policy_actions"] = malware_policy_actions
+            if forward_shared_ip_to_http_header_siem is None and not opts.urn:
+                raise TypeError("Missing required property 'forward_shared_ip_to_http_header_siem'")
+            __props__.__dict__["forward_shared_ip_to_http_header_siem"] = forward_shared_ip_to_http_header_siem
+            if forward_to_http_header is None and not opts.urn:
+                raise TypeError("Missing required property 'forward_to_http_header'")
+            __props__.__dict__["forward_to_http_header"] = forward_to_http_header
             if security_policy_id is None and not opts.urn:
                 raise TypeError("Missing required property 'security_policy_id'")
             __props__.__dict__["security_policy_id"] = security_policy_id
-        super(AppSecMalwarePolicyActions, __self__).__init__(
-            'akamai:index/appSecMalwarePolicyActions:AppSecMalwarePolicyActions',
+        super(AppSecReputationProfileAnalysis, __self__).__init__(
+            'akamai:index/appSecReputationProfileAnalysis:AppSecReputationProfileAnalysis',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
             config_id: Optional[pulumi.Input[int]] = None,
-            malware_policy_actions: Optional[pulumi.Input[str]] = None,
-            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecMalwarePolicyActions':
+            forward_shared_ip_to_http_header_siem: Optional[pulumi.Input[bool]] = None,
+            forward_to_http_header: Optional[pulumi.Input[bool]] = None,
+            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecReputationProfileAnalysis':
         """
-        Get an existing AppSecMalwarePolicyActions resource's state with the given name, id, and optional extra
+        Get an existing AppSecReputationProfileAnalysis resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the malware policy action being modified.
-        :param pulumi.Input[str] malware_policy_actions: . Path to a JSON file containing the malware policy IDs and their respective actions. A sample JSON file can be found in the [Modify malware policy actions for a security policy](https://techdocs.akamai.com/application-security/reference/put-policy) section of the Application Security API documentation.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the malware policy whose action is being modified.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] forward_shared_ip_to_http_header_siem: Whether to add a value indicating that shared IPs are included in HTTP header and SIEM integration
+        :param pulumi.Input[bool] forward_to_http_header: Whether to add client reputation details to requests forwarded to the origin server
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _AppSecMalwarePolicyActionsState.__new__(_AppSecMalwarePolicyActionsState)
+        __props__ = _AppSecReputationProfileAnalysisState.__new__(_AppSecReputationProfileAnalysisState)
 
         __props__.__dict__["config_id"] = config_id
-        __props__.__dict__["malware_policy_actions"] = malware_policy_actions
+        __props__.__dict__["forward_shared_ip_to_http_header_siem"] = forward_shared_ip_to_http_header_siem
+        __props__.__dict__["forward_to_http_header"] = forward_to_http_header
         __props__.__dict__["security_policy_id"] = security_policy_id
-        return AppSecMalwarePolicyActions(resource_name, opts=opts, __props__=__props__)
+        return AppSecReputationProfileAnalysis(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Output[int]:
         """
-        . Unique identifier of the security configuration associated with the malware policy action being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @property
-    @pulumi.getter(name="malwarePolicyActions")
-    def malware_policy_actions(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="forwardSharedIpToHttpHeaderSiem")
+    def forward_shared_ip_to_http_header_siem(self) -> pulumi.Output[bool]:
+        """
+        Whether to add a value indicating that shared IPs are included in HTTP header and SIEM integration
+        """
+        return pulumi.get(self, "forward_shared_ip_to_http_header_siem")
+
+    @property
+    @pulumi.getter(name="forwardToHttpHeader")
+    def forward_to_http_header(self) -> pulumi.Output[bool]:
         """
-        . Path to a JSON file containing the malware policy IDs and their respective actions. A sample JSON file can be found in the [Modify malware policy actions for a security policy](https://techdocs.akamai.com/application-security/reference/put-policy) section of the Application Security API documentation.
+        Whether to add client reputation details to requests forwarded to the origin server
         """
-        return pulumi.get(self, "malware_policy_actions")
+        return pulumi.get(self, "forward_to_http_header")
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Output[str]:
         """
-        . Unique identifier of the security policy associated with the malware policy whose action is being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_malware_protection.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_rate_policy_action.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,314 +5,332 @@
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
-__all__ = ['AppSecMalwareProtectionArgs', 'AppSecMalwareProtection']
+__all__ = ['AppSecRatePolicyActionArgs', 'AppSecRatePolicyAction']
 
 @pulumi.input_type
-class AppSecMalwareProtectionArgs:
+class AppSecRatePolicyActionArgs:
     def __init__(__self__, *,
                  config_id: pulumi.Input[int],
-                 enabled: pulumi.Input[bool],
+                 ipv4_action: pulumi.Input[str],
+                 ipv6_action: pulumi.Input[str],
+                 rate_policy_id: pulumi.Input[int],
                  security_policy_id: pulumi.Input[str]):
         """
-        The set of arguments for constructing a AppSecMalwareProtection resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the malware protection settings being modified.
-        :param pulumi.Input[bool] enabled: . Set to **true** to enable malware protection; set to **false** to disable malware protection.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the malware protection settings being modified.
+        The set of arguments for constructing a AppSecRatePolicyAction resource.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] ipv4_action: Action to be taken for requests coming from an IPv4 address
+        :param pulumi.Input[str] ipv6_action: Action to be taken for requests coming from an IPv6 address
+        :param pulumi.Input[int] rate_policy_id: Unique identifier of the rate policy
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         pulumi.set(__self__, "config_id", config_id)
-        pulumi.set(__self__, "enabled", enabled)
+        pulumi.set(__self__, "ipv4_action", ipv4_action)
+        pulumi.set(__self__, "ipv6_action", ipv6_action)
+        pulumi.set(__self__, "rate_policy_id", rate_policy_id)
         pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuration associated with the malware protection settings being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "config_id", value)
 
     @property
-    @pulumi.getter
-    def enabled(self) -> pulumi.Input[bool]:
+    @pulumi.getter(name="ipv4Action")
+    def ipv4_action(self) -> pulumi.Input[str]:
         """
-        . Set to **true** to enable malware protection; set to **false** to disable malware protection.
+        Action to be taken for requests coming from an IPv4 address
         """
-        return pulumi.get(self, "enabled")
+        return pulumi.get(self, "ipv4_action")
 
-    @enabled.setter
-    def enabled(self, value: pulumi.Input[bool]):
-        pulumi.set(self, "enabled", value)
+    @ipv4_action.setter
+    def ipv4_action(self, value: pulumi.Input[str]):
+        pulumi.set(self, "ipv4_action", value)
+
+    @property
+    @pulumi.getter(name="ipv6Action")
+    def ipv6_action(self) -> pulumi.Input[str]:
+        """
+        Action to be taken for requests coming from an IPv6 address
+        """
+        return pulumi.get(self, "ipv6_action")
+
+    @ipv6_action.setter
+    def ipv6_action(self, value: pulumi.Input[str]):
+        pulumi.set(self, "ipv6_action", value)
+
+    @property
+    @pulumi.getter(name="ratePolicyId")
+    def rate_policy_id(self) -> pulumi.Input[int]:
+        """
+        Unique identifier of the rate policy
+        """
+        return pulumi.get(self, "rate_policy_id")
+
+    @rate_policy_id.setter
+    def rate_policy_id(self, value: pulumi.Input[int]):
+        pulumi.set(self, "rate_policy_id", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Input[str]:
         """
-        . Unique identifier of the security policy associated with the malware protection settings being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "security_policy_id", value)
 
 
 @pulumi.input_type
-class _AppSecMalwareProtectionState:
+class _AppSecRatePolicyActionState:
     def __init__(__self__, *,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 enabled: Optional[pulumi.Input[bool]] = None,
-                 output_text: Optional[pulumi.Input[str]] = None,
+                 ipv4_action: Optional[pulumi.Input[str]] = None,
+                 ipv6_action: Optional[pulumi.Input[str]] = None,
+                 rate_policy_id: Optional[pulumi.Input[int]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None):
         """
-        Input properties used for looking up and filtering AppSecMalwareProtection resources.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the malware protection settings being modified.
-        :param pulumi.Input[bool] enabled: . Set to **true** to enable malware protection; set to **false** to disable malware protection.
-        :param pulumi.Input[str] output_text: Text representation
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the malware protection settings being modified.
+        Input properties used for looking up and filtering AppSecRatePolicyAction resources.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] ipv4_action: Action to be taken for requests coming from an IPv4 address
+        :param pulumi.Input[str] ipv6_action: Action to be taken for requests coming from an IPv6 address
+        :param pulumi.Input[int] rate_policy_id: Unique identifier of the rate policy
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
-        if enabled is not None:
-            pulumi.set(__self__, "enabled", enabled)
-        if output_text is not None:
-            pulumi.set(__self__, "output_text", output_text)
+        if ipv4_action is not None:
+            pulumi.set(__self__, "ipv4_action", ipv4_action)
+        if ipv6_action is not None:
+            pulumi.set(__self__, "ipv6_action", ipv6_action)
+        if rate_policy_id is not None:
+            pulumi.set(__self__, "rate_policy_id", rate_policy_id)
         if security_policy_id is not None:
             pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security configuration associated with the malware protection settings being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "config_id", value)
 
     @property
-    @pulumi.getter
-    def enabled(self) -> Optional[pulumi.Input[bool]]:
+    @pulumi.getter(name="ipv4Action")
+    def ipv4_action(self) -> Optional[pulumi.Input[str]]:
         """
-        . Set to **true** to enable malware protection; set to **false** to disable malware protection.
+        Action to be taken for requests coming from an IPv4 address
         """
-        return pulumi.get(self, "enabled")
+        return pulumi.get(self, "ipv4_action")
 
-    @enabled.setter
-    def enabled(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "enabled", value)
+    @ipv4_action.setter
+    def ipv4_action(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "ipv4_action", value)
 
     @property
-    @pulumi.getter(name="outputText")
-    def output_text(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="ipv6Action")
+    def ipv6_action(self) -> Optional[pulumi.Input[str]]:
         """
-        Text representation
+        Action to be taken for requests coming from an IPv6 address
         """
-        return pulumi.get(self, "output_text")
+        return pulumi.get(self, "ipv6_action")
 
-    @output_text.setter
-    def output_text(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "output_text", value)
+    @ipv6_action.setter
+    def ipv6_action(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "ipv6_action", value)
+
+    @property
+    @pulumi.getter(name="ratePolicyId")
+    def rate_policy_id(self) -> Optional[pulumi.Input[int]]:
+        """
+        Unique identifier of the rate policy
+        """
+        return pulumi.get(self, "rate_policy_id")
+
+    @rate_policy_id.setter
+    def rate_policy_id(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "rate_policy_id", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the security policy associated with the malware protection settings being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "security_policy_id", value)
 
 
-class AppSecMalwareProtection(pulumi.CustomResource):
+class AppSecRatePolicyAction(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 enabled: Optional[pulumi.Input[bool]] = None,
+                 ipv4_action: Optional[pulumi.Input[str]] = None,
+                 ipv6_action: Optional[pulumi.Input[str]] = None,
+                 rate_policy_id: Optional[pulumi.Input[int]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Security policy
-
-        Enables or disables malware protection for a security policy.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/put-policy-protections)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        protection = akamai.AppSecMalwareProtection("protection",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            enabled=True)
-        ```
-        ## Output Options
-
-        The following option can be used to determine the information returned, and how that returned information is formatted:
-
-        - `output_text`. Tabular report showing the current protection settings for the security policy.
-
+        Create a AppSecRatePolicyAction resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the malware protection settings being modified.
-        :param pulumi.Input[bool] enabled: . Set to **true** to enable malware protection; set to **false** to disable malware protection.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the malware protection settings being modified.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] ipv4_action: Action to be taken for requests coming from an IPv4 address
+        :param pulumi.Input[str] ipv6_action: Action to be taken for requests coming from an IPv6 address
+        :param pulumi.Input[int] rate_policy_id: Unique identifier of the rate policy
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: AppSecMalwareProtectionArgs,
+                 args: AppSecRatePolicyActionArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Security policy
-
-        Enables or disables malware protection for a security policy.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/put-policy-protections)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        protection = akamai.AppSecMalwareProtection("protection",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            enabled=True)
-        ```
-        ## Output Options
-
-        The following option can be used to determine the information returned, and how that returned information is formatted:
-
-        - `output_text`. Tabular report showing the current protection settings for the security policy.
-
+        Create a AppSecRatePolicyAction resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param AppSecMalwareProtectionArgs args: The arguments to use to populate this resource's properties.
+        :param AppSecRatePolicyActionArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(AppSecMalwareProtectionArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(AppSecRatePolicyActionArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 enabled: Optional[pulumi.Input[bool]] = None,
+                 ipv4_action: Optional[pulumi.Input[str]] = None,
+                 ipv6_action: Optional[pulumi.Input[str]] = None,
+                 rate_policy_id: Optional[pulumi.Input[int]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = AppSecMalwareProtectionArgs.__new__(AppSecMalwareProtectionArgs)
+            __props__ = AppSecRatePolicyActionArgs.__new__(AppSecRatePolicyActionArgs)
 
             if config_id is None and not opts.urn:
                 raise TypeError("Missing required property 'config_id'")
             __props__.__dict__["config_id"] = config_id
-            if enabled is None and not opts.urn:
-                raise TypeError("Missing required property 'enabled'")
-            __props__.__dict__["enabled"] = enabled
+            if ipv4_action is None and not opts.urn:
+                raise TypeError("Missing required property 'ipv4_action'")
+            __props__.__dict__["ipv4_action"] = ipv4_action
+            if ipv6_action is None and not opts.urn:
+                raise TypeError("Missing required property 'ipv6_action'")
+            __props__.__dict__["ipv6_action"] = ipv6_action
+            if rate_policy_id is None and not opts.urn:
+                raise TypeError("Missing required property 'rate_policy_id'")
+            __props__.__dict__["rate_policy_id"] = rate_policy_id
             if security_policy_id is None and not opts.urn:
                 raise TypeError("Missing required property 'security_policy_id'")
             __props__.__dict__["security_policy_id"] = security_policy_id
-            __props__.__dict__["output_text"] = None
-        super(AppSecMalwareProtection, __self__).__init__(
-            'akamai:index/appSecMalwareProtection:AppSecMalwareProtection',
+        super(AppSecRatePolicyAction, __self__).__init__(
+            'akamai:index/appSecRatePolicyAction:AppSecRatePolicyAction',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
             config_id: Optional[pulumi.Input[int]] = None,
-            enabled: Optional[pulumi.Input[bool]] = None,
-            output_text: Optional[pulumi.Input[str]] = None,
-            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecMalwareProtection':
+            ipv4_action: Optional[pulumi.Input[str]] = None,
+            ipv6_action: Optional[pulumi.Input[str]] = None,
+            rate_policy_id: Optional[pulumi.Input[int]] = None,
+            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecRatePolicyAction':
         """
-        Get an existing AppSecMalwareProtection resource's state with the given name, id, and optional extra
+        Get an existing AppSecRatePolicyAction resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the malware protection settings being modified.
-        :param pulumi.Input[bool] enabled: . Set to **true** to enable malware protection; set to **false** to disable malware protection.
-        :param pulumi.Input[str] output_text: Text representation
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the malware protection settings being modified.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] ipv4_action: Action to be taken for requests coming from an IPv4 address
+        :param pulumi.Input[str] ipv6_action: Action to be taken for requests coming from an IPv6 address
+        :param pulumi.Input[int] rate_policy_id: Unique identifier of the rate policy
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _AppSecMalwareProtectionState.__new__(_AppSecMalwareProtectionState)
+        __props__ = _AppSecRatePolicyActionState.__new__(_AppSecRatePolicyActionState)
 
         __props__.__dict__["config_id"] = config_id
-        __props__.__dict__["enabled"] = enabled
-        __props__.__dict__["output_text"] = output_text
+        __props__.__dict__["ipv4_action"] = ipv4_action
+        __props__.__dict__["ipv6_action"] = ipv6_action
+        __props__.__dict__["rate_policy_id"] = rate_policy_id
         __props__.__dict__["security_policy_id"] = security_policy_id
-        return AppSecMalwareProtection(resource_name, opts=opts, __props__=__props__)
+        return AppSecRatePolicyAction(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Output[int]:
         """
-        . Unique identifier of the security configuration associated with the malware protection settings being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @property
-    @pulumi.getter
-    def enabled(self) -> pulumi.Output[bool]:
+    @pulumi.getter(name="ipv4Action")
+    def ipv4_action(self) -> pulumi.Output[str]:
+        """
+        Action to be taken for requests coming from an IPv4 address
+        """
+        return pulumi.get(self, "ipv4_action")
+
+    @property
+    @pulumi.getter(name="ipv6Action")
+    def ipv6_action(self) -> pulumi.Output[str]:
         """
-        . Set to **true** to enable malware protection; set to **false** to disable malware protection.
+        Action to be taken for requests coming from an IPv6 address
         """
-        return pulumi.get(self, "enabled")
+        return pulumi.get(self, "ipv6_action")
 
     @property
-    @pulumi.getter(name="outputText")
-    def output_text(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="ratePolicyId")
+    def rate_policy_id(self) -> pulumi.Output[int]:
         """
-        Text representation
+        Unique identifier of the rate policy
         """
-        return pulumi.get(self, "output_text")
+        return pulumi.get(self, "rate_policy_id")
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Output[str]:
         """
-        . Unique identifier of the security policy associated with the malware protection settings being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_match_target.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_match_target.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,37 +14,37 @@
 @pulumi.input_type
 class AppSecMatchTargetArgs:
     def __init__(__self__, *,
                  config_id: pulumi.Input[int],
                  match_target: pulumi.Input[str]):
         """
         The set of arguments for constructing a AppSecMatchTarget resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the match target being modified.
-        :param pulumi.Input[str] match_target: . Path to a JSON file containing one or more match target definitions.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] match_target: JSON-formatted definition of the match target
         """
         pulumi.set(__self__, "config_id", config_id)
         pulumi.set(__self__, "match_target", match_target)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuration associated with the match target being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter(name="matchTarget")
     def match_target(self) -> pulumi.Input[str]:
         """
-        . Path to a JSON file containing one or more match target definitions.
+        JSON-formatted definition of the match target
         """
         return pulumi.get(self, "match_target")
 
     @match_target.setter
     def match_target(self, value: pulumi.Input[str]):
         pulumi.set(self, "match_target", value)
 
@@ -53,42 +53,42 @@
 class _AppSecMatchTargetState:
     def __init__(__self__, *,
                  config_id: Optional[pulumi.Input[int]] = None,
                  match_target: Optional[pulumi.Input[str]] = None,
                  match_target_id: Optional[pulumi.Input[int]] = None):
         """
         Input properties used for looking up and filtering AppSecMatchTarget resources.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the match target being modified.
-        :param pulumi.Input[str] match_target: . Path to a JSON file containing one or more match target definitions.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] match_target: JSON-formatted definition of the match target
         :param pulumi.Input[int] match_target_id: Unique identifier of the match target
         """
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
         if match_target is not None:
             pulumi.set(__self__, "match_target", match_target)
         if match_target_id is not None:
             pulumi.set(__self__, "match_target_id", match_target_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security configuration associated with the match target being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter(name="matchTarget")
     def match_target(self) -> Optional[pulumi.Input[str]]:
         """
-        . Path to a JSON file containing one or more match target definitions.
+        JSON-formatted definition of the match target
         """
         return pulumi.get(self, "match_target")
 
     @match_target.setter
     def match_target(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "match_target", value)
 
@@ -110,76 +110,28 @@
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
                  match_target: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Security configuration
-
-        Creates a match target associated with a security configuration. Match targets determine which security policy should apply to an API, hostname or path.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/match-targets](https://techdocs.akamai.com/application-security/reference/post-match-targets)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        match_target = akamai.AppSecMatchTarget("matchTarget",
-            config_id=configuration.config_id,
-            match_target=(lambda path: open(path).read())(f"{path['module']}/match_targets.json"))
-        ```
-        ## Output Options
-
-        In addition to the arguments above, the following attribute is exported:
-
-        - `match_target_id`. ID of the match target.
-
+        Create a AppSecMatchTarget resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the match target being modified.
-        :param pulumi.Input[str] match_target: . Path to a JSON file containing one or more match target definitions.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] match_target: JSON-formatted definition of the match target
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: AppSecMatchTargetArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Security configuration
-
-        Creates a match target associated with a security configuration. Match targets determine which security policy should apply to an API, hostname or path.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/match-targets](https://techdocs.akamai.com/application-security/reference/post-match-targets)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        match_target = akamai.AppSecMatchTarget("matchTarget",
-            config_id=configuration.config_id,
-            match_target=(lambda path: open(path).read())(f"{path['module']}/match_targets.json"))
-        ```
-        ## Output Options
-
-        In addition to the arguments above, the following attribute is exported:
-
-        - `match_target_id`. ID of the match target.
-
+        Create a AppSecMatchTarget resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param AppSecMatchTargetArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(AppSecMatchTargetArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -225,16 +177,16 @@
         """
         Get an existing AppSecMatchTarget resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the match target being modified.
-        :param pulumi.Input[str] match_target: . Path to a JSON file containing one or more match target definitions.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] match_target: JSON-formatted definition of the match target
         :param pulumi.Input[int] match_target_id: Unique identifier of the match target
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _AppSecMatchTargetState.__new__(_AppSecMatchTargetState)
 
         __props__.__dict__["config_id"] = config_id
@@ -242,23 +194,23 @@
         __props__.__dict__["match_target_id"] = match_target_id
         return AppSecMatchTarget(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Output[int]:
         """
-        . Unique identifier of the security configuration associated with the match target being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @property
     @pulumi.getter(name="matchTarget")
     def match_target(self) -> pulumi.Output[str]:
         """
-        . Path to a JSON file containing one or more match target definitions.
+        JSON-formatted definition of the match target
         """
         return pulumi.get(self, "match_target")
 
     @property
     @pulumi.getter(name="matchTargetId")
     def match_target_id(self) -> pulumi.Output[int]:
         """
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_penalty_box.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_eval_penalty_box.py`

 * *Files 26% similar despite different names*

```diff
@@ -5,256 +5,190 @@
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
-__all__ = ['AppSecPenaltyBoxArgs', 'AppSecPenaltyBox']
+__all__ = ['AppSecEvalPenaltyBoxArgs', 'AppSecEvalPenaltyBox']
 
 @pulumi.input_type
-class AppSecPenaltyBoxArgs:
+class AppSecEvalPenaltyBoxArgs:
     def __init__(__self__, *,
                  config_id: pulumi.Input[int],
                  penalty_box_action: pulumi.Input[str],
                  penalty_box_protection: pulumi.Input[bool],
                  security_policy_id: pulumi.Input[str]):
         """
-        The set of arguments for constructing a AppSecPenaltyBox resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the penalty box settings being modified.
-        :param pulumi.Input[str] penalty_box_action: . Action taken any time penalty box protection is triggered. Allowed values are:
-               - **alert**. Record the event.
-               - **deny**. Block the request.
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action.
-        :param pulumi.Input[bool] penalty_box_protection: . Set to **true** to enable penalty box protection; set to **false** to disable penalty box protection.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the penalty box settings being modified.
+        The set of arguments for constructing a AppSecEvalPenaltyBox resource.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] penalty_box_action: Action applied to requests from clients in the penalty box
+        :param pulumi.Input[bool] penalty_box_protection: Whether to enable the penalty box for the specified security policy
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         pulumi.set(__self__, "config_id", config_id)
         pulumi.set(__self__, "penalty_box_action", penalty_box_action)
         pulumi.set(__self__, "penalty_box_protection", penalty_box_protection)
         pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuration associated with the penalty box settings being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter(name="penaltyBoxAction")
     def penalty_box_action(self) -> pulumi.Input[str]:
         """
-        . Action taken any time penalty box protection is triggered. Allowed values are:
-        - **alert**. Record the event.
-        - **deny**. Block the request.
-        - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-        - **none**. Take no action.
+        Action applied to requests from clients in the penalty box
         """
         return pulumi.get(self, "penalty_box_action")
 
     @penalty_box_action.setter
     def penalty_box_action(self, value: pulumi.Input[str]):
         pulumi.set(self, "penalty_box_action", value)
 
     @property
     @pulumi.getter(name="penaltyBoxProtection")
     def penalty_box_protection(self) -> pulumi.Input[bool]:
         """
-        . Set to **true** to enable penalty box protection; set to **false** to disable penalty box protection.
+        Whether to enable the penalty box for the specified security policy
         """
         return pulumi.get(self, "penalty_box_protection")
 
     @penalty_box_protection.setter
     def penalty_box_protection(self, value: pulumi.Input[bool]):
         pulumi.set(self, "penalty_box_protection", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Input[str]:
         """
-        . Unique identifier of the security policy associated with the penalty box settings being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "security_policy_id", value)
 
 
 @pulumi.input_type
-class _AppSecPenaltyBoxState:
+class _AppSecEvalPenaltyBoxState:
     def __init__(__self__, *,
                  config_id: Optional[pulumi.Input[int]] = None,
                  penalty_box_action: Optional[pulumi.Input[str]] = None,
                  penalty_box_protection: Optional[pulumi.Input[bool]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None):
         """
-        Input properties used for looking up and filtering AppSecPenaltyBox resources.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the penalty box settings being modified.
-        :param pulumi.Input[str] penalty_box_action: . Action taken any time penalty box protection is triggered. Allowed values are:
-               - **alert**. Record the event.
-               - **deny**. Block the request.
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action.
-        :param pulumi.Input[bool] penalty_box_protection: . Set to **true** to enable penalty box protection; set to **false** to disable penalty box protection.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the penalty box settings being modified.
+        Input properties used for looking up and filtering AppSecEvalPenaltyBox resources.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] penalty_box_action: Action applied to requests from clients in the penalty box
+        :param pulumi.Input[bool] penalty_box_protection: Whether to enable the penalty box for the specified security policy
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
         if penalty_box_action is not None:
             pulumi.set(__self__, "penalty_box_action", penalty_box_action)
         if penalty_box_protection is not None:
             pulumi.set(__self__, "penalty_box_protection", penalty_box_protection)
         if security_policy_id is not None:
             pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security configuration associated with the penalty box settings being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter(name="penaltyBoxAction")
     def penalty_box_action(self) -> Optional[pulumi.Input[str]]:
         """
-        . Action taken any time penalty box protection is triggered. Allowed values are:
-        - **alert**. Record the event.
-        - **deny**. Block the request.
-        - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-        - **none**. Take no action.
+        Action applied to requests from clients in the penalty box
         """
         return pulumi.get(self, "penalty_box_action")
 
     @penalty_box_action.setter
     def penalty_box_action(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "penalty_box_action", value)
 
     @property
     @pulumi.getter(name="penaltyBoxProtection")
     def penalty_box_protection(self) -> Optional[pulumi.Input[bool]]:
         """
-        . Set to **true** to enable penalty box protection; set to **false** to disable penalty box protection.
+        Whether to enable the penalty box for the specified security policy
         """
         return pulumi.get(self, "penalty_box_protection")
 
     @penalty_box_protection.setter
     def penalty_box_protection(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "penalty_box_protection", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the security policy associated with the penalty box settings being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "security_policy_id", value)
 
 
-class AppSecPenaltyBox(pulumi.CustomResource):
+class AppSecEvalPenaltyBox(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
                  penalty_box_action: Optional[pulumi.Input[str]] = None,
                  penalty_box_protection: Optional[pulumi.Input[bool]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Security policy
-
-        Modifies the penalty box settings for a security policy.
-        When the penalty box is enabled for a policy, clients that trigger a WAF Deny action are placed in the penalty box.
-        There, the action you select for penalty box (either Alert or Deny ) continues to apply to any requests from that client for the next 10 minutes.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/match-targets/sequence](https://techdocs.akamai.com/application-security/reference/put-policy-penalty-box)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        penalty_box = akamai.AppSecPenaltyBox("penaltyBox",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            penalty_box_protection=True,
-            penalty_box_action="deny")
-        ```
-
+        Create a AppSecEvalPenaltyBox resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the penalty box settings being modified.
-        :param pulumi.Input[str] penalty_box_action: . Action taken any time penalty box protection is triggered. Allowed values are:
-               - **alert**. Record the event.
-               - **deny**. Block the request.
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action.
-        :param pulumi.Input[bool] penalty_box_protection: . Set to **true** to enable penalty box protection; set to **false** to disable penalty box protection.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the penalty box settings being modified.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] penalty_box_action: Action applied to requests from clients in the penalty box
+        :param pulumi.Input[bool] penalty_box_protection: Whether to enable the penalty box for the specified security policy
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: AppSecPenaltyBoxArgs,
+                 args: AppSecEvalPenaltyBoxArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Security policy
-
-        Modifies the penalty box settings for a security policy.
-        When the penalty box is enabled for a policy, clients that trigger a WAF Deny action are placed in the penalty box.
-        There, the action you select for penalty box (either Alert or Deny ) continues to apply to any requests from that client for the next 10 minutes.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/match-targets/sequence](https://techdocs.akamai.com/application-security/reference/put-policy-penalty-box)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        penalty_box = akamai.AppSecPenaltyBox("penaltyBox",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            penalty_box_protection=True,
-            penalty_box_action="deny")
-        ```
-
+        Create a AppSecEvalPenaltyBox resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param AppSecPenaltyBoxArgs args: The arguments to use to populate this resource's properties.
+        :param AppSecEvalPenaltyBoxArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(AppSecPenaltyBoxArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(AppSecEvalPenaltyBoxArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
@@ -266,97 +200,89 @@
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = AppSecPenaltyBoxArgs.__new__(AppSecPenaltyBoxArgs)
+            __props__ = AppSecEvalPenaltyBoxArgs.__new__(AppSecEvalPenaltyBoxArgs)
 
             if config_id is None and not opts.urn:
                 raise TypeError("Missing required property 'config_id'")
             __props__.__dict__["config_id"] = config_id
             if penalty_box_action is None and not opts.urn:
                 raise TypeError("Missing required property 'penalty_box_action'")
             __props__.__dict__["penalty_box_action"] = penalty_box_action
             if penalty_box_protection is None and not opts.urn:
                 raise TypeError("Missing required property 'penalty_box_protection'")
             __props__.__dict__["penalty_box_protection"] = penalty_box_protection
             if security_policy_id is None and not opts.urn:
                 raise TypeError("Missing required property 'security_policy_id'")
             __props__.__dict__["security_policy_id"] = security_policy_id
-        super(AppSecPenaltyBox, __self__).__init__(
-            'akamai:index/appSecPenaltyBox:AppSecPenaltyBox',
+        super(AppSecEvalPenaltyBox, __self__).__init__(
+            'akamai:index/appSecEvalPenaltyBox:AppSecEvalPenaltyBox',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
             config_id: Optional[pulumi.Input[int]] = None,
             penalty_box_action: Optional[pulumi.Input[str]] = None,
             penalty_box_protection: Optional[pulumi.Input[bool]] = None,
-            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecPenaltyBox':
+            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecEvalPenaltyBox':
         """
-        Get an existing AppSecPenaltyBox resource's state with the given name, id, and optional extra
+        Get an existing AppSecEvalPenaltyBox resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the penalty box settings being modified.
-        :param pulumi.Input[str] penalty_box_action: . Action taken any time penalty box protection is triggered. Allowed values are:
-               - **alert**. Record the event.
-               - **deny**. Block the request.
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action.
-        :param pulumi.Input[bool] penalty_box_protection: . Set to **true** to enable penalty box protection; set to **false** to disable penalty box protection.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the penalty box settings being modified.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] penalty_box_action: Action applied to requests from clients in the penalty box
+        :param pulumi.Input[bool] penalty_box_protection: Whether to enable the penalty box for the specified security policy
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _AppSecPenaltyBoxState.__new__(_AppSecPenaltyBoxState)
+        __props__ = _AppSecEvalPenaltyBoxState.__new__(_AppSecEvalPenaltyBoxState)
 
         __props__.__dict__["config_id"] = config_id
         __props__.__dict__["penalty_box_action"] = penalty_box_action
         __props__.__dict__["penalty_box_protection"] = penalty_box_protection
         __props__.__dict__["security_policy_id"] = security_policy_id
-        return AppSecPenaltyBox(resource_name, opts=opts, __props__=__props__)
+        return AppSecEvalPenaltyBox(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Output[int]:
         """
-        . Unique identifier of the security configuration associated with the penalty box settings being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @property
     @pulumi.getter(name="penaltyBoxAction")
     def penalty_box_action(self) -> pulumi.Output[str]:
         """
-        . Action taken any time penalty box protection is triggered. Allowed values are:
-        - **alert**. Record the event.
-        - **deny**. Block the request.
-        - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-        - **none**. Take no action.
+        Action applied to requests from clients in the penalty box
         """
         return pulumi.get(self, "penalty_box_action")
 
     @property
     @pulumi.getter(name="penaltyBoxProtection")
     def penalty_box_protection(self) -> pulumi.Output[bool]:
         """
-        . Set to **true** to enable penalty box protection; set to **false** to disable penalty box protection.
+        Whether to enable the penalty box for the specified security policy
         """
         return pulumi.get(self, "penalty_box_protection")
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Output[str]:
         """
-        . Unique identifier of the security policy associated with the penalty box settings being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_rate_policy.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_rate_policy.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,37 +14,37 @@
 @pulumi.input_type
 class AppSecRatePolicyArgs:
     def __init__(__self__, *,
                  config_id: pulumi.Input[int],
                  rate_policy: pulumi.Input[str]):
         """
         The set of arguments for constructing a AppSecRatePolicy resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the rate policy being modified.
-        :param pulumi.Input[str] rate_policy: . Path to a JSON file containing a rate policy definition.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] rate_policy: JSON-formatted definition of the rate policy
         """
         pulumi.set(__self__, "config_id", config_id)
         pulumi.set(__self__, "rate_policy", rate_policy)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuration associated with the rate policy being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter(name="ratePolicy")
     def rate_policy(self) -> pulumi.Input[str]:
         """
-        . Path to a JSON file containing a rate policy definition.
+        JSON-formatted definition of the rate policy
         """
         return pulumi.get(self, "rate_policy")
 
     @rate_policy.setter
     def rate_policy(self, value: pulumi.Input[str]):
         pulumi.set(self, "rate_policy", value)
 
@@ -53,42 +53,42 @@
 class _AppSecRatePolicyState:
     def __init__(__self__, *,
                  config_id: Optional[pulumi.Input[int]] = None,
                  rate_policy: Optional[pulumi.Input[str]] = None,
                  rate_policy_id: Optional[pulumi.Input[int]] = None):
         """
         Input properties used for looking up and filtering AppSecRatePolicy resources.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the rate policy being modified.
-        :param pulumi.Input[str] rate_policy: . Path to a JSON file containing a rate policy definition.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] rate_policy: JSON-formatted definition of the rate policy
         :param pulumi.Input[int] rate_policy_id: Unique identifier of the rate policy
         """
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
         if rate_policy is not None:
             pulumi.set(__self__, "rate_policy", rate_policy)
         if rate_policy_id is not None:
             pulumi.set(__self__, "rate_policy_id", rate_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security configuration associated with the rate policy being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter(name="ratePolicy")
     def rate_policy(self) -> Optional[pulumi.Input[str]]:
         """
-        . Path to a JSON file containing a rate policy definition.
+        JSON-formatted definition of the rate policy
         """
         return pulumi.get(self, "rate_policy")
 
     @rate_policy.setter
     def rate_policy(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "rate_policy", value)
 
@@ -110,80 +110,28 @@
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
                  rate_policy: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Security configuration; rate policy
-
-        Creates, modifies, or deletes rate policies. Rate polices help you monitor and moderate the number and rate of all the requests you receive.
-        In turn, this helps you prevent your website from being overwhelmed by a dramatic and unexpected surge in traffic.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/rate-policies](https://techdocs.akamai.com/application-security/reference/post-rate-policies)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        rate_policy = akamai.AppSecRatePolicy("ratePolicy",
-            config_id=configuration.config_id,
-            rate_policy=(lambda path: open(path).read())(f"{path['module']}/rate_policy.json"))
-        pulumi.export("ratePolicyId", rate_policy.rate_policy_id)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `rate_policy_id`. ID of the modified or newly-created rate policy.
-
+        Create a AppSecRatePolicy resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the rate policy being modified.
-        :param pulumi.Input[str] rate_policy: . Path to a JSON file containing a rate policy definition.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] rate_policy: JSON-formatted definition of the rate policy
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: AppSecRatePolicyArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Security configuration; rate policy
-
-        Creates, modifies, or deletes rate policies. Rate polices help you monitor and moderate the number and rate of all the requests you receive.
-        In turn, this helps you prevent your website from being overwhelmed by a dramatic and unexpected surge in traffic.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/rate-policies](https://techdocs.akamai.com/application-security/reference/post-rate-policies)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        rate_policy = akamai.AppSecRatePolicy("ratePolicy",
-            config_id=configuration.config_id,
-            rate_policy=(lambda path: open(path).read())(f"{path['module']}/rate_policy.json"))
-        pulumi.export("ratePolicyId", rate_policy.rate_policy_id)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `rate_policy_id`. ID of the modified or newly-created rate policy.
-
+        Create a AppSecRatePolicy resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param AppSecRatePolicyArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(AppSecRatePolicyArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -229,16 +177,16 @@
         """
         Get an existing AppSecRatePolicy resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the rate policy being modified.
-        :param pulumi.Input[str] rate_policy: . Path to a JSON file containing a rate policy definition.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] rate_policy: JSON-formatted definition of the rate policy
         :param pulumi.Input[int] rate_policy_id: Unique identifier of the rate policy
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _AppSecRatePolicyState.__new__(_AppSecRatePolicyState)
 
         __props__.__dict__["config_id"] = config_id
@@ -246,23 +194,23 @@
         __props__.__dict__["rate_policy_id"] = rate_policy_id
         return AppSecRatePolicy(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Output[int]:
         """
-        . Unique identifier of the security configuration associated with the rate policy being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @property
     @pulumi.getter(name="ratePolicy")
     def rate_policy(self) -> pulumi.Output[str]:
         """
-        . Path to a JSON file containing a rate policy definition.
+        JSON-formatted definition of the rate policy
         """
         return pulumi.get(self, "rate_policy")
 
     @property
     @pulumi.getter(name="ratePolicyId")
     def rate_policy_id(self) -> pulumi.Output[int]:
         """
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_rate_protection.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_eval_group.py`

 * *Files 18% similar despite different names*

```diff
@@ -5,314 +5,331 @@
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
-__all__ = ['AppSecRateProtectionArgs', 'AppSecRateProtection']
+__all__ = ['AppSecEvalGroupArgs', 'AppSecEvalGroup']
 
 @pulumi.input_type
-class AppSecRateProtectionArgs:
+class AppSecEvalGroupArgs:
     def __init__(__self__, *,
+                 attack_group: pulumi.Input[str],
+                 attack_group_action: pulumi.Input[str],
                  config_id: pulumi.Input[int],
-                 enabled: pulumi.Input[bool],
-                 security_policy_id: pulumi.Input[str]):
+                 security_policy_id: pulumi.Input[str],
+                 condition_exception: Optional[pulumi.Input[str]] = None):
         """
-        The set of arguments for constructing a AppSecRateProtection resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the rate protection settings being modified.
-        :param pulumi.Input[bool] enabled: . Set to **true** to enable rate protection; set to **false** to disable rate protection.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the rate protection settings being modified.
+        The set of arguments for constructing a AppSecEvalGroup resource.
+        :param pulumi.Input[str] attack_group: Unique identifier of the evaluation attack group being modified
+        :param pulumi.Input[str] attack_group_action: Action to be taken when the attack group is triggered
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
+        :param pulumi.Input[str] condition_exception: JSON-formatted condition and exception information for the evaluation attack group
         """
+        pulumi.set(__self__, "attack_group", attack_group)
+        pulumi.set(__self__, "attack_group_action", attack_group_action)
         pulumi.set(__self__, "config_id", config_id)
-        pulumi.set(__self__, "enabled", enabled)
         pulumi.set(__self__, "security_policy_id", security_policy_id)
+        if condition_exception is not None:
+            pulumi.set(__self__, "condition_exception", condition_exception)
+
+    @property
+    @pulumi.getter(name="attackGroup")
+    def attack_group(self) -> pulumi.Input[str]:
+        """
+        Unique identifier of the evaluation attack group being modified
+        """
+        return pulumi.get(self, "attack_group")
+
+    @attack_group.setter
+    def attack_group(self, value: pulumi.Input[str]):
+        pulumi.set(self, "attack_group", value)
+
+    @property
+    @pulumi.getter(name="attackGroupAction")
+    def attack_group_action(self) -> pulumi.Input[str]:
+        """
+        Action to be taken when the attack group is triggered
+        """
+        return pulumi.get(self, "attack_group_action")
+
+    @attack_group_action.setter
+    def attack_group_action(self, value: pulumi.Input[str]):
+        pulumi.set(self, "attack_group_action", value)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuration associated with the rate protection settings being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "config_id", value)
 
     @property
-    @pulumi.getter
-    def enabled(self) -> pulumi.Input[bool]:
-        """
-        . Set to **true** to enable rate protection; set to **false** to disable rate protection.
-        """
-        return pulumi.get(self, "enabled")
-
-    @enabled.setter
-    def enabled(self, value: pulumi.Input[bool]):
-        pulumi.set(self, "enabled", value)
-
-    @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Input[str]:
         """
-        . Unique identifier of the security policy associated with the rate protection settings being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "security_policy_id", value)
 
+    @property
+    @pulumi.getter(name="conditionException")
+    def condition_exception(self) -> Optional[pulumi.Input[str]]:
+        """
+        JSON-formatted condition and exception information for the evaluation attack group
+        """
+        return pulumi.get(self, "condition_exception")
+
+    @condition_exception.setter
+    def condition_exception(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "condition_exception", value)
+
 
 @pulumi.input_type
-class _AppSecRateProtectionState:
+class _AppSecEvalGroupState:
     def __init__(__self__, *,
+                 attack_group: Optional[pulumi.Input[str]] = None,
+                 attack_group_action: Optional[pulumi.Input[str]] = None,
+                 condition_exception: Optional[pulumi.Input[str]] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 enabled: Optional[pulumi.Input[bool]] = None,
-                 output_text: Optional[pulumi.Input[str]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None):
         """
-        Input properties used for looking up and filtering AppSecRateProtection resources.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the rate protection settings being modified.
-        :param pulumi.Input[bool] enabled: . Set to **true** to enable rate protection; set to **false** to disable rate protection.
-        :param pulumi.Input[str] output_text: Text representation
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the rate protection settings being modified.
-        """
+        Input properties used for looking up and filtering AppSecEvalGroup resources.
+        :param pulumi.Input[str] attack_group: Unique identifier of the evaluation attack group being modified
+        :param pulumi.Input[str] attack_group_action: Action to be taken when the attack group is triggered
+        :param pulumi.Input[str] condition_exception: JSON-formatted condition and exception information for the evaluation attack group
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
+        """
+        if attack_group is not None:
+            pulumi.set(__self__, "attack_group", attack_group)
+        if attack_group_action is not None:
+            pulumi.set(__self__, "attack_group_action", attack_group_action)
+        if condition_exception is not None:
+            pulumi.set(__self__, "condition_exception", condition_exception)
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
-        if enabled is not None:
-            pulumi.set(__self__, "enabled", enabled)
-        if output_text is not None:
-            pulumi.set(__self__, "output_text", output_text)
         if security_policy_id is not None:
             pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
-    @pulumi.getter(name="configId")
-    def config_id(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="attackGroup")
+    def attack_group(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the security configuration associated with the rate protection settings being modified.
+        Unique identifier of the evaluation attack group being modified
         """
-        return pulumi.get(self, "config_id")
+        return pulumi.get(self, "attack_group")
 
-    @config_id.setter
-    def config_id(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "config_id", value)
+    @attack_group.setter
+    def attack_group(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "attack_group", value)
+
+    @property
+    @pulumi.getter(name="attackGroupAction")
+    def attack_group_action(self) -> Optional[pulumi.Input[str]]:
+        """
+        Action to be taken when the attack group is triggered
+        """
+        return pulumi.get(self, "attack_group_action")
+
+    @attack_group_action.setter
+    def attack_group_action(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "attack_group_action", value)
 
     @property
-    @pulumi.getter
-    def enabled(self) -> Optional[pulumi.Input[bool]]:
+    @pulumi.getter(name="conditionException")
+    def condition_exception(self) -> Optional[pulumi.Input[str]]:
         """
-        . Set to **true** to enable rate protection; set to **false** to disable rate protection.
+        JSON-formatted condition and exception information for the evaluation attack group
         """
-        return pulumi.get(self, "enabled")
+        return pulumi.get(self, "condition_exception")
 
-    @enabled.setter
-    def enabled(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "enabled", value)
+    @condition_exception.setter
+    def condition_exception(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "condition_exception", value)
 
     @property
-    @pulumi.getter(name="outputText")
-    def output_text(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="configId")
+    def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        Text representation
+        Unique identifier of the security configuration
         """
-        return pulumi.get(self, "output_text")
+        return pulumi.get(self, "config_id")
 
-    @output_text.setter
-    def output_text(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "output_text", value)
+    @config_id.setter
+    def config_id(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the security policy associated with the rate protection settings being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "security_policy_id", value)
 
 
-class AppSecRateProtection(pulumi.CustomResource):
+class AppSecEvalGroup(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
+                 attack_group: Optional[pulumi.Input[str]] = None,
+                 attack_group_action: Optional[pulumi.Input[str]] = None,
+                 condition_exception: Optional[pulumi.Input[str]] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 enabled: Optional[pulumi.Input[bool]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Security policy
-
-        Enables or disables rate protection for a security policy.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/put-policy-protections)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        protection = akamai.AppSecRateProtection("protection",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            enabled=True)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `output_text`. Tabular report showing the current protection settings.
-
+        Create a AppSecEvalGroup resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the rate protection settings being modified.
-        :param pulumi.Input[bool] enabled: . Set to **true** to enable rate protection; set to **false** to disable rate protection.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the rate protection settings being modified.
+        :param pulumi.Input[str] attack_group: Unique identifier of the evaluation attack group being modified
+        :param pulumi.Input[str] attack_group_action: Action to be taken when the attack group is triggered
+        :param pulumi.Input[str] condition_exception: JSON-formatted condition and exception information for the evaluation attack group
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: AppSecRateProtectionArgs,
+                 args: AppSecEvalGroupArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Security policy
-
-        Enables or disables rate protection for a security policy.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/put-policy-protections)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        protection = akamai.AppSecRateProtection("protection",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            enabled=True)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `output_text`. Tabular report showing the current protection settings.
-
+        Create a AppSecEvalGroup resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param AppSecRateProtectionArgs args: The arguments to use to populate this resource's properties.
+        :param AppSecEvalGroupArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(AppSecRateProtectionArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(AppSecEvalGroupArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
+                 attack_group: Optional[pulumi.Input[str]] = None,
+                 attack_group_action: Optional[pulumi.Input[str]] = None,
+                 condition_exception: Optional[pulumi.Input[str]] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 enabled: Optional[pulumi.Input[bool]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = AppSecRateProtectionArgs.__new__(AppSecRateProtectionArgs)
+            __props__ = AppSecEvalGroupArgs.__new__(AppSecEvalGroupArgs)
 
+            if attack_group is None and not opts.urn:
+                raise TypeError("Missing required property 'attack_group'")
+            __props__.__dict__["attack_group"] = attack_group
+            if attack_group_action is None and not opts.urn:
+                raise TypeError("Missing required property 'attack_group_action'")
+            __props__.__dict__["attack_group_action"] = attack_group_action
+            __props__.__dict__["condition_exception"] = condition_exception
             if config_id is None and not opts.urn:
                 raise TypeError("Missing required property 'config_id'")
             __props__.__dict__["config_id"] = config_id
-            if enabled is None and not opts.urn:
-                raise TypeError("Missing required property 'enabled'")
-            __props__.__dict__["enabled"] = enabled
             if security_policy_id is None and not opts.urn:
                 raise TypeError("Missing required property 'security_policy_id'")
             __props__.__dict__["security_policy_id"] = security_policy_id
-            __props__.__dict__["output_text"] = None
-        super(AppSecRateProtection, __self__).__init__(
-            'akamai:index/appSecRateProtection:AppSecRateProtection',
+        super(AppSecEvalGroup, __self__).__init__(
+            'akamai:index/appSecEvalGroup:AppSecEvalGroup',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
+            attack_group: Optional[pulumi.Input[str]] = None,
+            attack_group_action: Optional[pulumi.Input[str]] = None,
+            condition_exception: Optional[pulumi.Input[str]] = None,
             config_id: Optional[pulumi.Input[int]] = None,
-            enabled: Optional[pulumi.Input[bool]] = None,
-            output_text: Optional[pulumi.Input[str]] = None,
-            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecRateProtection':
+            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecEvalGroup':
         """
-        Get an existing AppSecRateProtection resource's state with the given name, id, and optional extra
+        Get an existing AppSecEvalGroup resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the rate protection settings being modified.
-        :param pulumi.Input[bool] enabled: . Set to **true** to enable rate protection; set to **false** to disable rate protection.
-        :param pulumi.Input[str] output_text: Text representation
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the rate protection settings being modified.
+        :param pulumi.Input[str] attack_group: Unique identifier of the evaluation attack group being modified
+        :param pulumi.Input[str] attack_group_action: Action to be taken when the attack group is triggered
+        :param pulumi.Input[str] condition_exception: JSON-formatted condition and exception information for the evaluation attack group
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _AppSecRateProtectionState.__new__(_AppSecRateProtectionState)
+        __props__ = _AppSecEvalGroupState.__new__(_AppSecEvalGroupState)
 
+        __props__.__dict__["attack_group"] = attack_group
+        __props__.__dict__["attack_group_action"] = attack_group_action
+        __props__.__dict__["condition_exception"] = condition_exception
         __props__.__dict__["config_id"] = config_id
-        __props__.__dict__["enabled"] = enabled
-        __props__.__dict__["output_text"] = output_text
         __props__.__dict__["security_policy_id"] = security_policy_id
-        return AppSecRateProtection(resource_name, opts=opts, __props__=__props__)
+        return AppSecEvalGroup(resource_name, opts=opts, __props__=__props__)
 
     @property
-    @pulumi.getter(name="configId")
-    def config_id(self) -> pulumi.Output[int]:
+    @pulumi.getter(name="attackGroup")
+    def attack_group(self) -> pulumi.Output[str]:
         """
-        . Unique identifier of the security configuration associated with the rate protection settings being modified.
+        Unique identifier of the evaluation attack group being modified
         """
-        return pulumi.get(self, "config_id")
+        return pulumi.get(self, "attack_group")
+
+    @property
+    @pulumi.getter(name="attackGroupAction")
+    def attack_group_action(self) -> pulumi.Output[str]:
+        """
+        Action to be taken when the attack group is triggered
+        """
+        return pulumi.get(self, "attack_group_action")
 
     @property
-    @pulumi.getter
-    def enabled(self) -> pulumi.Output[bool]:
+    @pulumi.getter(name="conditionException")
+    def condition_exception(self) -> pulumi.Output[Optional[str]]:
         """
-        . Set to **true** to enable rate protection; set to **false** to disable rate protection.
+        JSON-formatted condition and exception information for the evaluation attack group
         """
-        return pulumi.get(self, "enabled")
+        return pulumi.get(self, "condition_exception")
 
     @property
-    @pulumi.getter(name="outputText")
-    def output_text(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="configId")
+    def config_id(self) -> pulumi.Output[int]:
         """
-        Text representation
+        Unique identifier of the security configuration
         """
-        return pulumi.get(self, "output_text")
+        return pulumi.get(self, "config_id")
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Output[str]:
         """
-        . Unique identifier of the security policy associated with the rate protection settings being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_reputation_profile.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_reputation_profile_action.py`

 * *Files 13% similar despite different names*

```diff
@@ -5,270 +5,284 @@
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
-__all__ = ['AppSecReputationProfileArgs', 'AppSecReputationProfile']
+__all__ = ['AppSecReputationProfileActionArgs', 'AppSecReputationProfileAction']
 
 @pulumi.input_type
-class AppSecReputationProfileArgs:
+class AppSecReputationProfileActionArgs:
     def __init__(__self__, *,
+                 action: pulumi.Input[str],
                  config_id: pulumi.Input[int],
-                 reputation_profile: pulumi.Input[str]):
+                 reputation_profile_id: pulumi.Input[int],
+                 security_policy_id: pulumi.Input[str]):
         """
-        The set of arguments for constructing a AppSecReputationProfile resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the reputation profile being modified.
-        :param pulumi.Input[str] reputation_profile: . Path to a JSON file containing a definition of the reputation profile.
+        The set of arguments for constructing a AppSecReputationProfileAction resource.
+        :param pulumi.Input[str] action: Action to be taken when the reputation profile is triggered
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[int] reputation_profile_id: Unique identifier of the reputation profile
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
+        pulumi.set(__self__, "action", action)
         pulumi.set(__self__, "config_id", config_id)
-        pulumi.set(__self__, "reputation_profile", reputation_profile)
+        pulumi.set(__self__, "reputation_profile_id", reputation_profile_id)
+        pulumi.set(__self__, "security_policy_id", security_policy_id)
+
+    @property
+    @pulumi.getter
+    def action(self) -> pulumi.Input[str]:
+        """
+        Action to be taken when the reputation profile is triggered
+        """
+        return pulumi.get(self, "action")
+
+    @action.setter
+    def action(self, value: pulumi.Input[str]):
+        pulumi.set(self, "action", value)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuration associated with the reputation profile being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "config_id", value)
 
     @property
-    @pulumi.getter(name="reputationProfile")
-    def reputation_profile(self) -> pulumi.Input[str]:
+    @pulumi.getter(name="reputationProfileId")
+    def reputation_profile_id(self) -> pulumi.Input[int]:
+        """
+        Unique identifier of the reputation profile
+        """
+        return pulumi.get(self, "reputation_profile_id")
+
+    @reputation_profile_id.setter
+    def reputation_profile_id(self, value: pulumi.Input[int]):
+        pulumi.set(self, "reputation_profile_id", value)
+
+    @property
+    @pulumi.getter(name="securityPolicyId")
+    def security_policy_id(self) -> pulumi.Input[str]:
         """
-        . Path to a JSON file containing a definition of the reputation profile.
+        Unique identifier of the security policy
         """
-        return pulumi.get(self, "reputation_profile")
+        return pulumi.get(self, "security_policy_id")
 
-    @reputation_profile.setter
-    def reputation_profile(self, value: pulumi.Input[str]):
-        pulumi.set(self, "reputation_profile", value)
+    @security_policy_id.setter
+    def security_policy_id(self, value: pulumi.Input[str]):
+        pulumi.set(self, "security_policy_id", value)
 
 
 @pulumi.input_type
-class _AppSecReputationProfileState:
+class _AppSecReputationProfileActionState:
     def __init__(__self__, *,
+                 action: Optional[pulumi.Input[str]] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 reputation_profile: Optional[pulumi.Input[str]] = None,
-                 reputation_profile_id: Optional[pulumi.Input[int]] = None):
+                 reputation_profile_id: Optional[pulumi.Input[int]] = None,
+                 security_policy_id: Optional[pulumi.Input[str]] = None):
         """
-        Input properties used for looking up and filtering AppSecReputationProfile resources.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the reputation profile being modified.
-        :param pulumi.Input[str] reputation_profile: . Path to a JSON file containing a definition of the reputation profile.
+        Input properties used for looking up and filtering AppSecReputationProfileAction resources.
+        :param pulumi.Input[str] action: Action to be taken when the reputation profile is triggered
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
         :param pulumi.Input[int] reputation_profile_id: Unique identifier of the reputation profile
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
+        if action is not None:
+            pulumi.set(__self__, "action", action)
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
-        if reputation_profile is not None:
-            pulumi.set(__self__, "reputation_profile", reputation_profile)
         if reputation_profile_id is not None:
             pulumi.set(__self__, "reputation_profile_id", reputation_profile_id)
+        if security_policy_id is not None:
+            pulumi.set(__self__, "security_policy_id", security_policy_id)
+
+    @property
+    @pulumi.getter
+    def action(self) -> Optional[pulumi.Input[str]]:
+        """
+        Action to be taken when the reputation profile is triggered
+        """
+        return pulumi.get(self, "action")
+
+    @action.setter
+    def action(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "action", value)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security configuration associated with the reputation profile being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "config_id", value)
 
     @property
-    @pulumi.getter(name="reputationProfile")
-    def reputation_profile(self) -> Optional[pulumi.Input[str]]:
-        """
-        . Path to a JSON file containing a definition of the reputation profile.
-        """
-        return pulumi.get(self, "reputation_profile")
-
-    @reputation_profile.setter
-    def reputation_profile(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "reputation_profile", value)
-
-    @property
     @pulumi.getter(name="reputationProfileId")
     def reputation_profile_id(self) -> Optional[pulumi.Input[int]]:
         """
         Unique identifier of the reputation profile
         """
         return pulumi.get(self, "reputation_profile_id")
 
     @reputation_profile_id.setter
     def reputation_profile_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "reputation_profile_id", value)
 
+    @property
+    @pulumi.getter(name="securityPolicyId")
+    def security_policy_id(self) -> Optional[pulumi.Input[str]]:
+        """
+        Unique identifier of the security policy
+        """
+        return pulumi.get(self, "security_policy_id")
+
+    @security_policy_id.setter
+    def security_policy_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "security_policy_id", value)
 
-class AppSecReputationProfile(pulumi.CustomResource):
+
+class AppSecReputationProfileAction(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
+                 action: Optional[pulumi.Input[str]] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 reputation_profile: Optional[pulumi.Input[str]] = None,
+                 reputation_profile_id: Optional[pulumi.Input[int]] = None,
+                 security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Security policy
-
-        Creates or modifies a reputation profile.
-        Reputation profiles grade the security risk of an IP address based on previous activities associated with that address.
-        Depending on the reputation score and how your configuration has been set up, requests from a specific IP address can trigger an alert or even be blocked.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/reputation-profiles](https://techdocs.akamai.com/application-security/reference/put-reputation-profile)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        reputation_profile = akamai.AppSecReputationProfile("reputationProfile",
-            config_id=configuration.config_id,
-            reputation_profile=(lambda path: open(path).read())(f"{path['module']}/reputation_profile.json"))
-        pulumi.export("reputationProfileId", reputation_profile.reputation_profile_id)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `reputation_profile_id`. ID of the newly-created or newly-modified reputation profile.
-
+        Create a AppSecReputationProfileAction resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the reputation profile being modified.
-        :param pulumi.Input[str] reputation_profile: . Path to a JSON file containing a definition of the reputation profile.
+        :param pulumi.Input[str] action: Action to be taken when the reputation profile is triggered
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[int] reputation_profile_id: Unique identifier of the reputation profile
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: AppSecReputationProfileArgs,
+                 args: AppSecReputationProfileActionArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Security policy
-
-        Creates or modifies a reputation profile.
-        Reputation profiles grade the security risk of an IP address based on previous activities associated with that address.
-        Depending on the reputation score and how your configuration has been set up, requests from a specific IP address can trigger an alert or even be blocked.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/reputation-profiles](https://techdocs.akamai.com/application-security/reference/put-reputation-profile)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        reputation_profile = akamai.AppSecReputationProfile("reputationProfile",
-            config_id=configuration.config_id,
-            reputation_profile=(lambda path: open(path).read())(f"{path['module']}/reputation_profile.json"))
-        pulumi.export("reputationProfileId", reputation_profile.reputation_profile_id)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `reputation_profile_id`. ID of the newly-created or newly-modified reputation profile.
-
+        Create a AppSecReputationProfileAction resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param AppSecReputationProfileArgs args: The arguments to use to populate this resource's properties.
+        :param AppSecReputationProfileActionArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(AppSecReputationProfileArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(AppSecReputationProfileActionArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
+                 action: Optional[pulumi.Input[str]] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 reputation_profile: Optional[pulumi.Input[str]] = None,
+                 reputation_profile_id: Optional[pulumi.Input[int]] = None,
+                 security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = AppSecReputationProfileArgs.__new__(AppSecReputationProfileArgs)
+            __props__ = AppSecReputationProfileActionArgs.__new__(AppSecReputationProfileActionArgs)
 
+            if action is None and not opts.urn:
+                raise TypeError("Missing required property 'action'")
+            __props__.__dict__["action"] = action
             if config_id is None and not opts.urn:
                 raise TypeError("Missing required property 'config_id'")
             __props__.__dict__["config_id"] = config_id
-            if reputation_profile is None and not opts.urn:
-                raise TypeError("Missing required property 'reputation_profile'")
-            __props__.__dict__["reputation_profile"] = reputation_profile
-            __props__.__dict__["reputation_profile_id"] = None
-        super(AppSecReputationProfile, __self__).__init__(
-            'akamai:index/appSecReputationProfile:AppSecReputationProfile',
+            if reputation_profile_id is None and not opts.urn:
+                raise TypeError("Missing required property 'reputation_profile_id'")
+            __props__.__dict__["reputation_profile_id"] = reputation_profile_id
+            if security_policy_id is None and not opts.urn:
+                raise TypeError("Missing required property 'security_policy_id'")
+            __props__.__dict__["security_policy_id"] = security_policy_id
+        super(AppSecReputationProfileAction, __self__).__init__(
+            'akamai:index/appSecReputationProfileAction:AppSecReputationProfileAction',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
+            action: Optional[pulumi.Input[str]] = None,
             config_id: Optional[pulumi.Input[int]] = None,
-            reputation_profile: Optional[pulumi.Input[str]] = None,
-            reputation_profile_id: Optional[pulumi.Input[int]] = None) -> 'AppSecReputationProfile':
+            reputation_profile_id: Optional[pulumi.Input[int]] = None,
+            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecReputationProfileAction':
         """
-        Get an existing AppSecReputationProfile resource's state with the given name, id, and optional extra
+        Get an existing AppSecReputationProfileAction resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the reputation profile being modified.
-        :param pulumi.Input[str] reputation_profile: . Path to a JSON file containing a definition of the reputation profile.
+        :param pulumi.Input[str] action: Action to be taken when the reputation profile is triggered
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
         :param pulumi.Input[int] reputation_profile_id: Unique identifier of the reputation profile
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _AppSecReputationProfileState.__new__(_AppSecReputationProfileState)
+        __props__ = _AppSecReputationProfileActionState.__new__(_AppSecReputationProfileActionState)
 
+        __props__.__dict__["action"] = action
         __props__.__dict__["config_id"] = config_id
-        __props__.__dict__["reputation_profile"] = reputation_profile
         __props__.__dict__["reputation_profile_id"] = reputation_profile_id
-        return AppSecReputationProfile(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["security_policy_id"] = security_policy_id
+        return AppSecReputationProfileAction(resource_name, opts=opts, __props__=__props__)
 
     @property
-    @pulumi.getter(name="configId")
-    def config_id(self) -> pulumi.Output[int]:
+    @pulumi.getter
+    def action(self) -> pulumi.Output[str]:
         """
-        . Unique identifier of the security configuration associated with the reputation profile being modified.
+        Action to be taken when the reputation profile is triggered
         """
-        return pulumi.get(self, "config_id")
+        return pulumi.get(self, "action")
 
     @property
-    @pulumi.getter(name="reputationProfile")
-    def reputation_profile(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="configId")
+    def config_id(self) -> pulumi.Output[int]:
         """
-        . Path to a JSON file containing a definition of the reputation profile.
+        Unique identifier of the security configuration
         """
-        return pulumi.get(self, "reputation_profile")
+        return pulumi.get(self, "config_id")
 
     @property
     @pulumi.getter(name="reputationProfileId")
     def reputation_profile_id(self) -> pulumi.Output[int]:
         """
         Unique identifier of the reputation profile
         """
         return pulumi.get(self, "reputation_profile_id")
 
+    @property
+    @pulumi.getter(name="securityPolicyId")
+    def security_policy_id(self) -> pulumi.Output[str]:
+        """
+        Unique identifier of the security policy
+        """
+        return pulumi.get(self, "security_policy_id")
+
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_reputation_profile_action.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_siem_settings.py`

 * *Files 21% similar despite different names*

```diff
@@ -5,358 +5,379 @@
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
-__all__ = ['AppSecReputationProfileActionArgs', 'AppSecReputationProfileAction']
+__all__ = ['AppSecSiemSettingsArgs', 'AppSecSiemSettings']
 
 @pulumi.input_type
-class AppSecReputationProfileActionArgs:
+class AppSecSiemSettingsArgs:
     def __init__(__self__, *,
-                 action: pulumi.Input[str],
                  config_id: pulumi.Input[int],
-                 reputation_profile_id: pulumi.Input[int],
-                 security_policy_id: pulumi.Input[str]):
+                 enable_botman_siem: pulumi.Input[bool],
+                 enable_for_all_policies: pulumi.Input[bool],
+                 enable_siem: pulumi.Input[bool],
+                 siem_id: pulumi.Input[int],
+                 security_policy_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
+        """
+        The set of arguments for constructing a AppSecSiemSettings resource.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enable_botman_siem: Whether Bot Manager events should be included in SIEM events
+        :param pulumi.Input[bool] enable_for_all_policies: Whether to enable SIEM on all security policies in the security configuration
+        :param pulumi.Input[bool] enable_siem: Whether to enable SIEM
+        :param pulumi.Input[int] siem_id: Unique identifier of the SIEM settings being modified
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_policy_ids: List of IDs of security policy for which SIEM integration is to be enabled
         """
-        The set of arguments for constructing a AppSecReputationProfileAction resource.
-        :param pulumi.Input[str] action: . Action taken any time the reputation profile is triggered. Allows values are:
-               - **alert**. Record the event.
-               - **deny**. Block the request.
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the reputation profile action being modified.
-        :param pulumi.Input[int] reputation_profile_id: . Unique identifier of the reputation profile whose action is being modified.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the reputation profile action being modified.
-        """
-        pulumi.set(__self__, "action", action)
         pulumi.set(__self__, "config_id", config_id)
-        pulumi.set(__self__, "reputation_profile_id", reputation_profile_id)
-        pulumi.set(__self__, "security_policy_id", security_policy_id)
-
-    @property
-    @pulumi.getter
-    def action(self) -> pulumi.Input[str]:
-        """
-        . Action taken any time the reputation profile is triggered. Allows values are:
-        - **alert**. Record the event.
-        - **deny**. Block the request.
-        - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-        - **none**. Take no action.
-        """
-        return pulumi.get(self, "action")
-
-    @action.setter
-    def action(self, value: pulumi.Input[str]):
-        pulumi.set(self, "action", value)
+        pulumi.set(__self__, "enable_botman_siem", enable_botman_siem)
+        pulumi.set(__self__, "enable_for_all_policies", enable_for_all_policies)
+        pulumi.set(__self__, "enable_siem", enable_siem)
+        pulumi.set(__self__, "siem_id", siem_id)
+        if security_policy_ids is not None:
+            pulumi.set(__self__, "security_policy_ids", security_policy_ids)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuration associated with the reputation profile action being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "config_id", value)
 
     @property
-    @pulumi.getter(name="reputationProfileId")
-    def reputation_profile_id(self) -> pulumi.Input[int]:
+    @pulumi.getter(name="enableBotmanSiem")
+    def enable_botman_siem(self) -> pulumi.Input[bool]:
         """
-        . Unique identifier of the reputation profile whose action is being modified.
+        Whether Bot Manager events should be included in SIEM events
         """
-        return pulumi.get(self, "reputation_profile_id")
+        return pulumi.get(self, "enable_botman_siem")
 
-    @reputation_profile_id.setter
-    def reputation_profile_id(self, value: pulumi.Input[int]):
-        pulumi.set(self, "reputation_profile_id", value)
+    @enable_botman_siem.setter
+    def enable_botman_siem(self, value: pulumi.Input[bool]):
+        pulumi.set(self, "enable_botman_siem", value)
 
     @property
-    @pulumi.getter(name="securityPolicyId")
-    def security_policy_id(self) -> pulumi.Input[str]:
+    @pulumi.getter(name="enableForAllPolicies")
+    def enable_for_all_policies(self) -> pulumi.Input[bool]:
         """
-        . Unique identifier of the security policy associated with the reputation profile action being modified.
+        Whether to enable SIEM on all security policies in the security configuration
         """
-        return pulumi.get(self, "security_policy_id")
+        return pulumi.get(self, "enable_for_all_policies")
 
-    @security_policy_id.setter
-    def security_policy_id(self, value: pulumi.Input[str]):
-        pulumi.set(self, "security_policy_id", value)
+    @enable_for_all_policies.setter
+    def enable_for_all_policies(self, value: pulumi.Input[bool]):
+        pulumi.set(self, "enable_for_all_policies", value)
+
+    @property
+    @pulumi.getter(name="enableSiem")
+    def enable_siem(self) -> pulumi.Input[bool]:
+        """
+        Whether to enable SIEM
+        """
+        return pulumi.get(self, "enable_siem")
+
+    @enable_siem.setter
+    def enable_siem(self, value: pulumi.Input[bool]):
+        pulumi.set(self, "enable_siem", value)
+
+    @property
+    @pulumi.getter(name="siemId")
+    def siem_id(self) -> pulumi.Input[int]:
+        """
+        Unique identifier of the SIEM settings being modified
+        """
+        return pulumi.get(self, "siem_id")
+
+    @siem_id.setter
+    def siem_id(self, value: pulumi.Input[int]):
+        pulumi.set(self, "siem_id", value)
+
+    @property
+    @pulumi.getter(name="securityPolicyIds")
+    def security_policy_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
+        """
+        List of IDs of security policy for which SIEM integration is to be enabled
+        """
+        return pulumi.get(self, "security_policy_ids")
+
+    @security_policy_ids.setter
+    def security_policy_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
+        pulumi.set(self, "security_policy_ids", value)
 
 
 @pulumi.input_type
-class _AppSecReputationProfileActionState:
+class _AppSecSiemSettingsState:
     def __init__(__self__, *,
-                 action: Optional[pulumi.Input[str]] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 reputation_profile_id: Optional[pulumi.Input[int]] = None,
-                 security_policy_id: Optional[pulumi.Input[str]] = None):
+                 enable_botman_siem: Optional[pulumi.Input[bool]] = None,
+                 enable_for_all_policies: Optional[pulumi.Input[bool]] = None,
+                 enable_siem: Optional[pulumi.Input[bool]] = None,
+                 security_policy_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 siem_id: Optional[pulumi.Input[int]] = None):
+        """
+        Input properties used for looking up and filtering AppSecSiemSettings resources.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enable_botman_siem: Whether Bot Manager events should be included in SIEM events
+        :param pulumi.Input[bool] enable_for_all_policies: Whether to enable SIEM on all security policies in the security configuration
+        :param pulumi.Input[bool] enable_siem: Whether to enable SIEM
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_policy_ids: List of IDs of security policy for which SIEM integration is to be enabled
+        :param pulumi.Input[int] siem_id: Unique identifier of the SIEM settings being modified
         """
-        Input properties used for looking up and filtering AppSecReputationProfileAction resources.
-        :param pulumi.Input[str] action: . Action taken any time the reputation profile is triggered. Allows values are:
-               - **alert**. Record the event.
-               - **deny**. Block the request.
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the reputation profile action being modified.
-        :param pulumi.Input[int] reputation_profile_id: . Unique identifier of the reputation profile whose action is being modified.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the reputation profile action being modified.
-        """
-        if action is not None:
-            pulumi.set(__self__, "action", action)
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
-        if reputation_profile_id is not None:
-            pulumi.set(__self__, "reputation_profile_id", reputation_profile_id)
-        if security_policy_id is not None:
-            pulumi.set(__self__, "security_policy_id", security_policy_id)
-
-    @property
-    @pulumi.getter
-    def action(self) -> Optional[pulumi.Input[str]]:
-        """
-        . Action taken any time the reputation profile is triggered. Allows values are:
-        - **alert**. Record the event.
-        - **deny**. Block the request.
-        - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-        - **none**. Take no action.
-        """
-        return pulumi.get(self, "action")
-
-    @action.setter
-    def action(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "action", value)
+        if enable_botman_siem is not None:
+            pulumi.set(__self__, "enable_botman_siem", enable_botman_siem)
+        if enable_for_all_policies is not None:
+            pulumi.set(__self__, "enable_for_all_policies", enable_for_all_policies)
+        if enable_siem is not None:
+            pulumi.set(__self__, "enable_siem", enable_siem)
+        if security_policy_ids is not None:
+            pulumi.set(__self__, "security_policy_ids", security_policy_ids)
+        if siem_id is not None:
+            pulumi.set(__self__, "siem_id", siem_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security configuration associated with the reputation profile action being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "config_id", value)
 
     @property
-    @pulumi.getter(name="reputationProfileId")
-    def reputation_profile_id(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="enableBotmanSiem")
+    def enable_botman_siem(self) -> Optional[pulumi.Input[bool]]:
         """
-        . Unique identifier of the reputation profile whose action is being modified.
+        Whether Bot Manager events should be included in SIEM events
         """
-        return pulumi.get(self, "reputation_profile_id")
+        return pulumi.get(self, "enable_botman_siem")
 
-    @reputation_profile_id.setter
-    def reputation_profile_id(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "reputation_profile_id", value)
+    @enable_botman_siem.setter
+    def enable_botman_siem(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "enable_botman_siem", value)
 
     @property
-    @pulumi.getter(name="securityPolicyId")
-    def security_policy_id(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="enableForAllPolicies")
+    def enable_for_all_policies(self) -> Optional[pulumi.Input[bool]]:
         """
-        . Unique identifier of the security policy associated with the reputation profile action being modified.
+        Whether to enable SIEM on all security policies in the security configuration
         """
-        return pulumi.get(self, "security_policy_id")
-
-    @security_policy_id.setter
-    def security_policy_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "security_policy_id", value)
+        return pulumi.get(self, "enable_for_all_policies")
 
+    @enable_for_all_policies.setter
+    def enable_for_all_policies(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "enable_for_all_policies", value)
 
-class AppSecReputationProfileAction(pulumi.CustomResource):
-    @overload
-    def __init__(__self__,
-                 resource_name: str,
-                 opts: Optional[pulumi.ResourceOptions] = None,
-                 action: Optional[pulumi.Input[str]] = None,
-                 config_id: Optional[pulumi.Input[int]] = None,
-                 reputation_profile_id: Optional[pulumi.Input[int]] = None,
-                 security_policy_id: Optional[pulumi.Input[str]] = None,
-                 __props__=None):
+    @property
+    @pulumi.getter(name="enableSiem")
+    def enable_siem(self) -> Optional[pulumi.Input[bool]]:
+        """
+        Whether to enable SIEM
         """
-        **Scopes**: Reputation profile
+        return pulumi.get(self, "enable_siem")
 
-        Modifies the action taken when a reputation profile is triggered.
+    @enable_siem.setter
+    def enable_siem(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "enable_siem", value)
 
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/reputation-profiles/{reputationProfileId}](https://techdocs.akamai.com/application-security/reference/put-reputation-profile-action)
+    @property
+    @pulumi.getter(name="securityPolicyIds")
+    def security_policy_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
+        """
+        List of IDs of security policy for which SIEM integration is to be enabled
+        """
+        return pulumi.get(self, "security_policy_ids")
 
-        ## Example Usage
+    @security_policy_ids.setter
+    def security_policy_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
+        pulumi.set(self, "security_policy_ids", value)
 
-        Basic usage:
+    @property
+    @pulumi.getter(name="siemId")
+    def siem_id(self) -> Optional[pulumi.Input[int]]:
+        """
+        Unique identifier of the SIEM settings being modified
+        """
+        return pulumi.get(self, "siem_id")
 
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
+    @siem_id.setter
+    def siem_id(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "siem_id", value)
 
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        appsec_reputation_profile_action = akamai.AppSecReputationProfileAction("appsecReputationProfileAction",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            reputation_profile_id=130713,
-            action="alert")
-        pulumi.export("reputationProfileId", appsec_reputation_profile_action.reputation_profile_id)
-        pulumi.export("reputationProfileAction", appsec_reputation_profile_action.action)
-        ```
 
+class AppSecSiemSettings(pulumi.CustomResource):
+    @overload
+    def __init__(__self__,
+                 resource_name: str,
+                 opts: Optional[pulumi.ResourceOptions] = None,
+                 config_id: Optional[pulumi.Input[int]] = None,
+                 enable_botman_siem: Optional[pulumi.Input[bool]] = None,
+                 enable_for_all_policies: Optional[pulumi.Input[bool]] = None,
+                 enable_siem: Optional[pulumi.Input[bool]] = None,
+                 security_policy_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 siem_id: Optional[pulumi.Input[int]] = None,
+                 __props__=None):
+        """
+        Create a AppSecSiemSettings resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] action: . Action taken any time the reputation profile is triggered. Allows values are:
-               - **alert**. Record the event.
-               - **deny**. Block the request.
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the reputation profile action being modified.
-        :param pulumi.Input[int] reputation_profile_id: . Unique identifier of the reputation profile whose action is being modified.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the reputation profile action being modified.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enable_botman_siem: Whether Bot Manager events should be included in SIEM events
+        :param pulumi.Input[bool] enable_for_all_policies: Whether to enable SIEM on all security policies in the security configuration
+        :param pulumi.Input[bool] enable_siem: Whether to enable SIEM
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_policy_ids: List of IDs of security policy for which SIEM integration is to be enabled
+        :param pulumi.Input[int] siem_id: Unique identifier of the SIEM settings being modified
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: AppSecReputationProfileActionArgs,
+                 args: AppSecSiemSettingsArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Reputation profile
-
-        Modifies the action taken when a reputation profile is triggered.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/reputation-profiles/{reputationProfileId}](https://techdocs.akamai.com/application-security/reference/put-reputation-profile-action)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        appsec_reputation_profile_action = akamai.AppSecReputationProfileAction("appsecReputationProfileAction",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            reputation_profile_id=130713,
-            action="alert")
-        pulumi.export("reputationProfileId", appsec_reputation_profile_action.reputation_profile_id)
-        pulumi.export("reputationProfileAction", appsec_reputation_profile_action.action)
-        ```
-
+        Create a AppSecSiemSettings resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param AppSecReputationProfileActionArgs args: The arguments to use to populate this resource's properties.
+        :param AppSecSiemSettingsArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(AppSecReputationProfileActionArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(AppSecSiemSettingsArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 action: Optional[pulumi.Input[str]] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 reputation_profile_id: Optional[pulumi.Input[int]] = None,
-                 security_policy_id: Optional[pulumi.Input[str]] = None,
+                 enable_botman_siem: Optional[pulumi.Input[bool]] = None,
+                 enable_for_all_policies: Optional[pulumi.Input[bool]] = None,
+                 enable_siem: Optional[pulumi.Input[bool]] = None,
+                 security_policy_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 siem_id: Optional[pulumi.Input[int]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = AppSecReputationProfileActionArgs.__new__(AppSecReputationProfileActionArgs)
+            __props__ = AppSecSiemSettingsArgs.__new__(AppSecSiemSettingsArgs)
 
-            if action is None and not opts.urn:
-                raise TypeError("Missing required property 'action'")
-            __props__.__dict__["action"] = action
             if config_id is None and not opts.urn:
                 raise TypeError("Missing required property 'config_id'")
             __props__.__dict__["config_id"] = config_id
-            if reputation_profile_id is None and not opts.urn:
-                raise TypeError("Missing required property 'reputation_profile_id'")
-            __props__.__dict__["reputation_profile_id"] = reputation_profile_id
-            if security_policy_id is None and not opts.urn:
-                raise TypeError("Missing required property 'security_policy_id'")
-            __props__.__dict__["security_policy_id"] = security_policy_id
-        super(AppSecReputationProfileAction, __self__).__init__(
-            'akamai:index/appSecReputationProfileAction:AppSecReputationProfileAction',
+            if enable_botman_siem is None and not opts.urn:
+                raise TypeError("Missing required property 'enable_botman_siem'")
+            __props__.__dict__["enable_botman_siem"] = enable_botman_siem
+            if enable_for_all_policies is None and not opts.urn:
+                raise TypeError("Missing required property 'enable_for_all_policies'")
+            __props__.__dict__["enable_for_all_policies"] = enable_for_all_policies
+            if enable_siem is None and not opts.urn:
+                raise TypeError("Missing required property 'enable_siem'")
+            __props__.__dict__["enable_siem"] = enable_siem
+            __props__.__dict__["security_policy_ids"] = security_policy_ids
+            if siem_id is None and not opts.urn:
+                raise TypeError("Missing required property 'siem_id'")
+            __props__.__dict__["siem_id"] = siem_id
+        super(AppSecSiemSettings, __self__).__init__(
+            'akamai:index/appSecSiemSettings:AppSecSiemSettings',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
-            action: Optional[pulumi.Input[str]] = None,
             config_id: Optional[pulumi.Input[int]] = None,
-            reputation_profile_id: Optional[pulumi.Input[int]] = None,
-            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecReputationProfileAction':
+            enable_botman_siem: Optional[pulumi.Input[bool]] = None,
+            enable_for_all_policies: Optional[pulumi.Input[bool]] = None,
+            enable_siem: Optional[pulumi.Input[bool]] = None,
+            security_policy_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+            siem_id: Optional[pulumi.Input[int]] = None) -> 'AppSecSiemSettings':
         """
-        Get an existing AppSecReputationProfileAction resource's state with the given name, id, and optional extra
+        Get an existing AppSecSiemSettings resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] action: . Action taken any time the reputation profile is triggered. Allows values are:
-               - **alert**. Record the event.
-               - **deny**. Block the request.
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the reputation profile action being modified.
-        :param pulumi.Input[int] reputation_profile_id: . Unique identifier of the reputation profile whose action is being modified.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the reputation profile action being modified.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enable_botman_siem: Whether Bot Manager events should be included in SIEM events
+        :param pulumi.Input[bool] enable_for_all_policies: Whether to enable SIEM on all security policies in the security configuration
+        :param pulumi.Input[bool] enable_siem: Whether to enable SIEM
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_policy_ids: List of IDs of security policy for which SIEM integration is to be enabled
+        :param pulumi.Input[int] siem_id: Unique identifier of the SIEM settings being modified
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _AppSecReputationProfileActionState.__new__(_AppSecReputationProfileActionState)
+        __props__ = _AppSecSiemSettingsState.__new__(_AppSecSiemSettingsState)
 
-        __props__.__dict__["action"] = action
         __props__.__dict__["config_id"] = config_id
-        __props__.__dict__["reputation_profile_id"] = reputation_profile_id
-        __props__.__dict__["security_policy_id"] = security_policy_id
-        return AppSecReputationProfileAction(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["enable_botman_siem"] = enable_botman_siem
+        __props__.__dict__["enable_for_all_policies"] = enable_for_all_policies
+        __props__.__dict__["enable_siem"] = enable_siem
+        __props__.__dict__["security_policy_ids"] = security_policy_ids
+        __props__.__dict__["siem_id"] = siem_id
+        return AppSecSiemSettings(resource_name, opts=opts, __props__=__props__)
 
     @property
-    @pulumi.getter
-    def action(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="configId")
+    def config_id(self) -> pulumi.Output[int]:
         """
-        . Action taken any time the reputation profile is triggered. Allows values are:
-        - **alert**. Record the event.
-        - **deny**. Block the request.
-        - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-        - **none**. Take no action.
+        Unique identifier of the security configuration
         """
-        return pulumi.get(self, "action")
+        return pulumi.get(self, "config_id")
 
     @property
-    @pulumi.getter(name="configId")
-    def config_id(self) -> pulumi.Output[int]:
+    @pulumi.getter(name="enableBotmanSiem")
+    def enable_botman_siem(self) -> pulumi.Output[bool]:
         """
-        . Unique identifier of the security configuration associated with the reputation profile action being modified.
+        Whether Bot Manager events should be included in SIEM events
         """
-        return pulumi.get(self, "config_id")
+        return pulumi.get(self, "enable_botman_siem")
+
+    @property
+    @pulumi.getter(name="enableForAllPolicies")
+    def enable_for_all_policies(self) -> pulumi.Output[bool]:
+        """
+        Whether to enable SIEM on all security policies in the security configuration
+        """
+        return pulumi.get(self, "enable_for_all_policies")
+
+    @property
+    @pulumi.getter(name="enableSiem")
+    def enable_siem(self) -> pulumi.Output[bool]:
+        """
+        Whether to enable SIEM
+        """
+        return pulumi.get(self, "enable_siem")
 
     @property
-    @pulumi.getter(name="reputationProfileId")
-    def reputation_profile_id(self) -> pulumi.Output[int]:
+    @pulumi.getter(name="securityPolicyIds")
+    def security_policy_ids(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        . Unique identifier of the reputation profile whose action is being modified.
+        List of IDs of security policy for which SIEM integration is to be enabled
         """
-        return pulumi.get(self, "reputation_profile_id")
+        return pulumi.get(self, "security_policy_ids")
 
     @property
-    @pulumi.getter(name="securityPolicyId")
-    def security_policy_id(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="siemId")
+    def siem_id(self) -> pulumi.Output[int]:
         """
-        . Unique identifier of the security policy associated with the reputation profile action being modified.
+        Unique identifier of the SIEM settings being modified
         """
-        return pulumi.get(self, "security_policy_id")
+        return pulumi.get(self, "siem_id")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_reputation_protection.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_reputation_protection.py`

 * *Files 18% similar despite different names*

```diff
@@ -15,51 +15,51 @@
 class AppSecReputationProtectionArgs:
     def __init__(__self__, *,
                  config_id: pulumi.Input[int],
                  enabled: pulumi.Input[bool],
                  security_policy_id: pulumi.Input[str]):
         """
         The set of arguments for constructing a AppSecReputationProtection resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the reputation protection settings being modified.
-        :param pulumi.Input[bool] enabled: . Set to **true** to enable reputation protection; set to **false** to disable reputation protection.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the reputation protection settings being modified.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enabled: Whether to enable reputation protection
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         pulumi.set(__self__, "config_id", config_id)
         pulumi.set(__self__, "enabled", enabled)
         pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuration associated with the reputation protection settings being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter
     def enabled(self) -> pulumi.Input[bool]:
         """
-        . Set to **true** to enable reputation protection; set to **false** to disable reputation protection.
+        Whether to enable reputation protection
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: pulumi.Input[bool]):
         pulumi.set(self, "enabled", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Input[str]:
         """
-        . Unique identifier of the security policy associated with the reputation protection settings being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "security_policy_id", value)
 
@@ -69,45 +69,45 @@
     def __init__(__self__, *,
                  config_id: Optional[pulumi.Input[int]] = None,
                  enabled: Optional[pulumi.Input[bool]] = None,
                  output_text: Optional[pulumi.Input[str]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering AppSecReputationProtection resources.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the reputation protection settings being modified.
-        :param pulumi.Input[bool] enabled: . Set to **true** to enable reputation protection; set to **false** to disable reputation protection.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enabled: Whether to enable reputation protection
         :param pulumi.Input[str] output_text: Text representation
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the reputation protection settings being modified.
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
         if enabled is not None:
             pulumi.set(__self__, "enabled", enabled)
         if output_text is not None:
             pulumi.set(__self__, "output_text", output_text)
         if security_policy_id is not None:
             pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security configuration associated with the reputation protection settings being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter
     def enabled(self) -> Optional[pulumi.Input[bool]]:
         """
-        . Set to **true** to enable reputation protection; set to **false** to disable reputation protection.
+        Whether to enable reputation protection
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "enabled", value)
 
@@ -123,15 +123,15 @@
     def output_text(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "output_text", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the security policy associated with the reputation protection settings being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "security_policy_id", value)
 
@@ -142,83 +142,29 @@
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
                  enabled: Optional[pulumi.Input[bool]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Security policy
-
-        Enables or disables reputation protection for a security configuration and security policy.
-        Reputation profiles grade the security risk of an IP address based on previous activities associated with that address.
-        Depending on the reputation score and how your configuration has been set up, requests from a specific IP address can trigger an alert or even be blocked.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/put-policy-protections)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        protection = akamai.AppSecReputationProtection("protection",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            enabled=True)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `output_text`. Tabular report showing the current protection settings.
-
+        Create a AppSecReputationProtection resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the reputation protection settings being modified.
-        :param pulumi.Input[bool] enabled: . Set to **true** to enable reputation protection; set to **false** to disable reputation protection.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the reputation protection settings being modified.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enabled: Whether to enable reputation protection
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: AppSecReputationProtectionArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Security policy
-
-        Enables or disables reputation protection for a security configuration and security policy.
-        Reputation profiles grade the security risk of an IP address based on previous activities associated with that address.
-        Depending on the reputation score and how your configuration has been set up, requests from a specific IP address can trigger an alert or even be blocked.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/put-policy-protections)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        protection = akamai.AppSecReputationProtection("protection",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            enabled=True)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `output_text`. Tabular report showing the current protection settings.
-
+        Create a AppSecReputationProtection resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param AppSecReputationProtectionArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(AppSecReputationProtectionArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -269,18 +215,18 @@
         """
         Get an existing AppSecReputationProtection resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the reputation protection settings being modified.
-        :param pulumi.Input[bool] enabled: . Set to **true** to enable reputation protection; set to **false** to disable reputation protection.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[bool] enabled: Whether to enable reputation protection
         :param pulumi.Input[str] output_text: Text representation
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the reputation protection settings being modified.
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _AppSecReputationProtectionState.__new__(_AppSecReputationProtectionState)
 
         __props__.__dict__["config_id"] = config_id
         __props__.__dict__["enabled"] = enabled
@@ -288,23 +234,23 @@
         __props__.__dict__["security_policy_id"] = security_policy_id
         return AppSecReputationProtection(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Output[int]:
         """
-        . Unique identifier of the security configuration associated with the reputation protection settings being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @property
     @pulumi.getter
     def enabled(self) -> pulumi.Output[bool]:
         """
-        . Set to **true** to enable reputation protection; set to **false** to disable reputation protection.
+        Whether to enable reputation protection
         """
         return pulumi.get(self, "enabled")
 
     @property
     @pulumi.getter(name="outputText")
     def output_text(self) -> pulumi.Output[str]:
         """
@@ -312,11 +258,11 @@
         """
         return pulumi.get(self, "output_text")
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Output[str]:
         """
-        . Unique identifier of the security policy associated with the reputation protection settings being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_rule.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/edge_kv.py`

 * *Files 23% similar despite different names*

```diff
@@ -4,403 +4,381 @@
 
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
+from . import outputs
+from ._inputs import *
 
-__all__ = ['AppSecRuleArgs', 'AppSecRule']
+__all__ = ['EdgeKvArgs', 'EdgeKv']
 
 @pulumi.input_type
-class AppSecRuleArgs:
+class EdgeKvArgs:
     def __init__(__self__, *,
-                 config_id: pulumi.Input[int],
-                 rule_id: pulumi.Input[int],
-                 security_policy_id: pulumi.Input[str],
-                 condition_exception: Optional[pulumi.Input[str]] = None,
-                 rule_action: Optional[pulumi.Input[str]] = None):
+                 group_id: pulumi.Input[int],
+                 namespace_name: pulumi.Input[str],
+                 network: pulumi.Input[str],
+                 retention_in_seconds: pulumi.Input[int],
+                 geo_location: Optional[pulumi.Input[str]] = None,
+                 initial_datas: Optional[pulumi.Input[Sequence[pulumi.Input['EdgeKvInitialDataArgs']]]] = None):
         """
-        The set of arguments for constructing a AppSecRule resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the Kona Rule Set rule being modified.
-        :param pulumi.Input[int] rule_id: . Unique identifier of the rule being modified.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the Kona Rule Set rule being modified.
-        :param pulumi.Input[str] condition_exception: . Path to a JSON file containing a description of the conditions and exceptions to be associated with a rule.
-        :param pulumi.Input[str] rule_action: Allowed values are:
-               - **alert**. Record the event.
-               - **deny**. Block the request.
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action. or `none` to take no action.
+        The set of arguments for constructing a EdgeKv resource.
+        :param pulumi.Input[int] group_id: Namespace ACC group ID. It will be used in EdgeKV API v2. Not updatable.
+        :param pulumi.Input[str] namespace_name: Name for the EKV namespace
+        :param pulumi.Input[str] network: The network on which the namespace will be activated
+        :param pulumi.Input[int] retention_in_seconds: Retention period for data in this namespace. An update of this value will just affect new EKV items.
+        :param pulumi.Input[str] geo_location: Storage location for data
+        :param pulumi.Input[Sequence[pulumi.Input['EdgeKvInitialDataArgs']]] initial_datas: List of pairs to initialize the namespace. Just meaningful for creation, updates will be ignored.
         """
-        pulumi.set(__self__, "config_id", config_id)
-        pulumi.set(__self__, "rule_id", rule_id)
-        pulumi.set(__self__, "security_policy_id", security_policy_id)
-        if condition_exception is not None:
-            pulumi.set(__self__, "condition_exception", condition_exception)
-        if rule_action is not None:
-            pulumi.set(__self__, "rule_action", rule_action)
+        pulumi.set(__self__, "group_id", group_id)
+        pulumi.set(__self__, "namespace_name", namespace_name)
+        pulumi.set(__self__, "network", network)
+        pulumi.set(__self__, "retention_in_seconds", retention_in_seconds)
+        if geo_location is not None:
+            pulumi.set(__self__, "geo_location", geo_location)
+        if initial_datas is not None:
+            pulumi.set(__self__, "initial_datas", initial_datas)
 
     @property
-    @pulumi.getter(name="configId")
-    def config_id(self) -> pulumi.Input[int]:
+    @pulumi.getter(name="groupId")
+    def group_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuration associated with the Kona Rule Set rule being modified.
+        Namespace ACC group ID. It will be used in EdgeKV API v2. Not updatable.
         """
-        return pulumi.get(self, "config_id")
+        return pulumi.get(self, "group_id")
 
-    @config_id.setter
-    def config_id(self, value: pulumi.Input[int]):
-        pulumi.set(self, "config_id", value)
+    @group_id.setter
+    def group_id(self, value: pulumi.Input[int]):
+        pulumi.set(self, "group_id", value)
 
     @property
-    @pulumi.getter(name="ruleId")
-    def rule_id(self) -> pulumi.Input[int]:
+    @pulumi.getter(name="namespaceName")
+    def namespace_name(self) -> pulumi.Input[str]:
         """
-        . Unique identifier of the rule being modified.
+        Name for the EKV namespace
         """
-        return pulumi.get(self, "rule_id")
+        return pulumi.get(self, "namespace_name")
 
-    @rule_id.setter
-    def rule_id(self, value: pulumi.Input[int]):
-        pulumi.set(self, "rule_id", value)
+    @namespace_name.setter
+    def namespace_name(self, value: pulumi.Input[str]):
+        pulumi.set(self, "namespace_name", value)
 
     @property
-    @pulumi.getter(name="securityPolicyId")
-    def security_policy_id(self) -> pulumi.Input[str]:
+    @pulumi.getter
+    def network(self) -> pulumi.Input[str]:
         """
-        . Unique identifier of the security policy associated with the Kona Rule Set rule being modified.
+        The network on which the namespace will be activated
         """
-        return pulumi.get(self, "security_policy_id")
+        return pulumi.get(self, "network")
 
-    @security_policy_id.setter
-    def security_policy_id(self, value: pulumi.Input[str]):
-        pulumi.set(self, "security_policy_id", value)
+    @network.setter
+    def network(self, value: pulumi.Input[str]):
+        pulumi.set(self, "network", value)
 
     @property
-    @pulumi.getter(name="conditionException")
-    def condition_exception(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="retentionInSeconds")
+    def retention_in_seconds(self) -> pulumi.Input[int]:
         """
-        . Path to a JSON file containing a description of the conditions and exceptions to be associated with a rule.
+        Retention period for data in this namespace. An update of this value will just affect new EKV items.
         """
-        return pulumi.get(self, "condition_exception")
+        return pulumi.get(self, "retention_in_seconds")
 
-    @condition_exception.setter
-    def condition_exception(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "condition_exception", value)
+    @retention_in_seconds.setter
+    def retention_in_seconds(self, value: pulumi.Input[int]):
+        pulumi.set(self, "retention_in_seconds", value)
 
     @property
-    @pulumi.getter(name="ruleAction")
-    def rule_action(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="geoLocation")
+    def geo_location(self) -> Optional[pulumi.Input[str]]:
         """
-        Allowed values are:
-        - **alert**. Record the event.
-        - **deny**. Block the request.
-        - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-        - **none**. Take no action. or `none` to take no action.
+        Storage location for data
         """
-        return pulumi.get(self, "rule_action")
+        return pulumi.get(self, "geo_location")
 
-    @rule_action.setter
-    def rule_action(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "rule_action", value)
+    @geo_location.setter
+    def geo_location(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "geo_location", value)
+
+    @property
+    @pulumi.getter(name="initialDatas")
+    def initial_datas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EdgeKvInitialDataArgs']]]]:
+        """
+        List of pairs to initialize the namespace. Just meaningful for creation, updates will be ignored.
+        """
+        return pulumi.get(self, "initial_datas")
+
+    @initial_datas.setter
+    def initial_datas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EdgeKvInitialDataArgs']]]]):
+        pulumi.set(self, "initial_datas", value)
 
 
 @pulumi.input_type
-class _AppSecRuleState:
+class _EdgeKvState:
     def __init__(__self__, *,
-                 condition_exception: Optional[pulumi.Input[str]] = None,
-                 config_id: Optional[pulumi.Input[int]] = None,
-                 rule_action: Optional[pulumi.Input[str]] = None,
-                 rule_id: Optional[pulumi.Input[int]] = None,
-                 security_policy_id: Optional[pulumi.Input[str]] = None):
+                 geo_location: Optional[pulumi.Input[str]] = None,
+                 group_id: Optional[pulumi.Input[int]] = None,
+                 initial_datas: Optional[pulumi.Input[Sequence[pulumi.Input['EdgeKvInitialDataArgs']]]] = None,
+                 namespace_name: Optional[pulumi.Input[str]] = None,
+                 network: Optional[pulumi.Input[str]] = None,
+                 retention_in_seconds: Optional[pulumi.Input[int]] = None):
+        """
+        Input properties used for looking up and filtering EdgeKv resources.
+        :param pulumi.Input[str] geo_location: Storage location for data
+        :param pulumi.Input[int] group_id: Namespace ACC group ID. It will be used in EdgeKV API v2. Not updatable.
+        :param pulumi.Input[Sequence[pulumi.Input['EdgeKvInitialDataArgs']]] initial_datas: List of pairs to initialize the namespace. Just meaningful for creation, updates will be ignored.
+        :param pulumi.Input[str] namespace_name: Name for the EKV namespace
+        :param pulumi.Input[str] network: The network on which the namespace will be activated
+        :param pulumi.Input[int] retention_in_seconds: Retention period for data in this namespace. An update of this value will just affect new EKV items.
+        """
+        if geo_location is not None:
+            pulumi.set(__self__, "geo_location", geo_location)
+        if group_id is not None:
+            pulumi.set(__self__, "group_id", group_id)
+        if initial_datas is not None:
+            pulumi.set(__self__, "initial_datas", initial_datas)
+        if namespace_name is not None:
+            pulumi.set(__self__, "namespace_name", namespace_name)
+        if network is not None:
+            pulumi.set(__self__, "network", network)
+        if retention_in_seconds is not None:
+            pulumi.set(__self__, "retention_in_seconds", retention_in_seconds)
+
+    @property
+    @pulumi.getter(name="geoLocation")
+    def geo_location(self) -> Optional[pulumi.Input[str]]:
         """
-        Input properties used for looking up and filtering AppSecRule resources.
-        :param pulumi.Input[str] condition_exception: . Path to a JSON file containing a description of the conditions and exceptions to be associated with a rule.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the Kona Rule Set rule being modified.
-        :param pulumi.Input[str] rule_action: Allowed values are:
-               - **alert**. Record the event.
-               - **deny**. Block the request.
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action. or `none` to take no action.
-        :param pulumi.Input[int] rule_id: . Unique identifier of the rule being modified.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the Kona Rule Set rule being modified.
+        Storage location for data
         """
-        if condition_exception is not None:
-            pulumi.set(__self__, "condition_exception", condition_exception)
-        if config_id is not None:
-            pulumi.set(__self__, "config_id", config_id)
-        if rule_action is not None:
-            pulumi.set(__self__, "rule_action", rule_action)
-        if rule_id is not None:
-            pulumi.set(__self__, "rule_id", rule_id)
-        if security_policy_id is not None:
-            pulumi.set(__self__, "security_policy_id", security_policy_id)
+        return pulumi.get(self, "geo_location")
+
+    @geo_location.setter
+    def geo_location(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "geo_location", value)
 
     @property
-    @pulumi.getter(name="conditionException")
-    def condition_exception(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="groupId")
+    def group_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Path to a JSON file containing a description of the conditions and exceptions to be associated with a rule.
+        Namespace ACC group ID. It will be used in EdgeKV API v2. Not updatable.
         """
-        return pulumi.get(self, "condition_exception")
+        return pulumi.get(self, "group_id")
 
-    @condition_exception.setter
-    def condition_exception(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "condition_exception", value)
+    @group_id.setter
+    def group_id(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "group_id", value)
 
     @property
-    @pulumi.getter(name="configId")
-    def config_id(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="initialDatas")
+    def initial_datas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EdgeKvInitialDataArgs']]]]:
         """
-        . Unique identifier of the security configuration associated with the Kona Rule Set rule being modified.
+        List of pairs to initialize the namespace. Just meaningful for creation, updates will be ignored.
         """
-        return pulumi.get(self, "config_id")
+        return pulumi.get(self, "initial_datas")
 
-    @config_id.setter
-    def config_id(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "config_id", value)
+    @initial_datas.setter
+    def initial_datas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EdgeKvInitialDataArgs']]]]):
+        pulumi.set(self, "initial_datas", value)
 
     @property
-    @pulumi.getter(name="ruleAction")
-    def rule_action(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="namespaceName")
+    def namespace_name(self) -> Optional[pulumi.Input[str]]:
         """
-        Allowed values are:
-        - **alert**. Record the event.
-        - **deny**. Block the request.
-        - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-        - **none**. Take no action. or `none` to take no action.
+        Name for the EKV namespace
         """
-        return pulumi.get(self, "rule_action")
+        return pulumi.get(self, "namespace_name")
 
-    @rule_action.setter
-    def rule_action(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "rule_action", value)
+    @namespace_name.setter
+    def namespace_name(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "namespace_name", value)
 
     @property
-    @pulumi.getter(name="ruleId")
-    def rule_id(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter
+    def network(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the rule being modified.
+        The network on which the namespace will be activated
         """
-        return pulumi.get(self, "rule_id")
+        return pulumi.get(self, "network")
 
-    @rule_id.setter
-    def rule_id(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "rule_id", value)
+    @network.setter
+    def network(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "network", value)
 
     @property
-    @pulumi.getter(name="securityPolicyId")
-    def security_policy_id(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="retentionInSeconds")
+    def retention_in_seconds(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security policy associated with the Kona Rule Set rule being modified.
+        Retention period for data in this namespace. An update of this value will just affect new EKV items.
         """
-        return pulumi.get(self, "security_policy_id")
+        return pulumi.get(self, "retention_in_seconds")
 
-    @security_policy_id.setter
-    def security_policy_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "security_policy_id", value)
+    @retention_in_seconds.setter
+    def retention_in_seconds(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "retention_in_seconds", value)
 
 
-class AppSecRule(pulumi.CustomResource):
+class EdgeKv(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 condition_exception: Optional[pulumi.Input[str]] = None,
-                 config_id: Optional[pulumi.Input[int]] = None,
-                 rule_action: Optional[pulumi.Input[str]] = None,
-                 rule_id: Optional[pulumi.Input[int]] = None,
-                 security_policy_id: Optional[pulumi.Input[str]] = None,
+                 geo_location: Optional[pulumi.Input[str]] = None,
+                 group_id: Optional[pulumi.Input[int]] = None,
+                 initial_datas: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['EdgeKvInitialDataArgs']]]]] = None,
+                 namespace_name: Optional[pulumi.Input[str]] = None,
+                 network: Optional[pulumi.Input[str]] = None,
+                 retention_in_seconds: Optional[pulumi.Input[int]] = None,
                  __props__=None):
         """
-        **Scopes**: Rule
-
-        Modifies a Kona Rule Set rule's action, conditions, and exceptions.
-
-        **Related API Endpoints**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rules/{ruleId}](https://techdocs.akamai.com/application-security/reference/put-rule) *and* [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rules/{ruleId}/condition-exception](https://techdocs.akamai.com/application-security/reference/put-rule-condition-exception)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        rule = akamai.AppSecRule("rule",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            rule_id=60029316,
-            rule_action="deny",
-            condition_exception=(lambda path: open(path).read())(f"{path['module']}/condition_exception.json"))
-        ```
-
+        Create a EdgeKv resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] condition_exception: . Path to a JSON file containing a description of the conditions and exceptions to be associated with a rule.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the Kona Rule Set rule being modified.
-        :param pulumi.Input[str] rule_action: Allowed values are:
-               - **alert**. Record the event.
-               - **deny**. Block the request.
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action. or `none` to take no action.
-        :param pulumi.Input[int] rule_id: . Unique identifier of the rule being modified.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the Kona Rule Set rule being modified.
+        :param pulumi.Input[str] geo_location: Storage location for data
+        :param pulumi.Input[int] group_id: Namespace ACC group ID. It will be used in EdgeKV API v2. Not updatable.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['EdgeKvInitialDataArgs']]]] initial_datas: List of pairs to initialize the namespace. Just meaningful for creation, updates will be ignored.
+        :param pulumi.Input[str] namespace_name: Name for the EKV namespace
+        :param pulumi.Input[str] network: The network on which the namespace will be activated
+        :param pulumi.Input[int] retention_in_seconds: Retention period for data in this namespace. An update of this value will just affect new EKV items.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: AppSecRuleArgs,
+                 args: EdgeKvArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Rule
-
-        Modifies a Kona Rule Set rule's action, conditions, and exceptions.
-
-        **Related API Endpoints**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rules/{ruleId}](https://techdocs.akamai.com/application-security/reference/put-rule) *and* [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rules/{ruleId}/condition-exception](https://techdocs.akamai.com/application-security/reference/put-rule-condition-exception)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        rule = akamai.AppSecRule("rule",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            rule_id=60029316,
-            rule_action="deny",
-            condition_exception=(lambda path: open(path).read())(f"{path['module']}/condition_exception.json"))
-        ```
-
+        Create a EdgeKv resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param AppSecRuleArgs args: The arguments to use to populate this resource's properties.
+        :param EdgeKvArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(AppSecRuleArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(EdgeKvArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 condition_exception: Optional[pulumi.Input[str]] = None,
-                 config_id: Optional[pulumi.Input[int]] = None,
-                 rule_action: Optional[pulumi.Input[str]] = None,
-                 rule_id: Optional[pulumi.Input[int]] = None,
-                 security_policy_id: Optional[pulumi.Input[str]] = None,
+                 geo_location: Optional[pulumi.Input[str]] = None,
+                 group_id: Optional[pulumi.Input[int]] = None,
+                 initial_datas: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['EdgeKvInitialDataArgs']]]]] = None,
+                 namespace_name: Optional[pulumi.Input[str]] = None,
+                 network: Optional[pulumi.Input[str]] = None,
+                 retention_in_seconds: Optional[pulumi.Input[int]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = AppSecRuleArgs.__new__(AppSecRuleArgs)
+            __props__ = EdgeKvArgs.__new__(EdgeKvArgs)
 
-            __props__.__dict__["condition_exception"] = condition_exception
-            if config_id is None and not opts.urn:
-                raise TypeError("Missing required property 'config_id'")
-            __props__.__dict__["config_id"] = config_id
-            __props__.__dict__["rule_action"] = rule_action
-            if rule_id is None and not opts.urn:
-                raise TypeError("Missing required property 'rule_id'")
-            __props__.__dict__["rule_id"] = rule_id
-            if security_policy_id is None and not opts.urn:
-                raise TypeError("Missing required property 'security_policy_id'")
-            __props__.__dict__["security_policy_id"] = security_policy_id
-        super(AppSecRule, __self__).__init__(
-            'akamai:index/appSecRule:AppSecRule',
+            __props__.__dict__["geo_location"] = geo_location
+            if group_id is None and not opts.urn:
+                raise TypeError("Missing required property 'group_id'")
+            __props__.__dict__["group_id"] = group_id
+            __props__.__dict__["initial_datas"] = initial_datas
+            if namespace_name is None and not opts.urn:
+                raise TypeError("Missing required property 'namespace_name'")
+            __props__.__dict__["namespace_name"] = namespace_name
+            if network is None and not opts.urn:
+                raise TypeError("Missing required property 'network'")
+            __props__.__dict__["network"] = network
+            if retention_in_seconds is None and not opts.urn:
+                raise TypeError("Missing required property 'retention_in_seconds'")
+            __props__.__dict__["retention_in_seconds"] = retention_in_seconds
+        super(EdgeKv, __self__).__init__(
+            'akamai:index/edgeKv:EdgeKv',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
-            condition_exception: Optional[pulumi.Input[str]] = None,
-            config_id: Optional[pulumi.Input[int]] = None,
-            rule_action: Optional[pulumi.Input[str]] = None,
-            rule_id: Optional[pulumi.Input[int]] = None,
-            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecRule':
+            geo_location: Optional[pulumi.Input[str]] = None,
+            group_id: Optional[pulumi.Input[int]] = None,
+            initial_datas: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['EdgeKvInitialDataArgs']]]]] = None,
+            namespace_name: Optional[pulumi.Input[str]] = None,
+            network: Optional[pulumi.Input[str]] = None,
+            retention_in_seconds: Optional[pulumi.Input[int]] = None) -> 'EdgeKv':
         """
-        Get an existing AppSecRule resource's state with the given name, id, and optional extra
+        Get an existing EdgeKv resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] condition_exception: . Path to a JSON file containing a description of the conditions and exceptions to be associated with a rule.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the Kona Rule Set rule being modified.
-        :param pulumi.Input[str] rule_action: Allowed values are:
-               - **alert**. Record the event.
-               - **deny**. Block the request.
-               - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-               - **none**. Take no action. or `none` to take no action.
-        :param pulumi.Input[int] rule_id: . Unique identifier of the rule being modified.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the Kona Rule Set rule being modified.
+        :param pulumi.Input[str] geo_location: Storage location for data
+        :param pulumi.Input[int] group_id: Namespace ACC group ID. It will be used in EdgeKV API v2. Not updatable.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['EdgeKvInitialDataArgs']]]] initial_datas: List of pairs to initialize the namespace. Just meaningful for creation, updates will be ignored.
+        :param pulumi.Input[str] namespace_name: Name for the EKV namespace
+        :param pulumi.Input[str] network: The network on which the namespace will be activated
+        :param pulumi.Input[int] retention_in_seconds: Retention period for data in this namespace. An update of this value will just affect new EKV items.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _AppSecRuleState.__new__(_AppSecRuleState)
+        __props__ = _EdgeKvState.__new__(_EdgeKvState)
+
+        __props__.__dict__["geo_location"] = geo_location
+        __props__.__dict__["group_id"] = group_id
+        __props__.__dict__["initial_datas"] = initial_datas
+        __props__.__dict__["namespace_name"] = namespace_name
+        __props__.__dict__["network"] = network
+        __props__.__dict__["retention_in_seconds"] = retention_in_seconds
+        return EdgeKv(resource_name, opts=opts, __props__=__props__)
 
-        __props__.__dict__["condition_exception"] = condition_exception
-        __props__.__dict__["config_id"] = config_id
-        __props__.__dict__["rule_action"] = rule_action
-        __props__.__dict__["rule_id"] = rule_id
-        __props__.__dict__["security_policy_id"] = security_policy_id
-        return AppSecRule(resource_name, opts=opts, __props__=__props__)
+    @property
+    @pulumi.getter(name="geoLocation")
+    def geo_location(self) -> pulumi.Output[Optional[str]]:
+        """
+        Storage location for data
+        """
+        return pulumi.get(self, "geo_location")
 
     @property
-    @pulumi.getter(name="conditionException")
-    def condition_exception(self) -> pulumi.Output[Optional[str]]:
+    @pulumi.getter(name="groupId")
+    def group_id(self) -> pulumi.Output[int]:
         """
-        . Path to a JSON file containing a description of the conditions and exceptions to be associated with a rule.
+        Namespace ACC group ID. It will be used in EdgeKV API v2. Not updatable.
         """
-        return pulumi.get(self, "condition_exception")
+        return pulumi.get(self, "group_id")
 
     @property
-    @pulumi.getter(name="configId")
-    def config_id(self) -> pulumi.Output[int]:
+    @pulumi.getter(name="initialDatas")
+    def initial_datas(self) -> pulumi.Output[Optional[Sequence['outputs.EdgeKvInitialData']]]:
         """
-        . Unique identifier of the security configuration associated with the Kona Rule Set rule being modified.
+        List of pairs to initialize the namespace. Just meaningful for creation, updates will be ignored.
         """
-        return pulumi.get(self, "config_id")
+        return pulumi.get(self, "initial_datas")
 
     @property
-    @pulumi.getter(name="ruleAction")
-    def rule_action(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="namespaceName")
+    def namespace_name(self) -> pulumi.Output[str]:
         """
-        Allowed values are:
-        - **alert**. Record the event.
-        - **deny**. Block the request.
-        - **deny_custom_{custom_deny_id}**. Take the action specified by the custom deny.
-        - **none**. Take no action. or `none` to take no action.
+        Name for the EKV namespace
         """
-        return pulumi.get(self, "rule_action")
+        return pulumi.get(self, "namespace_name")
 
     @property
-    @pulumi.getter(name="ruleId")
-    def rule_id(self) -> pulumi.Output[int]:
+    @pulumi.getter
+    def network(self) -> pulumi.Output[str]:
         """
-        . Unique identifier of the rule being modified.
+        The network on which the namespace will be activated
         """
-        return pulumi.get(self, "rule_id")
+        return pulumi.get(self, "network")
 
     @property
-    @pulumi.getter(name="securityPolicyId")
-    def security_policy_id(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="retentionInSeconds")
+    def retention_in_seconds(self) -> pulumi.Output[int]:
         """
-        . Unique identifier of the security policy associated with the Kona Rule Set rule being modified.
+        Retention period for data in this namespace. An update of this value will just affect new EKV items.
         """
-        return pulumi.get(self, "security_policy_id")
+        return pulumi.get(self, "retention_in_seconds")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_security_policy.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_configuration.py`

 * *Files 26% similar despite different names*

```diff
@@ -5,420 +5,453 @@
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
-__all__ = ['AppSecSecurityPolicyArgs', 'AppSecSecurityPolicy']
+__all__ = ['AppSecConfigurationArgs', 'AppSecConfiguration']
 
 @pulumi.input_type
-class AppSecSecurityPolicyArgs:
+class AppSecConfigurationArgs:
     def __init__(__self__, *,
-                 config_id: pulumi.Input[int],
-                 security_policy_name: pulumi.Input[str],
-                 security_policy_prefix: pulumi.Input[str],
-                 create_from_security_policy_id: Optional[pulumi.Input[str]] = None,
-                 default_settings: Optional[pulumi.Input[bool]] = None):
-        """
-        The set of arguments for constructing a AppSecSecurityPolicy resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration to be associated with the new security policy.
-        :param pulumi.Input[str] security_policy_name: . Name of the new security policy.
-        :param pulumi.Input[str] security_policy_prefix: . Four-character alphanumeric string prefix used in creating the security policy ID.
-        :param pulumi.Input[str] create_from_security_policy_id: . Unique identifier of the existing security policy that the new policy will be cloned from.
-        :param pulumi.Input[bool] default_settings: . Set to **true** to assign default setting values to the new policy; set to **false** to create a blank security policy. If not included, the new policy will be created using the default settings.
-        """
-        pulumi.set(__self__, "config_id", config_id)
-        pulumi.set(__self__, "security_policy_name", security_policy_name)
-        pulumi.set(__self__, "security_policy_prefix", security_policy_prefix)
-        if create_from_security_policy_id is not None:
-            pulumi.set(__self__, "create_from_security_policy_id", create_from_security_policy_id)
-        if default_settings is not None:
-            pulumi.set(__self__, "default_settings", default_settings)
+                 contract_id: pulumi.Input[str],
+                 description: pulumi.Input[str],
+                 group_id: pulumi.Input[int],
+                 host_names: pulumi.Input[Sequence[pulumi.Input[str]]],
+                 create_from_config_id: Optional[pulumi.Input[int]] = None,
+                 create_from_version: Optional[pulumi.Input[int]] = None,
+                 name: Optional[pulumi.Input[str]] = None):
+        """
+        The set of arguments for constructing a AppSecConfiguration resource.
+        :param pulumi.Input[str] contract_id: Unique identifier of the Akamai contract associated with the new configuration
+        :param pulumi.Input[str] description: Brief description of the new configuration
+        :param pulumi.Input[int] group_id: Unique identifier of the contract group associated with the new configuration
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] host_names: Hostnames to be protected by the new configuration
+        :param pulumi.Input[int] create_from_config_id: Unique identifier of the existing configuration being cloned to create the new configuration
+        :param pulumi.Input[int] create_from_version: Version number of the existing configuration being cloned to create the new configuration
+        :param pulumi.Input[str] name: Name of the new configuration
+        """
+        pulumi.set(__self__, "contract_id", contract_id)
+        pulumi.set(__self__, "description", description)
+        pulumi.set(__self__, "group_id", group_id)
+        pulumi.set(__self__, "host_names", host_names)
+        if create_from_config_id is not None:
+            pulumi.set(__self__, "create_from_config_id", create_from_config_id)
+        if create_from_version is not None:
+            pulumi.set(__self__, "create_from_version", create_from_version)
+        if name is not None:
+            pulumi.set(__self__, "name", name)
 
     @property
-    @pulumi.getter(name="configId")
-    def config_id(self) -> pulumi.Input[int]:
+    @pulumi.getter(name="contractId")
+    def contract_id(self) -> pulumi.Input[str]:
         """
-        . Unique identifier of the security configuration to be associated with the new security policy.
+        Unique identifier of the Akamai contract associated with the new configuration
         """
-        return pulumi.get(self, "config_id")
+        return pulumi.get(self, "contract_id")
 
-    @config_id.setter
-    def config_id(self, value: pulumi.Input[int]):
-        pulumi.set(self, "config_id", value)
+    @contract_id.setter
+    def contract_id(self, value: pulumi.Input[str]):
+        pulumi.set(self, "contract_id", value)
+
+    @property
+    @pulumi.getter
+    def description(self) -> pulumi.Input[str]:
+        """
+        Brief description of the new configuration
+        """
+        return pulumi.get(self, "description")
+
+    @description.setter
+    def description(self, value: pulumi.Input[str]):
+        pulumi.set(self, "description", value)
+
+    @property
+    @pulumi.getter(name="groupId")
+    def group_id(self) -> pulumi.Input[int]:
+        """
+        Unique identifier of the contract group associated with the new configuration
+        """
+        return pulumi.get(self, "group_id")
+
+    @group_id.setter
+    def group_id(self, value: pulumi.Input[int]):
+        pulumi.set(self, "group_id", value)
 
     @property
-    @pulumi.getter(name="securityPolicyName")
-    def security_policy_name(self) -> pulumi.Input[str]:
+    @pulumi.getter(name="hostNames")
+    def host_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
         """
-        . Name of the new security policy.
+        Hostnames to be protected by the new configuration
         """
-        return pulumi.get(self, "security_policy_name")
+        return pulumi.get(self, "host_names")
 
-    @security_policy_name.setter
-    def security_policy_name(self, value: pulumi.Input[str]):
-        pulumi.set(self, "security_policy_name", value)
+    @host_names.setter
+    def host_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
+        pulumi.set(self, "host_names", value)
 
     @property
-    @pulumi.getter(name="securityPolicyPrefix")
-    def security_policy_prefix(self) -> pulumi.Input[str]:
+    @pulumi.getter(name="createFromConfigId")
+    def create_from_config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Four-character alphanumeric string prefix used in creating the security policy ID.
+        Unique identifier of the existing configuration being cloned to create the new configuration
         """
-        return pulumi.get(self, "security_policy_prefix")
+        return pulumi.get(self, "create_from_config_id")
 
-    @security_policy_prefix.setter
-    def security_policy_prefix(self, value: pulumi.Input[str]):
-        pulumi.set(self, "security_policy_prefix", value)
+    @create_from_config_id.setter
+    def create_from_config_id(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "create_from_config_id", value)
 
     @property
-    @pulumi.getter(name="createFromSecurityPolicyId")
-    def create_from_security_policy_id(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="createFromVersion")
+    def create_from_version(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the existing security policy that the new policy will be cloned from.
+        Version number of the existing configuration being cloned to create the new configuration
         """
-        return pulumi.get(self, "create_from_security_policy_id")
+        return pulumi.get(self, "create_from_version")
 
-    @create_from_security_policy_id.setter
-    def create_from_security_policy_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "create_from_security_policy_id", value)
+    @create_from_version.setter
+    def create_from_version(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "create_from_version", value)
 
     @property
-    @pulumi.getter(name="defaultSettings")
-    def default_settings(self) -> Optional[pulumi.Input[bool]]:
+    @pulumi.getter
+    def name(self) -> Optional[pulumi.Input[str]]:
         """
-        . Set to **true** to assign default setting values to the new policy; set to **false** to create a blank security policy. If not included, the new policy will be created using the default settings.
+        Name of the new configuration
         """
-        return pulumi.get(self, "default_settings")
+        return pulumi.get(self, "name")
 
-    @default_settings.setter
-    def default_settings(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "default_settings", value)
+    @name.setter
+    def name(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "name", value)
 
 
 @pulumi.input_type
-class _AppSecSecurityPolicyState:
+class _AppSecConfigurationState:
     def __init__(__self__, *,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 create_from_security_policy_id: Optional[pulumi.Input[str]] = None,
-                 default_settings: Optional[pulumi.Input[bool]] = None,
-                 security_policy_id: Optional[pulumi.Input[str]] = None,
-                 security_policy_name: Optional[pulumi.Input[str]] = None,
-                 security_policy_prefix: Optional[pulumi.Input[str]] = None):
-        """
-        Input properties used for looking up and filtering AppSecSecurityPolicy resources.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration to be associated with the new security policy.
-        :param pulumi.Input[str] create_from_security_policy_id: . Unique identifier of the existing security policy that the new policy will be cloned from.
-        :param pulumi.Input[bool] default_settings: . Set to **true** to assign default setting values to the new policy; set to **false** to create a blank security policy. If not included, the new policy will be created using the default settings.
-        :param pulumi.Input[str] security_policy_id: Unique identifier of the new security policy
-        :param pulumi.Input[str] security_policy_name: . Name of the new security policy.
-        :param pulumi.Input[str] security_policy_prefix: . Four-character alphanumeric string prefix used in creating the security policy ID.
+                 contract_id: Optional[pulumi.Input[str]] = None,
+                 create_from_config_id: Optional[pulumi.Input[int]] = None,
+                 create_from_version: Optional[pulumi.Input[int]] = None,
+                 description: Optional[pulumi.Input[str]] = None,
+                 group_id: Optional[pulumi.Input[int]] = None,
+                 host_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 name: Optional[pulumi.Input[str]] = None):
+        """
+        Input properties used for looking up and filtering AppSecConfiguration resources.
+        :param pulumi.Input[int] config_id: Unique identifier of the new security configuration
+        :param pulumi.Input[str] contract_id: Unique identifier of the Akamai contract associated with the new configuration
+        :param pulumi.Input[int] create_from_config_id: Unique identifier of the existing configuration being cloned to create the new configuration
+        :param pulumi.Input[int] create_from_version: Version number of the existing configuration being cloned to create the new configuration
+        :param pulumi.Input[str] description: Brief description of the new configuration
+        :param pulumi.Input[int] group_id: Unique identifier of the contract group associated with the new configuration
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] host_names: Hostnames to be protected by the new configuration
+        :param pulumi.Input[str] name: Name of the new configuration
         """
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
-        if create_from_security_policy_id is not None:
-            pulumi.set(__self__, "create_from_security_policy_id", create_from_security_policy_id)
-        if default_settings is not None:
-            pulumi.set(__self__, "default_settings", default_settings)
-        if security_policy_id is not None:
-            pulumi.set(__self__, "security_policy_id", security_policy_id)
-        if security_policy_name is not None:
-            pulumi.set(__self__, "security_policy_name", security_policy_name)
-        if security_policy_prefix is not None:
-            pulumi.set(__self__, "security_policy_prefix", security_policy_prefix)
+        if contract_id is not None:
+            pulumi.set(__self__, "contract_id", contract_id)
+        if create_from_config_id is not None:
+            pulumi.set(__self__, "create_from_config_id", create_from_config_id)
+        if create_from_version is not None:
+            pulumi.set(__self__, "create_from_version", create_from_version)
+        if description is not None:
+            pulumi.set(__self__, "description", description)
+        if group_id is not None:
+            pulumi.set(__self__, "group_id", group_id)
+        if host_names is not None:
+            pulumi.set(__self__, "host_names", host_names)
+        if name is not None:
+            pulumi.set(__self__, "name", name)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security configuration to be associated with the new security policy.
+        Unique identifier of the new security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "config_id", value)
 
     @property
-    @pulumi.getter(name="createFromSecurityPolicyId")
-    def create_from_security_policy_id(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="contractId")
+    def contract_id(self) -> Optional[pulumi.Input[str]]:
+        """
+        Unique identifier of the Akamai contract associated with the new configuration
+        """
+        return pulumi.get(self, "contract_id")
+
+    @contract_id.setter
+    def contract_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "contract_id", value)
+
+    @property
+    @pulumi.getter(name="createFromConfigId")
+    def create_from_config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the existing security policy that the new policy will be cloned from.
+        Unique identifier of the existing configuration being cloned to create the new configuration
         """
-        return pulumi.get(self, "create_from_security_policy_id")
+        return pulumi.get(self, "create_from_config_id")
 
-    @create_from_security_policy_id.setter
-    def create_from_security_policy_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "create_from_security_policy_id", value)
+    @create_from_config_id.setter
+    def create_from_config_id(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "create_from_config_id", value)
 
     @property
-    @pulumi.getter(name="defaultSettings")
-    def default_settings(self) -> Optional[pulumi.Input[bool]]:
+    @pulumi.getter(name="createFromVersion")
+    def create_from_version(self) -> Optional[pulumi.Input[int]]:
         """
-        . Set to **true** to assign default setting values to the new policy; set to **false** to create a blank security policy. If not included, the new policy will be created using the default settings.
+        Version number of the existing configuration being cloned to create the new configuration
         """
-        return pulumi.get(self, "default_settings")
+        return pulumi.get(self, "create_from_version")
 
-    @default_settings.setter
-    def default_settings(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "default_settings", value)
+    @create_from_version.setter
+    def create_from_version(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "create_from_version", value)
 
     @property
-    @pulumi.getter(name="securityPolicyId")
-    def security_policy_id(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter
+    def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Unique identifier of the new security policy
+        Brief description of the new configuration
         """
-        return pulumi.get(self, "security_policy_id")
+        return pulumi.get(self, "description")
 
-    @security_policy_id.setter
-    def security_policy_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "security_policy_id", value)
+    @description.setter
+    def description(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "description", value)
 
     @property
-    @pulumi.getter(name="securityPolicyName")
-    def security_policy_name(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="groupId")
+    def group_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Name of the new security policy.
+        Unique identifier of the contract group associated with the new configuration
         """
-        return pulumi.get(self, "security_policy_name")
+        return pulumi.get(self, "group_id")
 
-    @security_policy_name.setter
-    def security_policy_name(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "security_policy_name", value)
+    @group_id.setter
+    def group_id(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "group_id", value)
 
     @property
-    @pulumi.getter(name="securityPolicyPrefix")
-    def security_policy_prefix(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="hostNames")
+    def host_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        . Four-character alphanumeric string prefix used in creating the security policy ID.
+        Hostnames to be protected by the new configuration
         """
-        return pulumi.get(self, "security_policy_prefix")
+        return pulumi.get(self, "host_names")
 
-    @security_policy_prefix.setter
-    def security_policy_prefix(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "security_policy_prefix", value)
+    @host_names.setter
+    def host_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
+        pulumi.set(self, "host_names", value)
 
+    @property
+    @pulumi.getter
+    def name(self) -> Optional[pulumi.Input[str]]:
+        """
+        Name of the new configuration
+        """
+        return pulumi.get(self, "name")
+
+    @name.setter
+    def name(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "name", value)
 
-class AppSecSecurityPolicy(pulumi.CustomResource):
+
+class AppSecConfiguration(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 config_id: Optional[pulumi.Input[int]] = None,
-                 create_from_security_policy_id: Optional[pulumi.Input[str]] = None,
-                 default_settings: Optional[pulumi.Input[bool]] = None,
-                 security_policy_name: Optional[pulumi.Input[str]] = None,
-                 security_policy_prefix: Optional[pulumi.Input[str]] = None,
+                 contract_id: Optional[pulumi.Input[str]] = None,
+                 create_from_config_id: Optional[pulumi.Input[int]] = None,
+                 create_from_version: Optional[pulumi.Input[int]] = None,
+                 description: Optional[pulumi.Input[str]] = None,
+                 group_id: Optional[pulumi.Input[int]] = None,
+                 host_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Security configuration
-
-        Creates a new security policy. The resource enables you to:
-
-        - Create a new, blank security policy.
-        - Create a new policy preconfigured with the default security policy settings.
-        - Clone an existing security policy.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies](https://techdocs.akamai.com/application-security/reference/post-policy)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        security_policy_create_app_sec_security_policy = akamai.AppSecSecurityPolicy("securityPolicyCreateAppSecSecurityPolicy",
-            config_id=configuration.config_id,
-            default_settings=True,
-            security_policy_name="Documentation Policy",
-            security_policy_prefix="gms1")
-        pulumi.export("securityPolicyCreate", security_policy_create_app_sec_security_policy.security_policy_id)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `security_policy_id`. ID of the newly-created security policy.
-
+        Create a AppSecConfiguration resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration to be associated with the new security policy.
-        :param pulumi.Input[str] create_from_security_policy_id: . Unique identifier of the existing security policy that the new policy will be cloned from.
-        :param pulumi.Input[bool] default_settings: . Set to **true** to assign default setting values to the new policy; set to **false** to create a blank security policy. If not included, the new policy will be created using the default settings.
-        :param pulumi.Input[str] security_policy_name: . Name of the new security policy.
-        :param pulumi.Input[str] security_policy_prefix: . Four-character alphanumeric string prefix used in creating the security policy ID.
+        :param pulumi.Input[str] contract_id: Unique identifier of the Akamai contract associated with the new configuration
+        :param pulumi.Input[int] create_from_config_id: Unique identifier of the existing configuration being cloned to create the new configuration
+        :param pulumi.Input[int] create_from_version: Version number of the existing configuration being cloned to create the new configuration
+        :param pulumi.Input[str] description: Brief description of the new configuration
+        :param pulumi.Input[int] group_id: Unique identifier of the contract group associated with the new configuration
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] host_names: Hostnames to be protected by the new configuration
+        :param pulumi.Input[str] name: Name of the new configuration
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: AppSecSecurityPolicyArgs,
+                 args: AppSecConfigurationArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Security configuration
-
-        Creates a new security policy. The resource enables you to:
-
-        - Create a new, blank security policy.
-        - Create a new policy preconfigured with the default security policy settings.
-        - Clone an existing security policy.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies](https://techdocs.akamai.com/application-security/reference/post-policy)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        security_policy_create_app_sec_security_policy = akamai.AppSecSecurityPolicy("securityPolicyCreateAppSecSecurityPolicy",
-            config_id=configuration.config_id,
-            default_settings=True,
-            security_policy_name="Documentation Policy",
-            security_policy_prefix="gms1")
-        pulumi.export("securityPolicyCreate", security_policy_create_app_sec_security_policy.security_policy_id)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `security_policy_id`. ID of the newly-created security policy.
-
+        Create a AppSecConfiguration resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param AppSecSecurityPolicyArgs args: The arguments to use to populate this resource's properties.
+        :param AppSecConfigurationArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(AppSecSecurityPolicyArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(AppSecConfigurationArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 config_id: Optional[pulumi.Input[int]] = None,
-                 create_from_security_policy_id: Optional[pulumi.Input[str]] = None,
-                 default_settings: Optional[pulumi.Input[bool]] = None,
-                 security_policy_name: Optional[pulumi.Input[str]] = None,
-                 security_policy_prefix: Optional[pulumi.Input[str]] = None,
+                 contract_id: Optional[pulumi.Input[str]] = None,
+                 create_from_config_id: Optional[pulumi.Input[int]] = None,
+                 create_from_version: Optional[pulumi.Input[int]] = None,
+                 description: Optional[pulumi.Input[str]] = None,
+                 group_id: Optional[pulumi.Input[int]] = None,
+                 host_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = AppSecSecurityPolicyArgs.__new__(AppSecSecurityPolicyArgs)
+            __props__ = AppSecConfigurationArgs.__new__(AppSecConfigurationArgs)
 
-            if config_id is None and not opts.urn:
-                raise TypeError("Missing required property 'config_id'")
-            __props__.__dict__["config_id"] = config_id
-            __props__.__dict__["create_from_security_policy_id"] = create_from_security_policy_id
-            __props__.__dict__["default_settings"] = default_settings
-            if security_policy_name is None and not opts.urn:
-                raise TypeError("Missing required property 'security_policy_name'")
-            __props__.__dict__["security_policy_name"] = security_policy_name
-            if security_policy_prefix is None and not opts.urn:
-                raise TypeError("Missing required property 'security_policy_prefix'")
-            __props__.__dict__["security_policy_prefix"] = security_policy_prefix
-            __props__.__dict__["security_policy_id"] = None
-        super(AppSecSecurityPolicy, __self__).__init__(
-            'akamai:index/appSecSecurityPolicy:AppSecSecurityPolicy',
+            if contract_id is None and not opts.urn:
+                raise TypeError("Missing required property 'contract_id'")
+            __props__.__dict__["contract_id"] = contract_id
+            __props__.__dict__["create_from_config_id"] = create_from_config_id
+            __props__.__dict__["create_from_version"] = create_from_version
+            if description is None and not opts.urn:
+                raise TypeError("Missing required property 'description'")
+            __props__.__dict__["description"] = description
+            if group_id is None and not opts.urn:
+                raise TypeError("Missing required property 'group_id'")
+            __props__.__dict__["group_id"] = group_id
+            if host_names is None and not opts.urn:
+                raise TypeError("Missing required property 'host_names'")
+            __props__.__dict__["host_names"] = host_names
+            __props__.__dict__["name"] = name
+            __props__.__dict__["config_id"] = None
+        super(AppSecConfiguration, __self__).__init__(
+            'akamai:index/appSecConfiguration:AppSecConfiguration',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
             config_id: Optional[pulumi.Input[int]] = None,
-            create_from_security_policy_id: Optional[pulumi.Input[str]] = None,
-            default_settings: Optional[pulumi.Input[bool]] = None,
-            security_policy_id: Optional[pulumi.Input[str]] = None,
-            security_policy_name: Optional[pulumi.Input[str]] = None,
-            security_policy_prefix: Optional[pulumi.Input[str]] = None) -> 'AppSecSecurityPolicy':
+            contract_id: Optional[pulumi.Input[str]] = None,
+            create_from_config_id: Optional[pulumi.Input[int]] = None,
+            create_from_version: Optional[pulumi.Input[int]] = None,
+            description: Optional[pulumi.Input[str]] = None,
+            group_id: Optional[pulumi.Input[int]] = None,
+            host_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+            name: Optional[pulumi.Input[str]] = None) -> 'AppSecConfiguration':
         """
-        Get an existing AppSecSecurityPolicy resource's state with the given name, id, and optional extra
+        Get an existing AppSecConfiguration resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration to be associated with the new security policy.
-        :param pulumi.Input[str] create_from_security_policy_id: . Unique identifier of the existing security policy that the new policy will be cloned from.
-        :param pulumi.Input[bool] default_settings: . Set to **true** to assign default setting values to the new policy; set to **false** to create a blank security policy. If not included, the new policy will be created using the default settings.
-        :param pulumi.Input[str] security_policy_id: Unique identifier of the new security policy
-        :param pulumi.Input[str] security_policy_name: . Name of the new security policy.
-        :param pulumi.Input[str] security_policy_prefix: . Four-character alphanumeric string prefix used in creating the security policy ID.
+        :param pulumi.Input[int] config_id: Unique identifier of the new security configuration
+        :param pulumi.Input[str] contract_id: Unique identifier of the Akamai contract associated with the new configuration
+        :param pulumi.Input[int] create_from_config_id: Unique identifier of the existing configuration being cloned to create the new configuration
+        :param pulumi.Input[int] create_from_version: Version number of the existing configuration being cloned to create the new configuration
+        :param pulumi.Input[str] description: Brief description of the new configuration
+        :param pulumi.Input[int] group_id: Unique identifier of the contract group associated with the new configuration
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] host_names: Hostnames to be protected by the new configuration
+        :param pulumi.Input[str] name: Name of the new configuration
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _AppSecSecurityPolicyState.__new__(_AppSecSecurityPolicyState)
+        __props__ = _AppSecConfigurationState.__new__(_AppSecConfigurationState)
 
         __props__.__dict__["config_id"] = config_id
-        __props__.__dict__["create_from_security_policy_id"] = create_from_security_policy_id
-        __props__.__dict__["default_settings"] = default_settings
-        __props__.__dict__["security_policy_id"] = security_policy_id
-        __props__.__dict__["security_policy_name"] = security_policy_name
-        __props__.__dict__["security_policy_prefix"] = security_policy_prefix
-        return AppSecSecurityPolicy(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["contract_id"] = contract_id
+        __props__.__dict__["create_from_config_id"] = create_from_config_id
+        __props__.__dict__["create_from_version"] = create_from_version
+        __props__.__dict__["description"] = description
+        __props__.__dict__["group_id"] = group_id
+        __props__.__dict__["host_names"] = host_names
+        __props__.__dict__["name"] = name
+        return AppSecConfiguration(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Output[int]:
         """
-        . Unique identifier of the security configuration to be associated with the new security policy.
+        Unique identifier of the new security configuration
         """
         return pulumi.get(self, "config_id")
 
     @property
-    @pulumi.getter(name="createFromSecurityPolicyId")
-    def create_from_security_policy_id(self) -> pulumi.Output[Optional[str]]:
+    @pulumi.getter(name="contractId")
+    def contract_id(self) -> pulumi.Output[str]:
+        """
+        Unique identifier of the Akamai contract associated with the new configuration
+        """
+        return pulumi.get(self, "contract_id")
+
+    @property
+    @pulumi.getter(name="createFromConfigId")
+    def create_from_config_id(self) -> pulumi.Output[Optional[int]]:
+        """
+        Unique identifier of the existing configuration being cloned to create the new configuration
+        """
+        return pulumi.get(self, "create_from_config_id")
+
+    @property
+    @pulumi.getter(name="createFromVersion")
+    def create_from_version(self) -> pulumi.Output[Optional[int]]:
         """
-        . Unique identifier of the existing security policy that the new policy will be cloned from.
+        Version number of the existing configuration being cloned to create the new configuration
         """
-        return pulumi.get(self, "create_from_security_policy_id")
+        return pulumi.get(self, "create_from_version")
 
     @property
-    @pulumi.getter(name="defaultSettings")
-    def default_settings(self) -> pulumi.Output[Optional[bool]]:
+    @pulumi.getter
+    def description(self) -> pulumi.Output[str]:
         """
-        . Set to **true** to assign default setting values to the new policy; set to **false** to create a blank security policy. If not included, the new policy will be created using the default settings.
+        Brief description of the new configuration
         """
-        return pulumi.get(self, "default_settings")
+        return pulumi.get(self, "description")
 
     @property
-    @pulumi.getter(name="securityPolicyId")
-    def security_policy_id(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="groupId")
+    def group_id(self) -> pulumi.Output[int]:
         """
-        Unique identifier of the new security policy
+        Unique identifier of the contract group associated with the new configuration
         """
-        return pulumi.get(self, "security_policy_id")
+        return pulumi.get(self, "group_id")
 
     @property
-    @pulumi.getter(name="securityPolicyName")
-    def security_policy_name(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="hostNames")
+    def host_names(self) -> pulumi.Output[Sequence[str]]:
         """
-        . Name of the new security policy.
+        Hostnames to be protected by the new configuration
         """
-        return pulumi.get(self, "security_policy_name")
+        return pulumi.get(self, "host_names")
 
     @property
-    @pulumi.getter(name="securityPolicyPrefix")
-    def security_policy_prefix(self) -> pulumi.Output[str]:
+    @pulumi.getter
+    def name(self) -> pulumi.Output[str]:
         """
-        . Four-character alphanumeric string prefix used in creating the security policy ID.
+        Name of the new configuration
         """
-        return pulumi.get(self, "security_policy_prefix")
+        return pulumi.get(self, "name")
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_security_policy_rename.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_security_policy_rename.py`

 * *Files 8% similar despite different names*

```diff
@@ -15,51 +15,51 @@
 class AppSecSecurityPolicyRenameArgs:
     def __init__(__self__, *,
                  config_id: pulumi.Input[int],
                  security_policy_id: pulumi.Input[str],
                  security_policy_name: pulumi.Input[str]):
         """
         The set of arguments for constructing a AppSecSecurityPolicyRename resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the security policy being renamed.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy being renamed.
-        :param pulumi.Input[str] security_policy_name: . New name to be given to the security policy.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
+        :param pulumi.Input[str] security_policy_name: New name to be given to the security policy
         """
         pulumi.set(__self__, "config_id", config_id)
         pulumi.set(__self__, "security_policy_id", security_policy_id)
         pulumi.set(__self__, "security_policy_name", security_policy_name)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuration associated with the security policy being renamed.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Input[str]:
         """
-        . Unique identifier of the security policy being renamed.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "security_policy_id", value)
 
     @property
     @pulumi.getter(name="securityPolicyName")
     def security_policy_name(self) -> pulumi.Input[str]:
         """
-        . New name to be given to the security policy.
+        New name to be given to the security policy
         """
         return pulumi.get(self, "security_policy_name")
 
     @security_policy_name.setter
     def security_policy_name(self, value: pulumi.Input[str]):
         pulumi.set(self, "security_policy_name", value)
 
@@ -68,54 +68,54 @@
 class _AppSecSecurityPolicyRenameState:
     def __init__(__self__, *,
                  config_id: Optional[pulumi.Input[int]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
                  security_policy_name: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering AppSecSecurityPolicyRename resources.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the security policy being renamed.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy being renamed.
-        :param pulumi.Input[str] security_policy_name: . New name to be given to the security policy.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
+        :param pulumi.Input[str] security_policy_name: New name to be given to the security policy
         """
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
         if security_policy_id is not None:
             pulumi.set(__self__, "security_policy_id", security_policy_id)
         if security_policy_name is not None:
             pulumi.set(__self__, "security_policy_name", security_policy_name)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security configuration associated with the security policy being renamed.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the security policy being renamed.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "security_policy_id", value)
 
     @property
     @pulumi.getter(name="securityPolicyName")
     def security_policy_name(self) -> Optional[pulumi.Input[str]]:
         """
-        . New name to be given to the security policy.
+        New name to be given to the security policy
         """
         return pulumi.get(self, "security_policy_name")
 
     @security_policy_name.setter
     def security_policy_name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "security_policy_name", value)
 
@@ -126,39 +126,29 @@
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
                  security_policy_name: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Security policy
-
-        Renames an existing security policy. Note that you can only change the name of the policy: once issued, the security policy ID can't be modified.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}](https://techdocs.akamai.com/application-security/reference/put-policy)
-
+        Create a AppSecSecurityPolicyRename resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the security policy being renamed.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy being renamed.
-        :param pulumi.Input[str] security_policy_name: . New name to be given to the security policy.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
+        :param pulumi.Input[str] security_policy_name: New name to be given to the security policy
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: AppSecSecurityPolicyRenameArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Security policy
-
-        Renames an existing security policy. Note that you can only change the name of the policy: once issued, the security policy ID can't be modified.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}](https://techdocs.akamai.com/application-security/reference/put-policy)
-
+        Create a AppSecSecurityPolicyRename resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param AppSecSecurityPolicyRenameArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(AppSecSecurityPolicyRenameArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -207,44 +197,44 @@
         """
         Get an existing AppSecSecurityPolicyRename resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the security policy being renamed.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy being renamed.
-        :param pulumi.Input[str] security_policy_name: . New name to be given to the security policy.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
+        :param pulumi.Input[str] security_policy_name: New name to be given to the security policy
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _AppSecSecurityPolicyRenameState.__new__(_AppSecSecurityPolicyRenameState)
 
         __props__.__dict__["config_id"] = config_id
         __props__.__dict__["security_policy_id"] = security_policy_id
         __props__.__dict__["security_policy_name"] = security_policy_name
         return AppSecSecurityPolicyRename(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Output[int]:
         """
-        . Unique identifier of the security configuration associated with the security policy being renamed.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Output[str]:
         """
-        . Unique identifier of the security policy being renamed.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @property
     @pulumi.getter(name="securityPolicyName")
     def security_policy_name(self) -> pulumi.Output[str]:
         """
-        . New name to be given to the security policy.
+        New name to be given to the security policy
         """
         return pulumi.get(self, "security_policy_name")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_version_nodes.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_advanced_settings_pragma_header.py`

 * *Files 20% similar despite different names*

```diff
@@ -5,266 +5,235 @@
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
-__all__ = ['AppSecVersionNodesArgs', 'AppSecVersionNodes']
+__all__ = ['AppSecAdvancedSettingsPragmaHeaderArgs', 'AppSecAdvancedSettingsPragmaHeader']
 
 @pulumi.input_type
-class AppSecVersionNodesArgs:
+class AppSecAdvancedSettingsPragmaHeaderArgs:
     def __init__(__self__, *,
                  config_id: pulumi.Input[int],
-                 version_notes: pulumi.Input[str]):
+                 pragma_header: pulumi.Input[str],
+                 security_policy_id: Optional[pulumi.Input[str]] = None):
         """
-        The set of arguments for constructing a AppSecVersionNodes resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration whose version notes are being modified.
-        :param pulumi.Input[str] version_notes: . Brief description of the security configuration version.
+        The set of arguments for constructing a AppSecAdvancedSettingsPragmaHeader resource.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] pragma_header: JSON-formatted information describing the conditions to exclude from the default remove action
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         pulumi.set(__self__, "config_id", config_id)
-        pulumi.set(__self__, "version_notes", version_notes)
+        pulumi.set(__self__, "pragma_header", pragma_header)
+        if security_policy_id is not None:
+            pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuration whose version notes are being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "config_id", value)
 
     @property
-    @pulumi.getter(name="versionNotes")
-    def version_notes(self) -> pulumi.Input[str]:
+    @pulumi.getter(name="pragmaHeader")
+    def pragma_header(self) -> pulumi.Input[str]:
         """
-        . Brief description of the security configuration version.
+        JSON-formatted information describing the conditions to exclude from the default remove action
         """
-        return pulumi.get(self, "version_notes")
+        return pulumi.get(self, "pragma_header")
 
-    @version_notes.setter
-    def version_notes(self, value: pulumi.Input[str]):
-        pulumi.set(self, "version_notes", value)
+    @pragma_header.setter
+    def pragma_header(self, value: pulumi.Input[str]):
+        pulumi.set(self, "pragma_header", value)
+
+    @property
+    @pulumi.getter(name="securityPolicyId")
+    def security_policy_id(self) -> Optional[pulumi.Input[str]]:
+        """
+        Unique identifier of the security policy
+        """
+        return pulumi.get(self, "security_policy_id")
+
+    @security_policy_id.setter
+    def security_policy_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "security_policy_id", value)
 
 
 @pulumi.input_type
-class _AppSecVersionNodesState:
+class _AppSecAdvancedSettingsPragmaHeaderState:
     def __init__(__self__, *,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 output_text: Optional[pulumi.Input[str]] = None,
-                 version_notes: Optional[pulumi.Input[str]] = None):
+                 pragma_header: Optional[pulumi.Input[str]] = None,
+                 security_policy_id: Optional[pulumi.Input[str]] = None):
         """
-        Input properties used for looking up and filtering AppSecVersionNodes resources.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration whose version notes are being modified.
-        :param pulumi.Input[str] output_text: Text representation
-        :param pulumi.Input[str] version_notes: . Brief description of the security configuration version.
+        Input properties used for looking up and filtering AppSecAdvancedSettingsPragmaHeader resources.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] pragma_header: JSON-formatted information describing the conditions to exclude from the default remove action
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
-        if output_text is not None:
-            pulumi.set(__self__, "output_text", output_text)
-        if version_notes is not None:
-            pulumi.set(__self__, "version_notes", version_notes)
+        if pragma_header is not None:
+            pulumi.set(__self__, "pragma_header", pragma_header)
+        if security_policy_id is not None:
+            pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security configuration whose version notes are being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "config_id", value)
 
     @property
-    @pulumi.getter(name="outputText")
-    def output_text(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="pragmaHeader")
+    def pragma_header(self) -> Optional[pulumi.Input[str]]:
         """
-        Text representation
+        JSON-formatted information describing the conditions to exclude from the default remove action
         """
-        return pulumi.get(self, "output_text")
+        return pulumi.get(self, "pragma_header")
 
-    @output_text.setter
-    def output_text(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "output_text", value)
+    @pragma_header.setter
+    def pragma_header(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "pragma_header", value)
 
     @property
-    @pulumi.getter(name="versionNotes")
-    def version_notes(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="securityPolicyId")
+    def security_policy_id(self) -> Optional[pulumi.Input[str]]:
         """
-        . Brief description of the security configuration version.
+        Unique identifier of the security policy
         """
-        return pulumi.get(self, "version_notes")
+        return pulumi.get(self, "security_policy_id")
 
-    @version_notes.setter
-    def version_notes(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "version_notes", value)
+    @security_policy_id.setter
+    def security_policy_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "security_policy_id", value)
 
 
-class AppSecVersionNodes(pulumi.CustomResource):
+class AppSecAdvancedSettingsPragmaHeader(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 version_notes: Optional[pulumi.Input[str]] = None,
+                 pragma_header: Optional[pulumi.Input[str]] = None,
+                 security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Security configuration
-
-        Updates the version notes for a security configuration.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/version-notes](https://techdocs.akamai.com/application-security/reference/put-version-notes)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        version_notes_app_sec_version_nodes = akamai.AppSecVersionNodes("versionNotesAppSecVersionNodes",
-            config_id=configuration.config_id,
-            version_notes="This version enables reputation profiles.")
-        pulumi.export("versionNotes", version_notes_app_sec_version_nodes.output_text)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `output_text`. Tabular report showing the updated version notes.
-
+        Create a AppSecAdvancedSettingsPragmaHeader resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration whose version notes are being modified.
-        :param pulumi.Input[str] version_notes: . Brief description of the security configuration version.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] pragma_header: JSON-formatted information describing the conditions to exclude from the default remove action
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: AppSecVersionNodesArgs,
+                 args: AppSecAdvancedSettingsPragmaHeaderArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Security configuration
-
-        Updates the version notes for a security configuration.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/version-notes](https://techdocs.akamai.com/application-security/reference/put-version-notes)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        version_notes_app_sec_version_nodes = akamai.AppSecVersionNodes("versionNotesAppSecVersionNodes",
-            config_id=configuration.config_id,
-            version_notes="This version enables reputation profiles.")
-        pulumi.export("versionNotes", version_notes_app_sec_version_nodes.output_text)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `output_text`. Tabular report showing the updated version notes.
-
+        Create a AppSecAdvancedSettingsPragmaHeader resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param AppSecVersionNodesArgs args: The arguments to use to populate this resource's properties.
+        :param AppSecAdvancedSettingsPragmaHeaderArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(AppSecVersionNodesArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(AppSecAdvancedSettingsPragmaHeaderArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 version_notes: Optional[pulumi.Input[str]] = None,
+                 pragma_header: Optional[pulumi.Input[str]] = None,
+                 security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = AppSecVersionNodesArgs.__new__(AppSecVersionNodesArgs)
+            __props__ = AppSecAdvancedSettingsPragmaHeaderArgs.__new__(AppSecAdvancedSettingsPragmaHeaderArgs)
 
             if config_id is None and not opts.urn:
                 raise TypeError("Missing required property 'config_id'")
             __props__.__dict__["config_id"] = config_id
-            if version_notes is None and not opts.urn:
-                raise TypeError("Missing required property 'version_notes'")
-            __props__.__dict__["version_notes"] = version_notes
-            __props__.__dict__["output_text"] = None
-        super(AppSecVersionNodes, __self__).__init__(
-            'akamai:index/appSecVersionNodes:AppSecVersionNodes',
+            if pragma_header is None and not opts.urn:
+                raise TypeError("Missing required property 'pragma_header'")
+            __props__.__dict__["pragma_header"] = pragma_header
+            __props__.__dict__["security_policy_id"] = security_policy_id
+        super(AppSecAdvancedSettingsPragmaHeader, __self__).__init__(
+            'akamai:index/appSecAdvancedSettingsPragmaHeader:AppSecAdvancedSettingsPragmaHeader',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
             config_id: Optional[pulumi.Input[int]] = None,
-            output_text: Optional[pulumi.Input[str]] = None,
-            version_notes: Optional[pulumi.Input[str]] = None) -> 'AppSecVersionNodes':
+            pragma_header: Optional[pulumi.Input[str]] = None,
+            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecAdvancedSettingsPragmaHeader':
         """
-        Get an existing AppSecVersionNodes resource's state with the given name, id, and optional extra
+        Get an existing AppSecAdvancedSettingsPragmaHeader resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration whose version notes are being modified.
-        :param pulumi.Input[str] output_text: Text representation
-        :param pulumi.Input[str] version_notes: . Brief description of the security configuration version.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] pragma_header: JSON-formatted information describing the conditions to exclude from the default remove action
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _AppSecVersionNodesState.__new__(_AppSecVersionNodesState)
+        __props__ = _AppSecAdvancedSettingsPragmaHeaderState.__new__(_AppSecAdvancedSettingsPragmaHeaderState)
 
         __props__.__dict__["config_id"] = config_id
-        __props__.__dict__["output_text"] = output_text
-        __props__.__dict__["version_notes"] = version_notes
-        return AppSecVersionNodes(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["pragma_header"] = pragma_header
+        __props__.__dict__["security_policy_id"] = security_policy_id
+        return AppSecAdvancedSettingsPragmaHeader(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Output[int]:
         """
-        . Unique identifier of the security configuration whose version notes are being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @property
-    @pulumi.getter(name="outputText")
-    def output_text(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="pragmaHeader")
+    def pragma_header(self) -> pulumi.Output[str]:
         """
-        Text representation
+        JSON-formatted information describing the conditions to exclude from the default remove action
         """
-        return pulumi.get(self, "output_text")
+        return pulumi.get(self, "pragma_header")
 
     @property
-    @pulumi.getter(name="versionNotes")
-    def version_notes(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="securityPolicyId")
+    def security_policy_id(self) -> pulumi.Output[Optional[str]]:
         """
-        . Brief description of the security configuration version.
+        Unique identifier of the security policy
         """
-        return pulumi.get(self, "version_notes")
+        return pulumi.get(self, "security_policy_id")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_waf_mode.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/property_include.py`

 * *Files 23% similar despite different names*

```diff
@@ -5,446 +5,565 @@
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
-__all__ = ['AppSecWafModeArgs', 'AppSecWafMode']
+__all__ = ['PropertyIncludeArgs', 'PropertyInclude']
 
 @pulumi.input_type
-class AppSecWafModeArgs:
+class PropertyIncludeArgs:
     def __init__(__self__, *,
-                 config_id: pulumi.Input[int],
-                 mode: pulumi.Input[str],
-                 security_policy_id: pulumi.Input[str]):
+                 contract_id: pulumi.Input[str],
+                 group_id: pulumi.Input[str],
+                 rule_format: pulumi.Input[str],
+                 type: pulumi.Input[str],
+                 name: Optional[pulumi.Input[str]] = None,
+                 product_id: Optional[pulumi.Input[str]] = None,
+                 rules: Optional[pulumi.Input[str]] = None):
         """
-        The set of arguments for constructing a AppSecWafMode resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the WAF mode settings being modified.
-        :param pulumi.Input[str] mode: . Specifies how Kona Rule Set rules are upgraded. Allowed values are:
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the WAF mode settings being modified.
+        The set of arguments for constructing a PropertyInclude resource.
+        :param pulumi.Input[str] contract_id: Identifies the contract to which the include is assigned
+        :param pulumi.Input[str] group_id: Identifies the group to which the include is assigned
+        :param pulumi.Input[str] rule_format: Indicates the versioned set of features and criteria
+        :param pulumi.Input[str] type: Specifies the type of the include, either 'MICROSERVICES' or 'COMMON_SETTINGS'
+        :param pulumi.Input[str] name: A descriptive name for the include
+        :param pulumi.Input[str] product_id: The product assigned to the include
+        :param pulumi.Input[str] rules: Property Rules as JSON
         """
-        pulumi.set(__self__, "config_id", config_id)
-        pulumi.set(__self__, "mode", mode)
-        pulumi.set(__self__, "security_policy_id", security_policy_id)
+        pulumi.set(__self__, "contract_id", contract_id)
+        pulumi.set(__self__, "group_id", group_id)
+        pulumi.set(__self__, "rule_format", rule_format)
+        pulumi.set(__self__, "type", type)
+        if name is not None:
+            pulumi.set(__self__, "name", name)
+        if product_id is not None:
+            pulumi.set(__self__, "product_id", product_id)
+        if rules is not None:
+            pulumi.set(__self__, "rules", rules)
 
     @property
-    @pulumi.getter(name="configId")
-    def config_id(self) -> pulumi.Input[int]:
+    @pulumi.getter(name="contractId")
+    def contract_id(self) -> pulumi.Input[str]:
         """
-        . Unique identifier of the security configuration associated with the WAF mode settings being modified.
+        Identifies the contract to which the include is assigned
         """
-        return pulumi.get(self, "config_id")
+        return pulumi.get(self, "contract_id")
 
-    @config_id.setter
-    def config_id(self, value: pulumi.Input[int]):
-        pulumi.set(self, "config_id", value)
+    @contract_id.setter
+    def contract_id(self, value: pulumi.Input[str]):
+        pulumi.set(self, "contract_id", value)
+
+    @property
+    @pulumi.getter(name="groupId")
+    def group_id(self) -> pulumi.Input[str]:
+        """
+        Identifies the group to which the include is assigned
+        """
+        return pulumi.get(self, "group_id")
+
+    @group_id.setter
+    def group_id(self, value: pulumi.Input[str]):
+        pulumi.set(self, "group_id", value)
+
+    @property
+    @pulumi.getter(name="ruleFormat")
+    def rule_format(self) -> pulumi.Input[str]:
+        """
+        Indicates the versioned set of features and criteria
+        """
+        return pulumi.get(self, "rule_format")
+
+    @rule_format.setter
+    def rule_format(self, value: pulumi.Input[str]):
+        pulumi.set(self, "rule_format", value)
+
+    @property
+    @pulumi.getter
+    def type(self) -> pulumi.Input[str]:
+        """
+        Specifies the type of the include, either 'MICROSERVICES' or 'COMMON_SETTINGS'
+        """
+        return pulumi.get(self, "type")
+
+    @type.setter
+    def type(self, value: pulumi.Input[str]):
+        pulumi.set(self, "type", value)
 
     @property
     @pulumi.getter
-    def mode(self) -> pulumi.Input[str]:
+    def name(self) -> Optional[pulumi.Input[str]]:
+        """
+        A descriptive name for the include
+        """
+        return pulumi.get(self, "name")
+
+    @name.setter
+    def name(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "name", value)
+
+    @property
+    @pulumi.getter(name="productId")
+    def product_id(self) -> Optional[pulumi.Input[str]]:
         """
-        . Specifies how Kona Rule Set rules are upgraded. Allowed values are:
+        The product assigned to the include
         """
-        return pulumi.get(self, "mode")
+        return pulumi.get(self, "product_id")
 
-    @mode.setter
-    def mode(self, value: pulumi.Input[str]):
-        pulumi.set(self, "mode", value)
+    @product_id.setter
+    def product_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "product_id", value)
 
     @property
-    @pulumi.getter(name="securityPolicyId")
-    def security_policy_id(self) -> pulumi.Input[str]:
+    @pulumi.getter
+    def rules(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the security policy associated with the WAF mode settings being modified.
+        Property Rules as JSON
         """
-        return pulumi.get(self, "security_policy_id")
+        return pulumi.get(self, "rules")
 
-    @security_policy_id.setter
-    def security_policy_id(self, value: pulumi.Input[str]):
-        pulumi.set(self, "security_policy_id", value)
+    @rules.setter
+    def rules(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "rules", value)
 
 
 @pulumi.input_type
-class _AppSecWafModeState:
+class _PropertyIncludeState:
     def __init__(__self__, *,
-                 config_id: Optional[pulumi.Input[int]] = None,
-                 current_ruleset: Optional[pulumi.Input[str]] = None,
-                 eval_expiration_date: Optional[pulumi.Input[str]] = None,
-                 eval_ruleset: Optional[pulumi.Input[str]] = None,
-                 eval_status: Optional[pulumi.Input[str]] = None,
-                 mode: Optional[pulumi.Input[str]] = None,
-                 output_text: Optional[pulumi.Input[str]] = None,
-                 security_policy_id: Optional[pulumi.Input[str]] = None):
+                 contract_id: Optional[pulumi.Input[str]] = None,
+                 group_id: Optional[pulumi.Input[str]] = None,
+                 latest_version: Optional[pulumi.Input[int]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
+                 product_id: Optional[pulumi.Input[str]] = None,
+                 production_version: Optional[pulumi.Input[str]] = None,
+                 rule_errors: Optional[pulumi.Input[str]] = None,
+                 rule_format: Optional[pulumi.Input[str]] = None,
+                 rule_warnings: Optional[pulumi.Input[str]] = None,
+                 rules: Optional[pulumi.Input[str]] = None,
+                 staging_version: Optional[pulumi.Input[str]] = None,
+                 type: Optional[pulumi.Input[str]] = None):
+        """
+        Input properties used for looking up and filtering PropertyInclude resources.
+        :param pulumi.Input[str] contract_id: Identifies the contract to which the include is assigned
+        :param pulumi.Input[str] group_id: Identifies the group to which the include is assigned
+        :param pulumi.Input[int] latest_version: Specifies the most recent version of the include
+        :param pulumi.Input[str] name: A descriptive name for the include
+        :param pulumi.Input[str] product_id: The product assigned to the include
+        :param pulumi.Input[str] production_version: The most recent version to be activated to the production network
+        :param pulumi.Input[str] rule_errors: Rule validation errors
+        :param pulumi.Input[str] rule_format: Indicates the versioned set of features and criteria
+        :param pulumi.Input[str] rule_warnings: Rule validation warnings
+        :param pulumi.Input[str] rules: Property Rules as JSON
+        :param pulumi.Input[str] staging_version: The most recent version to be activated to the staging network
+        :param pulumi.Input[str] type: Specifies the type of the include, either 'MICROSERVICES' or 'COMMON_SETTINGS'
+        """
+        if contract_id is not None:
+            pulumi.set(__self__, "contract_id", contract_id)
+        if group_id is not None:
+            pulumi.set(__self__, "group_id", group_id)
+        if latest_version is not None:
+            pulumi.set(__self__, "latest_version", latest_version)
+        if name is not None:
+            pulumi.set(__self__, "name", name)
+        if product_id is not None:
+            pulumi.set(__self__, "product_id", product_id)
+        if production_version is not None:
+            pulumi.set(__self__, "production_version", production_version)
+        if rule_errors is not None:
+            pulumi.set(__self__, "rule_errors", rule_errors)
+        if rule_format is not None:
+            pulumi.set(__self__, "rule_format", rule_format)
+        if rule_warnings is not None:
+            pulumi.set(__self__, "rule_warnings", rule_warnings)
+        if rules is not None:
+            pulumi.set(__self__, "rules", rules)
+        if staging_version is not None:
+            pulumi.set(__self__, "staging_version", staging_version)
+        if type is not None:
+            pulumi.set(__self__, "type", type)
+
+    @property
+    @pulumi.getter(name="contractId")
+    def contract_id(self) -> Optional[pulumi.Input[str]]:
+        """
+        Identifies the contract to which the include is assigned
+        """
+        return pulumi.get(self, "contract_id")
+
+    @contract_id.setter
+    def contract_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "contract_id", value)
+
+    @property
+    @pulumi.getter(name="groupId")
+    def group_id(self) -> Optional[pulumi.Input[str]]:
+        """
+        Identifies the group to which the include is assigned
+        """
+        return pulumi.get(self, "group_id")
+
+    @group_id.setter
+    def group_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "group_id", value)
+
+    @property
+    @pulumi.getter(name="latestVersion")
+    def latest_version(self) -> Optional[pulumi.Input[int]]:
+        """
+        Specifies the most recent version of the include
+        """
+        return pulumi.get(self, "latest_version")
+
+    @latest_version.setter
+    def latest_version(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "latest_version", value)
+
+    @property
+    @pulumi.getter
+    def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Input properties used for looking up and filtering AppSecWafMode resources.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the WAF mode settings being modified.
-        :param pulumi.Input[str] current_ruleset: Versioning information for the current Kona Rule Set
-        :param pulumi.Input[str] eval_expiration_date: Date on which the evaluation period ends, if applicable
-        :param pulumi.Input[str] eval_ruleset: Versioning information for the Kona Rule Set being evaluated, if applicable
-        :param pulumi.Input[str] eval_status: Whether an evaluation is currently in progress
-        :param pulumi.Input[str] mode: . Specifies how Kona Rule Set rules are upgraded. Allowed values are:
-        :param pulumi.Input[str] output_text: Text representation
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the WAF mode settings being modified.
+        A descriptive name for the include
         """
-        if config_id is not None:
-            pulumi.set(__self__, "config_id", config_id)
-        if current_ruleset is not None:
-            pulumi.set(__self__, "current_ruleset", current_ruleset)
-        if eval_expiration_date is not None:
-            pulumi.set(__self__, "eval_expiration_date", eval_expiration_date)
-        if eval_ruleset is not None:
-            pulumi.set(__self__, "eval_ruleset", eval_ruleset)
-        if eval_status is not None:
-            pulumi.set(__self__, "eval_status", eval_status)
-        if mode is not None:
-            pulumi.set(__self__, "mode", mode)
-        if output_text is not None:
-            pulumi.set(__self__, "output_text", output_text)
-        if security_policy_id is not None:
-            pulumi.set(__self__, "security_policy_id", security_policy_id)
+        return pulumi.get(self, "name")
+
+    @name.setter
+    def name(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "name", value)
 
     @property
-    @pulumi.getter(name="configId")
-    def config_id(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="productId")
+    def product_id(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the security configuration associated with the WAF mode settings being modified.
+        The product assigned to the include
         """
-        return pulumi.get(self, "config_id")
+        return pulumi.get(self, "product_id")
 
-    @config_id.setter
-    def config_id(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "config_id", value)
+    @product_id.setter
+    def product_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "product_id", value)
 
     @property
-    @pulumi.getter(name="currentRuleset")
-    def current_ruleset(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="productionVersion")
+    def production_version(self) -> Optional[pulumi.Input[str]]:
         """
-        Versioning information for the current Kona Rule Set
+        The most recent version to be activated to the production network
         """
-        return pulumi.get(self, "current_ruleset")
+        return pulumi.get(self, "production_version")
 
-    @current_ruleset.setter
-    def current_ruleset(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "current_ruleset", value)
+    @production_version.setter
+    def production_version(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "production_version", value)
 
     @property
-    @pulumi.getter(name="evalExpirationDate")
-    def eval_expiration_date(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="ruleErrors")
+    def rule_errors(self) -> Optional[pulumi.Input[str]]:
         """
-        Date on which the evaluation period ends, if applicable
+        Rule validation errors
         """
-        return pulumi.get(self, "eval_expiration_date")
+        return pulumi.get(self, "rule_errors")
 
-    @eval_expiration_date.setter
-    def eval_expiration_date(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "eval_expiration_date", value)
+    @rule_errors.setter
+    def rule_errors(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "rule_errors", value)
 
     @property
-    @pulumi.getter(name="evalRuleset")
-    def eval_ruleset(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="ruleFormat")
+    def rule_format(self) -> Optional[pulumi.Input[str]]:
         """
-        Versioning information for the Kona Rule Set being evaluated, if applicable
+        Indicates the versioned set of features and criteria
         """
-        return pulumi.get(self, "eval_ruleset")
+        return pulumi.get(self, "rule_format")
 
-    @eval_ruleset.setter
-    def eval_ruleset(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "eval_ruleset", value)
+    @rule_format.setter
+    def rule_format(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "rule_format", value)
 
     @property
-    @pulumi.getter(name="evalStatus")
-    def eval_status(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="ruleWarnings")
+    def rule_warnings(self) -> Optional[pulumi.Input[str]]:
         """
-        Whether an evaluation is currently in progress
+        Rule validation warnings
         """
-        return pulumi.get(self, "eval_status")
+        return pulumi.get(self, "rule_warnings")
 
-    @eval_status.setter
-    def eval_status(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "eval_status", value)
+    @rule_warnings.setter
+    def rule_warnings(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "rule_warnings", value)
 
     @property
     @pulumi.getter
-    def mode(self) -> Optional[pulumi.Input[str]]:
+    def rules(self) -> Optional[pulumi.Input[str]]:
         """
-        . Specifies how Kona Rule Set rules are upgraded. Allowed values are:
+        Property Rules as JSON
         """
-        return pulumi.get(self, "mode")
+        return pulumi.get(self, "rules")
 
-    @mode.setter
-    def mode(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "mode", value)
+    @rules.setter
+    def rules(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "rules", value)
 
     @property
-    @pulumi.getter(name="outputText")
-    def output_text(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="stagingVersion")
+    def staging_version(self) -> Optional[pulumi.Input[str]]:
         """
-        Text representation
+        The most recent version to be activated to the staging network
         """
-        return pulumi.get(self, "output_text")
+        return pulumi.get(self, "staging_version")
 
-    @output_text.setter
-    def output_text(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "output_text", value)
+    @staging_version.setter
+    def staging_version(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "staging_version", value)
 
     @property
-    @pulumi.getter(name="securityPolicyId")
-    def security_policy_id(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter
+    def type(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the security policy associated with the WAF mode settings being modified.
+        Specifies the type of the include, either 'MICROSERVICES' or 'COMMON_SETTINGS'
         """
-        return pulumi.get(self, "security_policy_id")
+        return pulumi.get(self, "type")
 
-    @security_policy_id.setter
-    def security_policy_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "security_policy_id", value)
+    @type.setter
+    def type(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "type", value)
 
 
-class AppSecWafMode(pulumi.CustomResource):
+class PropertyInclude(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 config_id: Optional[pulumi.Input[int]] = None,
-                 mode: Optional[pulumi.Input[str]] = None,
-                 security_policy_id: Optional[pulumi.Input[str]] = None,
+                 contract_id: Optional[pulumi.Input[str]] = None,
+                 group_id: Optional[pulumi.Input[str]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
+                 product_id: Optional[pulumi.Input[str]] = None,
+                 rule_format: Optional[pulumi.Input[str]] = None,
+                 rules: Optional[pulumi.Input[str]] = None,
+                 type: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Security policy
-
-        Modifies the way your Kona Rule Set rules are updated.
-        Use **KRS** mode to update the rule sets manually or **AAG** to have those rule sets automatically updated.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/mode](https://techdocs.akamai.com/application-security/reference/put-policy-mode)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        waf_mode = akamai.AppSecWafMode("wafMode",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            mode="KRS")
-        pulumi.export("wafModeMode", waf_mode.mode)
-        pulumi.export("wafModeCurrentRuleset", waf_mode.current_ruleset)
-        pulumi.export("wafModeEvalStatus", waf_mode.eval_status)
-        pulumi.export("wafModeEvalRuleset", waf_mode.eval_ruleset)
-        pulumi.export("wafModeEvalExpirationDate", waf_mode.eval_expiration_date)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `current_ruleset`  Versioning information for the current Kona Rule Set.
-        - `eval_ruleset`. Versioning information for the Kona Rule Set being evaluated (if applicable).
-        - `eval_status`. Returns **enabled** if an evaluation is currently in progress; otherwise returns **disabled**.
-        - `eval_expiration_date`. Date on which the evaluation period ends (if applicable).
-        - `output_text`. Tabular report showing the current rule set, WAF mode and evaluation status.
-
+        Create a PropertyInclude resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the WAF mode settings being modified.
-        :param pulumi.Input[str] mode: . Specifies how Kona Rule Set rules are upgraded. Allowed values are:
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the WAF mode settings being modified.
+        :param pulumi.Input[str] contract_id: Identifies the contract to which the include is assigned
+        :param pulumi.Input[str] group_id: Identifies the group to which the include is assigned
+        :param pulumi.Input[str] name: A descriptive name for the include
+        :param pulumi.Input[str] product_id: The product assigned to the include
+        :param pulumi.Input[str] rule_format: Indicates the versioned set of features and criteria
+        :param pulumi.Input[str] rules: Property Rules as JSON
+        :param pulumi.Input[str] type: Specifies the type of the include, either 'MICROSERVICES' or 'COMMON_SETTINGS'
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: AppSecWafModeArgs,
+                 args: PropertyIncludeArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Security policy
-
-        Modifies the way your Kona Rule Set rules are updated.
-        Use **KRS** mode to update the rule sets manually or **AAG** to have those rule sets automatically updated.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/mode](https://techdocs.akamai.com/application-security/reference/put-policy-mode)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        waf_mode = akamai.AppSecWafMode("wafMode",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            mode="KRS")
-        pulumi.export("wafModeMode", waf_mode.mode)
-        pulumi.export("wafModeCurrentRuleset", waf_mode.current_ruleset)
-        pulumi.export("wafModeEvalStatus", waf_mode.eval_status)
-        pulumi.export("wafModeEvalRuleset", waf_mode.eval_ruleset)
-        pulumi.export("wafModeEvalExpirationDate", waf_mode.eval_expiration_date)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `current_ruleset`  Versioning information for the current Kona Rule Set.
-        - `eval_ruleset`. Versioning information for the Kona Rule Set being evaluated (if applicable).
-        - `eval_status`. Returns **enabled** if an evaluation is currently in progress; otherwise returns **disabled**.
-        - `eval_expiration_date`. Date on which the evaluation period ends (if applicable).
-        - `output_text`. Tabular report showing the current rule set, WAF mode and evaluation status.
-
+        Create a PropertyInclude resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param AppSecWafModeArgs args: The arguments to use to populate this resource's properties.
+        :param PropertyIncludeArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(AppSecWafModeArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(PropertyIncludeArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 config_id: Optional[pulumi.Input[int]] = None,
-                 mode: Optional[pulumi.Input[str]] = None,
-                 security_policy_id: Optional[pulumi.Input[str]] = None,
+                 contract_id: Optional[pulumi.Input[str]] = None,
+                 group_id: Optional[pulumi.Input[str]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
+                 product_id: Optional[pulumi.Input[str]] = None,
+                 rule_format: Optional[pulumi.Input[str]] = None,
+                 rules: Optional[pulumi.Input[str]] = None,
+                 type: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = AppSecWafModeArgs.__new__(AppSecWafModeArgs)
+            __props__ = PropertyIncludeArgs.__new__(PropertyIncludeArgs)
 
-            if config_id is None and not opts.urn:
-                raise TypeError("Missing required property 'config_id'")
-            __props__.__dict__["config_id"] = config_id
-            if mode is None and not opts.urn:
-                raise TypeError("Missing required property 'mode'")
-            __props__.__dict__["mode"] = mode
-            if security_policy_id is None and not opts.urn:
-                raise TypeError("Missing required property 'security_policy_id'")
-            __props__.__dict__["security_policy_id"] = security_policy_id
-            __props__.__dict__["current_ruleset"] = None
-            __props__.__dict__["eval_expiration_date"] = None
-            __props__.__dict__["eval_ruleset"] = None
-            __props__.__dict__["eval_status"] = None
-            __props__.__dict__["output_text"] = None
-        super(AppSecWafMode, __self__).__init__(
-            'akamai:index/appSecWafMode:AppSecWafMode',
+            if contract_id is None and not opts.urn:
+                raise TypeError("Missing required property 'contract_id'")
+            __props__.__dict__["contract_id"] = contract_id
+            if group_id is None and not opts.urn:
+                raise TypeError("Missing required property 'group_id'")
+            __props__.__dict__["group_id"] = group_id
+            __props__.__dict__["name"] = name
+            __props__.__dict__["product_id"] = product_id
+            if rule_format is None and not opts.urn:
+                raise TypeError("Missing required property 'rule_format'")
+            __props__.__dict__["rule_format"] = rule_format
+            __props__.__dict__["rules"] = rules
+            if type is None and not opts.urn:
+                raise TypeError("Missing required property 'type'")
+            __props__.__dict__["type"] = type
+            __props__.__dict__["latest_version"] = None
+            __props__.__dict__["production_version"] = None
+            __props__.__dict__["rule_errors"] = None
+            __props__.__dict__["rule_warnings"] = None
+            __props__.__dict__["staging_version"] = None
+        super(PropertyInclude, __self__).__init__(
+            'akamai:index/propertyInclude:PropertyInclude',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
-            config_id: Optional[pulumi.Input[int]] = None,
-            current_ruleset: Optional[pulumi.Input[str]] = None,
-            eval_expiration_date: Optional[pulumi.Input[str]] = None,
-            eval_ruleset: Optional[pulumi.Input[str]] = None,
-            eval_status: Optional[pulumi.Input[str]] = None,
-            mode: Optional[pulumi.Input[str]] = None,
-            output_text: Optional[pulumi.Input[str]] = None,
-            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecWafMode':
+            contract_id: Optional[pulumi.Input[str]] = None,
+            group_id: Optional[pulumi.Input[str]] = None,
+            latest_version: Optional[pulumi.Input[int]] = None,
+            name: Optional[pulumi.Input[str]] = None,
+            product_id: Optional[pulumi.Input[str]] = None,
+            production_version: Optional[pulumi.Input[str]] = None,
+            rule_errors: Optional[pulumi.Input[str]] = None,
+            rule_format: Optional[pulumi.Input[str]] = None,
+            rule_warnings: Optional[pulumi.Input[str]] = None,
+            rules: Optional[pulumi.Input[str]] = None,
+            staging_version: Optional[pulumi.Input[str]] = None,
+            type: Optional[pulumi.Input[str]] = None) -> 'PropertyInclude':
         """
-        Get an existing AppSecWafMode resource's state with the given name, id, and optional extra
+        Get an existing PropertyInclude resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the WAF mode settings being modified.
-        :param pulumi.Input[str] current_ruleset: Versioning information for the current Kona Rule Set
-        :param pulumi.Input[str] eval_expiration_date: Date on which the evaluation period ends, if applicable
-        :param pulumi.Input[str] eval_ruleset: Versioning information for the Kona Rule Set being evaluated, if applicable
-        :param pulumi.Input[str] eval_status: Whether an evaluation is currently in progress
-        :param pulumi.Input[str] mode: . Specifies how Kona Rule Set rules are upgraded. Allowed values are:
-        :param pulumi.Input[str] output_text: Text representation
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the WAF mode settings being modified.
+        :param pulumi.Input[str] contract_id: Identifies the contract to which the include is assigned
+        :param pulumi.Input[str] group_id: Identifies the group to which the include is assigned
+        :param pulumi.Input[int] latest_version: Specifies the most recent version of the include
+        :param pulumi.Input[str] name: A descriptive name for the include
+        :param pulumi.Input[str] product_id: The product assigned to the include
+        :param pulumi.Input[str] production_version: The most recent version to be activated to the production network
+        :param pulumi.Input[str] rule_errors: Rule validation errors
+        :param pulumi.Input[str] rule_format: Indicates the versioned set of features and criteria
+        :param pulumi.Input[str] rule_warnings: Rule validation warnings
+        :param pulumi.Input[str] rules: Property Rules as JSON
+        :param pulumi.Input[str] staging_version: The most recent version to be activated to the staging network
+        :param pulumi.Input[str] type: Specifies the type of the include, either 'MICROSERVICES' or 'COMMON_SETTINGS'
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _AppSecWafModeState.__new__(_AppSecWafModeState)
+        __props__ = _PropertyIncludeState.__new__(_PropertyIncludeState)
 
-        __props__.__dict__["config_id"] = config_id
-        __props__.__dict__["current_ruleset"] = current_ruleset
-        __props__.__dict__["eval_expiration_date"] = eval_expiration_date
-        __props__.__dict__["eval_ruleset"] = eval_ruleset
-        __props__.__dict__["eval_status"] = eval_status
-        __props__.__dict__["mode"] = mode
-        __props__.__dict__["output_text"] = output_text
-        __props__.__dict__["security_policy_id"] = security_policy_id
-        return AppSecWafMode(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["contract_id"] = contract_id
+        __props__.__dict__["group_id"] = group_id
+        __props__.__dict__["latest_version"] = latest_version
+        __props__.__dict__["name"] = name
+        __props__.__dict__["product_id"] = product_id
+        __props__.__dict__["production_version"] = production_version
+        __props__.__dict__["rule_errors"] = rule_errors
+        __props__.__dict__["rule_format"] = rule_format
+        __props__.__dict__["rule_warnings"] = rule_warnings
+        __props__.__dict__["rules"] = rules
+        __props__.__dict__["staging_version"] = staging_version
+        __props__.__dict__["type"] = type
+        return PropertyInclude(resource_name, opts=opts, __props__=__props__)
 
     @property
-    @pulumi.getter(name="configId")
-    def config_id(self) -> pulumi.Output[int]:
+    @pulumi.getter(name="contractId")
+    def contract_id(self) -> pulumi.Output[str]:
         """
-        . Unique identifier of the security configuration associated with the WAF mode settings being modified.
+        Identifies the contract to which the include is assigned
         """
-        return pulumi.get(self, "config_id")
+        return pulumi.get(self, "contract_id")
 
     @property
-    @pulumi.getter(name="currentRuleset")
-    def current_ruleset(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="groupId")
+    def group_id(self) -> pulumi.Output[str]:
         """
-        Versioning information for the current Kona Rule Set
+        Identifies the group to which the include is assigned
         """
-        return pulumi.get(self, "current_ruleset")
+        return pulumi.get(self, "group_id")
 
     @property
-    @pulumi.getter(name="evalExpirationDate")
-    def eval_expiration_date(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="latestVersion")
+    def latest_version(self) -> pulumi.Output[int]:
+        """
+        Specifies the most recent version of the include
+        """
+        return pulumi.get(self, "latest_version")
+
+    @property
+    @pulumi.getter
+    def name(self) -> pulumi.Output[str]:
         """
-        Date on which the evaluation period ends, if applicable
+        A descriptive name for the include
         """
-        return pulumi.get(self, "eval_expiration_date")
+        return pulumi.get(self, "name")
 
     @property
-    @pulumi.getter(name="evalRuleset")
-    def eval_ruleset(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="productId")
+    def product_id(self) -> pulumi.Output[Optional[str]]:
         """
-        Versioning information for the Kona Rule Set being evaluated, if applicable
+        The product assigned to the include
         """
-        return pulumi.get(self, "eval_ruleset")
+        return pulumi.get(self, "product_id")
 
     @property
-    @pulumi.getter(name="evalStatus")
-    def eval_status(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="productionVersion")
+    def production_version(self) -> pulumi.Output[str]:
         """
-        Whether an evaluation is currently in progress
+        The most recent version to be activated to the production network
         """
-        return pulumi.get(self, "eval_status")
+        return pulumi.get(self, "production_version")
+
+    @property
+    @pulumi.getter(name="ruleErrors")
+    def rule_errors(self) -> pulumi.Output[str]:
+        """
+        Rule validation errors
+        """
+        return pulumi.get(self, "rule_errors")
+
+    @property
+    @pulumi.getter(name="ruleFormat")
+    def rule_format(self) -> pulumi.Output[str]:
+        """
+        Indicates the versioned set of features and criteria
+        """
+        return pulumi.get(self, "rule_format")
+
+    @property
+    @pulumi.getter(name="ruleWarnings")
+    def rule_warnings(self) -> pulumi.Output[str]:
+        """
+        Rule validation warnings
+        """
+        return pulumi.get(self, "rule_warnings")
 
     @property
     @pulumi.getter
-    def mode(self) -> pulumi.Output[str]:
+    def rules(self) -> pulumi.Output[str]:
         """
-        . Specifies how Kona Rule Set rules are upgraded. Allowed values are:
+        Property Rules as JSON
         """
-        return pulumi.get(self, "mode")
+        return pulumi.get(self, "rules")
 
     @property
-    @pulumi.getter(name="outputText")
-    def output_text(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="stagingVersion")
+    def staging_version(self) -> pulumi.Output[str]:
         """
-        Text representation
+        The most recent version to be activated to the staging network
         """
-        return pulumi.get(self, "output_text")
+        return pulumi.get(self, "staging_version")
 
     @property
-    @pulumi.getter(name="securityPolicyId")
-    def security_policy_id(self) -> pulumi.Output[str]:
+    @pulumi.getter
+    def type(self) -> pulumi.Output[str]:
         """
-        . Unique identifier of the security policy associated with the WAF mode settings being modified.
+        Specifies the type of the include, either 'MICROSERVICES' or 'COMMON_SETTINGS'
         """
-        return pulumi.get(self, "security_policy_id")
+        return pulumi.get(self, "type")
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_waf_protection.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_malware_policy_action.py`

 * *Files 26% similar despite different names*

```diff
@@ -5,314 +5,332 @@
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
-__all__ = ['AppSecWafProtectionArgs', 'AppSecWafProtection']
+__all__ = ['AppSecMalwarePolicyActionArgs', 'AppSecMalwarePolicyAction']
 
 @pulumi.input_type
-class AppSecWafProtectionArgs:
+class AppSecMalwarePolicyActionArgs:
     def __init__(__self__, *,
+                 action: pulumi.Input[str],
                  config_id: pulumi.Input[int],
-                 enabled: pulumi.Input[bool],
-                 security_policy_id: pulumi.Input[str]):
-        """
-        The set of arguments for constructing a AppSecWafProtection resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the WAF protection settings being modified.
-        :param pulumi.Input[bool] enabled: . Set to **true** to enable WAF protection; set to **false** to disable WAF protection.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the WAF protection settings being modified.
+                 malware_policy_id: pulumi.Input[int],
+                 security_policy_id: pulumi.Input[str],
+                 unscanned_action: pulumi.Input[str]):
+        """
+        The set of arguments for constructing a AppSecMalwarePolicyAction resource.
+        :param pulumi.Input[str] action: Action to be taken for requests scanned according to the malware policy
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[int] malware_policy_id: Unique identifier of the malware policy
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
+        :param pulumi.Input[str] unscanned_action: Action to be taken for requests not scanned according to the malware policy
         """
+        pulumi.set(__self__, "action", action)
         pulumi.set(__self__, "config_id", config_id)
-        pulumi.set(__self__, "enabled", enabled)
+        pulumi.set(__self__, "malware_policy_id", malware_policy_id)
         pulumi.set(__self__, "security_policy_id", security_policy_id)
+        pulumi.set(__self__, "unscanned_action", unscanned_action)
+
+    @property
+    @pulumi.getter
+    def action(self) -> pulumi.Input[str]:
+        """
+        Action to be taken for requests scanned according to the malware policy
+        """
+        return pulumi.get(self, "action")
+
+    @action.setter
+    def action(self, value: pulumi.Input[str]):
+        pulumi.set(self, "action", value)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuration associated with the WAF protection settings being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "config_id", value)
 
     @property
-    @pulumi.getter
-    def enabled(self) -> pulumi.Input[bool]:
+    @pulumi.getter(name="malwarePolicyId")
+    def malware_policy_id(self) -> pulumi.Input[int]:
         """
-        . Set to **true** to enable WAF protection; set to **false** to disable WAF protection.
+        Unique identifier of the malware policy
         """
-        return pulumi.get(self, "enabled")
+        return pulumi.get(self, "malware_policy_id")
 
-    @enabled.setter
-    def enabled(self, value: pulumi.Input[bool]):
-        pulumi.set(self, "enabled", value)
+    @malware_policy_id.setter
+    def malware_policy_id(self, value: pulumi.Input[int]):
+        pulumi.set(self, "malware_policy_id", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Input[str]:
         """
-        . Unique identifier of the security policy associated with the WAF protection settings being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "security_policy_id", value)
 
+    @property
+    @pulumi.getter(name="unscannedAction")
+    def unscanned_action(self) -> pulumi.Input[str]:
+        """
+        Action to be taken for requests not scanned according to the malware policy
+        """
+        return pulumi.get(self, "unscanned_action")
+
+    @unscanned_action.setter
+    def unscanned_action(self, value: pulumi.Input[str]):
+        pulumi.set(self, "unscanned_action", value)
+
 
 @pulumi.input_type
-class _AppSecWafProtectionState:
+class _AppSecMalwarePolicyActionState:
     def __init__(__self__, *,
+                 action: Optional[pulumi.Input[str]] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 enabled: Optional[pulumi.Input[bool]] = None,
-                 output_text: Optional[pulumi.Input[str]] = None,
-                 security_policy_id: Optional[pulumi.Input[str]] = None):
-        """
-        Input properties used for looking up and filtering AppSecWafProtection resources.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the WAF protection settings being modified.
-        :param pulumi.Input[bool] enabled: . Set to **true** to enable WAF protection; set to **false** to disable WAF protection.
-        :param pulumi.Input[str] output_text: Text representation
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the WAF protection settings being modified.
+                 malware_policy_id: Optional[pulumi.Input[int]] = None,
+                 security_policy_id: Optional[pulumi.Input[str]] = None,
+                 unscanned_action: Optional[pulumi.Input[str]] = None):
         """
+        Input properties used for looking up and filtering AppSecMalwarePolicyAction resources.
+        :param pulumi.Input[str] action: Action to be taken for requests scanned according to the malware policy
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[int] malware_policy_id: Unique identifier of the malware policy
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
+        :param pulumi.Input[str] unscanned_action: Action to be taken for requests not scanned according to the malware policy
+        """
+        if action is not None:
+            pulumi.set(__self__, "action", action)
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
-        if enabled is not None:
-            pulumi.set(__self__, "enabled", enabled)
-        if output_text is not None:
-            pulumi.set(__self__, "output_text", output_text)
+        if malware_policy_id is not None:
+            pulumi.set(__self__, "malware_policy_id", malware_policy_id)
         if security_policy_id is not None:
             pulumi.set(__self__, "security_policy_id", security_policy_id)
+        if unscanned_action is not None:
+            pulumi.set(__self__, "unscanned_action", unscanned_action)
+
+    @property
+    @pulumi.getter
+    def action(self) -> Optional[pulumi.Input[str]]:
+        """
+        Action to be taken for requests scanned according to the malware policy
+        """
+        return pulumi.get(self, "action")
+
+    @action.setter
+    def action(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "action", value)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security configuration associated with the WAF protection settings being modified.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "config_id", value)
 
     @property
-    @pulumi.getter
-    def enabled(self) -> Optional[pulumi.Input[bool]]:
+    @pulumi.getter(name="malwarePolicyId")
+    def malware_policy_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Set to **true** to enable WAF protection; set to **false** to disable WAF protection.
+        Unique identifier of the malware policy
         """
-        return pulumi.get(self, "enabled")
+        return pulumi.get(self, "malware_policy_id")
 
-    @enabled.setter
-    def enabled(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "enabled", value)
-
-    @property
-    @pulumi.getter(name="outputText")
-    def output_text(self) -> Optional[pulumi.Input[str]]:
-        """
-        Text representation
-        """
-        return pulumi.get(self, "output_text")
-
-    @output_text.setter
-    def output_text(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "output_text", value)
+    @malware_policy_id.setter
+    def malware_policy_id(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "malware_policy_id", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the security policy associated with the WAF protection settings being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "security_policy_id", value)
 
+    @property
+    @pulumi.getter(name="unscannedAction")
+    def unscanned_action(self) -> Optional[pulumi.Input[str]]:
+        """
+        Action to be taken for requests not scanned according to the malware policy
+        """
+        return pulumi.get(self, "unscanned_action")
+
+    @unscanned_action.setter
+    def unscanned_action(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "unscanned_action", value)
 
-class AppSecWafProtection(pulumi.CustomResource):
+
+class AppSecMalwarePolicyAction(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
+                 action: Optional[pulumi.Input[str]] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 enabled: Optional[pulumi.Input[bool]] = None,
+                 malware_policy_id: Optional[pulumi.Input[int]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
+                 unscanned_action: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        **Scopes**: Security policy
-
-        Enables or disables Web Application Firewall (WAF) protection for a security policy.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/put-policy-protections)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        protection = akamai.AppSecWafProtection("protection",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            enabled=True)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `output_text`. Tabular report showing the current protection settings.
-
+        Create a AppSecMalwarePolicyAction resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the WAF protection settings being modified.
-        :param pulumi.Input[bool] enabled: . Set to **true** to enable WAF protection; set to **false** to disable WAF protection.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the WAF protection settings being modified.
+        :param pulumi.Input[str] action: Action to be taken for requests scanned according to the malware policy
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[int] malware_policy_id: Unique identifier of the malware policy
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
+        :param pulumi.Input[str] unscanned_action: Action to be taken for requests not scanned according to the malware policy
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: AppSecWafProtectionArgs,
+                 args: AppSecMalwarePolicyActionArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        **Scopes**: Security policy
-
-        Enables or disables Web Application Firewall (WAF) protection for a security policy.
-
-        **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/protections](https://techdocs.akamai.com/application-security/reference/put-policy-protections)
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        protection = akamai.AppSecWafProtection("protection",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            enabled=True)
-        ```
-        ## Output Options
-
-        The following options can be used to determine the information returned, and how that returned information is formatted:
-
-        - `output_text`. Tabular report showing the current protection settings.
-
+        Create a AppSecMalwarePolicyAction resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param AppSecWafProtectionArgs args: The arguments to use to populate this resource's properties.
+        :param AppSecMalwarePolicyActionArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(AppSecWafProtectionArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(AppSecMalwarePolicyActionArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
+                 action: Optional[pulumi.Input[str]] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
-                 enabled: Optional[pulumi.Input[bool]] = None,
+                 malware_policy_id: Optional[pulumi.Input[int]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
+                 unscanned_action: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = AppSecWafProtectionArgs.__new__(AppSecWafProtectionArgs)
+            __props__ = AppSecMalwarePolicyActionArgs.__new__(AppSecMalwarePolicyActionArgs)
 
+            if action is None and not opts.urn:
+                raise TypeError("Missing required property 'action'")
+            __props__.__dict__["action"] = action
             if config_id is None and not opts.urn:
                 raise TypeError("Missing required property 'config_id'")
             __props__.__dict__["config_id"] = config_id
-            if enabled is None and not opts.urn:
-                raise TypeError("Missing required property 'enabled'")
-            __props__.__dict__["enabled"] = enabled
+            if malware_policy_id is None and not opts.urn:
+                raise TypeError("Missing required property 'malware_policy_id'")
+            __props__.__dict__["malware_policy_id"] = malware_policy_id
             if security_policy_id is None and not opts.urn:
                 raise TypeError("Missing required property 'security_policy_id'")
             __props__.__dict__["security_policy_id"] = security_policy_id
-            __props__.__dict__["output_text"] = None
-        super(AppSecWafProtection, __self__).__init__(
-            'akamai:index/appSecWafProtection:AppSecWafProtection',
+            if unscanned_action is None and not opts.urn:
+                raise TypeError("Missing required property 'unscanned_action'")
+            __props__.__dict__["unscanned_action"] = unscanned_action
+        super(AppSecMalwarePolicyAction, __self__).__init__(
+            'akamai:index/appSecMalwarePolicyAction:AppSecMalwarePolicyAction',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
+            action: Optional[pulumi.Input[str]] = None,
             config_id: Optional[pulumi.Input[int]] = None,
-            enabled: Optional[pulumi.Input[bool]] = None,
-            output_text: Optional[pulumi.Input[str]] = None,
-            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecWafProtection':
+            malware_policy_id: Optional[pulumi.Input[int]] = None,
+            security_policy_id: Optional[pulumi.Input[str]] = None,
+            unscanned_action: Optional[pulumi.Input[str]] = None) -> 'AppSecMalwarePolicyAction':
         """
-        Get an existing AppSecWafProtection resource's state with the given name, id, and optional extra
+        Get an existing AppSecMalwarePolicyAction resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the WAF protection settings being modified.
-        :param pulumi.Input[bool] enabled: . Set to **true** to enable WAF protection; set to **false** to disable WAF protection.
-        :param pulumi.Input[str] output_text: Text representation
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy associated with the WAF protection settings being modified.
+        :param pulumi.Input[str] action: Action to be taken for requests scanned according to the malware policy
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[int] malware_policy_id: Unique identifier of the malware policy
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
+        :param pulumi.Input[str] unscanned_action: Action to be taken for requests not scanned according to the malware policy
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _AppSecWafProtectionState.__new__(_AppSecWafProtectionState)
+        __props__ = _AppSecMalwarePolicyActionState.__new__(_AppSecMalwarePolicyActionState)
 
+        __props__.__dict__["action"] = action
         __props__.__dict__["config_id"] = config_id
-        __props__.__dict__["enabled"] = enabled
-        __props__.__dict__["output_text"] = output_text
+        __props__.__dict__["malware_policy_id"] = malware_policy_id
         __props__.__dict__["security_policy_id"] = security_policy_id
-        return AppSecWafProtection(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["unscanned_action"] = unscanned_action
+        return AppSecMalwarePolicyAction(resource_name, opts=opts, __props__=__props__)
 
     @property
-    @pulumi.getter(name="configId")
-    def config_id(self) -> pulumi.Output[int]:
+    @pulumi.getter
+    def action(self) -> pulumi.Output[str]:
         """
-        . Unique identifier of the security configuration associated with the WAF protection settings being modified.
+        Action to be taken for requests scanned according to the malware policy
         """
-        return pulumi.get(self, "config_id")
+        return pulumi.get(self, "action")
 
     @property
-    @pulumi.getter
-    def enabled(self) -> pulumi.Output[bool]:
+    @pulumi.getter(name="configId")
+    def config_id(self) -> pulumi.Output[int]:
         """
-        . Set to **true** to enable WAF protection; set to **false** to disable WAF protection.
+        Unique identifier of the security configuration
         """
-        return pulumi.get(self, "enabled")
+        return pulumi.get(self, "config_id")
 
     @property
-    @pulumi.getter(name="outputText")
-    def output_text(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="malwarePolicyId")
+    def malware_policy_id(self) -> pulumi.Output[int]:
         """
-        Text representation
+        Unique identifier of the malware policy
         """
-        return pulumi.get(self, "output_text")
+        return pulumi.get(self, "malware_policy_id")
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Output[str]:
         """
-        . Unique identifier of the security policy associated with the WAF protection settings being modified.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
+    @property
+    @pulumi.getter(name="unscannedAction")
+    def unscanned_action(self) -> pulumi.Output[str]:
+        """
+        Action to be taken for requests not scanned according to the malware policy
+        """
+        return pulumi.get(self, "unscanned_action")
+
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/app_sec_wap_selected_hostnames.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_wap_selected_hostnames.py`

 * *Files 20% similar despite different names*

```diff
@@ -16,43 +16,43 @@
     def __init__(__self__, *,
                  config_id: pulumi.Input[int],
                  security_policy_id: pulumi.Input[str],
                  evaluated_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  protected_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
         """
         The set of arguments for constructing a AppSecWapSelectedHostnames resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the hostnames being protected or evaluated.
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy responsible for protecting or evaluating the specified hosts.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         :param pulumi.Input[Sequence[pulumi.Input[str]]] evaluated_hosts: List of hostnames to be evaluated
         :param pulumi.Input[Sequence[pulumi.Input[str]]] protected_hosts: List of hostnames to be protected
         """
         pulumi.set(__self__, "config_id", config_id)
         pulumi.set(__self__, "security_policy_id", security_policy_id)
         if evaluated_hosts is not None:
             pulumi.set(__self__, "evaluated_hosts", evaluated_hosts)
         if protected_hosts is not None:
             pulumi.set(__self__, "protected_hosts", protected_hosts)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Input[int]:
         """
-        . Unique identifier of the security configuration associated with the hostnames being protected or evaluated.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Input[str]:
         """
-        . Unique identifier of the security policy responsible for protecting or evaluating the specified hosts.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "security_policy_id", value)
 
@@ -86,33 +86,33 @@
     def __init__(__self__, *,
                  config_id: Optional[pulumi.Input[int]] = None,
                  evaluated_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  protected_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering AppSecWapSelectedHostnames resources.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the hostnames being protected or evaluated.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
         :param pulumi.Input[Sequence[pulumi.Input[str]]] evaluated_hosts: List of hostnames to be evaluated
         :param pulumi.Input[Sequence[pulumi.Input[str]]] protected_hosts: List of hostnames to be protected
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy responsible for protecting or evaluating the specified hosts.
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
         if evaluated_hosts is not None:
             pulumi.set(__self__, "evaluated_hosts", evaluated_hosts)
         if protected_hosts is not None:
             pulumi.set(__self__, "protected_hosts", protected_hosts)
         if security_policy_id is not None:
             pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[int]]:
         """
-        . Unique identifier of the security configuration associated with the hostnames being protected or evaluated.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "config_id", value)
 
@@ -140,15 +140,15 @@
     def protected_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "protected_hosts", value)
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> Optional[pulumi.Input[str]]:
         """
-        . Unique identifier of the security policy responsible for protecting or evaluating the specified hosts.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
 
     @security_policy_id.setter
     def security_policy_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "security_policy_id", value)
 
@@ -160,60 +160,30 @@
                  opts: Optional[pulumi.ResourceOptions] = None,
                  config_id: Optional[pulumi.Input[int]] = None,
                  evaluated_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  protected_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  security_policy_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        appsecwap_selectedhostnames = akamai.AppSecWapSelectedHostnames("appsecwapSelectedhostnames",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            protected_hosts=["documentation.akamai.com"],
-            evaluated_hosts=["training.akamai.com"])
-        ```
-
+        Create a AppSecWapSelectedHostnames resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the hostnames being protected or evaluated.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
         :param pulumi.Input[Sequence[pulumi.Input[str]]] evaluated_hosts: List of hostnames to be evaluated
         :param pulumi.Input[Sequence[pulumi.Input[str]]] protected_hosts: List of hostnames to be protected
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy responsible for protecting or evaluating the specified hosts.
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: AppSecWapSelectedHostnamesArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        configuration = akamai.get_app_sec_configuration(name="Documentation")
-        appsecwap_selectedhostnames = akamai.AppSecWapSelectedHostnames("appsecwapSelectedhostnames",
-            config_id=configuration.config_id,
-            security_policy_id="gms1_134637",
-            protected_hosts=["documentation.akamai.com"],
-            evaluated_hosts=["training.akamai.com"])
-        ```
-
+        Create a AppSecWapSelectedHostnames resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param AppSecWapSelectedHostnamesArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(AppSecWapSelectedHostnamesArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -263,18 +233,18 @@
         """
         Get an existing AppSecWapSelectedHostnames resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] config_id: . Unique identifier of the security configuration associated with the hostnames being protected or evaluated.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
         :param pulumi.Input[Sequence[pulumi.Input[str]]] evaluated_hosts: List of hostnames to be evaluated
         :param pulumi.Input[Sequence[pulumi.Input[str]]] protected_hosts: List of hostnames to be protected
-        :param pulumi.Input[str] security_policy_id: . Unique identifier of the security policy responsible for protecting or evaluating the specified hosts.
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _AppSecWapSelectedHostnamesState.__new__(_AppSecWapSelectedHostnamesState)
 
         __props__.__dict__["config_id"] = config_id
         __props__.__dict__["evaluated_hosts"] = evaluated_hosts
@@ -282,15 +252,15 @@
         __props__.__dict__["security_policy_id"] = security_policy_id
         return AppSecWapSelectedHostnames(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> pulumi.Output[int]:
         """
-        . Unique identifier of the security configuration associated with the hostnames being protected or evaluated.
+        Unique identifier of the security configuration
         """
         return pulumi.get(self, "config_id")
 
     @property
     @pulumi.getter(name="evaluatedHosts")
     def evaluated_hosts(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
@@ -306,11 +276,11 @@
         """
         return pulumi.get(self, "protected_hosts")
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> pulumi.Output[str]:
         """
-        . Unique identifier of the security policy responsible for protecting or evaluating the specified hosts.
+        Unique identifier of the security policy
         """
         return pulumi.get(self, "security_policy_id")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/cloudlets_application_load_balancer_activation.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/cloudlets_application_load_balancer_activation.py`

 * *Files 27% similar despite different names*

```diff
@@ -15,51 +15,51 @@
 class CloudletsApplicationLoadBalancerActivationArgs:
     def __init__(__self__, *,
                  network: pulumi.Input[str],
                  origin_id: pulumi.Input[str],
                  version: pulumi.Input[int]):
         """
         The set of arguments for constructing a CloudletsApplicationLoadBalancerActivation resource.
-        :param pulumi.Input[str] network: The network you want to activate the policy version on, either `staging`, `stag`,  and `s` for the Staging network, or `production`, `prod`, and `p` for the Production network. All values are case insensitive.
-        :param pulumi.Input[str] origin_id: The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.
-        :param pulumi.Input[int] version: The Application Load Balancer Cloudlet configuration version you want to activate.
+        :param pulumi.Input[str] network: The network you want to activate the application load balancer version on (options are Staging and Production)
+        :param pulumi.Input[str] origin_id: The conditional origins unique identifier
+        :param pulumi.Input[int] version: Cloudlets application load balancer version you want to activate
         """
         pulumi.set(__self__, "network", network)
         pulumi.set(__self__, "origin_id", origin_id)
         pulumi.set(__self__, "version", version)
 
     @property
     @pulumi.getter
     def network(self) -> pulumi.Input[str]:
         """
-        The network you want to activate the policy version on, either `staging`, `stag`,  and `s` for the Staging network, or `production`, `prod`, and `p` for the Production network. All values are case insensitive.
+        The network you want to activate the application load balancer version on (options are Staging and Production)
         """
         return pulumi.get(self, "network")
 
     @network.setter
     def network(self, value: pulumi.Input[str]):
         pulumi.set(self, "network", value)
 
     @property
     @pulumi.getter(name="originId")
     def origin_id(self) -> pulumi.Input[str]:
         """
-        The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.
+        The conditional origins unique identifier
         """
         return pulumi.get(self, "origin_id")
 
     @origin_id.setter
     def origin_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "origin_id", value)
 
     @property
     @pulumi.getter
     def version(self) -> pulumi.Input[int]:
         """
-        The Application Load Balancer Cloudlet configuration version you want to activate.
+        Cloudlets application load balancer version you want to activate
         """
         return pulumi.get(self, "version")
 
     @version.setter
     def version(self, value: pulumi.Input[int]):
         pulumi.set(self, "version", value)
 
@@ -69,69 +69,69 @@
     def __init__(__self__, *,
                  network: Optional[pulumi.Input[str]] = None,
                  origin_id: Optional[pulumi.Input[str]] = None,
                  status: Optional[pulumi.Input[str]] = None,
                  version: Optional[pulumi.Input[int]] = None):
         """
         Input properties used for looking up and filtering CloudletsApplicationLoadBalancerActivation resources.
-        :param pulumi.Input[str] network: The network you want to activate the policy version on, either `staging`, `stag`,  and `s` for the Staging network, or `production`, `prod`, and `p` for the Production network. All values are case insensitive.
-        :param pulumi.Input[str] origin_id: The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.
-        :param pulumi.Input[str] status: The activation status for this load balancing configuration.
-        :param pulumi.Input[int] version: The Application Load Balancer Cloudlet configuration version you want to activate.
+        :param pulumi.Input[str] network: The network you want to activate the application load balancer version on (options are Staging and Production)
+        :param pulumi.Input[str] origin_id: The conditional origins unique identifier
+        :param pulumi.Input[str] status: Activation status for this application load balancer
+        :param pulumi.Input[int] version: Cloudlets application load balancer version you want to activate
         """
         if network is not None:
             pulumi.set(__self__, "network", network)
         if origin_id is not None:
             pulumi.set(__self__, "origin_id", origin_id)
         if status is not None:
             pulumi.set(__self__, "status", status)
         if version is not None:
             pulumi.set(__self__, "version", version)
 
     @property
     @pulumi.getter
     def network(self) -> Optional[pulumi.Input[str]]:
         """
-        The network you want to activate the policy version on, either `staging`, `stag`,  and `s` for the Staging network, or `production`, `prod`, and `p` for the Production network. All values are case insensitive.
+        The network you want to activate the application load balancer version on (options are Staging and Production)
         """
         return pulumi.get(self, "network")
 
     @network.setter
     def network(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "network", value)
 
     @property
     @pulumi.getter(name="originId")
     def origin_id(self) -> Optional[pulumi.Input[str]]:
         """
-        The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.
+        The conditional origins unique identifier
         """
         return pulumi.get(self, "origin_id")
 
     @origin_id.setter
     def origin_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "origin_id", value)
 
     @property
     @pulumi.getter
     def status(self) -> Optional[pulumi.Input[str]]:
         """
-        The activation status for this load balancing configuration.
+        Activation status for this application load balancer
         """
         return pulumi.get(self, "status")
 
     @status.setter
     def status(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "status", value)
 
     @property
     @pulumi.getter
     def version(self) -> Optional[pulumi.Input[int]]:
         """
-        The Application Load Balancer Cloudlet configuration version you want to activate.
+        Cloudlets application load balancer version you want to activate
         """
         return pulumi.get(self, "version")
 
     @version.setter
     def version(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "version", value)
 
@@ -142,65 +142,29 @@
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  network: Optional[pulumi.Input[str]] = None,
                  origin_id: Optional[pulumi.Input[str]] = None,
                  version: Optional[pulumi.Input[int]] = None,
                  __props__=None):
         """
-        Use the `CloudletsApplicationLoadBalancerActivation` resource to activate the Application Load Balancer Cloudlet configuration. An activation deploys the configuration version to either the Akamai staging or production network. You can activate a specific version multiple times if you need to.
-
-        Before activating on production, activate on staging first. This way you can detect any problems in staging before your changes progress to production.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        example = akamai.CloudletsApplicationLoadBalancerActivation("example",
-            origin_id="alb_test_1",
-            network="staging",
-            version=1)
-        pulumi.export("status", example.status)
-        ```
-
+        Create a CloudletsApplicationLoadBalancerActivation resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] network: The network you want to activate the policy version on, either `staging`, `stag`,  and `s` for the Staging network, or `production`, `prod`, and `p` for the Production network. All values are case insensitive.
-        :param pulumi.Input[str] origin_id: The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.
-        :param pulumi.Input[int] version: The Application Load Balancer Cloudlet configuration version you want to activate.
+        :param pulumi.Input[str] network: The network you want to activate the application load balancer version on (options are Staging and Production)
+        :param pulumi.Input[str] origin_id: The conditional origins unique identifier
+        :param pulumi.Input[int] version: Cloudlets application load balancer version you want to activate
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: CloudletsApplicationLoadBalancerActivationArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        Use the `CloudletsApplicationLoadBalancerActivation` resource to activate the Application Load Balancer Cloudlet configuration. An activation deploys the configuration version to either the Akamai staging or production network. You can activate a specific version multiple times if you need to.
-
-        Before activating on production, activate on staging first. This way you can detect any problems in staging before your changes progress to production.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        example = akamai.CloudletsApplicationLoadBalancerActivation("example",
-            origin_id="alb_test_1",
-            network="staging",
-            version=1)
-        pulumi.export("status", example.status)
-        ```
-
+        Create a CloudletsApplicationLoadBalancerActivation resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param CloudletsApplicationLoadBalancerActivationArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(CloudletsApplicationLoadBalancerActivationArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -251,18 +215,18 @@
         """
         Get an existing CloudletsApplicationLoadBalancerActivation resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] network: The network you want to activate the policy version on, either `staging`, `stag`,  and `s` for the Staging network, or `production`, `prod`, and `p` for the Production network. All values are case insensitive.
-        :param pulumi.Input[str] origin_id: The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.
-        :param pulumi.Input[str] status: The activation status for this load balancing configuration.
-        :param pulumi.Input[int] version: The Application Load Balancer Cloudlet configuration version you want to activate.
+        :param pulumi.Input[str] network: The network you want to activate the application load balancer version on (options are Staging and Production)
+        :param pulumi.Input[str] origin_id: The conditional origins unique identifier
+        :param pulumi.Input[str] status: Activation status for this application load balancer
+        :param pulumi.Input[int] version: Cloudlets application load balancer version you want to activate
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _CloudletsApplicationLoadBalancerActivationState.__new__(_CloudletsApplicationLoadBalancerActivationState)
 
         __props__.__dict__["network"] = network
         __props__.__dict__["origin_id"] = origin_id
@@ -270,35 +234,35 @@
         __props__.__dict__["version"] = version
         return CloudletsApplicationLoadBalancerActivation(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter
     def network(self) -> pulumi.Output[str]:
         """
-        The network you want to activate the policy version on, either `staging`, `stag`,  and `s` for the Staging network, or `production`, `prod`, and `p` for the Production network. All values are case insensitive.
+        The network you want to activate the application load balancer version on (options are Staging and Production)
         """
         return pulumi.get(self, "network")
 
     @property
     @pulumi.getter(name="originId")
     def origin_id(self) -> pulumi.Output[str]:
         """
-        The identifier of an origin that represents the data center. The Conditional Origin, which is defined in Property Manager, must have an origin type of either `CUSTOMER` or `NET_STORAGE` set in the `origin` behavior. See property rules for more information.
+        The conditional origins unique identifier
         """
         return pulumi.get(self, "origin_id")
 
     @property
     @pulumi.getter
     def status(self) -> pulumi.Output[str]:
         """
-        The activation status for this load balancing configuration.
+        Activation status for this application load balancer
         """
         return pulumi.get(self, "status")
 
     @property
     @pulumi.getter
     def version(self) -> pulumi.Output[int]:
         """
-        The Application Load Balancer Cloudlet configuration version you want to activate.
+        Cloudlets application load balancer version you want to activate
         """
         return pulumi.get(self, "version")
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/config/outputs.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/config/outputs.py`

 * *Files identical despite different names*

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/config/vars.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/config/vars.py`

 * *Files 3% similar despite different names*

```diff
@@ -75,7 +75,14 @@
     def property(self) -> Optional[str]:
         return __config__.get('property')
 
     @property
     def property_section(self) -> Optional[str]:
         return __config__.get('propertySection')
 
+    @property
+    def request_limit(self) -> Optional[int]:
+        """
+        The maximum number of API requests to be made per second (0 for no limit)
+        """
+        return __config__.get_int('requestLimit')
+
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/cp_code.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/edgedns/dns_zone.py`

 * *Files 18% similar despite different names*

```diff
@@ -3,541 +3,539 @@
 # *** Do not edit by hand unless you're certain you know what you are doing! ***
 
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
-from . import _utilities
+from .. import _utilities
+from . import outputs
+from ._inputs import *
 
-__all__ = ['CpCodeArgs', 'CpCode']
+__all__ = ['DnsZoneArgs', 'DnsZone']
 
 @pulumi.input_type
-class CpCodeArgs:
+class DnsZoneArgs:
     def __init__(__self__, *,
-                 contract: Optional[pulumi.Input[str]] = None,
-                 contract_id: Optional[pulumi.Input[str]] = None,
+                 contract: pulumi.Input[str],
+                 type: pulumi.Input[str],
+                 zone: pulumi.Input[str],
+                 comment: Optional[pulumi.Input[str]] = None,
+                 end_customer_id: Optional[pulumi.Input[str]] = None,
                  group: Optional[pulumi.Input[str]] = None,
-                 group_id: Optional[pulumi.Input[str]] = None,
-                 name: Optional[pulumi.Input[str]] = None,
-                 product: Optional[pulumi.Input[str]] = None,
-                 product_id: Optional[pulumi.Input[str]] = None):
-        """
-        The set of arguments for constructing a CpCode resource.
-        :param pulumi.Input[str] contract: Replaced by `contract_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] contract_id: (Required) A contract's unique ID, including the `ctr_` prefix.
-        :param pulumi.Input[str] group: Replaced by `group_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] group_id: (Required) A group's unique ID, including the `grp_` prefix.
-        :param pulumi.Input[str] name: (Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.
-        :param pulumi.Input[str] product: Replaced by `product_id`. Maintained for legacy purposes.
-        """
-        if contract is not None:
-            warnings.warn("""The setting \"contract\" has been deprecated.""", DeprecationWarning)
-            pulumi.log.warn("""contract is deprecated: The setting \"contract\" has been deprecated.""")
-        if contract is not None:
-            pulumi.set(__self__, "contract", contract)
-        if contract_id is not None:
-            pulumi.set(__self__, "contract_id", contract_id)
-        if group is not None:
-            warnings.warn("""The setting \"group\" has been deprecated.""", DeprecationWarning)
-            pulumi.log.warn("""group is deprecated: The setting \"group\" has been deprecated.""")
+                 masters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 sign_and_serve: Optional[pulumi.Input[bool]] = None,
+                 sign_and_serve_algorithm: Optional[pulumi.Input[str]] = None,
+                 target: Optional[pulumi.Input[str]] = None,
+                 tsig_key: Optional[pulumi.Input['DnsZoneTsigKeyArgs']] = None):
+        """
+        The set of arguments for constructing a DnsZone resource.
+        """
+        pulumi.set(__self__, "contract", contract)
+        pulumi.set(__self__, "type", type)
+        pulumi.set(__self__, "zone", zone)
+        if comment is not None:
+            pulumi.set(__self__, "comment", comment)
+        if end_customer_id is not None:
+            pulumi.set(__self__, "end_customer_id", end_customer_id)
         if group is not None:
             pulumi.set(__self__, "group", group)
-        if group_id is not None:
-            pulumi.set(__self__, "group_id", group_id)
-        if name is not None:
-            pulumi.set(__self__, "name", name)
-        if product is not None:
-            warnings.warn("""The setting \"product\" has been deprecated.""", DeprecationWarning)
-            pulumi.log.warn("""product is deprecated: The setting \"product\" has been deprecated.""")
-        if product is not None:
-            pulumi.set(__self__, "product", product)
-        if product_id is not None:
-            pulumi.set(__self__, "product_id", product_id)
+        if masters is not None:
+            pulumi.set(__self__, "masters", masters)
+        if sign_and_serve is not None:
+            pulumi.set(__self__, "sign_and_serve", sign_and_serve)
+        if sign_and_serve_algorithm is not None:
+            pulumi.set(__self__, "sign_and_serve_algorithm", sign_and_serve_algorithm)
+        if target is not None:
+            pulumi.set(__self__, "target", target)
+        if tsig_key is not None:
+            pulumi.set(__self__, "tsig_key", tsig_key)
 
     @property
     @pulumi.getter
-    def contract(self) -> Optional[pulumi.Input[str]]:
-        """
-        Replaced by `contract_id`. Maintained for legacy purposes.
-        """
+    def contract(self) -> pulumi.Input[str]:
         return pulumi.get(self, "contract")
 
     @contract.setter
-    def contract(self, value: Optional[pulumi.Input[str]]):
+    def contract(self, value: pulumi.Input[str]):
         pulumi.set(self, "contract", value)
 
     @property
-    @pulumi.getter(name="contractId")
-    def contract_id(self) -> Optional[pulumi.Input[str]]:
-        """
-        (Required) A contract's unique ID, including the `ctr_` prefix.
-        """
-        return pulumi.get(self, "contract_id")
+    @pulumi.getter
+    def type(self) -> pulumi.Input[str]:
+        return pulumi.get(self, "type")
+
+    @type.setter
+    def type(self, value: pulumi.Input[str]):
+        pulumi.set(self, "type", value)
+
+    @property
+    @pulumi.getter
+    def zone(self) -> pulumi.Input[str]:
+        return pulumi.get(self, "zone")
 
-    @contract_id.setter
-    def contract_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "contract_id", value)
+    @zone.setter
+    def zone(self, value: pulumi.Input[str]):
+        pulumi.set(self, "zone", value)
+
+    @property
+    @pulumi.getter
+    def comment(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "comment")
+
+    @comment.setter
+    def comment(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "comment", value)
+
+    @property
+    @pulumi.getter(name="endCustomerId")
+    def end_customer_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "end_customer_id")
+
+    @end_customer_id.setter
+    def end_customer_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "end_customer_id", value)
 
     @property
     @pulumi.getter
     def group(self) -> Optional[pulumi.Input[str]]:
-        """
-        Replaced by `group_id`. Maintained for legacy purposes.
-        """
         return pulumi.get(self, "group")
 
     @group.setter
     def group(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "group", value)
 
     @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> Optional[pulumi.Input[str]]:
-        """
-        (Required) A group's unique ID, including the `grp_` prefix.
-        """
-        return pulumi.get(self, "group_id")
+    @pulumi.getter
+    def masters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
+        return pulumi.get(self, "masters")
 
-    @group_id.setter
-    def group_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "group_id", value)
+    @masters.setter
+    def masters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
+        pulumi.set(self, "masters", value)
 
     @property
-    @pulumi.getter
-    def name(self) -> Optional[pulumi.Input[str]]:
-        """
-        (Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.
-        """
-        return pulumi.get(self, "name")
+    @pulumi.getter(name="signAndServe")
+    def sign_and_serve(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "sign_and_serve")
 
-    @name.setter
-    def name(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "name", value)
+    @sign_and_serve.setter
+    def sign_and_serve(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "sign_and_serve", value)
+
+    @property
+    @pulumi.getter(name="signAndServeAlgorithm")
+    def sign_and_serve_algorithm(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "sign_and_serve_algorithm")
+
+    @sign_and_serve_algorithm.setter
+    def sign_and_serve_algorithm(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "sign_and_serve_algorithm", value)
 
     @property
     @pulumi.getter
-    def product(self) -> Optional[pulumi.Input[str]]:
-        """
-        Replaced by `product_id`. Maintained for legacy purposes.
-        """
-        return pulumi.get(self, "product")
+    def target(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "target")
 
-    @product.setter
-    def product(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "product", value)
+    @target.setter
+    def target(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "target", value)
 
     @property
-    @pulumi.getter(name="productId")
-    def product_id(self) -> Optional[pulumi.Input[str]]:
-        return pulumi.get(self, "product_id")
+    @pulumi.getter(name="tsigKey")
+    def tsig_key(self) -> Optional[pulumi.Input['DnsZoneTsigKeyArgs']]:
+        return pulumi.get(self, "tsig_key")
 
-    @product_id.setter
-    def product_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "product_id", value)
+    @tsig_key.setter
+    def tsig_key(self, value: Optional[pulumi.Input['DnsZoneTsigKeyArgs']]):
+        pulumi.set(self, "tsig_key", value)
 
 
 @pulumi.input_type
-class _CpCodeState:
+class _DnsZoneState:
     def __init__(__self__, *,
+                 activation_state: Optional[pulumi.Input[str]] = None,
+                 alias_count: Optional[pulumi.Input[int]] = None,
+                 comment: Optional[pulumi.Input[str]] = None,
                  contract: Optional[pulumi.Input[str]] = None,
-                 contract_id: Optional[pulumi.Input[str]] = None,
+                 end_customer_id: Optional[pulumi.Input[str]] = None,
                  group: Optional[pulumi.Input[str]] = None,
-                 group_id: Optional[pulumi.Input[str]] = None,
-                 name: Optional[pulumi.Input[str]] = None,
-                 product: Optional[pulumi.Input[str]] = None,
-                 product_id: Optional[pulumi.Input[str]] = None):
-        """
-        Input properties used for looking up and filtering CpCode resources.
-        :param pulumi.Input[str] contract: Replaced by `contract_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] contract_id: (Required) A contract's unique ID, including the `ctr_` prefix.
-        :param pulumi.Input[str] group: Replaced by `group_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] group_id: (Required) A group's unique ID, including the `grp_` prefix.
-        :param pulumi.Input[str] name: (Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.
-        :param pulumi.Input[str] product: Replaced by `product_id`. Maintained for legacy purposes.
-        """
-        if contract is not None:
-            warnings.warn("""The setting \"contract\" has been deprecated.""", DeprecationWarning)
-            pulumi.log.warn("""contract is deprecated: The setting \"contract\" has been deprecated.""")
+                 masters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 sign_and_serve: Optional[pulumi.Input[bool]] = None,
+                 sign_and_serve_algorithm: Optional[pulumi.Input[str]] = None,
+                 target: Optional[pulumi.Input[str]] = None,
+                 tsig_key: Optional[pulumi.Input['DnsZoneTsigKeyArgs']] = None,
+                 type: Optional[pulumi.Input[str]] = None,
+                 version_id: Optional[pulumi.Input[str]] = None,
+                 zone: Optional[pulumi.Input[str]] = None):
+        """
+        Input properties used for looking up and filtering DnsZone resources.
+        """
+        if activation_state is not None:
+            pulumi.set(__self__, "activation_state", activation_state)
+        if alias_count is not None:
+            pulumi.set(__self__, "alias_count", alias_count)
+        if comment is not None:
+            pulumi.set(__self__, "comment", comment)
         if contract is not None:
             pulumi.set(__self__, "contract", contract)
-        if contract_id is not None:
-            pulumi.set(__self__, "contract_id", contract_id)
-        if group is not None:
-            warnings.warn("""The setting \"group\" has been deprecated.""", DeprecationWarning)
-            pulumi.log.warn("""group is deprecated: The setting \"group\" has been deprecated.""")
+        if end_customer_id is not None:
+            pulumi.set(__self__, "end_customer_id", end_customer_id)
         if group is not None:
             pulumi.set(__self__, "group", group)
-        if group_id is not None:
-            pulumi.set(__self__, "group_id", group_id)
-        if name is not None:
-            pulumi.set(__self__, "name", name)
-        if product is not None:
-            warnings.warn("""The setting \"product\" has been deprecated.""", DeprecationWarning)
-            pulumi.log.warn("""product is deprecated: The setting \"product\" has been deprecated.""")
-        if product is not None:
-            pulumi.set(__self__, "product", product)
-        if product_id is not None:
-            pulumi.set(__self__, "product_id", product_id)
+        if masters is not None:
+            pulumi.set(__self__, "masters", masters)
+        if sign_and_serve is not None:
+            pulumi.set(__self__, "sign_and_serve", sign_and_serve)
+        if sign_and_serve_algorithm is not None:
+            pulumi.set(__self__, "sign_and_serve_algorithm", sign_and_serve_algorithm)
+        if target is not None:
+            pulumi.set(__self__, "target", target)
+        if tsig_key is not None:
+            pulumi.set(__self__, "tsig_key", tsig_key)
+        if type is not None:
+            pulumi.set(__self__, "type", type)
+        if version_id is not None:
+            pulumi.set(__self__, "version_id", version_id)
+        if zone is not None:
+            pulumi.set(__self__, "zone", zone)
+
+    @property
+    @pulumi.getter(name="activationState")
+    def activation_state(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "activation_state")
+
+    @activation_state.setter
+    def activation_state(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "activation_state", value)
+
+    @property
+    @pulumi.getter(name="aliasCount")
+    def alias_count(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "alias_count")
+
+    @alias_count.setter
+    def alias_count(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "alias_count", value)
+
+    @property
+    @pulumi.getter
+    def comment(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "comment")
+
+    @comment.setter
+    def comment(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "comment", value)
 
     @property
     @pulumi.getter
     def contract(self) -> Optional[pulumi.Input[str]]:
-        """
-        Replaced by `contract_id`. Maintained for legacy purposes.
-        """
         return pulumi.get(self, "contract")
 
     @contract.setter
     def contract(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "contract", value)
 
     @property
-    @pulumi.getter(name="contractId")
-    def contract_id(self) -> Optional[pulumi.Input[str]]:
-        """
-        (Required) A contract's unique ID, including the `ctr_` prefix.
-        """
-        return pulumi.get(self, "contract_id")
-
-    @contract_id.setter
-    def contract_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "contract_id", value)
+    @pulumi.getter(name="endCustomerId")
+    def end_customer_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "end_customer_id")
+
+    @end_customer_id.setter
+    def end_customer_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "end_customer_id", value)
 
     @property
     @pulumi.getter
     def group(self) -> Optional[pulumi.Input[str]]:
-        """
-        Replaced by `group_id`. Maintained for legacy purposes.
-        """
         return pulumi.get(self, "group")
 
     @group.setter
     def group(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "group", value)
 
     @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> Optional[pulumi.Input[str]]:
-        """
-        (Required) A group's unique ID, including the `grp_` prefix.
-        """
-        return pulumi.get(self, "group_id")
-
-    @group_id.setter
-    def group_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "group_id", value)
-
-    @property
     @pulumi.getter
-    def name(self) -> Optional[pulumi.Input[str]]:
-        """
-        (Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.
-        """
-        return pulumi.get(self, "name")
+    def masters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
+        return pulumi.get(self, "masters")
 
-    @name.setter
-    def name(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "name", value)
+    @masters.setter
+    def masters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
+        pulumi.set(self, "masters", value)
 
     @property
-    @pulumi.getter
-    def product(self) -> Optional[pulumi.Input[str]]:
-        """
-        Replaced by `product_id`. Maintained for legacy purposes.
-        """
-        return pulumi.get(self, "product")
+    @pulumi.getter(name="signAndServe")
+    def sign_and_serve(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "sign_and_serve")
 
-    @product.setter
-    def product(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "product", value)
+    @sign_and_serve.setter
+    def sign_and_serve(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "sign_and_serve", value)
 
     @property
-    @pulumi.getter(name="productId")
-    def product_id(self) -> Optional[pulumi.Input[str]]:
-        return pulumi.get(self, "product_id")
-
-    @product_id.setter
-    def product_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "product_id", value)
-
-
-class CpCode(pulumi.CustomResource):
-    @overload
-    def __init__(__self__,
-                 resource_name: str,
-                 opts: Optional[pulumi.ResourceOptions] = None,
-                 contract: Optional[pulumi.Input[str]] = None,
-                 contract_id: Optional[pulumi.Input[str]] = None,
-                 group: Optional[pulumi.Input[str]] = None,
-                 group_id: Optional[pulumi.Input[str]] = None,
-                 name: Optional[pulumi.Input[str]] = None,
-                 product: Optional[pulumi.Input[str]] = None,
-                 product_id: Optional[pulumi.Input[str]] = None,
-                 __props__=None):
-        """
-        The `CpCode` resource lets you create or reuse content provider (CP) codes.  CP codes track web traffic handled by Akamai servers. Akamai gives you a CP code when you purchase a product. You need this code when you activate associated properties.
+    @pulumi.getter(name="signAndServeAlgorithm")
+    def sign_and_serve_algorithm(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "sign_and_serve_algorithm")
 
-        You can create additional CP codes to support more detailed billing and reporting functions.
+    @sign_and_serve_algorithm.setter
+    def sign_and_serve_algorithm(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "sign_and_serve_algorithm", value)
 
-        By default, the Akamai Provider uses your existing CP code instead of creating a new one.
+    @property
+    @pulumi.getter
+    def target(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "target")
 
-        ## Example Usage
+    @target.setter
+    def target(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "target", value)
 
-        Basic usage:
+    @property
+    @pulumi.getter(name="tsigKey")
+    def tsig_key(self) -> Optional[pulumi.Input['DnsZoneTsigKeyArgs']]:
+        return pulumi.get(self, "tsig_key")
 
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
+    @tsig_key.setter
+    def tsig_key(self, value: Optional[pulumi.Input['DnsZoneTsigKeyArgs']]):
+        pulumi.set(self, "tsig_key", value)
 
-        cp_code = akamai.CpCode("cpCode",
-            contract_id=akamai_contract["contract"]["id"],
-            group_id=akamai_group["group"]["id"],
-            product_id="prd_Object_Delivery")
-        ```
+    @property
+    @pulumi.getter
+    def type(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "type")
 
-        Here's a real-life example that includes other data sources as dependencies:
+    @type.setter
+    def type(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "type", value)
 
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
+    @property
+    @pulumi.getter(name="versionId")
+    def version_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "version_id")
 
-        group_name = "example group name"
-        cpcode_name = "My CP Code"
-        example_contract = akamai.get_contract(group_name=group_name)
-        example_group = akamai.get_group(name=group_name,
-            contract_id=example_contract.id)
-        example_cp = akamai.CpCode("exampleCp",
-            group_id=example_group.id,
-            contract_id=example_contract.id,
-            product_id="prd_Object_Delivery")
-        ```
-        ## Attributes reference
+    @version_id.setter
+    def version_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "version_id", value)
 
-        * `id` - The ID of the CP code.
+    @property
+    @pulumi.getter
+    def zone(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "zone")
 
-        ## Import
+    @zone.setter
+    def zone(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "zone", value)
 
-        Basic Usagehcl resource "akamai_cp_code" "example" {
 
-        # (resource arguments)
+warnings.warn("""akamai.edgedns.DnsZone has been deprecated in favor of akamai.DnsZone""", DeprecationWarning)
 
-         } You can import your Akamai CP codes using a comma-delimited string of the CP code, contract, and group IDs. You have to enter the IDs in this order`cpcode_id,contract_id,group_id` For example
 
-        ```sh
-         $ pulumi import akamai:index/cpCode:CpCode example cpc_123,ctr_1-AB123,grp_123
-        ```
+class DnsZone(pulumi.CustomResource):
+    warnings.warn("""akamai.edgedns.DnsZone has been deprecated in favor of akamai.DnsZone""", DeprecationWarning)
 
+    @overload
+    def __init__(__self__,
+                 resource_name: str,
+                 opts: Optional[pulumi.ResourceOptions] = None,
+                 comment: Optional[pulumi.Input[str]] = None,
+                 contract: Optional[pulumi.Input[str]] = None,
+                 end_customer_id: Optional[pulumi.Input[str]] = None,
+                 group: Optional[pulumi.Input[str]] = None,
+                 masters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 sign_and_serve: Optional[pulumi.Input[bool]] = None,
+                 sign_and_serve_algorithm: Optional[pulumi.Input[str]] = None,
+                 target: Optional[pulumi.Input[str]] = None,
+                 tsig_key: Optional[pulumi.Input[pulumi.InputType['DnsZoneTsigKeyArgs']]] = None,
+                 type: Optional[pulumi.Input[str]] = None,
+                 zone: Optional[pulumi.Input[str]] = None,
+                 __props__=None):
+        """
+        Create a DnsZone resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] contract: Replaced by `contract_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] contract_id: (Required) A contract's unique ID, including the `ctr_` prefix.
-        :param pulumi.Input[str] group: Replaced by `group_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] group_id: (Required) A group's unique ID, including the `grp_` prefix.
-        :param pulumi.Input[str] name: (Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.
-        :param pulumi.Input[str] product: Replaced by `product_id`. Maintained for legacy purposes.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: Optional[CpCodeArgs] = None,
+                 args: DnsZoneArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        The `CpCode` resource lets you create or reuse content provider (CP) codes.  CP codes track web traffic handled by Akamai servers. Akamai gives you a CP code when you purchase a product. You need this code when you activate associated properties.
-
-        You can create additional CP codes to support more detailed billing and reporting functions.
-
-        By default, the Akamai Provider uses your existing CP code instead of creating a new one.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        cp_code = akamai.CpCode("cpCode",
-            contract_id=akamai_contract["contract"]["id"],
-            group_id=akamai_group["group"]["id"],
-            product_id="prd_Object_Delivery")
-        ```
-
-        Here's a real-life example that includes other data sources as dependencies:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        group_name = "example group name"
-        cpcode_name = "My CP Code"
-        example_contract = akamai.get_contract(group_name=group_name)
-        example_group = akamai.get_group(name=group_name,
-            contract_id=example_contract.id)
-        example_cp = akamai.CpCode("exampleCp",
-            group_id=example_group.id,
-            contract_id=example_contract.id,
-            product_id="prd_Object_Delivery")
-        ```
-        ## Attributes reference
-
-        * `id` - The ID of the CP code.
-
-        ## Import
-
-        Basic Usagehcl resource "akamai_cp_code" "example" {
-
-        # (resource arguments)
-
-         } You can import your Akamai CP codes using a comma-delimited string of the CP code, contract, and group IDs. You have to enter the IDs in this order`cpcode_id,contract_id,group_id` For example
-
-        ```sh
-         $ pulumi import akamai:index/cpCode:CpCode example cpc_123,ctr_1-AB123,grp_123
-        ```
-
+        Create a DnsZone resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param CpCodeArgs args: The arguments to use to populate this resource's properties.
+        :param DnsZoneArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(CpCodeArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(DnsZoneArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
+                 comment: Optional[pulumi.Input[str]] = None,
                  contract: Optional[pulumi.Input[str]] = None,
-                 contract_id: Optional[pulumi.Input[str]] = None,
+                 end_customer_id: Optional[pulumi.Input[str]] = None,
                  group: Optional[pulumi.Input[str]] = None,
-                 group_id: Optional[pulumi.Input[str]] = None,
-                 name: Optional[pulumi.Input[str]] = None,
-                 product: Optional[pulumi.Input[str]] = None,
-                 product_id: Optional[pulumi.Input[str]] = None,
+                 masters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 sign_and_serve: Optional[pulumi.Input[bool]] = None,
+                 sign_and_serve_algorithm: Optional[pulumi.Input[str]] = None,
+                 target: Optional[pulumi.Input[str]] = None,
+                 tsig_key: Optional[pulumi.Input[pulumi.InputType['DnsZoneTsigKeyArgs']]] = None,
+                 type: Optional[pulumi.Input[str]] = None,
+                 zone: Optional[pulumi.Input[str]] = None,
                  __props__=None):
+        pulumi.log.warn("""DnsZone is deprecated: akamai.edgedns.DnsZone has been deprecated in favor of akamai.DnsZone""")
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = CpCodeArgs.__new__(CpCodeArgs)
+            __props__ = DnsZoneArgs.__new__(DnsZoneArgs)
 
-            if contract is not None and not opts.urn:
-                warnings.warn("""The setting \"contract\" has been deprecated.""", DeprecationWarning)
-                pulumi.log.warn("""contract is deprecated: The setting \"contract\" has been deprecated.""")
+            __props__.__dict__["comment"] = comment
+            if contract is None and not opts.urn:
+                raise TypeError("Missing required property 'contract'")
             __props__.__dict__["contract"] = contract
-            __props__.__dict__["contract_id"] = contract_id
-            if group is not None and not opts.urn:
-                warnings.warn("""The setting \"group\" has been deprecated.""", DeprecationWarning)
-                pulumi.log.warn("""group is deprecated: The setting \"group\" has been deprecated.""")
+            __props__.__dict__["end_customer_id"] = end_customer_id
             __props__.__dict__["group"] = group
-            __props__.__dict__["group_id"] = group_id
-            __props__.__dict__["name"] = name
-            if product is not None and not opts.urn:
-                warnings.warn("""The setting \"product\" has been deprecated.""", DeprecationWarning)
-                pulumi.log.warn("""product is deprecated: The setting \"product\" has been deprecated.""")
-            __props__.__dict__["product"] = product
-            __props__.__dict__["product_id"] = product_id
-        alias_opts = pulumi.ResourceOptions(aliases=[pulumi.Alias(type_="akamai:properties/cpCode:CpCode")])
-        opts = pulumi.ResourceOptions.merge(opts, alias_opts)
-        super(CpCode, __self__).__init__(
-            'akamai:index/cpCode:CpCode',
+            __props__.__dict__["masters"] = masters
+            __props__.__dict__["sign_and_serve"] = sign_and_serve
+            __props__.__dict__["sign_and_serve_algorithm"] = sign_and_serve_algorithm
+            __props__.__dict__["target"] = target
+            __props__.__dict__["tsig_key"] = tsig_key
+            if type is None and not opts.urn:
+                raise TypeError("Missing required property 'type'")
+            __props__.__dict__["type"] = type
+            if zone is None and not opts.urn:
+                raise TypeError("Missing required property 'zone'")
+            __props__.__dict__["zone"] = zone
+            __props__.__dict__["activation_state"] = None
+            __props__.__dict__["alias_count"] = None
+            __props__.__dict__["version_id"] = None
+        super(DnsZone, __self__).__init__(
+            'akamai:edgedns/dnsZone:DnsZone',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
+            activation_state: Optional[pulumi.Input[str]] = None,
+            alias_count: Optional[pulumi.Input[int]] = None,
+            comment: Optional[pulumi.Input[str]] = None,
             contract: Optional[pulumi.Input[str]] = None,
-            contract_id: Optional[pulumi.Input[str]] = None,
+            end_customer_id: Optional[pulumi.Input[str]] = None,
             group: Optional[pulumi.Input[str]] = None,
-            group_id: Optional[pulumi.Input[str]] = None,
-            name: Optional[pulumi.Input[str]] = None,
-            product: Optional[pulumi.Input[str]] = None,
-            product_id: Optional[pulumi.Input[str]] = None) -> 'CpCode':
+            masters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+            sign_and_serve: Optional[pulumi.Input[bool]] = None,
+            sign_and_serve_algorithm: Optional[pulumi.Input[str]] = None,
+            target: Optional[pulumi.Input[str]] = None,
+            tsig_key: Optional[pulumi.Input[pulumi.InputType['DnsZoneTsigKeyArgs']]] = None,
+            type: Optional[pulumi.Input[str]] = None,
+            version_id: Optional[pulumi.Input[str]] = None,
+            zone: Optional[pulumi.Input[str]] = None) -> 'DnsZone':
         """
-        Get an existing CpCode resource's state with the given name, id, and optional extra
+        Get an existing DnsZone resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] contract: Replaced by `contract_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] contract_id: (Required) A contract's unique ID, including the `ctr_` prefix.
-        :param pulumi.Input[str] group: Replaced by `group_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] group_id: (Required) A group's unique ID, including the `grp_` prefix.
-        :param pulumi.Input[str] name: (Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.
-        :param pulumi.Input[str] product: Replaced by `product_id`. Maintained for legacy purposes.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _CpCodeState.__new__(_CpCodeState)
+        __props__ = _DnsZoneState.__new__(_DnsZoneState)
 
+        __props__.__dict__["activation_state"] = activation_state
+        __props__.__dict__["alias_count"] = alias_count
+        __props__.__dict__["comment"] = comment
         __props__.__dict__["contract"] = contract
-        __props__.__dict__["contract_id"] = contract_id
+        __props__.__dict__["end_customer_id"] = end_customer_id
         __props__.__dict__["group"] = group
-        __props__.__dict__["group_id"] = group_id
-        __props__.__dict__["name"] = name
-        __props__.__dict__["product"] = product
-        __props__.__dict__["product_id"] = product_id
-        return CpCode(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["masters"] = masters
+        __props__.__dict__["sign_and_serve"] = sign_and_serve
+        __props__.__dict__["sign_and_serve_algorithm"] = sign_and_serve_algorithm
+        __props__.__dict__["target"] = target
+        __props__.__dict__["tsig_key"] = tsig_key
+        __props__.__dict__["type"] = type
+        __props__.__dict__["version_id"] = version_id
+        __props__.__dict__["zone"] = zone
+        return DnsZone(resource_name, opts=opts, __props__=__props__)
+
+    @property
+    @pulumi.getter(name="activationState")
+    def activation_state(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "activation_state")
+
+    @property
+    @pulumi.getter(name="aliasCount")
+    def alias_count(self) -> pulumi.Output[int]:
+        return pulumi.get(self, "alias_count")
+
+    @property
+    @pulumi.getter
+    def comment(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "comment")
 
     @property
     @pulumi.getter
     def contract(self) -> pulumi.Output[str]:
-        """
-        Replaced by `contract_id`. Maintained for legacy purposes.
-        """
         return pulumi.get(self, "contract")
 
     @property
-    @pulumi.getter(name="contractId")
-    def contract_id(self) -> pulumi.Output[str]:
-        """
-        (Required) A contract's unique ID, including the `ctr_` prefix.
-        """
-        return pulumi.get(self, "contract_id")
+    @pulumi.getter(name="endCustomerId")
+    def end_customer_id(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "end_customer_id")
 
     @property
     @pulumi.getter
-    def group(self) -> pulumi.Output[str]:
-        """
-        Replaced by `group_id`. Maintained for legacy purposes.
-        """
+    def group(self) -> pulumi.Output[Optional[str]]:
         return pulumi.get(self, "group")
 
     @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> pulumi.Output[str]:
-        """
-        (Required) A group's unique ID, including the `grp_` prefix.
-        """
-        return pulumi.get(self, "group_id")
+    @pulumi.getter
+    def masters(self) -> pulumi.Output[Optional[Sequence[str]]]:
+        return pulumi.get(self, "masters")
+
+    @property
+    @pulumi.getter(name="signAndServe")
+    def sign_and_serve(self) -> pulumi.Output[Optional[bool]]:
+        return pulumi.get(self, "sign_and_serve")
+
+    @property
+    @pulumi.getter(name="signAndServeAlgorithm")
+    def sign_and_serve_algorithm(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "sign_and_serve_algorithm")
 
     @property
     @pulumi.getter
-    def name(self) -> pulumi.Output[str]:
-        """
-        (Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.
-        """
-        return pulumi.get(self, "name")
+    def target(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "target")
+
+    @property
+    @pulumi.getter(name="tsigKey")
+    def tsig_key(self) -> pulumi.Output[Optional['outputs.DnsZoneTsigKey']]:
+        return pulumi.get(self, "tsig_key")
 
     @property
     @pulumi.getter
-    def product(self) -> pulumi.Output[str]:
-        """
-        Replaced by `product_id`. Maintained for legacy purposes.
-        """
-        return pulumi.get(self, "product")
+    def type(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "type")
+
+    @property
+    @pulumi.getter(name="versionId")
+    def version_id(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "version_id")
 
     @property
-    @pulumi.getter(name="productId")
-    def product_id(self) -> pulumi.Output[str]:
-        return pulumi.get(self, "product_id")
+    @pulumi.getter
+    def zone(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "zone")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/cps_dv_validation.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/trafficmanagement/gtm_a_smap.py`

 * *Files 26% similar despite different names*

```diff
@@ -3,251 +3,274 @@
 # *** Do not edit by hand unless you're certain you know what you are doing! ***
 
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
-from . import _utilities
+from .. import _utilities
+from . import outputs
+from ._inputs import *
 
-__all__ = ['CpsDvValidationArgs', 'CpsDvValidation']
+__all__ = ['GtmASmapArgs', 'GtmASmap']
 
 @pulumi.input_type
-class CpsDvValidationArgs:
+class GtmASmapArgs:
     def __init__(__self__, *,
-                 enrollment_id: pulumi.Input[int],
-                 sans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
-        """
-        The set of arguments for constructing a CpsDvValidation resource.
-        :param pulumi.Input[int] enrollment_id: Unique identifier for the DV certificate enrollment.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] sans: The Subject Alternative Names (SAN) list for tracking changes on related enrollments. Whenever any SAN changes, the Akamai provider recreates this resource and sends another acknowledgement request to CPS.
-        """
-        pulumi.set(__self__, "enrollment_id", enrollment_id)
-        if sans is not None:
-            pulumi.set(__self__, "sans", sans)
+                 default_datacenter: pulumi.Input['GtmASmapDefaultDatacenterArgs'],
+                 domain: pulumi.Input[str],
+                 assignments: Optional[pulumi.Input[Sequence[pulumi.Input['GtmASmapAssignmentArgs']]]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None):
+        """
+        The set of arguments for constructing a GtmASmap resource.
+        """
+        pulumi.set(__self__, "default_datacenter", default_datacenter)
+        pulumi.set(__self__, "domain", domain)
+        if assignments is not None:
+            pulumi.set(__self__, "assignments", assignments)
+        if name is not None:
+            pulumi.set(__self__, "name", name)
+        if wait_on_complete is not None:
+            pulumi.set(__self__, "wait_on_complete", wait_on_complete)
 
     @property
-    @pulumi.getter(name="enrollmentId")
-    def enrollment_id(self) -> pulumi.Input[int]:
-        """
-        Unique identifier for the DV certificate enrollment.
-        """
-        return pulumi.get(self, "enrollment_id")
+    @pulumi.getter(name="defaultDatacenter")
+    def default_datacenter(self) -> pulumi.Input['GtmASmapDefaultDatacenterArgs']:
+        return pulumi.get(self, "default_datacenter")
+
+    @default_datacenter.setter
+    def default_datacenter(self, value: pulumi.Input['GtmASmapDefaultDatacenterArgs']):
+        pulumi.set(self, "default_datacenter", value)
+
+    @property
+    @pulumi.getter
+    def domain(self) -> pulumi.Input[str]:
+        return pulumi.get(self, "domain")
 
-    @enrollment_id.setter
-    def enrollment_id(self, value: pulumi.Input[int]):
-        pulumi.set(self, "enrollment_id", value)
+    @domain.setter
+    def domain(self, value: pulumi.Input[str]):
+        pulumi.set(self, "domain", value)
 
     @property
     @pulumi.getter
-    def sans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
-        """
-        The Subject Alternative Names (SAN) list for tracking changes on related enrollments. Whenever any SAN changes, the Akamai provider recreates this resource and sends another acknowledgement request to CPS.
-        """
-        return pulumi.get(self, "sans")
+    def assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmASmapAssignmentArgs']]]]:
+        return pulumi.get(self, "assignments")
+
+    @assignments.setter
+    def assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmASmapAssignmentArgs']]]]):
+        pulumi.set(self, "assignments", value)
+
+    @property
+    @pulumi.getter
+    def name(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "name")
+
+    @name.setter
+    def name(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "name", value)
 
-    @sans.setter
-    def sans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
-        pulumi.set(self, "sans", value)
+    @property
+    @pulumi.getter(name="waitOnComplete")
+    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "wait_on_complete")
+
+    @wait_on_complete.setter
+    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "wait_on_complete", value)
 
 
 @pulumi.input_type
-class _CpsDvValidationState:
+class _GtmASmapState:
     def __init__(__self__, *,
-                 enrollment_id: Optional[pulumi.Input[int]] = None,
-                 sans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 status: Optional[pulumi.Input[str]] = None):
-        """
-        Input properties used for looking up and filtering CpsDvValidation resources.
-        :param pulumi.Input[int] enrollment_id: Unique identifier for the DV certificate enrollment.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] sans: The Subject Alternative Names (SAN) list for tracking changes on related enrollments. Whenever any SAN changes, the Akamai provider recreates this resource and sends another acknowledgement request to CPS.
-        :param pulumi.Input[str] status: Status of validation
-        """
-        if enrollment_id is not None:
-            pulumi.set(__self__, "enrollment_id", enrollment_id)
-        if sans is not None:
-            pulumi.set(__self__, "sans", sans)
-        if status is not None:
-            pulumi.set(__self__, "status", status)
+                 assignments: Optional[pulumi.Input[Sequence[pulumi.Input['GtmASmapAssignmentArgs']]]] = None,
+                 default_datacenter: Optional[pulumi.Input['GtmASmapDefaultDatacenterArgs']] = None,
+                 domain: Optional[pulumi.Input[str]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None):
+        """
+        Input properties used for looking up and filtering GtmASmap resources.
+        """
+        if assignments is not None:
+            pulumi.set(__self__, "assignments", assignments)
+        if default_datacenter is not None:
+            pulumi.set(__self__, "default_datacenter", default_datacenter)
+        if domain is not None:
+            pulumi.set(__self__, "domain", domain)
+        if name is not None:
+            pulumi.set(__self__, "name", name)
+        if wait_on_complete is not None:
+            pulumi.set(__self__, "wait_on_complete", wait_on_complete)
 
     @property
-    @pulumi.getter(name="enrollmentId")
-    def enrollment_id(self) -> Optional[pulumi.Input[int]]:
-        """
-        Unique identifier for the DV certificate enrollment.
-        """
-        return pulumi.get(self, "enrollment_id")
+    @pulumi.getter
+    def assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmASmapAssignmentArgs']]]]:
+        return pulumi.get(self, "assignments")
+
+    @assignments.setter
+    def assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmASmapAssignmentArgs']]]]):
+        pulumi.set(self, "assignments", value)
 
-    @enrollment_id.setter
-    def enrollment_id(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "enrollment_id", value)
+    @property
+    @pulumi.getter(name="defaultDatacenter")
+    def default_datacenter(self) -> Optional[pulumi.Input['GtmASmapDefaultDatacenterArgs']]:
+        return pulumi.get(self, "default_datacenter")
+
+    @default_datacenter.setter
+    def default_datacenter(self, value: Optional[pulumi.Input['GtmASmapDefaultDatacenterArgs']]):
+        pulumi.set(self, "default_datacenter", value)
 
     @property
     @pulumi.getter
-    def sans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
-        """
-        The Subject Alternative Names (SAN) list for tracking changes on related enrollments. Whenever any SAN changes, the Akamai provider recreates this resource and sends another acknowledgement request to CPS.
-        """
-        return pulumi.get(self, "sans")
+    def domain(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "domain")
 
-    @sans.setter
-    def sans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
-        pulumi.set(self, "sans", value)
+    @domain.setter
+    def domain(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "domain", value)
 
     @property
     @pulumi.getter
-    def status(self) -> Optional[pulumi.Input[str]]:
-        """
-        Status of validation
-        """
-        return pulumi.get(self, "status")
+    def name(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "name")
+
+    @name.setter
+    def name(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "name", value)
 
-    @status.setter
-    def status(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "status", value)
+    @property
+    @pulumi.getter(name="waitOnComplete")
+    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "wait_on_complete")
 
+    @wait_on_complete.setter
+    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "wait_on_complete", value)
+
+
+warnings.warn("""akamai.trafficmanagement.GtmASmap has been deprecated in favor of akamai.GtmAsmap""", DeprecationWarning)
+
+
+class GtmASmap(pulumi.CustomResource):
+    warnings.warn("""akamai.trafficmanagement.GtmASmap has been deprecated in favor of akamai.GtmAsmap""", DeprecationWarning)
 
-class CpsDvValidation(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 enrollment_id: Optional[pulumi.Input[int]] = None,
-                 sans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 assignments: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmASmapAssignmentArgs']]]]] = None,
+                 default_datacenter: Optional[pulumi.Input[pulumi.InputType['GtmASmapDefaultDatacenterArgs']]] = None,
+                 domain: Optional[pulumi.Input[str]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
                  __props__=None):
         """
-        Once you complete the Let's Encrypt challenges, optionally use the `CpsDvValidation` resource to send the acknowledgement to CPS and inform it that tokens are ready for validation. You can also wait for CPS to check for the tokens, which it does on a regular schedule. Next, CPS automatically deploys the certificate on Staging, and eventually on the Production network.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        example = akamai.CpsDvValidation("example",
-            enrollment_id=akamai_cps_dv_enrollment["example"]["id"],
-            sans=akamai_cps_dv_enrollment["example"]["sans"])
-        ```
-        ## Attributes reference
-
-        * `status` - The status of certificate validation.
-
+        Create a GtmASmap resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] enrollment_id: Unique identifier for the DV certificate enrollment.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] sans: The Subject Alternative Names (SAN) list for tracking changes on related enrollments. Whenever any SAN changes, the Akamai provider recreates this resource and sends another acknowledgement request to CPS.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: CpsDvValidationArgs,
+                 args: GtmASmapArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        Once you complete the Let's Encrypt challenges, optionally use the `CpsDvValidation` resource to send the acknowledgement to CPS and inform it that tokens are ready for validation. You can also wait for CPS to check for the tokens, which it does on a regular schedule. Next, CPS automatically deploys the certificate on Staging, and eventually on the Production network.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        example = akamai.CpsDvValidation("example",
-            enrollment_id=akamai_cps_dv_enrollment["example"]["id"],
-            sans=akamai_cps_dv_enrollment["example"]["sans"])
-        ```
-        ## Attributes reference
-
-        * `status` - The status of certificate validation.
-
+        Create a GtmASmap resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param CpsDvValidationArgs args: The arguments to use to populate this resource's properties.
+        :param GtmASmapArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(CpsDvValidationArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(GtmASmapArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 enrollment_id: Optional[pulumi.Input[int]] = None,
-                 sans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 assignments: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmASmapAssignmentArgs']]]]] = None,
+                 default_datacenter: Optional[pulumi.Input[pulumi.InputType['GtmASmapDefaultDatacenterArgs']]] = None,
+                 domain: Optional[pulumi.Input[str]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
                  __props__=None):
+        pulumi.log.warn("""GtmASmap is deprecated: akamai.trafficmanagement.GtmASmap has been deprecated in favor of akamai.GtmAsmap""")
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = CpsDvValidationArgs.__new__(CpsDvValidationArgs)
+            __props__ = GtmASmapArgs.__new__(GtmASmapArgs)
 
-            if enrollment_id is None and not opts.urn:
-                raise TypeError("Missing required property 'enrollment_id'")
-            __props__.__dict__["enrollment_id"] = enrollment_id
-            __props__.__dict__["sans"] = sans
-            __props__.__dict__["status"] = None
-        super(CpsDvValidation, __self__).__init__(
-            'akamai:index/cpsDvValidation:CpsDvValidation',
+            __props__.__dict__["assignments"] = assignments
+            if default_datacenter is None and not opts.urn:
+                raise TypeError("Missing required property 'default_datacenter'")
+            __props__.__dict__["default_datacenter"] = default_datacenter
+            if domain is None and not opts.urn:
+                raise TypeError("Missing required property 'domain'")
+            __props__.__dict__["domain"] = domain
+            __props__.__dict__["name"] = name
+            __props__.__dict__["wait_on_complete"] = wait_on_complete
+        super(GtmASmap, __self__).__init__(
+            'akamai:trafficmanagement/gtmASmap:GtmASmap',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
-            enrollment_id: Optional[pulumi.Input[int]] = None,
-            sans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-            status: Optional[pulumi.Input[str]] = None) -> 'CpsDvValidation':
+            assignments: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmASmapAssignmentArgs']]]]] = None,
+            default_datacenter: Optional[pulumi.Input[pulumi.InputType['GtmASmapDefaultDatacenterArgs']]] = None,
+            domain: Optional[pulumi.Input[str]] = None,
+            name: Optional[pulumi.Input[str]] = None,
+            wait_on_complete: Optional[pulumi.Input[bool]] = None) -> 'GtmASmap':
         """
-        Get an existing CpsDvValidation resource's state with the given name, id, and optional extra
+        Get an existing GtmASmap resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] enrollment_id: Unique identifier for the DV certificate enrollment.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] sans: The Subject Alternative Names (SAN) list for tracking changes on related enrollments. Whenever any SAN changes, the Akamai provider recreates this resource and sends another acknowledgement request to CPS.
-        :param pulumi.Input[str] status: Status of validation
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _CpsDvValidationState.__new__(_CpsDvValidationState)
+        __props__ = _GtmASmapState.__new__(_GtmASmapState)
 
-        __props__.__dict__["enrollment_id"] = enrollment_id
-        __props__.__dict__["sans"] = sans
-        __props__.__dict__["status"] = status
-        return CpsDvValidation(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["assignments"] = assignments
+        __props__.__dict__["default_datacenter"] = default_datacenter
+        __props__.__dict__["domain"] = domain
+        __props__.__dict__["name"] = name
+        __props__.__dict__["wait_on_complete"] = wait_on_complete
+        return GtmASmap(resource_name, opts=opts, __props__=__props__)
 
     @property
-    @pulumi.getter(name="enrollmentId")
-    def enrollment_id(self) -> pulumi.Output[int]:
-        """
-        Unique identifier for the DV certificate enrollment.
-        """
-        return pulumi.get(self, "enrollment_id")
+    @pulumi.getter
+    def assignments(self) -> pulumi.Output[Optional[Sequence['outputs.GtmASmapAssignment']]]:
+        return pulumi.get(self, "assignments")
+
+    @property
+    @pulumi.getter(name="defaultDatacenter")
+    def default_datacenter(self) -> pulumi.Output['outputs.GtmASmapDefaultDatacenter']:
+        return pulumi.get(self, "default_datacenter")
 
     @property
     @pulumi.getter
-    def sans(self) -> pulumi.Output[Optional[Sequence[str]]]:
-        """
-        The Subject Alternative Names (SAN) list for tracking changes on related enrollments. Whenever any SAN changes, the Akamai provider recreates this resource and sends another acknowledgement request to CPS.
-        """
-        return pulumi.get(self, "sans")
+    def domain(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "domain")
 
     @property
     @pulumi.getter
-    def status(self) -> pulumi.Output[str]:
-        """
-        Status of validation
-        """
-        return pulumi.get(self, "status")
+    def name(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "name")
+
+    @property
+    @pulumi.getter(name="waitOnComplete")
+    def wait_on_complete(self) -> pulumi.Output[Optional[bool]]:
+        return pulumi.get(self, "wait_on_complete")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/cps_upload_certificate.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/cps_upload_certificate.py`

 * *Files 26% similar despite different names*

```diff
@@ -21,24 +21,23 @@
                  certificate_ecdsa_pem: Optional[pulumi.Input[str]] = None,
                  certificate_rsa_pem: Optional[pulumi.Input[str]] = None,
                  trust_chain_ecdsa_pem: Optional[pulumi.Input[str]] = None,
                  trust_chain_rsa_pem: Optional[pulumi.Input[str]] = None,
                  wait_for_deployment: Optional[pulumi.Input[bool]] = None):
         """
         The set of arguments for constructing a CpsUploadCertificate resource.
-        :param pulumi.Input[int] enrollment_id: Unique identifier for the certificate enrollment.
-               * certificate PEM file (Required) - Include at least one of the following arguments for the PEM file to upload. You can upload an ECDSA certificate, an RSA certificate, or both.
-        :param pulumi.Input[bool] acknowledge_change_management: Boolean. Use only if `change_management` is set to `true` in the `CpsThirdPartyEnrollment` resource. Enter `true` to acknowledge that testing on staging is complete and to deploy the certificate to production.
-        :param pulumi.Input[bool] acknowledge_post_verification_warnings: Boolean. Enter `true` if you want to acknowledge the post-verification warnings defined in `auto_approve_warnings`.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] auto_approve_warnings: The list of post-verification warning IDs you want to automatically acknowledge. To retrieve the list of warnings, use the _get_cps_warnings_ data source.
-        :param pulumi.Input[str] certificate_ecdsa_pem: The ECDSA certificate in PEM format you want to upload.
-        :param pulumi.Input[str] certificate_rsa_pem: The RSA certificate in PEM format you want to upload.
-        :param pulumi.Input[str] trust_chain_ecdsa_pem: The trust chain in PEM format for the ECDSA certificate you want to upload.
-        :param pulumi.Input[str] trust_chain_rsa_pem: The trust chain in PEM format for the RSA certificate you want to upload.
-        :param pulumi.Input[bool] wait_for_deployment: Boolean. Enter `true` to wait for certificate to be deployed.
+        :param pulumi.Input[int] enrollment_id: The unique identifier of the enrollment
+        :param pulumi.Input[bool] acknowledge_change_management: Whether to acknowledge change management
+        :param pulumi.Input[bool] acknowledge_post_verification_warnings: Whether to acknowledge post-verification warnings
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] auto_approve_warnings: List of post-verification warnings to be automatically acknowledged
+        :param pulumi.Input[str] certificate_ecdsa_pem: ECDSA certificate in pem format to be uploaded
+        :param pulumi.Input[str] certificate_rsa_pem: RSA certificate in pem format to be uploaded
+        :param pulumi.Input[str] trust_chain_ecdsa_pem: Trust chain in pem format for provided ECDSA certificate
+        :param pulumi.Input[str] trust_chain_rsa_pem: Trust chain in pem format for provided RSA certificate
+        :param pulumi.Input[bool] wait_for_deployment: Whether to wait for certificate to be deployed
         """
         pulumi.set(__self__, "enrollment_id", enrollment_id)
         if acknowledge_change_management is not None:
             pulumi.set(__self__, "acknowledge_change_management", acknowledge_change_management)
         if acknowledge_post_verification_warnings is not None:
             pulumi.set(__self__, "acknowledge_post_verification_warnings", acknowledge_post_verification_warnings)
         if auto_approve_warnings is not None:
@@ -54,112 +53,111 @@
         if wait_for_deployment is not None:
             pulumi.set(__self__, "wait_for_deployment", wait_for_deployment)
 
     @property
     @pulumi.getter(name="enrollmentId")
     def enrollment_id(self) -> pulumi.Input[int]:
         """
-        Unique identifier for the certificate enrollment.
-        * certificate PEM file (Required) - Include at least one of the following arguments for the PEM file to upload. You can upload an ECDSA certificate, an RSA certificate, or both.
+        The unique identifier of the enrollment
         """
         return pulumi.get(self, "enrollment_id")
 
     @enrollment_id.setter
     def enrollment_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "enrollment_id", value)
 
     @property
     @pulumi.getter(name="acknowledgeChangeManagement")
     def acknowledge_change_management(self) -> Optional[pulumi.Input[bool]]:
         """
-        Boolean. Use only if `change_management` is set to `true` in the `CpsThirdPartyEnrollment` resource. Enter `true` to acknowledge that testing on staging is complete and to deploy the certificate to production.
+        Whether to acknowledge change management
         """
         return pulumi.get(self, "acknowledge_change_management")
 
     @acknowledge_change_management.setter
     def acknowledge_change_management(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "acknowledge_change_management", value)
 
     @property
     @pulumi.getter(name="acknowledgePostVerificationWarnings")
     def acknowledge_post_verification_warnings(self) -> Optional[pulumi.Input[bool]]:
         """
-        Boolean. Enter `true` if you want to acknowledge the post-verification warnings defined in `auto_approve_warnings`.
+        Whether to acknowledge post-verification warnings
         """
         return pulumi.get(self, "acknowledge_post_verification_warnings")
 
     @acknowledge_post_verification_warnings.setter
     def acknowledge_post_verification_warnings(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "acknowledge_post_verification_warnings", value)
 
     @property
     @pulumi.getter(name="autoApproveWarnings")
     def auto_approve_warnings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        The list of post-verification warning IDs you want to automatically acknowledge. To retrieve the list of warnings, use the _get_cps_warnings_ data source.
+        List of post-verification warnings to be automatically acknowledged
         """
         return pulumi.get(self, "auto_approve_warnings")
 
     @auto_approve_warnings.setter
     def auto_approve_warnings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "auto_approve_warnings", value)
 
     @property
     @pulumi.getter(name="certificateEcdsaPem")
     def certificate_ecdsa_pem(self) -> Optional[pulumi.Input[str]]:
         """
-        The ECDSA certificate in PEM format you want to upload.
+        ECDSA certificate in pem format to be uploaded
         """
         return pulumi.get(self, "certificate_ecdsa_pem")
 
     @certificate_ecdsa_pem.setter
     def certificate_ecdsa_pem(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "certificate_ecdsa_pem", value)
 
     @property
     @pulumi.getter(name="certificateRsaPem")
     def certificate_rsa_pem(self) -> Optional[pulumi.Input[str]]:
         """
-        The RSA certificate in PEM format you want to upload.
+        RSA certificate in pem format to be uploaded
         """
         return pulumi.get(self, "certificate_rsa_pem")
 
     @certificate_rsa_pem.setter
     def certificate_rsa_pem(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "certificate_rsa_pem", value)
 
     @property
     @pulumi.getter(name="trustChainEcdsaPem")
     def trust_chain_ecdsa_pem(self) -> Optional[pulumi.Input[str]]:
         """
-        The trust chain in PEM format for the ECDSA certificate you want to upload.
+        Trust chain in pem format for provided ECDSA certificate
         """
         return pulumi.get(self, "trust_chain_ecdsa_pem")
 
     @trust_chain_ecdsa_pem.setter
     def trust_chain_ecdsa_pem(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "trust_chain_ecdsa_pem", value)
 
     @property
     @pulumi.getter(name="trustChainRsaPem")
     def trust_chain_rsa_pem(self) -> Optional[pulumi.Input[str]]:
         """
-        The trust chain in PEM format for the RSA certificate you want to upload.
+        Trust chain in pem format for provided RSA certificate
         """
         return pulumi.get(self, "trust_chain_rsa_pem")
 
     @trust_chain_rsa_pem.setter
     def trust_chain_rsa_pem(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "trust_chain_rsa_pem", value)
 
     @property
     @pulumi.getter(name="waitForDeployment")
     def wait_for_deployment(self) -> Optional[pulumi.Input[bool]]:
         """
-        Boolean. Enter `true` to wait for certificate to be deployed.
+        Whether to wait for certificate to be deployed
         """
         return pulumi.get(self, "wait_for_deployment")
 
     @wait_for_deployment.setter
     def wait_for_deployment(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "wait_for_deployment", value)
 
@@ -175,25 +173,24 @@
                  enrollment_id: Optional[pulumi.Input[int]] = None,
                  trust_chain_ecdsa_pem: Optional[pulumi.Input[str]] = None,
                  trust_chain_rsa_pem: Optional[pulumi.Input[str]] = None,
                  unacknowledged_warnings: Optional[pulumi.Input[bool]] = None,
                  wait_for_deployment: Optional[pulumi.Input[bool]] = None):
         """
         Input properties used for looking up and filtering CpsUploadCertificate resources.
-        :param pulumi.Input[bool] acknowledge_change_management: Boolean. Use only if `change_management` is set to `true` in the `CpsThirdPartyEnrollment` resource. Enter `true` to acknowledge that testing on staging is complete and to deploy the certificate to production.
-        :param pulumi.Input[bool] acknowledge_post_verification_warnings: Boolean. Enter `true` if you want to acknowledge the post-verification warnings defined in `auto_approve_warnings`.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] auto_approve_warnings: The list of post-verification warning IDs you want to automatically acknowledge. To retrieve the list of warnings, use the _get_cps_warnings_ data source.
-        :param pulumi.Input[str] certificate_ecdsa_pem: The ECDSA certificate in PEM format you want to upload.
-        :param pulumi.Input[str] certificate_rsa_pem: The RSA certificate in PEM format you want to upload.
-        :param pulumi.Input[int] enrollment_id: Unique identifier for the certificate enrollment.
-               * certificate PEM file (Required) - Include at least one of the following arguments for the PEM file to upload. You can upload an ECDSA certificate, an RSA certificate, or both.
-        :param pulumi.Input[str] trust_chain_ecdsa_pem: The trust chain in PEM format for the ECDSA certificate you want to upload.
-        :param pulumi.Input[str] trust_chain_rsa_pem: The trust chain in PEM format for the RSA certificate you want to upload.
+        :param pulumi.Input[bool] acknowledge_change_management: Whether to acknowledge change management
+        :param pulumi.Input[bool] acknowledge_post_verification_warnings: Whether to acknowledge post-verification warnings
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] auto_approve_warnings: List of post-verification warnings to be automatically acknowledged
+        :param pulumi.Input[str] certificate_ecdsa_pem: ECDSA certificate in pem format to be uploaded
+        :param pulumi.Input[str] certificate_rsa_pem: RSA certificate in pem format to be uploaded
+        :param pulumi.Input[int] enrollment_id: The unique identifier of the enrollment
+        :param pulumi.Input[str] trust_chain_ecdsa_pem: Trust chain in pem format for provided ECDSA certificate
+        :param pulumi.Input[str] trust_chain_rsa_pem: Trust chain in pem format for provided RSA certificate
         :param pulumi.Input[bool] unacknowledged_warnings: Used to distinguish whether there are unacknowledged warnings for a certificate
-        :param pulumi.Input[bool] wait_for_deployment: Boolean. Enter `true` to wait for certificate to be deployed.
+        :param pulumi.Input[bool] wait_for_deployment: Whether to wait for certificate to be deployed
         """
         if acknowledge_change_management is not None:
             pulumi.set(__self__, "acknowledge_change_management", acknowledge_change_management)
         if acknowledge_post_verification_warnings is not None:
             pulumi.set(__self__, "acknowledge_post_verification_warnings", acknowledge_post_verification_warnings)
         if auto_approve_warnings is not None:
             pulumi.set(__self__, "auto_approve_warnings", auto_approve_warnings)
@@ -212,100 +209,99 @@
         if wait_for_deployment is not None:
             pulumi.set(__self__, "wait_for_deployment", wait_for_deployment)
 
     @property
     @pulumi.getter(name="acknowledgeChangeManagement")
     def acknowledge_change_management(self) -> Optional[pulumi.Input[bool]]:
         """
-        Boolean. Use only if `change_management` is set to `true` in the `CpsThirdPartyEnrollment` resource. Enter `true` to acknowledge that testing on staging is complete and to deploy the certificate to production.
+        Whether to acknowledge change management
         """
         return pulumi.get(self, "acknowledge_change_management")
 
     @acknowledge_change_management.setter
     def acknowledge_change_management(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "acknowledge_change_management", value)
 
     @property
     @pulumi.getter(name="acknowledgePostVerificationWarnings")
     def acknowledge_post_verification_warnings(self) -> Optional[pulumi.Input[bool]]:
         """
-        Boolean. Enter `true` if you want to acknowledge the post-verification warnings defined in `auto_approve_warnings`.
+        Whether to acknowledge post-verification warnings
         """
         return pulumi.get(self, "acknowledge_post_verification_warnings")
 
     @acknowledge_post_verification_warnings.setter
     def acknowledge_post_verification_warnings(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "acknowledge_post_verification_warnings", value)
 
     @property
     @pulumi.getter(name="autoApproveWarnings")
     def auto_approve_warnings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        The list of post-verification warning IDs you want to automatically acknowledge. To retrieve the list of warnings, use the _get_cps_warnings_ data source.
+        List of post-verification warnings to be automatically acknowledged
         """
         return pulumi.get(self, "auto_approve_warnings")
 
     @auto_approve_warnings.setter
     def auto_approve_warnings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "auto_approve_warnings", value)
 
     @property
     @pulumi.getter(name="certificateEcdsaPem")
     def certificate_ecdsa_pem(self) -> Optional[pulumi.Input[str]]:
         """
-        The ECDSA certificate in PEM format you want to upload.
+        ECDSA certificate in pem format to be uploaded
         """
         return pulumi.get(self, "certificate_ecdsa_pem")
 
     @certificate_ecdsa_pem.setter
     def certificate_ecdsa_pem(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "certificate_ecdsa_pem", value)
 
     @property
     @pulumi.getter(name="certificateRsaPem")
     def certificate_rsa_pem(self) -> Optional[pulumi.Input[str]]:
         """
-        The RSA certificate in PEM format you want to upload.
+        RSA certificate in pem format to be uploaded
         """
         return pulumi.get(self, "certificate_rsa_pem")
 
     @certificate_rsa_pem.setter
     def certificate_rsa_pem(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "certificate_rsa_pem", value)
 
     @property
     @pulumi.getter(name="enrollmentId")
     def enrollment_id(self) -> Optional[pulumi.Input[int]]:
         """
-        Unique identifier for the certificate enrollment.
-        * certificate PEM file (Required) - Include at least one of the following arguments for the PEM file to upload. You can upload an ECDSA certificate, an RSA certificate, or both.
+        The unique identifier of the enrollment
         """
         return pulumi.get(self, "enrollment_id")
 
     @enrollment_id.setter
     def enrollment_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "enrollment_id", value)
 
     @property
     @pulumi.getter(name="trustChainEcdsaPem")
     def trust_chain_ecdsa_pem(self) -> Optional[pulumi.Input[str]]:
         """
-        The trust chain in PEM format for the ECDSA certificate you want to upload.
+        Trust chain in pem format for provided ECDSA certificate
         """
         return pulumi.get(self, "trust_chain_ecdsa_pem")
 
     @trust_chain_ecdsa_pem.setter
     def trust_chain_ecdsa_pem(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "trust_chain_ecdsa_pem", value)
 
     @property
     @pulumi.getter(name="trustChainRsaPem")
     def trust_chain_rsa_pem(self) -> Optional[pulumi.Input[str]]:
         """
-        The trust chain in PEM format for the RSA certificate you want to upload.
+        Trust chain in pem format for provided RSA certificate
         """
         return pulumi.get(self, "trust_chain_rsa_pem")
 
     @trust_chain_rsa_pem.setter
     def trust_chain_rsa_pem(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "trust_chain_rsa_pem", value)
 
@@ -321,15 +317,15 @@
     def unacknowledged_warnings(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "unacknowledged_warnings", value)
 
     @property
     @pulumi.getter(name="waitForDeployment")
     def wait_for_deployment(self) -> Optional[pulumi.Input[bool]]:
         """
-        Boolean. Enter `true` to wait for certificate to be deployed.
+        Whether to wait for certificate to be deployed
         """
         return pulumi.get(self, "wait_for_deployment")
 
     @wait_for_deployment.setter
     def wait_for_deployment(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "wait_for_deployment", value)
 
@@ -346,76 +342,35 @@
                  certificate_rsa_pem: Optional[pulumi.Input[str]] = None,
                  enrollment_id: Optional[pulumi.Input[int]] = None,
                  trust_chain_ecdsa_pem: Optional[pulumi.Input[str]] = None,
                  trust_chain_rsa_pem: Optional[pulumi.Input[str]] = None,
                  wait_for_deployment: Optional[pulumi.Input[bool]] = None,
                  __props__=None):
         """
-        Use the `CpsUploadCertificate` resource to upload a third-party certificate and any other files that your CA sent you into CPS. The certificate and trust chain that your CA gives you must be in PEM format before you can use it in CPS. A PEM certificate is a base64 encoded ASCII file and contains `----BEGIN CERTIFICATE-----` and `-----END CERTIFICATE-----` statements.
-
-        If your CA provides you with a certificate that is not in PEM format, you can convert it to PEM format using an SSL converter.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        upload_cert = akamai.CpsUploadCertificate("uploadCert",
-            enrollment_id=12345,
-            certificate_ecdsa_pem=example_cert_ecdsa["pem"],
-            trust_chain_ecdsa_pem=example_trust_chain_ecdsa["pem"],
-            acknowledge_post_verification_warnings=True,
-            acknowledge_change_management=True,
-            wait_for_deployment=True)
-        ```
-
+        Create a CpsUploadCertificate resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[bool] acknowledge_change_management: Boolean. Use only if `change_management` is set to `true` in the `CpsThirdPartyEnrollment` resource. Enter `true` to acknowledge that testing on staging is complete and to deploy the certificate to production.
-        :param pulumi.Input[bool] acknowledge_post_verification_warnings: Boolean. Enter `true` if you want to acknowledge the post-verification warnings defined in `auto_approve_warnings`.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] auto_approve_warnings: The list of post-verification warning IDs you want to automatically acknowledge. To retrieve the list of warnings, use the _get_cps_warnings_ data source.
-        :param pulumi.Input[str] certificate_ecdsa_pem: The ECDSA certificate in PEM format you want to upload.
-        :param pulumi.Input[str] certificate_rsa_pem: The RSA certificate in PEM format you want to upload.
-        :param pulumi.Input[int] enrollment_id: Unique identifier for the certificate enrollment.
-               * certificate PEM file (Required) - Include at least one of the following arguments for the PEM file to upload. You can upload an ECDSA certificate, an RSA certificate, or both.
-        :param pulumi.Input[str] trust_chain_ecdsa_pem: The trust chain in PEM format for the ECDSA certificate you want to upload.
-        :param pulumi.Input[str] trust_chain_rsa_pem: The trust chain in PEM format for the RSA certificate you want to upload.
-        :param pulumi.Input[bool] wait_for_deployment: Boolean. Enter `true` to wait for certificate to be deployed.
+        :param pulumi.Input[bool] acknowledge_change_management: Whether to acknowledge change management
+        :param pulumi.Input[bool] acknowledge_post_verification_warnings: Whether to acknowledge post-verification warnings
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] auto_approve_warnings: List of post-verification warnings to be automatically acknowledged
+        :param pulumi.Input[str] certificate_ecdsa_pem: ECDSA certificate in pem format to be uploaded
+        :param pulumi.Input[str] certificate_rsa_pem: RSA certificate in pem format to be uploaded
+        :param pulumi.Input[int] enrollment_id: The unique identifier of the enrollment
+        :param pulumi.Input[str] trust_chain_ecdsa_pem: Trust chain in pem format for provided ECDSA certificate
+        :param pulumi.Input[str] trust_chain_rsa_pem: Trust chain in pem format for provided RSA certificate
+        :param pulumi.Input[bool] wait_for_deployment: Whether to wait for certificate to be deployed
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: CpsUploadCertificateArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        Use the `CpsUploadCertificate` resource to upload a third-party certificate and any other files that your CA sent you into CPS. The certificate and trust chain that your CA gives you must be in PEM format before you can use it in CPS. A PEM certificate is a base64 encoded ASCII file and contains `----BEGIN CERTIFICATE-----` and `-----END CERTIFICATE-----` statements.
-
-        If your CA provides you with a certificate that is not in PEM format, you can convert it to PEM format using an SSL converter.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        upload_cert = akamai.CpsUploadCertificate("uploadCert",
-            enrollment_id=12345,
-            certificate_ecdsa_pem=example_cert_ecdsa["pem"],
-            trust_chain_ecdsa_pem=example_trust_chain_ecdsa["pem"],
-            acknowledge_post_verification_warnings=True,
-            acknowledge_change_management=True,
-            wait_for_deployment=True)
-        ```
-
+        Create a CpsUploadCertificate resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param CpsUploadCertificateArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(CpsUploadCertificateArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -480,25 +435,24 @@
         """
         Get an existing CpsUploadCertificate resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[bool] acknowledge_change_management: Boolean. Use only if `change_management` is set to `true` in the `CpsThirdPartyEnrollment` resource. Enter `true` to acknowledge that testing on staging is complete and to deploy the certificate to production.
-        :param pulumi.Input[bool] acknowledge_post_verification_warnings: Boolean. Enter `true` if you want to acknowledge the post-verification warnings defined in `auto_approve_warnings`.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] auto_approve_warnings: The list of post-verification warning IDs you want to automatically acknowledge. To retrieve the list of warnings, use the _get_cps_warnings_ data source.
-        :param pulumi.Input[str] certificate_ecdsa_pem: The ECDSA certificate in PEM format you want to upload.
-        :param pulumi.Input[str] certificate_rsa_pem: The RSA certificate in PEM format you want to upload.
-        :param pulumi.Input[int] enrollment_id: Unique identifier for the certificate enrollment.
-               * certificate PEM file (Required) - Include at least one of the following arguments for the PEM file to upload. You can upload an ECDSA certificate, an RSA certificate, or both.
-        :param pulumi.Input[str] trust_chain_ecdsa_pem: The trust chain in PEM format for the ECDSA certificate you want to upload.
-        :param pulumi.Input[str] trust_chain_rsa_pem: The trust chain in PEM format for the RSA certificate you want to upload.
+        :param pulumi.Input[bool] acknowledge_change_management: Whether to acknowledge change management
+        :param pulumi.Input[bool] acknowledge_post_verification_warnings: Whether to acknowledge post-verification warnings
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] auto_approve_warnings: List of post-verification warnings to be automatically acknowledged
+        :param pulumi.Input[str] certificate_ecdsa_pem: ECDSA certificate in pem format to be uploaded
+        :param pulumi.Input[str] certificate_rsa_pem: RSA certificate in pem format to be uploaded
+        :param pulumi.Input[int] enrollment_id: The unique identifier of the enrollment
+        :param pulumi.Input[str] trust_chain_ecdsa_pem: Trust chain in pem format for provided ECDSA certificate
+        :param pulumi.Input[str] trust_chain_rsa_pem: Trust chain in pem format for provided RSA certificate
         :param pulumi.Input[bool] unacknowledged_warnings: Used to distinguish whether there are unacknowledged warnings for a certificate
-        :param pulumi.Input[bool] wait_for_deployment: Boolean. Enter `true` to wait for certificate to be deployed.
+        :param pulumi.Input[bool] wait_for_deployment: Whether to wait for certificate to be deployed
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _CpsUploadCertificateState.__new__(_CpsUploadCertificateState)
 
         __props__.__dict__["acknowledge_change_management"] = acknowledge_change_management
         __props__.__dict__["acknowledge_post_verification_warnings"] = acknowledge_post_verification_warnings
@@ -512,72 +466,71 @@
         __props__.__dict__["wait_for_deployment"] = wait_for_deployment
         return CpsUploadCertificate(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="acknowledgeChangeManagement")
     def acknowledge_change_management(self) -> pulumi.Output[Optional[bool]]:
         """
-        Boolean. Use only if `change_management` is set to `true` in the `CpsThirdPartyEnrollment` resource. Enter `true` to acknowledge that testing on staging is complete and to deploy the certificate to production.
+        Whether to acknowledge change management
         """
         return pulumi.get(self, "acknowledge_change_management")
 
     @property
     @pulumi.getter(name="acknowledgePostVerificationWarnings")
     def acknowledge_post_verification_warnings(self) -> pulumi.Output[Optional[bool]]:
         """
-        Boolean. Enter `true` if you want to acknowledge the post-verification warnings defined in `auto_approve_warnings`.
+        Whether to acknowledge post-verification warnings
         """
         return pulumi.get(self, "acknowledge_post_verification_warnings")
 
     @property
     @pulumi.getter(name="autoApproveWarnings")
     def auto_approve_warnings(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        The list of post-verification warning IDs you want to automatically acknowledge. To retrieve the list of warnings, use the _get_cps_warnings_ data source.
+        List of post-verification warnings to be automatically acknowledged
         """
         return pulumi.get(self, "auto_approve_warnings")
 
     @property
     @pulumi.getter(name="certificateEcdsaPem")
     def certificate_ecdsa_pem(self) -> pulumi.Output[Optional[str]]:
         """
-        The ECDSA certificate in PEM format you want to upload.
+        ECDSA certificate in pem format to be uploaded
         """
         return pulumi.get(self, "certificate_ecdsa_pem")
 
     @property
     @pulumi.getter(name="certificateRsaPem")
     def certificate_rsa_pem(self) -> pulumi.Output[Optional[str]]:
         """
-        The RSA certificate in PEM format you want to upload.
+        RSA certificate in pem format to be uploaded
         """
         return pulumi.get(self, "certificate_rsa_pem")
 
     @property
     @pulumi.getter(name="enrollmentId")
     def enrollment_id(self) -> pulumi.Output[int]:
         """
-        Unique identifier for the certificate enrollment.
-        * certificate PEM file (Required) - Include at least one of the following arguments for the PEM file to upload. You can upload an ECDSA certificate, an RSA certificate, or both.
+        The unique identifier of the enrollment
         """
         return pulumi.get(self, "enrollment_id")
 
     @property
     @pulumi.getter(name="trustChainEcdsaPem")
     def trust_chain_ecdsa_pem(self) -> pulumi.Output[Optional[str]]:
         """
-        The trust chain in PEM format for the ECDSA certificate you want to upload.
+        Trust chain in pem format for provided ECDSA certificate
         """
         return pulumi.get(self, "trust_chain_ecdsa_pem")
 
     @property
     @pulumi.getter(name="trustChainRsaPem")
     def trust_chain_rsa_pem(self) -> pulumi.Output[Optional[str]]:
         """
-        The trust chain in PEM format for the RSA certificate you want to upload.
+        Trust chain in pem format for provided RSA certificate
         """
         return pulumi.get(self, "trust_chain_rsa_pem")
 
     @property
     @pulumi.getter(name="unacknowledgedWarnings")
     def unacknowledged_warnings(self) -> pulumi.Output[bool]:
         """
@@ -585,11 +538,11 @@
         """
         return pulumi.get(self, "unacknowledged_warnings")
 
     @property
     @pulumi.getter(name="waitForDeployment")
     def wait_for_deployment(self) -> pulumi.Output[Optional[bool]]:
         """
-        Boolean. Enter `true` to wait for certificate to be deployed.
+        Whether to wait for certificate to be deployed
         """
         return pulumi.get(self, "wait_for_deployment")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/datastream.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/trafficmanagement/gtm_property.py`

 * *Files 27% similar despite different names*

```diff
@@ -3,1370 +3,1235 @@
 # *** Do not edit by hand unless you're certain you know what you are doing! ***
 
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
-from . import _utilities
+from .. import _utilities
 from . import outputs
 from ._inputs import *
 
-__all__ = ['DatastreamArgs', 'Datastream']
+__all__ = ['GtmPropertyArgs', 'GtmProperty']
 
 @pulumi.input_type
-class DatastreamArgs:
+class GtmPropertyArgs:
     def __init__(__self__, *,
-                 active: pulumi.Input[bool],
-                 config: pulumi.Input['DatastreamConfigArgs'],
-                 contract_id: pulumi.Input[str],
-                 dataset_fields_ids: pulumi.Input[Sequence[pulumi.Input[int]]],
-                 group_id: pulumi.Input[str],
-                 property_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
-                 stream_name: pulumi.Input[str],
-                 stream_type: pulumi.Input[str],
-                 template_name: pulumi.Input[str],
-                 azure_connector: Optional[pulumi.Input['DatastreamAzureConnectorArgs']] = None,
-                 datadog_connector: Optional[pulumi.Input['DatastreamDatadogConnectorArgs']] = None,
-                 elasticsearch_connector: Optional[pulumi.Input['DatastreamElasticsearchConnectorArgs']] = None,
-                 email_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 gcs_connector: Optional[pulumi.Input['DatastreamGcsConnectorArgs']] = None,
-                 https_connector: Optional[pulumi.Input['DatastreamHttpsConnectorArgs']] = None,
-                 loggly_connector: Optional[pulumi.Input['DatastreamLogglyConnectorArgs']] = None,
-                 new_relic_connector: Optional[pulumi.Input['DatastreamNewRelicConnectorArgs']] = None,
-                 oracle_connector: Optional[pulumi.Input['DatastreamOracleConnectorArgs']] = None,
-                 s3_connector: Optional[pulumi.Input['DatastreamS3ConnectorArgs']] = None,
-                 splunk_connector: Optional[pulumi.Input['DatastreamSplunkConnectorArgs']] = None,
-                 sumologic_connector: Optional[pulumi.Input['DatastreamSumologicConnectorArgs']] = None):
-        """
-        The set of arguments for constructing a Datastream resource.
-        :param pulumi.Input[bool] active: Whether you want to start activating the stream when applying the resource. Either `true` for activating the stream upon sending the request or `false` for leaving the stream inactive after the request.
-        :param pulumi.Input['DatastreamConfigArgs'] config: Provides information about the log line configuration, log file format, names of log files sent, and file delivery. The argument includes these sub-arguments:
-        :param pulumi.Input[str] contract_id: Identifies the contract that has access to the product.
-        :param pulumi.Input[Sequence[pulumi.Input[int]]] dataset_fields_ids: Identifiers of the data set fields within the template that you want to receive in logs. The order of the identifiers define how the value for these fields appears in the log lines. See [Data set parameters](https://techdocs.akamai.com/datastream2/reference/data-set-parameters-1).
-        :param pulumi.Input[str] group_id: Identifies the group that has access to the product and this stream configuration.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] property_ids: Identifies the properties that you want to monitor in the stream. Note that a stream can only log data for active properties.
-        :param pulumi.Input[str] stream_name: The name of the stream.
-        :param pulumi.Input[str] stream_type: The type of stream that you want to create. Currently, `RAW_LOGS` is the only possible stream type.
-        :param pulumi.Input[str] template_name: The name of the data set template available for the product that you want to use in the stream. Currently, `EDGE_LOGS` is the only data set template available.
-        :param pulumi.Input['DatastreamAzureConnectorArgs'] azure_connector: Specify details about the Azure Storage connector configuration in a data stream. Note that currently DataStream supports only streaming data to [block objects](https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs). The argument includes these sub-arguments:
-        :param pulumi.Input['DatastreamDatadogConnectorArgs'] datadog_connector: Specify details about the Datadog connector in a stream, including:
-        :param pulumi.Input['DatastreamElasticsearchConnectorArgs'] elasticsearch_connector: Specify details about the Elasticsearch connector you can use in a stream, including:
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_ids: A list of email addresses you want to notify about activations and deactivations of the stream.
-        :param pulumi.Input['DatastreamGcsConnectorArgs'] gcs_connector: Specify details about the Google Cloud Storage connector you can use in a stream. When validating this connector, DataStream uses the private access key to create an `Akamai_access_verification_<timestamp>.txt` object file in your GCS bucket. You can only see this file if the validation process is successful, and you have access to the Google Cloud Storage bucket where you are trying to send logs. The argument includes these sub-arguments:
-        :param pulumi.Input['DatastreamHttpsConnectorArgs'] https_connector: Specify details about the custom HTTPS endpoint you can use as a connector for a stream, including:
-        :param pulumi.Input['DatastreamLogglyConnectorArgs'] loggly_connector: Specify details about the Loggly connector you can use in a stream, including:
-        :param pulumi.Input['DatastreamNewRelicConnectorArgs'] new_relic_connector: Specify details about the New Relic connector you can use in a stream, including:
-        :param pulumi.Input['DatastreamOracleConnectorArgs'] oracle_connector: Specify details about the Oracle Cloud Storage connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and tries to save an `Akamai_access_verification_<timestamp>.txt` file in your Oracle Cloud Storage folder. You can only see this file if the validation process is successful, and you have access to the Oracle Cloud Storage bucket and folder that youre trying to send logs to.
-        :param pulumi.Input['DatastreamS3ConnectorArgs'] s3_connector: Specify details about the Amazon S3 connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and saves an `akamai_write_test_2147483647.txt` file in your Amazon S3 folder. You can only see this file if validation succeeds, and you have access to the Amazon S3 bucket and folder that youre trying to send logs to. The argument includes these sub-arguments:
-        :param pulumi.Input['DatastreamSplunkConnectorArgs'] splunk_connector: Specify details about the Splunk connector in your stream. Note that currently DataStream supports only endpoint URLs ending with `collector/raw`. The argument includes these sub-arguments:
-        :param pulumi.Input['DatastreamSumologicConnectorArgs'] sumologic_connector: Specify details about the Sumo Logic connector in a stream, including:
-        """
-        pulumi.set(__self__, "active", active)
-        pulumi.set(__self__, "config", config)
-        pulumi.set(__self__, "contract_id", contract_id)
-        pulumi.set(__self__, "dataset_fields_ids", dataset_fields_ids)
-        pulumi.set(__self__, "group_id", group_id)
-        pulumi.set(__self__, "property_ids", property_ids)
-        pulumi.set(__self__, "stream_name", stream_name)
-        pulumi.set(__self__, "stream_type", stream_type)
-        pulumi.set(__self__, "template_name", template_name)
-        if azure_connector is not None:
-            pulumi.set(__self__, "azure_connector", azure_connector)
-        if datadog_connector is not None:
-            pulumi.set(__self__, "datadog_connector", datadog_connector)
-        if elasticsearch_connector is not None:
-            pulumi.set(__self__, "elasticsearch_connector", elasticsearch_connector)
-        if email_ids is not None:
-            pulumi.set(__self__, "email_ids", email_ids)
-        if gcs_connector is not None:
-            pulumi.set(__self__, "gcs_connector", gcs_connector)
-        if https_connector is not None:
-            pulumi.set(__self__, "https_connector", https_connector)
-        if loggly_connector is not None:
-            pulumi.set(__self__, "loggly_connector", loggly_connector)
-        if new_relic_connector is not None:
-            pulumi.set(__self__, "new_relic_connector", new_relic_connector)
-        if oracle_connector is not None:
-            pulumi.set(__self__, "oracle_connector", oracle_connector)
-        if s3_connector is not None:
-            pulumi.set(__self__, "s3_connector", s3_connector)
-        if splunk_connector is not None:
-            pulumi.set(__self__, "splunk_connector", splunk_connector)
-        if sumologic_connector is not None:
-            pulumi.set(__self__, "sumologic_connector", sumologic_connector)
+                 domain: pulumi.Input[str],
+                 handout_limit: pulumi.Input[int],
+                 handout_mode: pulumi.Input[str],
+                 score_aggregation_type: pulumi.Input[str],
+                 type: pulumi.Input[str],
+                 backup_cname: Optional[pulumi.Input[str]] = None,
+                 backup_ip: Optional[pulumi.Input[str]] = None,
+                 balance_by_download_score: Optional[pulumi.Input[bool]] = None,
+                 cname: Optional[pulumi.Input[str]] = None,
+                 comments: Optional[pulumi.Input[str]] = None,
+                 dynamic_ttl: Optional[pulumi.Input[int]] = None,
+                 failback_delay: Optional[pulumi.Input[int]] = None,
+                 failover_delay: Optional[pulumi.Input[int]] = None,
+                 ghost_demand_reporting: Optional[pulumi.Input[bool]] = None,
+                 health_max: Optional[pulumi.Input[float]] = None,
+                 health_multiplier: Optional[pulumi.Input[float]] = None,
+                 health_threshold: Optional[pulumi.Input[float]] = None,
+                 ipv6: Optional[pulumi.Input[bool]] = None,
+                 liveness_tests: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]] = None,
+                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
+                 map_name: Optional[pulumi.Input[str]] = None,
+                 max_unreachable_penalty: Optional[pulumi.Input[int]] = None,
+                 min_live_fraction: Optional[pulumi.Input[float]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
+                 static_rr_sets: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]] = None,
+                 static_ttl: Optional[pulumi.Input[int]] = None,
+                 stickiness_bonus_constant: Optional[pulumi.Input[int]] = None,
+                 stickiness_bonus_percentage: Optional[pulumi.Input[int]] = None,
+                 traffic_targets: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]] = None,
+                 unreachable_threshold: Optional[pulumi.Input[float]] = None,
+                 use_computed_targets: Optional[pulumi.Input[bool]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None):
+        """
+        The set of arguments for constructing a GtmProperty resource.
+        """
+        pulumi.set(__self__, "domain", domain)
+        pulumi.set(__self__, "handout_limit", handout_limit)
+        pulumi.set(__self__, "handout_mode", handout_mode)
+        pulumi.set(__self__, "score_aggregation_type", score_aggregation_type)
+        pulumi.set(__self__, "type", type)
+        if backup_cname is not None:
+            pulumi.set(__self__, "backup_cname", backup_cname)
+        if backup_ip is not None:
+            pulumi.set(__self__, "backup_ip", backup_ip)
+        if balance_by_download_score is not None:
+            pulumi.set(__self__, "balance_by_download_score", balance_by_download_score)
+        if cname is not None:
+            pulumi.set(__self__, "cname", cname)
+        if comments is not None:
+            pulumi.set(__self__, "comments", comments)
+        if dynamic_ttl is not None:
+            pulumi.set(__self__, "dynamic_ttl", dynamic_ttl)
+        if failback_delay is not None:
+            pulumi.set(__self__, "failback_delay", failback_delay)
+        if failover_delay is not None:
+            pulumi.set(__self__, "failover_delay", failover_delay)
+        if ghost_demand_reporting is not None:
+            pulumi.set(__self__, "ghost_demand_reporting", ghost_demand_reporting)
+        if health_max is not None:
+            pulumi.set(__self__, "health_max", health_max)
+        if health_multiplier is not None:
+            pulumi.set(__self__, "health_multiplier", health_multiplier)
+        if health_threshold is not None:
+            pulumi.set(__self__, "health_threshold", health_threshold)
+        if ipv6 is not None:
+            pulumi.set(__self__, "ipv6", ipv6)
+        if liveness_tests is not None:
+            pulumi.set(__self__, "liveness_tests", liveness_tests)
+        if load_imbalance_percentage is not None:
+            pulumi.set(__self__, "load_imbalance_percentage", load_imbalance_percentage)
+        if map_name is not None:
+            pulumi.set(__self__, "map_name", map_name)
+        if max_unreachable_penalty is not None:
+            pulumi.set(__self__, "max_unreachable_penalty", max_unreachable_penalty)
+        if min_live_fraction is not None:
+            pulumi.set(__self__, "min_live_fraction", min_live_fraction)
+        if name is not None:
+            pulumi.set(__self__, "name", name)
+        if static_rr_sets is not None:
+            pulumi.set(__self__, "static_rr_sets", static_rr_sets)
+        if static_ttl is not None:
+            pulumi.set(__self__, "static_ttl", static_ttl)
+        if stickiness_bonus_constant is not None:
+            pulumi.set(__self__, "stickiness_bonus_constant", stickiness_bonus_constant)
+        if stickiness_bonus_percentage is not None:
+            pulumi.set(__self__, "stickiness_bonus_percentage", stickiness_bonus_percentage)
+        if traffic_targets is not None:
+            pulumi.set(__self__, "traffic_targets", traffic_targets)
+        if unreachable_threshold is not None:
+            pulumi.set(__self__, "unreachable_threshold", unreachable_threshold)
+        if use_computed_targets is not None:
+            pulumi.set(__self__, "use_computed_targets", use_computed_targets)
+        if wait_on_complete is not None:
+            pulumi.set(__self__, "wait_on_complete", wait_on_complete)
 
     @property
     @pulumi.getter
-    def active(self) -> pulumi.Input[bool]:
-        """
-        Whether you want to start activating the stream when applying the resource. Either `true` for activating the stream upon sending the request or `false` for leaving the stream inactive after the request.
-        """
-        return pulumi.get(self, "active")
+    def domain(self) -> pulumi.Input[str]:
+        return pulumi.get(self, "domain")
 
-    @active.setter
-    def active(self, value: pulumi.Input[bool]):
-        pulumi.set(self, "active", value)
+    @domain.setter
+    def domain(self, value: pulumi.Input[str]):
+        pulumi.set(self, "domain", value)
+
+    @property
+    @pulumi.getter(name="handoutLimit")
+    def handout_limit(self) -> pulumi.Input[int]:
+        return pulumi.get(self, "handout_limit")
+
+    @handout_limit.setter
+    def handout_limit(self, value: pulumi.Input[int]):
+        pulumi.set(self, "handout_limit", value)
+
+    @property
+    @pulumi.getter(name="handoutMode")
+    def handout_mode(self) -> pulumi.Input[str]:
+        return pulumi.get(self, "handout_mode")
+
+    @handout_mode.setter
+    def handout_mode(self, value: pulumi.Input[str]):
+        pulumi.set(self, "handout_mode", value)
+
+    @property
+    @pulumi.getter(name="scoreAggregationType")
+    def score_aggregation_type(self) -> pulumi.Input[str]:
+        return pulumi.get(self, "score_aggregation_type")
+
+    @score_aggregation_type.setter
+    def score_aggregation_type(self, value: pulumi.Input[str]):
+        pulumi.set(self, "score_aggregation_type", value)
 
     @property
     @pulumi.getter
-    def config(self) -> pulumi.Input['DatastreamConfigArgs']:
-        """
-        Provides information about the log line configuration, log file format, names of log files sent, and file delivery. The argument includes these sub-arguments:
-        """
-        return pulumi.get(self, "config")
+    def type(self) -> pulumi.Input[str]:
+        return pulumi.get(self, "type")
 
-    @config.setter
-    def config(self, value: pulumi.Input['DatastreamConfigArgs']):
-        pulumi.set(self, "config", value)
+    @type.setter
+    def type(self, value: pulumi.Input[str]):
+        pulumi.set(self, "type", value)
 
     @property
-    @pulumi.getter(name="contractId")
-    def contract_id(self) -> pulumi.Input[str]:
-        """
-        Identifies the contract that has access to the product.
-        """
-        return pulumi.get(self, "contract_id")
+    @pulumi.getter(name="backupCname")
+    def backup_cname(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "backup_cname")
 
-    @contract_id.setter
-    def contract_id(self, value: pulumi.Input[str]):
-        pulumi.set(self, "contract_id", value)
+    @backup_cname.setter
+    def backup_cname(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "backup_cname", value)
 
     @property
-    @pulumi.getter(name="datasetFieldsIds")
-    def dataset_fields_ids(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
-        """
-        Identifiers of the data set fields within the template that you want to receive in logs. The order of the identifiers define how the value for these fields appears in the log lines. See [Data set parameters](https://techdocs.akamai.com/datastream2/reference/data-set-parameters-1).
-        """
-        return pulumi.get(self, "dataset_fields_ids")
+    @pulumi.getter(name="backupIp")
+    def backup_ip(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "backup_ip")
 
-    @dataset_fields_ids.setter
-    def dataset_fields_ids(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
-        pulumi.set(self, "dataset_fields_ids", value)
+    @backup_ip.setter
+    def backup_ip(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "backup_ip", value)
 
     @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> pulumi.Input[str]:
-        """
-        Identifies the group that has access to the product and this stream configuration.
-        """
-        return pulumi.get(self, "group_id")
+    @pulumi.getter(name="balanceByDownloadScore")
+    def balance_by_download_score(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "balance_by_download_score")
 
-    @group_id.setter
-    def group_id(self, value: pulumi.Input[str]):
-        pulumi.set(self, "group_id", value)
+    @balance_by_download_score.setter
+    def balance_by_download_score(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "balance_by_download_score", value)
 
     @property
-    @pulumi.getter(name="propertyIds")
-    def property_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
-        """
-        Identifies the properties that you want to monitor in the stream. Note that a stream can only log data for active properties.
-        """
-        return pulumi.get(self, "property_ids")
+    @pulumi.getter
+    def cname(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "cname")
 
-    @property_ids.setter
-    def property_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
-        pulumi.set(self, "property_ids", value)
+    @cname.setter
+    def cname(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "cname", value)
 
     @property
-    @pulumi.getter(name="streamName")
-    def stream_name(self) -> pulumi.Input[str]:
-        """
-        The name of the stream.
-        """
-        return pulumi.get(self, "stream_name")
+    @pulumi.getter
+    def comments(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "comments")
 
-    @stream_name.setter
-    def stream_name(self, value: pulumi.Input[str]):
-        pulumi.set(self, "stream_name", value)
+    @comments.setter
+    def comments(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "comments", value)
 
     @property
-    @pulumi.getter(name="streamType")
-    def stream_type(self) -> pulumi.Input[str]:
-        """
-        The type of stream that you want to create. Currently, `RAW_LOGS` is the only possible stream type.
-        """
-        return pulumi.get(self, "stream_type")
+    @pulumi.getter(name="dynamicTtl")
+    def dynamic_ttl(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "dynamic_ttl")
 
-    @stream_type.setter
-    def stream_type(self, value: pulumi.Input[str]):
-        pulumi.set(self, "stream_type", value)
+    @dynamic_ttl.setter
+    def dynamic_ttl(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "dynamic_ttl", value)
 
     @property
-    @pulumi.getter(name="templateName")
-    def template_name(self) -> pulumi.Input[str]:
-        """
-        The name of the data set template available for the product that you want to use in the stream. Currently, `EDGE_LOGS` is the only data set template available.
-        """
-        return pulumi.get(self, "template_name")
+    @pulumi.getter(name="failbackDelay")
+    def failback_delay(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "failback_delay")
 
-    @template_name.setter
-    def template_name(self, value: pulumi.Input[str]):
-        pulumi.set(self, "template_name", value)
+    @failback_delay.setter
+    def failback_delay(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "failback_delay", value)
 
     @property
-    @pulumi.getter(name="azureConnector")
-    def azure_connector(self) -> Optional[pulumi.Input['DatastreamAzureConnectorArgs']]:
-        """
-        Specify details about the Azure Storage connector configuration in a data stream. Note that currently DataStream supports only streaming data to [block objects](https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs). The argument includes these sub-arguments:
-        """
-        return pulumi.get(self, "azure_connector")
+    @pulumi.getter(name="failoverDelay")
+    def failover_delay(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "failover_delay")
 
-    @azure_connector.setter
-    def azure_connector(self, value: Optional[pulumi.Input['DatastreamAzureConnectorArgs']]):
-        pulumi.set(self, "azure_connector", value)
+    @failover_delay.setter
+    def failover_delay(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "failover_delay", value)
 
     @property
-    @pulumi.getter(name="datadogConnector")
-    def datadog_connector(self) -> Optional[pulumi.Input['DatastreamDatadogConnectorArgs']]:
-        """
-        Specify details about the Datadog connector in a stream, including:
-        """
-        return pulumi.get(self, "datadog_connector")
+    @pulumi.getter(name="ghostDemandReporting")
+    def ghost_demand_reporting(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "ghost_demand_reporting")
 
-    @datadog_connector.setter
-    def datadog_connector(self, value: Optional[pulumi.Input['DatastreamDatadogConnectorArgs']]):
-        pulumi.set(self, "datadog_connector", value)
+    @ghost_demand_reporting.setter
+    def ghost_demand_reporting(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "ghost_demand_reporting", value)
 
     @property
-    @pulumi.getter(name="elasticsearchConnector")
-    def elasticsearch_connector(self) -> Optional[pulumi.Input['DatastreamElasticsearchConnectorArgs']]:
-        """
-        Specify details about the Elasticsearch connector you can use in a stream, including:
-        """
-        return pulumi.get(self, "elasticsearch_connector")
+    @pulumi.getter(name="healthMax")
+    def health_max(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "health_max")
 
-    @elasticsearch_connector.setter
-    def elasticsearch_connector(self, value: Optional[pulumi.Input['DatastreamElasticsearchConnectorArgs']]):
-        pulumi.set(self, "elasticsearch_connector", value)
+    @health_max.setter
+    def health_max(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "health_max", value)
 
     @property
-    @pulumi.getter(name="emailIds")
-    def email_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
-        """
-        A list of email addresses you want to notify about activations and deactivations of the stream.
-        """
-        return pulumi.get(self, "email_ids")
+    @pulumi.getter(name="healthMultiplier")
+    def health_multiplier(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "health_multiplier")
 
-    @email_ids.setter
-    def email_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
-        pulumi.set(self, "email_ids", value)
+    @health_multiplier.setter
+    def health_multiplier(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "health_multiplier", value)
 
     @property
-    @pulumi.getter(name="gcsConnector")
-    def gcs_connector(self) -> Optional[pulumi.Input['DatastreamGcsConnectorArgs']]:
-        """
-        Specify details about the Google Cloud Storage connector you can use in a stream. When validating this connector, DataStream uses the private access key to create an `Akamai_access_verification_<timestamp>.txt` object file in your GCS bucket. You can only see this file if the validation process is successful, and you have access to the Google Cloud Storage bucket where you are trying to send logs. The argument includes these sub-arguments:
-        """
-        return pulumi.get(self, "gcs_connector")
+    @pulumi.getter(name="healthThreshold")
+    def health_threshold(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "health_threshold")
 
-    @gcs_connector.setter
-    def gcs_connector(self, value: Optional[pulumi.Input['DatastreamGcsConnectorArgs']]):
-        pulumi.set(self, "gcs_connector", value)
+    @health_threshold.setter
+    def health_threshold(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "health_threshold", value)
 
     @property
-    @pulumi.getter(name="httpsConnector")
-    def https_connector(self) -> Optional[pulumi.Input['DatastreamHttpsConnectorArgs']]:
-        """
-        Specify details about the custom HTTPS endpoint you can use as a connector for a stream, including:
-        """
-        return pulumi.get(self, "https_connector")
+    @pulumi.getter
+    def ipv6(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "ipv6")
 
-    @https_connector.setter
-    def https_connector(self, value: Optional[pulumi.Input['DatastreamHttpsConnectorArgs']]):
-        pulumi.set(self, "https_connector", value)
+    @ipv6.setter
+    def ipv6(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "ipv6", value)
 
     @property
-    @pulumi.getter(name="logglyConnector")
-    def loggly_connector(self) -> Optional[pulumi.Input['DatastreamLogglyConnectorArgs']]:
-        """
-        Specify details about the Loggly connector you can use in a stream, including:
-        """
-        return pulumi.get(self, "loggly_connector")
+    @pulumi.getter(name="livenessTests")
+    def liveness_tests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]]:
+        return pulumi.get(self, "liveness_tests")
 
-    @loggly_connector.setter
-    def loggly_connector(self, value: Optional[pulumi.Input['DatastreamLogglyConnectorArgs']]):
-        pulumi.set(self, "loggly_connector", value)
+    @liveness_tests.setter
+    def liveness_tests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]]):
+        pulumi.set(self, "liveness_tests", value)
 
     @property
-    @pulumi.getter(name="newRelicConnector")
-    def new_relic_connector(self) -> Optional[pulumi.Input['DatastreamNewRelicConnectorArgs']]:
-        """
-        Specify details about the New Relic connector you can use in a stream, including:
-        """
-        return pulumi.get(self, "new_relic_connector")
+    @pulumi.getter(name="loadImbalancePercentage")
+    def load_imbalance_percentage(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "load_imbalance_percentage")
 
-    @new_relic_connector.setter
-    def new_relic_connector(self, value: Optional[pulumi.Input['DatastreamNewRelicConnectorArgs']]):
-        pulumi.set(self, "new_relic_connector", value)
+    @load_imbalance_percentage.setter
+    def load_imbalance_percentage(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "load_imbalance_percentage", value)
 
     @property
-    @pulumi.getter(name="oracleConnector")
-    def oracle_connector(self) -> Optional[pulumi.Input['DatastreamOracleConnectorArgs']]:
-        """
-        Specify details about the Oracle Cloud Storage connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and tries to save an `Akamai_access_verification_<timestamp>.txt` file in your Oracle Cloud Storage folder. You can only see this file if the validation process is successful, and you have access to the Oracle Cloud Storage bucket and folder that youre trying to send logs to.
-        """
-        return pulumi.get(self, "oracle_connector")
+    @pulumi.getter(name="mapName")
+    def map_name(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "map_name")
 
-    @oracle_connector.setter
-    def oracle_connector(self, value: Optional[pulumi.Input['DatastreamOracleConnectorArgs']]):
-        pulumi.set(self, "oracle_connector", value)
+    @map_name.setter
+    def map_name(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "map_name", value)
 
     @property
-    @pulumi.getter(name="s3Connector")
-    def s3_connector(self) -> Optional[pulumi.Input['DatastreamS3ConnectorArgs']]:
-        """
-        Specify details about the Amazon S3 connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and saves an `akamai_write_test_2147483647.txt` file in your Amazon S3 folder. You can only see this file if validation succeeds, and you have access to the Amazon S3 bucket and folder that youre trying to send logs to. The argument includes these sub-arguments:
-        """
-        return pulumi.get(self, "s3_connector")
+    @pulumi.getter(name="maxUnreachablePenalty")
+    def max_unreachable_penalty(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "max_unreachable_penalty")
 
-    @s3_connector.setter
-    def s3_connector(self, value: Optional[pulumi.Input['DatastreamS3ConnectorArgs']]):
-        pulumi.set(self, "s3_connector", value)
+    @max_unreachable_penalty.setter
+    def max_unreachable_penalty(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "max_unreachable_penalty", value)
 
     @property
-    @pulumi.getter(name="splunkConnector")
-    def splunk_connector(self) -> Optional[pulumi.Input['DatastreamSplunkConnectorArgs']]:
-        """
-        Specify details about the Splunk connector in your stream. Note that currently DataStream supports only endpoint URLs ending with `collector/raw`. The argument includes these sub-arguments:
-        """
-        return pulumi.get(self, "splunk_connector")
+    @pulumi.getter(name="minLiveFraction")
+    def min_live_fraction(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "min_live_fraction")
 
-    @splunk_connector.setter
-    def splunk_connector(self, value: Optional[pulumi.Input['DatastreamSplunkConnectorArgs']]):
-        pulumi.set(self, "splunk_connector", value)
+    @min_live_fraction.setter
+    def min_live_fraction(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "min_live_fraction", value)
 
     @property
-    @pulumi.getter(name="sumologicConnector")
-    def sumologic_connector(self) -> Optional[pulumi.Input['DatastreamSumologicConnectorArgs']]:
-        """
-        Specify details about the Sumo Logic connector in a stream, including:
-        """
-        return pulumi.get(self, "sumologic_connector")
+    @pulumi.getter
+    def name(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "name")
+
+    @name.setter
+    def name(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "name", value)
 
-    @sumologic_connector.setter
-    def sumologic_connector(self, value: Optional[pulumi.Input['DatastreamSumologicConnectorArgs']]):
-        pulumi.set(self, "sumologic_connector", value)
+    @property
+    @pulumi.getter(name="staticRrSets")
+    def static_rr_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]]:
+        return pulumi.get(self, "static_rr_sets")
+
+    @static_rr_sets.setter
+    def static_rr_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]]):
+        pulumi.set(self, "static_rr_sets", value)
+
+    @property
+    @pulumi.getter(name="staticTtl")
+    def static_ttl(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "static_ttl")
+
+    @static_ttl.setter
+    def static_ttl(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "static_ttl", value)
+
+    @property
+    @pulumi.getter(name="stickinessBonusConstant")
+    def stickiness_bonus_constant(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "stickiness_bonus_constant")
+
+    @stickiness_bonus_constant.setter
+    def stickiness_bonus_constant(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "stickiness_bonus_constant", value)
+
+    @property
+    @pulumi.getter(name="stickinessBonusPercentage")
+    def stickiness_bonus_percentage(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "stickiness_bonus_percentage")
+
+    @stickiness_bonus_percentage.setter
+    def stickiness_bonus_percentage(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "stickiness_bonus_percentage", value)
+
+    @property
+    @pulumi.getter(name="trafficTargets")
+    def traffic_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]]:
+        return pulumi.get(self, "traffic_targets")
+
+    @traffic_targets.setter
+    def traffic_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]]):
+        pulumi.set(self, "traffic_targets", value)
+
+    @property
+    @pulumi.getter(name="unreachableThreshold")
+    def unreachable_threshold(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "unreachable_threshold")
+
+    @unreachable_threshold.setter
+    def unreachable_threshold(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "unreachable_threshold", value)
+
+    @property
+    @pulumi.getter(name="useComputedTargets")
+    def use_computed_targets(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "use_computed_targets")
+
+    @use_computed_targets.setter
+    def use_computed_targets(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "use_computed_targets", value)
+
+    @property
+    @pulumi.getter(name="waitOnComplete")
+    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "wait_on_complete")
+
+    @wait_on_complete.setter
+    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "wait_on_complete", value)
 
 
 @pulumi.input_type
-class _DatastreamState:
+class _GtmPropertyState:
     def __init__(__self__, *,
-                 active: Optional[pulumi.Input[bool]] = None,
-                 azure_connector: Optional[pulumi.Input['DatastreamAzureConnectorArgs']] = None,
-                 config: Optional[pulumi.Input['DatastreamConfigArgs']] = None,
-                 contract_id: Optional[pulumi.Input[str]] = None,
-                 created_by: Optional[pulumi.Input[str]] = None,
-                 created_date: Optional[pulumi.Input[str]] = None,
-                 datadog_connector: Optional[pulumi.Input['DatastreamDatadogConnectorArgs']] = None,
-                 dataset_fields_ids: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
-                 elasticsearch_connector: Optional[pulumi.Input['DatastreamElasticsearchConnectorArgs']] = None,
-                 email_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 gcs_connector: Optional[pulumi.Input['DatastreamGcsConnectorArgs']] = None,
-                 group_id: Optional[pulumi.Input[str]] = None,
-                 group_name: Optional[pulumi.Input[str]] = None,
-                 https_connector: Optional[pulumi.Input['DatastreamHttpsConnectorArgs']] = None,
-                 loggly_connector: Optional[pulumi.Input['DatastreamLogglyConnectorArgs']] = None,
-                 modified_by: Optional[pulumi.Input[str]] = None,
-                 modified_date: Optional[pulumi.Input[str]] = None,
-                 new_relic_connector: Optional[pulumi.Input['DatastreamNewRelicConnectorArgs']] = None,
-                 oracle_connector: Optional[pulumi.Input['DatastreamOracleConnectorArgs']] = None,
-                 papi_json: Optional[pulumi.Input[str]] = None,
-                 product_id: Optional[pulumi.Input[str]] = None,
-                 product_name: Optional[pulumi.Input[str]] = None,
-                 property_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 s3_connector: Optional[pulumi.Input['DatastreamS3ConnectorArgs']] = None,
-                 splunk_connector: Optional[pulumi.Input['DatastreamSplunkConnectorArgs']] = None,
-                 stream_name: Optional[pulumi.Input[str]] = None,
-                 stream_type: Optional[pulumi.Input[str]] = None,
-                 stream_version_id: Optional[pulumi.Input[int]] = None,
-                 sumologic_connector: Optional[pulumi.Input['DatastreamSumologicConnectorArgs']] = None,
-                 template_name: Optional[pulumi.Input[str]] = None):
-        """
-        Input properties used for looking up and filtering Datastream resources.
-        :param pulumi.Input[bool] active: Whether you want to start activating the stream when applying the resource. Either `true` for activating the stream upon sending the request or `false` for leaving the stream inactive after the request.
-        :param pulumi.Input['DatastreamAzureConnectorArgs'] azure_connector: Specify details about the Azure Storage connector configuration in a data stream. Note that currently DataStream supports only streaming data to [block objects](https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs). The argument includes these sub-arguments:
-        :param pulumi.Input['DatastreamConfigArgs'] config: Provides information about the log line configuration, log file format, names of log files sent, and file delivery. The argument includes these sub-arguments:
-        :param pulumi.Input[str] contract_id: Identifies the contract that has access to the product.
-        :param pulumi.Input[str] created_by: The username who created the stream
-        :param pulumi.Input[str] created_date: The date and time when the stream was created
-        :param pulumi.Input['DatastreamDatadogConnectorArgs'] datadog_connector: Specify details about the Datadog connector in a stream, including:
-        :param pulumi.Input[Sequence[pulumi.Input[int]]] dataset_fields_ids: Identifiers of the data set fields within the template that you want to receive in logs. The order of the identifiers define how the value for these fields appears in the log lines. See [Data set parameters](https://techdocs.akamai.com/datastream2/reference/data-set-parameters-1).
-        :param pulumi.Input['DatastreamElasticsearchConnectorArgs'] elasticsearch_connector: Specify details about the Elasticsearch connector you can use in a stream, including:
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_ids: A list of email addresses you want to notify about activations and deactivations of the stream.
-        :param pulumi.Input['DatastreamGcsConnectorArgs'] gcs_connector: Specify details about the Google Cloud Storage connector you can use in a stream. When validating this connector, DataStream uses the private access key to create an `Akamai_access_verification_<timestamp>.txt` object file in your GCS bucket. You can only see this file if the validation process is successful, and you have access to the Google Cloud Storage bucket where you are trying to send logs. The argument includes these sub-arguments:
-        :param pulumi.Input[str] group_id: Identifies the group that has access to the product and this stream configuration.
-        :param pulumi.Input[str] group_name: The name of the user group for which the stream was created
-        :param pulumi.Input['DatastreamHttpsConnectorArgs'] https_connector: Specify details about the custom HTTPS endpoint you can use as a connector for a stream, including:
-        :param pulumi.Input['DatastreamLogglyConnectorArgs'] loggly_connector: Specify details about the Loggly connector you can use in a stream, including:
-        :param pulumi.Input[str] modified_by: The username who modified the stream
-        :param pulumi.Input[str] modified_date: The date and time when the stream was modified
-        :param pulumi.Input['DatastreamNewRelicConnectorArgs'] new_relic_connector: Specify details about the New Relic connector you can use in a stream, including:
-        :param pulumi.Input['DatastreamOracleConnectorArgs'] oracle_connector: Specify details about the Oracle Cloud Storage connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and tries to save an `Akamai_access_verification_<timestamp>.txt` file in your Oracle Cloud Storage folder. You can only see this file if the validation process is successful, and you have access to the Oracle Cloud Storage bucket and folder that youre trying to send logs to.
-        :param pulumi.Input[str] papi_json: The configuration in JSON format that can be copy-pasted into PAPI configuration to enable datastream behavior
-        :param pulumi.Input[str] product_id: The ID of the product for which the stream was created
-        :param pulumi.Input[str] product_name: The name of the product for which the stream was created
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] property_ids: Identifies the properties that you want to monitor in the stream. Note that a stream can only log data for active properties.
-        :param pulumi.Input['DatastreamS3ConnectorArgs'] s3_connector: Specify details about the Amazon S3 connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and saves an `akamai_write_test_2147483647.txt` file in your Amazon S3 folder. You can only see this file if validation succeeds, and you have access to the Amazon S3 bucket and folder that youre trying to send logs to. The argument includes these sub-arguments:
-        :param pulumi.Input['DatastreamSplunkConnectorArgs'] splunk_connector: Specify details about the Splunk connector in your stream. Note that currently DataStream supports only endpoint URLs ending with `collector/raw`. The argument includes these sub-arguments:
-        :param pulumi.Input[str] stream_name: The name of the stream.
-        :param pulumi.Input[str] stream_type: The type of stream that you want to create. Currently, `RAW_LOGS` is the only possible stream type.
-        :param pulumi.Input[int] stream_version_id: Identifies the configuration version of the stream
-        :param pulumi.Input['DatastreamSumologicConnectorArgs'] sumologic_connector: Specify details about the Sumo Logic connector in a stream, including:
-        :param pulumi.Input[str] template_name: The name of the data set template available for the product that you want to use in the stream. Currently, `EDGE_LOGS` is the only data set template available.
-        """
-        if active is not None:
-            pulumi.set(__self__, "active", active)
-        if azure_connector is not None:
-            pulumi.set(__self__, "azure_connector", azure_connector)
-        if config is not None:
-            pulumi.set(__self__, "config", config)
-        if contract_id is not None:
-            pulumi.set(__self__, "contract_id", contract_id)
-        if created_by is not None:
-            pulumi.set(__self__, "created_by", created_by)
-        if created_date is not None:
-            pulumi.set(__self__, "created_date", created_date)
-        if datadog_connector is not None:
-            pulumi.set(__self__, "datadog_connector", datadog_connector)
-        if dataset_fields_ids is not None:
-            pulumi.set(__self__, "dataset_fields_ids", dataset_fields_ids)
-        if elasticsearch_connector is not None:
-            pulumi.set(__self__, "elasticsearch_connector", elasticsearch_connector)
-        if email_ids is not None:
-            pulumi.set(__self__, "email_ids", email_ids)
-        if gcs_connector is not None:
-            pulumi.set(__self__, "gcs_connector", gcs_connector)
-        if group_id is not None:
-            pulumi.set(__self__, "group_id", group_id)
-        if group_name is not None:
-            pulumi.set(__self__, "group_name", group_name)
-        if https_connector is not None:
-            pulumi.set(__self__, "https_connector", https_connector)
-        if loggly_connector is not None:
-            pulumi.set(__self__, "loggly_connector", loggly_connector)
-        if modified_by is not None:
-            pulumi.set(__self__, "modified_by", modified_by)
-        if modified_date is not None:
-            pulumi.set(__self__, "modified_date", modified_date)
-        if new_relic_connector is not None:
-            pulumi.set(__self__, "new_relic_connector", new_relic_connector)
-        if oracle_connector is not None:
-            pulumi.set(__self__, "oracle_connector", oracle_connector)
-        if papi_json is not None:
-            pulumi.set(__self__, "papi_json", papi_json)
-        if product_id is not None:
-            pulumi.set(__self__, "product_id", product_id)
-        if product_name is not None:
-            pulumi.set(__self__, "product_name", product_name)
-        if property_ids is not None:
-            pulumi.set(__self__, "property_ids", property_ids)
-        if s3_connector is not None:
-            pulumi.set(__self__, "s3_connector", s3_connector)
-        if splunk_connector is not None:
-            pulumi.set(__self__, "splunk_connector", splunk_connector)
-        if stream_name is not None:
-            pulumi.set(__self__, "stream_name", stream_name)
-        if stream_type is not None:
-            pulumi.set(__self__, "stream_type", stream_type)
-        if stream_version_id is not None:
-            pulumi.set(__self__, "stream_version_id", stream_version_id)
-        if sumologic_connector is not None:
-            pulumi.set(__self__, "sumologic_connector", sumologic_connector)
-        if template_name is not None:
-            pulumi.set(__self__, "template_name", template_name)
+                 backup_cname: Optional[pulumi.Input[str]] = None,
+                 backup_ip: Optional[pulumi.Input[str]] = None,
+                 balance_by_download_score: Optional[pulumi.Input[bool]] = None,
+                 cname: Optional[pulumi.Input[str]] = None,
+                 comments: Optional[pulumi.Input[str]] = None,
+                 domain: Optional[pulumi.Input[str]] = None,
+                 dynamic_ttl: Optional[pulumi.Input[int]] = None,
+                 failback_delay: Optional[pulumi.Input[int]] = None,
+                 failover_delay: Optional[pulumi.Input[int]] = None,
+                 ghost_demand_reporting: Optional[pulumi.Input[bool]] = None,
+                 handout_limit: Optional[pulumi.Input[int]] = None,
+                 handout_mode: Optional[pulumi.Input[str]] = None,
+                 health_max: Optional[pulumi.Input[float]] = None,
+                 health_multiplier: Optional[pulumi.Input[float]] = None,
+                 health_threshold: Optional[pulumi.Input[float]] = None,
+                 ipv6: Optional[pulumi.Input[bool]] = None,
+                 liveness_tests: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]] = None,
+                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
+                 map_name: Optional[pulumi.Input[str]] = None,
+                 max_unreachable_penalty: Optional[pulumi.Input[int]] = None,
+                 min_live_fraction: Optional[pulumi.Input[float]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
+                 score_aggregation_type: Optional[pulumi.Input[str]] = None,
+                 static_rr_sets: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]] = None,
+                 static_ttl: Optional[pulumi.Input[int]] = None,
+                 stickiness_bonus_constant: Optional[pulumi.Input[int]] = None,
+                 stickiness_bonus_percentage: Optional[pulumi.Input[int]] = None,
+                 traffic_targets: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]] = None,
+                 type: Optional[pulumi.Input[str]] = None,
+                 unreachable_threshold: Optional[pulumi.Input[float]] = None,
+                 use_computed_targets: Optional[pulumi.Input[bool]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
+                 weighted_hash_bits_for_ipv4: Optional[pulumi.Input[int]] = None,
+                 weighted_hash_bits_for_ipv6: Optional[pulumi.Input[int]] = None):
+        """
+        Input properties used for looking up and filtering GtmProperty resources.
+        """
+        if backup_cname is not None:
+            pulumi.set(__self__, "backup_cname", backup_cname)
+        if backup_ip is not None:
+            pulumi.set(__self__, "backup_ip", backup_ip)
+        if balance_by_download_score is not None:
+            pulumi.set(__self__, "balance_by_download_score", balance_by_download_score)
+        if cname is not None:
+            pulumi.set(__self__, "cname", cname)
+        if comments is not None:
+            pulumi.set(__self__, "comments", comments)
+        if domain is not None:
+            pulumi.set(__self__, "domain", domain)
+        if dynamic_ttl is not None:
+            pulumi.set(__self__, "dynamic_ttl", dynamic_ttl)
+        if failback_delay is not None:
+            pulumi.set(__self__, "failback_delay", failback_delay)
+        if failover_delay is not None:
+            pulumi.set(__self__, "failover_delay", failover_delay)
+        if ghost_demand_reporting is not None:
+            pulumi.set(__self__, "ghost_demand_reporting", ghost_demand_reporting)
+        if handout_limit is not None:
+            pulumi.set(__self__, "handout_limit", handout_limit)
+        if handout_mode is not None:
+            pulumi.set(__self__, "handout_mode", handout_mode)
+        if health_max is not None:
+            pulumi.set(__self__, "health_max", health_max)
+        if health_multiplier is not None:
+            pulumi.set(__self__, "health_multiplier", health_multiplier)
+        if health_threshold is not None:
+            pulumi.set(__self__, "health_threshold", health_threshold)
+        if ipv6 is not None:
+            pulumi.set(__self__, "ipv6", ipv6)
+        if liveness_tests is not None:
+            pulumi.set(__self__, "liveness_tests", liveness_tests)
+        if load_imbalance_percentage is not None:
+            pulumi.set(__self__, "load_imbalance_percentage", load_imbalance_percentage)
+        if map_name is not None:
+            pulumi.set(__self__, "map_name", map_name)
+        if max_unreachable_penalty is not None:
+            pulumi.set(__self__, "max_unreachable_penalty", max_unreachable_penalty)
+        if min_live_fraction is not None:
+            pulumi.set(__self__, "min_live_fraction", min_live_fraction)
+        if name is not None:
+            pulumi.set(__self__, "name", name)
+        if score_aggregation_type is not None:
+            pulumi.set(__self__, "score_aggregation_type", score_aggregation_type)
+        if static_rr_sets is not None:
+            pulumi.set(__self__, "static_rr_sets", static_rr_sets)
+        if static_ttl is not None:
+            pulumi.set(__self__, "static_ttl", static_ttl)
+        if stickiness_bonus_constant is not None:
+            pulumi.set(__self__, "stickiness_bonus_constant", stickiness_bonus_constant)
+        if stickiness_bonus_percentage is not None:
+            pulumi.set(__self__, "stickiness_bonus_percentage", stickiness_bonus_percentage)
+        if traffic_targets is not None:
+            pulumi.set(__self__, "traffic_targets", traffic_targets)
+        if type is not None:
+            pulumi.set(__self__, "type", type)
+        if unreachable_threshold is not None:
+            pulumi.set(__self__, "unreachable_threshold", unreachable_threshold)
+        if use_computed_targets is not None:
+            pulumi.set(__self__, "use_computed_targets", use_computed_targets)
+        if wait_on_complete is not None:
+            pulumi.set(__self__, "wait_on_complete", wait_on_complete)
+        if weighted_hash_bits_for_ipv4 is not None:
+            pulumi.set(__self__, "weighted_hash_bits_for_ipv4", weighted_hash_bits_for_ipv4)
+        if weighted_hash_bits_for_ipv6 is not None:
+            pulumi.set(__self__, "weighted_hash_bits_for_ipv6", weighted_hash_bits_for_ipv6)
+
+    @property
+    @pulumi.getter(name="backupCname")
+    def backup_cname(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "backup_cname")
+
+    @backup_cname.setter
+    def backup_cname(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "backup_cname", value)
+
+    @property
+    @pulumi.getter(name="backupIp")
+    def backup_ip(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "backup_ip")
+
+    @backup_ip.setter
+    def backup_ip(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "backup_ip", value)
+
+    @property
+    @pulumi.getter(name="balanceByDownloadScore")
+    def balance_by_download_score(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "balance_by_download_score")
+
+    @balance_by_download_score.setter
+    def balance_by_download_score(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "balance_by_download_score", value)
 
     @property
     @pulumi.getter
-    def active(self) -> Optional[pulumi.Input[bool]]:
-        """
-        Whether you want to start activating the stream when applying the resource. Either `true` for activating the stream upon sending the request or `false` for leaving the stream inactive after the request.
-        """
-        return pulumi.get(self, "active")
+    def cname(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "cname")
 
-    @active.setter
-    def active(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "active", value)
+    @cname.setter
+    def cname(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "cname", value)
 
     @property
-    @pulumi.getter(name="azureConnector")
-    def azure_connector(self) -> Optional[pulumi.Input['DatastreamAzureConnectorArgs']]:
-        """
-        Specify details about the Azure Storage connector configuration in a data stream. Note that currently DataStream supports only streaming data to [block objects](https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs). The argument includes these sub-arguments:
-        """
-        return pulumi.get(self, "azure_connector")
+    @pulumi.getter
+    def comments(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "comments")
 
-    @azure_connector.setter
-    def azure_connector(self, value: Optional[pulumi.Input['DatastreamAzureConnectorArgs']]):
-        pulumi.set(self, "azure_connector", value)
+    @comments.setter
+    def comments(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "comments", value)
 
     @property
     @pulumi.getter
-    def config(self) -> Optional[pulumi.Input['DatastreamConfigArgs']]:
-        """
-        Provides information about the log line configuration, log file format, names of log files sent, and file delivery. The argument includes these sub-arguments:
-        """
-        return pulumi.get(self, "config")
+    def domain(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "domain")
 
-    @config.setter
-    def config(self, value: Optional[pulumi.Input['DatastreamConfigArgs']]):
-        pulumi.set(self, "config", value)
+    @domain.setter
+    def domain(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "domain", value)
 
     @property
-    @pulumi.getter(name="contractId")
-    def contract_id(self) -> Optional[pulumi.Input[str]]:
-        """
-        Identifies the contract that has access to the product.
-        """
-        return pulumi.get(self, "contract_id")
+    @pulumi.getter(name="dynamicTtl")
+    def dynamic_ttl(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "dynamic_ttl")
 
-    @contract_id.setter
-    def contract_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "contract_id", value)
+    @dynamic_ttl.setter
+    def dynamic_ttl(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "dynamic_ttl", value)
 
     @property
-    @pulumi.getter(name="createdBy")
-    def created_by(self) -> Optional[pulumi.Input[str]]:
-        """
-        The username who created the stream
-        """
-        return pulumi.get(self, "created_by")
+    @pulumi.getter(name="failbackDelay")
+    def failback_delay(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "failback_delay")
 
-    @created_by.setter
-    def created_by(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "created_by", value)
+    @failback_delay.setter
+    def failback_delay(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "failback_delay", value)
 
     @property
-    @pulumi.getter(name="createdDate")
-    def created_date(self) -> Optional[pulumi.Input[str]]:
-        """
-        The date and time when the stream was created
-        """
-        return pulumi.get(self, "created_date")
+    @pulumi.getter(name="failoverDelay")
+    def failover_delay(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "failover_delay")
 
-    @created_date.setter
-    def created_date(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "created_date", value)
+    @failover_delay.setter
+    def failover_delay(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "failover_delay", value)
 
     @property
-    @pulumi.getter(name="datadogConnector")
-    def datadog_connector(self) -> Optional[pulumi.Input['DatastreamDatadogConnectorArgs']]:
-        """
-        Specify details about the Datadog connector in a stream, including:
-        """
-        return pulumi.get(self, "datadog_connector")
+    @pulumi.getter(name="ghostDemandReporting")
+    def ghost_demand_reporting(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "ghost_demand_reporting")
 
-    @datadog_connector.setter
-    def datadog_connector(self, value: Optional[pulumi.Input['DatastreamDatadogConnectorArgs']]):
-        pulumi.set(self, "datadog_connector", value)
+    @ghost_demand_reporting.setter
+    def ghost_demand_reporting(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "ghost_demand_reporting", value)
 
     @property
-    @pulumi.getter(name="datasetFieldsIds")
-    def dataset_fields_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
-        """
-        Identifiers of the data set fields within the template that you want to receive in logs. The order of the identifiers define how the value for these fields appears in the log lines. See [Data set parameters](https://techdocs.akamai.com/datastream2/reference/data-set-parameters-1).
-        """
-        return pulumi.get(self, "dataset_fields_ids")
+    @pulumi.getter(name="handoutLimit")
+    def handout_limit(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "handout_limit")
 
-    @dataset_fields_ids.setter
-    def dataset_fields_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
-        pulumi.set(self, "dataset_fields_ids", value)
+    @handout_limit.setter
+    def handout_limit(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "handout_limit", value)
 
     @property
-    @pulumi.getter(name="elasticsearchConnector")
-    def elasticsearch_connector(self) -> Optional[pulumi.Input['DatastreamElasticsearchConnectorArgs']]:
-        """
-        Specify details about the Elasticsearch connector you can use in a stream, including:
-        """
-        return pulumi.get(self, "elasticsearch_connector")
+    @pulumi.getter(name="handoutMode")
+    def handout_mode(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "handout_mode")
 
-    @elasticsearch_connector.setter
-    def elasticsearch_connector(self, value: Optional[pulumi.Input['DatastreamElasticsearchConnectorArgs']]):
-        pulumi.set(self, "elasticsearch_connector", value)
+    @handout_mode.setter
+    def handout_mode(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "handout_mode", value)
 
     @property
-    @pulumi.getter(name="emailIds")
-    def email_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
-        """
-        A list of email addresses you want to notify about activations and deactivations of the stream.
-        """
-        return pulumi.get(self, "email_ids")
+    @pulumi.getter(name="healthMax")
+    def health_max(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "health_max")
 
-    @email_ids.setter
-    def email_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
-        pulumi.set(self, "email_ids", value)
+    @health_max.setter
+    def health_max(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "health_max", value)
 
     @property
-    @pulumi.getter(name="gcsConnector")
-    def gcs_connector(self) -> Optional[pulumi.Input['DatastreamGcsConnectorArgs']]:
-        """
-        Specify details about the Google Cloud Storage connector you can use in a stream. When validating this connector, DataStream uses the private access key to create an `Akamai_access_verification_<timestamp>.txt` object file in your GCS bucket. You can only see this file if the validation process is successful, and you have access to the Google Cloud Storage bucket where you are trying to send logs. The argument includes these sub-arguments:
-        """
-        return pulumi.get(self, "gcs_connector")
+    @pulumi.getter(name="healthMultiplier")
+    def health_multiplier(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "health_multiplier")
 
-    @gcs_connector.setter
-    def gcs_connector(self, value: Optional[pulumi.Input['DatastreamGcsConnectorArgs']]):
-        pulumi.set(self, "gcs_connector", value)
+    @health_multiplier.setter
+    def health_multiplier(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "health_multiplier", value)
 
     @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> Optional[pulumi.Input[str]]:
-        """
-        Identifies the group that has access to the product and this stream configuration.
-        """
-        return pulumi.get(self, "group_id")
+    @pulumi.getter(name="healthThreshold")
+    def health_threshold(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "health_threshold")
 
-    @group_id.setter
-    def group_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "group_id", value)
+    @health_threshold.setter
+    def health_threshold(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "health_threshold", value)
 
     @property
-    @pulumi.getter(name="groupName")
-    def group_name(self) -> Optional[pulumi.Input[str]]:
-        """
-        The name of the user group for which the stream was created
-        """
-        return pulumi.get(self, "group_name")
+    @pulumi.getter
+    def ipv6(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "ipv6")
 
-    @group_name.setter
-    def group_name(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "group_name", value)
+    @ipv6.setter
+    def ipv6(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "ipv6", value)
 
     @property
-    @pulumi.getter(name="httpsConnector")
-    def https_connector(self) -> Optional[pulumi.Input['DatastreamHttpsConnectorArgs']]:
-        """
-        Specify details about the custom HTTPS endpoint you can use as a connector for a stream, including:
-        """
-        return pulumi.get(self, "https_connector")
+    @pulumi.getter(name="livenessTests")
+    def liveness_tests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]]:
+        return pulumi.get(self, "liveness_tests")
 
-    @https_connector.setter
-    def https_connector(self, value: Optional[pulumi.Input['DatastreamHttpsConnectorArgs']]):
-        pulumi.set(self, "https_connector", value)
+    @liveness_tests.setter
+    def liveness_tests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyLivenessTestArgs']]]]):
+        pulumi.set(self, "liveness_tests", value)
 
     @property
-    @pulumi.getter(name="logglyConnector")
-    def loggly_connector(self) -> Optional[pulumi.Input['DatastreamLogglyConnectorArgs']]:
-        """
-        Specify details about the Loggly connector you can use in a stream, including:
-        """
-        return pulumi.get(self, "loggly_connector")
+    @pulumi.getter(name="loadImbalancePercentage")
+    def load_imbalance_percentage(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "load_imbalance_percentage")
 
-    @loggly_connector.setter
-    def loggly_connector(self, value: Optional[pulumi.Input['DatastreamLogglyConnectorArgs']]):
-        pulumi.set(self, "loggly_connector", value)
+    @load_imbalance_percentage.setter
+    def load_imbalance_percentage(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "load_imbalance_percentage", value)
 
     @property
-    @pulumi.getter(name="modifiedBy")
-    def modified_by(self) -> Optional[pulumi.Input[str]]:
-        """
-        The username who modified the stream
-        """
-        return pulumi.get(self, "modified_by")
+    @pulumi.getter(name="mapName")
+    def map_name(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "map_name")
 
-    @modified_by.setter
-    def modified_by(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "modified_by", value)
+    @map_name.setter
+    def map_name(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "map_name", value)
 
     @property
-    @pulumi.getter(name="modifiedDate")
-    def modified_date(self) -> Optional[pulumi.Input[str]]:
-        """
-        The date and time when the stream was modified
-        """
-        return pulumi.get(self, "modified_date")
+    @pulumi.getter(name="maxUnreachablePenalty")
+    def max_unreachable_penalty(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "max_unreachable_penalty")
 
-    @modified_date.setter
-    def modified_date(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "modified_date", value)
+    @max_unreachable_penalty.setter
+    def max_unreachable_penalty(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "max_unreachable_penalty", value)
 
     @property
-    @pulumi.getter(name="newRelicConnector")
-    def new_relic_connector(self) -> Optional[pulumi.Input['DatastreamNewRelicConnectorArgs']]:
-        """
-        Specify details about the New Relic connector you can use in a stream, including:
-        """
-        return pulumi.get(self, "new_relic_connector")
+    @pulumi.getter(name="minLiveFraction")
+    def min_live_fraction(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "min_live_fraction")
 
-    @new_relic_connector.setter
-    def new_relic_connector(self, value: Optional[pulumi.Input['DatastreamNewRelicConnectorArgs']]):
-        pulumi.set(self, "new_relic_connector", value)
+    @min_live_fraction.setter
+    def min_live_fraction(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "min_live_fraction", value)
 
     @property
-    @pulumi.getter(name="oracleConnector")
-    def oracle_connector(self) -> Optional[pulumi.Input['DatastreamOracleConnectorArgs']]:
-        """
-        Specify details about the Oracle Cloud Storage connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and tries to save an `Akamai_access_verification_<timestamp>.txt` file in your Oracle Cloud Storage folder. You can only see this file if the validation process is successful, and you have access to the Oracle Cloud Storage bucket and folder that youre trying to send logs to.
-        """
-        return pulumi.get(self, "oracle_connector")
+    @pulumi.getter
+    def name(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "name")
 
-    @oracle_connector.setter
-    def oracle_connector(self, value: Optional[pulumi.Input['DatastreamOracleConnectorArgs']]):
-        pulumi.set(self, "oracle_connector", value)
+    @name.setter
+    def name(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "name", value)
 
     @property
-    @pulumi.getter(name="papiJson")
-    def papi_json(self) -> Optional[pulumi.Input[str]]:
-        """
-        The configuration in JSON format that can be copy-pasted into PAPI configuration to enable datastream behavior
-        """
-        return pulumi.get(self, "papi_json")
+    @pulumi.getter(name="scoreAggregationType")
+    def score_aggregation_type(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "score_aggregation_type")
 
-    @papi_json.setter
-    def papi_json(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "papi_json", value)
+    @score_aggregation_type.setter
+    def score_aggregation_type(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "score_aggregation_type", value)
 
     @property
-    @pulumi.getter(name="productId")
-    def product_id(self) -> Optional[pulumi.Input[str]]:
-        """
-        The ID of the product for which the stream was created
-        """
-        return pulumi.get(self, "product_id")
+    @pulumi.getter(name="staticRrSets")
+    def static_rr_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]]:
+        return pulumi.get(self, "static_rr_sets")
 
-    @product_id.setter
-    def product_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "product_id", value)
+    @static_rr_sets.setter
+    def static_rr_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyStaticRrSetArgs']]]]):
+        pulumi.set(self, "static_rr_sets", value)
 
     @property
-    @pulumi.getter(name="productName")
-    def product_name(self) -> Optional[pulumi.Input[str]]:
-        """
-        The name of the product for which the stream was created
-        """
-        return pulumi.get(self, "product_name")
+    @pulumi.getter(name="staticTtl")
+    def static_ttl(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "static_ttl")
 
-    @product_name.setter
-    def product_name(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "product_name", value)
+    @static_ttl.setter
+    def static_ttl(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "static_ttl", value)
 
     @property
-    @pulumi.getter(name="propertyIds")
-    def property_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
-        """
-        Identifies the properties that you want to monitor in the stream. Note that a stream can only log data for active properties.
-        """
-        return pulumi.get(self, "property_ids")
+    @pulumi.getter(name="stickinessBonusConstant")
+    def stickiness_bonus_constant(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "stickiness_bonus_constant")
 
-    @property_ids.setter
-    def property_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
-        pulumi.set(self, "property_ids", value)
+    @stickiness_bonus_constant.setter
+    def stickiness_bonus_constant(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "stickiness_bonus_constant", value)
 
     @property
-    @pulumi.getter(name="s3Connector")
-    def s3_connector(self) -> Optional[pulumi.Input['DatastreamS3ConnectorArgs']]:
-        """
-        Specify details about the Amazon S3 connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and saves an `akamai_write_test_2147483647.txt` file in your Amazon S3 folder. You can only see this file if validation succeeds, and you have access to the Amazon S3 bucket and folder that youre trying to send logs to. The argument includes these sub-arguments:
-        """
-        return pulumi.get(self, "s3_connector")
+    @pulumi.getter(name="stickinessBonusPercentage")
+    def stickiness_bonus_percentage(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "stickiness_bonus_percentage")
 
-    @s3_connector.setter
-    def s3_connector(self, value: Optional[pulumi.Input['DatastreamS3ConnectorArgs']]):
-        pulumi.set(self, "s3_connector", value)
+    @stickiness_bonus_percentage.setter
+    def stickiness_bonus_percentage(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "stickiness_bonus_percentage", value)
 
     @property
-    @pulumi.getter(name="splunkConnector")
-    def splunk_connector(self) -> Optional[pulumi.Input['DatastreamSplunkConnectorArgs']]:
-        """
-        Specify details about the Splunk connector in your stream. Note that currently DataStream supports only endpoint URLs ending with `collector/raw`. The argument includes these sub-arguments:
-        """
-        return pulumi.get(self, "splunk_connector")
+    @pulumi.getter(name="trafficTargets")
+    def traffic_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]]:
+        return pulumi.get(self, "traffic_targets")
 
-    @splunk_connector.setter
-    def splunk_connector(self, value: Optional[pulumi.Input['DatastreamSplunkConnectorArgs']]):
-        pulumi.set(self, "splunk_connector", value)
+    @traffic_targets.setter
+    def traffic_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmPropertyTrafficTargetArgs']]]]):
+        pulumi.set(self, "traffic_targets", value)
 
     @property
-    @pulumi.getter(name="streamName")
-    def stream_name(self) -> Optional[pulumi.Input[str]]:
-        """
-        The name of the stream.
-        """
-        return pulumi.get(self, "stream_name")
+    @pulumi.getter
+    def type(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "type")
 
-    @stream_name.setter
-    def stream_name(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "stream_name", value)
+    @type.setter
+    def type(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "type", value)
 
     @property
-    @pulumi.getter(name="streamType")
-    def stream_type(self) -> Optional[pulumi.Input[str]]:
-        """
-        The type of stream that you want to create. Currently, `RAW_LOGS` is the only possible stream type.
-        """
-        return pulumi.get(self, "stream_type")
+    @pulumi.getter(name="unreachableThreshold")
+    def unreachable_threshold(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "unreachable_threshold")
 
-    @stream_type.setter
-    def stream_type(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "stream_type", value)
+    @unreachable_threshold.setter
+    def unreachable_threshold(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "unreachable_threshold", value)
 
     @property
-    @pulumi.getter(name="streamVersionId")
-    def stream_version_id(self) -> Optional[pulumi.Input[int]]:
-        """
-        Identifies the configuration version of the stream
-        """
-        return pulumi.get(self, "stream_version_id")
+    @pulumi.getter(name="useComputedTargets")
+    def use_computed_targets(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "use_computed_targets")
 
-    @stream_version_id.setter
-    def stream_version_id(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "stream_version_id", value)
+    @use_computed_targets.setter
+    def use_computed_targets(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "use_computed_targets", value)
 
     @property
-    @pulumi.getter(name="sumologicConnector")
-    def sumologic_connector(self) -> Optional[pulumi.Input['DatastreamSumologicConnectorArgs']]:
-        """
-        Specify details about the Sumo Logic connector in a stream, including:
-        """
-        return pulumi.get(self, "sumologic_connector")
+    @pulumi.getter(name="waitOnComplete")
+    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "wait_on_complete")
 
-    @sumologic_connector.setter
-    def sumologic_connector(self, value: Optional[pulumi.Input['DatastreamSumologicConnectorArgs']]):
-        pulumi.set(self, "sumologic_connector", value)
+    @wait_on_complete.setter
+    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "wait_on_complete", value)
 
     @property
-    @pulumi.getter(name="templateName")
-    def template_name(self) -> Optional[pulumi.Input[str]]:
-        """
-        The name of the data set template available for the product that you want to use in the stream. Currently, `EDGE_LOGS` is the only data set template available.
-        """
-        return pulumi.get(self, "template_name")
+    @pulumi.getter(name="weightedHashBitsForIpv4")
+    def weighted_hash_bits_for_ipv4(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "weighted_hash_bits_for_ipv4")
+
+    @weighted_hash_bits_for_ipv4.setter
+    def weighted_hash_bits_for_ipv4(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "weighted_hash_bits_for_ipv4", value)
+
+    @property
+    @pulumi.getter(name="weightedHashBitsForIpv6")
+    def weighted_hash_bits_for_ipv6(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "weighted_hash_bits_for_ipv6")
+
+    @weighted_hash_bits_for_ipv6.setter
+    def weighted_hash_bits_for_ipv6(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "weighted_hash_bits_for_ipv6", value)
+
+
+warnings.warn("""akamai.trafficmanagement.GtmProperty has been deprecated in favor of akamai.GtmProperty""", DeprecationWarning)
 
-    @template_name.setter
-    def template_name(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "template_name", value)
 
+class GtmProperty(pulumi.CustomResource):
+    warnings.warn("""akamai.trafficmanagement.GtmProperty has been deprecated in favor of akamai.GtmProperty""", DeprecationWarning)
 
-class Datastream(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 active: Optional[pulumi.Input[bool]] = None,
-                 azure_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamAzureConnectorArgs']]] = None,
-                 config: Optional[pulumi.Input[pulumi.InputType['DatastreamConfigArgs']]] = None,
-                 contract_id: Optional[pulumi.Input[str]] = None,
-                 datadog_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamDatadogConnectorArgs']]] = None,
-                 dataset_fields_ids: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
-                 elasticsearch_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamElasticsearchConnectorArgs']]] = None,
-                 email_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 gcs_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamGcsConnectorArgs']]] = None,
-                 group_id: Optional[pulumi.Input[str]] = None,
-                 https_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamHttpsConnectorArgs']]] = None,
-                 loggly_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamLogglyConnectorArgs']]] = None,
-                 new_relic_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamNewRelicConnectorArgs']]] = None,
-                 oracle_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamOracleConnectorArgs']]] = None,
-                 property_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 s3_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamS3ConnectorArgs']]] = None,
-                 splunk_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamSplunkConnectorArgs']]] = None,
-                 stream_name: Optional[pulumi.Input[str]] = None,
-                 stream_type: Optional[pulumi.Input[str]] = None,
-                 sumologic_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamSumologicConnectorArgs']]] = None,
-                 template_name: Optional[pulumi.Input[str]] = None,
+                 backup_cname: Optional[pulumi.Input[str]] = None,
+                 backup_ip: Optional[pulumi.Input[str]] = None,
+                 balance_by_download_score: Optional[pulumi.Input[bool]] = None,
+                 cname: Optional[pulumi.Input[str]] = None,
+                 comments: Optional[pulumi.Input[str]] = None,
+                 domain: Optional[pulumi.Input[str]] = None,
+                 dynamic_ttl: Optional[pulumi.Input[int]] = None,
+                 failback_delay: Optional[pulumi.Input[int]] = None,
+                 failover_delay: Optional[pulumi.Input[int]] = None,
+                 ghost_demand_reporting: Optional[pulumi.Input[bool]] = None,
+                 handout_limit: Optional[pulumi.Input[int]] = None,
+                 handout_mode: Optional[pulumi.Input[str]] = None,
+                 health_max: Optional[pulumi.Input[float]] = None,
+                 health_multiplier: Optional[pulumi.Input[float]] = None,
+                 health_threshold: Optional[pulumi.Input[float]] = None,
+                 ipv6: Optional[pulumi.Input[bool]] = None,
+                 liveness_tests: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyLivenessTestArgs']]]]] = None,
+                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
+                 map_name: Optional[pulumi.Input[str]] = None,
+                 max_unreachable_penalty: Optional[pulumi.Input[int]] = None,
+                 min_live_fraction: Optional[pulumi.Input[float]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
+                 score_aggregation_type: Optional[pulumi.Input[str]] = None,
+                 static_rr_sets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyStaticRrSetArgs']]]]] = None,
+                 static_ttl: Optional[pulumi.Input[int]] = None,
+                 stickiness_bonus_constant: Optional[pulumi.Input[int]] = None,
+                 stickiness_bonus_percentage: Optional[pulumi.Input[int]] = None,
+                 traffic_targets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyTrafficTargetArgs']]]]] = None,
+                 type: Optional[pulumi.Input[str]] = None,
+                 unreachable_threshold: Optional[pulumi.Input[float]] = None,
+                 use_computed_targets: Optional[pulumi.Input[bool]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
                  __props__=None):
         """
-        ## Import
-
-        Basic usagehcl resource "akamai_datastream" "example" {
-
-        # (resource arguments)
-
-         } You can import your Akamai DataStream configuration using a stream version ID. For example
-
-        ```sh
-         $ pulumi import akamai:index/datastream:Datastream example 1234
-        ```
-
-         ~> **IMPORTANT:** For security reasons, this command doesn't import any secrets you specify for your connector. To make sure the state file includes complete data, use this resource to manually add the arguments marked **Secret** above.
-
+        Create a GtmProperty resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[bool] active: Whether you want to start activating the stream when applying the resource. Either `true` for activating the stream upon sending the request or `false` for leaving the stream inactive after the request.
-        :param pulumi.Input[pulumi.InputType['DatastreamAzureConnectorArgs']] azure_connector: Specify details about the Azure Storage connector configuration in a data stream. Note that currently DataStream supports only streaming data to [block objects](https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs). The argument includes these sub-arguments:
-        :param pulumi.Input[pulumi.InputType['DatastreamConfigArgs']] config: Provides information about the log line configuration, log file format, names of log files sent, and file delivery. The argument includes these sub-arguments:
-        :param pulumi.Input[str] contract_id: Identifies the contract that has access to the product.
-        :param pulumi.Input[pulumi.InputType['DatastreamDatadogConnectorArgs']] datadog_connector: Specify details about the Datadog connector in a stream, including:
-        :param pulumi.Input[Sequence[pulumi.Input[int]]] dataset_fields_ids: Identifiers of the data set fields within the template that you want to receive in logs. The order of the identifiers define how the value for these fields appears in the log lines. See [Data set parameters](https://techdocs.akamai.com/datastream2/reference/data-set-parameters-1).
-        :param pulumi.Input[pulumi.InputType['DatastreamElasticsearchConnectorArgs']] elasticsearch_connector: Specify details about the Elasticsearch connector you can use in a stream, including:
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_ids: A list of email addresses you want to notify about activations and deactivations of the stream.
-        :param pulumi.Input[pulumi.InputType['DatastreamGcsConnectorArgs']] gcs_connector: Specify details about the Google Cloud Storage connector you can use in a stream. When validating this connector, DataStream uses the private access key to create an `Akamai_access_verification_<timestamp>.txt` object file in your GCS bucket. You can only see this file if the validation process is successful, and you have access to the Google Cloud Storage bucket where you are trying to send logs. The argument includes these sub-arguments:
-        :param pulumi.Input[str] group_id: Identifies the group that has access to the product and this stream configuration.
-        :param pulumi.Input[pulumi.InputType['DatastreamHttpsConnectorArgs']] https_connector: Specify details about the custom HTTPS endpoint you can use as a connector for a stream, including:
-        :param pulumi.Input[pulumi.InputType['DatastreamLogglyConnectorArgs']] loggly_connector: Specify details about the Loggly connector you can use in a stream, including:
-        :param pulumi.Input[pulumi.InputType['DatastreamNewRelicConnectorArgs']] new_relic_connector: Specify details about the New Relic connector you can use in a stream, including:
-        :param pulumi.Input[pulumi.InputType['DatastreamOracleConnectorArgs']] oracle_connector: Specify details about the Oracle Cloud Storage connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and tries to save an `Akamai_access_verification_<timestamp>.txt` file in your Oracle Cloud Storage folder. You can only see this file if the validation process is successful, and you have access to the Oracle Cloud Storage bucket and folder that youre trying to send logs to.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] property_ids: Identifies the properties that you want to monitor in the stream. Note that a stream can only log data for active properties.
-        :param pulumi.Input[pulumi.InputType['DatastreamS3ConnectorArgs']] s3_connector: Specify details about the Amazon S3 connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and saves an `akamai_write_test_2147483647.txt` file in your Amazon S3 folder. You can only see this file if validation succeeds, and you have access to the Amazon S3 bucket and folder that youre trying to send logs to. The argument includes these sub-arguments:
-        :param pulumi.Input[pulumi.InputType['DatastreamSplunkConnectorArgs']] splunk_connector: Specify details about the Splunk connector in your stream. Note that currently DataStream supports only endpoint URLs ending with `collector/raw`. The argument includes these sub-arguments:
-        :param pulumi.Input[str] stream_name: The name of the stream.
-        :param pulumi.Input[str] stream_type: The type of stream that you want to create. Currently, `RAW_LOGS` is the only possible stream type.
-        :param pulumi.Input[pulumi.InputType['DatastreamSumologicConnectorArgs']] sumologic_connector: Specify details about the Sumo Logic connector in a stream, including:
-        :param pulumi.Input[str] template_name: The name of the data set template available for the product that you want to use in the stream. Currently, `EDGE_LOGS` is the only data set template available.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: DatastreamArgs,
+                 args: GtmPropertyArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        ## Import
-
-        Basic usagehcl resource "akamai_datastream" "example" {
-
-        # (resource arguments)
-
-         } You can import your Akamai DataStream configuration using a stream version ID. For example
-
-        ```sh
-         $ pulumi import akamai:index/datastream:Datastream example 1234
-        ```
-
-         ~> **IMPORTANT:** For security reasons, this command doesn't import any secrets you specify for your connector. To make sure the state file includes complete data, use this resource to manually add the arguments marked **Secret** above.
-
+        Create a GtmProperty resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param DatastreamArgs args: The arguments to use to populate this resource's properties.
+        :param GtmPropertyArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(DatastreamArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(GtmPropertyArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 active: Optional[pulumi.Input[bool]] = None,
-                 azure_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamAzureConnectorArgs']]] = None,
-                 config: Optional[pulumi.Input[pulumi.InputType['DatastreamConfigArgs']]] = None,
-                 contract_id: Optional[pulumi.Input[str]] = None,
-                 datadog_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamDatadogConnectorArgs']]] = None,
-                 dataset_fields_ids: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
-                 elasticsearch_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamElasticsearchConnectorArgs']]] = None,
-                 email_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 gcs_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamGcsConnectorArgs']]] = None,
-                 group_id: Optional[pulumi.Input[str]] = None,
-                 https_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamHttpsConnectorArgs']]] = None,
-                 loggly_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamLogglyConnectorArgs']]] = None,
-                 new_relic_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamNewRelicConnectorArgs']]] = None,
-                 oracle_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamOracleConnectorArgs']]] = None,
-                 property_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 s3_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamS3ConnectorArgs']]] = None,
-                 splunk_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamSplunkConnectorArgs']]] = None,
-                 stream_name: Optional[pulumi.Input[str]] = None,
-                 stream_type: Optional[pulumi.Input[str]] = None,
-                 sumologic_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamSumologicConnectorArgs']]] = None,
-                 template_name: Optional[pulumi.Input[str]] = None,
+                 backup_cname: Optional[pulumi.Input[str]] = None,
+                 backup_ip: Optional[pulumi.Input[str]] = None,
+                 balance_by_download_score: Optional[pulumi.Input[bool]] = None,
+                 cname: Optional[pulumi.Input[str]] = None,
+                 comments: Optional[pulumi.Input[str]] = None,
+                 domain: Optional[pulumi.Input[str]] = None,
+                 dynamic_ttl: Optional[pulumi.Input[int]] = None,
+                 failback_delay: Optional[pulumi.Input[int]] = None,
+                 failover_delay: Optional[pulumi.Input[int]] = None,
+                 ghost_demand_reporting: Optional[pulumi.Input[bool]] = None,
+                 handout_limit: Optional[pulumi.Input[int]] = None,
+                 handout_mode: Optional[pulumi.Input[str]] = None,
+                 health_max: Optional[pulumi.Input[float]] = None,
+                 health_multiplier: Optional[pulumi.Input[float]] = None,
+                 health_threshold: Optional[pulumi.Input[float]] = None,
+                 ipv6: Optional[pulumi.Input[bool]] = None,
+                 liveness_tests: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyLivenessTestArgs']]]]] = None,
+                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
+                 map_name: Optional[pulumi.Input[str]] = None,
+                 max_unreachable_penalty: Optional[pulumi.Input[int]] = None,
+                 min_live_fraction: Optional[pulumi.Input[float]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
+                 score_aggregation_type: Optional[pulumi.Input[str]] = None,
+                 static_rr_sets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyStaticRrSetArgs']]]]] = None,
+                 static_ttl: Optional[pulumi.Input[int]] = None,
+                 stickiness_bonus_constant: Optional[pulumi.Input[int]] = None,
+                 stickiness_bonus_percentage: Optional[pulumi.Input[int]] = None,
+                 traffic_targets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyTrafficTargetArgs']]]]] = None,
+                 type: Optional[pulumi.Input[str]] = None,
+                 unreachable_threshold: Optional[pulumi.Input[float]] = None,
+                 use_computed_targets: Optional[pulumi.Input[bool]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
                  __props__=None):
+        pulumi.log.warn("""GtmProperty is deprecated: akamai.trafficmanagement.GtmProperty has been deprecated in favor of akamai.GtmProperty""")
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = DatastreamArgs.__new__(DatastreamArgs)
+            __props__ = GtmPropertyArgs.__new__(GtmPropertyArgs)
 
-            if active is None and not opts.urn:
-                raise TypeError("Missing required property 'active'")
-            __props__.__dict__["active"] = active
-            __props__.__dict__["azure_connector"] = azure_connector
-            if config is None and not opts.urn:
-                raise TypeError("Missing required property 'config'")
-            __props__.__dict__["config"] = config
-            if contract_id is None and not opts.urn:
-                raise TypeError("Missing required property 'contract_id'")
-            __props__.__dict__["contract_id"] = contract_id
-            __props__.__dict__["datadog_connector"] = datadog_connector
-            if dataset_fields_ids is None and not opts.urn:
-                raise TypeError("Missing required property 'dataset_fields_ids'")
-            __props__.__dict__["dataset_fields_ids"] = dataset_fields_ids
-            __props__.__dict__["elasticsearch_connector"] = elasticsearch_connector
-            __props__.__dict__["email_ids"] = email_ids
-            __props__.__dict__["gcs_connector"] = gcs_connector
-            if group_id is None and not opts.urn:
-                raise TypeError("Missing required property 'group_id'")
-            __props__.__dict__["group_id"] = group_id
-            __props__.__dict__["https_connector"] = https_connector
-            __props__.__dict__["loggly_connector"] = loggly_connector
-            __props__.__dict__["new_relic_connector"] = new_relic_connector
-            __props__.__dict__["oracle_connector"] = oracle_connector
-            if property_ids is None and not opts.urn:
-                raise TypeError("Missing required property 'property_ids'")
-            __props__.__dict__["property_ids"] = property_ids
-            __props__.__dict__["s3_connector"] = s3_connector
-            __props__.__dict__["splunk_connector"] = splunk_connector
-            if stream_name is None and not opts.urn:
-                raise TypeError("Missing required property 'stream_name'")
-            __props__.__dict__["stream_name"] = stream_name
-            if stream_type is None and not opts.urn:
-                raise TypeError("Missing required property 'stream_type'")
-            __props__.__dict__["stream_type"] = stream_type
-            __props__.__dict__["sumologic_connector"] = sumologic_connector
-            if template_name is None and not opts.urn:
-                raise TypeError("Missing required property 'template_name'")
-            __props__.__dict__["template_name"] = template_name
-            __props__.__dict__["created_by"] = None
-            __props__.__dict__["created_date"] = None
-            __props__.__dict__["group_name"] = None
-            __props__.__dict__["modified_by"] = None
-            __props__.__dict__["modified_date"] = None
-            __props__.__dict__["papi_json"] = None
-            __props__.__dict__["product_id"] = None
-            __props__.__dict__["product_name"] = None
-            __props__.__dict__["stream_version_id"] = None
-        super(Datastream, __self__).__init__(
-            'akamai:index/datastream:Datastream',
+            __props__.__dict__["backup_cname"] = backup_cname
+            __props__.__dict__["backup_ip"] = backup_ip
+            __props__.__dict__["balance_by_download_score"] = balance_by_download_score
+            __props__.__dict__["cname"] = cname
+            __props__.__dict__["comments"] = comments
+            if domain is None and not opts.urn:
+                raise TypeError("Missing required property 'domain'")
+            __props__.__dict__["domain"] = domain
+            __props__.__dict__["dynamic_ttl"] = dynamic_ttl
+            __props__.__dict__["failback_delay"] = failback_delay
+            __props__.__dict__["failover_delay"] = failover_delay
+            __props__.__dict__["ghost_demand_reporting"] = ghost_demand_reporting
+            if handout_limit is None and not opts.urn:
+                raise TypeError("Missing required property 'handout_limit'")
+            __props__.__dict__["handout_limit"] = handout_limit
+            if handout_mode is None and not opts.urn:
+                raise TypeError("Missing required property 'handout_mode'")
+            __props__.__dict__["handout_mode"] = handout_mode
+            __props__.__dict__["health_max"] = health_max
+            __props__.__dict__["health_multiplier"] = health_multiplier
+            __props__.__dict__["health_threshold"] = health_threshold
+            __props__.__dict__["ipv6"] = ipv6
+            __props__.__dict__["liveness_tests"] = liveness_tests
+            __props__.__dict__["load_imbalance_percentage"] = load_imbalance_percentage
+            __props__.__dict__["map_name"] = map_name
+            __props__.__dict__["max_unreachable_penalty"] = max_unreachable_penalty
+            __props__.__dict__["min_live_fraction"] = min_live_fraction
+            __props__.__dict__["name"] = name
+            if score_aggregation_type is None and not opts.urn:
+                raise TypeError("Missing required property 'score_aggregation_type'")
+            __props__.__dict__["score_aggregation_type"] = score_aggregation_type
+            __props__.__dict__["static_rr_sets"] = static_rr_sets
+            __props__.__dict__["static_ttl"] = static_ttl
+            __props__.__dict__["stickiness_bonus_constant"] = stickiness_bonus_constant
+            __props__.__dict__["stickiness_bonus_percentage"] = stickiness_bonus_percentage
+            __props__.__dict__["traffic_targets"] = traffic_targets
+            if type is None and not opts.urn:
+                raise TypeError("Missing required property 'type'")
+            __props__.__dict__["type"] = type
+            __props__.__dict__["unreachable_threshold"] = unreachable_threshold
+            __props__.__dict__["use_computed_targets"] = use_computed_targets
+            __props__.__dict__["wait_on_complete"] = wait_on_complete
+            __props__.__dict__["weighted_hash_bits_for_ipv4"] = None
+            __props__.__dict__["weighted_hash_bits_for_ipv6"] = None
+        super(GtmProperty, __self__).__init__(
+            'akamai:trafficmanagement/gtmProperty:GtmProperty',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
-            active: Optional[pulumi.Input[bool]] = None,
-            azure_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamAzureConnectorArgs']]] = None,
-            config: Optional[pulumi.Input[pulumi.InputType['DatastreamConfigArgs']]] = None,
-            contract_id: Optional[pulumi.Input[str]] = None,
-            created_by: Optional[pulumi.Input[str]] = None,
-            created_date: Optional[pulumi.Input[str]] = None,
-            datadog_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamDatadogConnectorArgs']]] = None,
-            dataset_fields_ids: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
-            elasticsearch_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamElasticsearchConnectorArgs']]] = None,
-            email_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-            gcs_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamGcsConnectorArgs']]] = None,
-            group_id: Optional[pulumi.Input[str]] = None,
-            group_name: Optional[pulumi.Input[str]] = None,
-            https_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamHttpsConnectorArgs']]] = None,
-            loggly_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamLogglyConnectorArgs']]] = None,
-            modified_by: Optional[pulumi.Input[str]] = None,
-            modified_date: Optional[pulumi.Input[str]] = None,
-            new_relic_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamNewRelicConnectorArgs']]] = None,
-            oracle_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamOracleConnectorArgs']]] = None,
-            papi_json: Optional[pulumi.Input[str]] = None,
-            product_id: Optional[pulumi.Input[str]] = None,
-            product_name: Optional[pulumi.Input[str]] = None,
-            property_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-            s3_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamS3ConnectorArgs']]] = None,
-            splunk_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamSplunkConnectorArgs']]] = None,
-            stream_name: Optional[pulumi.Input[str]] = None,
-            stream_type: Optional[pulumi.Input[str]] = None,
-            stream_version_id: Optional[pulumi.Input[int]] = None,
-            sumologic_connector: Optional[pulumi.Input[pulumi.InputType['DatastreamSumologicConnectorArgs']]] = None,
-            template_name: Optional[pulumi.Input[str]] = None) -> 'Datastream':
+            backup_cname: Optional[pulumi.Input[str]] = None,
+            backup_ip: Optional[pulumi.Input[str]] = None,
+            balance_by_download_score: Optional[pulumi.Input[bool]] = None,
+            cname: Optional[pulumi.Input[str]] = None,
+            comments: Optional[pulumi.Input[str]] = None,
+            domain: Optional[pulumi.Input[str]] = None,
+            dynamic_ttl: Optional[pulumi.Input[int]] = None,
+            failback_delay: Optional[pulumi.Input[int]] = None,
+            failover_delay: Optional[pulumi.Input[int]] = None,
+            ghost_demand_reporting: Optional[pulumi.Input[bool]] = None,
+            handout_limit: Optional[pulumi.Input[int]] = None,
+            handout_mode: Optional[pulumi.Input[str]] = None,
+            health_max: Optional[pulumi.Input[float]] = None,
+            health_multiplier: Optional[pulumi.Input[float]] = None,
+            health_threshold: Optional[pulumi.Input[float]] = None,
+            ipv6: Optional[pulumi.Input[bool]] = None,
+            liveness_tests: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyLivenessTestArgs']]]]] = None,
+            load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
+            map_name: Optional[pulumi.Input[str]] = None,
+            max_unreachable_penalty: Optional[pulumi.Input[int]] = None,
+            min_live_fraction: Optional[pulumi.Input[float]] = None,
+            name: Optional[pulumi.Input[str]] = None,
+            score_aggregation_type: Optional[pulumi.Input[str]] = None,
+            static_rr_sets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyStaticRrSetArgs']]]]] = None,
+            static_ttl: Optional[pulumi.Input[int]] = None,
+            stickiness_bonus_constant: Optional[pulumi.Input[int]] = None,
+            stickiness_bonus_percentage: Optional[pulumi.Input[int]] = None,
+            traffic_targets: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmPropertyTrafficTargetArgs']]]]] = None,
+            type: Optional[pulumi.Input[str]] = None,
+            unreachable_threshold: Optional[pulumi.Input[float]] = None,
+            use_computed_targets: Optional[pulumi.Input[bool]] = None,
+            wait_on_complete: Optional[pulumi.Input[bool]] = None,
+            weighted_hash_bits_for_ipv4: Optional[pulumi.Input[int]] = None,
+            weighted_hash_bits_for_ipv6: Optional[pulumi.Input[int]] = None) -> 'GtmProperty':
         """
-        Get an existing Datastream resource's state with the given name, id, and optional extra
+        Get an existing GtmProperty resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[bool] active: Whether you want to start activating the stream when applying the resource. Either `true` for activating the stream upon sending the request or `false` for leaving the stream inactive after the request.
-        :param pulumi.Input[pulumi.InputType['DatastreamAzureConnectorArgs']] azure_connector: Specify details about the Azure Storage connector configuration in a data stream. Note that currently DataStream supports only streaming data to [block objects](https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs). The argument includes these sub-arguments:
-        :param pulumi.Input[pulumi.InputType['DatastreamConfigArgs']] config: Provides information about the log line configuration, log file format, names of log files sent, and file delivery. The argument includes these sub-arguments:
-        :param pulumi.Input[str] contract_id: Identifies the contract that has access to the product.
-        :param pulumi.Input[str] created_by: The username who created the stream
-        :param pulumi.Input[str] created_date: The date and time when the stream was created
-        :param pulumi.Input[pulumi.InputType['DatastreamDatadogConnectorArgs']] datadog_connector: Specify details about the Datadog connector in a stream, including:
-        :param pulumi.Input[Sequence[pulumi.Input[int]]] dataset_fields_ids: Identifiers of the data set fields within the template that you want to receive in logs. The order of the identifiers define how the value for these fields appears in the log lines. See [Data set parameters](https://techdocs.akamai.com/datastream2/reference/data-set-parameters-1).
-        :param pulumi.Input[pulumi.InputType['DatastreamElasticsearchConnectorArgs']] elasticsearch_connector: Specify details about the Elasticsearch connector you can use in a stream, including:
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_ids: A list of email addresses you want to notify about activations and deactivations of the stream.
-        :param pulumi.Input[pulumi.InputType['DatastreamGcsConnectorArgs']] gcs_connector: Specify details about the Google Cloud Storage connector you can use in a stream. When validating this connector, DataStream uses the private access key to create an `Akamai_access_verification_<timestamp>.txt` object file in your GCS bucket. You can only see this file if the validation process is successful, and you have access to the Google Cloud Storage bucket where you are trying to send logs. The argument includes these sub-arguments:
-        :param pulumi.Input[str] group_id: Identifies the group that has access to the product and this stream configuration.
-        :param pulumi.Input[str] group_name: The name of the user group for which the stream was created
-        :param pulumi.Input[pulumi.InputType['DatastreamHttpsConnectorArgs']] https_connector: Specify details about the custom HTTPS endpoint you can use as a connector for a stream, including:
-        :param pulumi.Input[pulumi.InputType['DatastreamLogglyConnectorArgs']] loggly_connector: Specify details about the Loggly connector you can use in a stream, including:
-        :param pulumi.Input[str] modified_by: The username who modified the stream
-        :param pulumi.Input[str] modified_date: The date and time when the stream was modified
-        :param pulumi.Input[pulumi.InputType['DatastreamNewRelicConnectorArgs']] new_relic_connector: Specify details about the New Relic connector you can use in a stream, including:
-        :param pulumi.Input[pulumi.InputType['DatastreamOracleConnectorArgs']] oracle_connector: Specify details about the Oracle Cloud Storage connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and tries to save an `Akamai_access_verification_<timestamp>.txt` file in your Oracle Cloud Storage folder. You can only see this file if the validation process is successful, and you have access to the Oracle Cloud Storage bucket and folder that youre trying to send logs to.
-        :param pulumi.Input[str] papi_json: The configuration in JSON format that can be copy-pasted into PAPI configuration to enable datastream behavior
-        :param pulumi.Input[str] product_id: The ID of the product for which the stream was created
-        :param pulumi.Input[str] product_name: The name of the product for which the stream was created
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] property_ids: Identifies the properties that you want to monitor in the stream. Note that a stream can only log data for active properties.
-        :param pulumi.Input[pulumi.InputType['DatastreamS3ConnectorArgs']] s3_connector: Specify details about the Amazon S3 connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and saves an `akamai_write_test_2147483647.txt` file in your Amazon S3 folder. You can only see this file if validation succeeds, and you have access to the Amazon S3 bucket and folder that youre trying to send logs to. The argument includes these sub-arguments:
-        :param pulumi.Input[pulumi.InputType['DatastreamSplunkConnectorArgs']] splunk_connector: Specify details about the Splunk connector in your stream. Note that currently DataStream supports only endpoint URLs ending with `collector/raw`. The argument includes these sub-arguments:
-        :param pulumi.Input[str] stream_name: The name of the stream.
-        :param pulumi.Input[str] stream_type: The type of stream that you want to create. Currently, `RAW_LOGS` is the only possible stream type.
-        :param pulumi.Input[int] stream_version_id: Identifies the configuration version of the stream
-        :param pulumi.Input[pulumi.InputType['DatastreamSumologicConnectorArgs']] sumologic_connector: Specify details about the Sumo Logic connector in a stream, including:
-        :param pulumi.Input[str] template_name: The name of the data set template available for the product that you want to use in the stream. Currently, `EDGE_LOGS` is the only data set template available.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _DatastreamState.__new__(_DatastreamState)
+        __props__ = _GtmPropertyState.__new__(_GtmPropertyState)
 
-        __props__.__dict__["active"] = active
-        __props__.__dict__["azure_connector"] = azure_connector
-        __props__.__dict__["config"] = config
-        __props__.__dict__["contract_id"] = contract_id
-        __props__.__dict__["created_by"] = created_by
-        __props__.__dict__["created_date"] = created_date
-        __props__.__dict__["datadog_connector"] = datadog_connector
-        __props__.__dict__["dataset_fields_ids"] = dataset_fields_ids
-        __props__.__dict__["elasticsearch_connector"] = elasticsearch_connector
-        __props__.__dict__["email_ids"] = email_ids
-        __props__.__dict__["gcs_connector"] = gcs_connector
-        __props__.__dict__["group_id"] = group_id
-        __props__.__dict__["group_name"] = group_name
-        __props__.__dict__["https_connector"] = https_connector
-        __props__.__dict__["loggly_connector"] = loggly_connector
-        __props__.__dict__["modified_by"] = modified_by
-        __props__.__dict__["modified_date"] = modified_date
-        __props__.__dict__["new_relic_connector"] = new_relic_connector
-        __props__.__dict__["oracle_connector"] = oracle_connector
-        __props__.__dict__["papi_json"] = papi_json
-        __props__.__dict__["product_id"] = product_id
-        __props__.__dict__["product_name"] = product_name
-        __props__.__dict__["property_ids"] = property_ids
-        __props__.__dict__["s3_connector"] = s3_connector
-        __props__.__dict__["splunk_connector"] = splunk_connector
-        __props__.__dict__["stream_name"] = stream_name
-        __props__.__dict__["stream_type"] = stream_type
-        __props__.__dict__["stream_version_id"] = stream_version_id
-        __props__.__dict__["sumologic_connector"] = sumologic_connector
-        __props__.__dict__["template_name"] = template_name
-        return Datastream(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["backup_cname"] = backup_cname
+        __props__.__dict__["backup_ip"] = backup_ip
+        __props__.__dict__["balance_by_download_score"] = balance_by_download_score
+        __props__.__dict__["cname"] = cname
+        __props__.__dict__["comments"] = comments
+        __props__.__dict__["domain"] = domain
+        __props__.__dict__["dynamic_ttl"] = dynamic_ttl
+        __props__.__dict__["failback_delay"] = failback_delay
+        __props__.__dict__["failover_delay"] = failover_delay
+        __props__.__dict__["ghost_demand_reporting"] = ghost_demand_reporting
+        __props__.__dict__["handout_limit"] = handout_limit
+        __props__.__dict__["handout_mode"] = handout_mode
+        __props__.__dict__["health_max"] = health_max
+        __props__.__dict__["health_multiplier"] = health_multiplier
+        __props__.__dict__["health_threshold"] = health_threshold
+        __props__.__dict__["ipv6"] = ipv6
+        __props__.__dict__["liveness_tests"] = liveness_tests
+        __props__.__dict__["load_imbalance_percentage"] = load_imbalance_percentage
+        __props__.__dict__["map_name"] = map_name
+        __props__.__dict__["max_unreachable_penalty"] = max_unreachable_penalty
+        __props__.__dict__["min_live_fraction"] = min_live_fraction
+        __props__.__dict__["name"] = name
+        __props__.__dict__["score_aggregation_type"] = score_aggregation_type
+        __props__.__dict__["static_rr_sets"] = static_rr_sets
+        __props__.__dict__["static_ttl"] = static_ttl
+        __props__.__dict__["stickiness_bonus_constant"] = stickiness_bonus_constant
+        __props__.__dict__["stickiness_bonus_percentage"] = stickiness_bonus_percentage
+        __props__.__dict__["traffic_targets"] = traffic_targets
+        __props__.__dict__["type"] = type
+        __props__.__dict__["unreachable_threshold"] = unreachable_threshold
+        __props__.__dict__["use_computed_targets"] = use_computed_targets
+        __props__.__dict__["wait_on_complete"] = wait_on_complete
+        __props__.__dict__["weighted_hash_bits_for_ipv4"] = weighted_hash_bits_for_ipv4
+        __props__.__dict__["weighted_hash_bits_for_ipv6"] = weighted_hash_bits_for_ipv6
+        return GtmProperty(resource_name, opts=opts, __props__=__props__)
+
+    @property
+    @pulumi.getter(name="backupCname")
+    def backup_cname(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "backup_cname")
+
+    @property
+    @pulumi.getter(name="backupIp")
+    def backup_ip(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "backup_ip")
+
+    @property
+    @pulumi.getter(name="balanceByDownloadScore")
+    def balance_by_download_score(self) -> pulumi.Output[Optional[bool]]:
+        return pulumi.get(self, "balance_by_download_score")
 
     @property
     @pulumi.getter
-    def active(self) -> pulumi.Output[bool]:
-        """
-        Whether you want to start activating the stream when applying the resource. Either `true` for activating the stream upon sending the request or `false` for leaving the stream inactive after the request.
-        """
-        return pulumi.get(self, "active")
+    def cname(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "cname")
 
     @property
-    @pulumi.getter(name="azureConnector")
-    def azure_connector(self) -> pulumi.Output[Optional['outputs.DatastreamAzureConnector']]:
-        """
-        Specify details about the Azure Storage connector configuration in a data stream. Note that currently DataStream supports only streaming data to [block objects](https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs). The argument includes these sub-arguments:
-        """
-        return pulumi.get(self, "azure_connector")
+    @pulumi.getter
+    def comments(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "comments")
 
     @property
     @pulumi.getter
-    def config(self) -> pulumi.Output['outputs.DatastreamConfig']:
-        """
-        Provides information about the log line configuration, log file format, names of log files sent, and file delivery. The argument includes these sub-arguments:
-        """
-        return pulumi.get(self, "config")
+    def domain(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "domain")
 
     @property
-    @pulumi.getter(name="contractId")
-    def contract_id(self) -> pulumi.Output[str]:
-        """
-        Identifies the contract that has access to the product.
-        """
-        return pulumi.get(self, "contract_id")
+    @pulumi.getter(name="dynamicTtl")
+    def dynamic_ttl(self) -> pulumi.Output[Optional[int]]:
+        return pulumi.get(self, "dynamic_ttl")
 
     @property
-    @pulumi.getter(name="createdBy")
-    def created_by(self) -> pulumi.Output[str]:
-        """
-        The username who created the stream
-        """
-        return pulumi.get(self, "created_by")
+    @pulumi.getter(name="failbackDelay")
+    def failback_delay(self) -> pulumi.Output[Optional[int]]:
+        return pulumi.get(self, "failback_delay")
 
     @property
-    @pulumi.getter(name="createdDate")
-    def created_date(self) -> pulumi.Output[str]:
-        """
-        The date and time when the stream was created
-        """
-        return pulumi.get(self, "created_date")
+    @pulumi.getter(name="failoverDelay")
+    def failover_delay(self) -> pulumi.Output[Optional[int]]:
+        return pulumi.get(self, "failover_delay")
 
     @property
-    @pulumi.getter(name="datadogConnector")
-    def datadog_connector(self) -> pulumi.Output[Optional['outputs.DatastreamDatadogConnector']]:
-        """
-        Specify details about the Datadog connector in a stream, including:
-        """
-        return pulumi.get(self, "datadog_connector")
+    @pulumi.getter(name="ghostDemandReporting")
+    def ghost_demand_reporting(self) -> pulumi.Output[Optional[bool]]:
+        return pulumi.get(self, "ghost_demand_reporting")
 
     @property
-    @pulumi.getter(name="datasetFieldsIds")
-    def dataset_fields_ids(self) -> pulumi.Output[Sequence[int]]:
-        """
-        Identifiers of the data set fields within the template that you want to receive in logs. The order of the identifiers define how the value for these fields appears in the log lines. See [Data set parameters](https://techdocs.akamai.com/datastream2/reference/data-set-parameters-1).
-        """
-        return pulumi.get(self, "dataset_fields_ids")
+    @pulumi.getter(name="handoutLimit")
+    def handout_limit(self) -> pulumi.Output[int]:
+        return pulumi.get(self, "handout_limit")
 
     @property
-    @pulumi.getter(name="elasticsearchConnector")
-    def elasticsearch_connector(self) -> pulumi.Output[Optional['outputs.DatastreamElasticsearchConnector']]:
-        """
-        Specify details about the Elasticsearch connector you can use in a stream, including:
-        """
-        return pulumi.get(self, "elasticsearch_connector")
+    @pulumi.getter(name="handoutMode")
+    def handout_mode(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "handout_mode")
 
     @property
-    @pulumi.getter(name="emailIds")
-    def email_ids(self) -> pulumi.Output[Optional[Sequence[str]]]:
-        """
-        A list of email addresses you want to notify about activations and deactivations of the stream.
-        """
-        return pulumi.get(self, "email_ids")
+    @pulumi.getter(name="healthMax")
+    def health_max(self) -> pulumi.Output[Optional[float]]:
+        return pulumi.get(self, "health_max")
 
     @property
-    @pulumi.getter(name="gcsConnector")
-    def gcs_connector(self) -> pulumi.Output[Optional['outputs.DatastreamGcsConnector']]:
-        """
-        Specify details about the Google Cloud Storage connector you can use in a stream. When validating this connector, DataStream uses the private access key to create an `Akamai_access_verification_<timestamp>.txt` object file in your GCS bucket. You can only see this file if the validation process is successful, and you have access to the Google Cloud Storage bucket where you are trying to send logs. The argument includes these sub-arguments:
-        """
-        return pulumi.get(self, "gcs_connector")
+    @pulumi.getter(name="healthMultiplier")
+    def health_multiplier(self) -> pulumi.Output[Optional[float]]:
+        return pulumi.get(self, "health_multiplier")
 
     @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> pulumi.Output[str]:
-        """
-        Identifies the group that has access to the product and this stream configuration.
-        """
-        return pulumi.get(self, "group_id")
+    @pulumi.getter(name="healthThreshold")
+    def health_threshold(self) -> pulumi.Output[Optional[float]]:
+        return pulumi.get(self, "health_threshold")
 
     @property
-    @pulumi.getter(name="groupName")
-    def group_name(self) -> pulumi.Output[str]:
-        """
-        The name of the user group for which the stream was created
-        """
-        return pulumi.get(self, "group_name")
+    @pulumi.getter
+    def ipv6(self) -> pulumi.Output[Optional[bool]]:
+        return pulumi.get(self, "ipv6")
 
     @property
-    @pulumi.getter(name="httpsConnector")
-    def https_connector(self) -> pulumi.Output[Optional['outputs.DatastreamHttpsConnector']]:
-        """
-        Specify details about the custom HTTPS endpoint you can use as a connector for a stream, including:
-        """
-        return pulumi.get(self, "https_connector")
+    @pulumi.getter(name="livenessTests")
+    def liveness_tests(self) -> pulumi.Output[Optional[Sequence['outputs.GtmPropertyLivenessTest']]]:
+        return pulumi.get(self, "liveness_tests")
 
     @property
-    @pulumi.getter(name="logglyConnector")
-    def loggly_connector(self) -> pulumi.Output[Optional['outputs.DatastreamLogglyConnector']]:
-        """
-        Specify details about the Loggly connector you can use in a stream, including:
-        """
-        return pulumi.get(self, "loggly_connector")
+    @pulumi.getter(name="loadImbalancePercentage")
+    def load_imbalance_percentage(self) -> pulumi.Output[Optional[float]]:
+        return pulumi.get(self, "load_imbalance_percentage")
 
     @property
-    @pulumi.getter(name="modifiedBy")
-    def modified_by(self) -> pulumi.Output[str]:
-        """
-        The username who modified the stream
-        """
-        return pulumi.get(self, "modified_by")
+    @pulumi.getter(name="mapName")
+    def map_name(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "map_name")
 
     @property
-    @pulumi.getter(name="modifiedDate")
-    def modified_date(self) -> pulumi.Output[str]:
-        """
-        The date and time when the stream was modified
-        """
-        return pulumi.get(self, "modified_date")
+    @pulumi.getter(name="maxUnreachablePenalty")
+    def max_unreachable_penalty(self) -> pulumi.Output[Optional[int]]:
+        return pulumi.get(self, "max_unreachable_penalty")
 
     @property
-    @pulumi.getter(name="newRelicConnector")
-    def new_relic_connector(self) -> pulumi.Output[Optional['outputs.DatastreamNewRelicConnector']]:
-        """
-        Specify details about the New Relic connector you can use in a stream, including:
-        """
-        return pulumi.get(self, "new_relic_connector")
+    @pulumi.getter(name="minLiveFraction")
+    def min_live_fraction(self) -> pulumi.Output[Optional[float]]:
+        return pulumi.get(self, "min_live_fraction")
 
     @property
-    @pulumi.getter(name="oracleConnector")
-    def oracle_connector(self) -> pulumi.Output[Optional['outputs.DatastreamOracleConnector']]:
-        """
-        Specify details about the Oracle Cloud Storage connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and tries to save an `Akamai_access_verification_<timestamp>.txt` file in your Oracle Cloud Storage folder. You can only see this file if the validation process is successful, and you have access to the Oracle Cloud Storage bucket and folder that youre trying to send logs to.
-        """
-        return pulumi.get(self, "oracle_connector")
+    @pulumi.getter
+    def name(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "name")
 
     @property
-    @pulumi.getter(name="papiJson")
-    def papi_json(self) -> pulumi.Output[str]:
-        """
-        The configuration in JSON format that can be copy-pasted into PAPI configuration to enable datastream behavior
-        """
-        return pulumi.get(self, "papi_json")
+    @pulumi.getter(name="scoreAggregationType")
+    def score_aggregation_type(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "score_aggregation_type")
 
     @property
-    @pulumi.getter(name="productId")
-    def product_id(self) -> pulumi.Output[str]:
-        """
-        The ID of the product for which the stream was created
-        """
-        return pulumi.get(self, "product_id")
+    @pulumi.getter(name="staticRrSets")
+    def static_rr_sets(self) -> pulumi.Output[Optional[Sequence['outputs.GtmPropertyStaticRrSet']]]:
+        return pulumi.get(self, "static_rr_sets")
 
     @property
-    @pulumi.getter(name="productName")
-    def product_name(self) -> pulumi.Output[str]:
-        """
-        The name of the product for which the stream was created
-        """
-        return pulumi.get(self, "product_name")
+    @pulumi.getter(name="staticTtl")
+    def static_ttl(self) -> pulumi.Output[Optional[int]]:
+        return pulumi.get(self, "static_ttl")
 
     @property
-    @pulumi.getter(name="propertyIds")
-    def property_ids(self) -> pulumi.Output[Sequence[str]]:
-        """
-        Identifies the properties that you want to monitor in the stream. Note that a stream can only log data for active properties.
-        """
-        return pulumi.get(self, "property_ids")
+    @pulumi.getter(name="stickinessBonusConstant")
+    def stickiness_bonus_constant(self) -> pulumi.Output[Optional[int]]:
+        return pulumi.get(self, "stickiness_bonus_constant")
 
     @property
-    @pulumi.getter(name="s3Connector")
-    def s3_connector(self) -> pulumi.Output[Optional['outputs.DatastreamS3Connector']]:
-        """
-        Specify details about the Amazon S3 connector in a stream. When validating this connector, DataStream uses the provided `access_key` and `secret_access_key` values and saves an `akamai_write_test_2147483647.txt` file in your Amazon S3 folder. You can only see this file if validation succeeds, and you have access to the Amazon S3 bucket and folder that youre trying to send logs to. The argument includes these sub-arguments:
-        """
-        return pulumi.get(self, "s3_connector")
+    @pulumi.getter(name="stickinessBonusPercentage")
+    def stickiness_bonus_percentage(self) -> pulumi.Output[Optional[int]]:
+        return pulumi.get(self, "stickiness_bonus_percentage")
 
     @property
-    @pulumi.getter(name="splunkConnector")
-    def splunk_connector(self) -> pulumi.Output[Optional['outputs.DatastreamSplunkConnector']]:
-        """
-        Specify details about the Splunk connector in your stream. Note that currently DataStream supports only endpoint URLs ending with `collector/raw`. The argument includes these sub-arguments:
-        """
-        return pulumi.get(self, "splunk_connector")
+    @pulumi.getter(name="trafficTargets")
+    def traffic_targets(self) -> pulumi.Output[Optional[Sequence['outputs.GtmPropertyTrafficTarget']]]:
+        return pulumi.get(self, "traffic_targets")
 
     @property
-    @pulumi.getter(name="streamName")
-    def stream_name(self) -> pulumi.Output[str]:
-        """
-        The name of the stream.
-        """
-        return pulumi.get(self, "stream_name")
+    @pulumi.getter
+    def type(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "type")
 
     @property
-    @pulumi.getter(name="streamType")
-    def stream_type(self) -> pulumi.Output[str]:
-        """
-        The type of stream that you want to create. Currently, `RAW_LOGS` is the only possible stream type.
-        """
-        return pulumi.get(self, "stream_type")
+    @pulumi.getter(name="unreachableThreshold")
+    def unreachable_threshold(self) -> pulumi.Output[Optional[float]]:
+        return pulumi.get(self, "unreachable_threshold")
 
     @property
-    @pulumi.getter(name="streamVersionId")
-    def stream_version_id(self) -> pulumi.Output[int]:
-        """
-        Identifies the configuration version of the stream
-        """
-        return pulumi.get(self, "stream_version_id")
+    @pulumi.getter(name="useComputedTargets")
+    def use_computed_targets(self) -> pulumi.Output[Optional[bool]]:
+        return pulumi.get(self, "use_computed_targets")
 
     @property
-    @pulumi.getter(name="sumologicConnector")
-    def sumologic_connector(self) -> pulumi.Output[Optional['outputs.DatastreamSumologicConnector']]:
-        """
-        Specify details about the Sumo Logic connector in a stream, including:
-        """
-        return pulumi.get(self, "sumologic_connector")
+    @pulumi.getter(name="waitOnComplete")
+    def wait_on_complete(self) -> pulumi.Output[Optional[bool]]:
+        return pulumi.get(self, "wait_on_complete")
 
     @property
-    @pulumi.getter(name="templateName")
-    def template_name(self) -> pulumi.Output[str]:
-        """
-        The name of the data set template available for the product that you want to use in the stream. Currently, `EDGE_LOGS` is the only data set template available.
-        """
-        return pulumi.get(self, "template_name")
+    @pulumi.getter(name="weightedHashBitsForIpv4")
+    def weighted_hash_bits_for_ipv4(self) -> pulumi.Output[int]:
+        return pulumi.get(self, "weighted_hash_bits_for_ipv4")
+
+    @property
+    @pulumi.getter(name="weightedHashBitsForIpv6")
+    def weighted_hash_bits_for_ipv6(self) -> pulumi.Output[int]:
+        return pulumi.get(self, "weighted_hash_bits_for_ipv6")
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/dns_record.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/dns_record.py`

 * *Files identical despite different names*

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/dns_zone.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/gtm_datacenter.py`

 * *Files 20% similar despite different names*

```diff
@@ -7,674 +7,697 @@
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 from . import outputs
 from ._inputs import *
 
-__all__ = ['DnsZoneArgs', 'DnsZone']
+__all__ = ['GtmDatacenterArgs', 'GtmDatacenter']
 
 @pulumi.input_type
-class DnsZoneArgs:
+class GtmDatacenterArgs:
     def __init__(__self__, *,
-                 contract: pulumi.Input[str],
-                 type: pulumi.Input[str],
-                 zone: pulumi.Input[str],
-                 comment: Optional[pulumi.Input[str]] = None,
-                 end_customer_id: Optional[pulumi.Input[str]] = None,
-                 group: Optional[pulumi.Input[str]] = None,
-                 masters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 sign_and_serve: Optional[pulumi.Input[bool]] = None,
-                 sign_and_serve_algorithm: Optional[pulumi.Input[str]] = None,
-                 target: Optional[pulumi.Input[str]] = None,
-                 tsig_key: Optional[pulumi.Input['DnsZoneTsigKeyArgs']] = None):
+                 domain: pulumi.Input[str],
+                 city: Optional[pulumi.Input[str]] = None,
+                 clone_of: Optional[pulumi.Input[int]] = None,
+                 cloud_server_host_header_override: Optional[pulumi.Input[bool]] = None,
+                 cloud_server_targeting: Optional[pulumi.Input[bool]] = None,
+                 continent: Optional[pulumi.Input[str]] = None,
+                 country: Optional[pulumi.Input[str]] = None,
+                 default_load_object: Optional[pulumi.Input['GtmDatacenterDefaultLoadObjectArgs']] = None,
+                 latitude: Optional[pulumi.Input[float]] = None,
+                 longitude: Optional[pulumi.Input[float]] = None,
+                 nickname: Optional[pulumi.Input[str]] = None,
+                 state_or_province: Optional[pulumi.Input[str]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None):
         """
-        The set of arguments for constructing a DnsZone resource.
-        :param pulumi.Input[str] contract: The contract ID.
-        :param pulumi.Input[str] type: Whether the zone is `primary`, `secondary`, or `alias`.
-        :param pulumi.Input[str] zone: The domain zone, encapsulating any nested subdomains.
-        :param pulumi.Input[str] comment: A descriptive comment.
-        :param pulumi.Input[str] end_customer_id: A free form identifier for the zone.
-        :param pulumi.Input[str] group: The currently selected group ID.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] masters: The names or IP addresses of the nameservers that the zone data should be retrieved from.
-        :param pulumi.Input[bool] sign_and_serve: Whether DNSSEC Sign and Serve is enabled.
-        :param pulumi.Input[str] sign_and_serve_algorithm: The algorithm used by Sign and Serve.
-        :param pulumi.Input[str] target: The name of the zone whose configuration this zone will copy.
-        :param pulumi.Input['DnsZoneTsigKeyArgs'] tsig_key: The TSIG Key used in secure zone transfers. If used, requires these arguments:
+        The set of arguments for constructing a GtmDatacenter resource.
         """
-        pulumi.set(__self__, "contract", contract)
-        pulumi.set(__self__, "type", type)
-        pulumi.set(__self__, "zone", zone)
-        if comment is not None:
-            pulumi.set(__self__, "comment", comment)
-        if end_customer_id is not None:
-            pulumi.set(__self__, "end_customer_id", end_customer_id)
-        if group is not None:
-            pulumi.set(__self__, "group", group)
-        if masters is not None:
-            pulumi.set(__self__, "masters", masters)
-        if sign_and_serve is not None:
-            pulumi.set(__self__, "sign_and_serve", sign_and_serve)
-        if sign_and_serve_algorithm is not None:
-            pulumi.set(__self__, "sign_and_serve_algorithm", sign_and_serve_algorithm)
-        if target is not None:
-            pulumi.set(__self__, "target", target)
-        if tsig_key is not None:
-            pulumi.set(__self__, "tsig_key", tsig_key)
+        pulumi.set(__self__, "domain", domain)
+        if city is not None:
+            pulumi.set(__self__, "city", city)
+        if clone_of is not None:
+            pulumi.set(__self__, "clone_of", clone_of)
+        if cloud_server_host_header_override is not None:
+            pulumi.set(__self__, "cloud_server_host_header_override", cloud_server_host_header_override)
+        if cloud_server_targeting is not None:
+            pulumi.set(__self__, "cloud_server_targeting", cloud_server_targeting)
+        if continent is not None:
+            pulumi.set(__self__, "continent", continent)
+        if country is not None:
+            pulumi.set(__self__, "country", country)
+        if default_load_object is not None:
+            pulumi.set(__self__, "default_load_object", default_load_object)
+        if latitude is not None:
+            pulumi.set(__self__, "latitude", latitude)
+        if longitude is not None:
+            pulumi.set(__self__, "longitude", longitude)
+        if nickname is not None:
+            pulumi.set(__self__, "nickname", nickname)
+        if state_or_province is not None:
+            pulumi.set(__self__, "state_or_province", state_or_province)
+        if wait_on_complete is not None:
+            pulumi.set(__self__, "wait_on_complete", wait_on_complete)
 
     @property
     @pulumi.getter
-    def contract(self) -> pulumi.Input[str]:
-        """
-        The contract ID.
-        """
-        return pulumi.get(self, "contract")
+    def domain(self) -> pulumi.Input[str]:
+        return pulumi.get(self, "domain")
 
-    @contract.setter
-    def contract(self, value: pulumi.Input[str]):
-        pulumi.set(self, "contract", value)
+    @domain.setter
+    def domain(self, value: pulumi.Input[str]):
+        pulumi.set(self, "domain", value)
 
     @property
     @pulumi.getter
-    def type(self) -> pulumi.Input[str]:
-        """
-        Whether the zone is `primary`, `secondary`, or `alias`.
-        """
-        return pulumi.get(self, "type")
+    def city(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "city")
 
-    @type.setter
-    def type(self, value: pulumi.Input[str]):
-        pulumi.set(self, "type", value)
+    @city.setter
+    def city(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "city", value)
 
     @property
-    @pulumi.getter
-    def zone(self) -> pulumi.Input[str]:
-        """
-        The domain zone, encapsulating any nested subdomains.
-        """
-        return pulumi.get(self, "zone")
+    @pulumi.getter(name="cloneOf")
+    def clone_of(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "clone_of")
 
-    @zone.setter
-    def zone(self, value: pulumi.Input[str]):
-        pulumi.set(self, "zone", value)
+    @clone_of.setter
+    def clone_of(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "clone_of", value)
 
     @property
-    @pulumi.getter
-    def comment(self) -> Optional[pulumi.Input[str]]:
-        """
-        A descriptive comment.
-        """
-        return pulumi.get(self, "comment")
+    @pulumi.getter(name="cloudServerHostHeaderOverride")
+    def cloud_server_host_header_override(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "cloud_server_host_header_override")
 
-    @comment.setter
-    def comment(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "comment", value)
+    @cloud_server_host_header_override.setter
+    def cloud_server_host_header_override(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "cloud_server_host_header_override", value)
 
     @property
-    @pulumi.getter(name="endCustomerId")
-    def end_customer_id(self) -> Optional[pulumi.Input[str]]:
-        """
-        A free form identifier for the zone.
-        """
-        return pulumi.get(self, "end_customer_id")
+    @pulumi.getter(name="cloudServerTargeting")
+    def cloud_server_targeting(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "cloud_server_targeting")
 
-    @end_customer_id.setter
-    def end_customer_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "end_customer_id", value)
+    @cloud_server_targeting.setter
+    def cloud_server_targeting(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "cloud_server_targeting", value)
 
     @property
     @pulumi.getter
-    def group(self) -> Optional[pulumi.Input[str]]:
-        """
-        The currently selected group ID.
-        """
-        return pulumi.get(self, "group")
+    def continent(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "continent")
 
-    @group.setter
-    def group(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "group", value)
+    @continent.setter
+    def continent(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "continent", value)
 
     @property
     @pulumi.getter
-    def masters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
-        """
-        The names or IP addresses of the nameservers that the zone data should be retrieved from.
-        """
-        return pulumi.get(self, "masters")
+    def country(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "country")
 
-    @masters.setter
-    def masters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
-        pulumi.set(self, "masters", value)
+    @country.setter
+    def country(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "country", value)
 
     @property
-    @pulumi.getter(name="signAndServe")
-    def sign_and_serve(self) -> Optional[pulumi.Input[bool]]:
-        """
-        Whether DNSSEC Sign and Serve is enabled.
-        """
-        return pulumi.get(self, "sign_and_serve")
+    @pulumi.getter(name="defaultLoadObject")
+    def default_load_object(self) -> Optional[pulumi.Input['GtmDatacenterDefaultLoadObjectArgs']]:
+        return pulumi.get(self, "default_load_object")
 
-    @sign_and_serve.setter
-    def sign_and_serve(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "sign_and_serve", value)
+    @default_load_object.setter
+    def default_load_object(self, value: Optional[pulumi.Input['GtmDatacenterDefaultLoadObjectArgs']]):
+        pulumi.set(self, "default_load_object", value)
 
     @property
-    @pulumi.getter(name="signAndServeAlgorithm")
-    def sign_and_serve_algorithm(self) -> Optional[pulumi.Input[str]]:
-        """
-        The algorithm used by Sign and Serve.
-        """
-        return pulumi.get(self, "sign_and_serve_algorithm")
+    @pulumi.getter
+    def latitude(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "latitude")
 
-    @sign_and_serve_algorithm.setter
-    def sign_and_serve_algorithm(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "sign_and_serve_algorithm", value)
+    @latitude.setter
+    def latitude(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "latitude", value)
 
     @property
     @pulumi.getter
-    def target(self) -> Optional[pulumi.Input[str]]:
-        """
-        The name of the zone whose configuration this zone will copy.
-        """
-        return pulumi.get(self, "target")
+    def longitude(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "longitude")
 
-    @target.setter
-    def target(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "target", value)
+    @longitude.setter
+    def longitude(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "longitude", value)
 
     @property
-    @pulumi.getter(name="tsigKey")
-    def tsig_key(self) -> Optional[pulumi.Input['DnsZoneTsigKeyArgs']]:
-        """
-        The TSIG Key used in secure zone transfers. If used, requires these arguments:
-        """
-        return pulumi.get(self, "tsig_key")
+    @pulumi.getter
+    def nickname(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "nickname")
+
+    @nickname.setter
+    def nickname(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "nickname", value)
+
+    @property
+    @pulumi.getter(name="stateOrProvince")
+    def state_or_province(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "state_or_province")
+
+    @state_or_province.setter
+    def state_or_province(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "state_or_province", value)
+
+    @property
+    @pulumi.getter(name="waitOnComplete")
+    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "wait_on_complete")
 
-    @tsig_key.setter
-    def tsig_key(self, value: Optional[pulumi.Input['DnsZoneTsigKeyArgs']]):
-        pulumi.set(self, "tsig_key", value)
+    @wait_on_complete.setter
+    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "wait_on_complete", value)
 
 
 @pulumi.input_type
-class _DnsZoneState:
+class _GtmDatacenterState:
     def __init__(__self__, *,
-                 activation_state: Optional[pulumi.Input[str]] = None,
-                 alias_count: Optional[pulumi.Input[int]] = None,
-                 comment: Optional[pulumi.Input[str]] = None,
-                 contract: Optional[pulumi.Input[str]] = None,
-                 end_customer_id: Optional[pulumi.Input[str]] = None,
-                 group: Optional[pulumi.Input[str]] = None,
-                 masters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 sign_and_serve: Optional[pulumi.Input[bool]] = None,
-                 sign_and_serve_algorithm: Optional[pulumi.Input[str]] = None,
-                 target: Optional[pulumi.Input[str]] = None,
-                 tsig_key: Optional[pulumi.Input['DnsZoneTsigKeyArgs']] = None,
-                 type: Optional[pulumi.Input[str]] = None,
-                 version_id: Optional[pulumi.Input[str]] = None,
-                 zone: Optional[pulumi.Input[str]] = None):
+                 city: Optional[pulumi.Input[str]] = None,
+                 clone_of: Optional[pulumi.Input[int]] = None,
+                 cloud_server_host_header_override: Optional[pulumi.Input[bool]] = None,
+                 cloud_server_targeting: Optional[pulumi.Input[bool]] = None,
+                 continent: Optional[pulumi.Input[str]] = None,
+                 country: Optional[pulumi.Input[str]] = None,
+                 datacenter_id: Optional[pulumi.Input[int]] = None,
+                 default_load_object: Optional[pulumi.Input['GtmDatacenterDefaultLoadObjectArgs']] = None,
+                 domain: Optional[pulumi.Input[str]] = None,
+                 latitude: Optional[pulumi.Input[float]] = None,
+                 longitude: Optional[pulumi.Input[float]] = None,
+                 nickname: Optional[pulumi.Input[str]] = None,
+                 ping_interval: Optional[pulumi.Input[int]] = None,
+                 ping_packet_size: Optional[pulumi.Input[int]] = None,
+                 score_penalty: Optional[pulumi.Input[int]] = None,
+                 servermonitor_liveness_count: Optional[pulumi.Input[int]] = None,
+                 servermonitor_load_count: Optional[pulumi.Input[int]] = None,
+                 servermonitor_pool: Optional[pulumi.Input[str]] = None,
+                 state_or_province: Optional[pulumi.Input[str]] = None,
+                 virtual: Optional[pulumi.Input[bool]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None):
         """
-        Input properties used for looking up and filtering DnsZone resources.
-        :param pulumi.Input[str] comment: A descriptive comment.
-        :param pulumi.Input[str] contract: The contract ID.
-        :param pulumi.Input[str] end_customer_id: A free form identifier for the zone.
-        :param pulumi.Input[str] group: The currently selected group ID.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] masters: The names or IP addresses of the nameservers that the zone data should be retrieved from.
-        :param pulumi.Input[bool] sign_and_serve: Whether DNSSEC Sign and Serve is enabled.
-        :param pulumi.Input[str] sign_and_serve_algorithm: The algorithm used by Sign and Serve.
-        :param pulumi.Input[str] target: The name of the zone whose configuration this zone will copy.
-        :param pulumi.Input['DnsZoneTsigKeyArgs'] tsig_key: The TSIG Key used in secure zone transfers. If used, requires these arguments:
-        :param pulumi.Input[str] type: Whether the zone is `primary`, `secondary`, or `alias`.
-        :param pulumi.Input[str] zone: The domain zone, encapsulating any nested subdomains.
+        Input properties used for looking up and filtering GtmDatacenter resources.
         """
-        if activation_state is not None:
-            pulumi.set(__self__, "activation_state", activation_state)
-        if alias_count is not None:
-            pulumi.set(__self__, "alias_count", alias_count)
-        if comment is not None:
-            pulumi.set(__self__, "comment", comment)
-        if contract is not None:
-            pulumi.set(__self__, "contract", contract)
-        if end_customer_id is not None:
-            pulumi.set(__self__, "end_customer_id", end_customer_id)
-        if group is not None:
-            pulumi.set(__self__, "group", group)
-        if masters is not None:
-            pulumi.set(__self__, "masters", masters)
-        if sign_and_serve is not None:
-            pulumi.set(__self__, "sign_and_serve", sign_and_serve)
-        if sign_and_serve_algorithm is not None:
-            pulumi.set(__self__, "sign_and_serve_algorithm", sign_and_serve_algorithm)
-        if target is not None:
-            pulumi.set(__self__, "target", target)
-        if tsig_key is not None:
-            pulumi.set(__self__, "tsig_key", tsig_key)
-        if type is not None:
-            pulumi.set(__self__, "type", type)
-        if version_id is not None:
-            pulumi.set(__self__, "version_id", version_id)
-        if zone is not None:
-            pulumi.set(__self__, "zone", zone)
-
-    @property
-    @pulumi.getter(name="activationState")
-    def activation_state(self) -> Optional[pulumi.Input[str]]:
-        return pulumi.get(self, "activation_state")
-
-    @activation_state.setter
-    def activation_state(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "activation_state", value)
-
-    @property
-    @pulumi.getter(name="aliasCount")
-    def alias_count(self) -> Optional[pulumi.Input[int]]:
-        return pulumi.get(self, "alias_count")
-
-    @alias_count.setter
-    def alias_count(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "alias_count", value)
+        if city is not None:
+            pulumi.set(__self__, "city", city)
+        if clone_of is not None:
+            pulumi.set(__self__, "clone_of", clone_of)
+        if cloud_server_host_header_override is not None:
+            pulumi.set(__self__, "cloud_server_host_header_override", cloud_server_host_header_override)
+        if cloud_server_targeting is not None:
+            pulumi.set(__self__, "cloud_server_targeting", cloud_server_targeting)
+        if continent is not None:
+            pulumi.set(__self__, "continent", continent)
+        if country is not None:
+            pulumi.set(__self__, "country", country)
+        if datacenter_id is not None:
+            pulumi.set(__self__, "datacenter_id", datacenter_id)
+        if default_load_object is not None:
+            pulumi.set(__self__, "default_load_object", default_load_object)
+        if domain is not None:
+            pulumi.set(__self__, "domain", domain)
+        if latitude is not None:
+            pulumi.set(__self__, "latitude", latitude)
+        if longitude is not None:
+            pulumi.set(__self__, "longitude", longitude)
+        if nickname is not None:
+            pulumi.set(__self__, "nickname", nickname)
+        if ping_interval is not None:
+            pulumi.set(__self__, "ping_interval", ping_interval)
+        if ping_packet_size is not None:
+            pulumi.set(__self__, "ping_packet_size", ping_packet_size)
+        if score_penalty is not None:
+            pulumi.set(__self__, "score_penalty", score_penalty)
+        if servermonitor_liveness_count is not None:
+            pulumi.set(__self__, "servermonitor_liveness_count", servermonitor_liveness_count)
+        if servermonitor_load_count is not None:
+            pulumi.set(__self__, "servermonitor_load_count", servermonitor_load_count)
+        if servermonitor_pool is not None:
+            pulumi.set(__self__, "servermonitor_pool", servermonitor_pool)
+        if state_or_province is not None:
+            pulumi.set(__self__, "state_or_province", state_or_province)
+        if virtual is not None:
+            pulumi.set(__self__, "virtual", virtual)
+        if wait_on_complete is not None:
+            pulumi.set(__self__, "wait_on_complete", wait_on_complete)
 
     @property
     @pulumi.getter
-    def comment(self) -> Optional[pulumi.Input[str]]:
-        """
-        A descriptive comment.
-        """
-        return pulumi.get(self, "comment")
+    def city(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "city")
 
-    @comment.setter
-    def comment(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "comment", value)
+    @city.setter
+    def city(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "city", value)
 
     @property
-    @pulumi.getter
-    def contract(self) -> Optional[pulumi.Input[str]]:
-        """
-        The contract ID.
-        """
-        return pulumi.get(self, "contract")
+    @pulumi.getter(name="cloneOf")
+    def clone_of(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "clone_of")
 
-    @contract.setter
-    def contract(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "contract", value)
+    @clone_of.setter
+    def clone_of(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "clone_of", value)
 
     @property
-    @pulumi.getter(name="endCustomerId")
-    def end_customer_id(self) -> Optional[pulumi.Input[str]]:
-        """
-        A free form identifier for the zone.
-        """
-        return pulumi.get(self, "end_customer_id")
+    @pulumi.getter(name="cloudServerHostHeaderOverride")
+    def cloud_server_host_header_override(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "cloud_server_host_header_override")
+
+    @cloud_server_host_header_override.setter
+    def cloud_server_host_header_override(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "cloud_server_host_header_override", value)
 
-    @end_customer_id.setter
-    def end_customer_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "end_customer_id", value)
+    @property
+    @pulumi.getter(name="cloudServerTargeting")
+    def cloud_server_targeting(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "cloud_server_targeting")
+
+    @cloud_server_targeting.setter
+    def cloud_server_targeting(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "cloud_server_targeting", value)
 
     @property
     @pulumi.getter
-    def group(self) -> Optional[pulumi.Input[str]]:
-        """
-        The currently selected group ID.
-        """
-        return pulumi.get(self, "group")
+    def continent(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "continent")
 
-    @group.setter
-    def group(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "group", value)
+    @continent.setter
+    def continent(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "continent", value)
 
     @property
     @pulumi.getter
-    def masters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
-        """
-        The names or IP addresses of the nameservers that the zone data should be retrieved from.
-        """
-        return pulumi.get(self, "masters")
+    def country(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "country")
 
-    @masters.setter
-    def masters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
-        pulumi.set(self, "masters", value)
+    @country.setter
+    def country(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "country", value)
 
     @property
-    @pulumi.getter(name="signAndServe")
-    def sign_and_serve(self) -> Optional[pulumi.Input[bool]]:
-        """
-        Whether DNSSEC Sign and Serve is enabled.
-        """
-        return pulumi.get(self, "sign_and_serve")
+    @pulumi.getter(name="datacenterId")
+    def datacenter_id(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "datacenter_id")
 
-    @sign_and_serve.setter
-    def sign_and_serve(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "sign_and_serve", value)
+    @datacenter_id.setter
+    def datacenter_id(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "datacenter_id", value)
 
     @property
-    @pulumi.getter(name="signAndServeAlgorithm")
-    def sign_and_serve_algorithm(self) -> Optional[pulumi.Input[str]]:
-        """
-        The algorithm used by Sign and Serve.
-        """
-        return pulumi.get(self, "sign_and_serve_algorithm")
+    @pulumi.getter(name="defaultLoadObject")
+    def default_load_object(self) -> Optional[pulumi.Input['GtmDatacenterDefaultLoadObjectArgs']]:
+        return pulumi.get(self, "default_load_object")
 
-    @sign_and_serve_algorithm.setter
-    def sign_and_serve_algorithm(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "sign_and_serve_algorithm", value)
+    @default_load_object.setter
+    def default_load_object(self, value: Optional[pulumi.Input['GtmDatacenterDefaultLoadObjectArgs']]):
+        pulumi.set(self, "default_load_object", value)
 
     @property
     @pulumi.getter
-    def target(self) -> Optional[pulumi.Input[str]]:
-        """
-        The name of the zone whose configuration this zone will copy.
-        """
-        return pulumi.get(self, "target")
+    def domain(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "domain")
 
-    @target.setter
-    def target(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "target", value)
+    @domain.setter
+    def domain(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "domain", value)
 
     @property
-    @pulumi.getter(name="tsigKey")
-    def tsig_key(self) -> Optional[pulumi.Input['DnsZoneTsigKeyArgs']]:
-        """
-        The TSIG Key used in secure zone transfers. If used, requires these arguments:
-        """
-        return pulumi.get(self, "tsig_key")
+    @pulumi.getter
+    def latitude(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "latitude")
 
-    @tsig_key.setter
-    def tsig_key(self, value: Optional[pulumi.Input['DnsZoneTsigKeyArgs']]):
-        pulumi.set(self, "tsig_key", value)
+    @latitude.setter
+    def latitude(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "latitude", value)
 
     @property
     @pulumi.getter
-    def type(self) -> Optional[pulumi.Input[str]]:
-        """
-        Whether the zone is `primary`, `secondary`, or `alias`.
-        """
-        return pulumi.get(self, "type")
+    def longitude(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "longitude")
 
-    @type.setter
-    def type(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "type", value)
+    @longitude.setter
+    def longitude(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "longitude", value)
 
     @property
-    @pulumi.getter(name="versionId")
-    def version_id(self) -> Optional[pulumi.Input[str]]:
-        return pulumi.get(self, "version_id")
+    @pulumi.getter
+    def nickname(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "nickname")
 
-    @version_id.setter
-    def version_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "version_id", value)
+    @nickname.setter
+    def nickname(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "nickname", value)
+
+    @property
+    @pulumi.getter(name="pingInterval")
+    def ping_interval(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "ping_interval")
+
+    @ping_interval.setter
+    def ping_interval(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "ping_interval", value)
+
+    @property
+    @pulumi.getter(name="pingPacketSize")
+    def ping_packet_size(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "ping_packet_size")
+
+    @ping_packet_size.setter
+    def ping_packet_size(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "ping_packet_size", value)
+
+    @property
+    @pulumi.getter(name="scorePenalty")
+    def score_penalty(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "score_penalty")
+
+    @score_penalty.setter
+    def score_penalty(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "score_penalty", value)
+
+    @property
+    @pulumi.getter(name="servermonitorLivenessCount")
+    def servermonitor_liveness_count(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "servermonitor_liveness_count")
+
+    @servermonitor_liveness_count.setter
+    def servermonitor_liveness_count(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "servermonitor_liveness_count", value)
+
+    @property
+    @pulumi.getter(name="servermonitorLoadCount")
+    def servermonitor_load_count(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "servermonitor_load_count")
+
+    @servermonitor_load_count.setter
+    def servermonitor_load_count(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "servermonitor_load_count", value)
+
+    @property
+    @pulumi.getter(name="servermonitorPool")
+    def servermonitor_pool(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "servermonitor_pool")
+
+    @servermonitor_pool.setter
+    def servermonitor_pool(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "servermonitor_pool", value)
+
+    @property
+    @pulumi.getter(name="stateOrProvince")
+    def state_or_province(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "state_or_province")
+
+    @state_or_province.setter
+    def state_or_province(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "state_or_province", value)
 
     @property
     @pulumi.getter
-    def zone(self) -> Optional[pulumi.Input[str]]:
-        """
-        The domain zone, encapsulating any nested subdomains.
-        """
-        return pulumi.get(self, "zone")
+    def virtual(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "virtual")
+
+    @virtual.setter
+    def virtual(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "virtual", value)
+
+    @property
+    @pulumi.getter(name="waitOnComplete")
+    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "wait_on_complete")
 
-    @zone.setter
-    def zone(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "zone", value)
+    @wait_on_complete.setter
+    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "wait_on_complete", value)
 
 
-class DnsZone(pulumi.CustomResource):
+class GtmDatacenter(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 comment: Optional[pulumi.Input[str]] = None,
-                 contract: Optional[pulumi.Input[str]] = None,
-                 end_customer_id: Optional[pulumi.Input[str]] = None,
-                 group: Optional[pulumi.Input[str]] = None,
-                 masters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 sign_and_serve: Optional[pulumi.Input[bool]] = None,
-                 sign_and_serve_algorithm: Optional[pulumi.Input[str]] = None,
-                 target: Optional[pulumi.Input[str]] = None,
-                 tsig_key: Optional[pulumi.Input[pulumi.InputType['DnsZoneTsigKeyArgs']]] = None,
-                 type: Optional[pulumi.Input[str]] = None,
-                 zone: Optional[pulumi.Input[str]] = None,
+                 city: Optional[pulumi.Input[str]] = None,
+                 clone_of: Optional[pulumi.Input[int]] = None,
+                 cloud_server_host_header_override: Optional[pulumi.Input[bool]] = None,
+                 cloud_server_targeting: Optional[pulumi.Input[bool]] = None,
+                 continent: Optional[pulumi.Input[str]] = None,
+                 country: Optional[pulumi.Input[str]] = None,
+                 default_load_object: Optional[pulumi.Input[pulumi.InputType['GtmDatacenterDefaultLoadObjectArgs']]] = None,
+                 domain: Optional[pulumi.Input[str]] = None,
+                 latitude: Optional[pulumi.Input[float]] = None,
+                 longitude: Optional[pulumi.Input[float]] = None,
+                 nickname: Optional[pulumi.Input[str]] = None,
+                 state_or_province: Optional[pulumi.Input[str]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
                  __props__=None):
         """
-        Create a DnsZone resource with the given unique name, props, and options.
+        Create a GtmDatacenter resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] comment: A descriptive comment.
-        :param pulumi.Input[str] contract: The contract ID.
-        :param pulumi.Input[str] end_customer_id: A free form identifier for the zone.
-        :param pulumi.Input[str] group: The currently selected group ID.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] masters: The names or IP addresses of the nameservers that the zone data should be retrieved from.
-        :param pulumi.Input[bool] sign_and_serve: Whether DNSSEC Sign and Serve is enabled.
-        :param pulumi.Input[str] sign_and_serve_algorithm: The algorithm used by Sign and Serve.
-        :param pulumi.Input[str] target: The name of the zone whose configuration this zone will copy.
-        :param pulumi.Input[pulumi.InputType['DnsZoneTsigKeyArgs']] tsig_key: The TSIG Key used in secure zone transfers. If used, requires these arguments:
-        :param pulumi.Input[str] type: Whether the zone is `primary`, `secondary`, or `alias`.
-        :param pulumi.Input[str] zone: The domain zone, encapsulating any nested subdomains.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: DnsZoneArgs,
+                 args: GtmDatacenterArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        Create a DnsZone resource with the given unique name, props, and options.
+        Create a GtmDatacenter resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param DnsZoneArgs args: The arguments to use to populate this resource's properties.
+        :param GtmDatacenterArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(DnsZoneArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(GtmDatacenterArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 comment: Optional[pulumi.Input[str]] = None,
-                 contract: Optional[pulumi.Input[str]] = None,
-                 end_customer_id: Optional[pulumi.Input[str]] = None,
-                 group: Optional[pulumi.Input[str]] = None,
-                 masters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 sign_and_serve: Optional[pulumi.Input[bool]] = None,
-                 sign_and_serve_algorithm: Optional[pulumi.Input[str]] = None,
-                 target: Optional[pulumi.Input[str]] = None,
-                 tsig_key: Optional[pulumi.Input[pulumi.InputType['DnsZoneTsigKeyArgs']]] = None,
-                 type: Optional[pulumi.Input[str]] = None,
-                 zone: Optional[pulumi.Input[str]] = None,
+                 city: Optional[pulumi.Input[str]] = None,
+                 clone_of: Optional[pulumi.Input[int]] = None,
+                 cloud_server_host_header_override: Optional[pulumi.Input[bool]] = None,
+                 cloud_server_targeting: Optional[pulumi.Input[bool]] = None,
+                 continent: Optional[pulumi.Input[str]] = None,
+                 country: Optional[pulumi.Input[str]] = None,
+                 default_load_object: Optional[pulumi.Input[pulumi.InputType['GtmDatacenterDefaultLoadObjectArgs']]] = None,
+                 domain: Optional[pulumi.Input[str]] = None,
+                 latitude: Optional[pulumi.Input[float]] = None,
+                 longitude: Optional[pulumi.Input[float]] = None,
+                 nickname: Optional[pulumi.Input[str]] = None,
+                 state_or_province: Optional[pulumi.Input[str]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = DnsZoneArgs.__new__(DnsZoneArgs)
+            __props__ = GtmDatacenterArgs.__new__(GtmDatacenterArgs)
 
-            __props__.__dict__["comment"] = comment
-            if contract is None and not opts.urn:
-                raise TypeError("Missing required property 'contract'")
-            __props__.__dict__["contract"] = contract
-            __props__.__dict__["end_customer_id"] = end_customer_id
-            __props__.__dict__["group"] = group
-            __props__.__dict__["masters"] = masters
-            __props__.__dict__["sign_and_serve"] = sign_and_serve
-            __props__.__dict__["sign_and_serve_algorithm"] = sign_and_serve_algorithm
-            __props__.__dict__["target"] = target
-            __props__.__dict__["tsig_key"] = tsig_key
-            if type is None and not opts.urn:
-                raise TypeError("Missing required property 'type'")
-            __props__.__dict__["type"] = type
-            if zone is None and not opts.urn:
-                raise TypeError("Missing required property 'zone'")
-            __props__.__dict__["zone"] = zone
-            __props__.__dict__["activation_state"] = None
-            __props__.__dict__["alias_count"] = None
-            __props__.__dict__["version_id"] = None
-        alias_opts = pulumi.ResourceOptions(aliases=[pulumi.Alias(type_="akamai:edgedns/dnsZone:DnsZone")])
+            __props__.__dict__["city"] = city
+            __props__.__dict__["clone_of"] = clone_of
+            __props__.__dict__["cloud_server_host_header_override"] = cloud_server_host_header_override
+            __props__.__dict__["cloud_server_targeting"] = cloud_server_targeting
+            __props__.__dict__["continent"] = continent
+            __props__.__dict__["country"] = country
+            __props__.__dict__["default_load_object"] = default_load_object
+            if domain is None and not opts.urn:
+                raise TypeError("Missing required property 'domain'")
+            __props__.__dict__["domain"] = domain
+            __props__.__dict__["latitude"] = latitude
+            __props__.__dict__["longitude"] = longitude
+            __props__.__dict__["nickname"] = nickname
+            __props__.__dict__["state_or_province"] = state_or_province
+            __props__.__dict__["wait_on_complete"] = wait_on_complete
+            __props__.__dict__["datacenter_id"] = None
+            __props__.__dict__["ping_interval"] = None
+            __props__.__dict__["ping_packet_size"] = None
+            __props__.__dict__["score_penalty"] = None
+            __props__.__dict__["servermonitor_liveness_count"] = None
+            __props__.__dict__["servermonitor_load_count"] = None
+            __props__.__dict__["servermonitor_pool"] = None
+            __props__.__dict__["virtual"] = None
+        alias_opts = pulumi.ResourceOptions(aliases=[pulumi.Alias(type_="akamai:trafficmanagement/gtmDatacenter:GtmDatacenter")])
         opts = pulumi.ResourceOptions.merge(opts, alias_opts)
-        super(DnsZone, __self__).__init__(
-            'akamai:index/dnsZone:DnsZone',
+        super(GtmDatacenter, __self__).__init__(
+            'akamai:index/gtmDatacenter:GtmDatacenter',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
-            activation_state: Optional[pulumi.Input[str]] = None,
-            alias_count: Optional[pulumi.Input[int]] = None,
-            comment: Optional[pulumi.Input[str]] = None,
-            contract: Optional[pulumi.Input[str]] = None,
-            end_customer_id: Optional[pulumi.Input[str]] = None,
-            group: Optional[pulumi.Input[str]] = None,
-            masters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-            sign_and_serve: Optional[pulumi.Input[bool]] = None,
-            sign_and_serve_algorithm: Optional[pulumi.Input[str]] = None,
-            target: Optional[pulumi.Input[str]] = None,
-            tsig_key: Optional[pulumi.Input[pulumi.InputType['DnsZoneTsigKeyArgs']]] = None,
-            type: Optional[pulumi.Input[str]] = None,
-            version_id: Optional[pulumi.Input[str]] = None,
-            zone: Optional[pulumi.Input[str]] = None) -> 'DnsZone':
+            city: Optional[pulumi.Input[str]] = None,
+            clone_of: Optional[pulumi.Input[int]] = None,
+            cloud_server_host_header_override: Optional[pulumi.Input[bool]] = None,
+            cloud_server_targeting: Optional[pulumi.Input[bool]] = None,
+            continent: Optional[pulumi.Input[str]] = None,
+            country: Optional[pulumi.Input[str]] = None,
+            datacenter_id: Optional[pulumi.Input[int]] = None,
+            default_load_object: Optional[pulumi.Input[pulumi.InputType['GtmDatacenterDefaultLoadObjectArgs']]] = None,
+            domain: Optional[pulumi.Input[str]] = None,
+            latitude: Optional[pulumi.Input[float]] = None,
+            longitude: Optional[pulumi.Input[float]] = None,
+            nickname: Optional[pulumi.Input[str]] = None,
+            ping_interval: Optional[pulumi.Input[int]] = None,
+            ping_packet_size: Optional[pulumi.Input[int]] = None,
+            score_penalty: Optional[pulumi.Input[int]] = None,
+            servermonitor_liveness_count: Optional[pulumi.Input[int]] = None,
+            servermonitor_load_count: Optional[pulumi.Input[int]] = None,
+            servermonitor_pool: Optional[pulumi.Input[str]] = None,
+            state_or_province: Optional[pulumi.Input[str]] = None,
+            virtual: Optional[pulumi.Input[bool]] = None,
+            wait_on_complete: Optional[pulumi.Input[bool]] = None) -> 'GtmDatacenter':
         """
-        Get an existing DnsZone resource's state with the given name, id, and optional extra
+        Get an existing GtmDatacenter resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] comment: A descriptive comment.
-        :param pulumi.Input[str] contract: The contract ID.
-        :param pulumi.Input[str] end_customer_id: A free form identifier for the zone.
-        :param pulumi.Input[str] group: The currently selected group ID.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] masters: The names or IP addresses of the nameservers that the zone data should be retrieved from.
-        :param pulumi.Input[bool] sign_and_serve: Whether DNSSEC Sign and Serve is enabled.
-        :param pulumi.Input[str] sign_and_serve_algorithm: The algorithm used by Sign and Serve.
-        :param pulumi.Input[str] target: The name of the zone whose configuration this zone will copy.
-        :param pulumi.Input[pulumi.InputType['DnsZoneTsigKeyArgs']] tsig_key: The TSIG Key used in secure zone transfers. If used, requires these arguments:
-        :param pulumi.Input[str] type: Whether the zone is `primary`, `secondary`, or `alias`.
-        :param pulumi.Input[str] zone: The domain zone, encapsulating any nested subdomains.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _DnsZoneState.__new__(_DnsZoneState)
+        __props__ = _GtmDatacenterState.__new__(_GtmDatacenterState)
+
+        __props__.__dict__["city"] = city
+        __props__.__dict__["clone_of"] = clone_of
+        __props__.__dict__["cloud_server_host_header_override"] = cloud_server_host_header_override
+        __props__.__dict__["cloud_server_targeting"] = cloud_server_targeting
+        __props__.__dict__["continent"] = continent
+        __props__.__dict__["country"] = country
+        __props__.__dict__["datacenter_id"] = datacenter_id
+        __props__.__dict__["default_load_object"] = default_load_object
+        __props__.__dict__["domain"] = domain
+        __props__.__dict__["latitude"] = latitude
+        __props__.__dict__["longitude"] = longitude
+        __props__.__dict__["nickname"] = nickname
+        __props__.__dict__["ping_interval"] = ping_interval
+        __props__.__dict__["ping_packet_size"] = ping_packet_size
+        __props__.__dict__["score_penalty"] = score_penalty
+        __props__.__dict__["servermonitor_liveness_count"] = servermonitor_liveness_count
+        __props__.__dict__["servermonitor_load_count"] = servermonitor_load_count
+        __props__.__dict__["servermonitor_pool"] = servermonitor_pool
+        __props__.__dict__["state_or_province"] = state_or_province
+        __props__.__dict__["virtual"] = virtual
+        __props__.__dict__["wait_on_complete"] = wait_on_complete
+        return GtmDatacenter(resource_name, opts=opts, __props__=__props__)
 
-        __props__.__dict__["activation_state"] = activation_state
-        __props__.__dict__["alias_count"] = alias_count
-        __props__.__dict__["comment"] = comment
-        __props__.__dict__["contract"] = contract
-        __props__.__dict__["end_customer_id"] = end_customer_id
-        __props__.__dict__["group"] = group
-        __props__.__dict__["masters"] = masters
-        __props__.__dict__["sign_and_serve"] = sign_and_serve
-        __props__.__dict__["sign_and_serve_algorithm"] = sign_and_serve_algorithm
-        __props__.__dict__["target"] = target
-        __props__.__dict__["tsig_key"] = tsig_key
-        __props__.__dict__["type"] = type
-        __props__.__dict__["version_id"] = version_id
-        __props__.__dict__["zone"] = zone
-        return DnsZone(resource_name, opts=opts, __props__=__props__)
+    @property
+    @pulumi.getter
+    def city(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "city")
 
     @property
-    @pulumi.getter(name="activationState")
-    def activation_state(self) -> pulumi.Output[str]:
-        return pulumi.get(self, "activation_state")
+    @pulumi.getter(name="cloneOf")
+    def clone_of(self) -> pulumi.Output[Optional[int]]:
+        return pulumi.get(self, "clone_of")
 
     @property
-    @pulumi.getter(name="aliasCount")
-    def alias_count(self) -> pulumi.Output[int]:
-        return pulumi.get(self, "alias_count")
+    @pulumi.getter(name="cloudServerHostHeaderOverride")
+    def cloud_server_host_header_override(self) -> pulumi.Output[Optional[bool]]:
+        return pulumi.get(self, "cloud_server_host_header_override")
+
+    @property
+    @pulumi.getter(name="cloudServerTargeting")
+    def cloud_server_targeting(self) -> pulumi.Output[Optional[bool]]:
+        return pulumi.get(self, "cloud_server_targeting")
 
     @property
     @pulumi.getter
-    def comment(self) -> pulumi.Output[Optional[str]]:
-        """
-        A descriptive comment.
-        """
-        return pulumi.get(self, "comment")
+    def continent(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "continent")
 
     @property
     @pulumi.getter
-    def contract(self) -> pulumi.Output[str]:
-        """
-        The contract ID.
-        """
-        return pulumi.get(self, "contract")
+    def country(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "country")
 
     @property
-    @pulumi.getter(name="endCustomerId")
-    def end_customer_id(self) -> pulumi.Output[Optional[str]]:
-        """
-        A free form identifier for the zone.
-        """
-        return pulumi.get(self, "end_customer_id")
+    @pulumi.getter(name="datacenterId")
+    def datacenter_id(self) -> pulumi.Output[int]:
+        return pulumi.get(self, "datacenter_id")
 
     @property
-    @pulumi.getter
-    def group(self) -> pulumi.Output[Optional[str]]:
-        """
-        The currently selected group ID.
-        """
-        return pulumi.get(self, "group")
+    @pulumi.getter(name="defaultLoadObject")
+    def default_load_object(self) -> pulumi.Output[Optional['outputs.GtmDatacenterDefaultLoadObject']]:
+        return pulumi.get(self, "default_load_object")
 
     @property
     @pulumi.getter
-    def masters(self) -> pulumi.Output[Optional[Sequence[str]]]:
-        """
-        The names or IP addresses of the nameservers that the zone data should be retrieved from.
-        """
-        return pulumi.get(self, "masters")
+    def domain(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "domain")
 
     @property
-    @pulumi.getter(name="signAndServe")
-    def sign_and_serve(self) -> pulumi.Output[Optional[bool]]:
-        """
-        Whether DNSSEC Sign and Serve is enabled.
-        """
-        return pulumi.get(self, "sign_and_serve")
+    @pulumi.getter
+    def latitude(self) -> pulumi.Output[Optional[float]]:
+        return pulumi.get(self, "latitude")
 
     @property
-    @pulumi.getter(name="signAndServeAlgorithm")
-    def sign_and_serve_algorithm(self) -> pulumi.Output[Optional[str]]:
-        """
-        The algorithm used by Sign and Serve.
-        """
-        return pulumi.get(self, "sign_and_serve_algorithm")
+    @pulumi.getter
+    def longitude(self) -> pulumi.Output[Optional[float]]:
+        return pulumi.get(self, "longitude")
 
     @property
     @pulumi.getter
-    def target(self) -> pulumi.Output[Optional[str]]:
-        """
-        The name of the zone whose configuration this zone will copy.
-        """
-        return pulumi.get(self, "target")
+    def nickname(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "nickname")
 
     @property
-    @pulumi.getter(name="tsigKey")
-    def tsig_key(self) -> pulumi.Output[Optional['outputs.DnsZoneTsigKey']]:
-        """
-        The TSIG Key used in secure zone transfers. If used, requires these arguments:
-        """
-        return pulumi.get(self, "tsig_key")
+    @pulumi.getter(name="pingInterval")
+    def ping_interval(self) -> pulumi.Output[int]:
+        return pulumi.get(self, "ping_interval")
 
     @property
-    @pulumi.getter
-    def type(self) -> pulumi.Output[str]:
-        """
-        Whether the zone is `primary`, `secondary`, or `alias`.
-        """
-        return pulumi.get(self, "type")
+    @pulumi.getter(name="pingPacketSize")
+    def ping_packet_size(self) -> pulumi.Output[int]:
+        return pulumi.get(self, "ping_packet_size")
+
+    @property
+    @pulumi.getter(name="scorePenalty")
+    def score_penalty(self) -> pulumi.Output[int]:
+        return pulumi.get(self, "score_penalty")
+
+    @property
+    @pulumi.getter(name="servermonitorLivenessCount")
+    def servermonitor_liveness_count(self) -> pulumi.Output[int]:
+        return pulumi.get(self, "servermonitor_liveness_count")
 
     @property
-    @pulumi.getter(name="versionId")
-    def version_id(self) -> pulumi.Output[str]:
-        return pulumi.get(self, "version_id")
+    @pulumi.getter(name="servermonitorLoadCount")
+    def servermonitor_load_count(self) -> pulumi.Output[int]:
+        return pulumi.get(self, "servermonitor_load_count")
+
+    @property
+    @pulumi.getter(name="servermonitorPool")
+    def servermonitor_pool(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "servermonitor_pool")
+
+    @property
+    @pulumi.getter(name="stateOrProvince")
+    def state_or_province(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "state_or_province")
 
     @property
     @pulumi.getter
-    def zone(self) -> pulumi.Output[str]:
-        """
-        The domain zone, encapsulating any nested subdomains.
-        """
-        return pulumi.get(self, "zone")
+    def virtual(self) -> pulumi.Output[bool]:
+        return pulumi.get(self, "virtual")
+
+    @property
+    @pulumi.getter(name="waitOnComplete")
+    def wait_on_complete(self) -> pulumi.Output[Optional[bool]]:
+        return pulumi.get(self, "wait_on_complete")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/edge_host_name.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/cps_third_party_enrollment.py`

 * *Files 26% similar despite different names*

```diff
@@ -4,732 +4,903 @@
 
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
+from . import outputs
+from ._inputs import *
 
-__all__ = ['EdgeHostNameArgs', 'EdgeHostName']
+__all__ = ['CpsThirdPartyEnrollmentArgs', 'CpsThirdPartyEnrollment']
 
 @pulumi.input_type
-class EdgeHostNameArgs:
+class CpsThirdPartyEnrollmentArgs:
     def __init__(__self__, *,
-                 edge_hostname: pulumi.Input[str],
-                 ip_behavior: pulumi.Input[str],
-                 certificate: Optional[pulumi.Input[int]] = None,
-                 contract: Optional[pulumi.Input[str]] = None,
-                 contract_id: Optional[pulumi.Input[str]] = None,
-                 group: Optional[pulumi.Input[str]] = None,
-                 group_id: Optional[pulumi.Input[str]] = None,
-                 product: Optional[pulumi.Input[str]] = None,
-                 product_id: Optional[pulumi.Input[str]] = None,
-                 status_update_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 use_cases: Optional[pulumi.Input[str]] = None):
-        """
-        The set of arguments for constructing a EdgeHostName resource.
-        :param pulumi.Input[str] edge_hostname: One or more edge hostnames. The number of edge hostnames must be less than or equal to the number of public hostnames.
-        :param pulumi.Input[str] ip_behavior: Which version of the IP protocol to use: `IPV4` for version 4 only, `IPV6_PERFORMANCE` for version 6 only, or `IPV6_COMPLIANCE` for both 4 and 6.
-        :param pulumi.Input[int] certificate: Required only when creating an Enhanced TLS edge hostname. This argument sets the certificate enrollment ID. Edge hostnames for Enhanced TLS end in `edgekey.net`. You can retrieve this ID from the [Certificate Provisioning Service CLI](https://github.com/akamai/cli-cps) .
-        :param pulumi.Input[str] contract: Replaced by `contract_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] contract_id: A contract's unique ID, including the `ctr_` prefix.
-        :param pulumi.Input[str] group: Replaced by `group_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] group_id: A group's unique ID, including the `grp_` prefix.
-        :param pulumi.Input[str] product: Replaced by `product_id`. Maintained for legacy purposes.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] status_update_emails: Email address that should receive updates on the IP behavior update request. Required for update operation.
-        :param pulumi.Input[str] use_cases: A JSON encoded list of use cases.
-        """
-        pulumi.set(__self__, "edge_hostname", edge_hostname)
-        pulumi.set(__self__, "ip_behavior", ip_behavior)
-        if certificate is not None:
-            pulumi.set(__self__, "certificate", certificate)
-        if contract is not None:
-            warnings.warn("""The setting \"contract\" has been deprecated.""", DeprecationWarning)
-            pulumi.log.warn("""contract is deprecated: The setting \"contract\" has been deprecated.""")
-        if contract is not None:
-            pulumi.set(__self__, "contract", contract)
-        if contract_id is not None:
-            pulumi.set(__self__, "contract_id", contract_id)
-        if group is not None:
-            warnings.warn("""The setting \"group\" has been deprecated.""", DeprecationWarning)
-            pulumi.log.warn("""group is deprecated: The setting \"group\" has been deprecated.""")
-        if group is not None:
-            pulumi.set(__self__, "group", group)
-        if group_id is not None:
-            pulumi.set(__self__, "group_id", group_id)
-        if product is not None:
-            warnings.warn("""The setting \"product\" has been deprecated.""", DeprecationWarning)
-            pulumi.log.warn("""product is deprecated: The setting \"product\" has been deprecated.""")
-        if product is not None:
-            pulumi.set(__self__, "product", product)
-        if product_id is not None:
-            pulumi.set(__self__, "product_id", product_id)
-        if status_update_emails is not None:
-            pulumi.set(__self__, "status_update_emails", status_update_emails)
-        if use_cases is not None:
-            pulumi.set(__self__, "use_cases", use_cases)
-
-    @property
-    @pulumi.getter(name="edgeHostname")
-    def edge_hostname(self) -> pulumi.Input[str]:
-        """
-        One or more edge hostnames. The number of edge hostnames must be less than or equal to the number of public hostnames.
-        """
-        return pulumi.get(self, "edge_hostname")
-
-    @edge_hostname.setter
-    def edge_hostname(self, value: pulumi.Input[str]):
-        pulumi.set(self, "edge_hostname", value)
-
-    @property
-    @pulumi.getter(name="ipBehavior")
-    def ip_behavior(self) -> pulumi.Input[str]:
-        """
-        Which version of the IP protocol to use: `IPV4` for version 4 only, `IPV6_PERFORMANCE` for version 6 only, or `IPV6_COMPLIANCE` for both 4 and 6.
-        """
-        return pulumi.get(self, "ip_behavior")
-
-    @ip_behavior.setter
-    def ip_behavior(self, value: pulumi.Input[str]):
-        pulumi.set(self, "ip_behavior", value)
+                 admin_contact: pulumi.Input['CpsThirdPartyEnrollmentAdminContactArgs'],
+                 common_name: pulumi.Input[str],
+                 contract_id: pulumi.Input[str],
+                 csr: pulumi.Input['CpsThirdPartyEnrollmentCsrArgs'],
+                 network_configuration: pulumi.Input['CpsThirdPartyEnrollmentNetworkConfigurationArgs'],
+                 organization: pulumi.Input['CpsThirdPartyEnrollmentOrganizationArgs'],
+                 secure_network: pulumi.Input[str],
+                 sni_only: pulumi.Input[bool],
+                 tech_contact: pulumi.Input['CpsThirdPartyEnrollmentTechContactArgs'],
+                 acknowledge_pre_verification_warnings: Optional[pulumi.Input[bool]] = None,
+                 allow_duplicate_common_name: Optional[pulumi.Input[bool]] = None,
+                 auto_approve_warnings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 certificate_chain_type: Optional[pulumi.Input[str]] = None,
+                 change_management: Optional[pulumi.Input[bool]] = None,
+                 exclude_sans: Optional[pulumi.Input[bool]] = None,
+                 sans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 signature_algorithm: Optional[pulumi.Input[str]] = None):
+        """
+        The set of arguments for constructing a CpsThirdPartyEnrollment resource.
+        :param pulumi.Input['CpsThirdPartyEnrollmentAdminContactArgs'] admin_contact: Contact information for the certificate administrator to use at organization
+        :param pulumi.Input[str] common_name: Common name used for enrollment
+        :param pulumi.Input[str] contract_id: Contract ID for which enrollment is retrieved
+        :param pulumi.Input['CpsThirdPartyEnrollmentCsrArgs'] csr: Data used for generation of Certificate Signing Request
+        :param pulumi.Input['CpsThirdPartyEnrollmentNetworkConfigurationArgs'] network_configuration: Settings containing network information and TLS metadata used by CPS
+        :param pulumi.Input['CpsThirdPartyEnrollmentOrganizationArgs'] organization: Organization information
+        :param pulumi.Input[str] secure_network: Type of TLS deployment network
+        :param pulumi.Input[bool] sni_only: Whether Server Name Indication is used for enrollment
+        :param pulumi.Input['CpsThirdPartyEnrollmentTechContactArgs'] tech_contact: Contact information for an administrator at Akamai
+        :param pulumi.Input[bool] acknowledge_pre_verification_warnings: Whether acknowledge warnings before certificate verification
+        :param pulumi.Input[bool] allow_duplicate_common_name: Allow to duplicate common name
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] auto_approve_warnings: List of warnings to be automatically approved
+        :param pulumi.Input[str] certificate_chain_type: Certificate trust chain type
+        :param pulumi.Input[bool] change_management: When set to false, the certificate will be deployed to both staging and production networks
+        :param pulumi.Input[bool] exclude_sans: When true, SANs are excluded from the CSR
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] sans: List of SANs
+        :param pulumi.Input[str] signature_algorithm: The SHA function. Changing this value may require running terraform destroy, terraform apply
+        """
+        pulumi.set(__self__, "admin_contact", admin_contact)
+        pulumi.set(__self__, "common_name", common_name)
+        pulumi.set(__self__, "contract_id", contract_id)
+        pulumi.set(__self__, "csr", csr)
+        pulumi.set(__self__, "network_configuration", network_configuration)
+        pulumi.set(__self__, "organization", organization)
+        pulumi.set(__self__, "secure_network", secure_network)
+        pulumi.set(__self__, "sni_only", sni_only)
+        pulumi.set(__self__, "tech_contact", tech_contact)
+        if acknowledge_pre_verification_warnings is not None:
+            pulumi.set(__self__, "acknowledge_pre_verification_warnings", acknowledge_pre_verification_warnings)
+        if allow_duplicate_common_name is not None:
+            pulumi.set(__self__, "allow_duplicate_common_name", allow_duplicate_common_name)
+        if auto_approve_warnings is not None:
+            pulumi.set(__self__, "auto_approve_warnings", auto_approve_warnings)
+        if certificate_chain_type is not None:
+            pulumi.set(__self__, "certificate_chain_type", certificate_chain_type)
+        if change_management is not None:
+            pulumi.set(__self__, "change_management", change_management)
+        if exclude_sans is not None:
+            pulumi.set(__self__, "exclude_sans", exclude_sans)
+        if sans is not None:
+            pulumi.set(__self__, "sans", sans)
+        if signature_algorithm is not None:
+            pulumi.set(__self__, "signature_algorithm", signature_algorithm)
+
+    @property
+    @pulumi.getter(name="adminContact")
+    def admin_contact(self) -> pulumi.Input['CpsThirdPartyEnrollmentAdminContactArgs']:
+        """
+        Contact information for the certificate administrator to use at organization
+        """
+        return pulumi.get(self, "admin_contact")
+
+    @admin_contact.setter
+    def admin_contact(self, value: pulumi.Input['CpsThirdPartyEnrollmentAdminContactArgs']):
+        pulumi.set(self, "admin_contact", value)
+
+    @property
+    @pulumi.getter(name="commonName")
+    def common_name(self) -> pulumi.Input[str]:
+        """
+        Common name used for enrollment
+        """
+        return pulumi.get(self, "common_name")
+
+    @common_name.setter
+    def common_name(self, value: pulumi.Input[str]):
+        pulumi.set(self, "common_name", value)
 
     @property
-    @pulumi.getter
-    def certificate(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="contractId")
+    def contract_id(self) -> pulumi.Input[str]:
         """
-        Required only when creating an Enhanced TLS edge hostname. This argument sets the certificate enrollment ID. Edge hostnames for Enhanced TLS end in `edgekey.net`. You can retrieve this ID from the [Certificate Provisioning Service CLI](https://github.com/akamai/cli-cps) .
+        Contract ID for which enrollment is retrieved
         """
-        return pulumi.get(self, "certificate")
+        return pulumi.get(self, "contract_id")
 
-    @certificate.setter
-    def certificate(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "certificate", value)
+    @contract_id.setter
+    def contract_id(self, value: pulumi.Input[str]):
+        pulumi.set(self, "contract_id", value)
 
     @property
     @pulumi.getter
-    def contract(self) -> Optional[pulumi.Input[str]]:
+    def csr(self) -> pulumi.Input['CpsThirdPartyEnrollmentCsrArgs']:
         """
-        Replaced by `contract_id`. Maintained for legacy purposes.
+        Data used for generation of Certificate Signing Request
         """
-        return pulumi.get(self, "contract")
+        return pulumi.get(self, "csr")
 
-    @contract.setter
-    def contract(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "contract", value)
+    @csr.setter
+    def csr(self, value: pulumi.Input['CpsThirdPartyEnrollmentCsrArgs']):
+        pulumi.set(self, "csr", value)
 
     @property
-    @pulumi.getter(name="contractId")
-    def contract_id(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="networkConfiguration")
+    def network_configuration(self) -> pulumi.Input['CpsThirdPartyEnrollmentNetworkConfigurationArgs']:
         """
-        A contract's unique ID, including the `ctr_` prefix.
+        Settings containing network information and TLS metadata used by CPS
         """
-        return pulumi.get(self, "contract_id")
+        return pulumi.get(self, "network_configuration")
 
-    @contract_id.setter
-    def contract_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "contract_id", value)
+    @network_configuration.setter
+    def network_configuration(self, value: pulumi.Input['CpsThirdPartyEnrollmentNetworkConfigurationArgs']):
+        pulumi.set(self, "network_configuration", value)
 
     @property
     @pulumi.getter
-    def group(self) -> Optional[pulumi.Input[str]]:
+    def organization(self) -> pulumi.Input['CpsThirdPartyEnrollmentOrganizationArgs']:
         """
-        Replaced by `group_id`. Maintained for legacy purposes.
+        Organization information
         """
-        return pulumi.get(self, "group")
+        return pulumi.get(self, "organization")
 
-    @group.setter
-    def group(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "group", value)
+    @organization.setter
+    def organization(self, value: pulumi.Input['CpsThirdPartyEnrollmentOrganizationArgs']):
+        pulumi.set(self, "organization", value)
 
     @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="secureNetwork")
+    def secure_network(self) -> pulumi.Input[str]:
         """
-        A group's unique ID, including the `grp_` prefix.
+        Type of TLS deployment network
         """
-        return pulumi.get(self, "group_id")
+        return pulumi.get(self, "secure_network")
 
-    @group_id.setter
-    def group_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "group_id", value)
+    @secure_network.setter
+    def secure_network(self, value: pulumi.Input[str]):
+        pulumi.set(self, "secure_network", value)
 
     @property
-    @pulumi.getter
-    def product(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="sniOnly")
+    def sni_only(self) -> pulumi.Input[bool]:
+        """
+        Whether Server Name Indication is used for enrollment
+        """
+        return pulumi.get(self, "sni_only")
+
+    @sni_only.setter
+    def sni_only(self, value: pulumi.Input[bool]):
+        pulumi.set(self, "sni_only", value)
+
+    @property
+    @pulumi.getter(name="techContact")
+    def tech_contact(self) -> pulumi.Input['CpsThirdPartyEnrollmentTechContactArgs']:
+        """
+        Contact information for an administrator at Akamai
+        """
+        return pulumi.get(self, "tech_contact")
+
+    @tech_contact.setter
+    def tech_contact(self, value: pulumi.Input['CpsThirdPartyEnrollmentTechContactArgs']):
+        pulumi.set(self, "tech_contact", value)
+
+    @property
+    @pulumi.getter(name="acknowledgePreVerificationWarnings")
+    def acknowledge_pre_verification_warnings(self) -> Optional[pulumi.Input[bool]]:
+        """
+        Whether acknowledge warnings before certificate verification
+        """
+        return pulumi.get(self, "acknowledge_pre_verification_warnings")
+
+    @acknowledge_pre_verification_warnings.setter
+    def acknowledge_pre_verification_warnings(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "acknowledge_pre_verification_warnings", value)
+
+    @property
+    @pulumi.getter(name="allowDuplicateCommonName")
+    def allow_duplicate_common_name(self) -> Optional[pulumi.Input[bool]]:
+        """
+        Allow to duplicate common name
+        """
+        return pulumi.get(self, "allow_duplicate_common_name")
+
+    @allow_duplicate_common_name.setter
+    def allow_duplicate_common_name(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "allow_duplicate_common_name", value)
+
+    @property
+    @pulumi.getter(name="autoApproveWarnings")
+    def auto_approve_warnings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
+        """
+        List of warnings to be automatically approved
+        """
+        return pulumi.get(self, "auto_approve_warnings")
+
+    @auto_approve_warnings.setter
+    def auto_approve_warnings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
+        pulumi.set(self, "auto_approve_warnings", value)
+
+    @property
+    @pulumi.getter(name="certificateChainType")
+    def certificate_chain_type(self) -> Optional[pulumi.Input[str]]:
         """
-        Replaced by `product_id`. Maintained for legacy purposes.
+        Certificate trust chain type
         """
-        return pulumi.get(self, "product")
+        return pulumi.get(self, "certificate_chain_type")
 
-    @product.setter
-    def product(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "product", value)
+    @certificate_chain_type.setter
+    def certificate_chain_type(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "certificate_chain_type", value)
 
     @property
-    @pulumi.getter(name="productId")
-    def product_id(self) -> Optional[pulumi.Input[str]]:
-        return pulumi.get(self, "product_id")
+    @pulumi.getter(name="changeManagement")
+    def change_management(self) -> Optional[pulumi.Input[bool]]:
+        """
+        When set to false, the certificate will be deployed to both staging and production networks
+        """
+        return pulumi.get(self, "change_management")
 
-    @product_id.setter
-    def product_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "product_id", value)
+    @change_management.setter
+    def change_management(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "change_management", value)
 
     @property
-    @pulumi.getter(name="statusUpdateEmails")
-    def status_update_emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
+    @pulumi.getter(name="excludeSans")
+    def exclude_sans(self) -> Optional[pulumi.Input[bool]]:
         """
-        Email address that should receive updates on the IP behavior update request. Required for update operation.
+        When true, SANs are excluded from the CSR
         """
-        return pulumi.get(self, "status_update_emails")
+        return pulumi.get(self, "exclude_sans")
 
-    @status_update_emails.setter
-    def status_update_emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
-        pulumi.set(self, "status_update_emails", value)
+    @exclude_sans.setter
+    def exclude_sans(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "exclude_sans", value)
 
     @property
-    @pulumi.getter(name="useCases")
-    def use_cases(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter
+    def sans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        A JSON encoded list of use cases.
+        List of SANs
         """
-        return pulumi.get(self, "use_cases")
+        return pulumi.get(self, "sans")
+
+    @sans.setter
+    def sans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
+        pulumi.set(self, "sans", value)
 
-    @use_cases.setter
-    def use_cases(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "use_cases", value)
+    @property
+    @pulumi.getter(name="signatureAlgorithm")
+    def signature_algorithm(self) -> Optional[pulumi.Input[str]]:
+        """
+        The SHA function. Changing this value may require running terraform destroy, terraform apply
+        """
+        return pulumi.get(self, "signature_algorithm")
+
+    @signature_algorithm.setter
+    def signature_algorithm(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "signature_algorithm", value)
 
 
 @pulumi.input_type
-class _EdgeHostNameState:
+class _CpsThirdPartyEnrollmentState:
     def __init__(__self__, *,
-                 certificate: Optional[pulumi.Input[int]] = None,
-                 contract: Optional[pulumi.Input[str]] = None,
+                 acknowledge_pre_verification_warnings: Optional[pulumi.Input[bool]] = None,
+                 admin_contact: Optional[pulumi.Input['CpsThirdPartyEnrollmentAdminContactArgs']] = None,
+                 allow_duplicate_common_name: Optional[pulumi.Input[bool]] = None,
+                 auto_approve_warnings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 certificate_chain_type: Optional[pulumi.Input[str]] = None,
+                 change_management: Optional[pulumi.Input[bool]] = None,
+                 common_name: Optional[pulumi.Input[str]] = None,
                  contract_id: Optional[pulumi.Input[str]] = None,
-                 edge_hostname: Optional[pulumi.Input[str]] = None,
-                 group: Optional[pulumi.Input[str]] = None,
-                 group_id: Optional[pulumi.Input[str]] = None,
-                 ip_behavior: Optional[pulumi.Input[str]] = None,
-                 product: Optional[pulumi.Input[str]] = None,
-                 product_id: Optional[pulumi.Input[str]] = None,
-                 status_update_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 use_cases: Optional[pulumi.Input[str]] = None):
-        """
-        Input properties used for looking up and filtering EdgeHostName resources.
-        :param pulumi.Input[int] certificate: Required only when creating an Enhanced TLS edge hostname. This argument sets the certificate enrollment ID. Edge hostnames for Enhanced TLS end in `edgekey.net`. You can retrieve this ID from the [Certificate Provisioning Service CLI](https://github.com/akamai/cli-cps) .
-        :param pulumi.Input[str] contract: Replaced by `contract_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] contract_id: A contract's unique ID, including the `ctr_` prefix.
-        :param pulumi.Input[str] edge_hostname: One or more edge hostnames. The number of edge hostnames must be less than or equal to the number of public hostnames.
-        :param pulumi.Input[str] group: Replaced by `group_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] group_id: A group's unique ID, including the `grp_` prefix.
-        :param pulumi.Input[str] ip_behavior: Which version of the IP protocol to use: `IPV4` for version 4 only, `IPV6_PERFORMANCE` for version 6 only, or `IPV6_COMPLIANCE` for both 4 and 6.
-        :param pulumi.Input[str] product: Replaced by `product_id`. Maintained for legacy purposes.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] status_update_emails: Email address that should receive updates on the IP behavior update request. Required for update operation.
-        :param pulumi.Input[str] use_cases: A JSON encoded list of use cases.
-        """
-        if certificate is not None:
-            pulumi.set(__self__, "certificate", certificate)
-        if contract is not None:
-            warnings.warn("""The setting \"contract\" has been deprecated.""", DeprecationWarning)
-            pulumi.log.warn("""contract is deprecated: The setting \"contract\" has been deprecated.""")
-        if contract is not None:
-            pulumi.set(__self__, "contract", contract)
+                 csr: Optional[pulumi.Input['CpsThirdPartyEnrollmentCsrArgs']] = None,
+                 exclude_sans: Optional[pulumi.Input[bool]] = None,
+                 network_configuration: Optional[pulumi.Input['CpsThirdPartyEnrollmentNetworkConfigurationArgs']] = None,
+                 organization: Optional[pulumi.Input['CpsThirdPartyEnrollmentOrganizationArgs']] = None,
+                 sans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 secure_network: Optional[pulumi.Input[str]] = None,
+                 signature_algorithm: Optional[pulumi.Input[str]] = None,
+                 sni_only: Optional[pulumi.Input[bool]] = None,
+                 tech_contact: Optional[pulumi.Input['CpsThirdPartyEnrollmentTechContactArgs']] = None):
+        """
+        Input properties used for looking up and filtering CpsThirdPartyEnrollment resources.
+        :param pulumi.Input[bool] acknowledge_pre_verification_warnings: Whether acknowledge warnings before certificate verification
+        :param pulumi.Input['CpsThirdPartyEnrollmentAdminContactArgs'] admin_contact: Contact information for the certificate administrator to use at organization
+        :param pulumi.Input[bool] allow_duplicate_common_name: Allow to duplicate common name
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] auto_approve_warnings: List of warnings to be automatically approved
+        :param pulumi.Input[str] certificate_chain_type: Certificate trust chain type
+        :param pulumi.Input[bool] change_management: When set to false, the certificate will be deployed to both staging and production networks
+        :param pulumi.Input[str] common_name: Common name used for enrollment
+        :param pulumi.Input[str] contract_id: Contract ID for which enrollment is retrieved
+        :param pulumi.Input['CpsThirdPartyEnrollmentCsrArgs'] csr: Data used for generation of Certificate Signing Request
+        :param pulumi.Input[bool] exclude_sans: When true, SANs are excluded from the CSR
+        :param pulumi.Input['CpsThirdPartyEnrollmentNetworkConfigurationArgs'] network_configuration: Settings containing network information and TLS metadata used by CPS
+        :param pulumi.Input['CpsThirdPartyEnrollmentOrganizationArgs'] organization: Organization information
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] sans: List of SANs
+        :param pulumi.Input[str] secure_network: Type of TLS deployment network
+        :param pulumi.Input[str] signature_algorithm: The SHA function. Changing this value may require running terraform destroy, terraform apply
+        :param pulumi.Input[bool] sni_only: Whether Server Name Indication is used for enrollment
+        :param pulumi.Input['CpsThirdPartyEnrollmentTechContactArgs'] tech_contact: Contact information for an administrator at Akamai
+        """
+        if acknowledge_pre_verification_warnings is not None:
+            pulumi.set(__self__, "acknowledge_pre_verification_warnings", acknowledge_pre_verification_warnings)
+        if admin_contact is not None:
+            pulumi.set(__self__, "admin_contact", admin_contact)
+        if allow_duplicate_common_name is not None:
+            pulumi.set(__self__, "allow_duplicate_common_name", allow_duplicate_common_name)
+        if auto_approve_warnings is not None:
+            pulumi.set(__self__, "auto_approve_warnings", auto_approve_warnings)
+        if certificate_chain_type is not None:
+            pulumi.set(__self__, "certificate_chain_type", certificate_chain_type)
+        if change_management is not None:
+            pulumi.set(__self__, "change_management", change_management)
+        if common_name is not None:
+            pulumi.set(__self__, "common_name", common_name)
         if contract_id is not None:
             pulumi.set(__self__, "contract_id", contract_id)
-        if edge_hostname is not None:
-            pulumi.set(__self__, "edge_hostname", edge_hostname)
-        if group is not None:
-            warnings.warn("""The setting \"group\" has been deprecated.""", DeprecationWarning)
-            pulumi.log.warn("""group is deprecated: The setting \"group\" has been deprecated.""")
-        if group is not None:
-            pulumi.set(__self__, "group", group)
-        if group_id is not None:
-            pulumi.set(__self__, "group_id", group_id)
-        if ip_behavior is not None:
-            pulumi.set(__self__, "ip_behavior", ip_behavior)
-        if product is not None:
-            warnings.warn("""The setting \"product\" has been deprecated.""", DeprecationWarning)
-            pulumi.log.warn("""product is deprecated: The setting \"product\" has been deprecated.""")
-        if product is not None:
-            pulumi.set(__self__, "product", product)
-        if product_id is not None:
-            pulumi.set(__self__, "product_id", product_id)
-        if status_update_emails is not None:
-            pulumi.set(__self__, "status_update_emails", status_update_emails)
-        if use_cases is not None:
-            pulumi.set(__self__, "use_cases", use_cases)
+        if csr is not None:
+            pulumi.set(__self__, "csr", csr)
+        if exclude_sans is not None:
+            pulumi.set(__self__, "exclude_sans", exclude_sans)
+        if network_configuration is not None:
+            pulumi.set(__self__, "network_configuration", network_configuration)
+        if organization is not None:
+            pulumi.set(__self__, "organization", organization)
+        if sans is not None:
+            pulumi.set(__self__, "sans", sans)
+        if secure_network is not None:
+            pulumi.set(__self__, "secure_network", secure_network)
+        if signature_algorithm is not None:
+            pulumi.set(__self__, "signature_algorithm", signature_algorithm)
+        if sni_only is not None:
+            pulumi.set(__self__, "sni_only", sni_only)
+        if tech_contact is not None:
+            pulumi.set(__self__, "tech_contact", tech_contact)
 
     @property
-    @pulumi.getter
-    def certificate(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="acknowledgePreVerificationWarnings")
+    def acknowledge_pre_verification_warnings(self) -> Optional[pulumi.Input[bool]]:
         """
-        Required only when creating an Enhanced TLS edge hostname. This argument sets the certificate enrollment ID. Edge hostnames for Enhanced TLS end in `edgekey.net`. You can retrieve this ID from the [Certificate Provisioning Service CLI](https://github.com/akamai/cli-cps) .
+        Whether acknowledge warnings before certificate verification
         """
-        return pulumi.get(self, "certificate")
+        return pulumi.get(self, "acknowledge_pre_verification_warnings")
 
-    @certificate.setter
-    def certificate(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "certificate", value)
+    @acknowledge_pre_verification_warnings.setter
+    def acknowledge_pre_verification_warnings(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "acknowledge_pre_verification_warnings", value)
 
     @property
-    @pulumi.getter
-    def contract(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="adminContact")
+    def admin_contact(self) -> Optional[pulumi.Input['CpsThirdPartyEnrollmentAdminContactArgs']]:
+        """
+        Contact information for the certificate administrator to use at organization
+        """
+        return pulumi.get(self, "admin_contact")
+
+    @admin_contact.setter
+    def admin_contact(self, value: Optional[pulumi.Input['CpsThirdPartyEnrollmentAdminContactArgs']]):
+        pulumi.set(self, "admin_contact", value)
+
+    @property
+    @pulumi.getter(name="allowDuplicateCommonName")
+    def allow_duplicate_common_name(self) -> Optional[pulumi.Input[bool]]:
+        """
+        Allow to duplicate common name
+        """
+        return pulumi.get(self, "allow_duplicate_common_name")
+
+    @allow_duplicate_common_name.setter
+    def allow_duplicate_common_name(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "allow_duplicate_common_name", value)
+
+    @property
+    @pulumi.getter(name="autoApproveWarnings")
+    def auto_approve_warnings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
+        """
+        List of warnings to be automatically approved
+        """
+        return pulumi.get(self, "auto_approve_warnings")
+
+    @auto_approve_warnings.setter
+    def auto_approve_warnings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
+        pulumi.set(self, "auto_approve_warnings", value)
+
+    @property
+    @pulumi.getter(name="certificateChainType")
+    def certificate_chain_type(self) -> Optional[pulumi.Input[str]]:
+        """
+        Certificate trust chain type
+        """
+        return pulumi.get(self, "certificate_chain_type")
+
+    @certificate_chain_type.setter
+    def certificate_chain_type(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "certificate_chain_type", value)
+
+    @property
+    @pulumi.getter(name="changeManagement")
+    def change_management(self) -> Optional[pulumi.Input[bool]]:
+        """
+        When set to false, the certificate will be deployed to both staging and production networks
+        """
+        return pulumi.get(self, "change_management")
+
+    @change_management.setter
+    def change_management(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "change_management", value)
+
+    @property
+    @pulumi.getter(name="commonName")
+    def common_name(self) -> Optional[pulumi.Input[str]]:
         """
-        Replaced by `contract_id`. Maintained for legacy purposes.
+        Common name used for enrollment
         """
-        return pulumi.get(self, "contract")
+        return pulumi.get(self, "common_name")
 
-    @contract.setter
-    def contract(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "contract", value)
+    @common_name.setter
+    def common_name(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "common_name", value)
 
     @property
     @pulumi.getter(name="contractId")
     def contract_id(self) -> Optional[pulumi.Input[str]]:
         """
-        A contract's unique ID, including the `ctr_` prefix.
+        Contract ID for which enrollment is retrieved
         """
         return pulumi.get(self, "contract_id")
 
     @contract_id.setter
     def contract_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "contract_id", value)
 
     @property
-    @pulumi.getter(name="edgeHostname")
-    def edge_hostname(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter
+    def csr(self) -> Optional[pulumi.Input['CpsThirdPartyEnrollmentCsrArgs']]:
         """
-        One or more edge hostnames. The number of edge hostnames must be less than or equal to the number of public hostnames.
+        Data used for generation of Certificate Signing Request
         """
-        return pulumi.get(self, "edge_hostname")
+        return pulumi.get(self, "csr")
 
-    @edge_hostname.setter
-    def edge_hostname(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "edge_hostname", value)
+    @csr.setter
+    def csr(self, value: Optional[pulumi.Input['CpsThirdPartyEnrollmentCsrArgs']]):
+        pulumi.set(self, "csr", value)
 
     @property
-    @pulumi.getter
-    def group(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="excludeSans")
+    def exclude_sans(self) -> Optional[pulumi.Input[bool]]:
         """
-        Replaced by `group_id`. Maintained for legacy purposes.
+        When true, SANs are excluded from the CSR
         """
-        return pulumi.get(self, "group")
+        return pulumi.get(self, "exclude_sans")
 
-    @group.setter
-    def group(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "group", value)
+    @exclude_sans.setter
+    def exclude_sans(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "exclude_sans", value)
 
     @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="networkConfiguration")
+    def network_configuration(self) -> Optional[pulumi.Input['CpsThirdPartyEnrollmentNetworkConfigurationArgs']]:
         """
-        A group's unique ID, including the `grp_` prefix.
+        Settings containing network information and TLS metadata used by CPS
         """
-        return pulumi.get(self, "group_id")
+        return pulumi.get(self, "network_configuration")
 
-    @group_id.setter
-    def group_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "group_id", value)
+    @network_configuration.setter
+    def network_configuration(self, value: Optional[pulumi.Input['CpsThirdPartyEnrollmentNetworkConfigurationArgs']]):
+        pulumi.set(self, "network_configuration", value)
 
     @property
-    @pulumi.getter(name="ipBehavior")
-    def ip_behavior(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter
+    def organization(self) -> Optional[pulumi.Input['CpsThirdPartyEnrollmentOrganizationArgs']]:
         """
-        Which version of the IP protocol to use: `IPV4` for version 4 only, `IPV6_PERFORMANCE` for version 6 only, or `IPV6_COMPLIANCE` for both 4 and 6.
+        Organization information
         """
-        return pulumi.get(self, "ip_behavior")
+        return pulumi.get(self, "organization")
 
-    @ip_behavior.setter
-    def ip_behavior(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "ip_behavior", value)
+    @organization.setter
+    def organization(self, value: Optional[pulumi.Input['CpsThirdPartyEnrollmentOrganizationArgs']]):
+        pulumi.set(self, "organization", value)
 
     @property
     @pulumi.getter
-    def product(self) -> Optional[pulumi.Input[str]]:
+    def sans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        Replaced by `product_id`. Maintained for legacy purposes.
+        List of SANs
         """
-        return pulumi.get(self, "product")
+        return pulumi.get(self, "sans")
 
-    @product.setter
-    def product(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "product", value)
+    @sans.setter
+    def sans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
+        pulumi.set(self, "sans", value)
 
     @property
-    @pulumi.getter(name="productId")
-    def product_id(self) -> Optional[pulumi.Input[str]]:
-        return pulumi.get(self, "product_id")
+    @pulumi.getter(name="secureNetwork")
+    def secure_network(self) -> Optional[pulumi.Input[str]]:
+        """
+        Type of TLS deployment network
+        """
+        return pulumi.get(self, "secure_network")
 
-    @product_id.setter
-    def product_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "product_id", value)
+    @secure_network.setter
+    def secure_network(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "secure_network", value)
 
     @property
-    @pulumi.getter(name="statusUpdateEmails")
-    def status_update_emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
+    @pulumi.getter(name="signatureAlgorithm")
+    def signature_algorithm(self) -> Optional[pulumi.Input[str]]:
         """
-        Email address that should receive updates on the IP behavior update request. Required for update operation.
+        The SHA function. Changing this value may require running terraform destroy, terraform apply
         """
-        return pulumi.get(self, "status_update_emails")
+        return pulumi.get(self, "signature_algorithm")
 
-    @status_update_emails.setter
-    def status_update_emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
-        pulumi.set(self, "status_update_emails", value)
+    @signature_algorithm.setter
+    def signature_algorithm(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "signature_algorithm", value)
 
     @property
-    @pulumi.getter(name="useCases")
-    def use_cases(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="sniOnly")
+    def sni_only(self) -> Optional[pulumi.Input[bool]]:
         """
-        A JSON encoded list of use cases.
+        Whether Server Name Indication is used for enrollment
         """
-        return pulumi.get(self, "use_cases")
+        return pulumi.get(self, "sni_only")
+
+    @sni_only.setter
+    def sni_only(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "sni_only", value)
 
-    @use_cases.setter
-    def use_cases(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "use_cases", value)
+    @property
+    @pulumi.getter(name="techContact")
+    def tech_contact(self) -> Optional[pulumi.Input['CpsThirdPartyEnrollmentTechContactArgs']]:
+        """
+        Contact information for an administrator at Akamai
+        """
+        return pulumi.get(self, "tech_contact")
 
+    @tech_contact.setter
+    def tech_contact(self, value: Optional[pulumi.Input['CpsThirdPartyEnrollmentTechContactArgs']]):
+        pulumi.set(self, "tech_contact", value)
 
-class EdgeHostName(pulumi.CustomResource):
+
+class CpsThirdPartyEnrollment(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 certificate: Optional[pulumi.Input[int]] = None,
-                 contract: Optional[pulumi.Input[str]] = None,
+                 acknowledge_pre_verification_warnings: Optional[pulumi.Input[bool]] = None,
+                 admin_contact: Optional[pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentAdminContactArgs']]] = None,
+                 allow_duplicate_common_name: Optional[pulumi.Input[bool]] = None,
+                 auto_approve_warnings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 certificate_chain_type: Optional[pulumi.Input[str]] = None,
+                 change_management: Optional[pulumi.Input[bool]] = None,
+                 common_name: Optional[pulumi.Input[str]] = None,
                  contract_id: Optional[pulumi.Input[str]] = None,
-                 edge_hostname: Optional[pulumi.Input[str]] = None,
-                 group: Optional[pulumi.Input[str]] = None,
-                 group_id: Optional[pulumi.Input[str]] = None,
-                 ip_behavior: Optional[pulumi.Input[str]] = None,
-                 product: Optional[pulumi.Input[str]] = None,
-                 product_id: Optional[pulumi.Input[str]] = None,
-                 status_update_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 use_cases: Optional[pulumi.Input[str]] = None,
+                 csr: Optional[pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentCsrArgs']]] = None,
+                 exclude_sans: Optional[pulumi.Input[bool]] = None,
+                 network_configuration: Optional[pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentNetworkConfigurationArgs']]] = None,
+                 organization: Optional[pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentOrganizationArgs']]] = None,
+                 sans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 secure_network: Optional[pulumi.Input[str]] = None,
+                 signature_algorithm: Optional[pulumi.Input[str]] = None,
+                 sni_only: Optional[pulumi.Input[bool]] = None,
+                 tech_contact: Optional[pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentTechContactArgs']]] = None,
                  __props__=None):
         """
-        The `EdgeHostName` resource lets you configure a secure edge hostname. Your
-        edge hostname determines how requests for your site, app, or content are mapped to
-        Akamai edge servers.
-
-        An edge hostname is the CNAME target you use when directing your end user traffic to
-        Akamai. Each hostname assigned to a property has a corresponding edge hostname.
-
-        Akamai supports three types of edge hostnames, depending on the level of security
-        you need for your traffic: Standard TLS, Enhanced TLS, and Shared Certificate. When
-        entering the `edge_hostname` attribute, you need to include a specific domain suffix
-        for your edge hostname type:
-
-        | Edge hostname type | Domain suffix |
-        |------|-------|
-        | Enhanced TLS | edgekey.net |
-        | Standard TLS | edgesuite.net |
-        | Shared Cert | akamaized.net |
-
-        For example, if you use Standard TLS and have `www.example.com` as a hostname, your edge hostname would be `www.example.com.edgesuite.net`. If you wanted to use Enhanced TLS with the same hostname, your edge hostname would be `www.example.com.edgekey.net`. See  [Create a new edge hostname](https://techdocs.akamai.com/property-mgr/reference/post-edgehostnames) in the Property Manager API (PAPI) for more information.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        provider_demo = akamai.EdgeHostName("provider-demo",
-            contract_id="ctr_1-AB123",
-            edge_hostname="www.example.org.edgesuite.net",
-            group_id="grp_123",
-            ip_behavior="IPV4",
-            product_id="prd_Object_Delivery")
-        ```
-        ## Attributes reference
-
-        This resource returns this attribute:
-
-        * `ip_behavior` - Returns the IP protocol the hostname will use, either `IPV4` for version 4, IPV6_PERFORMANCE`for version 6, or`IPV6_COMPLIANCE` for both.
-
-        ## Import
-
-        Basic Usagehcl resource "akamai_edge_hostname" "example" {
-
-        # (resource arguments) } You can import Akamai edge hostnames using a comma-delimited string of edge hostname, contract ID, and group ID. You have to enter the values in this order:
-
-        `edge_hostname, contract_id, group_id` For example
-
-        ```sh
-         $ pulumi import akamai:index/edgeHostName:EdgeHostName example ehn_123,ctr_1-AB123,grp_123
-        ```
-
+        Create a CpsThirdPartyEnrollment resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] certificate: Required only when creating an Enhanced TLS edge hostname. This argument sets the certificate enrollment ID. Edge hostnames for Enhanced TLS end in `edgekey.net`. You can retrieve this ID from the [Certificate Provisioning Service CLI](https://github.com/akamai/cli-cps) .
-        :param pulumi.Input[str] contract: Replaced by `contract_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] contract_id: A contract's unique ID, including the `ctr_` prefix.
-        :param pulumi.Input[str] edge_hostname: One or more edge hostnames. The number of edge hostnames must be less than or equal to the number of public hostnames.
-        :param pulumi.Input[str] group: Replaced by `group_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] group_id: A group's unique ID, including the `grp_` prefix.
-        :param pulumi.Input[str] ip_behavior: Which version of the IP protocol to use: `IPV4` for version 4 only, `IPV6_PERFORMANCE` for version 6 only, or `IPV6_COMPLIANCE` for both 4 and 6.
-        :param pulumi.Input[str] product: Replaced by `product_id`. Maintained for legacy purposes.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] status_update_emails: Email address that should receive updates on the IP behavior update request. Required for update operation.
-        :param pulumi.Input[str] use_cases: A JSON encoded list of use cases.
+        :param pulumi.Input[bool] acknowledge_pre_verification_warnings: Whether acknowledge warnings before certificate verification
+        :param pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentAdminContactArgs']] admin_contact: Contact information for the certificate administrator to use at organization
+        :param pulumi.Input[bool] allow_duplicate_common_name: Allow to duplicate common name
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] auto_approve_warnings: List of warnings to be automatically approved
+        :param pulumi.Input[str] certificate_chain_type: Certificate trust chain type
+        :param pulumi.Input[bool] change_management: When set to false, the certificate will be deployed to both staging and production networks
+        :param pulumi.Input[str] common_name: Common name used for enrollment
+        :param pulumi.Input[str] contract_id: Contract ID for which enrollment is retrieved
+        :param pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentCsrArgs']] csr: Data used for generation of Certificate Signing Request
+        :param pulumi.Input[bool] exclude_sans: When true, SANs are excluded from the CSR
+        :param pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentNetworkConfigurationArgs']] network_configuration: Settings containing network information and TLS metadata used by CPS
+        :param pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentOrganizationArgs']] organization: Organization information
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] sans: List of SANs
+        :param pulumi.Input[str] secure_network: Type of TLS deployment network
+        :param pulumi.Input[str] signature_algorithm: The SHA function. Changing this value may require running terraform destroy, terraform apply
+        :param pulumi.Input[bool] sni_only: Whether Server Name Indication is used for enrollment
+        :param pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentTechContactArgs']] tech_contact: Contact information for an administrator at Akamai
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: EdgeHostNameArgs,
+                 args: CpsThirdPartyEnrollmentArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        The `EdgeHostName` resource lets you configure a secure edge hostname. Your
-        edge hostname determines how requests for your site, app, or content are mapped to
-        Akamai edge servers.
-
-        An edge hostname is the CNAME target you use when directing your end user traffic to
-        Akamai. Each hostname assigned to a property has a corresponding edge hostname.
-
-        Akamai supports three types of edge hostnames, depending on the level of security
-        you need for your traffic: Standard TLS, Enhanced TLS, and Shared Certificate. When
-        entering the `edge_hostname` attribute, you need to include a specific domain suffix
-        for your edge hostname type:
-
-        | Edge hostname type | Domain suffix |
-        |------|-------|
-        | Enhanced TLS | edgekey.net |
-        | Standard TLS | edgesuite.net |
-        | Shared Cert | akamaized.net |
-
-        For example, if you use Standard TLS and have `www.example.com` as a hostname, your edge hostname would be `www.example.com.edgesuite.net`. If you wanted to use Enhanced TLS with the same hostname, your edge hostname would be `www.example.com.edgekey.net`. See  [Create a new edge hostname](https://techdocs.akamai.com/property-mgr/reference/post-edgehostnames) in the Property Manager API (PAPI) for more information.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        provider_demo = akamai.EdgeHostName("provider-demo",
-            contract_id="ctr_1-AB123",
-            edge_hostname="www.example.org.edgesuite.net",
-            group_id="grp_123",
-            ip_behavior="IPV4",
-            product_id="prd_Object_Delivery")
-        ```
-        ## Attributes reference
-
-        This resource returns this attribute:
-
-        * `ip_behavior` - Returns the IP protocol the hostname will use, either `IPV4` for version 4, IPV6_PERFORMANCE`for version 6, or`IPV6_COMPLIANCE` for both.
-
-        ## Import
-
-        Basic Usagehcl resource "akamai_edge_hostname" "example" {
-
-        # (resource arguments) } You can import Akamai edge hostnames using a comma-delimited string of edge hostname, contract ID, and group ID. You have to enter the values in this order:
-
-        `edge_hostname, contract_id, group_id` For example
-
-        ```sh
-         $ pulumi import akamai:index/edgeHostName:EdgeHostName example ehn_123,ctr_1-AB123,grp_123
-        ```
-
+        Create a CpsThirdPartyEnrollment resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param EdgeHostNameArgs args: The arguments to use to populate this resource's properties.
+        :param CpsThirdPartyEnrollmentArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(EdgeHostNameArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(CpsThirdPartyEnrollmentArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 certificate: Optional[pulumi.Input[int]] = None,
-                 contract: Optional[pulumi.Input[str]] = None,
+                 acknowledge_pre_verification_warnings: Optional[pulumi.Input[bool]] = None,
+                 admin_contact: Optional[pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentAdminContactArgs']]] = None,
+                 allow_duplicate_common_name: Optional[pulumi.Input[bool]] = None,
+                 auto_approve_warnings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 certificate_chain_type: Optional[pulumi.Input[str]] = None,
+                 change_management: Optional[pulumi.Input[bool]] = None,
+                 common_name: Optional[pulumi.Input[str]] = None,
                  contract_id: Optional[pulumi.Input[str]] = None,
-                 edge_hostname: Optional[pulumi.Input[str]] = None,
-                 group: Optional[pulumi.Input[str]] = None,
-                 group_id: Optional[pulumi.Input[str]] = None,
-                 ip_behavior: Optional[pulumi.Input[str]] = None,
-                 product: Optional[pulumi.Input[str]] = None,
-                 product_id: Optional[pulumi.Input[str]] = None,
-                 status_update_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 use_cases: Optional[pulumi.Input[str]] = None,
+                 csr: Optional[pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentCsrArgs']]] = None,
+                 exclude_sans: Optional[pulumi.Input[bool]] = None,
+                 network_configuration: Optional[pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentNetworkConfigurationArgs']]] = None,
+                 organization: Optional[pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentOrganizationArgs']]] = None,
+                 sans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 secure_network: Optional[pulumi.Input[str]] = None,
+                 signature_algorithm: Optional[pulumi.Input[str]] = None,
+                 sni_only: Optional[pulumi.Input[bool]] = None,
+                 tech_contact: Optional[pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentTechContactArgs']]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = EdgeHostNameArgs.__new__(EdgeHostNameArgs)
+            __props__ = CpsThirdPartyEnrollmentArgs.__new__(CpsThirdPartyEnrollmentArgs)
 
-            __props__.__dict__["certificate"] = certificate
-            if contract is not None and not opts.urn:
-                warnings.warn("""The setting \"contract\" has been deprecated.""", DeprecationWarning)
-                pulumi.log.warn("""contract is deprecated: The setting \"contract\" has been deprecated.""")
-            __props__.__dict__["contract"] = contract
+            __props__.__dict__["acknowledge_pre_verification_warnings"] = acknowledge_pre_verification_warnings
+            if admin_contact is None and not opts.urn:
+                raise TypeError("Missing required property 'admin_contact'")
+            __props__.__dict__["admin_contact"] = admin_contact
+            __props__.__dict__["allow_duplicate_common_name"] = allow_duplicate_common_name
+            __props__.__dict__["auto_approve_warnings"] = auto_approve_warnings
+            __props__.__dict__["certificate_chain_type"] = certificate_chain_type
+            __props__.__dict__["change_management"] = change_management
+            if common_name is None and not opts.urn:
+                raise TypeError("Missing required property 'common_name'")
+            __props__.__dict__["common_name"] = common_name
+            if contract_id is None and not opts.urn:
+                raise TypeError("Missing required property 'contract_id'")
             __props__.__dict__["contract_id"] = contract_id
-            if edge_hostname is None and not opts.urn:
-                raise TypeError("Missing required property 'edge_hostname'")
-            __props__.__dict__["edge_hostname"] = edge_hostname
-            if group is not None and not opts.urn:
-                warnings.warn("""The setting \"group\" has been deprecated.""", DeprecationWarning)
-                pulumi.log.warn("""group is deprecated: The setting \"group\" has been deprecated.""")
-            __props__.__dict__["group"] = group
-            __props__.__dict__["group_id"] = group_id
-            if ip_behavior is None and not opts.urn:
-                raise TypeError("Missing required property 'ip_behavior'")
-            __props__.__dict__["ip_behavior"] = ip_behavior
-            if product is not None and not opts.urn:
-                warnings.warn("""The setting \"product\" has been deprecated.""", DeprecationWarning)
-                pulumi.log.warn("""product is deprecated: The setting \"product\" has been deprecated.""")
-            __props__.__dict__["product"] = product
-            __props__.__dict__["product_id"] = product_id
-            __props__.__dict__["status_update_emails"] = status_update_emails
-            __props__.__dict__["use_cases"] = use_cases
-        alias_opts = pulumi.ResourceOptions(aliases=[pulumi.Alias(type_="akamai:properties/edgeHostName:EdgeHostName")])
-        opts = pulumi.ResourceOptions.merge(opts, alias_opts)
-        super(EdgeHostName, __self__).__init__(
-            'akamai:index/edgeHostName:EdgeHostName',
+            if csr is None and not opts.urn:
+                raise TypeError("Missing required property 'csr'")
+            __props__.__dict__["csr"] = csr
+            __props__.__dict__["exclude_sans"] = exclude_sans
+            if network_configuration is None and not opts.urn:
+                raise TypeError("Missing required property 'network_configuration'")
+            __props__.__dict__["network_configuration"] = network_configuration
+            if organization is None and not opts.urn:
+                raise TypeError("Missing required property 'organization'")
+            __props__.__dict__["organization"] = organization
+            __props__.__dict__["sans"] = sans
+            if secure_network is None and not opts.urn:
+                raise TypeError("Missing required property 'secure_network'")
+            __props__.__dict__["secure_network"] = secure_network
+            __props__.__dict__["signature_algorithm"] = signature_algorithm
+            if sni_only is None and not opts.urn:
+                raise TypeError("Missing required property 'sni_only'")
+            __props__.__dict__["sni_only"] = sni_only
+            if tech_contact is None and not opts.urn:
+                raise TypeError("Missing required property 'tech_contact'")
+            __props__.__dict__["tech_contact"] = tech_contact
+        super(CpsThirdPartyEnrollment, __self__).__init__(
+            'akamai:index/cpsThirdPartyEnrollment:CpsThirdPartyEnrollment',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
-            certificate: Optional[pulumi.Input[int]] = None,
-            contract: Optional[pulumi.Input[str]] = None,
+            acknowledge_pre_verification_warnings: Optional[pulumi.Input[bool]] = None,
+            admin_contact: Optional[pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentAdminContactArgs']]] = None,
+            allow_duplicate_common_name: Optional[pulumi.Input[bool]] = None,
+            auto_approve_warnings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+            certificate_chain_type: Optional[pulumi.Input[str]] = None,
+            change_management: Optional[pulumi.Input[bool]] = None,
+            common_name: Optional[pulumi.Input[str]] = None,
             contract_id: Optional[pulumi.Input[str]] = None,
-            edge_hostname: Optional[pulumi.Input[str]] = None,
-            group: Optional[pulumi.Input[str]] = None,
-            group_id: Optional[pulumi.Input[str]] = None,
-            ip_behavior: Optional[pulumi.Input[str]] = None,
-            product: Optional[pulumi.Input[str]] = None,
-            product_id: Optional[pulumi.Input[str]] = None,
-            status_update_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-            use_cases: Optional[pulumi.Input[str]] = None) -> 'EdgeHostName':
+            csr: Optional[pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentCsrArgs']]] = None,
+            exclude_sans: Optional[pulumi.Input[bool]] = None,
+            network_configuration: Optional[pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentNetworkConfigurationArgs']]] = None,
+            organization: Optional[pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentOrganizationArgs']]] = None,
+            sans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+            secure_network: Optional[pulumi.Input[str]] = None,
+            signature_algorithm: Optional[pulumi.Input[str]] = None,
+            sni_only: Optional[pulumi.Input[bool]] = None,
+            tech_contact: Optional[pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentTechContactArgs']]] = None) -> 'CpsThirdPartyEnrollment':
         """
-        Get an existing EdgeHostName resource's state with the given name, id, and optional extra
+        Get an existing CpsThirdPartyEnrollment resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] certificate: Required only when creating an Enhanced TLS edge hostname. This argument sets the certificate enrollment ID. Edge hostnames for Enhanced TLS end in `edgekey.net`. You can retrieve this ID from the [Certificate Provisioning Service CLI](https://github.com/akamai/cli-cps) .
-        :param pulumi.Input[str] contract: Replaced by `contract_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] contract_id: A contract's unique ID, including the `ctr_` prefix.
-        :param pulumi.Input[str] edge_hostname: One or more edge hostnames. The number of edge hostnames must be less than or equal to the number of public hostnames.
-        :param pulumi.Input[str] group: Replaced by `group_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] group_id: A group's unique ID, including the `grp_` prefix.
-        :param pulumi.Input[str] ip_behavior: Which version of the IP protocol to use: `IPV4` for version 4 only, `IPV6_PERFORMANCE` for version 6 only, or `IPV6_COMPLIANCE` for both 4 and 6.
-        :param pulumi.Input[str] product: Replaced by `product_id`. Maintained for legacy purposes.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] status_update_emails: Email address that should receive updates on the IP behavior update request. Required for update operation.
-        :param pulumi.Input[str] use_cases: A JSON encoded list of use cases.
+        :param pulumi.Input[bool] acknowledge_pre_verification_warnings: Whether acknowledge warnings before certificate verification
+        :param pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentAdminContactArgs']] admin_contact: Contact information for the certificate administrator to use at organization
+        :param pulumi.Input[bool] allow_duplicate_common_name: Allow to duplicate common name
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] auto_approve_warnings: List of warnings to be automatically approved
+        :param pulumi.Input[str] certificate_chain_type: Certificate trust chain type
+        :param pulumi.Input[bool] change_management: When set to false, the certificate will be deployed to both staging and production networks
+        :param pulumi.Input[str] common_name: Common name used for enrollment
+        :param pulumi.Input[str] contract_id: Contract ID for which enrollment is retrieved
+        :param pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentCsrArgs']] csr: Data used for generation of Certificate Signing Request
+        :param pulumi.Input[bool] exclude_sans: When true, SANs are excluded from the CSR
+        :param pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentNetworkConfigurationArgs']] network_configuration: Settings containing network information and TLS metadata used by CPS
+        :param pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentOrganizationArgs']] organization: Organization information
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] sans: List of SANs
+        :param pulumi.Input[str] secure_network: Type of TLS deployment network
+        :param pulumi.Input[str] signature_algorithm: The SHA function. Changing this value may require running terraform destroy, terraform apply
+        :param pulumi.Input[bool] sni_only: Whether Server Name Indication is used for enrollment
+        :param pulumi.Input[pulumi.InputType['CpsThirdPartyEnrollmentTechContactArgs']] tech_contact: Contact information for an administrator at Akamai
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _EdgeHostNameState.__new__(_EdgeHostNameState)
+        __props__ = _CpsThirdPartyEnrollmentState.__new__(_CpsThirdPartyEnrollmentState)
 
-        __props__.__dict__["certificate"] = certificate
-        __props__.__dict__["contract"] = contract
+        __props__.__dict__["acknowledge_pre_verification_warnings"] = acknowledge_pre_verification_warnings
+        __props__.__dict__["admin_contact"] = admin_contact
+        __props__.__dict__["allow_duplicate_common_name"] = allow_duplicate_common_name
+        __props__.__dict__["auto_approve_warnings"] = auto_approve_warnings
+        __props__.__dict__["certificate_chain_type"] = certificate_chain_type
+        __props__.__dict__["change_management"] = change_management
+        __props__.__dict__["common_name"] = common_name
         __props__.__dict__["contract_id"] = contract_id
-        __props__.__dict__["edge_hostname"] = edge_hostname
-        __props__.__dict__["group"] = group
-        __props__.__dict__["group_id"] = group_id
-        __props__.__dict__["ip_behavior"] = ip_behavior
-        __props__.__dict__["product"] = product
-        __props__.__dict__["product_id"] = product_id
-        __props__.__dict__["status_update_emails"] = status_update_emails
-        __props__.__dict__["use_cases"] = use_cases
-        return EdgeHostName(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["csr"] = csr
+        __props__.__dict__["exclude_sans"] = exclude_sans
+        __props__.__dict__["network_configuration"] = network_configuration
+        __props__.__dict__["organization"] = organization
+        __props__.__dict__["sans"] = sans
+        __props__.__dict__["secure_network"] = secure_network
+        __props__.__dict__["signature_algorithm"] = signature_algorithm
+        __props__.__dict__["sni_only"] = sni_only
+        __props__.__dict__["tech_contact"] = tech_contact
+        return CpsThirdPartyEnrollment(resource_name, opts=opts, __props__=__props__)
 
     @property
-    @pulumi.getter
-    def certificate(self) -> pulumi.Output[Optional[int]]:
+    @pulumi.getter(name="acknowledgePreVerificationWarnings")
+    def acknowledge_pre_verification_warnings(self) -> pulumi.Output[Optional[bool]]:
         """
-        Required only when creating an Enhanced TLS edge hostname. This argument sets the certificate enrollment ID. Edge hostnames for Enhanced TLS end in `edgekey.net`. You can retrieve this ID from the [Certificate Provisioning Service CLI](https://github.com/akamai/cli-cps) .
+        Whether acknowledge warnings before certificate verification
         """
-        return pulumi.get(self, "certificate")
+        return pulumi.get(self, "acknowledge_pre_verification_warnings")
 
     @property
-    @pulumi.getter
-    def contract(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="adminContact")
+    def admin_contact(self) -> pulumi.Output['outputs.CpsThirdPartyEnrollmentAdminContact']:
         """
-        Replaced by `contract_id`. Maintained for legacy purposes.
+        Contact information for the certificate administrator to use at organization
         """
-        return pulumi.get(self, "contract")
+        return pulumi.get(self, "admin_contact")
+
+    @property
+    @pulumi.getter(name="allowDuplicateCommonName")
+    def allow_duplicate_common_name(self) -> pulumi.Output[Optional[bool]]:
+        """
+        Allow to duplicate common name
+        """
+        return pulumi.get(self, "allow_duplicate_common_name")
+
+    @property
+    @pulumi.getter(name="autoApproveWarnings")
+    def auto_approve_warnings(self) -> pulumi.Output[Optional[Sequence[str]]]:
+        """
+        List of warnings to be automatically approved
+        """
+        return pulumi.get(self, "auto_approve_warnings")
+
+    @property
+    @pulumi.getter(name="certificateChainType")
+    def certificate_chain_type(self) -> pulumi.Output[Optional[str]]:
+        """
+        Certificate trust chain type
+        """
+        return pulumi.get(self, "certificate_chain_type")
+
+    @property
+    @pulumi.getter(name="changeManagement")
+    def change_management(self) -> pulumi.Output[Optional[bool]]:
+        """
+        When set to false, the certificate will be deployed to both staging and production networks
+        """
+        return pulumi.get(self, "change_management")
+
+    @property
+    @pulumi.getter(name="commonName")
+    def common_name(self) -> pulumi.Output[str]:
+        """
+        Common name used for enrollment
+        """
+        return pulumi.get(self, "common_name")
 
     @property
     @pulumi.getter(name="contractId")
     def contract_id(self) -> pulumi.Output[str]:
         """
-        A contract's unique ID, including the `ctr_` prefix.
+        Contract ID for which enrollment is retrieved
         """
         return pulumi.get(self, "contract_id")
 
     @property
-    @pulumi.getter(name="edgeHostname")
-    def edge_hostname(self) -> pulumi.Output[str]:
+    @pulumi.getter
+    def csr(self) -> pulumi.Output['outputs.CpsThirdPartyEnrollmentCsr']:
         """
-        One or more edge hostnames. The number of edge hostnames must be less than or equal to the number of public hostnames.
+        Data used for generation of Certificate Signing Request
         """
-        return pulumi.get(self, "edge_hostname")
+        return pulumi.get(self, "csr")
 
     @property
-    @pulumi.getter
-    def group(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="excludeSans")
+    def exclude_sans(self) -> pulumi.Output[Optional[bool]]:
         """
-        Replaced by `group_id`. Maintained for legacy purposes.
+        When true, SANs are excluded from the CSR
         """
-        return pulumi.get(self, "group")
+        return pulumi.get(self, "exclude_sans")
 
     @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="networkConfiguration")
+    def network_configuration(self) -> pulumi.Output['outputs.CpsThirdPartyEnrollmentNetworkConfiguration']:
         """
-        A group's unique ID, including the `grp_` prefix.
+        Settings containing network information and TLS metadata used by CPS
         """
-        return pulumi.get(self, "group_id")
+        return pulumi.get(self, "network_configuration")
 
     @property
-    @pulumi.getter(name="ipBehavior")
-    def ip_behavior(self) -> pulumi.Output[str]:
+    @pulumi.getter
+    def organization(self) -> pulumi.Output['outputs.CpsThirdPartyEnrollmentOrganization']:
         """
-        Which version of the IP protocol to use: `IPV4` for version 4 only, `IPV6_PERFORMANCE` for version 6 only, or `IPV6_COMPLIANCE` for both 4 and 6.
+        Organization information
         """
-        return pulumi.get(self, "ip_behavior")
+        return pulumi.get(self, "organization")
 
     @property
     @pulumi.getter
-    def product(self) -> pulumi.Output[str]:
+    def sans(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        Replaced by `product_id`. Maintained for legacy purposes.
+        List of SANs
         """
-        return pulumi.get(self, "product")
+        return pulumi.get(self, "sans")
 
     @property
-    @pulumi.getter(name="productId")
-    def product_id(self) -> pulumi.Output[str]:
-        return pulumi.get(self, "product_id")
+    @pulumi.getter(name="secureNetwork")
+    def secure_network(self) -> pulumi.Output[str]:
+        """
+        Type of TLS deployment network
+        """
+        return pulumi.get(self, "secure_network")
+
+    @property
+    @pulumi.getter(name="signatureAlgorithm")
+    def signature_algorithm(self) -> pulumi.Output[Optional[str]]:
+        """
+        The SHA function. Changing this value may require running terraform destroy, terraform apply
+        """
+        return pulumi.get(self, "signature_algorithm")
 
     @property
-    @pulumi.getter(name="statusUpdateEmails")
-    def status_update_emails(self) -> pulumi.Output[Optional[Sequence[str]]]:
+    @pulumi.getter(name="sniOnly")
+    def sni_only(self) -> pulumi.Output[bool]:
         """
-        Email address that should receive updates on the IP behavior update request. Required for update operation.
+        Whether Server Name Indication is used for enrollment
         """
-        return pulumi.get(self, "status_update_emails")
+        return pulumi.get(self, "sni_only")
 
     @property
-    @pulumi.getter(name="useCases")
-    def use_cases(self) -> pulumi.Output[Optional[str]]:
+    @pulumi.getter(name="techContact")
+    def tech_contact(self) -> pulumi.Output['outputs.CpsThirdPartyEnrollmentTechContact']:
         """
-        A JSON encoded list of use cases.
+        Contact information for an administrator at Akamai
         """
-        return pulumi.get(self, "use_cases")
+        return pulumi.get(self, "tech_contact")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/edge_worker.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/edge_worker.py`

 * *Files 10% similar despite different names*

```diff
@@ -16,67 +16,67 @@
     def __init__(__self__, *,
                  group_id: pulumi.Input[int],
                  resource_tier_id: pulumi.Input[int],
                  local_bundle: Optional[pulumi.Input[str]] = None,
                  name: Optional[pulumi.Input[str]] = None):
         """
         The set of arguments for constructing a EdgeWorker resource.
-        :param pulumi.Input[int] group_id: (Required) Identifies a group to assign to the EdgeWorker ID.
-        :param pulumi.Input[int] resource_tier_id: (Required) Unique identifier of the resource tier.
-        :param pulumi.Input[str] local_bundle: (Optional) The path to the EdgeWorkers code bundle.
-        :param pulumi.Input[str] name: (Required) The name of the EdgeWorker ID.
+        :param pulumi.Input[int] group_id: Defines the group association for the EdgeWorker
+        :param pulumi.Input[int] resource_tier_id: The unique identifier of a resource tier
+        :param pulumi.Input[str] local_bundle: The path to the EdgeWorkers tgz code bundle
+        :param pulumi.Input[str] name: The EdgeWorker name
         """
         pulumi.set(__self__, "group_id", group_id)
         pulumi.set(__self__, "resource_tier_id", resource_tier_id)
         if local_bundle is not None:
             pulumi.set(__self__, "local_bundle", local_bundle)
         if name is not None:
             pulumi.set(__self__, "name", name)
 
     @property
     @pulumi.getter(name="groupId")
     def group_id(self) -> pulumi.Input[int]:
         """
-        (Required) Identifies a group to assign to the EdgeWorker ID.
+        Defines the group association for the EdgeWorker
         """
         return pulumi.get(self, "group_id")
 
     @group_id.setter
     def group_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "group_id", value)
 
     @property
     @pulumi.getter(name="resourceTierId")
     def resource_tier_id(self) -> pulumi.Input[int]:
         """
-        (Required) Unique identifier of the resource tier.
+        The unique identifier of a resource tier
         """
         return pulumi.get(self, "resource_tier_id")
 
     @resource_tier_id.setter
     def resource_tier_id(self, value: pulumi.Input[int]):
         pulumi.set(self, "resource_tier_id", value)
 
     @property
     @pulumi.getter(name="localBundle")
     def local_bundle(self) -> Optional[pulumi.Input[str]]:
         """
-        (Optional) The path to the EdgeWorkers code bundle.
+        The path to the EdgeWorkers tgz code bundle
         """
         return pulumi.get(self, "local_bundle")
 
     @local_bundle.setter
     def local_bundle(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "local_bundle", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        (Required) The name of the EdgeWorker ID.
+        The EdgeWorker name
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
@@ -91,19 +91,19 @@
                  name: Optional[pulumi.Input[str]] = None,
                  resource_tier_id: Optional[pulumi.Input[int]] = None,
                  version: Optional[pulumi.Input[str]] = None,
                  warnings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
         """
         Input properties used for looking up and filtering EdgeWorker resources.
         :param pulumi.Input[int] edgeworker_id: The unique identifier of the EdgeWorker
-        :param pulumi.Input[int] group_id: (Required) Identifies a group to assign to the EdgeWorker ID.
-        :param pulumi.Input[str] local_bundle: (Optional) The path to the EdgeWorkers code bundle.
+        :param pulumi.Input[int] group_id: Defines the group association for the EdgeWorker
+        :param pulumi.Input[str] local_bundle: The path to the EdgeWorkers tgz code bundle
         :param pulumi.Input[str] local_bundle_hash: The local bundle hash for the EdgeWorker
-        :param pulumi.Input[str] name: (Required) The name of the EdgeWorker ID.
-        :param pulumi.Input[int] resource_tier_id: (Required) Unique identifier of the resource tier.
+        :param pulumi.Input[str] name: The EdgeWorker name
+        :param pulumi.Input[int] resource_tier_id: The unique identifier of a resource tier
         :param pulumi.Input[str] version: The bundle version
         :param pulumi.Input[Sequence[pulumi.Input[str]]] warnings: The list of warnings returned by EdgeWorker validation
         """
         if edgeworker_id is not None:
             pulumi.set(__self__, "edgeworker_id", edgeworker_id)
         if group_id is not None:
             pulumi.set(__self__, "group_id", group_id)
@@ -132,27 +132,27 @@
     def edgeworker_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "edgeworker_id", value)
 
     @property
     @pulumi.getter(name="groupId")
     def group_id(self) -> Optional[pulumi.Input[int]]:
         """
-        (Required) Identifies a group to assign to the EdgeWorker ID.
+        Defines the group association for the EdgeWorker
         """
         return pulumi.get(self, "group_id")
 
     @group_id.setter
     def group_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "group_id", value)
 
     @property
     @pulumi.getter(name="localBundle")
     def local_bundle(self) -> Optional[pulumi.Input[str]]:
         """
-        (Optional) The path to the EdgeWorkers code bundle.
+        The path to the EdgeWorkers tgz code bundle
         """
         return pulumi.get(self, "local_bundle")
 
     @local_bundle.setter
     def local_bundle(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "local_bundle", value)
 
@@ -168,27 +168,27 @@
     def local_bundle_hash(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "local_bundle_hash", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        (Required) The name of the EdgeWorker ID.
+        The EdgeWorker name
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="resourceTierId")
     def resource_tier_id(self) -> Optional[pulumi.Input[int]]:
         """
-        (Required) Unique identifier of the resource tier.
+        The unique identifier of a resource tier
         """
         return pulumi.get(self, "resource_tier_id")
 
     @resource_tier_id.setter
     def resource_tier_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "resource_tier_id", value)
 
@@ -224,72 +224,30 @@
                  opts: Optional[pulumi.ResourceOptions] = None,
                  group_id: Optional[pulumi.Input[int]] = None,
                  local_bundle: Optional[pulumi.Input[str]] = None,
                  name: Optional[pulumi.Input[str]] = None,
                  resource_tier_id: Optional[pulumi.Input[int]] = None,
                  __props__=None):
         """
-        The `EdgeWorker` resource lets you deploy custom code on thousands of edge servers and apply logic that creates powerful web experiences.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        ew = akamai.EdgeWorker("ew",
-            group_id=72297,
-            resource_tier_id=100,
-            local_bundle=var["bundle_path"])
-        ```
-        ## Attributes reference
-
-        * `edgeworker_id` - Unique identifier for an EdgeWorker ID.
-        * `local_bundle_hash` - A SHA-256 hash digest of the EdgeWorkers code bundle.
-        * `version` -Unique identifier for a specific EdgeWorker version.
-        * `warnings` - List of validation warnings.
-
+        Create a EdgeWorker resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[int] group_id: (Required) Identifies a group to assign to the EdgeWorker ID.
-        :param pulumi.Input[str] local_bundle: (Optional) The path to the EdgeWorkers code bundle.
-        :param pulumi.Input[str] name: (Required) The name of the EdgeWorker ID.
-        :param pulumi.Input[int] resource_tier_id: (Required) Unique identifier of the resource tier.
+        :param pulumi.Input[int] group_id: Defines the group association for the EdgeWorker
+        :param pulumi.Input[str] local_bundle: The path to the EdgeWorkers tgz code bundle
+        :param pulumi.Input[str] name: The EdgeWorker name
+        :param pulumi.Input[int] resource_tier_id: The unique identifier of a resource tier
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: EdgeWorkerArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        The `EdgeWorker` resource lets you deploy custom code on thousands of edge servers and apply logic that creates powerful web experiences.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        ew = akamai.EdgeWorker("ew",
-            group_id=72297,
-            resource_tier_id=100,
-            local_bundle=var["bundle_path"])
-        ```
-        ## Attributes reference
-
-        * `edgeworker_id` - Unique identifier for an EdgeWorker ID.
-        * `local_bundle_hash` - A SHA-256 hash digest of the EdgeWorkers code bundle.
-        * `version` -Unique identifier for a specific EdgeWorker version.
-        * `warnings` - List of validation warnings.
-
+        Create a EdgeWorker resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param EdgeWorkerArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(EdgeWorkerArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -348,19 +306,19 @@
         Get an existing EdgeWorker resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
         :param pulumi.Input[int] edgeworker_id: The unique identifier of the EdgeWorker
-        :param pulumi.Input[int] group_id: (Required) Identifies a group to assign to the EdgeWorker ID.
-        :param pulumi.Input[str] local_bundle: (Optional) The path to the EdgeWorkers code bundle.
+        :param pulumi.Input[int] group_id: Defines the group association for the EdgeWorker
+        :param pulumi.Input[str] local_bundle: The path to the EdgeWorkers tgz code bundle
         :param pulumi.Input[str] local_bundle_hash: The local bundle hash for the EdgeWorker
-        :param pulumi.Input[str] name: (Required) The name of the EdgeWorker ID.
-        :param pulumi.Input[int] resource_tier_id: (Required) Unique identifier of the resource tier.
+        :param pulumi.Input[str] name: The EdgeWorker name
+        :param pulumi.Input[int] resource_tier_id: The unique identifier of a resource tier
         :param pulumi.Input[str] version: The bundle version
         :param pulumi.Input[Sequence[pulumi.Input[str]]] warnings: The list of warnings returned by EdgeWorker validation
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _EdgeWorkerState.__new__(_EdgeWorkerState)
 
@@ -382,23 +340,23 @@
         """
         return pulumi.get(self, "edgeworker_id")
 
     @property
     @pulumi.getter(name="groupId")
     def group_id(self) -> pulumi.Output[int]:
         """
-        (Required) Identifies a group to assign to the EdgeWorker ID.
+        Defines the group association for the EdgeWorker
         """
         return pulumi.get(self, "group_id")
 
     @property
     @pulumi.getter(name="localBundle")
     def local_bundle(self) -> pulumi.Output[Optional[str]]:
         """
-        (Optional) The path to the EdgeWorkers code bundle.
+        The path to the EdgeWorkers tgz code bundle
         """
         return pulumi.get(self, "local_bundle")
 
     @property
     @pulumi.getter(name="localBundleHash")
     def local_bundle_hash(self) -> pulumi.Output[str]:
         """
@@ -406,23 +364,23 @@
         """
         return pulumi.get(self, "local_bundle_hash")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        (Required) The name of the EdgeWorker ID.
+        The EdgeWorker name
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter(name="resourceTierId")
     def resource_tier_id(self) -> pulumi.Output[int]:
         """
-        (Required) Unique identifier of the resource tier.
+        The unique identifier of a resource tier
         """
         return pulumi.get(self, "resource_tier_id")
 
     @property
     @pulumi.getter
     def version(self) -> pulumi.Output[str]:
         """
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/edgedns/_inputs.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/edgedns/_inputs.py`

 * *Files 16% similar despite different names*

```diff
@@ -15,53 +15,39 @@
 
 @pulumi.input_type
 class DnsZoneTsigKeyArgs:
     def __init__(__self__, *,
                  algorithm: pulumi.Input[str],
                  name: pulumi.Input[str],
                  secret: pulumi.Input[str]):
-        """
-        :param pulumi.Input[str] algorithm: The hashing algorithm.
-        :param pulumi.Input[str] name: The key name.
-        :param pulumi.Input[str] secret: String known between transfer endpoints.
-        """
         pulumi.set(__self__, "algorithm", algorithm)
         pulumi.set(__self__, "name", name)
         pulumi.set(__self__, "secret", secret)
 
     @property
     @pulumi.getter
     def algorithm(self) -> pulumi.Input[str]:
-        """
-        The hashing algorithm.
-        """
         return pulumi.get(self, "algorithm")
 
     @algorithm.setter
     def algorithm(self, value: pulumi.Input[str]):
         pulumi.set(self, "algorithm", value)
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Input[str]:
-        """
-        The key name.
-        """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: pulumi.Input[str]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter
     def secret(self) -> pulumi.Input[str]:
-        """
-        String known between transfer endpoints.
-        """
         return pulumi.get(self, "secret")
 
     @secret.setter
     def secret(self, value: pulumi.Input[str]):
         pulumi.set(self, "secret", value)
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/edgedns/dns_record.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/edgedns/dns_record.py`

 * *Files identical despite different names*

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/edgedns/dns_zone.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/trafficmanagement/gtm_datacenter.py`

 * *Files 23% similar despite different names*

```diff
@@ -7,678 +7,701 @@
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from .. import _utilities
 from . import outputs
 from ._inputs import *
 
-__all__ = ['DnsZoneArgs', 'DnsZone']
+__all__ = ['GtmDatacenterArgs', 'GtmDatacenter']
 
 @pulumi.input_type
-class DnsZoneArgs:
+class GtmDatacenterArgs:
     def __init__(__self__, *,
-                 contract: pulumi.Input[str],
-                 type: pulumi.Input[str],
-                 zone: pulumi.Input[str],
-                 comment: Optional[pulumi.Input[str]] = None,
-                 end_customer_id: Optional[pulumi.Input[str]] = None,
-                 group: Optional[pulumi.Input[str]] = None,
-                 masters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 sign_and_serve: Optional[pulumi.Input[bool]] = None,
-                 sign_and_serve_algorithm: Optional[pulumi.Input[str]] = None,
-                 target: Optional[pulumi.Input[str]] = None,
-                 tsig_key: Optional[pulumi.Input['DnsZoneTsigKeyArgs']] = None):
+                 domain: pulumi.Input[str],
+                 city: Optional[pulumi.Input[str]] = None,
+                 clone_of: Optional[pulumi.Input[int]] = None,
+                 cloud_server_host_header_override: Optional[pulumi.Input[bool]] = None,
+                 cloud_server_targeting: Optional[pulumi.Input[bool]] = None,
+                 continent: Optional[pulumi.Input[str]] = None,
+                 country: Optional[pulumi.Input[str]] = None,
+                 default_load_object: Optional[pulumi.Input['GtmDatacenterDefaultLoadObjectArgs']] = None,
+                 latitude: Optional[pulumi.Input[float]] = None,
+                 longitude: Optional[pulumi.Input[float]] = None,
+                 nickname: Optional[pulumi.Input[str]] = None,
+                 state_or_province: Optional[pulumi.Input[str]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None):
         """
-        The set of arguments for constructing a DnsZone resource.
-        :param pulumi.Input[str] contract: The contract ID.
-        :param pulumi.Input[str] type: Whether the zone is `primary`, `secondary`, or `alias`.
-        :param pulumi.Input[str] zone: The domain zone, encapsulating any nested subdomains.
-        :param pulumi.Input[str] comment: A descriptive comment.
-        :param pulumi.Input[str] end_customer_id: A free form identifier for the zone.
-        :param pulumi.Input[str] group: The currently selected group ID.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] masters: The names or IP addresses of the nameservers that the zone data should be retrieved from.
-        :param pulumi.Input[bool] sign_and_serve: Whether DNSSEC Sign and Serve is enabled.
-        :param pulumi.Input[str] sign_and_serve_algorithm: The algorithm used by Sign and Serve.
-        :param pulumi.Input[str] target: The name of the zone whose configuration this zone will copy.
-        :param pulumi.Input['DnsZoneTsigKeyArgs'] tsig_key: The TSIG Key used in secure zone transfers. If used, requires these arguments:
+        The set of arguments for constructing a GtmDatacenter resource.
         """
-        pulumi.set(__self__, "contract", contract)
-        pulumi.set(__self__, "type", type)
-        pulumi.set(__self__, "zone", zone)
-        if comment is not None:
-            pulumi.set(__self__, "comment", comment)
-        if end_customer_id is not None:
-            pulumi.set(__self__, "end_customer_id", end_customer_id)
-        if group is not None:
-            pulumi.set(__self__, "group", group)
-        if masters is not None:
-            pulumi.set(__self__, "masters", masters)
-        if sign_and_serve is not None:
-            pulumi.set(__self__, "sign_and_serve", sign_and_serve)
-        if sign_and_serve_algorithm is not None:
-            pulumi.set(__self__, "sign_and_serve_algorithm", sign_and_serve_algorithm)
-        if target is not None:
-            pulumi.set(__self__, "target", target)
-        if tsig_key is not None:
-            pulumi.set(__self__, "tsig_key", tsig_key)
+        pulumi.set(__self__, "domain", domain)
+        if city is not None:
+            pulumi.set(__self__, "city", city)
+        if clone_of is not None:
+            pulumi.set(__self__, "clone_of", clone_of)
+        if cloud_server_host_header_override is not None:
+            pulumi.set(__self__, "cloud_server_host_header_override", cloud_server_host_header_override)
+        if cloud_server_targeting is not None:
+            pulumi.set(__self__, "cloud_server_targeting", cloud_server_targeting)
+        if continent is not None:
+            pulumi.set(__self__, "continent", continent)
+        if country is not None:
+            pulumi.set(__self__, "country", country)
+        if default_load_object is not None:
+            pulumi.set(__self__, "default_load_object", default_load_object)
+        if latitude is not None:
+            pulumi.set(__self__, "latitude", latitude)
+        if longitude is not None:
+            pulumi.set(__self__, "longitude", longitude)
+        if nickname is not None:
+            pulumi.set(__self__, "nickname", nickname)
+        if state_or_province is not None:
+            pulumi.set(__self__, "state_or_province", state_or_province)
+        if wait_on_complete is not None:
+            pulumi.set(__self__, "wait_on_complete", wait_on_complete)
 
     @property
     @pulumi.getter
-    def contract(self) -> pulumi.Input[str]:
-        """
-        The contract ID.
-        """
-        return pulumi.get(self, "contract")
+    def domain(self) -> pulumi.Input[str]:
+        return pulumi.get(self, "domain")
 
-    @contract.setter
-    def contract(self, value: pulumi.Input[str]):
-        pulumi.set(self, "contract", value)
+    @domain.setter
+    def domain(self, value: pulumi.Input[str]):
+        pulumi.set(self, "domain", value)
 
     @property
     @pulumi.getter
-    def type(self) -> pulumi.Input[str]:
-        """
-        Whether the zone is `primary`, `secondary`, or `alias`.
-        """
-        return pulumi.get(self, "type")
+    def city(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "city")
 
-    @type.setter
-    def type(self, value: pulumi.Input[str]):
-        pulumi.set(self, "type", value)
+    @city.setter
+    def city(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "city", value)
 
     @property
-    @pulumi.getter
-    def zone(self) -> pulumi.Input[str]:
-        """
-        The domain zone, encapsulating any nested subdomains.
-        """
-        return pulumi.get(self, "zone")
+    @pulumi.getter(name="cloneOf")
+    def clone_of(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "clone_of")
 
-    @zone.setter
-    def zone(self, value: pulumi.Input[str]):
-        pulumi.set(self, "zone", value)
+    @clone_of.setter
+    def clone_of(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "clone_of", value)
 
     @property
-    @pulumi.getter
-    def comment(self) -> Optional[pulumi.Input[str]]:
-        """
-        A descriptive comment.
-        """
-        return pulumi.get(self, "comment")
+    @pulumi.getter(name="cloudServerHostHeaderOverride")
+    def cloud_server_host_header_override(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "cloud_server_host_header_override")
 
-    @comment.setter
-    def comment(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "comment", value)
+    @cloud_server_host_header_override.setter
+    def cloud_server_host_header_override(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "cloud_server_host_header_override", value)
 
     @property
-    @pulumi.getter(name="endCustomerId")
-    def end_customer_id(self) -> Optional[pulumi.Input[str]]:
-        """
-        A free form identifier for the zone.
-        """
-        return pulumi.get(self, "end_customer_id")
+    @pulumi.getter(name="cloudServerTargeting")
+    def cloud_server_targeting(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "cloud_server_targeting")
 
-    @end_customer_id.setter
-    def end_customer_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "end_customer_id", value)
+    @cloud_server_targeting.setter
+    def cloud_server_targeting(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "cloud_server_targeting", value)
 
     @property
     @pulumi.getter
-    def group(self) -> Optional[pulumi.Input[str]]:
-        """
-        The currently selected group ID.
-        """
-        return pulumi.get(self, "group")
+    def continent(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "continent")
 
-    @group.setter
-    def group(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "group", value)
+    @continent.setter
+    def continent(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "continent", value)
 
     @property
     @pulumi.getter
-    def masters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
-        """
-        The names or IP addresses of the nameservers that the zone data should be retrieved from.
-        """
-        return pulumi.get(self, "masters")
+    def country(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "country")
 
-    @masters.setter
-    def masters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
-        pulumi.set(self, "masters", value)
+    @country.setter
+    def country(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "country", value)
 
     @property
-    @pulumi.getter(name="signAndServe")
-    def sign_and_serve(self) -> Optional[pulumi.Input[bool]]:
-        """
-        Whether DNSSEC Sign and Serve is enabled.
-        """
-        return pulumi.get(self, "sign_and_serve")
+    @pulumi.getter(name="defaultLoadObject")
+    def default_load_object(self) -> Optional[pulumi.Input['GtmDatacenterDefaultLoadObjectArgs']]:
+        return pulumi.get(self, "default_load_object")
 
-    @sign_and_serve.setter
-    def sign_and_serve(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "sign_and_serve", value)
+    @default_load_object.setter
+    def default_load_object(self, value: Optional[pulumi.Input['GtmDatacenterDefaultLoadObjectArgs']]):
+        pulumi.set(self, "default_load_object", value)
 
     @property
-    @pulumi.getter(name="signAndServeAlgorithm")
-    def sign_and_serve_algorithm(self) -> Optional[pulumi.Input[str]]:
-        """
-        The algorithm used by Sign and Serve.
-        """
-        return pulumi.get(self, "sign_and_serve_algorithm")
+    @pulumi.getter
+    def latitude(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "latitude")
 
-    @sign_and_serve_algorithm.setter
-    def sign_and_serve_algorithm(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "sign_and_serve_algorithm", value)
+    @latitude.setter
+    def latitude(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "latitude", value)
 
     @property
     @pulumi.getter
-    def target(self) -> Optional[pulumi.Input[str]]:
-        """
-        The name of the zone whose configuration this zone will copy.
-        """
-        return pulumi.get(self, "target")
+    def longitude(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "longitude")
 
-    @target.setter
-    def target(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "target", value)
+    @longitude.setter
+    def longitude(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "longitude", value)
 
     @property
-    @pulumi.getter(name="tsigKey")
-    def tsig_key(self) -> Optional[pulumi.Input['DnsZoneTsigKeyArgs']]:
-        """
-        The TSIG Key used in secure zone transfers. If used, requires these arguments:
-        """
-        return pulumi.get(self, "tsig_key")
+    @pulumi.getter
+    def nickname(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "nickname")
+
+    @nickname.setter
+    def nickname(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "nickname", value)
+
+    @property
+    @pulumi.getter(name="stateOrProvince")
+    def state_or_province(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "state_or_province")
+
+    @state_or_province.setter
+    def state_or_province(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "state_or_province", value)
+
+    @property
+    @pulumi.getter(name="waitOnComplete")
+    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "wait_on_complete")
 
-    @tsig_key.setter
-    def tsig_key(self, value: Optional[pulumi.Input['DnsZoneTsigKeyArgs']]):
-        pulumi.set(self, "tsig_key", value)
+    @wait_on_complete.setter
+    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "wait_on_complete", value)
 
 
 @pulumi.input_type
-class _DnsZoneState:
+class _GtmDatacenterState:
     def __init__(__self__, *,
-                 activation_state: Optional[pulumi.Input[str]] = None,
-                 alias_count: Optional[pulumi.Input[int]] = None,
-                 comment: Optional[pulumi.Input[str]] = None,
-                 contract: Optional[pulumi.Input[str]] = None,
-                 end_customer_id: Optional[pulumi.Input[str]] = None,
-                 group: Optional[pulumi.Input[str]] = None,
-                 masters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 sign_and_serve: Optional[pulumi.Input[bool]] = None,
-                 sign_and_serve_algorithm: Optional[pulumi.Input[str]] = None,
-                 target: Optional[pulumi.Input[str]] = None,
-                 tsig_key: Optional[pulumi.Input['DnsZoneTsigKeyArgs']] = None,
-                 type: Optional[pulumi.Input[str]] = None,
-                 version_id: Optional[pulumi.Input[str]] = None,
-                 zone: Optional[pulumi.Input[str]] = None):
+                 city: Optional[pulumi.Input[str]] = None,
+                 clone_of: Optional[pulumi.Input[int]] = None,
+                 cloud_server_host_header_override: Optional[pulumi.Input[bool]] = None,
+                 cloud_server_targeting: Optional[pulumi.Input[bool]] = None,
+                 continent: Optional[pulumi.Input[str]] = None,
+                 country: Optional[pulumi.Input[str]] = None,
+                 datacenter_id: Optional[pulumi.Input[int]] = None,
+                 default_load_object: Optional[pulumi.Input['GtmDatacenterDefaultLoadObjectArgs']] = None,
+                 domain: Optional[pulumi.Input[str]] = None,
+                 latitude: Optional[pulumi.Input[float]] = None,
+                 longitude: Optional[pulumi.Input[float]] = None,
+                 nickname: Optional[pulumi.Input[str]] = None,
+                 ping_interval: Optional[pulumi.Input[int]] = None,
+                 ping_packet_size: Optional[pulumi.Input[int]] = None,
+                 score_penalty: Optional[pulumi.Input[int]] = None,
+                 servermonitor_liveness_count: Optional[pulumi.Input[int]] = None,
+                 servermonitor_load_count: Optional[pulumi.Input[int]] = None,
+                 servermonitor_pool: Optional[pulumi.Input[str]] = None,
+                 state_or_province: Optional[pulumi.Input[str]] = None,
+                 virtual: Optional[pulumi.Input[bool]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None):
         """
-        Input properties used for looking up and filtering DnsZone resources.
-        :param pulumi.Input[str] comment: A descriptive comment.
-        :param pulumi.Input[str] contract: The contract ID.
-        :param pulumi.Input[str] end_customer_id: A free form identifier for the zone.
-        :param pulumi.Input[str] group: The currently selected group ID.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] masters: The names or IP addresses of the nameservers that the zone data should be retrieved from.
-        :param pulumi.Input[bool] sign_and_serve: Whether DNSSEC Sign and Serve is enabled.
-        :param pulumi.Input[str] sign_and_serve_algorithm: The algorithm used by Sign and Serve.
-        :param pulumi.Input[str] target: The name of the zone whose configuration this zone will copy.
-        :param pulumi.Input['DnsZoneTsigKeyArgs'] tsig_key: The TSIG Key used in secure zone transfers. If used, requires these arguments:
-        :param pulumi.Input[str] type: Whether the zone is `primary`, `secondary`, or `alias`.
-        :param pulumi.Input[str] zone: The domain zone, encapsulating any nested subdomains.
+        Input properties used for looking up and filtering GtmDatacenter resources.
         """
-        if activation_state is not None:
-            pulumi.set(__self__, "activation_state", activation_state)
-        if alias_count is not None:
-            pulumi.set(__self__, "alias_count", alias_count)
-        if comment is not None:
-            pulumi.set(__self__, "comment", comment)
-        if contract is not None:
-            pulumi.set(__self__, "contract", contract)
-        if end_customer_id is not None:
-            pulumi.set(__self__, "end_customer_id", end_customer_id)
-        if group is not None:
-            pulumi.set(__self__, "group", group)
-        if masters is not None:
-            pulumi.set(__self__, "masters", masters)
-        if sign_and_serve is not None:
-            pulumi.set(__self__, "sign_and_serve", sign_and_serve)
-        if sign_and_serve_algorithm is not None:
-            pulumi.set(__self__, "sign_and_serve_algorithm", sign_and_serve_algorithm)
-        if target is not None:
-            pulumi.set(__self__, "target", target)
-        if tsig_key is not None:
-            pulumi.set(__self__, "tsig_key", tsig_key)
-        if type is not None:
-            pulumi.set(__self__, "type", type)
-        if version_id is not None:
-            pulumi.set(__self__, "version_id", version_id)
-        if zone is not None:
-            pulumi.set(__self__, "zone", zone)
-
-    @property
-    @pulumi.getter(name="activationState")
-    def activation_state(self) -> Optional[pulumi.Input[str]]:
-        return pulumi.get(self, "activation_state")
-
-    @activation_state.setter
-    def activation_state(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "activation_state", value)
-
-    @property
-    @pulumi.getter(name="aliasCount")
-    def alias_count(self) -> Optional[pulumi.Input[int]]:
-        return pulumi.get(self, "alias_count")
-
-    @alias_count.setter
-    def alias_count(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "alias_count", value)
+        if city is not None:
+            pulumi.set(__self__, "city", city)
+        if clone_of is not None:
+            pulumi.set(__self__, "clone_of", clone_of)
+        if cloud_server_host_header_override is not None:
+            pulumi.set(__self__, "cloud_server_host_header_override", cloud_server_host_header_override)
+        if cloud_server_targeting is not None:
+            pulumi.set(__self__, "cloud_server_targeting", cloud_server_targeting)
+        if continent is not None:
+            pulumi.set(__self__, "continent", continent)
+        if country is not None:
+            pulumi.set(__self__, "country", country)
+        if datacenter_id is not None:
+            pulumi.set(__self__, "datacenter_id", datacenter_id)
+        if default_load_object is not None:
+            pulumi.set(__self__, "default_load_object", default_load_object)
+        if domain is not None:
+            pulumi.set(__self__, "domain", domain)
+        if latitude is not None:
+            pulumi.set(__self__, "latitude", latitude)
+        if longitude is not None:
+            pulumi.set(__self__, "longitude", longitude)
+        if nickname is not None:
+            pulumi.set(__self__, "nickname", nickname)
+        if ping_interval is not None:
+            pulumi.set(__self__, "ping_interval", ping_interval)
+        if ping_packet_size is not None:
+            pulumi.set(__self__, "ping_packet_size", ping_packet_size)
+        if score_penalty is not None:
+            pulumi.set(__self__, "score_penalty", score_penalty)
+        if servermonitor_liveness_count is not None:
+            pulumi.set(__self__, "servermonitor_liveness_count", servermonitor_liveness_count)
+        if servermonitor_load_count is not None:
+            pulumi.set(__self__, "servermonitor_load_count", servermonitor_load_count)
+        if servermonitor_pool is not None:
+            pulumi.set(__self__, "servermonitor_pool", servermonitor_pool)
+        if state_or_province is not None:
+            pulumi.set(__self__, "state_or_province", state_or_province)
+        if virtual is not None:
+            pulumi.set(__self__, "virtual", virtual)
+        if wait_on_complete is not None:
+            pulumi.set(__self__, "wait_on_complete", wait_on_complete)
 
     @property
     @pulumi.getter
-    def comment(self) -> Optional[pulumi.Input[str]]:
-        """
-        A descriptive comment.
-        """
-        return pulumi.get(self, "comment")
+    def city(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "city")
 
-    @comment.setter
-    def comment(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "comment", value)
+    @city.setter
+    def city(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "city", value)
 
     @property
-    @pulumi.getter
-    def contract(self) -> Optional[pulumi.Input[str]]:
-        """
-        The contract ID.
-        """
-        return pulumi.get(self, "contract")
+    @pulumi.getter(name="cloneOf")
+    def clone_of(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "clone_of")
 
-    @contract.setter
-    def contract(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "contract", value)
+    @clone_of.setter
+    def clone_of(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "clone_of", value)
 
     @property
-    @pulumi.getter(name="endCustomerId")
-    def end_customer_id(self) -> Optional[pulumi.Input[str]]:
-        """
-        A free form identifier for the zone.
-        """
-        return pulumi.get(self, "end_customer_id")
+    @pulumi.getter(name="cloudServerHostHeaderOverride")
+    def cloud_server_host_header_override(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "cloud_server_host_header_override")
+
+    @cloud_server_host_header_override.setter
+    def cloud_server_host_header_override(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "cloud_server_host_header_override", value)
 
-    @end_customer_id.setter
-    def end_customer_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "end_customer_id", value)
+    @property
+    @pulumi.getter(name="cloudServerTargeting")
+    def cloud_server_targeting(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "cloud_server_targeting")
+
+    @cloud_server_targeting.setter
+    def cloud_server_targeting(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "cloud_server_targeting", value)
 
     @property
     @pulumi.getter
-    def group(self) -> Optional[pulumi.Input[str]]:
-        """
-        The currently selected group ID.
-        """
-        return pulumi.get(self, "group")
+    def continent(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "continent")
 
-    @group.setter
-    def group(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "group", value)
+    @continent.setter
+    def continent(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "continent", value)
 
     @property
     @pulumi.getter
-    def masters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
-        """
-        The names or IP addresses of the nameservers that the zone data should be retrieved from.
-        """
-        return pulumi.get(self, "masters")
+    def country(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "country")
 
-    @masters.setter
-    def masters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
-        pulumi.set(self, "masters", value)
+    @country.setter
+    def country(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "country", value)
 
     @property
-    @pulumi.getter(name="signAndServe")
-    def sign_and_serve(self) -> Optional[pulumi.Input[bool]]:
-        """
-        Whether DNSSEC Sign and Serve is enabled.
-        """
-        return pulumi.get(self, "sign_and_serve")
+    @pulumi.getter(name="datacenterId")
+    def datacenter_id(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "datacenter_id")
 
-    @sign_and_serve.setter
-    def sign_and_serve(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "sign_and_serve", value)
+    @datacenter_id.setter
+    def datacenter_id(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "datacenter_id", value)
 
     @property
-    @pulumi.getter(name="signAndServeAlgorithm")
-    def sign_and_serve_algorithm(self) -> Optional[pulumi.Input[str]]:
-        """
-        The algorithm used by Sign and Serve.
-        """
-        return pulumi.get(self, "sign_and_serve_algorithm")
+    @pulumi.getter(name="defaultLoadObject")
+    def default_load_object(self) -> Optional[pulumi.Input['GtmDatacenterDefaultLoadObjectArgs']]:
+        return pulumi.get(self, "default_load_object")
 
-    @sign_and_serve_algorithm.setter
-    def sign_and_serve_algorithm(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "sign_and_serve_algorithm", value)
+    @default_load_object.setter
+    def default_load_object(self, value: Optional[pulumi.Input['GtmDatacenterDefaultLoadObjectArgs']]):
+        pulumi.set(self, "default_load_object", value)
 
     @property
     @pulumi.getter
-    def target(self) -> Optional[pulumi.Input[str]]:
-        """
-        The name of the zone whose configuration this zone will copy.
-        """
-        return pulumi.get(self, "target")
+    def domain(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "domain")
 
-    @target.setter
-    def target(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "target", value)
+    @domain.setter
+    def domain(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "domain", value)
 
     @property
-    @pulumi.getter(name="tsigKey")
-    def tsig_key(self) -> Optional[pulumi.Input['DnsZoneTsigKeyArgs']]:
-        """
-        The TSIG Key used in secure zone transfers. If used, requires these arguments:
-        """
-        return pulumi.get(self, "tsig_key")
+    @pulumi.getter
+    def latitude(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "latitude")
 
-    @tsig_key.setter
-    def tsig_key(self, value: Optional[pulumi.Input['DnsZoneTsigKeyArgs']]):
-        pulumi.set(self, "tsig_key", value)
+    @latitude.setter
+    def latitude(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "latitude", value)
 
     @property
     @pulumi.getter
-    def type(self) -> Optional[pulumi.Input[str]]:
-        """
-        Whether the zone is `primary`, `secondary`, or `alias`.
-        """
-        return pulumi.get(self, "type")
+    def longitude(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "longitude")
 
-    @type.setter
-    def type(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "type", value)
+    @longitude.setter
+    def longitude(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "longitude", value)
 
     @property
-    @pulumi.getter(name="versionId")
-    def version_id(self) -> Optional[pulumi.Input[str]]:
-        return pulumi.get(self, "version_id")
+    @pulumi.getter
+    def nickname(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "nickname")
 
-    @version_id.setter
-    def version_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "version_id", value)
+    @nickname.setter
+    def nickname(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "nickname", value)
+
+    @property
+    @pulumi.getter(name="pingInterval")
+    def ping_interval(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "ping_interval")
+
+    @ping_interval.setter
+    def ping_interval(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "ping_interval", value)
+
+    @property
+    @pulumi.getter(name="pingPacketSize")
+    def ping_packet_size(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "ping_packet_size")
+
+    @ping_packet_size.setter
+    def ping_packet_size(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "ping_packet_size", value)
+
+    @property
+    @pulumi.getter(name="scorePenalty")
+    def score_penalty(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "score_penalty")
+
+    @score_penalty.setter
+    def score_penalty(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "score_penalty", value)
+
+    @property
+    @pulumi.getter(name="servermonitorLivenessCount")
+    def servermonitor_liveness_count(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "servermonitor_liveness_count")
+
+    @servermonitor_liveness_count.setter
+    def servermonitor_liveness_count(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "servermonitor_liveness_count", value)
+
+    @property
+    @pulumi.getter(name="servermonitorLoadCount")
+    def servermonitor_load_count(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "servermonitor_load_count")
+
+    @servermonitor_load_count.setter
+    def servermonitor_load_count(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "servermonitor_load_count", value)
+
+    @property
+    @pulumi.getter(name="servermonitorPool")
+    def servermonitor_pool(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "servermonitor_pool")
+
+    @servermonitor_pool.setter
+    def servermonitor_pool(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "servermonitor_pool", value)
+
+    @property
+    @pulumi.getter(name="stateOrProvince")
+    def state_or_province(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "state_or_province")
+
+    @state_or_province.setter
+    def state_or_province(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "state_or_province", value)
 
     @property
     @pulumi.getter
-    def zone(self) -> Optional[pulumi.Input[str]]:
-        """
-        The domain zone, encapsulating any nested subdomains.
-        """
-        return pulumi.get(self, "zone")
+    def virtual(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "virtual")
+
+    @virtual.setter
+    def virtual(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "virtual", value)
+
+    @property
+    @pulumi.getter(name="waitOnComplete")
+    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "wait_on_complete")
 
-    @zone.setter
-    def zone(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "zone", value)
+    @wait_on_complete.setter
+    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "wait_on_complete", value)
 
 
-warnings.warn("""akamai.edgedns.DnsZone has been deprecated in favor of akamai.DnsZone""", DeprecationWarning)
+warnings.warn("""akamai.trafficmanagement.GtmDatacenter has been deprecated in favor of akamai.GtmDatacenter""", DeprecationWarning)
 
 
-class DnsZone(pulumi.CustomResource):
-    warnings.warn("""akamai.edgedns.DnsZone has been deprecated in favor of akamai.DnsZone""", DeprecationWarning)
+class GtmDatacenter(pulumi.CustomResource):
+    warnings.warn("""akamai.trafficmanagement.GtmDatacenter has been deprecated in favor of akamai.GtmDatacenter""", DeprecationWarning)
 
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 comment: Optional[pulumi.Input[str]] = None,
-                 contract: Optional[pulumi.Input[str]] = None,
-                 end_customer_id: Optional[pulumi.Input[str]] = None,
-                 group: Optional[pulumi.Input[str]] = None,
-                 masters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 sign_and_serve: Optional[pulumi.Input[bool]] = None,
-                 sign_and_serve_algorithm: Optional[pulumi.Input[str]] = None,
-                 target: Optional[pulumi.Input[str]] = None,
-                 tsig_key: Optional[pulumi.Input[pulumi.InputType['DnsZoneTsigKeyArgs']]] = None,
-                 type: Optional[pulumi.Input[str]] = None,
-                 zone: Optional[pulumi.Input[str]] = None,
+                 city: Optional[pulumi.Input[str]] = None,
+                 clone_of: Optional[pulumi.Input[int]] = None,
+                 cloud_server_host_header_override: Optional[pulumi.Input[bool]] = None,
+                 cloud_server_targeting: Optional[pulumi.Input[bool]] = None,
+                 continent: Optional[pulumi.Input[str]] = None,
+                 country: Optional[pulumi.Input[str]] = None,
+                 default_load_object: Optional[pulumi.Input[pulumi.InputType['GtmDatacenterDefaultLoadObjectArgs']]] = None,
+                 domain: Optional[pulumi.Input[str]] = None,
+                 latitude: Optional[pulumi.Input[float]] = None,
+                 longitude: Optional[pulumi.Input[float]] = None,
+                 nickname: Optional[pulumi.Input[str]] = None,
+                 state_or_province: Optional[pulumi.Input[str]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
                  __props__=None):
         """
-        Create a DnsZone resource with the given unique name, props, and options.
+        Create a GtmDatacenter resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] comment: A descriptive comment.
-        :param pulumi.Input[str] contract: The contract ID.
-        :param pulumi.Input[str] end_customer_id: A free form identifier for the zone.
-        :param pulumi.Input[str] group: The currently selected group ID.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] masters: The names or IP addresses of the nameservers that the zone data should be retrieved from.
-        :param pulumi.Input[bool] sign_and_serve: Whether DNSSEC Sign and Serve is enabled.
-        :param pulumi.Input[str] sign_and_serve_algorithm: The algorithm used by Sign and Serve.
-        :param pulumi.Input[str] target: The name of the zone whose configuration this zone will copy.
-        :param pulumi.Input[pulumi.InputType['DnsZoneTsigKeyArgs']] tsig_key: The TSIG Key used in secure zone transfers. If used, requires these arguments:
-        :param pulumi.Input[str] type: Whether the zone is `primary`, `secondary`, or `alias`.
-        :param pulumi.Input[str] zone: The domain zone, encapsulating any nested subdomains.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: DnsZoneArgs,
+                 args: GtmDatacenterArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        Create a DnsZone resource with the given unique name, props, and options.
+        Create a GtmDatacenter resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param DnsZoneArgs args: The arguments to use to populate this resource's properties.
+        :param GtmDatacenterArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(DnsZoneArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(GtmDatacenterArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 comment: Optional[pulumi.Input[str]] = None,
-                 contract: Optional[pulumi.Input[str]] = None,
-                 end_customer_id: Optional[pulumi.Input[str]] = None,
-                 group: Optional[pulumi.Input[str]] = None,
-                 masters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 sign_and_serve: Optional[pulumi.Input[bool]] = None,
-                 sign_and_serve_algorithm: Optional[pulumi.Input[str]] = None,
-                 target: Optional[pulumi.Input[str]] = None,
-                 tsig_key: Optional[pulumi.Input[pulumi.InputType['DnsZoneTsigKeyArgs']]] = None,
-                 type: Optional[pulumi.Input[str]] = None,
-                 zone: Optional[pulumi.Input[str]] = None,
+                 city: Optional[pulumi.Input[str]] = None,
+                 clone_of: Optional[pulumi.Input[int]] = None,
+                 cloud_server_host_header_override: Optional[pulumi.Input[bool]] = None,
+                 cloud_server_targeting: Optional[pulumi.Input[bool]] = None,
+                 continent: Optional[pulumi.Input[str]] = None,
+                 country: Optional[pulumi.Input[str]] = None,
+                 default_load_object: Optional[pulumi.Input[pulumi.InputType['GtmDatacenterDefaultLoadObjectArgs']]] = None,
+                 domain: Optional[pulumi.Input[str]] = None,
+                 latitude: Optional[pulumi.Input[float]] = None,
+                 longitude: Optional[pulumi.Input[float]] = None,
+                 nickname: Optional[pulumi.Input[str]] = None,
+                 state_or_province: Optional[pulumi.Input[str]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
                  __props__=None):
-        pulumi.log.warn("""DnsZone is deprecated: akamai.edgedns.DnsZone has been deprecated in favor of akamai.DnsZone""")
+        pulumi.log.warn("""GtmDatacenter is deprecated: akamai.trafficmanagement.GtmDatacenter has been deprecated in favor of akamai.GtmDatacenter""")
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = DnsZoneArgs.__new__(DnsZoneArgs)
+            __props__ = GtmDatacenterArgs.__new__(GtmDatacenterArgs)
 
-            __props__.__dict__["comment"] = comment
-            if contract is None and not opts.urn:
-                raise TypeError("Missing required property 'contract'")
-            __props__.__dict__["contract"] = contract
-            __props__.__dict__["end_customer_id"] = end_customer_id
-            __props__.__dict__["group"] = group
-            __props__.__dict__["masters"] = masters
-            __props__.__dict__["sign_and_serve"] = sign_and_serve
-            __props__.__dict__["sign_and_serve_algorithm"] = sign_and_serve_algorithm
-            __props__.__dict__["target"] = target
-            __props__.__dict__["tsig_key"] = tsig_key
-            if type is None and not opts.urn:
-                raise TypeError("Missing required property 'type'")
-            __props__.__dict__["type"] = type
-            if zone is None and not opts.urn:
-                raise TypeError("Missing required property 'zone'")
-            __props__.__dict__["zone"] = zone
-            __props__.__dict__["activation_state"] = None
-            __props__.__dict__["alias_count"] = None
-            __props__.__dict__["version_id"] = None
-        super(DnsZone, __self__).__init__(
-            'akamai:edgedns/dnsZone:DnsZone',
+            __props__.__dict__["city"] = city
+            __props__.__dict__["clone_of"] = clone_of
+            __props__.__dict__["cloud_server_host_header_override"] = cloud_server_host_header_override
+            __props__.__dict__["cloud_server_targeting"] = cloud_server_targeting
+            __props__.__dict__["continent"] = continent
+            __props__.__dict__["country"] = country
+            __props__.__dict__["default_load_object"] = default_load_object
+            if domain is None and not opts.urn:
+                raise TypeError("Missing required property 'domain'")
+            __props__.__dict__["domain"] = domain
+            __props__.__dict__["latitude"] = latitude
+            __props__.__dict__["longitude"] = longitude
+            __props__.__dict__["nickname"] = nickname
+            __props__.__dict__["state_or_province"] = state_or_province
+            __props__.__dict__["wait_on_complete"] = wait_on_complete
+            __props__.__dict__["datacenter_id"] = None
+            __props__.__dict__["ping_interval"] = None
+            __props__.__dict__["ping_packet_size"] = None
+            __props__.__dict__["score_penalty"] = None
+            __props__.__dict__["servermonitor_liveness_count"] = None
+            __props__.__dict__["servermonitor_load_count"] = None
+            __props__.__dict__["servermonitor_pool"] = None
+            __props__.__dict__["virtual"] = None
+        super(GtmDatacenter, __self__).__init__(
+            'akamai:trafficmanagement/gtmDatacenter:GtmDatacenter',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
-            activation_state: Optional[pulumi.Input[str]] = None,
-            alias_count: Optional[pulumi.Input[int]] = None,
-            comment: Optional[pulumi.Input[str]] = None,
-            contract: Optional[pulumi.Input[str]] = None,
-            end_customer_id: Optional[pulumi.Input[str]] = None,
-            group: Optional[pulumi.Input[str]] = None,
-            masters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-            sign_and_serve: Optional[pulumi.Input[bool]] = None,
-            sign_and_serve_algorithm: Optional[pulumi.Input[str]] = None,
-            target: Optional[pulumi.Input[str]] = None,
-            tsig_key: Optional[pulumi.Input[pulumi.InputType['DnsZoneTsigKeyArgs']]] = None,
-            type: Optional[pulumi.Input[str]] = None,
-            version_id: Optional[pulumi.Input[str]] = None,
-            zone: Optional[pulumi.Input[str]] = None) -> 'DnsZone':
+            city: Optional[pulumi.Input[str]] = None,
+            clone_of: Optional[pulumi.Input[int]] = None,
+            cloud_server_host_header_override: Optional[pulumi.Input[bool]] = None,
+            cloud_server_targeting: Optional[pulumi.Input[bool]] = None,
+            continent: Optional[pulumi.Input[str]] = None,
+            country: Optional[pulumi.Input[str]] = None,
+            datacenter_id: Optional[pulumi.Input[int]] = None,
+            default_load_object: Optional[pulumi.Input[pulumi.InputType['GtmDatacenterDefaultLoadObjectArgs']]] = None,
+            domain: Optional[pulumi.Input[str]] = None,
+            latitude: Optional[pulumi.Input[float]] = None,
+            longitude: Optional[pulumi.Input[float]] = None,
+            nickname: Optional[pulumi.Input[str]] = None,
+            ping_interval: Optional[pulumi.Input[int]] = None,
+            ping_packet_size: Optional[pulumi.Input[int]] = None,
+            score_penalty: Optional[pulumi.Input[int]] = None,
+            servermonitor_liveness_count: Optional[pulumi.Input[int]] = None,
+            servermonitor_load_count: Optional[pulumi.Input[int]] = None,
+            servermonitor_pool: Optional[pulumi.Input[str]] = None,
+            state_or_province: Optional[pulumi.Input[str]] = None,
+            virtual: Optional[pulumi.Input[bool]] = None,
+            wait_on_complete: Optional[pulumi.Input[bool]] = None) -> 'GtmDatacenter':
         """
-        Get an existing DnsZone resource's state with the given name, id, and optional extra
+        Get an existing GtmDatacenter resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] comment: A descriptive comment.
-        :param pulumi.Input[str] contract: The contract ID.
-        :param pulumi.Input[str] end_customer_id: A free form identifier for the zone.
-        :param pulumi.Input[str] group: The currently selected group ID.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] masters: The names or IP addresses of the nameservers that the zone data should be retrieved from.
-        :param pulumi.Input[bool] sign_and_serve: Whether DNSSEC Sign and Serve is enabled.
-        :param pulumi.Input[str] sign_and_serve_algorithm: The algorithm used by Sign and Serve.
-        :param pulumi.Input[str] target: The name of the zone whose configuration this zone will copy.
-        :param pulumi.Input[pulumi.InputType['DnsZoneTsigKeyArgs']] tsig_key: The TSIG Key used in secure zone transfers. If used, requires these arguments:
-        :param pulumi.Input[str] type: Whether the zone is `primary`, `secondary`, or `alias`.
-        :param pulumi.Input[str] zone: The domain zone, encapsulating any nested subdomains.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _DnsZoneState.__new__(_DnsZoneState)
+        __props__ = _GtmDatacenterState.__new__(_GtmDatacenterState)
+
+        __props__.__dict__["city"] = city
+        __props__.__dict__["clone_of"] = clone_of
+        __props__.__dict__["cloud_server_host_header_override"] = cloud_server_host_header_override
+        __props__.__dict__["cloud_server_targeting"] = cloud_server_targeting
+        __props__.__dict__["continent"] = continent
+        __props__.__dict__["country"] = country
+        __props__.__dict__["datacenter_id"] = datacenter_id
+        __props__.__dict__["default_load_object"] = default_load_object
+        __props__.__dict__["domain"] = domain
+        __props__.__dict__["latitude"] = latitude
+        __props__.__dict__["longitude"] = longitude
+        __props__.__dict__["nickname"] = nickname
+        __props__.__dict__["ping_interval"] = ping_interval
+        __props__.__dict__["ping_packet_size"] = ping_packet_size
+        __props__.__dict__["score_penalty"] = score_penalty
+        __props__.__dict__["servermonitor_liveness_count"] = servermonitor_liveness_count
+        __props__.__dict__["servermonitor_load_count"] = servermonitor_load_count
+        __props__.__dict__["servermonitor_pool"] = servermonitor_pool
+        __props__.__dict__["state_or_province"] = state_or_province
+        __props__.__dict__["virtual"] = virtual
+        __props__.__dict__["wait_on_complete"] = wait_on_complete
+        return GtmDatacenter(resource_name, opts=opts, __props__=__props__)
 
-        __props__.__dict__["activation_state"] = activation_state
-        __props__.__dict__["alias_count"] = alias_count
-        __props__.__dict__["comment"] = comment
-        __props__.__dict__["contract"] = contract
-        __props__.__dict__["end_customer_id"] = end_customer_id
-        __props__.__dict__["group"] = group
-        __props__.__dict__["masters"] = masters
-        __props__.__dict__["sign_and_serve"] = sign_and_serve
-        __props__.__dict__["sign_and_serve_algorithm"] = sign_and_serve_algorithm
-        __props__.__dict__["target"] = target
-        __props__.__dict__["tsig_key"] = tsig_key
-        __props__.__dict__["type"] = type
-        __props__.__dict__["version_id"] = version_id
-        __props__.__dict__["zone"] = zone
-        return DnsZone(resource_name, opts=opts, __props__=__props__)
+    @property
+    @pulumi.getter
+    def city(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "city")
 
     @property
-    @pulumi.getter(name="activationState")
-    def activation_state(self) -> pulumi.Output[str]:
-        return pulumi.get(self, "activation_state")
+    @pulumi.getter(name="cloneOf")
+    def clone_of(self) -> pulumi.Output[Optional[int]]:
+        return pulumi.get(self, "clone_of")
 
     @property
-    @pulumi.getter(name="aliasCount")
-    def alias_count(self) -> pulumi.Output[int]:
-        return pulumi.get(self, "alias_count")
+    @pulumi.getter(name="cloudServerHostHeaderOverride")
+    def cloud_server_host_header_override(self) -> pulumi.Output[Optional[bool]]:
+        return pulumi.get(self, "cloud_server_host_header_override")
+
+    @property
+    @pulumi.getter(name="cloudServerTargeting")
+    def cloud_server_targeting(self) -> pulumi.Output[Optional[bool]]:
+        return pulumi.get(self, "cloud_server_targeting")
 
     @property
     @pulumi.getter
-    def comment(self) -> pulumi.Output[Optional[str]]:
-        """
-        A descriptive comment.
-        """
-        return pulumi.get(self, "comment")
+    def continent(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "continent")
 
     @property
     @pulumi.getter
-    def contract(self) -> pulumi.Output[str]:
-        """
-        The contract ID.
-        """
-        return pulumi.get(self, "contract")
+    def country(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "country")
 
     @property
-    @pulumi.getter(name="endCustomerId")
-    def end_customer_id(self) -> pulumi.Output[Optional[str]]:
-        """
-        A free form identifier for the zone.
-        """
-        return pulumi.get(self, "end_customer_id")
+    @pulumi.getter(name="datacenterId")
+    def datacenter_id(self) -> pulumi.Output[int]:
+        return pulumi.get(self, "datacenter_id")
 
     @property
-    @pulumi.getter
-    def group(self) -> pulumi.Output[Optional[str]]:
-        """
-        The currently selected group ID.
-        """
-        return pulumi.get(self, "group")
+    @pulumi.getter(name="defaultLoadObject")
+    def default_load_object(self) -> pulumi.Output[Optional['outputs.GtmDatacenterDefaultLoadObject']]:
+        return pulumi.get(self, "default_load_object")
 
     @property
     @pulumi.getter
-    def masters(self) -> pulumi.Output[Optional[Sequence[str]]]:
-        """
-        The names or IP addresses of the nameservers that the zone data should be retrieved from.
-        """
-        return pulumi.get(self, "masters")
+    def domain(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "domain")
 
     @property
-    @pulumi.getter(name="signAndServe")
-    def sign_and_serve(self) -> pulumi.Output[Optional[bool]]:
-        """
-        Whether DNSSEC Sign and Serve is enabled.
-        """
-        return pulumi.get(self, "sign_and_serve")
+    @pulumi.getter
+    def latitude(self) -> pulumi.Output[Optional[float]]:
+        return pulumi.get(self, "latitude")
 
     @property
-    @pulumi.getter(name="signAndServeAlgorithm")
-    def sign_and_serve_algorithm(self) -> pulumi.Output[Optional[str]]:
-        """
-        The algorithm used by Sign and Serve.
-        """
-        return pulumi.get(self, "sign_and_serve_algorithm")
+    @pulumi.getter
+    def longitude(self) -> pulumi.Output[Optional[float]]:
+        return pulumi.get(self, "longitude")
 
     @property
     @pulumi.getter
-    def target(self) -> pulumi.Output[Optional[str]]:
-        """
-        The name of the zone whose configuration this zone will copy.
-        """
-        return pulumi.get(self, "target")
+    def nickname(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "nickname")
 
     @property
-    @pulumi.getter(name="tsigKey")
-    def tsig_key(self) -> pulumi.Output[Optional['outputs.DnsZoneTsigKey']]:
-        """
-        The TSIG Key used in secure zone transfers. If used, requires these arguments:
-        """
-        return pulumi.get(self, "tsig_key")
+    @pulumi.getter(name="pingInterval")
+    def ping_interval(self) -> pulumi.Output[int]:
+        return pulumi.get(self, "ping_interval")
 
     @property
-    @pulumi.getter
-    def type(self) -> pulumi.Output[str]:
-        """
-        Whether the zone is `primary`, `secondary`, or `alias`.
-        """
-        return pulumi.get(self, "type")
+    @pulumi.getter(name="pingPacketSize")
+    def ping_packet_size(self) -> pulumi.Output[int]:
+        return pulumi.get(self, "ping_packet_size")
+
+    @property
+    @pulumi.getter(name="scorePenalty")
+    def score_penalty(self) -> pulumi.Output[int]:
+        return pulumi.get(self, "score_penalty")
+
+    @property
+    @pulumi.getter(name="servermonitorLivenessCount")
+    def servermonitor_liveness_count(self) -> pulumi.Output[int]:
+        return pulumi.get(self, "servermonitor_liveness_count")
 
     @property
-    @pulumi.getter(name="versionId")
-    def version_id(self) -> pulumi.Output[str]:
-        return pulumi.get(self, "version_id")
+    @pulumi.getter(name="servermonitorLoadCount")
+    def servermonitor_load_count(self) -> pulumi.Output[int]:
+        return pulumi.get(self, "servermonitor_load_count")
+
+    @property
+    @pulumi.getter(name="servermonitorPool")
+    def servermonitor_pool(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "servermonitor_pool")
+
+    @property
+    @pulumi.getter(name="stateOrProvince")
+    def state_or_province(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "state_or_province")
 
     @property
     @pulumi.getter
-    def zone(self) -> pulumi.Output[str]:
-        """
-        The domain zone, encapsulating any nested subdomains.
-        """
-        return pulumi.get(self, "zone")
+    def virtual(self) -> pulumi.Output[bool]:
+        return pulumi.get(self, "virtual")
+
+    @property
+    @pulumi.getter(name="waitOnComplete")
+    def wait_on_complete(self) -> pulumi.Output[Optional[bool]]:
+        return pulumi.get(self, "wait_on_complete")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/edgedns/get_authorities_set.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/edgedns/get_authorities_set.py`

 * *Files 18% similar despite different names*

```diff
@@ -63,34 +63,15 @@
             contract=self.contract,
             id=self.id)
 
 
 def get_authorities_set(contract: Optional[str] = None,
                         opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAuthoritiesSetResult:
     """
-    Use the _get_authorities_set_ data source to retrieve a contract's authorities set. You use the authorities set when creating new zones.
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    example = akamai.get_authorities_set(contract="ctr_1-AB123")
-    ```
-    ## Attributes reference
-
-    This data source supports this attribute:
-
-    * `authorities` - A list of authorities.
-
-
-    :param str contract: The contract ID.
+    Use this data source to access information about an existing resource.
     """
     pulumi.log.warn("""get_authorities_set is deprecated: akamai.edgedns.getAuthoritiesSet has been deprecated in favor of akamai.getAuthoritiesSet""")
     __args__ = dict()
     __args__['contract'] = contract
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:edgedns/getAuthoritiesSet:getAuthoritiesSet', __args__, opts=opts, typ=GetAuthoritiesSetResult).value
 
@@ -100,30 +81,11 @@
         id=__ret__.id)
 
 
 @_utilities.lift_output_func(get_authorities_set)
 def get_authorities_set_output(contract: Optional[pulumi.Input[str]] = None,
                                opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAuthoritiesSetResult]:
     """
-    Use the _get_authorities_set_ data source to retrieve a contract's authorities set. You use the authorities set when creating new zones.
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    example = akamai.get_authorities_set(contract="ctr_1-AB123")
-    ```
-    ## Attributes reference
-
-    This data source supports this attribute:
-
-    * `authorities` - A list of authorities.
-
-
-    :param str contract: The contract ID.
+    Use this data source to access information about an existing resource.
     """
     pulumi.log.warn("""get_authorities_set is deprecated: akamai.edgedns.getAuthoritiesSet has been deprecated in favor of akamai.getAuthoritiesSet""")
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/edgedns/get_dns_record_set.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/edgedns/get_dns_record_set.py`

 * *Files identical despite different names*

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/edgedns/outputs.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/edgedns/outputs.py`

 * *Files 20% similar despite different names*

```diff
@@ -15,41 +15,27 @@
 
 @pulumi.output_type
 class DnsZoneTsigKey(dict):
     def __init__(__self__, *,
                  algorithm: str,
                  name: str,
                  secret: str):
-        """
-        :param str algorithm: The hashing algorithm.
-        :param str name: The key name.
-        :param str secret: String known between transfer endpoints.
-        """
         pulumi.set(__self__, "algorithm", algorithm)
         pulumi.set(__self__, "name", name)
         pulumi.set(__self__, "secret", secret)
 
     @property
     @pulumi.getter
     def algorithm(self) -> str:
-        """
-        The hashing algorithm.
-        """
         return pulumi.get(self, "algorithm")
 
     @property
     @pulumi.getter
     def name(self) -> str:
-        """
-        The key name.
-        """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter
     def secret(self) -> str:
-        """
-        String known between transfer endpoints.
-        """
         return pulumi.get(self, "secret")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_advanced_settings_prefetch.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_waf_mode.py`

 * *Files 24% similar despite different names*

```diff
@@ -6,146 +6,155 @@
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
 __all__ = [
-    'GetAppSecAdvancedSettingsPrefetchResult',
-    'AwaitableGetAppSecAdvancedSettingsPrefetchResult',
-    'get_app_sec_advanced_settings_prefetch',
-    'get_app_sec_advanced_settings_prefetch_output',
+    'GetAppSecWafModeResult',
+    'AwaitableGetAppSecWafModeResult',
+    'get_app_sec_waf_mode',
+    'get_app_sec_waf_mode_output',
 ]
 
 @pulumi.output_type
-class GetAppSecAdvancedSettingsPrefetchResult:
+class GetAppSecWafModeResult:
     """
-    A collection of values returned by getAppSecAdvancedSettingsPrefetch.
+    A collection of values returned by getAppSecWafMode.
     """
-    def __init__(__self__, config_id=None, id=None, json=None, output_text=None):
+    def __init__(__self__, config_id=None, current_ruleset=None, eval_expiration_date=None, eval_ruleset=None, eval_status=None, id=None, json=None, mode=None, output_text=None, security_policy_id=None):
         if config_id and not isinstance(config_id, int):
             raise TypeError("Expected argument 'config_id' to be a int")
         pulumi.set(__self__, "config_id", config_id)
+        if current_ruleset and not isinstance(current_ruleset, str):
+            raise TypeError("Expected argument 'current_ruleset' to be a str")
+        pulumi.set(__self__, "current_ruleset", current_ruleset)
+        if eval_expiration_date and not isinstance(eval_expiration_date, str):
+            raise TypeError("Expected argument 'eval_expiration_date' to be a str")
+        pulumi.set(__self__, "eval_expiration_date", eval_expiration_date)
+        if eval_ruleset and not isinstance(eval_ruleset, str):
+            raise TypeError("Expected argument 'eval_ruleset' to be a str")
+        pulumi.set(__self__, "eval_ruleset", eval_ruleset)
+        if eval_status and not isinstance(eval_status, str):
+            raise TypeError("Expected argument 'eval_status' to be a str")
+        pulumi.set(__self__, "eval_status", eval_status)
         if id and not isinstance(id, str):
             raise TypeError("Expected argument 'id' to be a str")
         pulumi.set(__self__, "id", id)
         if json and not isinstance(json, str):
             raise TypeError("Expected argument 'json' to be a str")
         pulumi.set(__self__, "json", json)
+        if mode and not isinstance(mode, str):
+            raise TypeError("Expected argument 'mode' to be a str")
+        pulumi.set(__self__, "mode", mode)
         if output_text and not isinstance(output_text, str):
             raise TypeError("Expected argument 'output_text' to be a str")
         pulumi.set(__self__, "output_text", output_text)
+        if security_policy_id and not isinstance(security_policy_id, str):
+            raise TypeError("Expected argument 'security_policy_id' to be a str")
+        pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> int:
         return pulumi.get(self, "config_id")
 
     @property
+    @pulumi.getter(name="currentRuleset")
+    def current_ruleset(self) -> str:
+        return pulumi.get(self, "current_ruleset")
+
+    @property
+    @pulumi.getter(name="evalExpirationDate")
+    def eval_expiration_date(self) -> str:
+        return pulumi.get(self, "eval_expiration_date")
+
+    @property
+    @pulumi.getter(name="evalRuleset")
+    def eval_ruleset(self) -> str:
+        return pulumi.get(self, "eval_ruleset")
+
+    @property
+    @pulumi.getter(name="evalStatus")
+    def eval_status(self) -> str:
+        return pulumi.get(self, "eval_status")
+
+    @property
     @pulumi.getter
     def id(self) -> str:
         """
         The provider-assigned unique ID for this managed resource.
         """
         return pulumi.get(self, "id")
 
     @property
     @pulumi.getter
     def json(self) -> str:
         return pulumi.get(self, "json")
 
     @property
+    @pulumi.getter
+    def mode(self) -> str:
+        return pulumi.get(self, "mode")
+
+    @property
     @pulumi.getter(name="outputText")
     def output_text(self) -> str:
         return pulumi.get(self, "output_text")
 
+    @property
+    @pulumi.getter(name="securityPolicyId")
+    def security_policy_id(self) -> str:
+        return pulumi.get(self, "security_policy_id")
+
 
-class AwaitableGetAppSecAdvancedSettingsPrefetchResult(GetAppSecAdvancedSettingsPrefetchResult):
+class AwaitableGetAppSecWafModeResult(GetAppSecWafModeResult):
     # pylint: disable=using-constant-test
     def __await__(self):
         if False:
             yield self
-        return GetAppSecAdvancedSettingsPrefetchResult(
+        return GetAppSecWafModeResult(
             config_id=self.config_id,
+            current_ruleset=self.current_ruleset,
+            eval_expiration_date=self.eval_expiration_date,
+            eval_ruleset=self.eval_ruleset,
+            eval_status=self.eval_status,
             id=self.id,
             json=self.json,
-            output_text=self.output_text)
+            mode=self.mode,
+            output_text=self.output_text,
+            security_policy_id=self.security_policy_id)
 
 
-def get_app_sec_advanced_settings_prefetch(config_id: Optional[int] = None,
-                                           opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecAdvancedSettingsPrefetchResult:
+def get_app_sec_waf_mode(config_id: Optional[int] = None,
+                         security_policy_id: Optional[str] = None,
+                         opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecWafModeResult:
     """
-    **Scopes**: Security configuration
-
-    Returns information about your prefetch request settings. By default, Web Application Firewall inspects only external requests  requests originating outside of your firewall or Akamai's edge servers. When prefetch is enabled, requests between your origin servers and Akamai's edge servers can also be inspected by the firewall.
-
-    **Related** **API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/prefetch](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-prefetch)
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    configuration = akamai.get_app_sec_configuration(name="Documentation")
-    prefetch = akamai.get_app_sec_advanced_settings_prefetch(config_id=configuration.config_id)
-    pulumi.export("advancedSettingsPrefetchOutput", prefetch.output_text)
-    pulumi.export("advancedSettingsPrefetchJson", prefetch.json)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `json`. JSON-formatted list of information about the prefetch request settings.
-    - `output_text`. Tabular report showing the prefetch request settings.
-
-
-    :param int config_id: . Unique identifier of the security configuration associated with the prefetch settings.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     __args__['configId'] = config_id
+    __args__['securityPolicyId'] = security_policy_id
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
-    __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecAdvancedSettingsPrefetch:getAppSecAdvancedSettingsPrefetch', __args__, opts=opts, typ=GetAppSecAdvancedSettingsPrefetchResult).value
+    __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecWafMode:getAppSecWafMode', __args__, opts=opts, typ=GetAppSecWafModeResult).value
 
-    return AwaitableGetAppSecAdvancedSettingsPrefetchResult(
+    return AwaitableGetAppSecWafModeResult(
         config_id=__ret__.config_id,
+        current_ruleset=__ret__.current_ruleset,
+        eval_expiration_date=__ret__.eval_expiration_date,
+        eval_ruleset=__ret__.eval_ruleset,
+        eval_status=__ret__.eval_status,
         id=__ret__.id,
         json=__ret__.json,
-        output_text=__ret__.output_text)
+        mode=__ret__.mode,
+        output_text=__ret__.output_text,
+        security_policy_id=__ret__.security_policy_id)
 
 
-@_utilities.lift_output_func(get_app_sec_advanced_settings_prefetch)
-def get_app_sec_advanced_settings_prefetch_output(config_id: Optional[pulumi.Input[int]] = None,
-                                                  opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecAdvancedSettingsPrefetchResult]:
+@_utilities.lift_output_func(get_app_sec_waf_mode)
+def get_app_sec_waf_mode_output(config_id: Optional[pulumi.Input[int]] = None,
+                                security_policy_id: Optional[pulumi.Input[str]] = None,
+                                opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecWafModeResult]:
     """
-    **Scopes**: Security configuration
-
-    Returns information about your prefetch request settings. By default, Web Application Firewall inspects only external requests  requests originating outside of your firewall or Akamai's edge servers. When prefetch is enabled, requests between your origin servers and Akamai's edge servers can also be inspected by the firewall.
-
-    **Related** **API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/advanced-settings/prefetch](https://techdocs.akamai.com/application-security/reference/get-advanced-settings-prefetch)
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    configuration = akamai.get_app_sec_configuration(name="Documentation")
-    prefetch = akamai.get_app_sec_advanced_settings_prefetch(config_id=configuration.config_id)
-    pulumi.export("advancedSettingsPrefetchOutput", prefetch.output_text)
-    pulumi.export("advancedSettingsPrefetchJson", prefetch.json)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `json`. JSON-formatted list of information about the prefetch request settings.
-    - `output_text`. Tabular report showing the prefetch request settings.
-
-
-    :param int config_id: . Unique identifier of the security configuration associated with the prefetch settings.
+    Use this data source to access information about an existing resource.
     """
     ...
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_api_endpoints.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_api_endpoints.py`

 * *Files 26% similar despite different names*

```diff
@@ -99,43 +99,15 @@
 
 
 def get_app_sec_api_endpoints(api_name: Optional[str] = None,
                               config_id: Optional[int] = None,
                               security_policy_id: Optional[str] = None,
                               opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecApiEndpointsResult:
     """
-    **Scopes**: Security configuration; security policy
-
-    Returns information about the API endpoints associated with a security policy or configuration.
-
-    **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/api-endpoints](https://techdocs.akamai.com/application-security/reference/get-api-endpoints)
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    api_endpoints = akamai.get_app_sec_api_endpoints(api_name="Contracts",
-        config_id=58843)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `id_list`. List of API endpoint IDs.
-    - `json`. JSON-formatted list of information about the API endpoints.
-    - `output_text`. Tabular report showing the ID and name of the API endpoints.
-
-
-    :param str api_name: . Name of the API endpoint you want to return information for. If not included, information is returned for all your API endpoints.
-    :param int config_id: . Unique identifier of the security configuration associated with the API endpoints.
-    :param str security_policy_id: . Unique identifier of the security policy associated with the API endpoints. If not included, information is returned for all your security policies.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     __args__['apiName'] = api_name
     __args__['configId'] = config_id
     __args__['securityPolicyId'] = security_policy_id
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecApiEndpoints:getAppSecApiEndpoints', __args__, opts=opts, typ=GetAppSecApiEndpointsResult).value
@@ -152,38 +124,10 @@
 
 @_utilities.lift_output_func(get_app_sec_api_endpoints)
 def get_app_sec_api_endpoints_output(api_name: Optional[pulumi.Input[Optional[str]]] = None,
                                      config_id: Optional[pulumi.Input[int]] = None,
                                      security_policy_id: Optional[pulumi.Input[Optional[str]]] = None,
                                      opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecApiEndpointsResult]:
     """
-    **Scopes**: Security configuration; security policy
-
-    Returns information about the API endpoints associated with a security policy or configuration.
-
-    **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/api-endpoints](https://techdocs.akamai.com/application-security/reference/get-api-endpoints)
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    api_endpoints = akamai.get_app_sec_api_endpoints(api_name="Contracts",
-        config_id=58843)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `id_list`. List of API endpoint IDs.
-    - `json`. JSON-formatted list of information about the API endpoints.
-    - `output_text`. Tabular report showing the ID and name of the API endpoints.
-
-
-    :param str api_name: . Name of the API endpoint you want to return information for. If not included, information is returned for all your API endpoints.
-    :param int config_id: . Unique identifier of the security configuration associated with the API endpoints.
-    :param str security_policy_id: . Unique identifier of the security policy associated with the API endpoints. If not included, information is returned for all your security policies.
+    Use this data source to access information about an existing resource.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_bypass_network_lists.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_ip_geo.py`

 * *Files 27% similar despite different names*

```diff
@@ -6,181 +6,135 @@
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
 __all__ = [
-    'GetAppSecBypassNetworkListsResult',
-    'AwaitableGetAppSecBypassNetworkListsResult',
-    'get_app_sec_bypass_network_lists',
-    'get_app_sec_bypass_network_lists_output',
+    'GetAppSecIPGeoResult',
+    'AwaitableGetAppSecIPGeoResult',
+    'get_app_sec_ip_geo',
+    'get_app_sec_ip_geo_output',
 ]
 
 @pulumi.output_type
-class GetAppSecBypassNetworkListsResult:
+class GetAppSecIPGeoResult:
     """
-    A collection of values returned by getAppSecBypassNetworkLists.
+    A collection of values returned by getAppSecIPGeo.
     """
-    def __init__(__self__, bypass_network_lists=None, config_id=None, id=None, json=None, output_text=None, security_policy_id=None):
-        if bypass_network_lists and not isinstance(bypass_network_lists, list):
-            raise TypeError("Expected argument 'bypass_network_lists' to be a list")
-        pulumi.set(__self__, "bypass_network_lists", bypass_network_lists)
+    def __init__(__self__, config_id=None, exception_ip_network_lists=None, geo_network_lists=None, id=None, ip_network_lists=None, mode=None, output_text=None, security_policy_id=None):
         if config_id and not isinstance(config_id, int):
             raise TypeError("Expected argument 'config_id' to be a int")
         pulumi.set(__self__, "config_id", config_id)
+        if exception_ip_network_lists and not isinstance(exception_ip_network_lists, list):
+            raise TypeError("Expected argument 'exception_ip_network_lists' to be a list")
+        pulumi.set(__self__, "exception_ip_network_lists", exception_ip_network_lists)
+        if geo_network_lists and not isinstance(geo_network_lists, list):
+            raise TypeError("Expected argument 'geo_network_lists' to be a list")
+        pulumi.set(__self__, "geo_network_lists", geo_network_lists)
         if id and not isinstance(id, str):
             raise TypeError("Expected argument 'id' to be a str")
         pulumi.set(__self__, "id", id)
-        if json and not isinstance(json, str):
-            raise TypeError("Expected argument 'json' to be a str")
-        pulumi.set(__self__, "json", json)
+        if ip_network_lists and not isinstance(ip_network_lists, list):
+            raise TypeError("Expected argument 'ip_network_lists' to be a list")
+        pulumi.set(__self__, "ip_network_lists", ip_network_lists)
+        if mode and not isinstance(mode, str):
+            raise TypeError("Expected argument 'mode' to be a str")
+        pulumi.set(__self__, "mode", mode)
         if output_text and not isinstance(output_text, str):
             raise TypeError("Expected argument 'output_text' to be a str")
         pulumi.set(__self__, "output_text", output_text)
         if security_policy_id and not isinstance(security_policy_id, str):
             raise TypeError("Expected argument 'security_policy_id' to be a str")
         pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
-    @pulumi.getter(name="bypassNetworkLists")
-    def bypass_network_lists(self) -> Sequence[str]:
-        return pulumi.get(self, "bypass_network_lists")
-
-    @property
     @pulumi.getter(name="configId")
     def config_id(self) -> int:
         return pulumi.get(self, "config_id")
 
     @property
+    @pulumi.getter(name="exceptionIpNetworkLists")
+    def exception_ip_network_lists(self) -> Sequence[str]:
+        return pulumi.get(self, "exception_ip_network_lists")
+
+    @property
+    @pulumi.getter(name="geoNetworkLists")
+    def geo_network_lists(self) -> Sequence[str]:
+        return pulumi.get(self, "geo_network_lists")
+
+    @property
     @pulumi.getter
     def id(self) -> str:
         """
         The provider-assigned unique ID for this managed resource.
         """
         return pulumi.get(self, "id")
 
     @property
+    @pulumi.getter(name="ipNetworkLists")
+    def ip_network_lists(self) -> Sequence[str]:
+        return pulumi.get(self, "ip_network_lists")
+
+    @property
     @pulumi.getter
-    def json(self) -> str:
-        return pulumi.get(self, "json")
+    def mode(self) -> str:
+        return pulumi.get(self, "mode")
 
     @property
     @pulumi.getter(name="outputText")
     def output_text(self) -> str:
         return pulumi.get(self, "output_text")
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> str:
         return pulumi.get(self, "security_policy_id")
 
 
-class AwaitableGetAppSecBypassNetworkListsResult(GetAppSecBypassNetworkListsResult):
+class AwaitableGetAppSecIPGeoResult(GetAppSecIPGeoResult):
     # pylint: disable=using-constant-test
     def __await__(self):
         if False:
             yield self
-        return GetAppSecBypassNetworkListsResult(
-            bypass_network_lists=self.bypass_network_lists,
+        return GetAppSecIPGeoResult(
             config_id=self.config_id,
+            exception_ip_network_lists=self.exception_ip_network_lists,
+            geo_network_lists=self.geo_network_lists,
             id=self.id,
-            json=self.json,
+            ip_network_lists=self.ip_network_lists,
+            mode=self.mode,
             output_text=self.output_text,
             security_policy_id=self.security_policy_id)
 
 
-def get_app_sec_bypass_network_lists(config_id: Optional[int] = None,
-                                     security_policy_id: Optional[str] = None,
-                                     opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecBypassNetworkListsResult:
+def get_app_sec_ip_geo(config_id: Optional[int] = None,
+                       security_policy_id: Optional[str] = None,
+                       opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecIPGeoResult:
     """
-    **Scopes**: Security configuration
-
-    Returns information about the network lists assigned to the bypass network list; networks on this list are not subject to firewall checking.
-
-    Note that this data source is only applicable to WAP (Web Application Protector) configurations.
-
-    **Related API Endpoint**:[/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/bypass-network-lists](https://techdocs.akamai.com/application-security/reference/get-bypass-network-lists-per-policy)
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    configuration = akamai.get_app_sec_configuration(name="Documentation")
-    bypass_network_lists = akamai.get_app_sec_bypass_network_lists(config_id=configuration.config_id,
-        security_policy_id="gms1_134637")
-    pulumi.export("bypassNetworkListsOutput", bypass_network_lists.output_text)
-    pulumi.export("bypassNetworkListsJson", bypass_network_lists.json)
-    pulumi.export("bypassNetworkListsIdList", bypass_network_lists.bypass_network_lists)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `bypass_network_list`. List of network IDs.
-    - `json`. JSON-formatted list of information about the bypass networks.
-    - `output_text`. Tabular report showing the bypass network list information.
-
-
-    :param int config_id: . Unique identifier of the security configuration associated with the bypass network lists.
-    :param str security_policy_id: . Unique identifier of the security policy associated with the bypass network lists.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     __args__['configId'] = config_id
     __args__['securityPolicyId'] = security_policy_id
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
-    __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecBypassNetworkLists:getAppSecBypassNetworkLists', __args__, opts=opts, typ=GetAppSecBypassNetworkListsResult).value
+    __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecIPGeo:getAppSecIPGeo', __args__, opts=opts, typ=GetAppSecIPGeoResult).value
 
-    return AwaitableGetAppSecBypassNetworkListsResult(
-        bypass_network_lists=__ret__.bypass_network_lists,
+    return AwaitableGetAppSecIPGeoResult(
         config_id=__ret__.config_id,
+        exception_ip_network_lists=__ret__.exception_ip_network_lists,
+        geo_network_lists=__ret__.geo_network_lists,
         id=__ret__.id,
-        json=__ret__.json,
+        ip_network_lists=__ret__.ip_network_lists,
+        mode=__ret__.mode,
         output_text=__ret__.output_text,
         security_policy_id=__ret__.security_policy_id)
 
 
-@_utilities.lift_output_func(get_app_sec_bypass_network_lists)
-def get_app_sec_bypass_network_lists_output(config_id: Optional[pulumi.Input[int]] = None,
-                                            security_policy_id: Optional[pulumi.Input[str]] = None,
-                                            opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecBypassNetworkListsResult]:
+@_utilities.lift_output_func(get_app_sec_ip_geo)
+def get_app_sec_ip_geo_output(config_id: Optional[pulumi.Input[int]] = None,
+                              security_policy_id: Optional[pulumi.Input[str]] = None,
+                              opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecIPGeoResult]:
     """
-    **Scopes**: Security configuration
-
-    Returns information about the network lists assigned to the bypass network list; networks on this list are not subject to firewall checking.
-
-    Note that this data source is only applicable to WAP (Web Application Protector) configurations.
-
-    **Related API Endpoint**:[/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/bypass-network-lists](https://techdocs.akamai.com/application-security/reference/get-bypass-network-lists-per-policy)
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    configuration = akamai.get_app_sec_configuration(name="Documentation")
-    bypass_network_lists = akamai.get_app_sec_bypass_network_lists(config_id=configuration.config_id,
-        security_policy_id="gms1_134637")
-    pulumi.export("bypassNetworkListsOutput", bypass_network_lists.output_text)
-    pulumi.export("bypassNetworkListsJson", bypass_network_lists.json)
-    pulumi.export("bypassNetworkListsIdList", bypass_network_lists.bypass_network_lists)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `bypass_network_list`. List of network IDs.
-    - `json`. JSON-formatted list of information about the bypass networks.
-    - `output_text`. Tabular report showing the bypass network list information.
-
-
-    :param int config_id: . Unique identifier of the security configuration associated with the bypass network lists.
-    :param str security_policy_id: . Unique identifier of the security policy associated with the bypass network lists.
+    Use this data source to access information about an existing resource.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_configuration.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_configuration.py`

 * *Files 8% similar despite different names*

```diff
@@ -98,16 +98,14 @@
             staging_version=self.staging_version)
 
 
 def get_app_sec_configuration(name: Optional[str] = None,
                               opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecConfigurationResult:
     """
     Use this data source to access information about an existing resource.
-
-    :param str name: . Name of the security configuration you want to return information for. If not included, information is returned for all your security configurations.
     """
     __args__ = dict()
     __args__['name'] = name
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecConfiguration:getAppSecConfiguration', __args__, opts=opts, typ=GetAppSecConfigurationResult).value
 
     return AwaitableGetAppSecConfigurationResult(
@@ -121,11 +119,9 @@
 
 
 @_utilities.lift_output_func(get_app_sec_configuration)
 def get_app_sec_configuration_output(name: Optional[pulumi.Input[Optional[str]]] = None,
                                      opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecConfigurationResult]:
     """
     Use this data source to access information about an existing resource.
-
-    :param str name: . Name of the security configuration you want to return information for. If not included, information is returned for all your security configurations.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_configuration_version.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_configuration_version.py`

 * *Files 13% similar despite different names*

```diff
@@ -99,17 +99,14 @@
 
 
 def get_app_sec_configuration_version(config_id: Optional[int] = None,
                                       version: Optional[int] = None,
                                       opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecConfigurationVersionResult:
     """
     Use this data source to access information about an existing resource.
-
-    :param int config_id: . Unique identifier of the security configuration you want to return version information for.
-    :param int version: . Version number of the security configuration you want to return information about. If not included, information about all the security configuration's versions is returned.
     """
     __args__ = dict()
     __args__['configId'] = config_id
     __args__['version'] = version
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecConfigurationVersion:getAppSecConfigurationVersion', __args__, opts=opts, typ=GetAppSecConfigurationVersionResult).value
 
@@ -125,12 +122,9 @@
 
 @_utilities.lift_output_func(get_app_sec_configuration_version)
 def get_app_sec_configuration_version_output(config_id: Optional[pulumi.Input[int]] = None,
                                              version: Optional[pulumi.Input[Optional[int]]] = None,
                                              opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecConfigurationVersionResult]:
     """
     Use this data source to access information about an existing resource.
-
-    :param int config_id: . Unique identifier of the security configuration you want to return version information for.
-    :param int version: . Version number of the security configuration you want to return information about. If not included, information about all the security configuration's versions is returned.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_eval.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_eval.py`

 * *Files identical despite different names*

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_eval_groups.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_eval_groups.py`

 * *Files 17% similar despite different names*

```diff
@@ -109,18 +109,14 @@
 
 def get_app_sec_eval_groups(attack_group: Optional[str] = None,
                             config_id: Optional[int] = None,
                             security_policy_id: Optional[str] = None,
                             opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecEvalGroupsResult:
     """
     Use this data source to access information about an existing resource.
-
-    :param str attack_group: . Unique identifier of the evaluation attack group you want to return information for. If not included, information is returned for all your evaluation attack groups.
-    :param int config_id: . Unique identifier of the security configuration associated with the evaluation attack group.
-    :param str security_policy_id: . Unique identifier of the security policy associated with the evaluation attack group.
     """
     __args__ = dict()
     __args__['attackGroup'] = attack_group
     __args__['configId'] = config_id
     __args__['securityPolicyId'] = security_policy_id
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecEvalGroups:getAppSecEvalGroups', __args__, opts=opts, typ=GetAppSecEvalGroupsResult).value
@@ -139,13 +135,9 @@
 @_utilities.lift_output_func(get_app_sec_eval_groups)
 def get_app_sec_eval_groups_output(attack_group: Optional[pulumi.Input[Optional[str]]] = None,
                                    config_id: Optional[pulumi.Input[int]] = None,
                                    security_policy_id: Optional[pulumi.Input[str]] = None,
                                    opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecEvalGroupsResult]:
     """
     Use this data source to access information about an existing resource.
-
-    :param str attack_group: . Unique identifier of the evaluation attack group you want to return information for. If not included, information is returned for all your evaluation attack groups.
-    :param int config_id: . Unique identifier of the security configuration associated with the evaluation attack group.
-    :param str security_policy_id: . Unique identifier of the security policy associated with the evaluation attack group.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_export_configuration.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_selectable_hostnames.py`

 * *Files 27% similar despite different names*

```diff
@@ -6,174 +6,154 @@
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
 __all__ = [
-    'GetAppSecExportConfigurationResult',
-    'AwaitableGetAppSecExportConfigurationResult',
-    'get_app_sec_export_configuration',
-    'get_app_sec_export_configuration_output',
+    'GetAppSecSelectableHostnamesResult',
+    'AwaitableGetAppSecSelectableHostnamesResult',
+    'get_app_sec_selectable_hostnames',
+    'get_app_sec_selectable_hostnames_output',
 ]
 
 @pulumi.output_type
-class GetAppSecExportConfigurationResult:
+class GetAppSecSelectableHostnamesResult:
     """
-    A collection of values returned by getAppSecExportConfiguration.
+    A collection of values returned by getAppSecSelectableHostnames.
     """
-    def __init__(__self__, config_id=None, id=None, json=None, output_text=None, searches=None, version=None):
+    def __init__(__self__, active_in_production=None, active_in_staging=None, config_id=None, contractid=None, groupid=None, hostnames=None, hostnames_json=None, id=None, output_text=None):
+        if active_in_production and not isinstance(active_in_production, bool):
+            raise TypeError("Expected argument 'active_in_production' to be a bool")
+        pulumi.set(__self__, "active_in_production", active_in_production)
+        if active_in_staging and not isinstance(active_in_staging, bool):
+            raise TypeError("Expected argument 'active_in_staging' to be a bool")
+        pulumi.set(__self__, "active_in_staging", active_in_staging)
         if config_id and not isinstance(config_id, int):
             raise TypeError("Expected argument 'config_id' to be a int")
         pulumi.set(__self__, "config_id", config_id)
+        if contractid and not isinstance(contractid, str):
+            raise TypeError("Expected argument 'contractid' to be a str")
+        pulumi.set(__self__, "contractid", contractid)
+        if groupid and not isinstance(groupid, int):
+            raise TypeError("Expected argument 'groupid' to be a int")
+        pulumi.set(__self__, "groupid", groupid)
+        if hostnames and not isinstance(hostnames, list):
+            raise TypeError("Expected argument 'hostnames' to be a list")
+        pulumi.set(__self__, "hostnames", hostnames)
+        if hostnames_json and not isinstance(hostnames_json, str):
+            raise TypeError("Expected argument 'hostnames_json' to be a str")
+        pulumi.set(__self__, "hostnames_json", hostnames_json)
         if id and not isinstance(id, str):
             raise TypeError("Expected argument 'id' to be a str")
         pulumi.set(__self__, "id", id)
-        if json and not isinstance(json, str):
-            raise TypeError("Expected argument 'json' to be a str")
-        pulumi.set(__self__, "json", json)
         if output_text and not isinstance(output_text, str):
             raise TypeError("Expected argument 'output_text' to be a str")
         pulumi.set(__self__, "output_text", output_text)
-        if searches and not isinstance(searches, list):
-            raise TypeError("Expected argument 'searches' to be a list")
-        pulumi.set(__self__, "searches", searches)
-        if version and not isinstance(version, int):
-            raise TypeError("Expected argument 'version' to be a int")
-        pulumi.set(__self__, "version", version)
+
+    @property
+    @pulumi.getter(name="activeInProduction")
+    def active_in_production(self) -> Optional[bool]:
+        return pulumi.get(self, "active_in_production")
+
+    @property
+    @pulumi.getter(name="activeInStaging")
+    def active_in_staging(self) -> Optional[bool]:
+        return pulumi.get(self, "active_in_staging")
 
     @property
     @pulumi.getter(name="configId")
-    def config_id(self) -> int:
+    def config_id(self) -> Optional[int]:
         return pulumi.get(self, "config_id")
 
     @property
     @pulumi.getter
-    def id(self) -> str:
-        """
-        The provider-assigned unique ID for this managed resource.
-        """
-        return pulumi.get(self, "id")
+    def contractid(self) -> Optional[str]:
+        return pulumi.get(self, "contractid")
 
     @property
     @pulumi.getter
-    def json(self) -> str:
-        return pulumi.get(self, "json")
+    def groupid(self) -> Optional[int]:
+        return pulumi.get(self, "groupid")
 
     @property
-    @pulumi.getter(name="outputText")
-    def output_text(self) -> str:
-        return pulumi.get(self, "output_text")
+    @pulumi.getter
+    def hostnames(self) -> Sequence[str]:
+        return pulumi.get(self, "hostnames")
 
     @property
-    @pulumi.getter
-    def searches(self) -> Optional[Sequence[str]]:
-        return pulumi.get(self, "searches")
+    @pulumi.getter(name="hostnamesJson")
+    def hostnames_json(self) -> str:
+        return pulumi.get(self, "hostnames_json")
 
     @property
     @pulumi.getter
-    def version(self) -> int:
-        return pulumi.get(self, "version")
+    def id(self) -> str:
+        """
+        The provider-assigned unique ID for this managed resource.
+        """
+        return pulumi.get(self, "id")
 
+    @property
+    @pulumi.getter(name="outputText")
+    def output_text(self) -> str:
+        return pulumi.get(self, "output_text")
 
-class AwaitableGetAppSecExportConfigurationResult(GetAppSecExportConfigurationResult):
+
+class AwaitableGetAppSecSelectableHostnamesResult(GetAppSecSelectableHostnamesResult):
     # pylint: disable=using-constant-test
     def __await__(self):
         if False:
             yield self
-        return GetAppSecExportConfigurationResult(
+        return GetAppSecSelectableHostnamesResult(
+            active_in_production=self.active_in_production,
+            active_in_staging=self.active_in_staging,
             config_id=self.config_id,
+            contractid=self.contractid,
+            groupid=self.groupid,
+            hostnames=self.hostnames,
+            hostnames_json=self.hostnames_json,
             id=self.id,
-            json=self.json,
-            output_text=self.output_text,
-            searches=self.searches,
-            version=self.version)
-
-
-def get_app_sec_export_configuration(config_id: Optional[int] = None,
-                                     searches: Optional[Sequence[str]] = None,
-                                     version: Optional[int] = None,
-                                     opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecExportConfigurationResult:
-    """
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    configuration = akamai.get_app_sec_configuration(name="Documentation")
-    export = akamai.get_app_sec_export_configuration(config_id=configuration.config_id,
-        version=configuration.latest_version,
-        searches=[
-            "securityPolicies",
-            "selectedHosts",
-        ])
-    pulumi.export("json", export.json)
-    pulumi.export("text", export.output_text)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `json`. Complete set of information about the specified security configuration version in JSON format. When this option is included information is always returned for the _entire_ configuration. Among other things, that means that, if your command uses the `search` parameter, that parameter is ignored.
-    - `output_text`. Tabular report showing the types of data specified in the `search` parameter. Valid only if the `search` parameter references at least one type.
-
-
-    :param int config_id: . Unique identifier of the security configuration you want to return information for.
-    :param Sequence[str] searches: . JSON array of strings specifying the types of information to be retrieved. Note that there are two different ways to return data by using the `search` parameter. To return data in tabular format, use one or more of the following terms:
-    :param int version: . Version number of the security configuration.
+            output_text=self.output_text)
+
+
+def get_app_sec_selectable_hostnames(active_in_production: Optional[bool] = None,
+                                     active_in_staging: Optional[bool] = None,
+                                     config_id: Optional[int] = None,
+                                     contractid: Optional[str] = None,
+                                     groupid: Optional[int] = None,
+                                     opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecSelectableHostnamesResult:
+    """
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
+    __args__['activeInProduction'] = active_in_production
+    __args__['activeInStaging'] = active_in_staging
     __args__['configId'] = config_id
-    __args__['searches'] = searches
-    __args__['version'] = version
+    __args__['contractid'] = contractid
+    __args__['groupid'] = groupid
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
-    __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecExportConfiguration:getAppSecExportConfiguration', __args__, opts=opts, typ=GetAppSecExportConfigurationResult).value
+    __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecSelectableHostnames:getAppSecSelectableHostnames', __args__, opts=opts, typ=GetAppSecSelectableHostnamesResult).value
 
-    return AwaitableGetAppSecExportConfigurationResult(
+    return AwaitableGetAppSecSelectableHostnamesResult(
+        active_in_production=__ret__.active_in_production,
+        active_in_staging=__ret__.active_in_staging,
         config_id=__ret__.config_id,
+        contractid=__ret__.contractid,
+        groupid=__ret__.groupid,
+        hostnames=__ret__.hostnames,
+        hostnames_json=__ret__.hostnames_json,
         id=__ret__.id,
-        json=__ret__.json,
-        output_text=__ret__.output_text,
-        searches=__ret__.searches,
-        version=__ret__.version)
-
-
-@_utilities.lift_output_func(get_app_sec_export_configuration)
-def get_app_sec_export_configuration_output(config_id: Optional[pulumi.Input[int]] = None,
-                                            searches: Optional[pulumi.Input[Optional[Sequence[str]]]] = None,
-                                            version: Optional[pulumi.Input[int]] = None,
-                                            opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecExportConfigurationResult]:
-    """
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    configuration = akamai.get_app_sec_configuration(name="Documentation")
-    export = akamai.get_app_sec_export_configuration(config_id=configuration.config_id,
-        version=configuration.latest_version,
-        searches=[
-            "securityPolicies",
-            "selectedHosts",
-        ])
-    pulumi.export("json", export.json)
-    pulumi.export("text", export.output_text)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `json`. Complete set of information about the specified security configuration version in JSON format. When this option is included information is always returned for the _entire_ configuration. Among other things, that means that, if your command uses the `search` parameter, that parameter is ignored.
-    - `output_text`. Tabular report showing the types of data specified in the `search` parameter. Valid only if the `search` parameter references at least one type.
-
-
-    :param int config_id: . Unique identifier of the security configuration you want to return information for.
-    :param Sequence[str] searches: . JSON array of strings specifying the types of information to be retrieved. Note that there are two different ways to return data by using the `search` parameter. To return data in tabular format, use one or more of the following terms:
-    :param int version: . Version number of the security configuration.
+        output_text=__ret__.output_text)
+
+
+@_utilities.lift_output_func(get_app_sec_selectable_hostnames)
+def get_app_sec_selectable_hostnames_output(active_in_production: Optional[pulumi.Input[Optional[bool]]] = None,
+                                            active_in_staging: Optional[pulumi.Input[Optional[bool]]] = None,
+                                            config_id: Optional[pulumi.Input[Optional[int]]] = None,
+                                            contractid: Optional[pulumi.Input[Optional[str]]] = None,
+                                            groupid: Optional[pulumi.Input[Optional[int]]] = None,
+                                            opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecSelectableHostnamesResult]:
+    """
+    Use this data source to access information about an existing resource.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_hostname_coverage.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_hostname_coverage.py`

 * *Files 15% similar despite different names*

```diff
@@ -59,38 +59,15 @@
             id=self.id,
             json=self.json,
             output_text=self.output_text)
 
 
 def get_app_sec_hostname_coverage(opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecHostnameCoverageResult:
     """
-    **Scopes**: Individual account
-
-    Returns information about the hostnames associated with your account. The returned data includes the hostname's protections, activation status, and other summary information.
-
-    **Related API Endpoint**: [/appsec/v1/hostname-coverage](https://techdocs.akamai.com/application-security/reference/get-hostname-coverage)
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    hostname_coverage = akamai.get_app_sec_hostname_coverage()
-    pulumi.export("hostnameCoverageListJson", hostname_coverage.json)
-    pulumi.export("hostnameCoverageListOutput", hostname_coverage.output_text)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `json`. JSON-formatted list of the hostname coverage information.
-    - `output_text`. Tabular report of the hostname coverage information.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecHostnameCoverage:getAppSecHostnameCoverage', __args__, opts=opts, typ=GetAppSecHostnameCoverageResult).value
 
     return AwaitableGetAppSecHostnameCoverageResult(
         id=__ret__.id,
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_hostname_coverage_overlapping.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_reputation_profile_actions.py`

 * *Files 23% similar despite different names*

```diff
@@ -6,54 +6,60 @@
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
 __all__ = [
-    'GetAppSecHostnameCoverageOverlappingResult',
-    'AwaitableGetAppSecHostnameCoverageOverlappingResult',
-    'get_app_sec_hostname_coverage_overlapping',
-    'get_app_sec_hostname_coverage_overlapping_output',
+    'GetAppSecReputationProfileActionsResult',
+    'AwaitableGetAppSecReputationProfileActionsResult',
+    'get_app_sec_reputation_profile_actions',
+    'get_app_sec_reputation_profile_actions_output',
 ]
 
 @pulumi.output_type
-class GetAppSecHostnameCoverageOverlappingResult:
+class GetAppSecReputationProfileActionsResult:
     """
-    A collection of values returned by getAppSecHostnameCoverageOverlapping.
+    A collection of values returned by getAppSecReputationProfileActions.
     """
-    def __init__(__self__, config_id=None, hostname=None, id=None, json=None, output_text=None):
+    def __init__(__self__, action=None, config_id=None, id=None, json=None, output_text=None, reputation_profile_id=None, security_policy_id=None):
+        if action and not isinstance(action, str):
+            raise TypeError("Expected argument 'action' to be a str")
+        pulumi.set(__self__, "action", action)
         if config_id and not isinstance(config_id, int):
             raise TypeError("Expected argument 'config_id' to be a int")
         pulumi.set(__self__, "config_id", config_id)
-        if hostname and not isinstance(hostname, str):
-            raise TypeError("Expected argument 'hostname' to be a str")
-        pulumi.set(__self__, "hostname", hostname)
         if id and not isinstance(id, str):
             raise TypeError("Expected argument 'id' to be a str")
         pulumi.set(__self__, "id", id)
         if json and not isinstance(json, str):
             raise TypeError("Expected argument 'json' to be a str")
         pulumi.set(__self__, "json", json)
         if output_text and not isinstance(output_text, str):
             raise TypeError("Expected argument 'output_text' to be a str")
         pulumi.set(__self__, "output_text", output_text)
+        if reputation_profile_id and not isinstance(reputation_profile_id, int):
+            raise TypeError("Expected argument 'reputation_profile_id' to be a int")
+        pulumi.set(__self__, "reputation_profile_id", reputation_profile_id)
+        if security_policy_id and not isinstance(security_policy_id, str):
+            raise TypeError("Expected argument 'security_policy_id' to be a str")
+        pulumi.set(__self__, "security_policy_id", security_policy_id)
+
+    @property
+    @pulumi.getter
+    def action(self) -> str:
+        return pulumi.get(self, "action")
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> int:
         return pulumi.get(self, "config_id")
 
     @property
     @pulumi.getter
-    def hostname(self) -> str:
-        return pulumi.get(self, "hostname")
-
-    @property
-    @pulumi.getter
     def id(self) -> str:
         """
         The provider-assigned unique ID for this managed resource.
         """
         return pulumi.get(self, "id")
 
     @property
@@ -62,103 +68,66 @@
         return pulumi.get(self, "json")
 
     @property
     @pulumi.getter(name="outputText")
     def output_text(self) -> str:
         return pulumi.get(self, "output_text")
 
+    @property
+    @pulumi.getter(name="reputationProfileId")
+    def reputation_profile_id(self) -> Optional[int]:
+        return pulumi.get(self, "reputation_profile_id")
 
-class AwaitableGetAppSecHostnameCoverageOverlappingResult(GetAppSecHostnameCoverageOverlappingResult):
+    @property
+    @pulumi.getter(name="securityPolicyId")
+    def security_policy_id(self) -> str:
+        return pulumi.get(self, "security_policy_id")
+
+
+class AwaitableGetAppSecReputationProfileActionsResult(GetAppSecReputationProfileActionsResult):
     # pylint: disable=using-constant-test
     def __await__(self):
         if False:
             yield self
-        return GetAppSecHostnameCoverageOverlappingResult(
+        return GetAppSecReputationProfileActionsResult(
+            action=self.action,
             config_id=self.config_id,
-            hostname=self.hostname,
             id=self.id,
             json=self.json,
-            output_text=self.output_text)
+            output_text=self.output_text,
+            reputation_profile_id=self.reputation_profile_id,
+            security_policy_id=self.security_policy_id)
 
 
-def get_app_sec_hostname_coverage_overlapping(config_id: Optional[int] = None,
-                                              hostname: Optional[str] = None,
-                                              opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecHostnameCoverageOverlappingResult:
+def get_app_sec_reputation_profile_actions(config_id: Optional[int] = None,
+                                           reputation_profile_id: Optional[int] = None,
+                                           security_policy_id: Optional[str] = None,
+                                           opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecReputationProfileActionsResult:
     """
-    **Scopes**: Security configuration; hostname
-
-    Returns information about any other configuration versions that contain a hostname found in the current configuration version.
-
-    **Related API Endpoint**:[/appsec/v1/configs/{configId}/versions/{versionNumber}/hostname-coverage/overlapping](https://techdocs.akamai.com/application-security/reference/get-hostname-coverage-overlapping)
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    configuration = akamai.get_app_sec_configuration(name="Documentation")
-    test = akamai.get_app_sec_hostname_coverage_overlapping(config_id=configuration.config_id,
-        hostname="documentation.akamai.com")
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `json`. JSON-formatted list of the overlap information.
-    - `output_text`. Tabular report of the overlap information.
-
-
-    :param int config_id: . Unique identifier of the security configuration you want to return information for.
-    :param str hostname: . Name of the host you want to return information for.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     __args__['configId'] = config_id
-    __args__['hostname'] = hostname
+    __args__['reputationProfileId'] = reputation_profile_id
+    __args__['securityPolicyId'] = security_policy_id
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
-    __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecHostnameCoverageOverlapping:getAppSecHostnameCoverageOverlapping', __args__, opts=opts, typ=GetAppSecHostnameCoverageOverlappingResult).value
+    __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecReputationProfileActions:getAppSecReputationProfileActions', __args__, opts=opts, typ=GetAppSecReputationProfileActionsResult).value
 
-    return AwaitableGetAppSecHostnameCoverageOverlappingResult(
+    return AwaitableGetAppSecReputationProfileActionsResult(
+        action=__ret__.action,
         config_id=__ret__.config_id,
-        hostname=__ret__.hostname,
         id=__ret__.id,
         json=__ret__.json,
-        output_text=__ret__.output_text)
+        output_text=__ret__.output_text,
+        reputation_profile_id=__ret__.reputation_profile_id,
+        security_policy_id=__ret__.security_policy_id)
 
 
-@_utilities.lift_output_func(get_app_sec_hostname_coverage_overlapping)
-def get_app_sec_hostname_coverage_overlapping_output(config_id: Optional[pulumi.Input[int]] = None,
-                                                     hostname: Optional[pulumi.Input[str]] = None,
-                                                     opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecHostnameCoverageOverlappingResult]:
+@_utilities.lift_output_func(get_app_sec_reputation_profile_actions)
+def get_app_sec_reputation_profile_actions_output(config_id: Optional[pulumi.Input[int]] = None,
+                                                  reputation_profile_id: Optional[pulumi.Input[Optional[int]]] = None,
+                                                  security_policy_id: Optional[pulumi.Input[str]] = None,
+                                                  opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecReputationProfileActionsResult]:
     """
-    **Scopes**: Security configuration; hostname
-
-    Returns information about any other configuration versions that contain a hostname found in the current configuration version.
-
-    **Related API Endpoint**:[/appsec/v1/configs/{configId}/versions/{versionNumber}/hostname-coverage/overlapping](https://techdocs.akamai.com/application-security/reference/get-hostname-coverage-overlapping)
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    configuration = akamai.get_app_sec_configuration(name="Documentation")
-    test = akamai.get_app_sec_hostname_coverage_overlapping(config_id=configuration.config_id,
-        hostname="documentation.akamai.com")
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `json`. JSON-formatted list of the overlap information.
-    - `output_text`. Tabular report of the overlap information.
-
-
-    :param int config_id: . Unique identifier of the security configuration you want to return information for.
-    :param str hostname: . Name of the host you want to return information for.
+    Use this data source to access information about an existing resource.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_malware_content_types.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_rules.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,38 +6,55 @@
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
 __all__ = [
-    'GetAppSecMalwareContentTypesResult',
-    'AwaitableGetAppSecMalwareContentTypesResult',
-    'get_app_sec_malware_content_types',
-    'get_app_sec_malware_content_types_output',
+    'GetAppSecRulesResult',
+    'AwaitableGetAppSecRulesResult',
+    'get_app_sec_rules',
+    'get_app_sec_rules_output',
 ]
 
 @pulumi.output_type
-class GetAppSecMalwareContentTypesResult:
+class GetAppSecRulesResult:
     """
-    A collection of values returned by getAppSecMalwareContentTypes.
+    A collection of values returned by getAppSecRules.
     """
-    def __init__(__self__, config_id=None, id=None, json=None, output_text=None):
+    def __init__(__self__, condition_exception=None, config_id=None, id=None, json=None, output_text=None, rule_action=None, rule_id=None, security_policy_id=None):
+        if condition_exception and not isinstance(condition_exception, str):
+            raise TypeError("Expected argument 'condition_exception' to be a str")
+        pulumi.set(__self__, "condition_exception", condition_exception)
         if config_id and not isinstance(config_id, int):
             raise TypeError("Expected argument 'config_id' to be a int")
         pulumi.set(__self__, "config_id", config_id)
         if id and not isinstance(id, str):
             raise TypeError("Expected argument 'id' to be a str")
         pulumi.set(__self__, "id", id)
         if json and not isinstance(json, str):
             raise TypeError("Expected argument 'json' to be a str")
         pulumi.set(__self__, "json", json)
         if output_text and not isinstance(output_text, str):
             raise TypeError("Expected argument 'output_text' to be a str")
         pulumi.set(__self__, "output_text", output_text)
+        if rule_action and not isinstance(rule_action, str):
+            raise TypeError("Expected argument 'rule_action' to be a str")
+        pulumi.set(__self__, "rule_action", rule_action)
+        if rule_id and not isinstance(rule_id, int):
+            raise TypeError("Expected argument 'rule_id' to be a int")
+        pulumi.set(__self__, "rule_id", rule_id)
+        if security_policy_id and not isinstance(security_policy_id, str):
+            raise TypeError("Expected argument 'security_policy_id' to be a str")
+        pulumi.set(__self__, "security_policy_id", security_policy_id)
+
+    @property
+    @pulumi.getter(name="conditionException")
+    def condition_exception(self) -> str:
+        return pulumi.get(self, "condition_exception")
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> int:
         return pulumi.get(self, "config_id")
 
     @property
@@ -54,94 +71,73 @@
         return pulumi.get(self, "json")
 
     @property
     @pulumi.getter(name="outputText")
     def output_text(self) -> str:
         return pulumi.get(self, "output_text")
 
+    @property
+    @pulumi.getter(name="ruleAction")
+    def rule_action(self) -> str:
+        return pulumi.get(self, "rule_action")
+
+    @property
+    @pulumi.getter(name="ruleId")
+    def rule_id(self) -> Optional[int]:
+        return pulumi.get(self, "rule_id")
+
+    @property
+    @pulumi.getter(name="securityPolicyId")
+    def security_policy_id(self) -> str:
+        return pulumi.get(self, "security_policy_id")
 
-class AwaitableGetAppSecMalwareContentTypesResult(GetAppSecMalwareContentTypesResult):
+
+class AwaitableGetAppSecRulesResult(GetAppSecRulesResult):
     # pylint: disable=using-constant-test
     def __await__(self):
         if False:
             yield self
-        return GetAppSecMalwareContentTypesResult(
+        return GetAppSecRulesResult(
+            condition_exception=self.condition_exception,
             config_id=self.config_id,
             id=self.id,
             json=self.json,
-            output_text=self.output_text)
+            output_text=self.output_text,
+            rule_action=self.rule_action,
+            rule_id=self.rule_id,
+            security_policy_id=self.security_policy_id)
 
 
-def get_app_sec_malware_content_types(config_id: Optional[int] = None,
-                                      opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecMalwareContentTypesResult:
+def get_app_sec_rules(config_id: Optional[int] = None,
+                      rule_id: Optional[int] = None,
+                      security_policy_id: Optional[str] = None,
+                      opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecRulesResult:
     """
-    **Scopes**: Security configuration; malware protection
-
-    Returns information about available content types for malware protection. Each malware policy includes a set of content types to which the policy's actions are applied.
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    configuration = akamai.get_app_sec_configuration(name="Documentation")
-    malware_content_types = akamai.get_app_sec_malware_content_types(config_id=configuration.config_id)
-    pulumi.export("malwareContentTypesOutput", malware_content_types.output_text)
-    pulumi.export("malwareContentTypesJson", malware_content_types.json)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `output_text`. Tabular report showing the available content types.
-    - `json`. JSON-formatted list of the available content types.
-
-
-    :param int config_id: . Unique identifier of the security configuration associated with the content types.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     __args__['configId'] = config_id
+    __args__['ruleId'] = rule_id
+    __args__['securityPolicyId'] = security_policy_id
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
-    __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecMalwareContentTypes:getAppSecMalwareContentTypes', __args__, opts=opts, typ=GetAppSecMalwareContentTypesResult).value
+    __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecRules:getAppSecRules', __args__, opts=opts, typ=GetAppSecRulesResult).value
 
-    return AwaitableGetAppSecMalwareContentTypesResult(
+    return AwaitableGetAppSecRulesResult(
+        condition_exception=__ret__.condition_exception,
         config_id=__ret__.config_id,
         id=__ret__.id,
         json=__ret__.json,
-        output_text=__ret__.output_text)
+        output_text=__ret__.output_text,
+        rule_action=__ret__.rule_action,
+        rule_id=__ret__.rule_id,
+        security_policy_id=__ret__.security_policy_id)
 
 
-@_utilities.lift_output_func(get_app_sec_malware_content_types)
-def get_app_sec_malware_content_types_output(config_id: Optional[pulumi.Input[int]] = None,
-                                             opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecMalwareContentTypesResult]:
+@_utilities.lift_output_func(get_app_sec_rules)
+def get_app_sec_rules_output(config_id: Optional[pulumi.Input[int]] = None,
+                             rule_id: Optional[pulumi.Input[Optional[int]]] = None,
+                             security_policy_id: Optional[pulumi.Input[str]] = None,
+                             opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecRulesResult]:
     """
-    **Scopes**: Security configuration; malware protection
-
-    Returns information about available content types for malware protection. Each malware policy includes a set of content types to which the policy's actions are applied.
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    configuration = akamai.get_app_sec_configuration(name="Documentation")
-    malware_content_types = akamai.get_app_sec_malware_content_types(config_id=configuration.config_id)
-    pulumi.export("malwareContentTypesOutput", malware_content_types.output_text)
-    pulumi.export("malwareContentTypesJson", malware_content_types.json)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `output_text`. Tabular report showing the available content types.
-    - `json`. JSON-formatted list of the available content types.
-
-
-    :param int config_id: . Unique identifier of the security configuration associated with the content types.
+    Use this data source to access information about an existing resource.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_rate_policy_actions.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_rate_policy_actions.py`

 * *Files 27% similar despite different names*

```diff
@@ -81,43 +81,15 @@
 
 
 def get_app_sec_rate_policy_actions(config_id: Optional[int] = None,
                                     rate_policy_id: Optional[int] = None,
                                     security_policy_id: Optional[str] = None,
                                     opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecRatePolicyActionsResult:
     """
-    **Scopes**: Security policy; rate policy
-
-    Returns information about your rate policy actions. Actions specify what happens any time a rate policy is triggered: the issue could be ignored, the request could be denied, or an alert could be generated.
-
-    **Related API Endpoint:** [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rate-policies](https://techdocs.akamai.com/application-security/reference/get-rate-policies-actions)
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    configuration = akamai.get_app_sec_configuration(name="Documentation")
-    rate_policy_actions_app_sec_rate_policy_actions = akamai.get_app_sec_rate_policy_actions(config_id=configuration.config_id,
-        security_policy_id="gms1_134637")
-    pulumi.export("ratePolicyActions", rate_policy_actions_app_sec_rate_policy_actions.output_text)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `output_text`. Tabular report showing the ID, IPv4 action, and IPv6 action of the rate policies.
-
-
-    :param int config_id: . Unique identifier of the security configuration associated with the rate policies and rate policy actions.
-    :param int rate_policy_id: . Unique identifier of the rate policy you want to return action information for. If not included, action information is returned for all your rate policies.
-    :param str security_policy_id: . Unique identifier of the security policy associated with the rate policies and rate policy actions.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     __args__['configId'] = config_id
     __args__['ratePolicyId'] = rate_policy_id
     __args__['securityPolicyId'] = security_policy_id
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecRatePolicyActions:getAppSecRatePolicyActions', __args__, opts=opts, typ=GetAppSecRatePolicyActionsResult).value
@@ -132,38 +104,10 @@
 
 @_utilities.lift_output_func(get_app_sec_rate_policy_actions)
 def get_app_sec_rate_policy_actions_output(config_id: Optional[pulumi.Input[int]] = None,
                                            rate_policy_id: Optional[pulumi.Input[Optional[int]]] = None,
                                            security_policy_id: Optional[pulumi.Input[str]] = None,
                                            opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecRatePolicyActionsResult]:
     """
-    **Scopes**: Security policy; rate policy
-
-    Returns information about your rate policy actions. Actions specify what happens any time a rate policy is triggered: the issue could be ignored, the request could be denied, or an alert could be generated.
-
-    **Related API Endpoint:** [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/rate-policies](https://techdocs.akamai.com/application-security/reference/get-rate-policies-actions)
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    configuration = akamai.get_app_sec_configuration(name="Documentation")
-    rate_policy_actions_app_sec_rate_policy_actions = akamai.get_app_sec_rate_policy_actions(config_id=configuration.config_id,
-        security_policy_id="gms1_134637")
-    pulumi.export("ratePolicyActions", rate_policy_actions_app_sec_rate_policy_actions.output_text)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `output_text`. Tabular report showing the ID, IPv4 action, and IPv6 action of the rate policies.
-
-
-    :param int config_id: . Unique identifier of the security configuration associated with the rate policies and rate policy actions.
-    :param int rate_policy_id: . Unique identifier of the rate policy you want to return action information for. If not included, action information is returned for all your rate policies.
-    :param str security_policy_id: . Unique identifier of the security policy associated with the rate policies and rate policy actions.
+    Use this data source to access information about an existing resource.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_reputation_profile_actions.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_rate_protection.py`

 * *Files 26% similar despite different names*

```diff
@@ -5,209 +5,251 @@
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
-__all__ = [
-    'GetAppSecReputationProfileActionsResult',
-    'AwaitableGetAppSecReputationProfileActionsResult',
-    'get_app_sec_reputation_profile_actions',
-    'get_app_sec_reputation_profile_actions_output',
-]
-
-@pulumi.output_type
-class GetAppSecReputationProfileActionsResult:
-    """
-    A collection of values returned by getAppSecReputationProfileActions.
-    """
-    def __init__(__self__, action=None, config_id=None, id=None, json=None, output_text=None, reputation_profile_id=None, security_policy_id=None):
-        if action and not isinstance(action, str):
-            raise TypeError("Expected argument 'action' to be a str")
-        pulumi.set(__self__, "action", action)
-        if config_id and not isinstance(config_id, int):
-            raise TypeError("Expected argument 'config_id' to be a int")
+__all__ = ['AppSecRateProtectionArgs', 'AppSecRateProtection']
+
+@pulumi.input_type
+class AppSecRateProtectionArgs:
+    def __init__(__self__, *,
+                 config_id: pulumi.Input[int],
+                 enabled: pulumi.Input[bool],
+                 security_policy_id: pulumi.Input[str]):
+        """
+        The set of arguments for constructing a AppSecRateProtection resource.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
+        """
         pulumi.set(__self__, "config_id", config_id)
-        if id and not isinstance(id, str):
-            raise TypeError("Expected argument 'id' to be a str")
-        pulumi.set(__self__, "id", id)
-        if json and not isinstance(json, str):
-            raise TypeError("Expected argument 'json' to be a str")
-        pulumi.set(__self__, "json", json)
-        if output_text and not isinstance(output_text, str):
-            raise TypeError("Expected argument 'output_text' to be a str")
-        pulumi.set(__self__, "output_text", output_text)
-        if reputation_profile_id and not isinstance(reputation_profile_id, int):
-            raise TypeError("Expected argument 'reputation_profile_id' to be a int")
-        pulumi.set(__self__, "reputation_profile_id", reputation_profile_id)
-        if security_policy_id and not isinstance(security_policy_id, str):
-            raise TypeError("Expected argument 'security_policy_id' to be a str")
+        pulumi.set(__self__, "enabled", enabled)
         pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
+    @pulumi.getter(name="configId")
+    def config_id(self) -> pulumi.Input[int]:
+        """
+        Unique identifier of the security configuration
+        """
+        return pulumi.get(self, "config_id")
+
+    @config_id.setter
+    def config_id(self, value: pulumi.Input[int]):
+        pulumi.set(self, "config_id", value)
+
+    @property
     @pulumi.getter
-    def action(self) -> str:
-        return pulumi.get(self, "action")
+    def enabled(self) -> pulumi.Input[bool]:
+        return pulumi.get(self, "enabled")
+
+    @enabled.setter
+    def enabled(self, value: pulumi.Input[bool]):
+        pulumi.set(self, "enabled", value)
+
+    @property
+    @pulumi.getter(name="securityPolicyId")
+    def security_policy_id(self) -> pulumi.Input[str]:
+        """
+        Unique identifier of the security policy
+        """
+        return pulumi.get(self, "security_policy_id")
+
+    @security_policy_id.setter
+    def security_policy_id(self, value: pulumi.Input[str]):
+        pulumi.set(self, "security_policy_id", value)
+
+
+@pulumi.input_type
+class _AppSecRateProtectionState:
+    def __init__(__self__, *,
+                 config_id: Optional[pulumi.Input[int]] = None,
+                 enabled: Optional[pulumi.Input[bool]] = None,
+                 output_text: Optional[pulumi.Input[str]] = None,
+                 security_policy_id: Optional[pulumi.Input[str]] = None):
+        """
+        Input properties used for looking up and filtering AppSecRateProtection resources.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] output_text: Text representation
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
+        """
+        if config_id is not None:
+            pulumi.set(__self__, "config_id", config_id)
+        if enabled is not None:
+            pulumi.set(__self__, "enabled", enabled)
+        if output_text is not None:
+            pulumi.set(__self__, "output_text", output_text)
+        if security_policy_id is not None:
+            pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
     @pulumi.getter(name="configId")
-    def config_id(self) -> int:
+    def config_id(self) -> Optional[pulumi.Input[int]]:
+        """
+        Unique identifier of the security configuration
+        """
         return pulumi.get(self, "config_id")
 
+    @config_id.setter
+    def config_id(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "config_id", value)
+
     @property
     @pulumi.getter
-    def id(self) -> str:
+    def enabled(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "enabled")
+
+    @enabled.setter
+    def enabled(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "enabled", value)
+
+    @property
+    @pulumi.getter(name="outputText")
+    def output_text(self) -> Optional[pulumi.Input[str]]:
+        """
+        Text representation
+        """
+        return pulumi.get(self, "output_text")
+
+    @output_text.setter
+    def output_text(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "output_text", value)
+
+    @property
+    @pulumi.getter(name="securityPolicyId")
+    def security_policy_id(self) -> Optional[pulumi.Input[str]]:
+        """
+        Unique identifier of the security policy
+        """
+        return pulumi.get(self, "security_policy_id")
+
+    @security_policy_id.setter
+    def security_policy_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "security_policy_id", value)
+
+
+class AppSecRateProtection(pulumi.CustomResource):
+    @overload
+    def __init__(__self__,
+                 resource_name: str,
+                 opts: Optional[pulumi.ResourceOptions] = None,
+                 config_id: Optional[pulumi.Input[int]] = None,
+                 enabled: Optional[pulumi.Input[bool]] = None,
+                 security_policy_id: Optional[pulumi.Input[str]] = None,
+                 __props__=None):
+        """
+        Create a AppSecRateProtection resource with the given unique name, props, and options.
+        :param str resource_name: The name of the resource.
+        :param pulumi.ResourceOptions opts: Options for the resource.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
-        The provider-assigned unique ID for this managed resource.
+        ...
+    @overload
+    def __init__(__self__,
+                 resource_name: str,
+                 args: AppSecRateProtectionArgs,
+                 opts: Optional[pulumi.ResourceOptions] = None):
+        """
+        Create a AppSecRateProtection resource with the given unique name, props, and options.
+        :param str resource_name: The name of the resource.
+        :param AppSecRateProtectionArgs args: The arguments to use to populate this resource's properties.
+        :param pulumi.ResourceOptions opts: Options for the resource.
+        """
+        ...
+    def __init__(__self__, resource_name: str, *args, **kwargs):
+        resource_args, opts = _utilities.get_resource_args_opts(AppSecRateProtectionArgs, pulumi.ResourceOptions, *args, **kwargs)
+        if resource_args is not None:
+            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
+        else:
+            __self__._internal_init(resource_name, *args, **kwargs)
+
+    def _internal_init(__self__,
+                 resource_name: str,
+                 opts: Optional[pulumi.ResourceOptions] = None,
+                 config_id: Optional[pulumi.Input[int]] = None,
+                 enabled: Optional[pulumi.Input[bool]] = None,
+                 security_policy_id: Optional[pulumi.Input[str]] = None,
+                 __props__=None):
+        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
+        if not isinstance(opts, pulumi.ResourceOptions):
+            raise TypeError('Expected resource options to be a ResourceOptions instance')
+        if opts.id is None:
+            if __props__ is not None:
+                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
+            __props__ = AppSecRateProtectionArgs.__new__(AppSecRateProtectionArgs)
+
+            if config_id is None and not opts.urn:
+                raise TypeError("Missing required property 'config_id'")
+            __props__.__dict__["config_id"] = config_id
+            if enabled is None and not opts.urn:
+                raise TypeError("Missing required property 'enabled'")
+            __props__.__dict__["enabled"] = enabled
+            if security_policy_id is None and not opts.urn:
+                raise TypeError("Missing required property 'security_policy_id'")
+            __props__.__dict__["security_policy_id"] = security_policy_id
+            __props__.__dict__["output_text"] = None
+        super(AppSecRateProtection, __self__).__init__(
+            'akamai:index/appSecRateProtection:AppSecRateProtection',
+            resource_name,
+            __props__,
+            opts)
+
+    @staticmethod
+    def get(resource_name: str,
+            id: pulumi.Input[str],
+            opts: Optional[pulumi.ResourceOptions] = None,
+            config_id: Optional[pulumi.Input[int]] = None,
+            enabled: Optional[pulumi.Input[bool]] = None,
+            output_text: Optional[pulumi.Input[str]] = None,
+            security_policy_id: Optional[pulumi.Input[str]] = None) -> 'AppSecRateProtection':
+        """
+        Get an existing AppSecRateProtection resource's state with the given name, id, and optional extra
+        properties used to qualify the lookup.
+
+        :param str resource_name: The unique name of the resulting resource.
+        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
+        :param pulumi.ResourceOptions opts: Options for the resource.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] output_text: Text representation
+        :param pulumi.Input[str] security_policy_id: Unique identifier of the security policy
         """
-        return pulumi.get(self, "id")
+        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
+
+        __props__ = _AppSecRateProtectionState.__new__(_AppSecRateProtectionState)
+
+        __props__.__dict__["config_id"] = config_id
+        __props__.__dict__["enabled"] = enabled
+        __props__.__dict__["output_text"] = output_text
+        __props__.__dict__["security_policy_id"] = security_policy_id
+        return AppSecRateProtection(resource_name, opts=opts, __props__=__props__)
+
+    @property
+    @pulumi.getter(name="configId")
+    def config_id(self) -> pulumi.Output[int]:
+        """
+        Unique identifier of the security configuration
+        """
+        return pulumi.get(self, "config_id")
 
     @property
     @pulumi.getter
-    def json(self) -> str:
-        return pulumi.get(self, "json")
+    def enabled(self) -> pulumi.Output[bool]:
+        return pulumi.get(self, "enabled")
 
     @property
     @pulumi.getter(name="outputText")
-    def output_text(self) -> str:
+    def output_text(self) -> pulumi.Output[str]:
+        """
+        Text representation
+        """
         return pulumi.get(self, "output_text")
 
     @property
-    @pulumi.getter(name="reputationProfileId")
-    def reputation_profile_id(self) -> Optional[int]:
-        return pulumi.get(self, "reputation_profile_id")
-
-    @property
     @pulumi.getter(name="securityPolicyId")
-    def security_policy_id(self) -> str:
+    def security_policy_id(self) -> pulumi.Output[str]:
+        """
+        Unique identifier of the security policy
+        """
         return pulumi.get(self, "security_policy_id")
 
-
-class AwaitableGetAppSecReputationProfileActionsResult(GetAppSecReputationProfileActionsResult):
-    # pylint: disable=using-constant-test
-    def __await__(self):
-        if False:
-            yield self
-        return GetAppSecReputationProfileActionsResult(
-            action=self.action,
-            config_id=self.config_id,
-            id=self.id,
-            json=self.json,
-            output_text=self.output_text,
-            reputation_profile_id=self.reputation_profile_id,
-            security_policy_id=self.security_policy_id)
-
-
-def get_app_sec_reputation_profile_actions(config_id: Optional[int] = None,
-                                           reputation_profile_id: Optional[int] = None,
-                                           security_policy_id: Optional[str] = None,
-                                           opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecReputationProfileActionsResult:
-    """
-    ##_get_app_sec_reputation_profile_actions_
-    **Scopes**: Security policy; reputation profile
-
-    Returns action information for your reputation profiles. Actions specify what happens any time a profile is triggered: the issue could be ignored, the request could be denied, or an alert could be generated.
-
-    **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/reputation-profiles](https://techdocs.akamai.com/application-security/reference/get-reputation-profiles-actions)
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    configuration = akamai.get_app_sec_configuration(name="Documentation")
-    reputation_profile_actions = akamai.get_app_sec_reputation_profile_actions(config_id=configuration.config_id,
-        security_policy_id="gms1_134637")
-    pulumi.export("reputationProfileActionsText", reputation_profile_actions.output_text)
-    pulumi.export("reputationProfileActionsJson", reputation_profile_actions.json)
-    reputation_profile_actions2_app_sec_reputation_profile_actions = akamai.get_app_sec_reputation_profile_actions(config_id=configuration.config_id,
-        security_policy_id="gms1_134637",
-        reputation_profile_id=12345)
-    pulumi.export("reputationProfileActions2", reputation_profile_actions.action)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `action`. Action taken any time the reputation profile is triggered. Valid values are:
-      - **alert**. Record the event.
-      - **deny**. Block the request.
-      - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.
-      - **none**. Take no action.
-    - `json`. JSON-formatted report of the reputation profile action information.
-    - `output_text`. Tabular report of the reputation profile action information.
-
-
-    :param int config_id: . Unique identifier of the security configuration associated with the reputation profiles.
-    :param int reputation_profile_id: . Unique identifier of the reputation profile you want to return information for. If not included, information is returned for all your reputation profiles.
-    :param str security_policy_id: . Unique identifier of the security policy associated with the reputation profiles.
-    """
-    __args__ = dict()
-    __args__['configId'] = config_id
-    __args__['reputationProfileId'] = reputation_profile_id
-    __args__['securityPolicyId'] = security_policy_id
-    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
-    __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecReputationProfileActions:getAppSecReputationProfileActions', __args__, opts=opts, typ=GetAppSecReputationProfileActionsResult).value
-
-    return AwaitableGetAppSecReputationProfileActionsResult(
-        action=__ret__.action,
-        config_id=__ret__.config_id,
-        id=__ret__.id,
-        json=__ret__.json,
-        output_text=__ret__.output_text,
-        reputation_profile_id=__ret__.reputation_profile_id,
-        security_policy_id=__ret__.security_policy_id)
-
-
-@_utilities.lift_output_func(get_app_sec_reputation_profile_actions)
-def get_app_sec_reputation_profile_actions_output(config_id: Optional[pulumi.Input[int]] = None,
-                                                  reputation_profile_id: Optional[pulumi.Input[Optional[int]]] = None,
-                                                  security_policy_id: Optional[pulumi.Input[str]] = None,
-                                                  opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecReputationProfileActionsResult]:
-    """
-    ##_get_app_sec_reputation_profile_actions_
-    **Scopes**: Security policy; reputation profile
-
-    Returns action information for your reputation profiles. Actions specify what happens any time a profile is triggered: the issue could be ignored, the request could be denied, or an alert could be generated.
-
-    **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/security-policies/{policyId}/reputation-profiles](https://techdocs.akamai.com/application-security/reference/get-reputation-profiles-actions)
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    configuration = akamai.get_app_sec_configuration(name="Documentation")
-    reputation_profile_actions = akamai.get_app_sec_reputation_profile_actions(config_id=configuration.config_id,
-        security_policy_id="gms1_134637")
-    pulumi.export("reputationProfileActionsText", reputation_profile_actions.output_text)
-    pulumi.export("reputationProfileActionsJson", reputation_profile_actions.json)
-    reputation_profile_actions2_app_sec_reputation_profile_actions = akamai.get_app_sec_reputation_profile_actions(config_id=configuration.config_id,
-        security_policy_id="gms1_134637",
-        reputation_profile_id=12345)
-    pulumi.export("reputationProfileActions2", reputation_profile_actions.action)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `action`. Action taken any time the reputation profile is triggered. Valid values are:
-      - **alert**. Record the event.
-      - **deny**. Block the request.
-      - **deny_custom_{custom_deny_id}**. The action defined by the custom deny is taken.
-      - **none**. Take no action.
-    - `json`. JSON-formatted report of the reputation profile action information.
-    - `output_text`. Tabular report of the reputation profile action information.
-
-
-    :param int config_id: . Unique identifier of the security configuration associated with the reputation profiles.
-    :param int reputation_profile_id: . Unique identifier of the reputation profile you want to return information for. If not included, information is returned for all your reputation profiles.
-    :param str security_policy_id: . Unique identifier of the security policy associated with the reputation profiles.
-    """
-    ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_reputation_profiles.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/app_sec_reputation_profile.py`

 * *Files 17% similar despite different names*

```diff
@@ -5,170 +5,216 @@
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
-__all__ = [
-    'GetAppSecReputationProfilesResult',
-    'AwaitableGetAppSecReputationProfilesResult',
-    'get_app_sec_reputation_profiles',
-    'get_app_sec_reputation_profiles_output',
-]
-
-@pulumi.output_type
-class GetAppSecReputationProfilesResult:
-    """
-    A collection of values returned by getAppSecReputationProfiles.
-    """
-    def __init__(__self__, config_id=None, id=None, json=None, output_text=None, reputation_profile_id=None):
-        if config_id and not isinstance(config_id, int):
-            raise TypeError("Expected argument 'config_id' to be a int")
+__all__ = ['AppSecReputationProfileArgs', 'AppSecReputationProfile']
+
+@pulumi.input_type
+class AppSecReputationProfileArgs:
+    def __init__(__self__, *,
+                 config_id: pulumi.Input[int],
+                 reputation_profile: pulumi.Input[str]):
+        """
+        The set of arguments for constructing a AppSecReputationProfile resource.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] reputation_profile: JSON-formatted definition of the reputation profile
+        """
         pulumi.set(__self__, "config_id", config_id)
-        if id and not isinstance(id, str):
-            raise TypeError("Expected argument 'id' to be a str")
-        pulumi.set(__self__, "id", id)
-        if json and not isinstance(json, str):
-            raise TypeError("Expected argument 'json' to be a str")
-        pulumi.set(__self__, "json", json)
-        if output_text and not isinstance(output_text, str):
-            raise TypeError("Expected argument 'output_text' to be a str")
-        pulumi.set(__self__, "output_text", output_text)
-        if reputation_profile_id and not isinstance(reputation_profile_id, int):
-            raise TypeError("Expected argument 'reputation_profile_id' to be a int")
-        pulumi.set(__self__, "reputation_profile_id", reputation_profile_id)
+        pulumi.set(__self__, "reputation_profile", reputation_profile)
 
     @property
     @pulumi.getter(name="configId")
-    def config_id(self) -> int:
+    def config_id(self) -> pulumi.Input[int]:
+        """
+        Unique identifier of the security configuration
+        """
         return pulumi.get(self, "config_id")
 
+    @config_id.setter
+    def config_id(self, value: pulumi.Input[int]):
+        pulumi.set(self, "config_id", value)
+
     @property
-    @pulumi.getter
-    def id(self) -> str:
+    @pulumi.getter(name="reputationProfile")
+    def reputation_profile(self) -> pulumi.Input[str]:
         """
-        The provider-assigned unique ID for this managed resource.
+        JSON-formatted definition of the reputation profile
         """
-        return pulumi.get(self, "id")
+        return pulumi.get(self, "reputation_profile")
+
+    @reputation_profile.setter
+    def reputation_profile(self, value: pulumi.Input[str]):
+        pulumi.set(self, "reputation_profile", value)
+
+
+@pulumi.input_type
+class _AppSecReputationProfileState:
+    def __init__(__self__, *,
+                 config_id: Optional[pulumi.Input[int]] = None,
+                 reputation_profile: Optional[pulumi.Input[str]] = None,
+                 reputation_profile_id: Optional[pulumi.Input[int]] = None):
+        """
+        Input properties used for looking up and filtering AppSecReputationProfile resources.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] reputation_profile: JSON-formatted definition of the reputation profile
+        :param pulumi.Input[int] reputation_profile_id: Unique identifier of the reputation profile
+        """
+        if config_id is not None:
+            pulumi.set(__self__, "config_id", config_id)
+        if reputation_profile is not None:
+            pulumi.set(__self__, "reputation_profile", reputation_profile)
+        if reputation_profile_id is not None:
+            pulumi.set(__self__, "reputation_profile_id", reputation_profile_id)
 
     @property
-    @pulumi.getter
-    def json(self) -> str:
-        return pulumi.get(self, "json")
+    @pulumi.getter(name="configId")
+    def config_id(self) -> Optional[pulumi.Input[int]]:
+        """
+        Unique identifier of the security configuration
+        """
+        return pulumi.get(self, "config_id")
+
+    @config_id.setter
+    def config_id(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "config_id", value)
 
     @property
-    @pulumi.getter(name="outputText")
-    def output_text(self) -> str:
-        return pulumi.get(self, "output_text")
+    @pulumi.getter(name="reputationProfile")
+    def reputation_profile(self) -> Optional[pulumi.Input[str]]:
+        """
+        JSON-formatted definition of the reputation profile
+        """
+        return pulumi.get(self, "reputation_profile")
+
+    @reputation_profile.setter
+    def reputation_profile(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "reputation_profile", value)
 
     @property
     @pulumi.getter(name="reputationProfileId")
-    def reputation_profile_id(self) -> Optional[int]:
+    def reputation_profile_id(self) -> Optional[pulumi.Input[int]]:
+        """
+        Unique identifier of the reputation profile
+        """
         return pulumi.get(self, "reputation_profile_id")
 
+    @reputation_profile_id.setter
+    def reputation_profile_id(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "reputation_profile_id", value)
+
+
+class AppSecReputationProfile(pulumi.CustomResource):
+    @overload
+    def __init__(__self__,
+                 resource_name: str,
+                 opts: Optional[pulumi.ResourceOptions] = None,
+                 config_id: Optional[pulumi.Input[int]] = None,
+                 reputation_profile: Optional[pulumi.Input[str]] = None,
+                 __props__=None):
+        """
+        Create a AppSecReputationProfile resource with the given unique name, props, and options.
+        :param str resource_name: The name of the resource.
+        :param pulumi.ResourceOptions opts: Options for the resource.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] reputation_profile: JSON-formatted definition of the reputation profile
+        """
+        ...
+    @overload
+    def __init__(__self__,
+                 resource_name: str,
+                 args: AppSecReputationProfileArgs,
+                 opts: Optional[pulumi.ResourceOptions] = None):
+        """
+        Create a AppSecReputationProfile resource with the given unique name, props, and options.
+        :param str resource_name: The name of the resource.
+        :param AppSecReputationProfileArgs args: The arguments to use to populate this resource's properties.
+        :param pulumi.ResourceOptions opts: Options for the resource.
+        """
+        ...
+    def __init__(__self__, resource_name: str, *args, **kwargs):
+        resource_args, opts = _utilities.get_resource_args_opts(AppSecReputationProfileArgs, pulumi.ResourceOptions, *args, **kwargs)
+        if resource_args is not None:
+            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
+        else:
+            __self__._internal_init(resource_name, *args, **kwargs)
+
+    def _internal_init(__self__,
+                 resource_name: str,
+                 opts: Optional[pulumi.ResourceOptions] = None,
+                 config_id: Optional[pulumi.Input[int]] = None,
+                 reputation_profile: Optional[pulumi.Input[str]] = None,
+                 __props__=None):
+        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
+        if not isinstance(opts, pulumi.ResourceOptions):
+            raise TypeError('Expected resource options to be a ResourceOptions instance')
+        if opts.id is None:
+            if __props__ is not None:
+                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
+            __props__ = AppSecReputationProfileArgs.__new__(AppSecReputationProfileArgs)
+
+            if config_id is None and not opts.urn:
+                raise TypeError("Missing required property 'config_id'")
+            __props__.__dict__["config_id"] = config_id
+            if reputation_profile is None and not opts.urn:
+                raise TypeError("Missing required property 'reputation_profile'")
+            __props__.__dict__["reputation_profile"] = reputation_profile
+            __props__.__dict__["reputation_profile_id"] = None
+        super(AppSecReputationProfile, __self__).__init__(
+            'akamai:index/appSecReputationProfile:AppSecReputationProfile',
+            resource_name,
+            __props__,
+            opts)
+
+    @staticmethod
+    def get(resource_name: str,
+            id: pulumi.Input[str],
+            opts: Optional[pulumi.ResourceOptions] = None,
+            config_id: Optional[pulumi.Input[int]] = None,
+            reputation_profile: Optional[pulumi.Input[str]] = None,
+            reputation_profile_id: Optional[pulumi.Input[int]] = None) -> 'AppSecReputationProfile':
+        """
+        Get an existing AppSecReputationProfile resource's state with the given name, id, and optional extra
+        properties used to qualify the lookup.
+
+        :param str resource_name: The unique name of the resulting resource.
+        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
+        :param pulumi.ResourceOptions opts: Options for the resource.
+        :param pulumi.Input[int] config_id: Unique identifier of the security configuration
+        :param pulumi.Input[str] reputation_profile: JSON-formatted definition of the reputation profile
+        :param pulumi.Input[int] reputation_profile_id: Unique identifier of the reputation profile
+        """
+        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
+
+        __props__ = _AppSecReputationProfileState.__new__(_AppSecReputationProfileState)
+
+        __props__.__dict__["config_id"] = config_id
+        __props__.__dict__["reputation_profile"] = reputation_profile
+        __props__.__dict__["reputation_profile_id"] = reputation_profile_id
+        return AppSecReputationProfile(resource_name, opts=opts, __props__=__props__)
+
+    @property
+    @pulumi.getter(name="configId")
+    def config_id(self) -> pulumi.Output[int]:
+        """
+        Unique identifier of the security configuration
+        """
+        return pulumi.get(self, "config_id")
+
+    @property
+    @pulumi.getter(name="reputationProfile")
+    def reputation_profile(self) -> pulumi.Output[str]:
+        """
+        JSON-formatted definition of the reputation profile
+        """
+        return pulumi.get(self, "reputation_profile")
+
+    @property
+    @pulumi.getter(name="reputationProfileId")
+    def reputation_profile_id(self) -> pulumi.Output[int]:
+        """
+        Unique identifier of the reputation profile
+        """
+        return pulumi.get(self, "reputation_profile_id")
 
-class AwaitableGetAppSecReputationProfilesResult(GetAppSecReputationProfilesResult):
-    # pylint: disable=using-constant-test
-    def __await__(self):
-        if False:
-            yield self
-        return GetAppSecReputationProfilesResult(
-            config_id=self.config_id,
-            id=self.id,
-            json=self.json,
-            output_text=self.output_text,
-            reputation_profile_id=self.reputation_profile_id)
-
-
-def get_app_sec_reputation_profiles(config_id: Optional[int] = None,
-                                    reputation_profile_id: Optional[int] = None,
-                                    opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecReputationProfilesResult:
-    """
-    **Scopes**: Security configuration; reputation profile
-
-    Returns information about your reputation profiles. Reputation profiles grade the security risk of an IP address based on previous activities associated with that address. Depending on the reputation score, and depending on how your configuration has been set up, requests from a specific IP address can trigger an alert, or even be blocked.
-
-    **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/reputation-profiles](https://techdocs.akamai.com/application-security/reference/get-reputation-profiles)
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    configuration = akamai.get_app_sec_configuration(name="Documentation")
-    reputation_profiles = akamai.get_app_sec_reputation_profiles(config_id=configuration.config_id)
-    pulumi.export("reputationProfilesOutput", reputation_profiles.output_text)
-    pulumi.export("reputationProfilesJson", reputation_profiles.json)
-    reputation_profile = akamai.get_app_sec_reputation_profiles(config_id=configuration.config_id,
-        reputation_profile_id=12345)
-    pulumi.export("reputationProfileJson", reputation_profile.json)
-    pulumi.export("reputationProfileOutput", reputation_profile.output_text)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `output_text`. Tabular report of the details about the specified reputation profile or profiles.
-    - `json`. JSON-formatted report of the details about the specified reputation profile or profiles.
-
-
-    :param int config_id: . Unique identifier of the security configuration associated with the reputation profiles.
-    :param int reputation_profile_id: . Unique identifier of the reputation profile you want to return information for. If not included, information is returned for all your reputation profiles.
-    """
-    __args__ = dict()
-    __args__['configId'] = config_id
-    __args__['reputationProfileId'] = reputation_profile_id
-    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
-    __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecReputationProfiles:getAppSecReputationProfiles', __args__, opts=opts, typ=GetAppSecReputationProfilesResult).value
-
-    return AwaitableGetAppSecReputationProfilesResult(
-        config_id=__ret__.config_id,
-        id=__ret__.id,
-        json=__ret__.json,
-        output_text=__ret__.output_text,
-        reputation_profile_id=__ret__.reputation_profile_id)
-
-
-@_utilities.lift_output_func(get_app_sec_reputation_profiles)
-def get_app_sec_reputation_profiles_output(config_id: Optional[pulumi.Input[int]] = None,
-                                           reputation_profile_id: Optional[pulumi.Input[Optional[int]]] = None,
-                                           opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecReputationProfilesResult]:
-    """
-    **Scopes**: Security configuration; reputation profile
-
-    Returns information about your reputation profiles. Reputation profiles grade the security risk of an IP address based on previous activities associated with that address. Depending on the reputation score, and depending on how your configuration has been set up, requests from a specific IP address can trigger an alert, or even be blocked.
-
-    **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/reputation-profiles](https://techdocs.akamai.com/application-security/reference/get-reputation-profiles)
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    configuration = akamai.get_app_sec_configuration(name="Documentation")
-    reputation_profiles = akamai.get_app_sec_reputation_profiles(config_id=configuration.config_id)
-    pulumi.export("reputationProfilesOutput", reputation_profiles.output_text)
-    pulumi.export("reputationProfilesJson", reputation_profiles.json)
-    reputation_profile = akamai.get_app_sec_reputation_profiles(config_id=configuration.config_id,
-        reputation_profile_id=12345)
-    pulumi.export("reputationProfileJson", reputation_profile.json)
-    pulumi.export("reputationProfileOutput", reputation_profile.output_text)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `output_text`. Tabular report of the details about the specified reputation profile or profiles.
-    - `json`. JSON-formatted report of the details about the specified reputation profile or profiles.
-
-
-    :param int config_id: . Unique identifier of the security configuration associated with the reputation profiles.
-    :param int reputation_profile_id: . Unique identifier of the reputation profile you want to return information for. If not included, information is returned for all your reputation profiles.
-    """
-    ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_rules.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_eval_rules.py`

 * *Files 14% similar despite different names*

```diff
@@ -6,44 +6,44 @@
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
 __all__ = [
-    'GetAppSecRulesResult',
-    'AwaitableGetAppSecRulesResult',
-    'get_app_sec_rules',
-    'get_app_sec_rules_output',
+    'GetAppSecEvalRulesResult',
+    'AwaitableGetAppSecEvalRulesResult',
+    'get_app_sec_eval_rules',
+    'get_app_sec_eval_rules_output',
 ]
 
 @pulumi.output_type
-class GetAppSecRulesResult:
+class GetAppSecEvalRulesResult:
     """
-    A collection of values returned by getAppSecRules.
+    A collection of values returned by getAppSecEvalRules.
     """
-    def __init__(__self__, condition_exception=None, config_id=None, id=None, json=None, output_text=None, rule_action=None, rule_id=None, security_policy_id=None):
+    def __init__(__self__, condition_exception=None, config_id=None, eval_rule_action=None, id=None, json=None, output_text=None, rule_id=None, security_policy_id=None):
         if condition_exception and not isinstance(condition_exception, str):
             raise TypeError("Expected argument 'condition_exception' to be a str")
         pulumi.set(__self__, "condition_exception", condition_exception)
         if config_id and not isinstance(config_id, int):
             raise TypeError("Expected argument 'config_id' to be a int")
         pulumi.set(__self__, "config_id", config_id)
+        if eval_rule_action and not isinstance(eval_rule_action, str):
+            raise TypeError("Expected argument 'eval_rule_action' to be a str")
+        pulumi.set(__self__, "eval_rule_action", eval_rule_action)
         if id and not isinstance(id, str):
             raise TypeError("Expected argument 'id' to be a str")
         pulumi.set(__self__, "id", id)
         if json and not isinstance(json, str):
             raise TypeError("Expected argument 'json' to be a str")
         pulumi.set(__self__, "json", json)
         if output_text and not isinstance(output_text, str):
             raise TypeError("Expected argument 'output_text' to be a str")
         pulumi.set(__self__, "output_text", output_text)
-        if rule_action and not isinstance(rule_action, str):
-            raise TypeError("Expected argument 'rule_action' to be a str")
-        pulumi.set(__self__, "rule_action", rule_action)
         if rule_id and not isinstance(rule_id, int):
             raise TypeError("Expected argument 'rule_id' to be a int")
         pulumi.set(__self__, "rule_id", rule_id)
         if security_policy_id and not isinstance(security_policy_id, str):
             raise TypeError("Expected argument 'security_policy_id' to be a str")
         pulumi.set(__self__, "security_policy_id", security_policy_id)
 
@@ -54,14 +54,19 @@
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> int:
         return pulumi.get(self, "config_id")
 
     @property
+    @pulumi.getter(name="evalRuleAction")
+    def eval_rule_action(self) -> str:
+        return pulumi.get(self, "eval_rule_action")
+
+    @property
     @pulumi.getter
     def id(self) -> str:
         """
         The provider-assigned unique ID for this managed resource.
         """
         return pulumi.get(self, "id")
 
@@ -72,80 +77,67 @@
 
     @property
     @pulumi.getter(name="outputText")
     def output_text(self) -> str:
         return pulumi.get(self, "output_text")
 
     @property
-    @pulumi.getter(name="ruleAction")
-    def rule_action(self) -> str:
-        return pulumi.get(self, "rule_action")
-
-    @property
     @pulumi.getter(name="ruleId")
     def rule_id(self) -> Optional[int]:
         return pulumi.get(self, "rule_id")
 
     @property
     @pulumi.getter(name="securityPolicyId")
     def security_policy_id(self) -> str:
         return pulumi.get(self, "security_policy_id")
 
 
-class AwaitableGetAppSecRulesResult(GetAppSecRulesResult):
+class AwaitableGetAppSecEvalRulesResult(GetAppSecEvalRulesResult):
     # pylint: disable=using-constant-test
     def __await__(self):
         if False:
             yield self
-        return GetAppSecRulesResult(
+        return GetAppSecEvalRulesResult(
             condition_exception=self.condition_exception,
             config_id=self.config_id,
+            eval_rule_action=self.eval_rule_action,
             id=self.id,
             json=self.json,
             output_text=self.output_text,
-            rule_action=self.rule_action,
             rule_id=self.rule_id,
             security_policy_id=self.security_policy_id)
 
 
-def get_app_sec_rules(config_id: Optional[int] = None,
-                      rule_id: Optional[int] = None,
-                      security_policy_id: Optional[str] = None,
-                      opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecRulesResult:
+def get_app_sec_eval_rules(config_id: Optional[int] = None,
+                           rule_id: Optional[int] = None,
+                           security_policy_id: Optional[str] = None,
+                           opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecEvalRulesResult:
     """
     Use this data source to access information about an existing resource.
-
-    :param int config_id: . Unique identifier of the security configuration associated with the rules.
-    :param int rule_id: . Unique identifier of the Kona Rule Set rule you want to return information for. If not included, information is returned for all your KRS rules.
-    :param str security_policy_id: . Unique identifier of the security policy associated with the rules.
     """
     __args__ = dict()
     __args__['configId'] = config_id
     __args__['ruleId'] = rule_id
     __args__['securityPolicyId'] = security_policy_id
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
-    __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecRules:getAppSecRules', __args__, opts=opts, typ=GetAppSecRulesResult).value
+    __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecEvalRules:getAppSecEvalRules', __args__, opts=opts, typ=GetAppSecEvalRulesResult).value
 
-    return AwaitableGetAppSecRulesResult(
+    return AwaitableGetAppSecEvalRulesResult(
         condition_exception=__ret__.condition_exception,
         config_id=__ret__.config_id,
+        eval_rule_action=__ret__.eval_rule_action,
         id=__ret__.id,
         json=__ret__.json,
         output_text=__ret__.output_text,
-        rule_action=__ret__.rule_action,
         rule_id=__ret__.rule_id,
         security_policy_id=__ret__.security_policy_id)
 
 
-@_utilities.lift_output_func(get_app_sec_rules)
-def get_app_sec_rules_output(config_id: Optional[pulumi.Input[int]] = None,
-                             rule_id: Optional[pulumi.Input[Optional[int]]] = None,
-                             security_policy_id: Optional[pulumi.Input[str]] = None,
-                             opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecRulesResult]:
+@_utilities.lift_output_func(get_app_sec_eval_rules)
+def get_app_sec_eval_rules_output(config_id: Optional[pulumi.Input[int]] = None,
+                                  rule_id: Optional[pulumi.Input[Optional[int]]] = None,
+                                  security_policy_id: Optional[pulumi.Input[str]] = None,
+                                  opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecEvalRulesResult]:
     """
     Use this data source to access information about an existing resource.
-
-    :param int config_id: . Unique identifier of the security configuration associated with the rules.
-    :param int rule_id: . Unique identifier of the Kona Rule Set rule you want to return information for. If not included, information is returned for all your KRS rules.
-    :param str security_policy_id: . Unique identifier of the security policy associated with the rules.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_security_policy.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_security_policy.py`

 * *Files 15% similar despite different names*

```diff
@@ -99,17 +99,14 @@
 
 
 def get_app_sec_security_policy(config_id: Optional[int] = None,
                                 security_policy_name: Optional[str] = None,
                                 opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecSecurityPolicyResult:
     """
     Use this data source to access information about an existing resource.
-
-    :param int config_id: . Unique identifier of the security configuration associated with the security policies.
-    :param str security_policy_name: . (Optional). Name of the security policy you want to return information for (be sure to reference the policy name and not the policy ID). If not included, information is returned for all your security policies.
     """
     __args__ = dict()
     __args__['configId'] = config_id
     __args__['securityPolicyName'] = security_policy_name
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecSecurityPolicy:getAppSecSecurityPolicy', __args__, opts=opts, typ=GetAppSecSecurityPolicyResult).value
 
@@ -125,12 +122,9 @@
 
 @_utilities.lift_output_func(get_app_sec_security_policy)
 def get_app_sec_security_policy_output(config_id: Optional[pulumi.Input[int]] = None,
                                        security_policy_name: Optional[pulumi.Input[Optional[str]]] = None,
                                        opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecSecurityPolicyResult]:
     """
     Use this data source to access information about an existing resource.
-
-    :param int config_id: . Unique identifier of the security configuration associated with the security policies.
-    :param str security_policy_name: . (Optional). Name of the security policy you want to return information for (be sure to reference the policy name and not the policy ID). If not included, information is returned for all your security policies.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_siem_settings.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_api_request_constraints.py`

 * *Files 23% similar despite different names*

```diff
@@ -6,38 +6,49 @@
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
 __all__ = [
-    'GetAppSecSiemSettingsResult',
-    'AwaitableGetAppSecSiemSettingsResult',
-    'get_app_sec_siem_settings',
-    'get_app_sec_siem_settings_output',
+    'GetAppSecApiRequestConstraintsResult',
+    'AwaitableGetAppSecApiRequestConstraintsResult',
+    'get_app_sec_api_request_constraints',
+    'get_app_sec_api_request_constraints_output',
 ]
 
 @pulumi.output_type
-class GetAppSecSiemSettingsResult:
+class GetAppSecApiRequestConstraintsResult:
     """
-    A collection of values returned by getAppSecSiemSettings.
+    A collection of values returned by getAppSecApiRequestConstraints.
     """
-    def __init__(__self__, config_id=None, id=None, json=None, output_text=None):
+    def __init__(__self__, api_id=None, config_id=None, id=None, json=None, output_text=None, security_policy_id=None):
+        if api_id and not isinstance(api_id, int):
+            raise TypeError("Expected argument 'api_id' to be a int")
+        pulumi.set(__self__, "api_id", api_id)
         if config_id and not isinstance(config_id, int):
             raise TypeError("Expected argument 'config_id' to be a int")
         pulumi.set(__self__, "config_id", config_id)
         if id and not isinstance(id, str):
             raise TypeError("Expected argument 'id' to be a str")
         pulumi.set(__self__, "id", id)
         if json and not isinstance(json, str):
             raise TypeError("Expected argument 'json' to be a str")
         pulumi.set(__self__, "json", json)
         if output_text and not isinstance(output_text, str):
             raise TypeError("Expected argument 'output_text' to be a str")
         pulumi.set(__self__, "output_text", output_text)
+        if security_policy_id and not isinstance(security_policy_id, str):
+            raise TypeError("Expected argument 'security_policy_id' to be a str")
+        pulumi.set(__self__, "security_policy_id", security_policy_id)
+
+    @property
+    @pulumi.getter(name="apiId")
+    def api_id(self) -> Optional[int]:
+        return pulumi.get(self, "api_id")
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> int:
         return pulumi.get(self, "config_id")
 
     @property
@@ -54,98 +65,59 @@
         return pulumi.get(self, "json")
 
     @property
     @pulumi.getter(name="outputText")
     def output_text(self) -> str:
         return pulumi.get(self, "output_text")
 
+    @property
+    @pulumi.getter(name="securityPolicyId")
+    def security_policy_id(self) -> str:
+        return pulumi.get(self, "security_policy_id")
+
 
-class AwaitableGetAppSecSiemSettingsResult(GetAppSecSiemSettingsResult):
+class AwaitableGetAppSecApiRequestConstraintsResult(GetAppSecApiRequestConstraintsResult):
     # pylint: disable=using-constant-test
     def __await__(self):
         if False:
             yield self
-        return GetAppSecSiemSettingsResult(
+        return GetAppSecApiRequestConstraintsResult(
+            api_id=self.api_id,
             config_id=self.config_id,
             id=self.id,
             json=self.json,
-            output_text=self.output_text)
+            output_text=self.output_text,
+            security_policy_id=self.security_policy_id)
 
 
-def get_app_sec_siem_settings(config_id: Optional[int] = None,
-                              opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecSiemSettingsResult:
+def get_app_sec_api_request_constraints(api_id: Optional[int] = None,
+                                        config_id: Optional[int] = None,
+                                        security_policy_id: Optional[str] = None,
+                                        opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecApiRequestConstraintsResult:
     """
-    **Scopes**: Security configuration
-
-    Returns the SIEM (Security Event and Information Management) settings for a security configuration.
-
-    **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/siem](https://techdocs.akamai.com/application-security/reference/get-siem)
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    configuration = akamai.get_app_sec_configuration(name="Documentation")
-    siem_settings = akamai.get_app_sec_siem_settings(config_id=configuration.config_id)
-    pulumi.export("siemSettingsJson", siem_settings.json)
-    pulumi.export("siemSettingsOutput", siem_settings.output_text)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `json`. JSON-formatted list of the SIEM setting information.
-    - `output_text`. Tabular report showing the SIEM setting information.
-
-
-    :param int config_id: . Unique identifier of the security configuration you want to return information for.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
+    __args__['apiId'] = api_id
     __args__['configId'] = config_id
+    __args__['securityPolicyId'] = security_policy_id
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
-    __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecSiemSettings:getAppSecSiemSettings', __args__, opts=opts, typ=GetAppSecSiemSettingsResult).value
+    __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecApiRequestConstraints:getAppSecApiRequestConstraints', __args__, opts=opts, typ=GetAppSecApiRequestConstraintsResult).value
 
-    return AwaitableGetAppSecSiemSettingsResult(
+    return AwaitableGetAppSecApiRequestConstraintsResult(
+        api_id=__ret__.api_id,
         config_id=__ret__.config_id,
         id=__ret__.id,
         json=__ret__.json,
-        output_text=__ret__.output_text)
+        output_text=__ret__.output_text,
+        security_policy_id=__ret__.security_policy_id)
 
 
-@_utilities.lift_output_func(get_app_sec_siem_settings)
-def get_app_sec_siem_settings_output(config_id: Optional[pulumi.Input[int]] = None,
-                                     opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecSiemSettingsResult]:
+@_utilities.lift_output_func(get_app_sec_api_request_constraints)
+def get_app_sec_api_request_constraints_output(api_id: Optional[pulumi.Input[Optional[int]]] = None,
+                                               config_id: Optional[pulumi.Input[int]] = None,
+                                               security_policy_id: Optional[pulumi.Input[str]] = None,
+                                               opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecApiRequestConstraintsResult]:
     """
-    **Scopes**: Security configuration
-
-    Returns the SIEM (Security Event and Information Management) settings for a security configuration.
-
-    **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/siem](https://techdocs.akamai.com/application-security/reference/get-siem)
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    configuration = akamai.get_app_sec_configuration(name="Documentation")
-    siem_settings = akamai.get_app_sec_siem_settings(config_id=configuration.config_id)
-    pulumi.export("siemSettingsJson", siem_settings.json)
-    pulumi.export("siemSettingsOutput", siem_settings.output_text)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `json`. JSON-formatted list of the SIEM setting information.
-    - `output_text`. Tabular report showing the SIEM setting information.
-
-
-    :param int config_id: . Unique identifier of the security configuration you want to return information for.
+    Use this data source to access information about an existing resource.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_version_notes.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_bypass_network_lists.py`

 * *Files 22% similar despite different names*

```diff
@@ -6,38 +6,49 @@
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
 __all__ = [
-    'GetAppSecVersionNotesResult',
-    'AwaitableGetAppSecVersionNotesResult',
-    'get_app_sec_version_notes',
-    'get_app_sec_version_notes_output',
+    'GetAppSecBypassNetworkListsResult',
+    'AwaitableGetAppSecBypassNetworkListsResult',
+    'get_app_sec_bypass_network_lists',
+    'get_app_sec_bypass_network_lists_output',
 ]
 
 @pulumi.output_type
-class GetAppSecVersionNotesResult:
+class GetAppSecBypassNetworkListsResult:
     """
-    A collection of values returned by getAppSecVersionNotes.
+    A collection of values returned by getAppSecBypassNetworkLists.
     """
-    def __init__(__self__, config_id=None, id=None, json=None, output_text=None):
+    def __init__(__self__, bypass_network_lists=None, config_id=None, id=None, json=None, output_text=None, security_policy_id=None):
+        if bypass_network_lists and not isinstance(bypass_network_lists, list):
+            raise TypeError("Expected argument 'bypass_network_lists' to be a list")
+        pulumi.set(__self__, "bypass_network_lists", bypass_network_lists)
         if config_id and not isinstance(config_id, int):
             raise TypeError("Expected argument 'config_id' to be a int")
         pulumi.set(__self__, "config_id", config_id)
         if id and not isinstance(id, str):
             raise TypeError("Expected argument 'id' to be a str")
         pulumi.set(__self__, "id", id)
         if json and not isinstance(json, str):
             raise TypeError("Expected argument 'json' to be a str")
         pulumi.set(__self__, "json", json)
         if output_text and not isinstance(output_text, str):
             raise TypeError("Expected argument 'output_text' to be a str")
         pulumi.set(__self__, "output_text", output_text)
+        if security_policy_id and not isinstance(security_policy_id, str):
+            raise TypeError("Expected argument 'security_policy_id' to be a str")
+        pulumi.set(__self__, "security_policy_id", security_policy_id)
+
+    @property
+    @pulumi.getter(name="bypassNetworkLists")
+    def bypass_network_lists(self) -> Sequence[str]:
+        return pulumi.get(self, "bypass_network_lists")
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> int:
         return pulumi.get(self, "config_id")
 
     @property
@@ -54,98 +65,56 @@
         return pulumi.get(self, "json")
 
     @property
     @pulumi.getter(name="outputText")
     def output_text(self) -> str:
         return pulumi.get(self, "output_text")
 
+    @property
+    @pulumi.getter(name="securityPolicyId")
+    def security_policy_id(self) -> str:
+        return pulumi.get(self, "security_policy_id")
+
 
-class AwaitableGetAppSecVersionNotesResult(GetAppSecVersionNotesResult):
+class AwaitableGetAppSecBypassNetworkListsResult(GetAppSecBypassNetworkListsResult):
     # pylint: disable=using-constant-test
     def __await__(self):
         if False:
             yield self
-        return GetAppSecVersionNotesResult(
+        return GetAppSecBypassNetworkListsResult(
+            bypass_network_lists=self.bypass_network_lists,
             config_id=self.config_id,
             id=self.id,
             json=self.json,
-            output_text=self.output_text)
+            output_text=self.output_text,
+            security_policy_id=self.security_policy_id)
 
 
-def get_app_sec_version_notes(config_id: Optional[int] = None,
-                              opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecVersionNotesResult:
+def get_app_sec_bypass_network_lists(config_id: Optional[int] = None,
+                                     security_policy_id: Optional[str] = None,
+                                     opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecBypassNetworkListsResult:
     """
-    **Scopes**: Security configuration
-
-    Returns the most recent version notes for a security configuration.
-
-    **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/version-notes](https://techdocs.akamai.com/application-security/reference/get-version-notes)
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    configuration = akamai.get_app_sec_configuration(name="Documentation")
-    version_notes = akamai.get_app_sec_version_notes(config_id=configuration.config_id)
-    pulumi.export("versionNotesText", version_notes.output_text)
-    pulumi.export("versionNotesJson", version_notes.json)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `json`. JSON-formatted list showing the version notes.
-    - `output_text`. Tabular report showing the version notes.
-
-
-    :param int config_id: . Unique identifier of the security configuration you want to return information for.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     __args__['configId'] = config_id
+    __args__['securityPolicyId'] = security_policy_id
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
-    __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecVersionNotes:getAppSecVersionNotes', __args__, opts=opts, typ=GetAppSecVersionNotesResult).value
+    __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecBypassNetworkLists:getAppSecBypassNetworkLists', __args__, opts=opts, typ=GetAppSecBypassNetworkListsResult).value
 
-    return AwaitableGetAppSecVersionNotesResult(
+    return AwaitableGetAppSecBypassNetworkListsResult(
+        bypass_network_lists=__ret__.bypass_network_lists,
         config_id=__ret__.config_id,
         id=__ret__.id,
         json=__ret__.json,
-        output_text=__ret__.output_text)
+        output_text=__ret__.output_text,
+        security_policy_id=__ret__.security_policy_id)
 
 
-@_utilities.lift_output_func(get_app_sec_version_notes)
-def get_app_sec_version_notes_output(config_id: Optional[pulumi.Input[int]] = None,
-                                     opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecVersionNotesResult]:
+@_utilities.lift_output_func(get_app_sec_bypass_network_lists)
+def get_app_sec_bypass_network_lists_output(config_id: Optional[pulumi.Input[int]] = None,
+                                            security_policy_id: Optional[pulumi.Input[str]] = None,
+                                            opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecBypassNetworkListsResult]:
     """
-    **Scopes**: Security configuration
-
-    Returns the most recent version notes for a security configuration.
-
-    **Related API Endpoint**: [/appsec/v1/configs/{configId}/versions/{versionNumber}/version-notes](https://techdocs.akamai.com/application-security/reference/get-version-notes)
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    configuration = akamai.get_app_sec_configuration(name="Documentation")
-    version_notes = akamai.get_app_sec_version_notes(config_id=configuration.config_id)
-    pulumi.export("versionNotesText", version_notes.output_text)
-    pulumi.export("versionNotesJson", version_notes.json)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned, and how that returned information is formatted:
-
-    - `json`. JSON-formatted list showing the version notes.
-    - `output_text`. Tabular report showing the version notes.
-
-
-    :param int config_id: . Unique identifier of the security configuration you want to return information for.
+    Use this data source to access information about an existing resource.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_app_sec_wap_selected_hostnames.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_wap_selected_hostnames.py`

 * *Files 22% similar despite different names*

```diff
@@ -116,47 +116,15 @@
             selected_hosts=self.selected_hosts)
 
 
 def get_app_sec_wap_selected_hostnames(config_id: Optional[int] = None,
                                        security_policy_id: Optional[str] = None,
                                        opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecWapSelectedHostnamesResult:
     """
-    **Scopes**: Security policy
-
-    Returns hostnames currently protected or being evaluated by a configuration and security policy.
-    This resource is available only to organizations running Web Application Protector (WAP).
-    Note that the WAP selected hostnames feature is currently in beta.
-    Please contact your Akamai representative for more information.
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    configuration = akamai.get_app_sec_configuration(name="Documentation")
-    wap_selected_hostnames = akamai.get_app_sec_wap_selected_hostnames(config_id=configuration.config_id,
-        security_policy_id="gms1_134637")
-    pulumi.export("protectedHostnames", wap_selected_hostnames.protected_hosts)
-    pulumi.export("evaluatedHostnames", wap_selected_hostnames.evaluated_hosts)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned and how that returned information is formatted:
-
-    - `protected_hostnames`. List of hostnames currently protected under the security configuration and security policy.
-    - `evaluated_hostnames`. List of hostnames currently being evaluated under the security configuration and security policy.
-    - `hostnames_json`. JSON-formatted report of the protected and evaluated hostnames.
-    - `output_text`. Tabular reports of the protected and evaluated hostnames.
-
-
-    :param int config_id: . Unique identifier of the security configuration associated with the hostnames.
-    :param str security_policy_id: . Unique identifier of the security policy associated with the hostnames.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     __args__['configId'] = config_id
     __args__['securityPolicyId'] = security_policy_id
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecWapSelectedHostnames:getAppSecWapSelectedHostnames', __args__, opts=opts, typ=GetAppSecWapSelectedHostnamesResult).value
 
@@ -173,42 +141,10 @@
 
 
 @_utilities.lift_output_func(get_app_sec_wap_selected_hostnames)
 def get_app_sec_wap_selected_hostnames_output(config_id: Optional[pulumi.Input[int]] = None,
                                               security_policy_id: Optional[pulumi.Input[str]] = None,
                                               opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecWapSelectedHostnamesResult]:
     """
-    **Scopes**: Security policy
-
-    Returns hostnames currently protected or being evaluated by a configuration and security policy.
-    This resource is available only to organizations running Web Application Protector (WAP).
-    Note that the WAP selected hostnames feature is currently in beta.
-    Please contact your Akamai representative for more information.
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    configuration = akamai.get_app_sec_configuration(name="Documentation")
-    wap_selected_hostnames = akamai.get_app_sec_wap_selected_hostnames(config_id=configuration.config_id,
-        security_policy_id="gms1_134637")
-    pulumi.export("protectedHostnames", wap_selected_hostnames.protected_hosts)
-    pulumi.export("evaluatedHostnames", wap_selected_hostnames.evaluated_hosts)
-    ```
-    ## Output Options
-
-    The following options can be used to determine the information returned and how that returned information is formatted:
-
-    - `protected_hostnames`. List of hostnames currently protected under the security configuration and security policy.
-    - `evaluated_hostnames`. List of hostnames currently being evaluated under the security configuration and security policy.
-    - `hostnames_json`. JSON-formatted report of the protected and evaluated hostnames.
-    - `output_text`. Tabular reports of the protected and evaluated hostnames.
-
-
-    :param int config_id: . Unique identifier of the security configuration associated with the hostnames.
-    :param str security_policy_id: . Unique identifier of the security policy associated with the hostnames.
+    Use this data source to access information about an existing resource.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_authorities_set.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_authorities_set.py`

 * *Files 20% similar despite different names*

```diff
@@ -61,34 +61,15 @@
             contract=self.contract,
             id=self.id)
 
 
 def get_authorities_set(contract: Optional[str] = None,
                         opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAuthoritiesSetResult:
     """
-    Use the _get_authorities_set_ data source to retrieve a contract's authorities set. You use the authorities set when creating new zones.
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    example = akamai.get_authorities_set(contract="ctr_1-AB123")
-    ```
-    ## Attributes reference
-
-    This data source supports this attribute:
-
-    * `authorities` - A list of authorities.
-
-
-    :param str contract: The contract ID.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     __args__['contract'] = contract
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getAuthoritiesSet:getAuthoritiesSet', __args__, opts=opts, typ=GetAuthoritiesSetResult).value
 
     return AwaitableGetAuthoritiesSetResult(
@@ -97,29 +78,10 @@
         id=__ret__.id)
 
 
 @_utilities.lift_output_func(get_authorities_set)
 def get_authorities_set_output(contract: Optional[pulumi.Input[str]] = None,
                                opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAuthoritiesSetResult]:
     """
-    Use the _get_authorities_set_ data source to retrieve a contract's authorities set. You use the authorities set when creating new zones.
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    example = akamai.get_authorities_set(contract="ctr_1-AB123")
-    ```
-    ## Attributes reference
-
-    This data source supports this attribute:
-
-    * `authorities` - A list of authorities.
-
-
-    :param str contract: The contract ID.
+    Use this data source to access information about an existing resource.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_cloudlets_api_prioritization_match_rule.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cloudlets_api_prioritization_match_rule.py`

 * *Files 17% similar despite different names*

```diff
@@ -63,27 +63,15 @@
             json=self.json,
             match_rules=self.match_rules)
 
 
 def get_cloudlets_api_prioritization_match_rule(match_rules: Optional[Sequence[pulumi.InputType['GetCloudletsApiPrioritizationMatchRuleMatchRuleArgs']]] = None,
                                                 opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetCloudletsApiPrioritizationMatchRuleResult:
     """
-    Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
-
-    Use the _get_cloudlets_api_prioritization_match_rule_ data source to build a match rule JSON object for the API Prioritization Cloudlet.
-
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `type` - The type of Cloudlet the rule is for.
-    * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
-
-
-    :param Sequence[pulumi.InputType['GetCloudletsApiPrioritizationMatchRuleMatchRuleArgs']] match_rules: (Optional) A list of Cloudlet-specific match rules for a policy.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     __args__['matchRules'] = match_rules
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getCloudletsApiPrioritizationMatchRule:getCloudletsApiPrioritizationMatchRule', __args__, opts=opts, typ=GetCloudletsApiPrioritizationMatchRuleResult).value
 
     return AwaitableGetCloudletsApiPrioritizationMatchRuleResult(
@@ -92,22 +80,10 @@
         match_rules=__ret__.match_rules)
 
 
 @_utilities.lift_output_func(get_cloudlets_api_prioritization_match_rule)
 def get_cloudlets_api_prioritization_match_rule_output(match_rules: Optional[pulumi.Input[Optional[Sequence[pulumi.InputType['GetCloudletsApiPrioritizationMatchRuleMatchRuleArgs']]]]] = None,
                                                        opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetCloudletsApiPrioritizationMatchRuleResult]:
     """
-    Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
-
-    Use the _get_cloudlets_api_prioritization_match_rule_ data source to build a match rule JSON object for the API Prioritization Cloudlet.
-
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `type` - The type of Cloudlet the rule is for.
-    * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
-
-
-    :param Sequence[pulumi.InputType['GetCloudletsApiPrioritizationMatchRuleMatchRuleArgs']] match_rules: (Optional) A list of Cloudlet-specific match rules for a policy.
+    Use this data source to access information about an existing resource.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_cloudlets_audience_segmentation_match_rule.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cloudlets_audience_segmentation_match_rule.py`

 * *Files 20% similar despite different names*

```diff
@@ -63,27 +63,15 @@
             json=self.json,
             match_rules=self.match_rules)
 
 
 def get_cloudlets_audience_segmentation_match_rule(match_rules: Optional[Sequence[pulumi.InputType['GetCloudletsAudienceSegmentationMatchRuleMatchRuleArgs']]] = None,
                                                    opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetCloudletsAudienceSegmentationMatchRuleResult:
     """
-    Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
-
-    Use the _get_cloudlets_audience_segmentation_match_rule_ data source to build a match rule JSON object for the Audience Segmentation Cloudlet.
-
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `type` - The type of Cloudlet the rule is for.
-    * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
-
-
-    :param Sequence[pulumi.InputType['GetCloudletsAudienceSegmentationMatchRuleMatchRuleArgs']] match_rules: (Optional) A list of Cloudlet-specific match rules for a policy.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     __args__['matchRules'] = match_rules
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getCloudletsAudienceSegmentationMatchRule:getCloudletsAudienceSegmentationMatchRule', __args__, opts=opts, typ=GetCloudletsAudienceSegmentationMatchRuleResult).value
 
     return AwaitableGetCloudletsAudienceSegmentationMatchRuleResult(
@@ -92,22 +80,10 @@
         match_rules=__ret__.match_rules)
 
 
 @_utilities.lift_output_func(get_cloudlets_audience_segmentation_match_rule)
 def get_cloudlets_audience_segmentation_match_rule_output(match_rules: Optional[pulumi.Input[Optional[Sequence[pulumi.InputType['GetCloudletsAudienceSegmentationMatchRuleMatchRuleArgs']]]]] = None,
                                                           opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetCloudletsAudienceSegmentationMatchRuleResult]:
     """
-    Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
-
-    Use the _get_cloudlets_audience_segmentation_match_rule_ data source to build a match rule JSON object for the Audience Segmentation Cloudlet.
-
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `type` - The type of Cloudlet the rule is for.
-    * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
-
-
-    :param Sequence[pulumi.InputType['GetCloudletsAudienceSegmentationMatchRuleMatchRuleArgs']] match_rules: (Optional) A list of Cloudlet-specific match rules for a policy.
+    Use this data source to access information about an existing resource.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_cloudlets_phased_release_match_rule.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cloudlets_phased_release_match_rule.py`

 * *Files 21% similar despite different names*

```diff
@@ -63,27 +63,15 @@
             json=self.json,
             match_rules=self.match_rules)
 
 
 def get_cloudlets_phased_release_match_rule(match_rules: Optional[Sequence[pulumi.InputType['GetCloudletsPhasedReleaseMatchRuleMatchRuleArgs']]] = None,
                                             opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetCloudletsPhasedReleaseMatchRuleResult:
     """
-    Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
-
-    Use the _get_cloudlets_phased_release_match_rule_ data source to build a match rule JSON object for the Phased Release Cloudlet.
-
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `type` - The type of Cloudlet the rule is for.
-    * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
-
-
-    :param Sequence[pulumi.InputType['GetCloudletsPhasedReleaseMatchRuleMatchRuleArgs']] match_rules: (Optional) A list of Cloudlet-specific match rules for a policy.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     __args__['matchRules'] = match_rules
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getCloudletsPhasedReleaseMatchRule:getCloudletsPhasedReleaseMatchRule', __args__, opts=opts, typ=GetCloudletsPhasedReleaseMatchRuleResult).value
 
     return AwaitableGetCloudletsPhasedReleaseMatchRuleResult(
@@ -92,22 +80,10 @@
         match_rules=__ret__.match_rules)
 
 
 @_utilities.lift_output_func(get_cloudlets_phased_release_match_rule)
 def get_cloudlets_phased_release_match_rule_output(match_rules: Optional[pulumi.Input[Optional[Sequence[pulumi.InputType['GetCloudletsPhasedReleaseMatchRuleMatchRuleArgs']]]]] = None,
                                                    opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetCloudletsPhasedReleaseMatchRuleResult]:
     """
-    Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
-
-    Use the _get_cloudlets_phased_release_match_rule_ data source to build a match rule JSON object for the Phased Release Cloudlet.
-
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `type` - The type of Cloudlet the rule is for.
-    * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
-
-
-    :param Sequence[pulumi.InputType['GetCloudletsPhasedReleaseMatchRuleMatchRuleArgs']] match_rules: (Optional) A list of Cloudlet-specific match rules for a policy.
+    Use this data source to access information about an existing resource.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_cloudlets_request_control_match_rule.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cloudlets_request_control_match_rule.py`

 * *Files 20% similar despite different names*

```diff
@@ -63,27 +63,15 @@
             json=self.json,
             match_rules=self.match_rules)
 
 
 def get_cloudlets_request_control_match_rule(match_rules: Optional[Sequence[pulumi.InputType['GetCloudletsRequestControlMatchRuleMatchRuleArgs']]] = None,
                                              opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetCloudletsRequestControlMatchRuleResult:
     """
-    Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
-
-    Use the _get_cloudlets_request_control_match_rule_ data source to build a match rule JSON object for the Request Control Cloudlet.
-
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `type` - The type of Cloudlet the rule is for.
-    * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
-
-
-    :param Sequence[pulumi.InputType['GetCloudletsRequestControlMatchRuleMatchRuleArgs']] match_rules: (Optional) A list of Cloudlet-specific match rules for a policy.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     __args__['matchRules'] = match_rules
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getCloudletsRequestControlMatchRule:getCloudletsRequestControlMatchRule', __args__, opts=opts, typ=GetCloudletsRequestControlMatchRuleResult).value
 
     return AwaitableGetCloudletsRequestControlMatchRuleResult(
@@ -92,22 +80,10 @@
         match_rules=__ret__.match_rules)
 
 
 @_utilities.lift_output_func(get_cloudlets_request_control_match_rule)
 def get_cloudlets_request_control_match_rule_output(match_rules: Optional[pulumi.Input[Optional[Sequence[pulumi.InputType['GetCloudletsRequestControlMatchRuleMatchRuleArgs']]]]] = None,
                                                     opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetCloudletsRequestControlMatchRuleResult]:
     """
-    Every policy version specifies the match rules that govern how the Cloudlet is used. Matches specify conditions that need to be met in the incoming request.
-
-    Use the _get_cloudlets_request_control_match_rule_ data source to build a match rule JSON object for the Request Control Cloudlet.
-
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `type` - The type of Cloudlet the rule is for.
-    * `json` - A `match_rules` JSON structure generated from the API schema that defines the rules for this policy.
-
-
-    :param Sequence[pulumi.InputType['GetCloudletsRequestControlMatchRuleMatchRuleArgs']] match_rules: (Optional) A list of Cloudlet-specific match rules for a policy.
+    Use this data source to access information about an existing resource.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_contract.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_group.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,120 +6,119 @@
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
 __all__ = [
-    'GetContractResult',
-    'AwaitableGetContractResult',
-    'get_contract',
-    'get_contract_output',
+    'GetGroupResult',
+    'AwaitableGetGroupResult',
+    'get_group',
+    'get_group_output',
 ]
 
 @pulumi.output_type
-class GetContractResult:
+class GetGroupResult:
     """
-    A collection of values returned by getContract.
+    A collection of values returned by getGroup.
     """
-    def __init__(__self__, group=None, group_id=None, group_name=None, id=None):
-        if group and not isinstance(group, str):
-            raise TypeError("Expected argument 'group' to be a str")
-        if group is not None:
-            warnings.warn("""The setting \"group\" has been deprecated.""", DeprecationWarning)
-            pulumi.log.warn("""group is deprecated: The setting \"group\" has been deprecated.""")
-
-        pulumi.set(__self__, "group", group)
-        if group_id and not isinstance(group_id, str):
-            raise TypeError("Expected argument 'group_id' to be a str")
-        pulumi.set(__self__, "group_id", group_id)
+    def __init__(__self__, contract=None, contract_id=None, group_name=None, id=None, name=None):
+        if contract and not isinstance(contract, str):
+            raise TypeError("Expected argument 'contract' to be a str")
+        if contract is not None:
+            warnings.warn("""The setting \"contract\" has been deprecated.""", DeprecationWarning)
+            pulumi.log.warn("""contract is deprecated: The setting \"contract\" has been deprecated.""")
+
+        pulumi.set(__self__, "contract", contract)
+        if contract_id and not isinstance(contract_id, str):
+            raise TypeError("Expected argument 'contract_id' to be a str")
+        pulumi.set(__self__, "contract_id", contract_id)
         if group_name and not isinstance(group_name, str):
             raise TypeError("Expected argument 'group_name' to be a str")
         pulumi.set(__self__, "group_name", group_name)
         if id and not isinstance(id, str):
             raise TypeError("Expected argument 'id' to be a str")
         pulumi.set(__self__, "id", id)
+        if name and not isinstance(name, str):
+            raise TypeError("Expected argument 'name' to be a str")
+        if name is not None:
+            warnings.warn("""The setting \"name\" has been deprecated.""", DeprecationWarning)
+            pulumi.log.warn("""name is deprecated: The setting \"name\" has been deprecated.""")
+
+        pulumi.set(__self__, "name", name)
 
     @property
     @pulumi.getter
-    def group(self) -> Optional[str]:
-        return pulumi.get(self, "group")
+    def contract(self) -> str:
+        return pulumi.get(self, "contract")
 
     @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> str:
-        return pulumi.get(self, "group_id")
+    @pulumi.getter(name="contractId")
+    def contract_id(self) -> str:
+        return pulumi.get(self, "contract_id")
 
     @property
     @pulumi.getter(name="groupName")
     def group_name(self) -> str:
         return pulumi.get(self, "group_name")
 
     @property
     @pulumi.getter
     def id(self) -> str:
         """
         The provider-assigned unique ID for this managed resource.
         """
         return pulumi.get(self, "id")
 
+    @property
+    @pulumi.getter
+    def name(self) -> str:
+        return pulumi.get(self, "name")
+
 
-class AwaitableGetContractResult(GetContractResult):
+class AwaitableGetGroupResult(GetGroupResult):
     # pylint: disable=using-constant-test
     def __await__(self):
         if False:
             yield self
-        return GetContractResult(
-            group=self.group,
-            group_id=self.group_id,
+        return GetGroupResult(
+            contract=self.contract,
+            contract_id=self.contract_id,
             group_name=self.group_name,
-            id=self.id)
+            id=self.id,
+            name=self.name)
 
 
-def get_contract(group: Optional[str] = None,
-                 group_id: Optional[str] = None,
-                 group_name: Optional[str] = None,
-                 opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetContractResult:
+def get_group(contract: Optional[str] = None,
+              contract_id: Optional[str] = None,
+              group_name: Optional[str] = None,
+              name: Optional[str] = None,
+              opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetGroupResult:
     """
-    Use the _get_contract_ data source to find a contract ID.
-
-    ## Attributes reference
-
-    * `id` - The contract's unique ID, including the `ctr_` prefix.
-
-
-    :param str group: Either the group ID or the group name that includes the contract. You can't use this argument with `group_id` and `group_name`.
-    :param str group_id: The unique ID of the group containing the contract, including the  `grp_` prefix.
-    :param str group_name: The name of the group containing the contract.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
-    __args__['group'] = group
-    __args__['groupId'] = group_id
+    __args__['contract'] = contract
+    __args__['contractId'] = contract_id
     __args__['groupName'] = group_name
+    __args__['name'] = name
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
-    __ret__ = pulumi.runtime.invoke('akamai:index/getContract:getContract', __args__, opts=opts, typ=GetContractResult).value
+    __ret__ = pulumi.runtime.invoke('akamai:index/getGroup:getGroup', __args__, opts=opts, typ=GetGroupResult).value
 
-    return AwaitableGetContractResult(
-        group=__ret__.group,
-        group_id=__ret__.group_id,
+    return AwaitableGetGroupResult(
+        contract=__ret__.contract,
+        contract_id=__ret__.contract_id,
         group_name=__ret__.group_name,
-        id=__ret__.id)
+        id=__ret__.id,
+        name=__ret__.name)
 
 
-@_utilities.lift_output_func(get_contract)
-def get_contract_output(group: Optional[pulumi.Input[Optional[str]]] = None,
-                        group_id: Optional[pulumi.Input[Optional[str]]] = None,
-                        group_name: Optional[pulumi.Input[Optional[str]]] = None,
-                        opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetContractResult]:
+@_utilities.lift_output_func(get_group)
+def get_group_output(contract: Optional[pulumi.Input[Optional[str]]] = None,
+                     contract_id: Optional[pulumi.Input[Optional[str]]] = None,
+                     group_name: Optional[pulumi.Input[Optional[str]]] = None,
+                     name: Optional[pulumi.Input[Optional[str]]] = None,
+                     opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetGroupResult]:
     """
-    Use the _get_contract_ data source to find a contract ID.
-
-    ## Attributes reference
-
-    * `id` - The contract's unique ID, including the `ctr_` prefix.
-
-
-    :param str group: Either the group ID or the group name that includes the contract. You can't use this argument with `group_id` and `group_name`.
-    :param str group_id: The unique ID of the group containing the contract, including the  `grp_` prefix.
-    :param str group_name: The name of the group containing the contract.
+    Use this data source to access information about an existing resource.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_contracts.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_contracts.py`

 * *Files 22% similar despite different names*

```diff
@@ -51,34 +51,15 @@
         return GetContractsResult(
             contracts=self.contracts,
             id=self.id)
 
 
 def get_contracts(opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetContractsResult:
     """
-    Use the _get_contracts_ data source to list contracts associated with the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you're using.
-
-    ## Example Usage
-
-    Return contracts associated with the EdgeGrid API client token currently used for authentication:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    my_example = akamai.get_contracts()
-    pulumi.export("propertyMatch", my_example)
-    ```
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `contracts` - A list of supported contracts, with the following properties:
-      * `contract_id` - The contract's unique ID, including the `ctr_` prefix.
-      * `contract_type_name` - The type of contract, either `DIRECT_CUSTOMER`, `INDIRECT_CUSTOMER`, `PARENT_CUSTOMER`, `REFERRAL_PARTNER`, `TIER_1_RESELLER`, `VAR_CUSTOMER`, `VALUE_ADDED_RESELLER`, `PARTNER`, `PORTAL_PARTNER`, `STREAMING_RESELLER`, `AKAMAI_INTERNAL`, or `UNKNOWN`.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getContracts:getContracts', __args__, opts=opts, typ=GetContractsResult).value
 
     return AwaitableGetContractsResult(
         contracts=__ret__.contracts,
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_cp_code.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/properties/get_cp_code.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,23 +3,25 @@
 # *** Do not edit by hand unless you're certain you know what you are doing! ***
 
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
-from . import _utilities
+from .. import _utilities
 
 __all__ = [
     'GetCpCodeResult',
     'AwaitableGetCpCodeResult',
     'get_cp_code',
     'get_cp_code_output',
 ]
 
+warnings.warn("""akamai.properties.getCpCode has been deprecated in favor of akamai.getCpCode""", DeprecationWarning)
+
 @pulumi.output_type
 class GetCpCodeResult:
     """
     A collection of values returned by getCpCode.
     """
     def __init__(__self__, contract=None, contract_id=None, group=None, group_id=None, id=None, name=None, product_ids=None):
         if contract and not isinstance(contract, str):
@@ -110,29 +112,24 @@
                 contract_id: Optional[str] = None,
                 group: Optional[str] = None,
                 group_id: Optional[str] = None,
                 name: Optional[str] = None,
                 opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetCpCodeResult:
     """
     Use this data source to access information about an existing resource.
-
-    :param str contract: Replaced by `contract_id`. Maintained for legacy purposes.
-    :param str contract_id: (Required) A contract's unique ID, including the `ctr_` prefix.
-    :param str group: Replaced by `group_id`. Maintained for legacy purposes.
-    :param str group_id: The group's unique ID, including the `grp_` prefix.
-    :param str name: The name of the CP code.
     """
+    pulumi.log.warn("""get_cp_code is deprecated: akamai.properties.getCpCode has been deprecated in favor of akamai.getCpCode""")
     __args__ = dict()
     __args__['contract'] = contract
     __args__['contractId'] = contract_id
     __args__['group'] = group
     __args__['groupId'] = group_id
     __args__['name'] = name
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
-    __ret__ = pulumi.runtime.invoke('akamai:index/getCpCode:getCpCode', __args__, opts=opts, typ=GetCpCodeResult).value
+    __ret__ = pulumi.runtime.invoke('akamai:properties/getCpCode:getCpCode', __args__, opts=opts, typ=GetCpCodeResult).value
 
     return AwaitableGetCpCodeResult(
         contract=__ret__.contract,
         contract_id=__ret__.contract_id,
         group=__ret__.group,
         group_id=__ret__.group_id,
         id=__ret__.id,
@@ -145,15 +142,10 @@
                        contract_id: Optional[pulumi.Input[Optional[str]]] = None,
                        group: Optional[pulumi.Input[Optional[str]]] = None,
                        group_id: Optional[pulumi.Input[Optional[str]]] = None,
                        name: Optional[pulumi.Input[str]] = None,
                        opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetCpCodeResult]:
     """
     Use this data source to access information about an existing resource.
-
-    :param str contract: Replaced by `contract_id`. Maintained for legacy purposes.
-    :param str contract_id: (Required) A contract's unique ID, including the `ctr_` prefix.
-    :param str group: Replaced by `group_id`. Maintained for legacy purposes.
-    :param str group_id: The group's unique ID, including the `grp_` prefix.
-    :param str name: The name of the CP code.
     """
+    pulumi.log.warn("""get_cp_code is deprecated: akamai.properties.getCpCode has been deprecated in favor of akamai.getCpCode""")
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_cps_deployments.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cps_deployments.py`

 * *Files 25% similar despite different names*

```diff
@@ -106,42 +106,15 @@
             staging_certificate_ecdsa=self.staging_certificate_ecdsa,
             staging_certificate_rsa=self.staging_certificate_rsa)
 
 
 def get_cps_deployments(enrollment_id: Optional[int] = None,
                         opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetCpsDeploymentsResult:
     """
-    Use the _get_cps_deployments_ data source to retrieve deployed certificates for a specific enrollment.
-
-    You'll see data for ECDSA, RSA, or both depending on the type and number of certificates you uploaded.
-
-    ## Basic usage
-
-    This example shows how to return information about deployed certificates for enrollment ID 12345.
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    example = akamai.get_cps_deployments(enrollment_id=12345)
-    ```
-
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `production_certificate_rsa` - The RSA certificate deployed on the production network.
-    * `production_certificate_ecdsa` - The ECDSA certificate deployed on the production network.
-    * `staging_certificate_rsa` - The RSA certificate deployed on the staging network.
-    * `staging_certificate_ecdsa` - The ECDSA certificate deployed on the staging network.
-    * `expiry_date` - The expiration date for the certificate in ISO-8601 format.
-    * `auto_renewal_start_time` - The specific date the automatic renewal will start on. The date is in ISO-8601 format. <br> For DV certificates, CPS automatically starts the renewal process 90 days before the current certificate expires. It then automatically deploys the renewed certificate when it receives it from the CA. <br> For third-party certificates, CPS creates a change. This change is needed to get a new CSR and upload the new certificate. Use the _get_cps_enrollments_ data source to view pending changes.
-
-
-    :param int enrollment_id: Unique identifier of the enrollment.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     __args__['enrollmentId'] = enrollment_id
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getCpsDeployments:getCpsDeployments', __args__, opts=opts, typ=GetCpsDeploymentsResult).value
 
     return AwaitableGetCpsDeploymentsResult(
@@ -155,37 +128,10 @@
         staging_certificate_rsa=__ret__.staging_certificate_rsa)
 
 
 @_utilities.lift_output_func(get_cps_deployments)
 def get_cps_deployments_output(enrollment_id: Optional[pulumi.Input[int]] = None,
                                opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetCpsDeploymentsResult]:
     """
-    Use the _get_cps_deployments_ data source to retrieve deployed certificates for a specific enrollment.
-
-    You'll see data for ECDSA, RSA, or both depending on the type and number of certificates you uploaded.
-
-    ## Basic usage
-
-    This example shows how to return information about deployed certificates for enrollment ID 12345.
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    example = akamai.get_cps_deployments(enrollment_id=12345)
-    ```
-
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `production_certificate_rsa` - The RSA certificate deployed on the production network.
-    * `production_certificate_ecdsa` - The ECDSA certificate deployed on the production network.
-    * `staging_certificate_rsa` - The RSA certificate deployed on the staging network.
-    * `staging_certificate_ecdsa` - The ECDSA certificate deployed on the staging network.
-    * `expiry_date` - The expiration date for the certificate in ISO-8601 format.
-    * `auto_renewal_start_time` - The specific date the automatic renewal will start on. The date is in ISO-8601 format. <br> For DV certificates, CPS automatically starts the renewal process 90 days before the current certificate expires. It then automatically deploys the renewed certificate when it receives it from the CA. <br> For third-party certificates, CPS creates a change. This change is needed to get a new CSR and upload the new certificate. Use the _get_cps_enrollments_ data source to view pending changes.
-
-
-    :param int enrollment_id: Unique identifier of the enrollment.
+    Use this data source to access information about an existing resource.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_dns_record_set.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_dns_record_set.py`

 * *Files identical despite different names*

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_edge_worker_activation.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/properties/get_activation.py`

 * *Files 21% similar despite different names*

```diff
@@ -3,152 +3,161 @@
 # *** Do not edit by hand unless you're certain you know what you are doing! ***
 
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
-from . import _utilities
+from .. import _utilities
 
 __all__ = [
-    'GetEdgeWorkerActivationResult',
-    'AwaitableGetEdgeWorkerActivationResult',
-    'get_edge_worker_activation',
-    'get_edge_worker_activation_output',
+    'GetActivationResult',
+    'AwaitableGetActivationResult',
+    'get_activation',
+    'get_activation_output',
 ]
 
 @pulumi.output_type
-class GetEdgeWorkerActivationResult:
+class GetActivationResult:
     """
-    A collection of values returned by getEdgeWorkerActivation.
+    A collection of values returned by getActivation.
     """
-    def __init__(__self__, activation_id=None, edgeworker_id=None, id=None, network=None, version=None):
-        if activation_id and not isinstance(activation_id, int):
-            raise TypeError("Expected argument 'activation_id' to be a int")
+    def __init__(__self__, activation_id=None, contacts=None, errors=None, id=None, network=None, note=None, property_id=None, status=None, version=None, warnings=None):
+        if activation_id and not isinstance(activation_id, str):
+            raise TypeError("Expected argument 'activation_id' to be a str")
         pulumi.set(__self__, "activation_id", activation_id)
-        if edgeworker_id and not isinstance(edgeworker_id, int):
-            raise TypeError("Expected argument 'edgeworker_id' to be a int")
-        pulumi.set(__self__, "edgeworker_id", edgeworker_id)
+        if contacts and not isinstance(contacts, list):
+            raise TypeError("Expected argument 'contacts' to be a list")
+        pulumi.set(__self__, "contacts", contacts)
+        if errors and not isinstance(errors, str):
+            raise TypeError("Expected argument 'errors' to be a str")
+        pulumi.set(__self__, "errors", errors)
         if id and not isinstance(id, str):
             raise TypeError("Expected argument 'id' to be a str")
         pulumi.set(__self__, "id", id)
         if network and not isinstance(network, str):
             raise TypeError("Expected argument 'network' to be a str")
         pulumi.set(__self__, "network", network)
-        if version and not isinstance(version, str):
-            raise TypeError("Expected argument 'version' to be a str")
+        if note and not isinstance(note, str):
+            raise TypeError("Expected argument 'note' to be a str")
+        pulumi.set(__self__, "note", note)
+        if property_id and not isinstance(property_id, str):
+            raise TypeError("Expected argument 'property_id' to be a str")
+        pulumi.set(__self__, "property_id", property_id)
+        if status and not isinstance(status, str):
+            raise TypeError("Expected argument 'status' to be a str")
+        pulumi.set(__self__, "status", status)
+        if version and not isinstance(version, int):
+            raise TypeError("Expected argument 'version' to be a int")
         pulumi.set(__self__, "version", version)
+        if warnings and not isinstance(warnings, str):
+            raise TypeError("Expected argument 'warnings' to be a str")
+        pulumi.set(__self__, "warnings", warnings)
 
     @property
     @pulumi.getter(name="activationId")
-    def activation_id(self) -> int:
+    def activation_id(self) -> str:
         return pulumi.get(self, "activation_id")
 
     @property
-    @pulumi.getter(name="edgeworkerId")
-    def edgeworker_id(self) -> int:
-        return pulumi.get(self, "edgeworker_id")
+    @pulumi.getter
+    def contacts(self) -> Sequence[str]:
+        return pulumi.get(self, "contacts")
+
+    @property
+    @pulumi.getter
+    def errors(self) -> str:
+        return pulumi.get(self, "errors")
 
     @property
     @pulumi.getter
     def id(self) -> str:
         """
         The provider-assigned unique ID for this managed resource.
         """
         return pulumi.get(self, "id")
 
     @property
     @pulumi.getter
-    def network(self) -> str:
+    def network(self) -> Optional[str]:
         return pulumi.get(self, "network")
 
     @property
     @pulumi.getter
-    def version(self) -> str:
+    def note(self) -> str:
+        return pulumi.get(self, "note")
+
+    @property
+    @pulumi.getter(name="propertyId")
+    def property_id(self) -> str:
+        return pulumi.get(self, "property_id")
+
+    @property
+    @pulumi.getter
+    def status(self) -> str:
+        return pulumi.get(self, "status")
+
+    @property
+    @pulumi.getter
+    def version(self) -> int:
         return pulumi.get(self, "version")
 
+    @property
+    @pulumi.getter
+    def warnings(self) -> str:
+        return pulumi.get(self, "warnings")
 
-class AwaitableGetEdgeWorkerActivationResult(GetEdgeWorkerActivationResult):
+
+class AwaitableGetActivationResult(GetActivationResult):
     # pylint: disable=using-constant-test
     def __await__(self):
         if False:
             yield self
-        return GetEdgeWorkerActivationResult(
+        return GetActivationResult(
             activation_id=self.activation_id,
-            edgeworker_id=self.edgeworker_id,
+            contacts=self.contacts,
+            errors=self.errors,
             id=self.id,
             network=self.network,
-            version=self.version)
+            note=self.note,
+            property_id=self.property_id,
+            status=self.status,
+            version=self.version,
+            warnings=self.warnings)
 
 
-def get_edge_worker_activation(edgeworker_id: Optional[int] = None,
-                               network: Optional[str] = None,
-                               opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetEdgeWorkerActivationResult:
+def get_activation(network: Optional[str] = None,
+                   property_id: Optional[str] = None,
+                   version: Optional[int] = None,
+                   opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetActivationResult:
     """
-    Use the _get_edge_worker_activation_ data source to fetch the latest activation for a given EdgeWorker ID.
-
-    ## Example Usage
-
-    This example returns the latest activation on the staging network:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    test = akamai.get_edge_worker_activation(edgeworker_id=1,
-        network="STAGING")
-    ```
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `activation_id` - The unique identifier of the activation.
-    * `version` - The EdgeWorker version of the latest activation.
-
-
-    :param int edgeworker_id: The unique identifier of the EdgeWorker.
-    :param str network: The network from where the activation information will be fetched.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
-    __args__['edgeworkerId'] = edgeworker_id
     __args__['network'] = network
+    __args__['propertyId'] = property_id
+    __args__['version'] = version
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
-    __ret__ = pulumi.runtime.invoke('akamai:index/getEdgeWorkerActivation:getEdgeWorkerActivation', __args__, opts=opts, typ=GetEdgeWorkerActivationResult).value
+    __ret__ = pulumi.runtime.invoke('akamai:properties/getActivation:getActivation', __args__, opts=opts, typ=GetActivationResult).value
 
-    return AwaitableGetEdgeWorkerActivationResult(
+    return AwaitableGetActivationResult(
         activation_id=__ret__.activation_id,
-        edgeworker_id=__ret__.edgeworker_id,
+        contacts=__ret__.contacts,
+        errors=__ret__.errors,
         id=__ret__.id,
         network=__ret__.network,
-        version=__ret__.version)
+        note=__ret__.note,
+        property_id=__ret__.property_id,
+        status=__ret__.status,
+        version=__ret__.version,
+        warnings=__ret__.warnings)
 
 
-@_utilities.lift_output_func(get_edge_worker_activation)
-def get_edge_worker_activation_output(edgeworker_id: Optional[pulumi.Input[int]] = None,
-                                      network: Optional[pulumi.Input[str]] = None,
-                                      opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetEdgeWorkerActivationResult]:
+@_utilities.lift_output_func(get_activation)
+def get_activation_output(network: Optional[pulumi.Input[Optional[str]]] = None,
+                          property_id: Optional[pulumi.Input[str]] = None,
+                          version: Optional[pulumi.Input[int]] = None,
+                          opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetActivationResult]:
     """
-    Use the _get_edge_worker_activation_ data source to fetch the latest activation for a given EdgeWorker ID.
-
-    ## Example Usage
-
-    This example returns the latest activation on the staging network:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    test = akamai.get_edge_worker_activation(edgeworker_id=1,
-        network="STAGING")
-    ```
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `activation_id` - The unique identifier of the activation.
-    * `version` - The EdgeWorker version of the latest activation.
-
-
-    :param int edgeworker_id: The unique identifier of the EdgeWorker.
-    :param str network: The network from where the activation information will be fetched.
+    Use this data source to access information about an existing resource.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_edge_workers_property_rules.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_edge_workers_property_rules.py`

 * *Files 6% similar despite different names*

```diff
@@ -62,16 +62,14 @@
             json=self.json)
 
 
 def get_edge_workers_property_rules(edgeworker_id: Optional[int] = None,
                                     opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetEdgeWorkersPropertyRulesResult:
     """
     Use this data source to access information about an existing resource.
-
-    :param int edgeworker_id: Unique identifier of an EdgeWorker ID.
     """
     __args__ = dict()
     __args__['edgeworkerId'] = edgeworker_id
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getEdgeWorkersPropertyRules:getEdgeWorkersPropertyRules', __args__, opts=opts, typ=GetEdgeWorkersPropertyRulesResult).value
 
     return AwaitableGetEdgeWorkersPropertyRulesResult(
@@ -81,11 +79,9 @@
 
 
 @_utilities.lift_output_func(get_edge_workers_property_rules)
 def get_edge_workers_property_rules_output(edgeworker_id: Optional[pulumi.Input[int]] = None,
                                            opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetEdgeWorkersPropertyRulesResult]:
     """
     Use this data source to access information about an existing resource.
-
-    :param int edgeworker_id: Unique identifier of an EdgeWorker ID.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_groups.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_groups.py`

 * *Files 25% similar despite different names*

```diff
@@ -51,37 +51,15 @@
         return GetGroupsResult(
             groups=self.groups,
             id=self.id)
 
 
 def get_groups(opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetGroupsResult:
     """
-    Use the _get_groups_ data source to list groups associated with the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you're using.
-
-    ## Basic usage
-
-    Return groups associated with the EdgeGrid API client token you're using:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    my_example = akamai.get_groups()
-    pulumi.export("propertyMatch", my_example)
-    ```
-
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `groups` - A list of supported groups, with the following attributes:
-      * `group_id` - A group's unique ID, including the `grp_` prefix.
-      * `group_name` - The name of the group.
-      * `parent_group_id` - The ID of the parent group, if applicable.
-      * `contract_ids` - An array of strings listing the contract IDs for each group.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getGroups:getGroups', __args__, opts=opts, typ=GetGroupsResult).value
 
     return AwaitableGetGroupsResult(
         groups=__ret__.groups,
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_gtm_default_datacenter.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/trafficmanagement/get_gtm_default_datacenter.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,23 +3,25 @@
 # *** Do not edit by hand unless you're certain you know what you are doing! ***
 
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
-from . import _utilities
+from .. import _utilities
 
 __all__ = [
     'GetGtmDefaultDatacenterResult',
     'AwaitableGetGtmDefaultDatacenterResult',
     'get_gtm_default_datacenter',
     'get_gtm_default_datacenter_output',
 ]
 
+warnings.warn("""akamai.trafficmanagement.getGtmDefaultDatacenter has been deprecated in favor of akamai.getGtmDefaultDatacenter""", DeprecationWarning)
+
 @pulumi.output_type
 class GetGtmDefaultDatacenterResult:
     """
     A collection of values returned by getGtmDefaultDatacenter.
     """
     def __init__(__self__, datacenter=None, datacenter_id=None, domain=None, id=None, nickname=None):
         if datacenter and not isinstance(datacenter, int):
@@ -80,53 +82,33 @@
             nickname=self.nickname)
 
 
 def get_gtm_default_datacenter(datacenter: Optional[int] = None,
                                domain: Optional[str] = None,
                                opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetGtmDefaultDatacenterResult:
     """
-    Use the _get_gtm_default_datacenter_ data source to retrieve the default data center, ID, and nickname.
-
-    ## Attributes reference
-
-    This data source supports these attributes:
-
-    * `id` - The data resource ID. Enter in this format: `<domain>:default_datacenter:<datacenter_id>`.
-    * `datacenter_id` - The default data center ID.
-    * `nickname` - The default data center nickname.
-
-
-    :param int datacenter: The default is `5400`.
+    Use this data source to access information about an existing resource.
     """
+    pulumi.log.warn("""get_gtm_default_datacenter is deprecated: akamai.trafficmanagement.getGtmDefaultDatacenter has been deprecated in favor of akamai.getGtmDefaultDatacenter""")
     __args__ = dict()
     __args__['datacenter'] = datacenter
     __args__['domain'] = domain
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
-    __ret__ = pulumi.runtime.invoke('akamai:index/getGtmDefaultDatacenter:getGtmDefaultDatacenter', __args__, opts=opts, typ=GetGtmDefaultDatacenterResult).value
+    __ret__ = pulumi.runtime.invoke('akamai:trafficmanagement/getGtmDefaultDatacenter:getGtmDefaultDatacenter', __args__, opts=opts, typ=GetGtmDefaultDatacenterResult).value
 
     return AwaitableGetGtmDefaultDatacenterResult(
         datacenter=__ret__.datacenter,
         datacenter_id=__ret__.datacenter_id,
         domain=__ret__.domain,
         id=__ret__.id,
         nickname=__ret__.nickname)
 
 
 @_utilities.lift_output_func(get_gtm_default_datacenter)
 def get_gtm_default_datacenter_output(datacenter: Optional[pulumi.Input[Optional[int]]] = None,
                                       domain: Optional[pulumi.Input[str]] = None,
                                       opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetGtmDefaultDatacenterResult]:
     """
-    Use the _get_gtm_default_datacenter_ data source to retrieve the default data center, ID, and nickname.
-
-    ## Attributes reference
-
-    This data source supports these attributes:
-
-    * `id` - The data resource ID. Enter in this format: `<domain>:default_datacenter:<datacenter_id>`.
-    * `datacenter_id` - The default data center ID.
-    * `nickname` - The default data center nickname.
-
-
-    :param int datacenter: The default is `5400`.
+    Use this data source to access information about an existing resource.
     """
+    pulumi.log.warn("""get_gtm_default_datacenter is deprecated: akamai.trafficmanagement.getGtmDefaultDatacenter has been deprecated in favor of akamai.getGtmDefaultDatacenter""")
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_iam_contact_types.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_iam_contact_types.py`

 * *Files 19% similar despite different names*

```diff
@@ -50,34 +50,15 @@
         return GetIamContactTypesResult(
             contact_types=self.contact_types,
             id=self.id)
 
 
 def get_iam_contact_types(opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetIamContactTypesResult:
     """
-    Use _get_iam_contact_types_ to retrieve all the possible `contact_types` that Akamai supports. Use the values from this data source to add or update a user's contact type.
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    contact_types = akamai.get_iam_contact_types()
-    pulumi.export("supportedContactTypes", contact_types)
-    ```
-    ## Attributes reference
-
-    These attributes are returned:
-
-    * `contact_types`  A list of contact types.
-
-    [API Reference](https://techdocs.akamai.com/iam-api/reference/get-user-contact-types)
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getIamContactTypes:getIamContactTypes', __args__, opts=opts, typ=GetIamContactTypesResult).value
 
     return AwaitableGetIamContactTypesResult(
         contact_types=__ret__.contact_types,
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_iam_countries.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_iam_countries.py`

 * *Files 10% similar despite different names*

```diff
@@ -50,34 +50,15 @@
         return GetIamCountriesResult(
             countries=self.countries,
             id=self.id)
 
 
 def get_iam_countries(opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetIamCountriesResult:
     """
-    Use _get_iam_countries_ to retrieve all the possible countries that Akamai supports. Use the values from this data source to add or update a user's country information.
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    countries = akamai.get_iam_countries()
-    pulumi.export("supportedCountries", countries)
-    ```
-    ## Attributes reference
-
-    These attributes are returned:
-
-    * `countries`  A list of countries.
-
-    [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-countries)
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getIamCountries:getIamCountries', __args__, opts=opts, typ=GetIamCountriesResult).value
 
     return AwaitableGetIamCountriesResult(
         countries=__ret__.countries,
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_iam_grantable_roles.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_iam_grantable_roles.py`

 * *Files 13% similar despite different names*

```diff
@@ -51,37 +51,15 @@
         return GetIamGrantableRolesResult(
             grantable_roles=self.grantable_roles,
             id=self.id)
 
 
 def get_iam_grantable_roles(opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetIamGrantableRolesResult:
     """
-    List which grantable roles you can include in a new custom role or add to an existing custom role.
-
-    ## Basic usage
-
-    This example returns the available roles to grant to users:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    example = akamai.get_iam_grantable_roles()
-    pulumi.export("akaGrantableRolesCount", len(data["akamai_iam_grantable_roles"]["test"]["grantable_roles"]))
-    pulumi.export("akaGrantableRoles", data["akamai_iam_grantable_roles"]["test"])
-    ```
-
-    ## Attributes reference
-
-    This resource returns this attribute:
-
-    * `grantable_roles` - Lists which grantable roles you can include in a new custom role or add to an existing custom role.
-      * `granted_role_id` - Granted role ID.
-      * `name` - Granted role name.
-      * `description` - Granted role description.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getIamGrantableRoles:getIamGrantableRoles', __args__, opts=opts, typ=GetIamGrantableRolesResult).value
 
     return AwaitableGetIamGrantableRolesResult(
         grantable_roles=__ret__.grantable_roles,
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_iam_roles.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_iam_roles.py`

 * *Files 12% similar despite different names*

```diff
@@ -51,34 +51,15 @@
         return GetIamRolesResult(
             id=self.id,
             roles=self.roles)
 
 
 def get_iam_roles(opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetIamRolesResult:
     """
-    Use _get_iam_roles_ to list roles for the current account and contract type. The account and contract type are determined by the access tokens in your API client. Use the `roleId` from this data source to construct the `auth_grants_json` when creating or updating a user's auth grants.
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    my_roles = akamai.get_iam_roles()
-    pulumi.export("roles", my_roles)
-    ```
-    ## Attributes reference
-
-    These attributes are returned:
-
-    * `roles`  A list of roles.
-
-    [API Reference](https://techdocs.akamai.com/iam-api/reference/get-roles)
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getIamRoles:getIamRoles', __args__, opts=opts, typ=GetIamRolesResult).value
 
     return AwaitableGetIamRolesResult(
         id=__ret__.id,
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_iam_states.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_iam_states.py`

 * *Files 24% similar despite different names*

```diff
@@ -61,37 +61,15 @@
             id=self.id,
             states=self.states)
 
 
 def get_iam_states(country: Optional[str] = None,
                    opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetIamStatesResult:
     """
-    Use _get_iam_states_ to list US states or Canadian provinces. If `country=USA` you may enter a value of `TBD` if you don't know a user's state. Administrators use this data source to set a user's state.
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    states = akamai.get_iam_states(country="canada")
-    pulumi.export("supportedStates", states)
-    ```
-    ## Attributes reference
-
-    These attributes are returned:
-
-    * `states`  A list of states.
-
-    [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-states)
-
-
-    :param str country: (required, string) Specifies USA or Canada.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     __args__['country'] = country
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getIamStates:getIamStates', __args__, opts=opts, typ=GetIamStatesResult).value
 
     return AwaitableGetIamStatesResult(
@@ -100,32 +78,10 @@
         states=__ret__.states)
 
 
 @_utilities.lift_output_func(get_iam_states)
 def get_iam_states_output(country: Optional[pulumi.Input[str]] = None,
                           opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetIamStatesResult]:
     """
-    Use _get_iam_states_ to list US states or Canadian provinces. If `country=USA` you may enter a value of `TBD` if you don't know a user's state. Administrators use this data source to set a user's state.
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    states = akamai.get_iam_states(country="canada")
-    pulumi.export("supportedStates", states)
-    ```
-    ## Attributes reference
-
-    These attributes are returned:
-
-    * `states`  A list of states.
-
-    [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-states)
-
-
-    :param str country: (required, string) Specifies USA or Canada.
+    Use this data source to access information about an existing resource.
     """
     ...
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_iam_supported_langs.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_iam_supported_langs.py`

 * *Files 16% similar despite different names*

```diff
@@ -50,34 +50,15 @@
         return GetIamSupportedLangsResult(
             id=self.id,
             languages=self.languages)
 
 
 def get_iam_supported_langs(opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetIamSupportedLangsResult:
     """
-    Use _get_iam_supported_langs_ to list all the possible languages Akamai supports. Use the values from this API to set the preferred language for a user. Users should see Control Center in the language you set for them. The default language is English.
-
-    ## Example Usage
-
-    Basic usage:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    supported_langs = akamai.get_iam_supported_langs()
-    pulumi.export("supportedSupportedLangs", supported_langs)
-    ```
-    ## Attributes reference
-
-    These attributes are returned:
-
-    * `languages`  Languages supported by Akamai
-
-    [API Reference](https://techdocs.akamai.com/iam-api/reference/get-user-languages)
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getIamSupportedLangs:getIamSupportedLangs', __args__, opts=opts, typ=GetIamSupportedLangsResult).value
 
     return AwaitableGetIamSupportedLangsResult(
         id=__ret__.id,
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_iam_timezones.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_iam_timezones.py`

 * *Files 14% similar despite different names*

```diff
@@ -51,27 +51,15 @@
         return GetIamTimezonesResult(
             id=self.id,
             timezones=self.timezones)
 
 
 def get_iam_timezones(opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetIamTimezonesResult:
     """
-    Use _get_iam_timezones_ to list all time zones Akamai supports. Time zones are in ISO 8601 format. Use the values from this data source to set the time zone for a user. Administrators use this data source to set a user's time zone. The default time zone is GMT.
-
-    ## Attributes reference
-
-    These attributes are returned:
-
-    * `timezones`  Supported timezones.
-      * `timezone` - The time zone ID.
-      * `description` - The description of a time zone, including the GMT +/-.
-      * `offset` - The time zone offset from GMT.
-      * `posix` - The time zone posix.
-
-    [API Reference](https://techdocs.akamai.com/iam-api/reference/get-common-timezones)
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getIamTimezones:getIamTimezones', __args__, opts=opts, typ=GetIamTimezonesResult).value
 
     return AwaitableGetIamTimezonesResult(
         id=__ret__.id,
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_properties.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_properties.py`

 * *Files 18% similar despite different names*

```diff
@@ -72,35 +72,15 @@
             properties=self.properties)
 
 
 def get_properties(contract_id: Optional[str] = None,
                    group_id: Optional[str] = None,
                    opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetPropertiesResult:
     """
-    Use the _get_properties_ data source to query and retrieve the list of properties for a group and contract
-    based on the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you're using.
-
-    ## Example Usage
-
-    Return properties associated with the EdgeGrid API client token currently used for authentication:
-
-    ```python
-    import pulumi
-
-    pulumi.export("myPropertyList", data["akamai_properties"]["example"])
-    ```
-    ## Attributes reference
-
-    This data source returns this attribute:
-
-    * `properties` - A list of properties available for the contract and group IDs provided.
-
-
-    :param str contract_id: (Required) A contract's unique ID, including the `ctr_` prefix.
-    :param str group_id: (Required) A group's unique ID, including the `grp_` prefix.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     __args__['contractId'] = contract_id
     __args__['groupId'] = group_id
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getProperties:getProperties', __args__, opts=opts, typ=GetPropertiesResult).value
 
@@ -112,30 +92,10 @@
 
 
 @_utilities.lift_output_func(get_properties)
 def get_properties_output(contract_id: Optional[pulumi.Input[str]] = None,
                           group_id: Optional[pulumi.Input[str]] = None,
                           opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetPropertiesResult]:
     """
-    Use the _get_properties_ data source to query and retrieve the list of properties for a group and contract
-    based on the [EdgeGrid API client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) you're using.
-
-    ## Example Usage
-
-    Return properties associated with the EdgeGrid API client token currently used for authentication:
-
-    ```python
-    import pulumi
-
-    pulumi.export("myPropertyList", data["akamai_properties"]["example"])
-    ```
-    ## Attributes reference
-
-    This data source returns this attribute:
-
-    * `properties` - A list of properties available for the contract and group IDs provided.
-
-
-    :param str contract_id: (Required) A contract's unique ID, including the `ctr_` prefix.
-    :param str group_id: (Required) A group's unique ID, including the `grp_` prefix.
+    Use this data source to access information about an existing resource.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_property.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_property_rules.py`

 * *Files 24% similar despite different names*

```diff
@@ -6,141 +6,144 @@
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
 __all__ = [
-    'GetPropertyResult',
-    'AwaitableGetPropertyResult',
-    'get_property',
-    'get_property_output',
+    'GetPropertyRulesResult',
+    'AwaitableGetPropertyRulesResult',
+    'get_property_rules',
+    'get_property_rules_output',
 ]
 
 @pulumi.output_type
-class GetPropertyResult:
+class GetPropertyRulesResult:
     """
-    A collection of values returned by getProperty.
+    A collection of values returned by getPropertyRules.
     """
-    def __init__(__self__, id=None, name=None, rules=None, version=None):
+    def __init__(__self__, contract_id=None, errors=None, group_id=None, id=None, property_id=None, rule_format=None, rules=None, version=None):
+        if contract_id and not isinstance(contract_id, str):
+            raise TypeError("Expected argument 'contract_id' to be a str")
+        pulumi.set(__self__, "contract_id", contract_id)
+        if errors and not isinstance(errors, str):
+            raise TypeError("Expected argument 'errors' to be a str")
+        pulumi.set(__self__, "errors", errors)
+        if group_id and not isinstance(group_id, str):
+            raise TypeError("Expected argument 'group_id' to be a str")
+        pulumi.set(__self__, "group_id", group_id)
         if id and not isinstance(id, str):
             raise TypeError("Expected argument 'id' to be a str")
         pulumi.set(__self__, "id", id)
-        if name and not isinstance(name, str):
-            raise TypeError("Expected argument 'name' to be a str")
-        pulumi.set(__self__, "name", name)
+        if property_id and not isinstance(property_id, str):
+            raise TypeError("Expected argument 'property_id' to be a str")
+        pulumi.set(__self__, "property_id", property_id)
+        if rule_format and not isinstance(rule_format, str):
+            raise TypeError("Expected argument 'rule_format' to be a str")
+        pulumi.set(__self__, "rule_format", rule_format)
         if rules and not isinstance(rules, str):
             raise TypeError("Expected argument 'rules' to be a str")
         pulumi.set(__self__, "rules", rules)
         if version and not isinstance(version, int):
             raise TypeError("Expected argument 'version' to be a int")
         pulumi.set(__self__, "version", version)
 
     @property
+    @pulumi.getter(name="contractId")
+    def contract_id(self) -> str:
+        return pulumi.get(self, "contract_id")
+
+    @property
+    @pulumi.getter
+    def errors(self) -> str:
+        return pulumi.get(self, "errors")
+
+    @property
+    @pulumi.getter(name="groupId")
+    def group_id(self) -> str:
+        return pulumi.get(self, "group_id")
+
+    @property
     @pulumi.getter
     def id(self) -> str:
         """
         The provider-assigned unique ID for this managed resource.
         """
         return pulumi.get(self, "id")
 
     @property
-    @pulumi.getter
-    def name(self) -> str:
-        return pulumi.get(self, "name")
+    @pulumi.getter(name="propertyId")
+    def property_id(self) -> str:
+        return pulumi.get(self, "property_id")
+
+    @property
+    @pulumi.getter(name="ruleFormat")
+    def rule_format(self) -> Optional[str]:
+        return pulumi.get(self, "rule_format")
 
     @property
     @pulumi.getter
     def rules(self) -> str:
         return pulumi.get(self, "rules")
 
     @property
     @pulumi.getter
-    def version(self) -> Optional[int]:
+    def version(self) -> int:
         return pulumi.get(self, "version")
 
 
-class AwaitableGetPropertyResult(GetPropertyResult):
+class AwaitableGetPropertyRulesResult(GetPropertyRulesResult):
     # pylint: disable=using-constant-test
     def __await__(self):
         if False:
             yield self
-        return GetPropertyResult(
+        return GetPropertyRulesResult(
+            contract_id=self.contract_id,
+            errors=self.errors,
+            group_id=self.group_id,
             id=self.id,
-            name=self.name,
+            property_id=self.property_id,
+            rule_format=self.rule_format,
             rules=self.rules,
             version=self.version)
 
 
-def get_property(name: Optional[str] = None,
-                 version: Optional[int] = None,
-                 opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetPropertyResult:
+def get_property_rules(contract_id: Optional[str] = None,
+                       group_id: Optional[str] = None,
+                       property_id: Optional[str] = None,
+                       rule_format: Optional[str] = None,
+                       version: Optional[int] = None,
+                       opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetPropertyRulesResult:
     """
-    Use the `Property` data source to query and list the property ID and rule tree based on the property name.
-
-    ## Example Usage
-
-    This example returns the property ID and rule tree based on the property name and optional version argument:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    example = akamai.get_property(name="terraform-demo",
-        version=1)
-    pulumi.export("myPropertyID", example)
-    ```
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `property_ID` - A property's unique identifier, including the `prp_` prefix.
-    * `rules` - A JSON-encoded rule tree for a given property.
-
-
-    :param str name: (Required) The property name.
-    :param int version: (Optional) The version of the property whose ID you want to list.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
-    __args__['name'] = name
+    __args__['contractId'] = contract_id
+    __args__['groupId'] = group_id
+    __args__['propertyId'] = property_id
+    __args__['ruleFormat'] = rule_format
     __args__['version'] = version
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
-    __ret__ = pulumi.runtime.invoke('akamai:index/getProperty:getProperty', __args__, opts=opts, typ=GetPropertyResult).value
+    __ret__ = pulumi.runtime.invoke('akamai:index/getPropertyRules:getPropertyRules', __args__, opts=opts, typ=GetPropertyRulesResult).value
 
-    return AwaitableGetPropertyResult(
+    return AwaitableGetPropertyRulesResult(
+        contract_id=__ret__.contract_id,
+        errors=__ret__.errors,
+        group_id=__ret__.group_id,
         id=__ret__.id,
-        name=__ret__.name,
+        property_id=__ret__.property_id,
+        rule_format=__ret__.rule_format,
         rules=__ret__.rules,
         version=__ret__.version)
 
 
-@_utilities.lift_output_func(get_property)
-def get_property_output(name: Optional[pulumi.Input[str]] = None,
-                        version: Optional[pulumi.Input[Optional[int]]] = None,
-                        opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetPropertyResult]:
+@_utilities.lift_output_func(get_property_rules)
+def get_property_rules_output(contract_id: Optional[pulumi.Input[Optional[str]]] = None,
+                              group_id: Optional[pulumi.Input[Optional[str]]] = None,
+                              property_id: Optional[pulumi.Input[str]] = None,
+                              rule_format: Optional[pulumi.Input[Optional[str]]] = None,
+                              version: Optional[pulumi.Input[Optional[int]]] = None,
+                              opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetPropertyRulesResult]:
     """
-    Use the `Property` data source to query and list the property ID and rule tree based on the property name.
-
-    ## Example Usage
-
-    This example returns the property ID and rule tree based on the property name and optional version argument:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    example = akamai.get_property(name="terraform-demo",
-        version=1)
-    pulumi.export("myPropertyID", example)
-    ```
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `property_ID` - A property's unique identifier, including the `prp_` prefix.
-    * `rules` - A JSON-encoded rule tree for a given property.
-
-
-    :param str name: (Required) The property name.
-    :param int version: (Optional) The version of the property whose ID you want to list.
+    Use this data source to access information about an existing resource.
     """
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_property_include.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_app_sec_security_policy_protections.py`

 * *Files 24% similar despite different names*

```diff
@@ -6,206 +6,185 @@
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
 __all__ = [
-    'GetPropertyIncludeResult',
-    'AwaitableGetPropertyIncludeResult',
-    'get_property_include',
-    'get_property_include_output',
+    'GetAppSecSecurityPolicyProtectionsResult',
+    'AwaitableGetAppSecSecurityPolicyProtectionsResult',
+    'get_app_sec_security_policy_protections',
+    'get_app_sec_security_policy_protections_output',
 ]
 
 @pulumi.output_type
-class GetPropertyIncludeResult:
+class GetAppSecSecurityPolicyProtectionsResult:
     """
-    A collection of values returned by getPropertyInclude.
+    A collection of values returned by getAppSecSecurityPolicyProtections.
     """
-    def __init__(__self__, contract_id=None, group_id=None, id=None, include_id=None, latest_version=None, name=None, production_version=None, staging_version=None, type=None):
-        if contract_id and not isinstance(contract_id, str):
-            raise TypeError("Expected argument 'contract_id' to be a str")
-        pulumi.set(__self__, "contract_id", contract_id)
-        if group_id and not isinstance(group_id, str):
-            raise TypeError("Expected argument 'group_id' to be a str")
-        pulumi.set(__self__, "group_id", group_id)
+    def __init__(__self__, apply_api_constraints=None, apply_application_layer_controls=None, apply_botman_controls=None, apply_malware_controls=None, apply_network_layer_controls=None, apply_rate_controls=None, apply_reputation_controls=None, apply_slow_post_controls=None, config_id=None, id=None, json=None, output_text=None, security_policy_id=None):
+        if apply_api_constraints and not isinstance(apply_api_constraints, bool):
+            raise TypeError("Expected argument 'apply_api_constraints' to be a bool")
+        pulumi.set(__self__, "apply_api_constraints", apply_api_constraints)
+        if apply_application_layer_controls and not isinstance(apply_application_layer_controls, bool):
+            raise TypeError("Expected argument 'apply_application_layer_controls' to be a bool")
+        pulumi.set(__self__, "apply_application_layer_controls", apply_application_layer_controls)
+        if apply_botman_controls and not isinstance(apply_botman_controls, bool):
+            raise TypeError("Expected argument 'apply_botman_controls' to be a bool")
+        pulumi.set(__self__, "apply_botman_controls", apply_botman_controls)
+        if apply_malware_controls and not isinstance(apply_malware_controls, bool):
+            raise TypeError("Expected argument 'apply_malware_controls' to be a bool")
+        pulumi.set(__self__, "apply_malware_controls", apply_malware_controls)
+        if apply_network_layer_controls and not isinstance(apply_network_layer_controls, bool):
+            raise TypeError("Expected argument 'apply_network_layer_controls' to be a bool")
+        pulumi.set(__self__, "apply_network_layer_controls", apply_network_layer_controls)
+        if apply_rate_controls and not isinstance(apply_rate_controls, bool):
+            raise TypeError("Expected argument 'apply_rate_controls' to be a bool")
+        pulumi.set(__self__, "apply_rate_controls", apply_rate_controls)
+        if apply_reputation_controls and not isinstance(apply_reputation_controls, bool):
+            raise TypeError("Expected argument 'apply_reputation_controls' to be a bool")
+        pulumi.set(__self__, "apply_reputation_controls", apply_reputation_controls)
+        if apply_slow_post_controls and not isinstance(apply_slow_post_controls, bool):
+            raise TypeError("Expected argument 'apply_slow_post_controls' to be a bool")
+        pulumi.set(__self__, "apply_slow_post_controls", apply_slow_post_controls)
+        if config_id and not isinstance(config_id, int):
+            raise TypeError("Expected argument 'config_id' to be a int")
+        pulumi.set(__self__, "config_id", config_id)
         if id and not isinstance(id, str):
             raise TypeError("Expected argument 'id' to be a str")
         pulumi.set(__self__, "id", id)
-        if include_id and not isinstance(include_id, str):
-            raise TypeError("Expected argument 'include_id' to be a str")
-        pulumi.set(__self__, "include_id", include_id)
-        if latest_version and not isinstance(latest_version, int):
-            raise TypeError("Expected argument 'latest_version' to be a int")
-        pulumi.set(__self__, "latest_version", latest_version)
-        if name and not isinstance(name, str):
-            raise TypeError("Expected argument 'name' to be a str")
-        pulumi.set(__self__, "name", name)
-        if production_version and not isinstance(production_version, int):
-            raise TypeError("Expected argument 'production_version' to be a int")
-        pulumi.set(__self__, "production_version", production_version)
-        if staging_version and not isinstance(staging_version, int):
-            raise TypeError("Expected argument 'staging_version' to be a int")
-        pulumi.set(__self__, "staging_version", staging_version)
-        if type and not isinstance(type, str):
-            raise TypeError("Expected argument 'type' to be a str")
-        pulumi.set(__self__, "type", type)
-
-    @property
-    @pulumi.getter(name="contractId")
-    def contract_id(self) -> str:
-        return pulumi.get(self, "contract_id")
-
-    @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> str:
-        return pulumi.get(self, "group_id")
+        if json and not isinstance(json, str):
+            raise TypeError("Expected argument 'json' to be a str")
+        pulumi.set(__self__, "json", json)
+        if output_text and not isinstance(output_text, str):
+            raise TypeError("Expected argument 'output_text' to be a str")
+        pulumi.set(__self__, "output_text", output_text)
+        if security_policy_id and not isinstance(security_policy_id, str):
+            raise TypeError("Expected argument 'security_policy_id' to be a str")
+        pulumi.set(__self__, "security_policy_id", security_policy_id)
 
     @property
-    @pulumi.getter
-    def id(self) -> str:
-        """
-        The provider-assigned unique ID for this managed resource.
-        """
-        return pulumi.get(self, "id")
+    @pulumi.getter(name="applyApiConstraints")
+    def apply_api_constraints(self) -> bool:
+        return pulumi.get(self, "apply_api_constraints")
 
     @property
-    @pulumi.getter(name="includeId")
-    def include_id(self) -> str:
-        return pulumi.get(self, "include_id")
+    @pulumi.getter(name="applyApplicationLayerControls")
+    def apply_application_layer_controls(self) -> bool:
+        return pulumi.get(self, "apply_application_layer_controls")
 
     @property
-    @pulumi.getter(name="latestVersion")
-    def latest_version(self) -> int:
-        return pulumi.get(self, "latest_version")
+    @pulumi.getter(name="applyBotmanControls")
+    def apply_botman_controls(self) -> bool:
+        return pulumi.get(self, "apply_botman_controls")
 
     @property
-    @pulumi.getter
-    def name(self) -> str:
-        return pulumi.get(self, "name")
+    @pulumi.getter(name="applyMalwareControls")
+    def apply_malware_controls(self) -> bool:
+        return pulumi.get(self, "apply_malware_controls")
+
+    @property
+    @pulumi.getter(name="applyNetworkLayerControls")
+    def apply_network_layer_controls(self) -> bool:
+        return pulumi.get(self, "apply_network_layer_controls")
+
+    @property
+    @pulumi.getter(name="applyRateControls")
+    def apply_rate_controls(self) -> bool:
+        return pulumi.get(self, "apply_rate_controls")
 
     @property
-    @pulumi.getter(name="productionVersion")
-    def production_version(self) -> int:
-        return pulumi.get(self, "production_version")
+    @pulumi.getter(name="applyReputationControls")
+    def apply_reputation_controls(self) -> bool:
+        return pulumi.get(self, "apply_reputation_controls")
 
     @property
-    @pulumi.getter(name="stagingVersion")
-    def staging_version(self) -> int:
-        return pulumi.get(self, "staging_version")
+    @pulumi.getter(name="applySlowPostControls")
+    def apply_slow_post_controls(self) -> bool:
+        return pulumi.get(self, "apply_slow_post_controls")
+
+    @property
+    @pulumi.getter(name="configId")
+    def config_id(self) -> int:
+        return pulumi.get(self, "config_id")
 
     @property
     @pulumi.getter
-    def type(self) -> str:
-        return pulumi.get(self, "type")
+    def id(self) -> str:
+        """
+        The provider-assigned unique ID for this managed resource.
+        """
+        return pulumi.get(self, "id")
 
+    @property
+    @pulumi.getter
+    def json(self) -> str:
+        return pulumi.get(self, "json")
+
+    @property
+    @pulumi.getter(name="outputText")
+    def output_text(self) -> str:
+        return pulumi.get(self, "output_text")
 
-class AwaitableGetPropertyIncludeResult(GetPropertyIncludeResult):
+    @property
+    @pulumi.getter(name="securityPolicyId")
+    def security_policy_id(self) -> str:
+        return pulumi.get(self, "security_policy_id")
+
+
+class AwaitableGetAppSecSecurityPolicyProtectionsResult(GetAppSecSecurityPolicyProtectionsResult):
     # pylint: disable=using-constant-test
     def __await__(self):
         if False:
             yield self
-        return GetPropertyIncludeResult(
-            contract_id=self.contract_id,
-            group_id=self.group_id,
+        return GetAppSecSecurityPolicyProtectionsResult(
+            apply_api_constraints=self.apply_api_constraints,
+            apply_application_layer_controls=self.apply_application_layer_controls,
+            apply_botman_controls=self.apply_botman_controls,
+            apply_malware_controls=self.apply_malware_controls,
+            apply_network_layer_controls=self.apply_network_layer_controls,
+            apply_rate_controls=self.apply_rate_controls,
+            apply_reputation_controls=self.apply_reputation_controls,
+            apply_slow_post_controls=self.apply_slow_post_controls,
+            config_id=self.config_id,
             id=self.id,
-            include_id=self.include_id,
-            latest_version=self.latest_version,
-            name=self.name,
-            production_version=self.production_version,
-            staging_version=self.staging_version,
-            type=self.type)
+            json=self.json,
+            output_text=self.output_text,
+            security_policy_id=self.security_policy_id)
 
 
-def get_property_include(contract_id: Optional[str] = None,
-                         group_id: Optional[str] = None,
-                         include_id: Optional[str] = None,
-                         opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetPropertyIncludeResult:
+def get_app_sec_security_policy_protections(config_id: Optional[int] = None,
+                                            security_policy_id: Optional[str] = None,
+                                            opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetAppSecSecurityPolicyProtectionsResult:
     """
-    Use the `PropertyInclude` data source to get details about a specific include.
-
-    ## Basic usage
-
-    This example returns details for an include based on contract, group, and include IDs.
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    my_example_property_include = akamai.get_property_include(contract_id="ctr_1234",
-        group_id="grp_5678",
-        include_id="inc_9012")
-    pulumi.export("myExample", my_example_property_include)
-    ```
-
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `name` -The descriptive name for the include.
-    * `type` -Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`. Use this field for filtering. `MICROSERVICES` allow different teams to work independently on different parts of a single site. `COMMON_SETTINGS` includes are useful for configurations that share a large number of settings, often managed by a central team.
-    * `latest_version` -Returns the most recent version of the include.
-    * `staging_version` -The include version currently activated on the staging network.
-    * `production_version` -The include version currently activated on the production network.
-
-
-    :param str contract_id: (Required) A contract's unique ID, including the optional `ctr_` prefix.
-    :param str group_id: (Required) A group's unique ID, including the optional `grp_` prefix.
-    :param str include_id: (Required) An include's unique ID with the optional `inc_` prefix.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
-    __args__['contractId'] = contract_id
-    __args__['groupId'] = group_id
-    __args__['includeId'] = include_id
+    __args__['configId'] = config_id
+    __args__['securityPolicyId'] = security_policy_id
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
-    __ret__ = pulumi.runtime.invoke('akamai:index/getPropertyInclude:getPropertyInclude', __args__, opts=opts, typ=GetPropertyIncludeResult).value
+    __ret__ = pulumi.runtime.invoke('akamai:index/getAppSecSecurityPolicyProtections:getAppSecSecurityPolicyProtections', __args__, opts=opts, typ=GetAppSecSecurityPolicyProtectionsResult).value
 
-    return AwaitableGetPropertyIncludeResult(
-        contract_id=__ret__.contract_id,
-        group_id=__ret__.group_id,
+    return AwaitableGetAppSecSecurityPolicyProtectionsResult(
+        apply_api_constraints=__ret__.apply_api_constraints,
+        apply_application_layer_controls=__ret__.apply_application_layer_controls,
+        apply_botman_controls=__ret__.apply_botman_controls,
+        apply_malware_controls=__ret__.apply_malware_controls,
+        apply_network_layer_controls=__ret__.apply_network_layer_controls,
+        apply_rate_controls=__ret__.apply_rate_controls,
+        apply_reputation_controls=__ret__.apply_reputation_controls,
+        apply_slow_post_controls=__ret__.apply_slow_post_controls,
+        config_id=__ret__.config_id,
         id=__ret__.id,
-        include_id=__ret__.include_id,
-        latest_version=__ret__.latest_version,
-        name=__ret__.name,
-        production_version=__ret__.production_version,
-        staging_version=__ret__.staging_version,
-        type=__ret__.type)
+        json=__ret__.json,
+        output_text=__ret__.output_text,
+        security_policy_id=__ret__.security_policy_id)
 
 
-@_utilities.lift_output_func(get_property_include)
-def get_property_include_output(contract_id: Optional[pulumi.Input[str]] = None,
-                                group_id: Optional[pulumi.Input[str]] = None,
-                                include_id: Optional[pulumi.Input[str]] = None,
-                                opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetPropertyIncludeResult]:
+@_utilities.lift_output_func(get_app_sec_security_policy_protections)
+def get_app_sec_security_policy_protections_output(config_id: Optional[pulumi.Input[int]] = None,
+                                                   security_policy_id: Optional[pulumi.Input[str]] = None,
+                                                   opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetAppSecSecurityPolicyProtectionsResult]:
     """
-    Use the `PropertyInclude` data source to get details about a specific include.
-
-    ## Basic usage
-
-    This example returns details for an include based on contract, group, and include IDs.
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    my_example_property_include = akamai.get_property_include(contract_id="ctr_1234",
-        group_id="grp_5678",
-        include_id="inc_9012")
-    pulumi.export("myExample", my_example_property_include)
-    ```
-
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `name` -The descriptive name for the include.
-    * `type` -Specifies the type of the include, either `MICROSERVICES` or `COMMON_SETTINGS`. Use this field for filtering. `MICROSERVICES` allow different teams to work independently on different parts of a single site. `COMMON_SETTINGS` includes are useful for configurations that share a large number of settings, often managed by a central team.
-    * `latest_version` -Returns the most recent version of the include.
-    * `staging_version` -The include version currently activated on the staging network.
-    * `production_version` -The include version currently activated on the production network.
-
-
-    :param str contract_id: (Required) A contract's unique ID, including the optional `ctr_` prefix.
-    :param str group_id: (Required) A group's unique ID, including the optional `grp_` prefix.
-    :param str include_id: (Required) An include's unique ID with the optional `inc_` prefix.
+    Use this data source to access information about an existing resource.
     """
     ...
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_property_include_activation.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cloudlets_application_load_balancer.py`

 * *Files 27% similar despite different names*

```diff
@@ -4,183 +4,208 @@
 
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
+from . import outputs
 
 __all__ = [
-    'GetPropertyIncludeActivationResult',
-    'AwaitableGetPropertyIncludeActivationResult',
-    'get_property_include_activation',
-    'get_property_include_activation_output',
+    'GetCloudletsApplicationLoadBalancerResult',
+    'AwaitableGetCloudletsApplicationLoadBalancerResult',
+    'get_cloudlets_application_load_balancer',
+    'get_cloudlets_application_load_balancer_output',
 ]
 
 @pulumi.output_type
-class GetPropertyIncludeActivationResult:
+class GetCloudletsApplicationLoadBalancerResult:
     """
-    A collection of values returned by getPropertyIncludeActivation.
+    A collection of values returned by getCloudletsApplicationLoadBalancer.
     """
-    def __init__(__self__, contract_id=None, group_id=None, id=None, include_id=None, name=None, network=None, note=None, notify_emails=None, version=None):
-        if contract_id and not isinstance(contract_id, str):
-            raise TypeError("Expected argument 'contract_id' to be a str")
-        pulumi.set(__self__, "contract_id", contract_id)
-        if group_id and not isinstance(group_id, str):
-            raise TypeError("Expected argument 'group_id' to be a str")
-        pulumi.set(__self__, "group_id", group_id)
+    def __init__(__self__, balancing_type=None, created_by=None, created_date=None, data_centers=None, deleted=None, description=None, id=None, immutable=None, last_modified_by=None, last_modified_date=None, liveness_settings=None, origin_id=None, type=None, version=None, warnings=None):
+        if balancing_type and not isinstance(balancing_type, str):
+            raise TypeError("Expected argument 'balancing_type' to be a str")
+        pulumi.set(__self__, "balancing_type", balancing_type)
+        if created_by and not isinstance(created_by, str):
+            raise TypeError("Expected argument 'created_by' to be a str")
+        pulumi.set(__self__, "created_by", created_by)
+        if created_date and not isinstance(created_date, str):
+            raise TypeError("Expected argument 'created_date' to be a str")
+        pulumi.set(__self__, "created_date", created_date)
+        if data_centers and not isinstance(data_centers, list):
+            raise TypeError("Expected argument 'data_centers' to be a list")
+        pulumi.set(__self__, "data_centers", data_centers)
+        if deleted and not isinstance(deleted, bool):
+            raise TypeError("Expected argument 'deleted' to be a bool")
+        pulumi.set(__self__, "deleted", deleted)
+        if description and not isinstance(description, str):
+            raise TypeError("Expected argument 'description' to be a str")
+        pulumi.set(__self__, "description", description)
         if id and not isinstance(id, str):
             raise TypeError("Expected argument 'id' to be a str")
         pulumi.set(__self__, "id", id)
-        if include_id and not isinstance(include_id, str):
-            raise TypeError("Expected argument 'include_id' to be a str")
-        pulumi.set(__self__, "include_id", include_id)
-        if name and not isinstance(name, str):
-            raise TypeError("Expected argument 'name' to be a str")
-        pulumi.set(__self__, "name", name)
-        if network and not isinstance(network, str):
-            raise TypeError("Expected argument 'network' to be a str")
-        pulumi.set(__self__, "network", network)
-        if note and not isinstance(note, str):
-            raise TypeError("Expected argument 'note' to be a str")
-        pulumi.set(__self__, "note", note)
-        if notify_emails and not isinstance(notify_emails, list):
-            raise TypeError("Expected argument 'notify_emails' to be a list")
-        pulumi.set(__self__, "notify_emails", notify_emails)
-        if version and not isinstance(version, str):
-            raise TypeError("Expected argument 'version' to be a str")
+        if immutable and not isinstance(immutable, bool):
+            raise TypeError("Expected argument 'immutable' to be a bool")
+        pulumi.set(__self__, "immutable", immutable)
+        if last_modified_by and not isinstance(last_modified_by, str):
+            raise TypeError("Expected argument 'last_modified_by' to be a str")
+        pulumi.set(__self__, "last_modified_by", last_modified_by)
+        if last_modified_date and not isinstance(last_modified_date, str):
+            raise TypeError("Expected argument 'last_modified_date' to be a str")
+        pulumi.set(__self__, "last_modified_date", last_modified_date)
+        if liveness_settings and not isinstance(liveness_settings, list):
+            raise TypeError("Expected argument 'liveness_settings' to be a list")
+        pulumi.set(__self__, "liveness_settings", liveness_settings)
+        if origin_id and not isinstance(origin_id, str):
+            raise TypeError("Expected argument 'origin_id' to be a str")
+        pulumi.set(__self__, "origin_id", origin_id)
+        if type and not isinstance(type, str):
+            raise TypeError("Expected argument 'type' to be a str")
+        pulumi.set(__self__, "type", type)
+        if version and not isinstance(version, int):
+            raise TypeError("Expected argument 'version' to be a int")
         pulumi.set(__self__, "version", version)
+        if warnings and not isinstance(warnings, str):
+            raise TypeError("Expected argument 'warnings' to be a str")
+        pulumi.set(__self__, "warnings", warnings)
 
     @property
-    @pulumi.getter(name="contractId")
-    def contract_id(self) -> str:
-        return pulumi.get(self, "contract_id")
+    @pulumi.getter(name="balancingType")
+    def balancing_type(self) -> str:
+        return pulumi.get(self, "balancing_type")
 
     @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> str:
-        return pulumi.get(self, "group_id")
+    @pulumi.getter(name="createdBy")
+    def created_by(self) -> str:
+        return pulumi.get(self, "created_by")
+
+    @property
+    @pulumi.getter(name="createdDate")
+    def created_date(self) -> str:
+        return pulumi.get(self, "created_date")
+
+    @property
+    @pulumi.getter(name="dataCenters")
+    def data_centers(self) -> Sequence['outputs.GetCloudletsApplicationLoadBalancerDataCenterResult']:
+        return pulumi.get(self, "data_centers")
+
+    @property
+    @pulumi.getter
+    def deleted(self) -> bool:
+        return pulumi.get(self, "deleted")
+
+    @property
+    @pulumi.getter
+    def description(self) -> str:
+        return pulumi.get(self, "description")
 
     @property
     @pulumi.getter
     def id(self) -> str:
         """
         The provider-assigned unique ID for this managed resource.
         """
         return pulumi.get(self, "id")
 
     @property
-    @pulumi.getter(name="includeId")
-    def include_id(self) -> str:
-        return pulumi.get(self, "include_id")
+    @pulumi.getter
+    def immutable(self) -> bool:
+        return pulumi.get(self, "immutable")
 
     @property
-    @pulumi.getter
-    def name(self) -> str:
-        return pulumi.get(self, "name")
+    @pulumi.getter(name="lastModifiedBy")
+    def last_modified_by(self) -> str:
+        return pulumi.get(self, "last_modified_by")
 
     @property
-    @pulumi.getter
-    def network(self) -> str:
-        return pulumi.get(self, "network")
+    @pulumi.getter(name="lastModifiedDate")
+    def last_modified_date(self) -> str:
+        return pulumi.get(self, "last_modified_date")
 
     @property
-    @pulumi.getter
-    def note(self) -> str:
-        return pulumi.get(self, "note")
+    @pulumi.getter(name="livenessSettings")
+    def liveness_settings(self) -> Sequence['outputs.GetCloudletsApplicationLoadBalancerLivenessSettingResult']:
+        return pulumi.get(self, "liveness_settings")
+
+    @property
+    @pulumi.getter(name="originId")
+    def origin_id(self) -> str:
+        return pulumi.get(self, "origin_id")
 
     @property
-    @pulumi.getter(name="notifyEmails")
-    def notify_emails(self) -> Sequence[str]:
-        return pulumi.get(self, "notify_emails")
+    @pulumi.getter
+    def type(self) -> str:
+        return pulumi.get(self, "type")
 
     @property
     @pulumi.getter
-    def version(self) -> str:
+    def version(self) -> Optional[int]:
         return pulumi.get(self, "version")
 
+    @property
+    @pulumi.getter
+    def warnings(self) -> str:
+        return pulumi.get(self, "warnings")
+
 
-class AwaitableGetPropertyIncludeActivationResult(GetPropertyIncludeActivationResult):
+class AwaitableGetCloudletsApplicationLoadBalancerResult(GetCloudletsApplicationLoadBalancerResult):
     # pylint: disable=using-constant-test
     def __await__(self):
         if False:
             yield self
-        return GetPropertyIncludeActivationResult(
-            contract_id=self.contract_id,
-            group_id=self.group_id,
+        return GetCloudletsApplicationLoadBalancerResult(
+            balancing_type=self.balancing_type,
+            created_by=self.created_by,
+            created_date=self.created_date,
+            data_centers=self.data_centers,
+            deleted=self.deleted,
+            description=self.description,
             id=self.id,
-            include_id=self.include_id,
-            name=self.name,
-            network=self.network,
-            note=self.note,
-            notify_emails=self.notify_emails,
-            version=self.version)
+            immutable=self.immutable,
+            last_modified_by=self.last_modified_by,
+            last_modified_date=self.last_modified_date,
+            liveness_settings=self.liveness_settings,
+            origin_id=self.origin_id,
+            type=self.type,
+            version=self.version,
+            warnings=self.warnings)
 
 
-def get_property_include_activation(contract_id: Optional[str] = None,
-                                    group_id: Optional[str] = None,
-                                    include_id: Optional[str] = None,
-                                    network: Optional[str] = None,
-                                    opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetPropertyIncludeActivationResult:
+def get_cloudlets_application_load_balancer(origin_id: Optional[str] = None,
+                                            version: Optional[int] = None,
+                                            opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetCloudletsApplicationLoadBalancerResult:
     """
-    Use the `PropertyIncludeActivation` data source to get activation details for an include on the provided network.
-
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `version` -The version of the activated include.
-    * `name` -The descriptive name for the property.
-    * `note` -A log message assigned to the activation request.
-    * `notify_emails` -The list of email addresses notified when the activation status changes.
-
-
-    :param str contract_id: (Required) A contract's unique ID, including the optional `ctr_` prefix.
-    :param str group_id: (Required) A group's unique ID, including the optional `grp_` prefix.
-    :param str include_id: (Required) An include's unique ID with the optional `inc_` prefix.
-    :param str network: (Required) The Akamai network where you want to check the activation details, either `STAGING` or `PRODUCTION`. `STAGING` is the default.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
-    __args__['contractId'] = contract_id
-    __args__['groupId'] = group_id
-    __args__['includeId'] = include_id
-    __args__['network'] = network
+    __args__['originId'] = origin_id
+    __args__['version'] = version
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
-    __ret__ = pulumi.runtime.invoke('akamai:index/getPropertyIncludeActivation:getPropertyIncludeActivation', __args__, opts=opts, typ=GetPropertyIncludeActivationResult).value
+    __ret__ = pulumi.runtime.invoke('akamai:index/getCloudletsApplicationLoadBalancer:getCloudletsApplicationLoadBalancer', __args__, opts=opts, typ=GetCloudletsApplicationLoadBalancerResult).value
 
-    return AwaitableGetPropertyIncludeActivationResult(
-        contract_id=__ret__.contract_id,
-        group_id=__ret__.group_id,
+    return AwaitableGetCloudletsApplicationLoadBalancerResult(
+        balancing_type=__ret__.balancing_type,
+        created_by=__ret__.created_by,
+        created_date=__ret__.created_date,
+        data_centers=__ret__.data_centers,
+        deleted=__ret__.deleted,
+        description=__ret__.description,
         id=__ret__.id,
-        include_id=__ret__.include_id,
-        name=__ret__.name,
-        network=__ret__.network,
-        note=__ret__.note,
-        notify_emails=__ret__.notify_emails,
-        version=__ret__.version)
-
-
-@_utilities.lift_output_func(get_property_include_activation)
-def get_property_include_activation_output(contract_id: Optional[pulumi.Input[str]] = None,
-                                           group_id: Optional[pulumi.Input[str]] = None,
-                                           include_id: Optional[pulumi.Input[str]] = None,
-                                           network: Optional[pulumi.Input[str]] = None,
-                                           opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetPropertyIncludeActivationResult]:
+        immutable=__ret__.immutable,
+        last_modified_by=__ret__.last_modified_by,
+        last_modified_date=__ret__.last_modified_date,
+        liveness_settings=__ret__.liveness_settings,
+        origin_id=__ret__.origin_id,
+        type=__ret__.type,
+        version=__ret__.version,
+        warnings=__ret__.warnings)
+
+
+@_utilities.lift_output_func(get_cloudlets_application_load_balancer)
+def get_cloudlets_application_load_balancer_output(origin_id: Optional[pulumi.Input[str]] = None,
+                                                   version: Optional[pulumi.Input[Optional[int]]] = None,
+                                                   opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetCloudletsApplicationLoadBalancerResult]:
     """
-    Use the `PropertyIncludeActivation` data source to get activation details for an include on the provided network.
-
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `version` -The version of the activated include.
-    * `name` -The descriptive name for the property.
-    * `note` -A log message assigned to the activation request.
-    * `notify_emails` -The list of email addresses notified when the activation status changes.
-
-
-    :param str contract_id: (Required) A contract's unique ID, including the optional `ctr_` prefix.
-    :param str group_id: (Required) A group's unique ID, including the optional `grp_` prefix.
-    :param str include_id: (Required) An include's unique ID with the optional `inc_` prefix.
-    :param str network: (Required) The Akamai network where you want to check the activation details, either `STAGING` or `PRODUCTION`. `STAGING` is the default.
+    Use this data source to access information about an existing resource.
     """
     ...
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_property_products.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_property_products.py`

 * *Files 23% similar despite different names*

```diff
@@ -62,35 +62,15 @@
             id=self.id,
             products=self.products)
 
 
 def get_property_products(contract_id: Optional[str] = None,
                           opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetPropertyProductsResult:
     """
-    Use the _get_property_products_ data source to list the products included on a contract.
-
-    ## Example Usage
-
-    This example returns products associated with the [EdgeGrid client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) for a given contract:
-
-    ```python
-    import pulumi
-
-    pulumi.export("propertyMatch", data["akamai_property_products"]["my-example"])
-    ```
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `products` - A list of supported products for the contract, including:
-      * `product_id` -The product's unique ID, including the `prd_` prefix.
-      * `product_name` - A string containing the product name.
-
-
-    :param str contract_id: (Required) A contract's unique ID, including the `ctr_` prefix.
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
     __args__['contractId'] = contract_id
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('akamai:index/getPropertyProducts:getPropertyProducts', __args__, opts=opts, typ=GetPropertyProductsResult).value
 
     return AwaitableGetPropertyProductsResult(
@@ -99,30 +79,10 @@
         products=__ret__.products)
 
 
 @_utilities.lift_output_func(get_property_products)
 def get_property_products_output(contract_id: Optional[pulumi.Input[str]] = None,
                                  opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetPropertyProductsResult]:
     """
-    Use the _get_property_products_ data source to list the products included on a contract.
-
-    ## Example Usage
-
-    This example returns products associated with the [EdgeGrid client token](https://techdocs.akamai.com/developer/docs/authenticate-with-edgegrid) for a given contract:
-
-    ```python
-    import pulumi
-
-    pulumi.export("propertyMatch", data["akamai_property_products"]["my-example"])
-    ```
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `products` - A list of supported products for the contract, including:
-      * `product_id` -The product's unique ID, including the `prd_` prefix.
-      * `product_name` - A string containing the product name.
-
-
-    :param str contract_id: (Required) A contract's unique ID, including the `ctr_` prefix.
+    Use this data source to access information about an existing resource.
     """
     ...
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/get_property_rule_formats.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_property.py`

 * *Files 22% similar despite different names*

```diff
@@ -6,75 +6,95 @@
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
 __all__ = [
-    'GetPropertyRuleFormatsResult',
-    'AwaitableGetPropertyRuleFormatsResult',
-    'get_property_rule_formats',
+    'GetPropertyResult',
+    'AwaitableGetPropertyResult',
+    'get_property',
+    'get_property_output',
 ]
 
 @pulumi.output_type
-class GetPropertyRuleFormatsResult:
+class GetPropertyResult:
     """
-    A collection of values returned by getPropertyRuleFormats.
+    A collection of values returned by getProperty.
     """
-    def __init__(__self__, id=None, rule_formats=None):
+    def __init__(__self__, id=None, name=None, rules=None, version=None):
         if id and not isinstance(id, str):
             raise TypeError("Expected argument 'id' to be a str")
         pulumi.set(__self__, "id", id)
-        if rule_formats and not isinstance(rule_formats, list):
-            raise TypeError("Expected argument 'rule_formats' to be a list")
-        pulumi.set(__self__, "rule_formats", rule_formats)
+        if name and not isinstance(name, str):
+            raise TypeError("Expected argument 'name' to be a str")
+        pulumi.set(__self__, "name", name)
+        if rules and not isinstance(rules, str):
+            raise TypeError("Expected argument 'rules' to be a str")
+        pulumi.set(__self__, "rules", rules)
+        if version and not isinstance(version, int):
+            raise TypeError("Expected argument 'version' to be a int")
+        pulumi.set(__self__, "version", version)
 
     @property
     @pulumi.getter
     def id(self) -> str:
         """
         The provider-assigned unique ID for this managed resource.
         """
         return pulumi.get(self, "id")
 
     @property
-    @pulumi.getter(name="ruleFormats")
-    def rule_formats(self) -> Sequence[str]:
-        return pulumi.get(self, "rule_formats")
+    @pulumi.getter
+    def name(self) -> str:
+        return pulumi.get(self, "name")
+
+    @property
+    @pulumi.getter
+    def rules(self) -> str:
+        return pulumi.get(self, "rules")
 
+    @property
+    @pulumi.getter
+    def version(self) -> Optional[int]:
+        return pulumi.get(self, "version")
 
-class AwaitableGetPropertyRuleFormatsResult(GetPropertyRuleFormatsResult):
+
+class AwaitableGetPropertyResult(GetPropertyResult):
     # pylint: disable=using-constant-test
     def __await__(self):
         if False:
             yield self
-        return GetPropertyRuleFormatsResult(
+        return GetPropertyResult(
             id=self.id,
-            rule_formats=self.rule_formats)
+            name=self.name,
+            rules=self.rules,
+            version=self.version)
 
 
-def get_property_rule_formats(opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetPropertyRuleFormatsResult:
+def get_property(name: Optional[str] = None,
+                 version: Optional[int] = None,
+                 opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetPropertyResult:
     """
-    Use the _get_property_rule_formats_ data source to query the list of
-    known rule formats.
-    You use rule formats to [freeze](https://techdocs.akamai.com/property-mgr/reference/modify-a-rule#freeze-a-feature-set-for-a-rule-tree) or
-    [update](https://techdocs.akamai.com/property-mgr/reference/modify-a-rule#update-rules-to-a-newer-set-of-features) the versioned set of behaviors
-    and criteria a rule tree invokes. Without this mechanism, behaviors and criteria
-    would update automatically and generate unexpected errors.
-
-    ## Example Usage
-
-    Use this example to list available property rule formats:
-
-    ```python
-    import pulumi
-
-    pulumi.export("propertyMatch", data["akamai_property_rule_formats"]["my-example"])
-    ```
+    Use this data source to access information about an existing resource.
     """
     __args__ = dict()
+    __args__['name'] = name
+    __args__['version'] = version
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
-    __ret__ = pulumi.runtime.invoke('akamai:index/getPropertyRuleFormats:getPropertyRuleFormats', __args__, opts=opts, typ=GetPropertyRuleFormatsResult).value
+    __ret__ = pulumi.runtime.invoke('akamai:index/getProperty:getProperty', __args__, opts=opts, typ=GetPropertyResult).value
 
-    return AwaitableGetPropertyRuleFormatsResult(
+    return AwaitableGetPropertyResult(
         id=__ret__.id,
-        rule_formats=__ret__.rule_formats)
+        name=__ret__.name,
+        rules=__ret__.rules,
+        version=__ret__.version)
+
+
+@_utilities.lift_output_func(get_property)
+def get_property_output(name: Optional[pulumi.Input[str]] = None,
+                        version: Optional[pulumi.Input[Optional[int]]] = None,
+                        opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetPropertyResult]:
+    """
+    Use this data source to access information about an existing resource.
+    """
+    ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/gtm_cidrmap.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/dns_zone.py`

 * *Files 27% similar despite different names*

```diff
@@ -7,373 +7,531 @@
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 from . import outputs
 from ._inputs import *
 
-__all__ = ['GtmCidrmapArgs', 'GtmCidrmap']
+__all__ = ['DnsZoneArgs', 'DnsZone']
 
 @pulumi.input_type
-class GtmCidrmapArgs:
+class DnsZoneArgs:
     def __init__(__self__, *,
-                 default_datacenter: pulumi.Input['GtmCidrmapDefaultDatacenterArgs'],
-                 domain: pulumi.Input[str],
-                 assignments: Optional[pulumi.Input[Sequence[pulumi.Input['GtmCidrmapAssignmentArgs']]]] = None,
-                 name: Optional[pulumi.Input[str]] = None,
-                 wait_on_complete: Optional[pulumi.Input[bool]] = None):
-        """
-        The set of arguments for constructing a GtmCidrmap resource.
-        :param pulumi.Input['GtmCidrmapDefaultDatacenterArgs'] default_datacenter: A placeholder for all other CIDR zones not found in these CIDR zones. Requires these additional arguments:
-        :param pulumi.Input[str] domain: GTM Domain name for the CIDR Map.
-        :param pulumi.Input[Sequence[pulumi.Input['GtmCidrmapAssignmentArgs']]] assignments: Contains information about the CIDR zone groupings of CIDR blocks. You can have multiple entries with this argument. If used, requires these additional arguments:
-        :param pulumi.Input[str] name: A descriptive label for the CIDR map, up to 255 characters.
-        :param pulumi.Input[bool] wait_on_complete: A boolean that, if set to `true`, waits for transaction to complete.
-        """
-        pulumi.set(__self__, "default_datacenter", default_datacenter)
-        pulumi.set(__self__, "domain", domain)
-        if assignments is not None:
-            pulumi.set(__self__, "assignments", assignments)
-        if name is not None:
-            pulumi.set(__self__, "name", name)
-        if wait_on_complete is not None:
-            pulumi.set(__self__, "wait_on_complete", wait_on_complete)
+                 contract: pulumi.Input[str],
+                 type: pulumi.Input[str],
+                 zone: pulumi.Input[str],
+                 comment: Optional[pulumi.Input[str]] = None,
+                 end_customer_id: Optional[pulumi.Input[str]] = None,
+                 group: Optional[pulumi.Input[str]] = None,
+                 masters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 sign_and_serve: Optional[pulumi.Input[bool]] = None,
+                 sign_and_serve_algorithm: Optional[pulumi.Input[str]] = None,
+                 target: Optional[pulumi.Input[str]] = None,
+                 tsig_key: Optional[pulumi.Input['DnsZoneTsigKeyArgs']] = None):
+        """
+        The set of arguments for constructing a DnsZone resource.
+        """
+        pulumi.set(__self__, "contract", contract)
+        pulumi.set(__self__, "type", type)
+        pulumi.set(__self__, "zone", zone)
+        if comment is not None:
+            pulumi.set(__self__, "comment", comment)
+        if end_customer_id is not None:
+            pulumi.set(__self__, "end_customer_id", end_customer_id)
+        if group is not None:
+            pulumi.set(__self__, "group", group)
+        if masters is not None:
+            pulumi.set(__self__, "masters", masters)
+        if sign_and_serve is not None:
+            pulumi.set(__self__, "sign_and_serve", sign_and_serve)
+        if sign_and_serve_algorithm is not None:
+            pulumi.set(__self__, "sign_and_serve_algorithm", sign_and_serve_algorithm)
+        if target is not None:
+            pulumi.set(__self__, "target", target)
+        if tsig_key is not None:
+            pulumi.set(__self__, "tsig_key", tsig_key)
 
     @property
-    @pulumi.getter(name="defaultDatacenter")
-    def default_datacenter(self) -> pulumi.Input['GtmCidrmapDefaultDatacenterArgs']:
-        """
-        A placeholder for all other CIDR zones not found in these CIDR zones. Requires these additional arguments:
-        """
-        return pulumi.get(self, "default_datacenter")
+    @pulumi.getter
+    def contract(self) -> pulumi.Input[str]:
+        return pulumi.get(self, "contract")
 
-    @default_datacenter.setter
-    def default_datacenter(self, value: pulumi.Input['GtmCidrmapDefaultDatacenterArgs']):
-        pulumi.set(self, "default_datacenter", value)
+    @contract.setter
+    def contract(self, value: pulumi.Input[str]):
+        pulumi.set(self, "contract", value)
 
     @property
     @pulumi.getter
-    def domain(self) -> pulumi.Input[str]:
-        """
-        GTM Domain name for the CIDR Map.
-        """
-        return pulumi.get(self, "domain")
+    def type(self) -> pulumi.Input[str]:
+        return pulumi.get(self, "type")
 
-    @domain.setter
-    def domain(self, value: pulumi.Input[str]):
-        pulumi.set(self, "domain", value)
+    @type.setter
+    def type(self, value: pulumi.Input[str]):
+        pulumi.set(self, "type", value)
 
     @property
     @pulumi.getter
-    def assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmCidrmapAssignmentArgs']]]]:
-        """
-        Contains information about the CIDR zone groupings of CIDR blocks. You can have multiple entries with this argument. If used, requires these additional arguments:
-        """
-        return pulumi.get(self, "assignments")
+    def zone(self) -> pulumi.Input[str]:
+        return pulumi.get(self, "zone")
 
-    @assignments.setter
-    def assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmCidrmapAssignmentArgs']]]]):
-        pulumi.set(self, "assignments", value)
+    @zone.setter
+    def zone(self, value: pulumi.Input[str]):
+        pulumi.set(self, "zone", value)
 
     @property
     @pulumi.getter
-    def name(self) -> Optional[pulumi.Input[str]]:
-        """
-        A descriptive label for the CIDR map, up to 255 characters.
-        """
-        return pulumi.get(self, "name")
+    def comment(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "comment")
 
-    @name.setter
-    def name(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "name", value)
+    @comment.setter
+    def comment(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "comment", value)
 
     @property
-    @pulumi.getter(name="waitOnComplete")
-    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
-        """
-        A boolean that, if set to `true`, waits for transaction to complete.
-        """
-        return pulumi.get(self, "wait_on_complete")
+    @pulumi.getter(name="endCustomerId")
+    def end_customer_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "end_customer_id")
+
+    @end_customer_id.setter
+    def end_customer_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "end_customer_id", value)
+
+    @property
+    @pulumi.getter
+    def group(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "group")
+
+    @group.setter
+    def group(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "group", value)
+
+    @property
+    @pulumi.getter
+    def masters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
+        return pulumi.get(self, "masters")
+
+    @masters.setter
+    def masters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
+        pulumi.set(self, "masters", value)
+
+    @property
+    @pulumi.getter(name="signAndServe")
+    def sign_and_serve(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "sign_and_serve")
+
+    @sign_and_serve.setter
+    def sign_and_serve(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "sign_and_serve", value)
+
+    @property
+    @pulumi.getter(name="signAndServeAlgorithm")
+    def sign_and_serve_algorithm(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "sign_and_serve_algorithm")
+
+    @sign_and_serve_algorithm.setter
+    def sign_and_serve_algorithm(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "sign_and_serve_algorithm", value)
 
-    @wait_on_complete.setter
-    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "wait_on_complete", value)
+    @property
+    @pulumi.getter
+    def target(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "target")
+
+    @target.setter
+    def target(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "target", value)
+
+    @property
+    @pulumi.getter(name="tsigKey")
+    def tsig_key(self) -> Optional[pulumi.Input['DnsZoneTsigKeyArgs']]:
+        return pulumi.get(self, "tsig_key")
+
+    @tsig_key.setter
+    def tsig_key(self, value: Optional[pulumi.Input['DnsZoneTsigKeyArgs']]):
+        pulumi.set(self, "tsig_key", value)
 
 
 @pulumi.input_type
-class _GtmCidrmapState:
+class _DnsZoneState:
     def __init__(__self__, *,
-                 assignments: Optional[pulumi.Input[Sequence[pulumi.Input['GtmCidrmapAssignmentArgs']]]] = None,
-                 default_datacenter: Optional[pulumi.Input['GtmCidrmapDefaultDatacenterArgs']] = None,
-                 domain: Optional[pulumi.Input[str]] = None,
-                 name: Optional[pulumi.Input[str]] = None,
-                 wait_on_complete: Optional[pulumi.Input[bool]] = None):
-        """
-        Input properties used for looking up and filtering GtmCidrmap resources.
-        :param pulumi.Input[Sequence[pulumi.Input['GtmCidrmapAssignmentArgs']]] assignments: Contains information about the CIDR zone groupings of CIDR blocks. You can have multiple entries with this argument. If used, requires these additional arguments:
-        :param pulumi.Input['GtmCidrmapDefaultDatacenterArgs'] default_datacenter: A placeholder for all other CIDR zones not found in these CIDR zones. Requires these additional arguments:
-        :param pulumi.Input[str] domain: GTM Domain name for the CIDR Map.
-        :param pulumi.Input[str] name: A descriptive label for the CIDR map, up to 255 characters.
-        :param pulumi.Input[bool] wait_on_complete: A boolean that, if set to `true`, waits for transaction to complete.
-        """
-        if assignments is not None:
-            pulumi.set(__self__, "assignments", assignments)
-        if default_datacenter is not None:
-            pulumi.set(__self__, "default_datacenter", default_datacenter)
-        if domain is not None:
-            pulumi.set(__self__, "domain", domain)
-        if name is not None:
-            pulumi.set(__self__, "name", name)
-        if wait_on_complete is not None:
-            pulumi.set(__self__, "wait_on_complete", wait_on_complete)
+                 activation_state: Optional[pulumi.Input[str]] = None,
+                 alias_count: Optional[pulumi.Input[int]] = None,
+                 comment: Optional[pulumi.Input[str]] = None,
+                 contract: Optional[pulumi.Input[str]] = None,
+                 end_customer_id: Optional[pulumi.Input[str]] = None,
+                 group: Optional[pulumi.Input[str]] = None,
+                 masters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 sign_and_serve: Optional[pulumi.Input[bool]] = None,
+                 sign_and_serve_algorithm: Optional[pulumi.Input[str]] = None,
+                 target: Optional[pulumi.Input[str]] = None,
+                 tsig_key: Optional[pulumi.Input['DnsZoneTsigKeyArgs']] = None,
+                 type: Optional[pulumi.Input[str]] = None,
+                 version_id: Optional[pulumi.Input[str]] = None,
+                 zone: Optional[pulumi.Input[str]] = None):
+        """
+        Input properties used for looking up and filtering DnsZone resources.
+        """
+        if activation_state is not None:
+            pulumi.set(__self__, "activation_state", activation_state)
+        if alias_count is not None:
+            pulumi.set(__self__, "alias_count", alias_count)
+        if comment is not None:
+            pulumi.set(__self__, "comment", comment)
+        if contract is not None:
+            pulumi.set(__self__, "contract", contract)
+        if end_customer_id is not None:
+            pulumi.set(__self__, "end_customer_id", end_customer_id)
+        if group is not None:
+            pulumi.set(__self__, "group", group)
+        if masters is not None:
+            pulumi.set(__self__, "masters", masters)
+        if sign_and_serve is not None:
+            pulumi.set(__self__, "sign_and_serve", sign_and_serve)
+        if sign_and_serve_algorithm is not None:
+            pulumi.set(__self__, "sign_and_serve_algorithm", sign_and_serve_algorithm)
+        if target is not None:
+            pulumi.set(__self__, "target", target)
+        if tsig_key is not None:
+            pulumi.set(__self__, "tsig_key", tsig_key)
+        if type is not None:
+            pulumi.set(__self__, "type", type)
+        if version_id is not None:
+            pulumi.set(__self__, "version_id", version_id)
+        if zone is not None:
+            pulumi.set(__self__, "zone", zone)
+
+    @property
+    @pulumi.getter(name="activationState")
+    def activation_state(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "activation_state")
+
+    @activation_state.setter
+    def activation_state(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "activation_state", value)
+
+    @property
+    @pulumi.getter(name="aliasCount")
+    def alias_count(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "alias_count")
+
+    @alias_count.setter
+    def alias_count(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "alias_count", value)
 
     @property
     @pulumi.getter
-    def assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmCidrmapAssignmentArgs']]]]:
-        """
-        Contains information about the CIDR zone groupings of CIDR blocks. You can have multiple entries with this argument. If used, requires these additional arguments:
-        """
-        return pulumi.get(self, "assignments")
+    def comment(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "comment")
 
-    @assignments.setter
-    def assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmCidrmapAssignmentArgs']]]]):
-        pulumi.set(self, "assignments", value)
+    @comment.setter
+    def comment(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "comment", value)
 
     @property
-    @pulumi.getter(name="defaultDatacenter")
-    def default_datacenter(self) -> Optional[pulumi.Input['GtmCidrmapDefaultDatacenterArgs']]:
-        """
-        A placeholder for all other CIDR zones not found in these CIDR zones. Requires these additional arguments:
-        """
-        return pulumi.get(self, "default_datacenter")
+    @pulumi.getter
+    def contract(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "contract")
+
+    @contract.setter
+    def contract(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "contract", value)
 
-    @default_datacenter.setter
-    def default_datacenter(self, value: Optional[pulumi.Input['GtmCidrmapDefaultDatacenterArgs']]):
-        pulumi.set(self, "default_datacenter", value)
+    @property
+    @pulumi.getter(name="endCustomerId")
+    def end_customer_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "end_customer_id")
+
+    @end_customer_id.setter
+    def end_customer_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "end_customer_id", value)
 
     @property
     @pulumi.getter
-    def domain(self) -> Optional[pulumi.Input[str]]:
-        """
-        GTM Domain name for the CIDR Map.
-        """
-        return pulumi.get(self, "domain")
+    def group(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "group")
 
-    @domain.setter
-    def domain(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "domain", value)
+    @group.setter
+    def group(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "group", value)
 
     @property
     @pulumi.getter
-    def name(self) -> Optional[pulumi.Input[str]]:
-        """
-        A descriptive label for the CIDR map, up to 255 characters.
-        """
-        return pulumi.get(self, "name")
+    def masters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
+        return pulumi.get(self, "masters")
 
-    @name.setter
-    def name(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "name", value)
+    @masters.setter
+    def masters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
+        pulumi.set(self, "masters", value)
 
     @property
-    @pulumi.getter(name="waitOnComplete")
-    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
-        """
-        A boolean that, if set to `true`, waits for transaction to complete.
-        """
-        return pulumi.get(self, "wait_on_complete")
+    @pulumi.getter(name="signAndServe")
+    def sign_and_serve(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "sign_and_serve")
 
-    @wait_on_complete.setter
-    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "wait_on_complete", value)
+    @sign_and_serve.setter
+    def sign_and_serve(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "sign_and_serve", value)
 
+    @property
+    @pulumi.getter(name="signAndServeAlgorithm")
+    def sign_and_serve_algorithm(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "sign_and_serve_algorithm")
 
-class GtmCidrmap(pulumi.CustomResource):
-    @overload
-    def __init__(__self__,
-                 resource_name: str,
-                 opts: Optional[pulumi.ResourceOptions] = None,
-                 assignments: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmCidrmapAssignmentArgs']]]]] = None,
-                 default_datacenter: Optional[pulumi.Input[pulumi.InputType['GtmCidrmapDefaultDatacenterArgs']]] = None,
-                 domain: Optional[pulumi.Input[str]] = None,
-                 name: Optional[pulumi.Input[str]] = None,
-                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
-                 __props__=None):
-        """
-        Use the `GtmCidrmap` resource to create, configure, and import a GTM Classless Inter-Domain Routing (CIDR) map. CIDR mapping uses the IP addresses of the requesting name server to provide IP-specific CNAME entries. CNAMEs let you direct internal users to a specific environment or direct them to the origin. This lets you provide different responses to an internal corporate DNS infrastructure, such as internal test environments and another answer for all other name servers (`default_datacenter`).
+    @sign_and_serve_algorithm.setter
+    def sign_and_serve_algorithm(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "sign_and_serve_algorithm", value)
+
+    @property
+    @pulumi.getter
+    def target(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "target")
+
+    @target.setter
+    def target(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "target", value)
+
+    @property
+    @pulumi.getter(name="tsigKey")
+    def tsig_key(self) -> Optional[pulumi.Input['DnsZoneTsigKeyArgs']]:
+        return pulumi.get(self, "tsig_key")
 
-         CIDR maps split the Internet into multiple CIDR block zones. Properties that use a map can specify a handout CNAME for each zone on the property's editing page. To configure a property for CIDR mapping, your domain needs at least one CIDR map defined.
+    @tsig_key.setter
+    def tsig_key(self, value: Optional[pulumi.Input['DnsZoneTsigKeyArgs']]):
+        pulumi.set(self, "tsig_key", value)
 
-        > **Note** Import requires an ID with this format: `existing_domain_name`:`existing_map_name`.
+    @property
+    @pulumi.getter
+    def type(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "type")
 
-        ## Example Usage
+    @type.setter
+    def type(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "type", value)
+
+    @property
+    @pulumi.getter(name="versionId")
+    def version_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "version_id")
 
-        Basic usage:
+    @version_id.setter
+    def version_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "version_id", value)
+
+    @property
+    @pulumi.getter
+    def zone(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "zone")
 
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
+    @zone.setter
+    def zone(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "zone", value)
 
-        demo_cidrmap = akamai.GtmCidrmap("demoCidrmap",
-            default_datacenter=akamai.GtmCidrmapDefaultDatacenterArgs(
-                datacenter_id=5400,
-                nickname="All Other CIDR Blocks",
-            ),
-            domain="demo_domain.akadns.net")
-        ```
 
+class DnsZone(pulumi.CustomResource):
+    @overload
+    def __init__(__self__,
+                 resource_name: str,
+                 opts: Optional[pulumi.ResourceOptions] = None,
+                 comment: Optional[pulumi.Input[str]] = None,
+                 contract: Optional[pulumi.Input[str]] = None,
+                 end_customer_id: Optional[pulumi.Input[str]] = None,
+                 group: Optional[pulumi.Input[str]] = None,
+                 masters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 sign_and_serve: Optional[pulumi.Input[bool]] = None,
+                 sign_and_serve_algorithm: Optional[pulumi.Input[str]] = None,
+                 target: Optional[pulumi.Input[str]] = None,
+                 tsig_key: Optional[pulumi.Input[pulumi.InputType['DnsZoneTsigKeyArgs']]] = None,
+                 type: Optional[pulumi.Input[str]] = None,
+                 zone: Optional[pulumi.Input[str]] = None,
+                 __props__=None):
+        """
+        Create a DnsZone resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmCidrmapAssignmentArgs']]]] assignments: Contains information about the CIDR zone groupings of CIDR blocks. You can have multiple entries with this argument. If used, requires these additional arguments:
-        :param pulumi.Input[pulumi.InputType['GtmCidrmapDefaultDatacenterArgs']] default_datacenter: A placeholder for all other CIDR zones not found in these CIDR zones. Requires these additional arguments:
-        :param pulumi.Input[str] domain: GTM Domain name for the CIDR Map.
-        :param pulumi.Input[str] name: A descriptive label for the CIDR map, up to 255 characters.
-        :param pulumi.Input[bool] wait_on_complete: A boolean that, if set to `true`, waits for transaction to complete.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: GtmCidrmapArgs,
+                 args: DnsZoneArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        Use the `GtmCidrmap` resource to create, configure, and import a GTM Classless Inter-Domain Routing (CIDR) map. CIDR mapping uses the IP addresses of the requesting name server to provide IP-specific CNAME entries. CNAMEs let you direct internal users to a specific environment or direct them to the origin. This lets you provide different responses to an internal corporate DNS infrastructure, such as internal test environments and another answer for all other name servers (`default_datacenter`).
-
-         CIDR maps split the Internet into multiple CIDR block zones. Properties that use a map can specify a handout CNAME for each zone on the property's editing page. To configure a property for CIDR mapping, your domain needs at least one CIDR map defined.
-
-        > **Note** Import requires an ID with this format: `existing_domain_name`:`existing_map_name`.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        demo_cidrmap = akamai.GtmCidrmap("demoCidrmap",
-            default_datacenter=akamai.GtmCidrmapDefaultDatacenterArgs(
-                datacenter_id=5400,
-                nickname="All Other CIDR Blocks",
-            ),
-            domain="demo_domain.akadns.net")
-        ```
-
+        Create a DnsZone resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param GtmCidrmapArgs args: The arguments to use to populate this resource's properties.
+        :param DnsZoneArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(GtmCidrmapArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(DnsZoneArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 assignments: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmCidrmapAssignmentArgs']]]]] = None,
-                 default_datacenter: Optional[pulumi.Input[pulumi.InputType['GtmCidrmapDefaultDatacenterArgs']]] = None,
-                 domain: Optional[pulumi.Input[str]] = None,
-                 name: Optional[pulumi.Input[str]] = None,
-                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
+                 comment: Optional[pulumi.Input[str]] = None,
+                 contract: Optional[pulumi.Input[str]] = None,
+                 end_customer_id: Optional[pulumi.Input[str]] = None,
+                 group: Optional[pulumi.Input[str]] = None,
+                 masters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 sign_and_serve: Optional[pulumi.Input[bool]] = None,
+                 sign_and_serve_algorithm: Optional[pulumi.Input[str]] = None,
+                 target: Optional[pulumi.Input[str]] = None,
+                 tsig_key: Optional[pulumi.Input[pulumi.InputType['DnsZoneTsigKeyArgs']]] = None,
+                 type: Optional[pulumi.Input[str]] = None,
+                 zone: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = GtmCidrmapArgs.__new__(GtmCidrmapArgs)
+            __props__ = DnsZoneArgs.__new__(DnsZoneArgs)
 
-            __props__.__dict__["assignments"] = assignments
-            if default_datacenter is None and not opts.urn:
-                raise TypeError("Missing required property 'default_datacenter'")
-            __props__.__dict__["default_datacenter"] = default_datacenter
-            if domain is None and not opts.urn:
-                raise TypeError("Missing required property 'domain'")
-            __props__.__dict__["domain"] = domain
-            __props__.__dict__["name"] = name
-            __props__.__dict__["wait_on_complete"] = wait_on_complete
-        alias_opts = pulumi.ResourceOptions(aliases=[pulumi.Alias(type_="akamai:trafficmanagement/gtmCidrmap:GtmCidrmap")])
+            __props__.__dict__["comment"] = comment
+            if contract is None and not opts.urn:
+                raise TypeError("Missing required property 'contract'")
+            __props__.__dict__["contract"] = contract
+            __props__.__dict__["end_customer_id"] = end_customer_id
+            __props__.__dict__["group"] = group
+            __props__.__dict__["masters"] = masters
+            __props__.__dict__["sign_and_serve"] = sign_and_serve
+            __props__.__dict__["sign_and_serve_algorithm"] = sign_and_serve_algorithm
+            __props__.__dict__["target"] = target
+            __props__.__dict__["tsig_key"] = tsig_key
+            if type is None and not opts.urn:
+                raise TypeError("Missing required property 'type'")
+            __props__.__dict__["type"] = type
+            if zone is None and not opts.urn:
+                raise TypeError("Missing required property 'zone'")
+            __props__.__dict__["zone"] = zone
+            __props__.__dict__["activation_state"] = None
+            __props__.__dict__["alias_count"] = None
+            __props__.__dict__["version_id"] = None
+        alias_opts = pulumi.ResourceOptions(aliases=[pulumi.Alias(type_="akamai:edgedns/dnsZone:DnsZone")])
         opts = pulumi.ResourceOptions.merge(opts, alias_opts)
-        super(GtmCidrmap, __self__).__init__(
-            'akamai:index/gtmCidrmap:GtmCidrmap',
+        super(DnsZone, __self__).__init__(
+            'akamai:index/dnsZone:DnsZone',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
-            assignments: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmCidrmapAssignmentArgs']]]]] = None,
-            default_datacenter: Optional[pulumi.Input[pulumi.InputType['GtmCidrmapDefaultDatacenterArgs']]] = None,
-            domain: Optional[pulumi.Input[str]] = None,
-            name: Optional[pulumi.Input[str]] = None,
-            wait_on_complete: Optional[pulumi.Input[bool]] = None) -> 'GtmCidrmap':
+            activation_state: Optional[pulumi.Input[str]] = None,
+            alias_count: Optional[pulumi.Input[int]] = None,
+            comment: Optional[pulumi.Input[str]] = None,
+            contract: Optional[pulumi.Input[str]] = None,
+            end_customer_id: Optional[pulumi.Input[str]] = None,
+            group: Optional[pulumi.Input[str]] = None,
+            masters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+            sign_and_serve: Optional[pulumi.Input[bool]] = None,
+            sign_and_serve_algorithm: Optional[pulumi.Input[str]] = None,
+            target: Optional[pulumi.Input[str]] = None,
+            tsig_key: Optional[pulumi.Input[pulumi.InputType['DnsZoneTsigKeyArgs']]] = None,
+            type: Optional[pulumi.Input[str]] = None,
+            version_id: Optional[pulumi.Input[str]] = None,
+            zone: Optional[pulumi.Input[str]] = None) -> 'DnsZone':
         """
-        Get an existing GtmCidrmap resource's state with the given name, id, and optional extra
+        Get an existing DnsZone resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmCidrmapAssignmentArgs']]]] assignments: Contains information about the CIDR zone groupings of CIDR blocks. You can have multiple entries with this argument. If used, requires these additional arguments:
-        :param pulumi.Input[pulumi.InputType['GtmCidrmapDefaultDatacenterArgs']] default_datacenter: A placeholder for all other CIDR zones not found in these CIDR zones. Requires these additional arguments:
-        :param pulumi.Input[str] domain: GTM Domain name for the CIDR Map.
-        :param pulumi.Input[str] name: A descriptive label for the CIDR map, up to 255 characters.
-        :param pulumi.Input[bool] wait_on_complete: A boolean that, if set to `true`, waits for transaction to complete.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _GtmCidrmapState.__new__(_GtmCidrmapState)
+        __props__ = _DnsZoneState.__new__(_DnsZoneState)
 
-        __props__.__dict__["assignments"] = assignments
-        __props__.__dict__["default_datacenter"] = default_datacenter
-        __props__.__dict__["domain"] = domain
-        __props__.__dict__["name"] = name
-        __props__.__dict__["wait_on_complete"] = wait_on_complete
-        return GtmCidrmap(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["activation_state"] = activation_state
+        __props__.__dict__["alias_count"] = alias_count
+        __props__.__dict__["comment"] = comment
+        __props__.__dict__["contract"] = contract
+        __props__.__dict__["end_customer_id"] = end_customer_id
+        __props__.__dict__["group"] = group
+        __props__.__dict__["masters"] = masters
+        __props__.__dict__["sign_and_serve"] = sign_and_serve
+        __props__.__dict__["sign_and_serve_algorithm"] = sign_and_serve_algorithm
+        __props__.__dict__["target"] = target
+        __props__.__dict__["tsig_key"] = tsig_key
+        __props__.__dict__["type"] = type
+        __props__.__dict__["version_id"] = version_id
+        __props__.__dict__["zone"] = zone
+        return DnsZone(resource_name, opts=opts, __props__=__props__)
+
+    @property
+    @pulumi.getter(name="activationState")
+    def activation_state(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "activation_state")
+
+    @property
+    @pulumi.getter(name="aliasCount")
+    def alias_count(self) -> pulumi.Output[int]:
+        return pulumi.get(self, "alias_count")
 
     @property
     @pulumi.getter
-    def assignments(self) -> pulumi.Output[Optional[Sequence['outputs.GtmCidrmapAssignment']]]:
-        """
-        Contains information about the CIDR zone groupings of CIDR blocks. You can have multiple entries with this argument. If used, requires these additional arguments:
-        """
-        return pulumi.get(self, "assignments")
+    def comment(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "comment")
 
     @property
-    @pulumi.getter(name="defaultDatacenter")
-    def default_datacenter(self) -> pulumi.Output['outputs.GtmCidrmapDefaultDatacenter']:
-        """
-        A placeholder for all other CIDR zones not found in these CIDR zones. Requires these additional arguments:
-        """
-        return pulumi.get(self, "default_datacenter")
+    @pulumi.getter
+    def contract(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "contract")
+
+    @property
+    @pulumi.getter(name="endCustomerId")
+    def end_customer_id(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "end_customer_id")
 
     @property
     @pulumi.getter
-    def domain(self) -> pulumi.Output[str]:
-        """
-        GTM Domain name for the CIDR Map.
-        """
-        return pulumi.get(self, "domain")
+    def group(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "group")
 
     @property
     @pulumi.getter
-    def name(self) -> pulumi.Output[str]:
-        """
-        A descriptive label for the CIDR map, up to 255 characters.
-        """
-        return pulumi.get(self, "name")
+    def masters(self) -> pulumi.Output[Optional[Sequence[str]]]:
+        return pulumi.get(self, "masters")
 
     @property
-    @pulumi.getter(name="waitOnComplete")
-    def wait_on_complete(self) -> pulumi.Output[Optional[bool]]:
-        """
-        A boolean that, if set to `true`, waits for transaction to complete.
-        """
-        return pulumi.get(self, "wait_on_complete")
+    @pulumi.getter(name="signAndServe")
+    def sign_and_serve(self) -> pulumi.Output[Optional[bool]]:
+        return pulumi.get(self, "sign_and_serve")
+
+    @property
+    @pulumi.getter(name="signAndServeAlgorithm")
+    def sign_and_serve_algorithm(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "sign_and_serve_algorithm")
+
+    @property
+    @pulumi.getter
+    def target(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "target")
+
+    @property
+    @pulumi.getter(name="tsigKey")
+    def tsig_key(self) -> pulumi.Output[Optional['outputs.DnsZoneTsigKey']]:
+        return pulumi.get(self, "tsig_key")
+
+    @property
+    @pulumi.getter
+    def type(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "type")
+
+    @property
+    @pulumi.getter(name="versionId")
+    def version_id(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "version_id")
+
+    @property
+    @pulumi.getter
+    def zone(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "zone")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/gtm_datacenter.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/cps_dv_enrollment.py`

 * *Files 18% similar despite different names*

```diff
@@ -7,918 +7,956 @@
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 from . import outputs
 from ._inputs import *
 
-__all__ = ['GtmDatacenterArgs', 'GtmDatacenter']
+__all__ = ['CpsDvEnrollmentArgs', 'CpsDvEnrollment']
 
 @pulumi.input_type
-class GtmDatacenterArgs:
+class CpsDvEnrollmentArgs:
     def __init__(__self__, *,
-                 domain: pulumi.Input[str],
-                 city: Optional[pulumi.Input[str]] = None,
-                 clone_of: Optional[pulumi.Input[int]] = None,
-                 cloud_server_host_header_override: Optional[pulumi.Input[bool]] = None,
-                 cloud_server_targeting: Optional[pulumi.Input[bool]] = None,
-                 continent: Optional[pulumi.Input[str]] = None,
-                 country: Optional[pulumi.Input[str]] = None,
-                 default_load_object: Optional[pulumi.Input['GtmDatacenterDefaultLoadObjectArgs']] = None,
-                 latitude: Optional[pulumi.Input[float]] = None,
-                 longitude: Optional[pulumi.Input[float]] = None,
-                 nickname: Optional[pulumi.Input[str]] = None,
-                 state_or_province: Optional[pulumi.Input[str]] = None,
-                 wait_on_complete: Optional[pulumi.Input[bool]] = None):
-        """
-        The set of arguments for constructing a GtmDatacenter resource.
-        :param pulumi.Input[str] domain: The GTM domain name for the data center.
-        :param pulumi.Input[str] city: The name of the city where the data center is located.
-        :param pulumi.Input[int] clone_of: Identifies the data center's `datacenter_id` of which this data center is a clone.
-        :param pulumi.Input[bool] cloud_server_host_header_override: A boolean that, if set to `true`, Akamai's liveness test agents use the Host header configured in the liveness test.
-        :param pulumi.Input[bool] cloud_server_targeting: A boolean indicating whether to balance load between two or more servers in a cloud environment.
-        :param pulumi.Input[str] continent: A two-letter code that specifies the continent where the data center maps to.
-        :param pulumi.Input[str] country: A two-letter ISO 3166 country code that specifies the country where the data center maps to.
-        :param pulumi.Input['GtmDatacenterDefaultLoadObjectArgs'] default_load_object: Specifies the load reporting interface between you and the GTM system. If used, requires these additional arguments:
-        :param pulumi.Input[float] latitude: Specifies the geographical latitude of the data center's position. See also longitude within this object.
-        :param pulumi.Input[float] longitude: Specifies the geographic longitude of the data center's position. See also latitude within this object.
-        :param pulumi.Input[str] nickname: A descriptive label for the data center.
-        :param pulumi.Input[str] state_or_province: Specifies a two-letter ISO 3166 country code for the state or province where the data center is located.
-        :param pulumi.Input[bool] wait_on_complete: A boolean, that if set to `true`, waits for transaction to complete.
-        """
-        pulumi.set(__self__, "domain", domain)
-        if city is not None:
-            pulumi.set(__self__, "city", city)
-        if clone_of is not None:
-            pulumi.set(__self__, "clone_of", clone_of)
-        if cloud_server_host_header_override is not None:
-            pulumi.set(__self__, "cloud_server_host_header_override", cloud_server_host_header_override)
-        if cloud_server_targeting is not None:
-            pulumi.set(__self__, "cloud_server_targeting", cloud_server_targeting)
-        if continent is not None:
-            pulumi.set(__self__, "continent", continent)
-        if country is not None:
-            pulumi.set(__self__, "country", country)
-        if default_load_object is not None:
-            pulumi.set(__self__, "default_load_object", default_load_object)
-        if latitude is not None:
-            pulumi.set(__self__, "latitude", latitude)
-        if longitude is not None:
-            pulumi.set(__self__, "longitude", longitude)
-        if nickname is not None:
-            pulumi.set(__self__, "nickname", nickname)
-        if state_or_province is not None:
-            pulumi.set(__self__, "state_or_province", state_or_province)
-        if wait_on_complete is not None:
-            pulumi.set(__self__, "wait_on_complete", wait_on_complete)
+                 admin_contact: pulumi.Input['CpsDvEnrollmentAdminContactArgs'],
+                 common_name: pulumi.Input[str],
+                 contract_id: pulumi.Input[str],
+                 csr: pulumi.Input['CpsDvEnrollmentCsrArgs'],
+                 network_configuration: pulumi.Input['CpsDvEnrollmentNetworkConfigurationArgs'],
+                 organization: pulumi.Input['CpsDvEnrollmentOrganizationArgs'],
+                 secure_network: pulumi.Input[str],
+                 signature_algorithm: pulumi.Input[str],
+                 sni_only: pulumi.Input[bool],
+                 tech_contact: pulumi.Input['CpsDvEnrollmentTechContactArgs'],
+                 acknowledge_pre_verification_warnings: Optional[pulumi.Input[bool]] = None,
+                 allow_duplicate_common_name: Optional[pulumi.Input[bool]] = None,
+                 certificate_chain_type: Optional[pulumi.Input[str]] = None,
+                 enable_multi_stacked_certificates: Optional[pulumi.Input[bool]] = None,
+                 sans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
+        """
+        The set of arguments for constructing a CpsDvEnrollment resource.
+        :param pulumi.Input['CpsDvEnrollmentAdminContactArgs'] admin_contact: Contact information for the certificate administrator to use at organization
+        :param pulumi.Input[str] common_name: Common name used for enrollment
+        :param pulumi.Input[str] contract_id: Contract ID for which enrollment is retrieved
+        :param pulumi.Input['CpsDvEnrollmentCsrArgs'] csr: Certificate signing request generated during enrollment creation
+        :param pulumi.Input['CpsDvEnrollmentNetworkConfigurationArgs'] network_configuration: Settings containing network information and TLS Metadata used by CPS
+        :param pulumi.Input['CpsDvEnrollmentOrganizationArgs'] organization: Organization information
+        :param pulumi.Input[str] secure_network: Type of TLS deployment network
+        :param pulumi.Input[str] signature_algorithm: SHA algorithm type
+        :param pulumi.Input[bool] sni_only: Whether Server Name Indication is used for enrollment
+        :param pulumi.Input['CpsDvEnrollmentTechContactArgs'] tech_contact: Contact information for an administrator at Akamai
+        :param pulumi.Input[bool] acknowledge_pre_verification_warnings: Whether acknowledge warnings before certificate verification
+        :param pulumi.Input[bool] allow_duplicate_common_name: Allow to duplicate common name
+        :param pulumi.Input[str] certificate_chain_type: Certificate trust chain type
+        :param pulumi.Input[bool] enable_multi_stacked_certificates: Enable Dual-Stacked certificate deployment for enrollment
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] sans: List of SANs
+        """
+        pulumi.set(__self__, "admin_contact", admin_contact)
+        pulumi.set(__self__, "common_name", common_name)
+        pulumi.set(__self__, "contract_id", contract_id)
+        pulumi.set(__self__, "csr", csr)
+        pulumi.set(__self__, "network_configuration", network_configuration)
+        pulumi.set(__self__, "organization", organization)
+        pulumi.set(__self__, "secure_network", secure_network)
+        pulumi.set(__self__, "signature_algorithm", signature_algorithm)
+        pulumi.set(__self__, "sni_only", sni_only)
+        pulumi.set(__self__, "tech_contact", tech_contact)
+        if acknowledge_pre_verification_warnings is not None:
+            pulumi.set(__self__, "acknowledge_pre_verification_warnings", acknowledge_pre_verification_warnings)
+        if allow_duplicate_common_name is not None:
+            pulumi.set(__self__, "allow_duplicate_common_name", allow_duplicate_common_name)
+        if certificate_chain_type is not None:
+            pulumi.set(__self__, "certificate_chain_type", certificate_chain_type)
+        if enable_multi_stacked_certificates is not None:
+            warnings.warn("""Deprecated, don't use; always false""", DeprecationWarning)
+            pulumi.log.warn("""enable_multi_stacked_certificates is deprecated: Deprecated, don't use; always false""")
+        if enable_multi_stacked_certificates is not None:
+            pulumi.set(__self__, "enable_multi_stacked_certificates", enable_multi_stacked_certificates)
+        if sans is not None:
+            pulumi.set(__self__, "sans", sans)
 
     @property
-    @pulumi.getter
-    def domain(self) -> pulumi.Input[str]:
+    @pulumi.getter(name="adminContact")
+    def admin_contact(self) -> pulumi.Input['CpsDvEnrollmentAdminContactArgs']:
         """
-        The GTM domain name for the data center.
+        Contact information for the certificate administrator to use at organization
         """
-        return pulumi.get(self, "domain")
+        return pulumi.get(self, "admin_contact")
 
-    @domain.setter
-    def domain(self, value: pulumi.Input[str]):
-        pulumi.set(self, "domain", value)
+    @admin_contact.setter
+    def admin_contact(self, value: pulumi.Input['CpsDvEnrollmentAdminContactArgs']):
+        pulumi.set(self, "admin_contact", value)
 
     @property
-    @pulumi.getter
-    def city(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="commonName")
+    def common_name(self) -> pulumi.Input[str]:
         """
-        The name of the city where the data center is located.
+        Common name used for enrollment
         """
-        return pulumi.get(self, "city")
+        return pulumi.get(self, "common_name")
 
-    @city.setter
-    def city(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "city", value)
+    @common_name.setter
+    def common_name(self, value: pulumi.Input[str]):
+        pulumi.set(self, "common_name", value)
 
     @property
-    @pulumi.getter(name="cloneOf")
-    def clone_of(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="contractId")
+    def contract_id(self) -> pulumi.Input[str]:
         """
-        Identifies the data center's `datacenter_id` of which this data center is a clone.
+        Contract ID for which enrollment is retrieved
         """
-        return pulumi.get(self, "clone_of")
+        return pulumi.get(self, "contract_id")
 
-    @clone_of.setter
-    def clone_of(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "clone_of", value)
+    @contract_id.setter
+    def contract_id(self, value: pulumi.Input[str]):
+        pulumi.set(self, "contract_id", value)
 
     @property
-    @pulumi.getter(name="cloudServerHostHeaderOverride")
-    def cloud_server_host_header_override(self) -> Optional[pulumi.Input[bool]]:
+    @pulumi.getter
+    def csr(self) -> pulumi.Input['CpsDvEnrollmentCsrArgs']:
         """
-        A boolean that, if set to `true`, Akamai's liveness test agents use the Host header configured in the liveness test.
+        Certificate signing request generated during enrollment creation
         """
-        return pulumi.get(self, "cloud_server_host_header_override")
+        return pulumi.get(self, "csr")
 
-    @cloud_server_host_header_override.setter
-    def cloud_server_host_header_override(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "cloud_server_host_header_override", value)
+    @csr.setter
+    def csr(self, value: pulumi.Input['CpsDvEnrollmentCsrArgs']):
+        pulumi.set(self, "csr", value)
 
     @property
-    @pulumi.getter(name="cloudServerTargeting")
-    def cloud_server_targeting(self) -> Optional[pulumi.Input[bool]]:
+    @pulumi.getter(name="networkConfiguration")
+    def network_configuration(self) -> pulumi.Input['CpsDvEnrollmentNetworkConfigurationArgs']:
         """
-        A boolean indicating whether to balance load between two or more servers in a cloud environment.
+        Settings containing network information and TLS Metadata used by CPS
         """
-        return pulumi.get(self, "cloud_server_targeting")
+        return pulumi.get(self, "network_configuration")
 
-    @cloud_server_targeting.setter
-    def cloud_server_targeting(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "cloud_server_targeting", value)
+    @network_configuration.setter
+    def network_configuration(self, value: pulumi.Input['CpsDvEnrollmentNetworkConfigurationArgs']):
+        pulumi.set(self, "network_configuration", value)
 
     @property
     @pulumi.getter
-    def continent(self) -> Optional[pulumi.Input[str]]:
+    def organization(self) -> pulumi.Input['CpsDvEnrollmentOrganizationArgs']:
         """
-        A two-letter code that specifies the continent where the data center maps to.
+        Organization information
         """
-        return pulumi.get(self, "continent")
+        return pulumi.get(self, "organization")
 
-    @continent.setter
-    def continent(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "continent", value)
+    @organization.setter
+    def organization(self, value: pulumi.Input['CpsDvEnrollmentOrganizationArgs']):
+        pulumi.set(self, "organization", value)
 
     @property
-    @pulumi.getter
-    def country(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="secureNetwork")
+    def secure_network(self) -> pulumi.Input[str]:
         """
-        A two-letter ISO 3166 country code that specifies the country where the data center maps to.
+        Type of TLS deployment network
         """
-        return pulumi.get(self, "country")
+        return pulumi.get(self, "secure_network")
 
-    @country.setter
-    def country(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "country", value)
+    @secure_network.setter
+    def secure_network(self, value: pulumi.Input[str]):
+        pulumi.set(self, "secure_network", value)
 
     @property
-    @pulumi.getter(name="defaultLoadObject")
-    def default_load_object(self) -> Optional[pulumi.Input['GtmDatacenterDefaultLoadObjectArgs']]:
+    @pulumi.getter(name="signatureAlgorithm")
+    def signature_algorithm(self) -> pulumi.Input[str]:
         """
-        Specifies the load reporting interface between you and the GTM system. If used, requires these additional arguments:
+        SHA algorithm type
         """
-        return pulumi.get(self, "default_load_object")
+        return pulumi.get(self, "signature_algorithm")
 
-    @default_load_object.setter
-    def default_load_object(self, value: Optional[pulumi.Input['GtmDatacenterDefaultLoadObjectArgs']]):
-        pulumi.set(self, "default_load_object", value)
+    @signature_algorithm.setter
+    def signature_algorithm(self, value: pulumi.Input[str]):
+        pulumi.set(self, "signature_algorithm", value)
 
     @property
-    @pulumi.getter
-    def latitude(self) -> Optional[pulumi.Input[float]]:
+    @pulumi.getter(name="sniOnly")
+    def sni_only(self) -> pulumi.Input[bool]:
         """
-        Specifies the geographical latitude of the data center's position. See also longitude within this object.
+        Whether Server Name Indication is used for enrollment
         """
-        return pulumi.get(self, "latitude")
+        return pulumi.get(self, "sni_only")
 
-    @latitude.setter
-    def latitude(self, value: Optional[pulumi.Input[float]]):
-        pulumi.set(self, "latitude", value)
+    @sni_only.setter
+    def sni_only(self, value: pulumi.Input[bool]):
+        pulumi.set(self, "sni_only", value)
 
     @property
-    @pulumi.getter
-    def longitude(self) -> Optional[pulumi.Input[float]]:
+    @pulumi.getter(name="techContact")
+    def tech_contact(self) -> pulumi.Input['CpsDvEnrollmentTechContactArgs']:
         """
-        Specifies the geographic longitude of the data center's position. See also latitude within this object.
+        Contact information for an administrator at Akamai
         """
-        return pulumi.get(self, "longitude")
+        return pulumi.get(self, "tech_contact")
 
-    @longitude.setter
-    def longitude(self, value: Optional[pulumi.Input[float]]):
-        pulumi.set(self, "longitude", value)
+    @tech_contact.setter
+    def tech_contact(self, value: pulumi.Input['CpsDvEnrollmentTechContactArgs']):
+        pulumi.set(self, "tech_contact", value)
 
     @property
-    @pulumi.getter
-    def nickname(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="acknowledgePreVerificationWarnings")
+    def acknowledge_pre_verification_warnings(self) -> Optional[pulumi.Input[bool]]:
         """
-        A descriptive label for the data center.
+        Whether acknowledge warnings before certificate verification
         """
-        return pulumi.get(self, "nickname")
+        return pulumi.get(self, "acknowledge_pre_verification_warnings")
 
-    @nickname.setter
-    def nickname(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "nickname", value)
+    @acknowledge_pre_verification_warnings.setter
+    def acknowledge_pre_verification_warnings(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "acknowledge_pre_verification_warnings", value)
 
     @property
-    @pulumi.getter(name="stateOrProvince")
-    def state_or_province(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="allowDuplicateCommonName")
+    def allow_duplicate_common_name(self) -> Optional[pulumi.Input[bool]]:
         """
-        Specifies a two-letter ISO 3166 country code for the state or province where the data center is located.
+        Allow to duplicate common name
         """
-        return pulumi.get(self, "state_or_province")
+        return pulumi.get(self, "allow_duplicate_common_name")
 
-    @state_or_province.setter
-    def state_or_province(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "state_or_province", value)
+    @allow_duplicate_common_name.setter
+    def allow_duplicate_common_name(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "allow_duplicate_common_name", value)
 
     @property
-    @pulumi.getter(name="waitOnComplete")
-    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
+    @pulumi.getter(name="certificateChainType")
+    def certificate_chain_type(self) -> Optional[pulumi.Input[str]]:
         """
-        A boolean, that if set to `true`, waits for transaction to complete.
+        Certificate trust chain type
         """
-        return pulumi.get(self, "wait_on_complete")
+        return pulumi.get(self, "certificate_chain_type")
 
-    @wait_on_complete.setter
-    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "wait_on_complete", value)
+    @certificate_chain_type.setter
+    def certificate_chain_type(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "certificate_chain_type", value)
 
+    @property
+    @pulumi.getter(name="enableMultiStackedCertificates")
+    def enable_multi_stacked_certificates(self) -> Optional[pulumi.Input[bool]]:
+        """
+        Enable Dual-Stacked certificate deployment for enrollment
+        """
+        return pulumi.get(self, "enable_multi_stacked_certificates")
 
-@pulumi.input_type
-class _GtmDatacenterState:
-    def __init__(__self__, *,
-                 city: Optional[pulumi.Input[str]] = None,
-                 clone_of: Optional[pulumi.Input[int]] = None,
-                 cloud_server_host_header_override: Optional[pulumi.Input[bool]] = None,
-                 cloud_server_targeting: Optional[pulumi.Input[bool]] = None,
-                 continent: Optional[pulumi.Input[str]] = None,
-                 country: Optional[pulumi.Input[str]] = None,
-                 datacenter_id: Optional[pulumi.Input[int]] = None,
-                 default_load_object: Optional[pulumi.Input['GtmDatacenterDefaultLoadObjectArgs']] = None,
-                 domain: Optional[pulumi.Input[str]] = None,
-                 latitude: Optional[pulumi.Input[float]] = None,
-                 longitude: Optional[pulumi.Input[float]] = None,
-                 nickname: Optional[pulumi.Input[str]] = None,
-                 ping_interval: Optional[pulumi.Input[int]] = None,
-                 ping_packet_size: Optional[pulumi.Input[int]] = None,
-                 score_penalty: Optional[pulumi.Input[int]] = None,
-                 servermonitor_liveness_count: Optional[pulumi.Input[int]] = None,
-                 servermonitor_load_count: Optional[pulumi.Input[int]] = None,
-                 servermonitor_pool: Optional[pulumi.Input[str]] = None,
-                 state_or_province: Optional[pulumi.Input[str]] = None,
-                 virtual: Optional[pulumi.Input[bool]] = None,
-                 wait_on_complete: Optional[pulumi.Input[bool]] = None):
-        """
-        Input properties used for looking up and filtering GtmDatacenter resources.
-        :param pulumi.Input[str] city: The name of the city where the data center is located.
-        :param pulumi.Input[int] clone_of: Identifies the data center's `datacenter_id` of which this data center is a clone.
-        :param pulumi.Input[bool] cloud_server_host_header_override: A boolean that, if set to `true`, Akamai's liveness test agents use the Host header configured in the liveness test.
-        :param pulumi.Input[bool] cloud_server_targeting: A boolean indicating whether to balance load between two or more servers in a cloud environment.
-        :param pulumi.Input[str] continent: A two-letter code that specifies the continent where the data center maps to.
-        :param pulumi.Input[str] country: A two-letter ISO 3166 country code that specifies the country where the data center maps to.
-        :param pulumi.Input[int] datacenter_id: A unique identifier for an existing data center in the domain.
-        :param pulumi.Input['GtmDatacenterDefaultLoadObjectArgs'] default_load_object: Specifies the load reporting interface between you and the GTM system. If used, requires these additional arguments:
-        :param pulumi.Input[str] domain: The GTM domain name for the data center.
-        :param pulumi.Input[float] latitude: Specifies the geographical latitude of the data center's position. See also longitude within this object.
-        :param pulumi.Input[float] longitude: Specifies the geographic longitude of the data center's position. See also latitude within this object.
-        :param pulumi.Input[str] nickname: A descriptive label for the data center.
-        :param pulumi.Input[str] state_or_province: Specifies a two-letter ISO 3166 country code for the state or province where the data center is located.
-        :param pulumi.Input[bool] virtual: A boolean indicating whether the data center is virtual or physical, the latter meaning the data center has an Akamai Network Agent installed, and its physical location (`latitude`, `longitude`) is fixed. Either `true` if virtual or `false` if physical.
-        :param pulumi.Input[bool] wait_on_complete: A boolean, that if set to `true`, waits for transaction to complete.
-        """
-        if city is not None:
-            pulumi.set(__self__, "city", city)
-        if clone_of is not None:
-            pulumi.set(__self__, "clone_of", clone_of)
-        if cloud_server_host_header_override is not None:
-            pulumi.set(__self__, "cloud_server_host_header_override", cloud_server_host_header_override)
-        if cloud_server_targeting is not None:
-            pulumi.set(__self__, "cloud_server_targeting", cloud_server_targeting)
-        if continent is not None:
-            pulumi.set(__self__, "continent", continent)
-        if country is not None:
-            pulumi.set(__self__, "country", country)
-        if datacenter_id is not None:
-            pulumi.set(__self__, "datacenter_id", datacenter_id)
-        if default_load_object is not None:
-            pulumi.set(__self__, "default_load_object", default_load_object)
-        if domain is not None:
-            pulumi.set(__self__, "domain", domain)
-        if latitude is not None:
-            pulumi.set(__self__, "latitude", latitude)
-        if longitude is not None:
-            pulumi.set(__self__, "longitude", longitude)
-        if nickname is not None:
-            pulumi.set(__self__, "nickname", nickname)
-        if ping_interval is not None:
-            pulumi.set(__self__, "ping_interval", ping_interval)
-        if ping_packet_size is not None:
-            pulumi.set(__self__, "ping_packet_size", ping_packet_size)
-        if score_penalty is not None:
-            pulumi.set(__self__, "score_penalty", score_penalty)
-        if servermonitor_liveness_count is not None:
-            pulumi.set(__self__, "servermonitor_liveness_count", servermonitor_liveness_count)
-        if servermonitor_load_count is not None:
-            pulumi.set(__self__, "servermonitor_load_count", servermonitor_load_count)
-        if servermonitor_pool is not None:
-            pulumi.set(__self__, "servermonitor_pool", servermonitor_pool)
-        if state_or_province is not None:
-            pulumi.set(__self__, "state_or_province", state_or_province)
-        if virtual is not None:
-            pulumi.set(__self__, "virtual", virtual)
-        if wait_on_complete is not None:
-            pulumi.set(__self__, "wait_on_complete", wait_on_complete)
+    @enable_multi_stacked_certificates.setter
+    def enable_multi_stacked_certificates(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "enable_multi_stacked_certificates", value)
 
     @property
     @pulumi.getter
-    def city(self) -> Optional[pulumi.Input[str]]:
+    def sans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        The name of the city where the data center is located.
+        List of SANs
         """
-        return pulumi.get(self, "city")
+        return pulumi.get(self, "sans")
+
+    @sans.setter
+    def sans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
+        pulumi.set(self, "sans", value)
 
-    @city.setter
-    def city(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "city", value)
+
+@pulumi.input_type
+class _CpsDvEnrollmentState:
+    def __init__(__self__, *,
+                 acknowledge_pre_verification_warnings: Optional[pulumi.Input[bool]] = None,
+                 admin_contact: Optional[pulumi.Input['CpsDvEnrollmentAdminContactArgs']] = None,
+                 allow_duplicate_common_name: Optional[pulumi.Input[bool]] = None,
+                 certificate_chain_type: Optional[pulumi.Input[str]] = None,
+                 certificate_type: Optional[pulumi.Input[str]] = None,
+                 common_name: Optional[pulumi.Input[str]] = None,
+                 contract_id: Optional[pulumi.Input[str]] = None,
+                 csr: Optional[pulumi.Input['CpsDvEnrollmentCsrArgs']] = None,
+                 dns_challenges: Optional[pulumi.Input[Sequence[pulumi.Input['CpsDvEnrollmentDnsChallengeArgs']]]] = None,
+                 enable_multi_stacked_certificates: Optional[pulumi.Input[bool]] = None,
+                 http_challenges: Optional[pulumi.Input[Sequence[pulumi.Input['CpsDvEnrollmentHttpChallengeArgs']]]] = None,
+                 network_configuration: Optional[pulumi.Input['CpsDvEnrollmentNetworkConfigurationArgs']] = None,
+                 organization: Optional[pulumi.Input['CpsDvEnrollmentOrganizationArgs']] = None,
+                 registration_authority: Optional[pulumi.Input[str]] = None,
+                 sans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 secure_network: Optional[pulumi.Input[str]] = None,
+                 signature_algorithm: Optional[pulumi.Input[str]] = None,
+                 sni_only: Optional[pulumi.Input[bool]] = None,
+                 tech_contact: Optional[pulumi.Input['CpsDvEnrollmentTechContactArgs']] = None,
+                 validation_type: Optional[pulumi.Input[str]] = None):
+        """
+        Input properties used for looking up and filtering CpsDvEnrollment resources.
+        :param pulumi.Input[bool] acknowledge_pre_verification_warnings: Whether acknowledge warnings before certificate verification
+        :param pulumi.Input['CpsDvEnrollmentAdminContactArgs'] admin_contact: Contact information for the certificate administrator to use at organization
+        :param pulumi.Input[bool] allow_duplicate_common_name: Allow to duplicate common name
+        :param pulumi.Input[str] certificate_chain_type: Certificate trust chain type
+        :param pulumi.Input[str] certificate_type: Certificate type of enrollment
+        :param pulumi.Input[str] common_name: Common name used for enrollment
+        :param pulumi.Input[str] contract_id: Contract ID for which enrollment is retrieved
+        :param pulumi.Input['CpsDvEnrollmentCsrArgs'] csr: Certificate signing request generated during enrollment creation
+        :param pulumi.Input[Sequence[pulumi.Input['CpsDvEnrollmentDnsChallengeArgs']]] dns_challenges: DNS challenge information
+        :param pulumi.Input[bool] enable_multi_stacked_certificates: Enable Dual-Stacked certificate deployment for enrollment
+        :param pulumi.Input[Sequence[pulumi.Input['CpsDvEnrollmentHttpChallengeArgs']]] http_challenges: HTTP challenge information
+        :param pulumi.Input['CpsDvEnrollmentNetworkConfigurationArgs'] network_configuration: Settings containing network information and TLS Metadata used by CPS
+        :param pulumi.Input['CpsDvEnrollmentOrganizationArgs'] organization: Organization information
+        :param pulumi.Input[str] registration_authority: The registration authority or certificate authority (CA) used to obtain a certificate
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] sans: List of SANs
+        :param pulumi.Input[str] secure_network: Type of TLS deployment network
+        :param pulumi.Input[str] signature_algorithm: SHA algorithm type
+        :param pulumi.Input[bool] sni_only: Whether Server Name Indication is used for enrollment
+        :param pulumi.Input['CpsDvEnrollmentTechContactArgs'] tech_contact: Contact information for an administrator at Akamai
+        :param pulumi.Input[str] validation_type: Enrolment validation type
+        """
+        if acknowledge_pre_verification_warnings is not None:
+            pulumi.set(__self__, "acknowledge_pre_verification_warnings", acknowledge_pre_verification_warnings)
+        if admin_contact is not None:
+            pulumi.set(__self__, "admin_contact", admin_contact)
+        if allow_duplicate_common_name is not None:
+            pulumi.set(__self__, "allow_duplicate_common_name", allow_duplicate_common_name)
+        if certificate_chain_type is not None:
+            pulumi.set(__self__, "certificate_chain_type", certificate_chain_type)
+        if certificate_type is not None:
+            pulumi.set(__self__, "certificate_type", certificate_type)
+        if common_name is not None:
+            pulumi.set(__self__, "common_name", common_name)
+        if contract_id is not None:
+            pulumi.set(__self__, "contract_id", contract_id)
+        if csr is not None:
+            pulumi.set(__self__, "csr", csr)
+        if dns_challenges is not None:
+            pulumi.set(__self__, "dns_challenges", dns_challenges)
+        if enable_multi_stacked_certificates is not None:
+            warnings.warn("""Deprecated, don't use; always false""", DeprecationWarning)
+            pulumi.log.warn("""enable_multi_stacked_certificates is deprecated: Deprecated, don't use; always false""")
+        if enable_multi_stacked_certificates is not None:
+            pulumi.set(__self__, "enable_multi_stacked_certificates", enable_multi_stacked_certificates)
+        if http_challenges is not None:
+            pulumi.set(__self__, "http_challenges", http_challenges)
+        if network_configuration is not None:
+            pulumi.set(__self__, "network_configuration", network_configuration)
+        if organization is not None:
+            pulumi.set(__self__, "organization", organization)
+        if registration_authority is not None:
+            pulumi.set(__self__, "registration_authority", registration_authority)
+        if sans is not None:
+            pulumi.set(__self__, "sans", sans)
+        if secure_network is not None:
+            pulumi.set(__self__, "secure_network", secure_network)
+        if signature_algorithm is not None:
+            pulumi.set(__self__, "signature_algorithm", signature_algorithm)
+        if sni_only is not None:
+            pulumi.set(__self__, "sni_only", sni_only)
+        if tech_contact is not None:
+            pulumi.set(__self__, "tech_contact", tech_contact)
+        if validation_type is not None:
+            pulumi.set(__self__, "validation_type", validation_type)
 
     @property
-    @pulumi.getter(name="cloneOf")
-    def clone_of(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="acknowledgePreVerificationWarnings")
+    def acknowledge_pre_verification_warnings(self) -> Optional[pulumi.Input[bool]]:
         """
-        Identifies the data center's `datacenter_id` of which this data center is a clone.
+        Whether acknowledge warnings before certificate verification
         """
-        return pulumi.get(self, "clone_of")
+        return pulumi.get(self, "acknowledge_pre_verification_warnings")
 
-    @clone_of.setter
-    def clone_of(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "clone_of", value)
+    @acknowledge_pre_verification_warnings.setter
+    def acknowledge_pre_verification_warnings(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "acknowledge_pre_verification_warnings", value)
 
     @property
-    @pulumi.getter(name="cloudServerHostHeaderOverride")
-    def cloud_server_host_header_override(self) -> Optional[pulumi.Input[bool]]:
+    @pulumi.getter(name="adminContact")
+    def admin_contact(self) -> Optional[pulumi.Input['CpsDvEnrollmentAdminContactArgs']]:
         """
-        A boolean that, if set to `true`, Akamai's liveness test agents use the Host header configured in the liveness test.
+        Contact information for the certificate administrator to use at organization
         """
-        return pulumi.get(self, "cloud_server_host_header_override")
+        return pulumi.get(self, "admin_contact")
 
-    @cloud_server_host_header_override.setter
-    def cloud_server_host_header_override(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "cloud_server_host_header_override", value)
+    @admin_contact.setter
+    def admin_contact(self, value: Optional[pulumi.Input['CpsDvEnrollmentAdminContactArgs']]):
+        pulumi.set(self, "admin_contact", value)
 
     @property
-    @pulumi.getter(name="cloudServerTargeting")
-    def cloud_server_targeting(self) -> Optional[pulumi.Input[bool]]:
+    @pulumi.getter(name="allowDuplicateCommonName")
+    def allow_duplicate_common_name(self) -> Optional[pulumi.Input[bool]]:
         """
-        A boolean indicating whether to balance load between two or more servers in a cloud environment.
+        Allow to duplicate common name
         """
-        return pulumi.get(self, "cloud_server_targeting")
+        return pulumi.get(self, "allow_duplicate_common_name")
 
-    @cloud_server_targeting.setter
-    def cloud_server_targeting(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "cloud_server_targeting", value)
+    @allow_duplicate_common_name.setter
+    def allow_duplicate_common_name(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "allow_duplicate_common_name", value)
 
     @property
-    @pulumi.getter
-    def continent(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="certificateChainType")
+    def certificate_chain_type(self) -> Optional[pulumi.Input[str]]:
         """
-        A two-letter code that specifies the continent where the data center maps to.
+        Certificate trust chain type
         """
-        return pulumi.get(self, "continent")
+        return pulumi.get(self, "certificate_chain_type")
 
-    @continent.setter
-    def continent(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "continent", value)
+    @certificate_chain_type.setter
+    def certificate_chain_type(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "certificate_chain_type", value)
 
     @property
-    @pulumi.getter
-    def country(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="certificateType")
+    def certificate_type(self) -> Optional[pulumi.Input[str]]:
         """
-        A two-letter ISO 3166 country code that specifies the country where the data center maps to.
+        Certificate type of enrollment
         """
-        return pulumi.get(self, "country")
+        return pulumi.get(self, "certificate_type")
 
-    @country.setter
-    def country(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "country", value)
+    @certificate_type.setter
+    def certificate_type(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "certificate_type", value)
 
     @property
-    @pulumi.getter(name="datacenterId")
-    def datacenter_id(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="commonName")
+    def common_name(self) -> Optional[pulumi.Input[str]]:
         """
-        A unique identifier for an existing data center in the domain.
+        Common name used for enrollment
         """
-        return pulumi.get(self, "datacenter_id")
+        return pulumi.get(self, "common_name")
 
-    @datacenter_id.setter
-    def datacenter_id(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "datacenter_id", value)
+    @common_name.setter
+    def common_name(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "common_name", value)
 
     @property
-    @pulumi.getter(name="defaultLoadObject")
-    def default_load_object(self) -> Optional[pulumi.Input['GtmDatacenterDefaultLoadObjectArgs']]:
+    @pulumi.getter(name="contractId")
+    def contract_id(self) -> Optional[pulumi.Input[str]]:
         """
-        Specifies the load reporting interface between you and the GTM system. If used, requires these additional arguments:
+        Contract ID for which enrollment is retrieved
         """
-        return pulumi.get(self, "default_load_object")
+        return pulumi.get(self, "contract_id")
 
-    @default_load_object.setter
-    def default_load_object(self, value: Optional[pulumi.Input['GtmDatacenterDefaultLoadObjectArgs']]):
-        pulumi.set(self, "default_load_object", value)
+    @contract_id.setter
+    def contract_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "contract_id", value)
 
     @property
     @pulumi.getter
-    def domain(self) -> Optional[pulumi.Input[str]]:
+    def csr(self) -> Optional[pulumi.Input['CpsDvEnrollmentCsrArgs']]:
         """
-        The GTM domain name for the data center.
+        Certificate signing request generated during enrollment creation
         """
-        return pulumi.get(self, "domain")
+        return pulumi.get(self, "csr")
 
-    @domain.setter
-    def domain(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "domain", value)
+    @csr.setter
+    def csr(self, value: Optional[pulumi.Input['CpsDvEnrollmentCsrArgs']]):
+        pulumi.set(self, "csr", value)
 
     @property
-    @pulumi.getter
-    def latitude(self) -> Optional[pulumi.Input[float]]:
+    @pulumi.getter(name="dnsChallenges")
+    def dns_challenges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CpsDvEnrollmentDnsChallengeArgs']]]]:
         """
-        Specifies the geographical latitude of the data center's position. See also longitude within this object.
+        DNS challenge information
         """
-        return pulumi.get(self, "latitude")
+        return pulumi.get(self, "dns_challenges")
 
-    @latitude.setter
-    def latitude(self, value: Optional[pulumi.Input[float]]):
-        pulumi.set(self, "latitude", value)
+    @dns_challenges.setter
+    def dns_challenges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CpsDvEnrollmentDnsChallengeArgs']]]]):
+        pulumi.set(self, "dns_challenges", value)
 
     @property
-    @pulumi.getter
-    def longitude(self) -> Optional[pulumi.Input[float]]:
+    @pulumi.getter(name="enableMultiStackedCertificates")
+    def enable_multi_stacked_certificates(self) -> Optional[pulumi.Input[bool]]:
         """
-        Specifies the geographic longitude of the data center's position. See also latitude within this object.
+        Enable Dual-Stacked certificate deployment for enrollment
         """
-        return pulumi.get(self, "longitude")
+        return pulumi.get(self, "enable_multi_stacked_certificates")
 
-    @longitude.setter
-    def longitude(self, value: Optional[pulumi.Input[float]]):
-        pulumi.set(self, "longitude", value)
+    @enable_multi_stacked_certificates.setter
+    def enable_multi_stacked_certificates(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "enable_multi_stacked_certificates", value)
 
     @property
-    @pulumi.getter
-    def nickname(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="httpChallenges")
+    def http_challenges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CpsDvEnrollmentHttpChallengeArgs']]]]:
         """
-        A descriptive label for the data center.
+        HTTP challenge information
         """
-        return pulumi.get(self, "nickname")
+        return pulumi.get(self, "http_challenges")
 
-    @nickname.setter
-    def nickname(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "nickname", value)
+    @http_challenges.setter
+    def http_challenges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CpsDvEnrollmentHttpChallengeArgs']]]]):
+        pulumi.set(self, "http_challenges", value)
 
     @property
-    @pulumi.getter(name="pingInterval")
-    def ping_interval(self) -> Optional[pulumi.Input[int]]:
-        return pulumi.get(self, "ping_interval")
+    @pulumi.getter(name="networkConfiguration")
+    def network_configuration(self) -> Optional[pulumi.Input['CpsDvEnrollmentNetworkConfigurationArgs']]:
+        """
+        Settings containing network information and TLS Metadata used by CPS
+        """
+        return pulumi.get(self, "network_configuration")
 
-    @ping_interval.setter
-    def ping_interval(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "ping_interval", value)
+    @network_configuration.setter
+    def network_configuration(self, value: Optional[pulumi.Input['CpsDvEnrollmentNetworkConfigurationArgs']]):
+        pulumi.set(self, "network_configuration", value)
 
     @property
-    @pulumi.getter(name="pingPacketSize")
-    def ping_packet_size(self) -> Optional[pulumi.Input[int]]:
-        return pulumi.get(self, "ping_packet_size")
+    @pulumi.getter
+    def organization(self) -> Optional[pulumi.Input['CpsDvEnrollmentOrganizationArgs']]:
+        """
+        Organization information
+        """
+        return pulumi.get(self, "organization")
 
-    @ping_packet_size.setter
-    def ping_packet_size(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "ping_packet_size", value)
+    @organization.setter
+    def organization(self, value: Optional[pulumi.Input['CpsDvEnrollmentOrganizationArgs']]):
+        pulumi.set(self, "organization", value)
 
     @property
-    @pulumi.getter(name="scorePenalty")
-    def score_penalty(self) -> Optional[pulumi.Input[int]]:
-        return pulumi.get(self, "score_penalty")
+    @pulumi.getter(name="registrationAuthority")
+    def registration_authority(self) -> Optional[pulumi.Input[str]]:
+        """
+        The registration authority or certificate authority (CA) used to obtain a certificate
+        """
+        return pulumi.get(self, "registration_authority")
 
-    @score_penalty.setter
-    def score_penalty(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "score_penalty", value)
+    @registration_authority.setter
+    def registration_authority(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "registration_authority", value)
 
     @property
-    @pulumi.getter(name="servermonitorLivenessCount")
-    def servermonitor_liveness_count(self) -> Optional[pulumi.Input[int]]:
-        return pulumi.get(self, "servermonitor_liveness_count")
+    @pulumi.getter
+    def sans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
+        """
+        List of SANs
+        """
+        return pulumi.get(self, "sans")
 
-    @servermonitor_liveness_count.setter
-    def servermonitor_liveness_count(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "servermonitor_liveness_count", value)
+    @sans.setter
+    def sans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
+        pulumi.set(self, "sans", value)
 
     @property
-    @pulumi.getter(name="servermonitorLoadCount")
-    def servermonitor_load_count(self) -> Optional[pulumi.Input[int]]:
-        return pulumi.get(self, "servermonitor_load_count")
+    @pulumi.getter(name="secureNetwork")
+    def secure_network(self) -> Optional[pulumi.Input[str]]:
+        """
+        Type of TLS deployment network
+        """
+        return pulumi.get(self, "secure_network")
 
-    @servermonitor_load_count.setter
-    def servermonitor_load_count(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "servermonitor_load_count", value)
+    @secure_network.setter
+    def secure_network(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "secure_network", value)
 
     @property
-    @pulumi.getter(name="servermonitorPool")
-    def servermonitor_pool(self) -> Optional[pulumi.Input[str]]:
-        return pulumi.get(self, "servermonitor_pool")
+    @pulumi.getter(name="signatureAlgorithm")
+    def signature_algorithm(self) -> Optional[pulumi.Input[str]]:
+        """
+        SHA algorithm type
+        """
+        return pulumi.get(self, "signature_algorithm")
 
-    @servermonitor_pool.setter
-    def servermonitor_pool(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "servermonitor_pool", value)
+    @signature_algorithm.setter
+    def signature_algorithm(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "signature_algorithm", value)
 
     @property
-    @pulumi.getter(name="stateOrProvince")
-    def state_or_province(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="sniOnly")
+    def sni_only(self) -> Optional[pulumi.Input[bool]]:
         """
-        Specifies a two-letter ISO 3166 country code for the state or province where the data center is located.
+        Whether Server Name Indication is used for enrollment
         """
-        return pulumi.get(self, "state_or_province")
+        return pulumi.get(self, "sni_only")
 
-    @state_or_province.setter
-    def state_or_province(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "state_or_province", value)
+    @sni_only.setter
+    def sni_only(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "sni_only", value)
 
     @property
-    @pulumi.getter
-    def virtual(self) -> Optional[pulumi.Input[bool]]:
+    @pulumi.getter(name="techContact")
+    def tech_contact(self) -> Optional[pulumi.Input['CpsDvEnrollmentTechContactArgs']]:
         """
-        A boolean indicating whether the data center is virtual or physical, the latter meaning the data center has an Akamai Network Agent installed, and its physical location (`latitude`, `longitude`) is fixed. Either `true` if virtual or `false` if physical.
+        Contact information for an administrator at Akamai
         """
-        return pulumi.get(self, "virtual")
+        return pulumi.get(self, "tech_contact")
 
-    @virtual.setter
-    def virtual(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "virtual", value)
+    @tech_contact.setter
+    def tech_contact(self, value: Optional[pulumi.Input['CpsDvEnrollmentTechContactArgs']]):
+        pulumi.set(self, "tech_contact", value)
 
     @property
-    @pulumi.getter(name="waitOnComplete")
-    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
+    @pulumi.getter(name="validationType")
+    def validation_type(self) -> Optional[pulumi.Input[str]]:
         """
-        A boolean, that if set to `true`, waits for transaction to complete.
+        Enrolment validation type
         """
-        return pulumi.get(self, "wait_on_complete")
+        return pulumi.get(self, "validation_type")
 
-    @wait_on_complete.setter
-    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "wait_on_complete", value)
+    @validation_type.setter
+    def validation_type(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "validation_type", value)
 
 
-class GtmDatacenter(pulumi.CustomResource):
+class CpsDvEnrollment(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 city: Optional[pulumi.Input[str]] = None,
-                 clone_of: Optional[pulumi.Input[int]] = None,
-                 cloud_server_host_header_override: Optional[pulumi.Input[bool]] = None,
-                 cloud_server_targeting: Optional[pulumi.Input[bool]] = None,
-                 continent: Optional[pulumi.Input[str]] = None,
-                 country: Optional[pulumi.Input[str]] = None,
-                 default_load_object: Optional[pulumi.Input[pulumi.InputType['GtmDatacenterDefaultLoadObjectArgs']]] = None,
-                 domain: Optional[pulumi.Input[str]] = None,
-                 latitude: Optional[pulumi.Input[float]] = None,
-                 longitude: Optional[pulumi.Input[float]] = None,
-                 nickname: Optional[pulumi.Input[str]] = None,
-                 state_or_province: Optional[pulumi.Input[str]] = None,
-                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
+                 acknowledge_pre_verification_warnings: Optional[pulumi.Input[bool]] = None,
+                 admin_contact: Optional[pulumi.Input[pulumi.InputType['CpsDvEnrollmentAdminContactArgs']]] = None,
+                 allow_duplicate_common_name: Optional[pulumi.Input[bool]] = None,
+                 certificate_chain_type: Optional[pulumi.Input[str]] = None,
+                 common_name: Optional[pulumi.Input[str]] = None,
+                 contract_id: Optional[pulumi.Input[str]] = None,
+                 csr: Optional[pulumi.Input[pulumi.InputType['CpsDvEnrollmentCsrArgs']]] = None,
+                 enable_multi_stacked_certificates: Optional[pulumi.Input[bool]] = None,
+                 network_configuration: Optional[pulumi.Input[pulumi.InputType['CpsDvEnrollmentNetworkConfigurationArgs']]] = None,
+                 organization: Optional[pulumi.Input[pulumi.InputType['CpsDvEnrollmentOrganizationArgs']]] = None,
+                 sans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 secure_network: Optional[pulumi.Input[str]] = None,
+                 signature_algorithm: Optional[pulumi.Input[str]] = None,
+                 sni_only: Optional[pulumi.Input[bool]] = None,
+                 tech_contact: Optional[pulumi.Input[pulumi.InputType['CpsDvEnrollmentTechContactArgs']]] = None,
                  __props__=None):
         """
-        Use the `GtmDatacenter` resource to create, configure, and import a GTM data center. A GTM data center represents a customer data center and is also known as a traffic target, a location containing many servers GTM can direct traffic to.
-
-        GTM uses data centers to scale load balancing. For example, you might have data centers in both New York and Amsterdam and want to balance load between them. You can configure GTM to send US users to the New York data center and European users to the data center in Amsterdam.
-
-        > **Note** Import requires an ID with this format: `existing_domain_name`:`existing_datacenter_id`.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        demo_datacenter = akamai.GtmDatacenter("demoDatacenter",
-            domain="demo_domain.akadns.net",
-            nickname="demo_datacenter")
-        ```
-
+        Create a CpsDvEnrollment resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] city: The name of the city where the data center is located.
-        :param pulumi.Input[int] clone_of: Identifies the data center's `datacenter_id` of which this data center is a clone.
-        :param pulumi.Input[bool] cloud_server_host_header_override: A boolean that, if set to `true`, Akamai's liveness test agents use the Host header configured in the liveness test.
-        :param pulumi.Input[bool] cloud_server_targeting: A boolean indicating whether to balance load between two or more servers in a cloud environment.
-        :param pulumi.Input[str] continent: A two-letter code that specifies the continent where the data center maps to.
-        :param pulumi.Input[str] country: A two-letter ISO 3166 country code that specifies the country where the data center maps to.
-        :param pulumi.Input[pulumi.InputType['GtmDatacenterDefaultLoadObjectArgs']] default_load_object: Specifies the load reporting interface between you and the GTM system. If used, requires these additional arguments:
-        :param pulumi.Input[str] domain: The GTM domain name for the data center.
-        :param pulumi.Input[float] latitude: Specifies the geographical latitude of the data center's position. See also longitude within this object.
-        :param pulumi.Input[float] longitude: Specifies the geographic longitude of the data center's position. See also latitude within this object.
-        :param pulumi.Input[str] nickname: A descriptive label for the data center.
-        :param pulumi.Input[str] state_or_province: Specifies a two-letter ISO 3166 country code for the state or province where the data center is located.
-        :param pulumi.Input[bool] wait_on_complete: A boolean, that if set to `true`, waits for transaction to complete.
+        :param pulumi.Input[bool] acknowledge_pre_verification_warnings: Whether acknowledge warnings before certificate verification
+        :param pulumi.Input[pulumi.InputType['CpsDvEnrollmentAdminContactArgs']] admin_contact: Contact information for the certificate administrator to use at organization
+        :param pulumi.Input[bool] allow_duplicate_common_name: Allow to duplicate common name
+        :param pulumi.Input[str] certificate_chain_type: Certificate trust chain type
+        :param pulumi.Input[str] common_name: Common name used for enrollment
+        :param pulumi.Input[str] contract_id: Contract ID for which enrollment is retrieved
+        :param pulumi.Input[pulumi.InputType['CpsDvEnrollmentCsrArgs']] csr: Certificate signing request generated during enrollment creation
+        :param pulumi.Input[bool] enable_multi_stacked_certificates: Enable Dual-Stacked certificate deployment for enrollment
+        :param pulumi.Input[pulumi.InputType['CpsDvEnrollmentNetworkConfigurationArgs']] network_configuration: Settings containing network information and TLS Metadata used by CPS
+        :param pulumi.Input[pulumi.InputType['CpsDvEnrollmentOrganizationArgs']] organization: Organization information
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] sans: List of SANs
+        :param pulumi.Input[str] secure_network: Type of TLS deployment network
+        :param pulumi.Input[str] signature_algorithm: SHA algorithm type
+        :param pulumi.Input[bool] sni_only: Whether Server Name Indication is used for enrollment
+        :param pulumi.Input[pulumi.InputType['CpsDvEnrollmentTechContactArgs']] tech_contact: Contact information for an administrator at Akamai
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: GtmDatacenterArgs,
+                 args: CpsDvEnrollmentArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        Use the `GtmDatacenter` resource to create, configure, and import a GTM data center. A GTM data center represents a customer data center and is also known as a traffic target, a location containing many servers GTM can direct traffic to.
-
-        GTM uses data centers to scale load balancing. For example, you might have data centers in both New York and Amsterdam and want to balance load between them. You can configure GTM to send US users to the New York data center and European users to the data center in Amsterdam.
-
-        > **Note** Import requires an ID with this format: `existing_domain_name`:`existing_datacenter_id`.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        demo_datacenter = akamai.GtmDatacenter("demoDatacenter",
-            domain="demo_domain.akadns.net",
-            nickname="demo_datacenter")
-        ```
-
+        Create a CpsDvEnrollment resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param GtmDatacenterArgs args: The arguments to use to populate this resource's properties.
+        :param CpsDvEnrollmentArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(GtmDatacenterArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(CpsDvEnrollmentArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 city: Optional[pulumi.Input[str]] = None,
-                 clone_of: Optional[pulumi.Input[int]] = None,
-                 cloud_server_host_header_override: Optional[pulumi.Input[bool]] = None,
-                 cloud_server_targeting: Optional[pulumi.Input[bool]] = None,
-                 continent: Optional[pulumi.Input[str]] = None,
-                 country: Optional[pulumi.Input[str]] = None,
-                 default_load_object: Optional[pulumi.Input[pulumi.InputType['GtmDatacenterDefaultLoadObjectArgs']]] = None,
-                 domain: Optional[pulumi.Input[str]] = None,
-                 latitude: Optional[pulumi.Input[float]] = None,
-                 longitude: Optional[pulumi.Input[float]] = None,
-                 nickname: Optional[pulumi.Input[str]] = None,
-                 state_or_province: Optional[pulumi.Input[str]] = None,
-                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
+                 acknowledge_pre_verification_warnings: Optional[pulumi.Input[bool]] = None,
+                 admin_contact: Optional[pulumi.Input[pulumi.InputType['CpsDvEnrollmentAdminContactArgs']]] = None,
+                 allow_duplicate_common_name: Optional[pulumi.Input[bool]] = None,
+                 certificate_chain_type: Optional[pulumi.Input[str]] = None,
+                 common_name: Optional[pulumi.Input[str]] = None,
+                 contract_id: Optional[pulumi.Input[str]] = None,
+                 csr: Optional[pulumi.Input[pulumi.InputType['CpsDvEnrollmentCsrArgs']]] = None,
+                 enable_multi_stacked_certificates: Optional[pulumi.Input[bool]] = None,
+                 network_configuration: Optional[pulumi.Input[pulumi.InputType['CpsDvEnrollmentNetworkConfigurationArgs']]] = None,
+                 organization: Optional[pulumi.Input[pulumi.InputType['CpsDvEnrollmentOrganizationArgs']]] = None,
+                 sans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 secure_network: Optional[pulumi.Input[str]] = None,
+                 signature_algorithm: Optional[pulumi.Input[str]] = None,
+                 sni_only: Optional[pulumi.Input[bool]] = None,
+                 tech_contact: Optional[pulumi.Input[pulumi.InputType['CpsDvEnrollmentTechContactArgs']]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = GtmDatacenterArgs.__new__(GtmDatacenterArgs)
+            __props__ = CpsDvEnrollmentArgs.__new__(CpsDvEnrollmentArgs)
 
-            __props__.__dict__["city"] = city
-            __props__.__dict__["clone_of"] = clone_of
-            __props__.__dict__["cloud_server_host_header_override"] = cloud_server_host_header_override
-            __props__.__dict__["cloud_server_targeting"] = cloud_server_targeting
-            __props__.__dict__["continent"] = continent
-            __props__.__dict__["country"] = country
-            __props__.__dict__["default_load_object"] = default_load_object
-            if domain is None and not opts.urn:
-                raise TypeError("Missing required property 'domain'")
-            __props__.__dict__["domain"] = domain
-            __props__.__dict__["latitude"] = latitude
-            __props__.__dict__["longitude"] = longitude
-            __props__.__dict__["nickname"] = nickname
-            __props__.__dict__["state_or_province"] = state_or_province
-            __props__.__dict__["wait_on_complete"] = wait_on_complete
-            __props__.__dict__["datacenter_id"] = None
-            __props__.__dict__["ping_interval"] = None
-            __props__.__dict__["ping_packet_size"] = None
-            __props__.__dict__["score_penalty"] = None
-            __props__.__dict__["servermonitor_liveness_count"] = None
-            __props__.__dict__["servermonitor_load_count"] = None
-            __props__.__dict__["servermonitor_pool"] = None
-            __props__.__dict__["virtual"] = None
-        alias_opts = pulumi.ResourceOptions(aliases=[pulumi.Alias(type_="akamai:trafficmanagement/gtmDatacenter:GtmDatacenter")])
-        opts = pulumi.ResourceOptions.merge(opts, alias_opts)
-        super(GtmDatacenter, __self__).__init__(
-            'akamai:index/gtmDatacenter:GtmDatacenter',
+            __props__.__dict__["acknowledge_pre_verification_warnings"] = acknowledge_pre_verification_warnings
+            if admin_contact is None and not opts.urn:
+                raise TypeError("Missing required property 'admin_contact'")
+            __props__.__dict__["admin_contact"] = admin_contact
+            __props__.__dict__["allow_duplicate_common_name"] = allow_duplicate_common_name
+            __props__.__dict__["certificate_chain_type"] = certificate_chain_type
+            if common_name is None and not opts.urn:
+                raise TypeError("Missing required property 'common_name'")
+            __props__.__dict__["common_name"] = common_name
+            if contract_id is None and not opts.urn:
+                raise TypeError("Missing required property 'contract_id'")
+            __props__.__dict__["contract_id"] = contract_id
+            if csr is None and not opts.urn:
+                raise TypeError("Missing required property 'csr'")
+            __props__.__dict__["csr"] = csr
+            if enable_multi_stacked_certificates is not None and not opts.urn:
+                warnings.warn("""Deprecated, don't use; always false""", DeprecationWarning)
+                pulumi.log.warn("""enable_multi_stacked_certificates is deprecated: Deprecated, don't use; always false""")
+            __props__.__dict__["enable_multi_stacked_certificates"] = enable_multi_stacked_certificates
+            if network_configuration is None and not opts.urn:
+                raise TypeError("Missing required property 'network_configuration'")
+            __props__.__dict__["network_configuration"] = network_configuration
+            if organization is None and not opts.urn:
+                raise TypeError("Missing required property 'organization'")
+            __props__.__dict__["organization"] = organization
+            __props__.__dict__["sans"] = sans
+            if secure_network is None and not opts.urn:
+                raise TypeError("Missing required property 'secure_network'")
+            __props__.__dict__["secure_network"] = secure_network
+            if signature_algorithm is None and not opts.urn:
+                raise TypeError("Missing required property 'signature_algorithm'")
+            __props__.__dict__["signature_algorithm"] = signature_algorithm
+            if sni_only is None and not opts.urn:
+                raise TypeError("Missing required property 'sni_only'")
+            __props__.__dict__["sni_only"] = sni_only
+            if tech_contact is None and not opts.urn:
+                raise TypeError("Missing required property 'tech_contact'")
+            __props__.__dict__["tech_contact"] = tech_contact
+            __props__.__dict__["certificate_type"] = None
+            __props__.__dict__["dns_challenges"] = None
+            __props__.__dict__["http_challenges"] = None
+            __props__.__dict__["registration_authority"] = None
+            __props__.__dict__["validation_type"] = None
+        super(CpsDvEnrollment, __self__).__init__(
+            'akamai:index/cpsDvEnrollment:CpsDvEnrollment',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
-            city: Optional[pulumi.Input[str]] = None,
-            clone_of: Optional[pulumi.Input[int]] = None,
-            cloud_server_host_header_override: Optional[pulumi.Input[bool]] = None,
-            cloud_server_targeting: Optional[pulumi.Input[bool]] = None,
-            continent: Optional[pulumi.Input[str]] = None,
-            country: Optional[pulumi.Input[str]] = None,
-            datacenter_id: Optional[pulumi.Input[int]] = None,
-            default_load_object: Optional[pulumi.Input[pulumi.InputType['GtmDatacenterDefaultLoadObjectArgs']]] = None,
-            domain: Optional[pulumi.Input[str]] = None,
-            latitude: Optional[pulumi.Input[float]] = None,
-            longitude: Optional[pulumi.Input[float]] = None,
-            nickname: Optional[pulumi.Input[str]] = None,
-            ping_interval: Optional[pulumi.Input[int]] = None,
-            ping_packet_size: Optional[pulumi.Input[int]] = None,
-            score_penalty: Optional[pulumi.Input[int]] = None,
-            servermonitor_liveness_count: Optional[pulumi.Input[int]] = None,
-            servermonitor_load_count: Optional[pulumi.Input[int]] = None,
-            servermonitor_pool: Optional[pulumi.Input[str]] = None,
-            state_or_province: Optional[pulumi.Input[str]] = None,
-            virtual: Optional[pulumi.Input[bool]] = None,
-            wait_on_complete: Optional[pulumi.Input[bool]] = None) -> 'GtmDatacenter':
+            acknowledge_pre_verification_warnings: Optional[pulumi.Input[bool]] = None,
+            admin_contact: Optional[pulumi.Input[pulumi.InputType['CpsDvEnrollmentAdminContactArgs']]] = None,
+            allow_duplicate_common_name: Optional[pulumi.Input[bool]] = None,
+            certificate_chain_type: Optional[pulumi.Input[str]] = None,
+            certificate_type: Optional[pulumi.Input[str]] = None,
+            common_name: Optional[pulumi.Input[str]] = None,
+            contract_id: Optional[pulumi.Input[str]] = None,
+            csr: Optional[pulumi.Input[pulumi.InputType['CpsDvEnrollmentCsrArgs']]] = None,
+            dns_challenges: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['CpsDvEnrollmentDnsChallengeArgs']]]]] = None,
+            enable_multi_stacked_certificates: Optional[pulumi.Input[bool]] = None,
+            http_challenges: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['CpsDvEnrollmentHttpChallengeArgs']]]]] = None,
+            network_configuration: Optional[pulumi.Input[pulumi.InputType['CpsDvEnrollmentNetworkConfigurationArgs']]] = None,
+            organization: Optional[pulumi.Input[pulumi.InputType['CpsDvEnrollmentOrganizationArgs']]] = None,
+            registration_authority: Optional[pulumi.Input[str]] = None,
+            sans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+            secure_network: Optional[pulumi.Input[str]] = None,
+            signature_algorithm: Optional[pulumi.Input[str]] = None,
+            sni_only: Optional[pulumi.Input[bool]] = None,
+            tech_contact: Optional[pulumi.Input[pulumi.InputType['CpsDvEnrollmentTechContactArgs']]] = None,
+            validation_type: Optional[pulumi.Input[str]] = None) -> 'CpsDvEnrollment':
         """
-        Get an existing GtmDatacenter resource's state with the given name, id, and optional extra
+        Get an existing CpsDvEnrollment resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] city: The name of the city where the data center is located.
-        :param pulumi.Input[int] clone_of: Identifies the data center's `datacenter_id` of which this data center is a clone.
-        :param pulumi.Input[bool] cloud_server_host_header_override: A boolean that, if set to `true`, Akamai's liveness test agents use the Host header configured in the liveness test.
-        :param pulumi.Input[bool] cloud_server_targeting: A boolean indicating whether to balance load between two or more servers in a cloud environment.
-        :param pulumi.Input[str] continent: A two-letter code that specifies the continent where the data center maps to.
-        :param pulumi.Input[str] country: A two-letter ISO 3166 country code that specifies the country where the data center maps to.
-        :param pulumi.Input[int] datacenter_id: A unique identifier for an existing data center in the domain.
-        :param pulumi.Input[pulumi.InputType['GtmDatacenterDefaultLoadObjectArgs']] default_load_object: Specifies the load reporting interface between you and the GTM system. If used, requires these additional arguments:
-        :param pulumi.Input[str] domain: The GTM domain name for the data center.
-        :param pulumi.Input[float] latitude: Specifies the geographical latitude of the data center's position. See also longitude within this object.
-        :param pulumi.Input[float] longitude: Specifies the geographic longitude of the data center's position. See also latitude within this object.
-        :param pulumi.Input[str] nickname: A descriptive label for the data center.
-        :param pulumi.Input[str] state_or_province: Specifies a two-letter ISO 3166 country code for the state or province where the data center is located.
-        :param pulumi.Input[bool] virtual: A boolean indicating whether the data center is virtual or physical, the latter meaning the data center has an Akamai Network Agent installed, and its physical location (`latitude`, `longitude`) is fixed. Either `true` if virtual or `false` if physical.
-        :param pulumi.Input[bool] wait_on_complete: A boolean, that if set to `true`, waits for transaction to complete.
+        :param pulumi.Input[bool] acknowledge_pre_verification_warnings: Whether acknowledge warnings before certificate verification
+        :param pulumi.Input[pulumi.InputType['CpsDvEnrollmentAdminContactArgs']] admin_contact: Contact information for the certificate administrator to use at organization
+        :param pulumi.Input[bool] allow_duplicate_common_name: Allow to duplicate common name
+        :param pulumi.Input[str] certificate_chain_type: Certificate trust chain type
+        :param pulumi.Input[str] certificate_type: Certificate type of enrollment
+        :param pulumi.Input[str] common_name: Common name used for enrollment
+        :param pulumi.Input[str] contract_id: Contract ID for which enrollment is retrieved
+        :param pulumi.Input[pulumi.InputType['CpsDvEnrollmentCsrArgs']] csr: Certificate signing request generated during enrollment creation
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['CpsDvEnrollmentDnsChallengeArgs']]]] dns_challenges: DNS challenge information
+        :param pulumi.Input[bool] enable_multi_stacked_certificates: Enable Dual-Stacked certificate deployment for enrollment
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['CpsDvEnrollmentHttpChallengeArgs']]]] http_challenges: HTTP challenge information
+        :param pulumi.Input[pulumi.InputType['CpsDvEnrollmentNetworkConfigurationArgs']] network_configuration: Settings containing network information and TLS Metadata used by CPS
+        :param pulumi.Input[pulumi.InputType['CpsDvEnrollmentOrganizationArgs']] organization: Organization information
+        :param pulumi.Input[str] registration_authority: The registration authority or certificate authority (CA) used to obtain a certificate
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] sans: List of SANs
+        :param pulumi.Input[str] secure_network: Type of TLS deployment network
+        :param pulumi.Input[str] signature_algorithm: SHA algorithm type
+        :param pulumi.Input[bool] sni_only: Whether Server Name Indication is used for enrollment
+        :param pulumi.Input[pulumi.InputType['CpsDvEnrollmentTechContactArgs']] tech_contact: Contact information for an administrator at Akamai
+        :param pulumi.Input[str] validation_type: Enrolment validation type
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _GtmDatacenterState.__new__(_GtmDatacenterState)
+        __props__ = _CpsDvEnrollmentState.__new__(_CpsDvEnrollmentState)
 
-        __props__.__dict__["city"] = city
-        __props__.__dict__["clone_of"] = clone_of
-        __props__.__dict__["cloud_server_host_header_override"] = cloud_server_host_header_override
-        __props__.__dict__["cloud_server_targeting"] = cloud_server_targeting
-        __props__.__dict__["continent"] = continent
-        __props__.__dict__["country"] = country
-        __props__.__dict__["datacenter_id"] = datacenter_id
-        __props__.__dict__["default_load_object"] = default_load_object
-        __props__.__dict__["domain"] = domain
-        __props__.__dict__["latitude"] = latitude
-        __props__.__dict__["longitude"] = longitude
-        __props__.__dict__["nickname"] = nickname
-        __props__.__dict__["ping_interval"] = ping_interval
-        __props__.__dict__["ping_packet_size"] = ping_packet_size
-        __props__.__dict__["score_penalty"] = score_penalty
-        __props__.__dict__["servermonitor_liveness_count"] = servermonitor_liveness_count
-        __props__.__dict__["servermonitor_load_count"] = servermonitor_load_count
-        __props__.__dict__["servermonitor_pool"] = servermonitor_pool
-        __props__.__dict__["state_or_province"] = state_or_province
-        __props__.__dict__["virtual"] = virtual
-        __props__.__dict__["wait_on_complete"] = wait_on_complete
-        return GtmDatacenter(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["acknowledge_pre_verification_warnings"] = acknowledge_pre_verification_warnings
+        __props__.__dict__["admin_contact"] = admin_contact
+        __props__.__dict__["allow_duplicate_common_name"] = allow_duplicate_common_name
+        __props__.__dict__["certificate_chain_type"] = certificate_chain_type
+        __props__.__dict__["certificate_type"] = certificate_type
+        __props__.__dict__["common_name"] = common_name
+        __props__.__dict__["contract_id"] = contract_id
+        __props__.__dict__["csr"] = csr
+        __props__.__dict__["dns_challenges"] = dns_challenges
+        __props__.__dict__["enable_multi_stacked_certificates"] = enable_multi_stacked_certificates
+        __props__.__dict__["http_challenges"] = http_challenges
+        __props__.__dict__["network_configuration"] = network_configuration
+        __props__.__dict__["organization"] = organization
+        __props__.__dict__["registration_authority"] = registration_authority
+        __props__.__dict__["sans"] = sans
+        __props__.__dict__["secure_network"] = secure_network
+        __props__.__dict__["signature_algorithm"] = signature_algorithm
+        __props__.__dict__["sni_only"] = sni_only
+        __props__.__dict__["tech_contact"] = tech_contact
+        __props__.__dict__["validation_type"] = validation_type
+        return CpsDvEnrollment(resource_name, opts=opts, __props__=__props__)
 
     @property
-    @pulumi.getter
-    def city(self) -> pulumi.Output[Optional[str]]:
+    @pulumi.getter(name="acknowledgePreVerificationWarnings")
+    def acknowledge_pre_verification_warnings(self) -> pulumi.Output[Optional[bool]]:
         """
-        The name of the city where the data center is located.
+        Whether acknowledge warnings before certificate verification
         """
-        return pulumi.get(self, "city")
+        return pulumi.get(self, "acknowledge_pre_verification_warnings")
 
     @property
-    @pulumi.getter(name="cloneOf")
-    def clone_of(self) -> pulumi.Output[Optional[int]]:
+    @pulumi.getter(name="adminContact")
+    def admin_contact(self) -> pulumi.Output['outputs.CpsDvEnrollmentAdminContact']:
         """
-        Identifies the data center's `datacenter_id` of which this data center is a clone.
+        Contact information for the certificate administrator to use at organization
         """
-        return pulumi.get(self, "clone_of")
+        return pulumi.get(self, "admin_contact")
 
     @property
-    @pulumi.getter(name="cloudServerHostHeaderOverride")
-    def cloud_server_host_header_override(self) -> pulumi.Output[Optional[bool]]:
+    @pulumi.getter(name="allowDuplicateCommonName")
+    def allow_duplicate_common_name(self) -> pulumi.Output[Optional[bool]]:
         """
-        A boolean that, if set to `true`, Akamai's liveness test agents use the Host header configured in the liveness test.
+        Allow to duplicate common name
         """
-        return pulumi.get(self, "cloud_server_host_header_override")
+        return pulumi.get(self, "allow_duplicate_common_name")
 
     @property
-    @pulumi.getter(name="cloudServerTargeting")
-    def cloud_server_targeting(self) -> pulumi.Output[Optional[bool]]:
+    @pulumi.getter(name="certificateChainType")
+    def certificate_chain_type(self) -> pulumi.Output[Optional[str]]:
         """
-        A boolean indicating whether to balance load between two or more servers in a cloud environment.
+        Certificate trust chain type
         """
-        return pulumi.get(self, "cloud_server_targeting")
+        return pulumi.get(self, "certificate_chain_type")
 
     @property
-    @pulumi.getter
-    def continent(self) -> pulumi.Output[Optional[str]]:
+    @pulumi.getter(name="certificateType")
+    def certificate_type(self) -> pulumi.Output[str]:
         """
-        A two-letter code that specifies the continent where the data center maps to.
+        Certificate type of enrollment
         """
-        return pulumi.get(self, "continent")
+        return pulumi.get(self, "certificate_type")
 
     @property
-    @pulumi.getter
-    def country(self) -> pulumi.Output[Optional[str]]:
+    @pulumi.getter(name="commonName")
+    def common_name(self) -> pulumi.Output[str]:
         """
-        A two-letter ISO 3166 country code that specifies the country where the data center maps to.
+        Common name used for enrollment
         """
-        return pulumi.get(self, "country")
+        return pulumi.get(self, "common_name")
 
     @property
-    @pulumi.getter(name="datacenterId")
-    def datacenter_id(self) -> pulumi.Output[int]:
+    @pulumi.getter(name="contractId")
+    def contract_id(self) -> pulumi.Output[str]:
         """
-        A unique identifier for an existing data center in the domain.
+        Contract ID for which enrollment is retrieved
         """
-        return pulumi.get(self, "datacenter_id")
+        return pulumi.get(self, "contract_id")
 
     @property
-    @pulumi.getter(name="defaultLoadObject")
-    def default_load_object(self) -> pulumi.Output[Optional['outputs.GtmDatacenterDefaultLoadObject']]:
+    @pulumi.getter
+    def csr(self) -> pulumi.Output['outputs.CpsDvEnrollmentCsr']:
         """
-        Specifies the load reporting interface between you and the GTM system. If used, requires these additional arguments:
+        Certificate signing request generated during enrollment creation
         """
-        return pulumi.get(self, "default_load_object")
+        return pulumi.get(self, "csr")
 
     @property
-    @pulumi.getter
-    def domain(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="dnsChallenges")
+    def dns_challenges(self) -> pulumi.Output[Sequence['outputs.CpsDvEnrollmentDnsChallenge']]:
         """
-        The GTM domain name for the data center.
+        DNS challenge information
         """
-        return pulumi.get(self, "domain")
+        return pulumi.get(self, "dns_challenges")
 
     @property
-    @pulumi.getter
-    def latitude(self) -> pulumi.Output[Optional[float]]:
+    @pulumi.getter(name="enableMultiStackedCertificates")
+    def enable_multi_stacked_certificates(self) -> pulumi.Output[Optional[bool]]:
         """
-        Specifies the geographical latitude of the data center's position. See also longitude within this object.
+        Enable Dual-Stacked certificate deployment for enrollment
         """
-        return pulumi.get(self, "latitude")
+        return pulumi.get(self, "enable_multi_stacked_certificates")
 
     @property
-    @pulumi.getter
-    def longitude(self) -> pulumi.Output[Optional[float]]:
+    @pulumi.getter(name="httpChallenges")
+    def http_challenges(self) -> pulumi.Output[Sequence['outputs.CpsDvEnrollmentHttpChallenge']]:
         """
-        Specifies the geographic longitude of the data center's position. See also latitude within this object.
+        HTTP challenge information
         """
-        return pulumi.get(self, "longitude")
+        return pulumi.get(self, "http_challenges")
 
     @property
-    @pulumi.getter
-    def nickname(self) -> pulumi.Output[Optional[str]]:
+    @pulumi.getter(name="networkConfiguration")
+    def network_configuration(self) -> pulumi.Output['outputs.CpsDvEnrollmentNetworkConfiguration']:
         """
-        A descriptive label for the data center.
+        Settings containing network information and TLS Metadata used by CPS
         """
-        return pulumi.get(self, "nickname")
-
-    @property
-    @pulumi.getter(name="pingInterval")
-    def ping_interval(self) -> pulumi.Output[int]:
-        return pulumi.get(self, "ping_interval")
+        return pulumi.get(self, "network_configuration")
 
     @property
-    @pulumi.getter(name="pingPacketSize")
-    def ping_packet_size(self) -> pulumi.Output[int]:
-        return pulumi.get(self, "ping_packet_size")
+    @pulumi.getter
+    def organization(self) -> pulumi.Output['outputs.CpsDvEnrollmentOrganization']:
+        """
+        Organization information
+        """
+        return pulumi.get(self, "organization")
 
     @property
-    @pulumi.getter(name="scorePenalty")
-    def score_penalty(self) -> pulumi.Output[int]:
-        return pulumi.get(self, "score_penalty")
+    @pulumi.getter(name="registrationAuthority")
+    def registration_authority(self) -> pulumi.Output[str]:
+        """
+        The registration authority or certificate authority (CA) used to obtain a certificate
+        """
+        return pulumi.get(self, "registration_authority")
 
     @property
-    @pulumi.getter(name="servermonitorLivenessCount")
-    def servermonitor_liveness_count(self) -> pulumi.Output[int]:
-        return pulumi.get(self, "servermonitor_liveness_count")
+    @pulumi.getter
+    def sans(self) -> pulumi.Output[Optional[Sequence[str]]]:
+        """
+        List of SANs
+        """
+        return pulumi.get(self, "sans")
 
     @property
-    @pulumi.getter(name="servermonitorLoadCount")
-    def servermonitor_load_count(self) -> pulumi.Output[int]:
-        return pulumi.get(self, "servermonitor_load_count")
+    @pulumi.getter(name="secureNetwork")
+    def secure_network(self) -> pulumi.Output[str]:
+        """
+        Type of TLS deployment network
+        """
+        return pulumi.get(self, "secure_network")
 
     @property
-    @pulumi.getter(name="servermonitorPool")
-    def servermonitor_pool(self) -> pulumi.Output[str]:
-        return pulumi.get(self, "servermonitor_pool")
+    @pulumi.getter(name="signatureAlgorithm")
+    def signature_algorithm(self) -> pulumi.Output[str]:
+        """
+        SHA algorithm type
+        """
+        return pulumi.get(self, "signature_algorithm")
 
     @property
-    @pulumi.getter(name="stateOrProvince")
-    def state_or_province(self) -> pulumi.Output[Optional[str]]:
+    @pulumi.getter(name="sniOnly")
+    def sni_only(self) -> pulumi.Output[bool]:
         """
-        Specifies a two-letter ISO 3166 country code for the state or province where the data center is located.
+        Whether Server Name Indication is used for enrollment
         """
-        return pulumi.get(self, "state_or_province")
+        return pulumi.get(self, "sni_only")
 
     @property
-    @pulumi.getter
-    def virtual(self) -> pulumi.Output[bool]:
+    @pulumi.getter(name="techContact")
+    def tech_contact(self) -> pulumi.Output['outputs.CpsDvEnrollmentTechContact']:
         """
-        A boolean indicating whether the data center is virtual or physical, the latter meaning the data center has an Akamai Network Agent installed, and its physical location (`latitude`, `longitude`) is fixed. Either `true` if virtual or `false` if physical.
+        Contact information for an administrator at Akamai
         """
-        return pulumi.get(self, "virtual")
+        return pulumi.get(self, "tech_contact")
 
     @property
-    @pulumi.getter(name="waitOnComplete")
-    def wait_on_complete(self) -> pulumi.Output[Optional[bool]]:
+    @pulumi.getter(name="validationType")
+    def validation_type(self) -> pulumi.Output[str]:
         """
-        A boolean, that if set to `true`, waits for transaction to complete.
+        Enrolment validation type
         """
-        return pulumi.get(self, "wait_on_complete")
+        return pulumi.get(self, "validation_type")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/gtm_resource.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/iam_user.py`

 * *Files 23% similar despite different names*

```diff
@@ -4,828 +4,1164 @@
 
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
-from . import outputs
-from ._inputs import *
 
-__all__ = ['GtmResourceArgs', 'GtmResource']
+__all__ = ['IamUserArgs', 'IamUser']
 
 @pulumi.input_type
-class GtmResourceArgs:
+class IamUserArgs:
     def __init__(__self__, *,
-                 aggregation_type: pulumi.Input[str],
-                 domain: pulumi.Input[str],
-                 type: pulumi.Input[str],
-                 constrained_property: Optional[pulumi.Input[str]] = None,
-                 decay_rate: Optional[pulumi.Input[float]] = None,
-                 description: Optional[pulumi.Input[str]] = None,
-                 host_header: Optional[pulumi.Input[str]] = None,
-                 leader_string: Optional[pulumi.Input[str]] = None,
-                 least_squares_decay: Optional[pulumi.Input[float]] = None,
-                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
-                 max_u_multiplicative_increment: Optional[pulumi.Input[float]] = None,
-                 name: Optional[pulumi.Input[str]] = None,
-                 resource_instances: Optional[pulumi.Input[Sequence[pulumi.Input['GtmResourceResourceInstanceArgs']]]] = None,
-                 upper_bound: Optional[pulumi.Input[int]] = None,
-                 wait_on_complete: Optional[pulumi.Input[bool]] = None):
+                 auth_grants_json: pulumi.Input[str],
+                 country: pulumi.Input[str],
+                 email: pulumi.Input[str],
+                 enable_tfa: pulumi.Input[bool],
+                 first_name: pulumi.Input[str],
+                 last_name: pulumi.Input[str],
+                 phone: pulumi.Input[str],
+                 address: Optional[pulumi.Input[str]] = None,
+                 city: Optional[pulumi.Input[str]] = None,
+                 contact_type: Optional[pulumi.Input[str]] = None,
+                 job_title: Optional[pulumi.Input[str]] = None,
+                 lock: Optional[pulumi.Input[bool]] = None,
+                 mobile_phone: Optional[pulumi.Input[str]] = None,
+                 preferred_language: Optional[pulumi.Input[str]] = None,
+                 secondary_email: Optional[pulumi.Input[str]] = None,
+                 session_timeout: Optional[pulumi.Input[int]] = None,
+                 state: Optional[pulumi.Input[str]] = None,
+                 time_zone: Optional[pulumi.Input[str]] = None,
+                 zip_code: Optional[pulumi.Input[str]] = None):
+        """
+        The set of arguments for constructing a IamUser resource.
+        :param pulumi.Input[str] auth_grants_json: A user's per-group role assignments, in JSON form
+        :param pulumi.Input[str] country: As part of the user's location, the value can be any that are available from the view-supported-countries operation
+        :param pulumi.Input[str] email: The user's email address
+        :param pulumi.Input[bool] enable_tfa: Indicates whether two-factor authentication is allowed
+        :param pulumi.Input[str] first_name: The user's first name
+        :param pulumi.Input[str] last_name: The user's surname
+        :param pulumi.Input[str] phone: The user's main phone number
+        :param pulumi.Input[str] address: The user's street address
+        :param pulumi.Input[str] city: The user's city
+        :param pulumi.Input[str] contact_type: To help characterize the user, the value can be any that are available from the view-contact-types operation
+        :param pulumi.Input[str] job_title: The user's position at your company
+        :param pulumi.Input[bool] lock: Flag to block a user account
+        :param pulumi.Input[str] mobile_phone: The user's mobile phone number
+        :param pulumi.Input[str] preferred_language: The value can be any that are available from the view-languages operation
+        :param pulumi.Input[str] secondary_email: The user's secondary email address
+        :param pulumi.Input[int] session_timeout: The number of seconds it takes for the user's Control Center session to time out if there hasn't been any activity
+        :param pulumi.Input[str] state: The user's state
+        :param pulumi.Input[str] time_zone: The user's time zone. The value can be any that are available from the view-time-zones operation
+        :param pulumi.Input[str] zip_code: The user's five-digit ZIP code
+        """
+        pulumi.set(__self__, "auth_grants_json", auth_grants_json)
+        pulumi.set(__self__, "country", country)
+        pulumi.set(__self__, "email", email)
+        pulumi.set(__self__, "enable_tfa", enable_tfa)
+        pulumi.set(__self__, "first_name", first_name)
+        pulumi.set(__self__, "last_name", last_name)
+        pulumi.set(__self__, "phone", phone)
+        if address is not None:
+            pulumi.set(__self__, "address", address)
+        if city is not None:
+            pulumi.set(__self__, "city", city)
+        if contact_type is not None:
+            pulumi.set(__self__, "contact_type", contact_type)
+        if job_title is not None:
+            pulumi.set(__self__, "job_title", job_title)
+        if lock is not None:
+            pulumi.set(__self__, "lock", lock)
+        if mobile_phone is not None:
+            pulumi.set(__self__, "mobile_phone", mobile_phone)
+        if preferred_language is not None:
+            pulumi.set(__self__, "preferred_language", preferred_language)
+        if secondary_email is not None:
+            pulumi.set(__self__, "secondary_email", secondary_email)
+        if session_timeout is not None:
+            pulumi.set(__self__, "session_timeout", session_timeout)
+        if state is not None:
+            pulumi.set(__self__, "state", state)
+        if time_zone is not None:
+            pulumi.set(__self__, "time_zone", time_zone)
+        if zip_code is not None:
+            pulumi.set(__self__, "zip_code", zip_code)
+
+    @property
+    @pulumi.getter(name="authGrantsJson")
+    def auth_grants_json(self) -> pulumi.Input[str]:
+        """
+        A user's per-group role assignments, in JSON form
+        """
+        return pulumi.get(self, "auth_grants_json")
+
+    @auth_grants_json.setter
+    def auth_grants_json(self, value: pulumi.Input[str]):
+        pulumi.set(self, "auth_grants_json", value)
+
+    @property
+    @pulumi.getter
+    def country(self) -> pulumi.Input[str]:
         """
-        The set of arguments for constructing a GtmResource resource.
-        :param pulumi.Input[str] aggregation_type: Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.
-        :param pulumi.Input[str] domain: DNS name for the GTM Domain set that includes this property.
-        :param pulumi.Input[str] type: Indicates the kind of `load_object` format used to determine the load on the resource.
-        :param pulumi.Input[str] constrained_property: Specifies the name of the property that this resource constrains, enter `**` to constrain all properties.
-        :param pulumi.Input[float] decay_rate: For Akamai internal use only. You can omit the value or set it to `null`.
-        :param pulumi.Input[str] description: A descriptive note to help you track what the resource constrains.
-        :param pulumi.Input[str] host_header: Optionally specifies the host header used when fetching the load object.
-        :param pulumi.Input[str] leader_string: Specifies the text that comes before the `load_object`.
-        :param pulumi.Input[float] least_squares_decay: For internal use only. Unless Akamai indicates otherwise, omit the value or set it to null.
-        :param pulumi.Input[float] max_u_multiplicative_increment: For Akamai internal use only. You can omit the value or set it to `null`.
-        :param pulumi.Input[str] name: A descriptive label for the GTM resource.
-        :param pulumi.Input[Sequence[pulumi.Input['GtmResourceResourceInstanceArgs']]] resource_instances: (multiple allowed) Contains information about the resources that constrain the properties within the data center. You can have multiple `resource_instance` entries. Requires these arguments:
-        :param pulumi.Input[int] upper_bound: An optional sanity check that specifies the maximum allowed value for any component of the load object.
-        :param pulumi.Input[bool] wait_on_complete: A boolean indicating whether to wait for transaction to complete. Set to `true` by default.
+        As part of the user's location, the value can be any that are available from the view-supported-countries operation
         """
-        pulumi.set(__self__, "aggregation_type", aggregation_type)
-        pulumi.set(__self__, "domain", domain)
-        pulumi.set(__self__, "type", type)
-        if constrained_property is not None:
-            pulumi.set(__self__, "constrained_property", constrained_property)
-        if decay_rate is not None:
-            pulumi.set(__self__, "decay_rate", decay_rate)
-        if description is not None:
-            pulumi.set(__self__, "description", description)
-        if host_header is not None:
-            pulumi.set(__self__, "host_header", host_header)
-        if leader_string is not None:
-            pulumi.set(__self__, "leader_string", leader_string)
-        if least_squares_decay is not None:
-            pulumi.set(__self__, "least_squares_decay", least_squares_decay)
-        if load_imbalance_percentage is not None:
-            pulumi.set(__self__, "load_imbalance_percentage", load_imbalance_percentage)
-        if max_u_multiplicative_increment is not None:
-            pulumi.set(__self__, "max_u_multiplicative_increment", max_u_multiplicative_increment)
-        if name is not None:
-            pulumi.set(__self__, "name", name)
-        if resource_instances is not None:
-            pulumi.set(__self__, "resource_instances", resource_instances)
-        if upper_bound is not None:
-            pulumi.set(__self__, "upper_bound", upper_bound)
-        if wait_on_complete is not None:
-            pulumi.set(__self__, "wait_on_complete", wait_on_complete)
+        return pulumi.get(self, "country")
+
+    @country.setter
+    def country(self, value: pulumi.Input[str]):
+        pulumi.set(self, "country", value)
 
     @property
-    @pulumi.getter(name="aggregationType")
-    def aggregation_type(self) -> pulumi.Input[str]:
+    @pulumi.getter
+    def email(self) -> pulumi.Input[str]:
         """
-        Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.
+        The user's email address
         """
-        return pulumi.get(self, "aggregation_type")
+        return pulumi.get(self, "email")
 
-    @aggregation_type.setter
-    def aggregation_type(self, value: pulumi.Input[str]):
-        pulumi.set(self, "aggregation_type", value)
+    @email.setter
+    def email(self, value: pulumi.Input[str]):
+        pulumi.set(self, "email", value)
 
     @property
-    @pulumi.getter
-    def domain(self) -> pulumi.Input[str]:
+    @pulumi.getter(name="enableTfa")
+    def enable_tfa(self) -> pulumi.Input[bool]:
         """
-        DNS name for the GTM Domain set that includes this property.
+        Indicates whether two-factor authentication is allowed
         """
-        return pulumi.get(self, "domain")
+        return pulumi.get(self, "enable_tfa")
 
-    @domain.setter
-    def domain(self, value: pulumi.Input[str]):
-        pulumi.set(self, "domain", value)
+    @enable_tfa.setter
+    def enable_tfa(self, value: pulumi.Input[bool]):
+        pulumi.set(self, "enable_tfa", value)
 
     @property
-    @pulumi.getter
-    def type(self) -> pulumi.Input[str]:
+    @pulumi.getter(name="firstName")
+    def first_name(self) -> pulumi.Input[str]:
         """
-        Indicates the kind of `load_object` format used to determine the load on the resource.
+        The user's first name
         """
-        return pulumi.get(self, "type")
+        return pulumi.get(self, "first_name")
 
-    @type.setter
-    def type(self, value: pulumi.Input[str]):
-        pulumi.set(self, "type", value)
+    @first_name.setter
+    def first_name(self, value: pulumi.Input[str]):
+        pulumi.set(self, "first_name", value)
 
     @property
-    @pulumi.getter(name="constrainedProperty")
-    def constrained_property(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="lastName")
+    def last_name(self) -> pulumi.Input[str]:
         """
-        Specifies the name of the property that this resource constrains, enter `**` to constrain all properties.
+        The user's surname
         """
-        return pulumi.get(self, "constrained_property")
+        return pulumi.get(self, "last_name")
 
-    @constrained_property.setter
-    def constrained_property(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "constrained_property", value)
+    @last_name.setter
+    def last_name(self, value: pulumi.Input[str]):
+        pulumi.set(self, "last_name", value)
 
     @property
-    @pulumi.getter(name="decayRate")
-    def decay_rate(self) -> Optional[pulumi.Input[float]]:
+    @pulumi.getter
+    def phone(self) -> pulumi.Input[str]:
         """
-        For Akamai internal use only. You can omit the value or set it to `null`.
+        The user's main phone number
         """
-        return pulumi.get(self, "decay_rate")
+        return pulumi.get(self, "phone")
 
-    @decay_rate.setter
-    def decay_rate(self, value: Optional[pulumi.Input[float]]):
-        pulumi.set(self, "decay_rate", value)
+    @phone.setter
+    def phone(self, value: pulumi.Input[str]):
+        pulumi.set(self, "phone", value)
 
     @property
     @pulumi.getter
-    def description(self) -> Optional[pulumi.Input[str]]:
+    def address(self) -> Optional[pulumi.Input[str]]:
         """
-        A descriptive note to help you track what the resource constrains.
+        The user's street address
         """
-        return pulumi.get(self, "description")
+        return pulumi.get(self, "address")
 
-    @description.setter
-    def description(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "description", value)
+    @address.setter
+    def address(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "address", value)
 
     @property
-    @pulumi.getter(name="hostHeader")
-    def host_header(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter
+    def city(self) -> Optional[pulumi.Input[str]]:
         """
-        Optionally specifies the host header used when fetching the load object.
+        The user's city
         """
-        return pulumi.get(self, "host_header")
+        return pulumi.get(self, "city")
 
-    @host_header.setter
-    def host_header(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "host_header", value)
+    @city.setter
+    def city(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "city", value)
 
     @property
-    @pulumi.getter(name="leaderString")
-    def leader_string(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="contactType")
+    def contact_type(self) -> Optional[pulumi.Input[str]]:
         """
-        Specifies the text that comes before the `load_object`.
+        To help characterize the user, the value can be any that are available from the view-contact-types operation
         """
-        return pulumi.get(self, "leader_string")
+        return pulumi.get(self, "contact_type")
 
-    @leader_string.setter
-    def leader_string(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "leader_string", value)
+    @contact_type.setter
+    def contact_type(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "contact_type", value)
 
     @property
-    @pulumi.getter(name="leastSquaresDecay")
-    def least_squares_decay(self) -> Optional[pulumi.Input[float]]:
+    @pulumi.getter(name="jobTitle")
+    def job_title(self) -> Optional[pulumi.Input[str]]:
         """
-        For internal use only. Unless Akamai indicates otherwise, omit the value or set it to null.
+        The user's position at your company
         """
-        return pulumi.get(self, "least_squares_decay")
+        return pulumi.get(self, "job_title")
 
-    @least_squares_decay.setter
-    def least_squares_decay(self, value: Optional[pulumi.Input[float]]):
-        pulumi.set(self, "least_squares_decay", value)
+    @job_title.setter
+    def job_title(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "job_title", value)
 
     @property
-    @pulumi.getter(name="loadImbalancePercentage")
-    def load_imbalance_percentage(self) -> Optional[pulumi.Input[float]]:
-        return pulumi.get(self, "load_imbalance_percentage")
+    @pulumi.getter
+    def lock(self) -> Optional[pulumi.Input[bool]]:
+        """
+        Flag to block a user account
+        """
+        return pulumi.get(self, "lock")
 
-    @load_imbalance_percentage.setter
-    def load_imbalance_percentage(self, value: Optional[pulumi.Input[float]]):
-        pulumi.set(self, "load_imbalance_percentage", value)
+    @lock.setter
+    def lock(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "lock", value)
 
     @property
-    @pulumi.getter(name="maxUMultiplicativeIncrement")
-    def max_u_multiplicative_increment(self) -> Optional[pulumi.Input[float]]:
+    @pulumi.getter(name="mobilePhone")
+    def mobile_phone(self) -> Optional[pulumi.Input[str]]:
         """
-        For Akamai internal use only. You can omit the value or set it to `null`.
+        The user's mobile phone number
         """
-        return pulumi.get(self, "max_u_multiplicative_increment")
+        return pulumi.get(self, "mobile_phone")
 
-    @max_u_multiplicative_increment.setter
-    def max_u_multiplicative_increment(self, value: Optional[pulumi.Input[float]]):
-        pulumi.set(self, "max_u_multiplicative_increment", value)
+    @mobile_phone.setter
+    def mobile_phone(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "mobile_phone", value)
 
     @property
-    @pulumi.getter
-    def name(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="preferredLanguage")
+    def preferred_language(self) -> Optional[pulumi.Input[str]]:
         """
-        A descriptive label for the GTM resource.
+        The value can be any that are available from the view-languages operation
         """
-        return pulumi.get(self, "name")
+        return pulumi.get(self, "preferred_language")
 
-    @name.setter
-    def name(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "name", value)
+    @preferred_language.setter
+    def preferred_language(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "preferred_language", value)
 
     @property
-    @pulumi.getter(name="resourceInstances")
-    def resource_instances(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmResourceResourceInstanceArgs']]]]:
+    @pulumi.getter(name="secondaryEmail")
+    def secondary_email(self) -> Optional[pulumi.Input[str]]:
         """
-        (multiple allowed) Contains information about the resources that constrain the properties within the data center. You can have multiple `resource_instance` entries. Requires these arguments:
+        The user's secondary email address
         """
-        return pulumi.get(self, "resource_instances")
+        return pulumi.get(self, "secondary_email")
 
-    @resource_instances.setter
-    def resource_instances(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmResourceResourceInstanceArgs']]]]):
-        pulumi.set(self, "resource_instances", value)
+    @secondary_email.setter
+    def secondary_email(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "secondary_email", value)
 
     @property
-    @pulumi.getter(name="upperBound")
-    def upper_bound(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="sessionTimeout")
+    def session_timeout(self) -> Optional[pulumi.Input[int]]:
         """
-        An optional sanity check that specifies the maximum allowed value for any component of the load object.
+        The number of seconds it takes for the user's Control Center session to time out if there hasn't been any activity
         """
-        return pulumi.get(self, "upper_bound")
+        return pulumi.get(self, "session_timeout")
 
-    @upper_bound.setter
-    def upper_bound(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "upper_bound", value)
+    @session_timeout.setter
+    def session_timeout(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "session_timeout", value)
 
     @property
-    @pulumi.getter(name="waitOnComplete")
-    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
+    @pulumi.getter
+    def state(self) -> Optional[pulumi.Input[str]]:
         """
-        A boolean indicating whether to wait for transaction to complete. Set to `true` by default.
+        The user's state
         """
-        return pulumi.get(self, "wait_on_complete")
+        return pulumi.get(self, "state")
 
-    @wait_on_complete.setter
-    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "wait_on_complete", value)
+    @state.setter
+    def state(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "state", value)
+
+    @property
+    @pulumi.getter(name="timeZone")
+    def time_zone(self) -> Optional[pulumi.Input[str]]:
+        """
+        The user's time zone. The value can be any that are available from the view-time-zones operation
+        """
+        return pulumi.get(self, "time_zone")
+
+    @time_zone.setter
+    def time_zone(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "time_zone", value)
+
+    @property
+    @pulumi.getter(name="zipCode")
+    def zip_code(self) -> Optional[pulumi.Input[str]]:
+        """
+        The user's five-digit ZIP code
+        """
+        return pulumi.get(self, "zip_code")
+
+    @zip_code.setter
+    def zip_code(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "zip_code", value)
 
 
 @pulumi.input_type
-class _GtmResourceState:
+class _IamUserState:
     def __init__(__self__, *,
-                 aggregation_type: Optional[pulumi.Input[str]] = None,
-                 constrained_property: Optional[pulumi.Input[str]] = None,
-                 decay_rate: Optional[pulumi.Input[float]] = None,
-                 description: Optional[pulumi.Input[str]] = None,
-                 domain: Optional[pulumi.Input[str]] = None,
-                 host_header: Optional[pulumi.Input[str]] = None,
-                 leader_string: Optional[pulumi.Input[str]] = None,
-                 least_squares_decay: Optional[pulumi.Input[float]] = None,
-                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
-                 max_u_multiplicative_increment: Optional[pulumi.Input[float]] = None,
-                 name: Optional[pulumi.Input[str]] = None,
-                 resource_instances: Optional[pulumi.Input[Sequence[pulumi.Input['GtmResourceResourceInstanceArgs']]]] = None,
-                 type: Optional[pulumi.Input[str]] = None,
-                 upper_bound: Optional[pulumi.Input[int]] = None,
-                 wait_on_complete: Optional[pulumi.Input[bool]] = None):
+                 address: Optional[pulumi.Input[str]] = None,
+                 auth_grants_json: Optional[pulumi.Input[str]] = None,
+                 city: Optional[pulumi.Input[str]] = None,
+                 contact_type: Optional[pulumi.Input[str]] = None,
+                 country: Optional[pulumi.Input[str]] = None,
+                 email: Optional[pulumi.Input[str]] = None,
+                 email_update_pending: Optional[pulumi.Input[bool]] = None,
+                 enable_tfa: Optional[pulumi.Input[bool]] = None,
+                 first_name: Optional[pulumi.Input[str]] = None,
+                 is_locked: Optional[pulumi.Input[bool]] = None,
+                 job_title: Optional[pulumi.Input[str]] = None,
+                 last_login: Optional[pulumi.Input[str]] = None,
+                 last_name: Optional[pulumi.Input[str]] = None,
+                 lock: Optional[pulumi.Input[bool]] = None,
+                 mobile_phone: Optional[pulumi.Input[str]] = None,
+                 password_expired_after: Optional[pulumi.Input[str]] = None,
+                 phone: Optional[pulumi.Input[str]] = None,
+                 preferred_language: Optional[pulumi.Input[str]] = None,
+                 secondary_email: Optional[pulumi.Input[str]] = None,
+                 session_timeout: Optional[pulumi.Input[int]] = None,
+                 state: Optional[pulumi.Input[str]] = None,
+                 tfa_configured: Optional[pulumi.Input[bool]] = None,
+                 time_zone: Optional[pulumi.Input[str]] = None,
+                 user_name: Optional[pulumi.Input[str]] = None,
+                 zip_code: Optional[pulumi.Input[str]] = None):
+        """
+        Input properties used for looking up and filtering IamUser resources.
+        :param pulumi.Input[str] address: The user's street address
+        :param pulumi.Input[str] auth_grants_json: A user's per-group role assignments, in JSON form
+        :param pulumi.Input[str] city: The user's city
+        :param pulumi.Input[str] contact_type: To help characterize the user, the value can be any that are available from the view-contact-types operation
+        :param pulumi.Input[str] country: As part of the user's location, the value can be any that are available from the view-supported-countries operation
+        :param pulumi.Input[str] email: The user's email address
+        :param pulumi.Input[bool] email_update_pending: Indicates whether email update is pending
+        :param pulumi.Input[bool] enable_tfa: Indicates whether two-factor authentication is allowed
+        :param pulumi.Input[str] first_name: The user's first name
+        :param pulumi.Input[bool] is_locked: The user's lock status
+        :param pulumi.Input[str] job_title: The user's position at your company
+        :param pulumi.Input[str] last_login: ISO 8601 timestamp indicating when the user last logged in
+        :param pulumi.Input[str] last_name: The user's surname
+        :param pulumi.Input[bool] lock: Flag to block a user account
+        :param pulumi.Input[str] mobile_phone: The user's mobile phone number
+        :param pulumi.Input[str] password_expired_after: The date a user's password expires
+        :param pulumi.Input[str] phone: The user's main phone number
+        :param pulumi.Input[str] preferred_language: The value can be any that are available from the view-languages operation
+        :param pulumi.Input[str] secondary_email: The user's secondary email address
+        :param pulumi.Input[int] session_timeout: The number of seconds it takes for the user's Control Center session to time out if there hasn't been any activity
+        :param pulumi.Input[str] state: The user's state
+        :param pulumi.Input[bool] tfa_configured: Indicates whether two-factor authentication is configured
+        :param pulumi.Input[str] time_zone: The user's time zone. The value can be any that are available from the view-time-zones operation
+        :param pulumi.Input[str] user_name: A user's `loginId`. Typically, a user's email address
+        :param pulumi.Input[str] zip_code: The user's five-digit ZIP code
+        """
+        if address is not None:
+            pulumi.set(__self__, "address", address)
+        if auth_grants_json is not None:
+            pulumi.set(__self__, "auth_grants_json", auth_grants_json)
+        if city is not None:
+            pulumi.set(__self__, "city", city)
+        if contact_type is not None:
+            pulumi.set(__self__, "contact_type", contact_type)
+        if country is not None:
+            pulumi.set(__self__, "country", country)
+        if email is not None:
+            pulumi.set(__self__, "email", email)
+        if email_update_pending is not None:
+            pulumi.set(__self__, "email_update_pending", email_update_pending)
+        if enable_tfa is not None:
+            pulumi.set(__self__, "enable_tfa", enable_tfa)
+        if first_name is not None:
+            pulumi.set(__self__, "first_name", first_name)
+        if is_locked is not None:
+            warnings.warn("""The setting \"is_locked\" has been deprecated. Please use \"lock\" setting instead""", DeprecationWarning)
+            pulumi.log.warn("""is_locked is deprecated: The setting \"is_locked\" has been deprecated. Please use \"lock\" setting instead""")
+        if is_locked is not None:
+            pulumi.set(__self__, "is_locked", is_locked)
+        if job_title is not None:
+            pulumi.set(__self__, "job_title", job_title)
+        if last_login is not None:
+            pulumi.set(__self__, "last_login", last_login)
+        if last_name is not None:
+            pulumi.set(__self__, "last_name", last_name)
+        if lock is not None:
+            pulumi.set(__self__, "lock", lock)
+        if mobile_phone is not None:
+            pulumi.set(__self__, "mobile_phone", mobile_phone)
+        if password_expired_after is not None:
+            pulumi.set(__self__, "password_expired_after", password_expired_after)
+        if phone is not None:
+            pulumi.set(__self__, "phone", phone)
+        if preferred_language is not None:
+            pulumi.set(__self__, "preferred_language", preferred_language)
+        if secondary_email is not None:
+            pulumi.set(__self__, "secondary_email", secondary_email)
+        if session_timeout is not None:
+            pulumi.set(__self__, "session_timeout", session_timeout)
+        if state is not None:
+            pulumi.set(__self__, "state", state)
+        if tfa_configured is not None:
+            pulumi.set(__self__, "tfa_configured", tfa_configured)
+        if time_zone is not None:
+            pulumi.set(__self__, "time_zone", time_zone)
+        if user_name is not None:
+            pulumi.set(__self__, "user_name", user_name)
+        if zip_code is not None:
+            pulumi.set(__self__, "zip_code", zip_code)
+
+    @property
+    @pulumi.getter
+    def address(self) -> Optional[pulumi.Input[str]]:
         """
-        Input properties used for looking up and filtering GtmResource resources.
-        :param pulumi.Input[str] aggregation_type: Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.
-        :param pulumi.Input[str] constrained_property: Specifies the name of the property that this resource constrains, enter `**` to constrain all properties.
-        :param pulumi.Input[float] decay_rate: For Akamai internal use only. You can omit the value or set it to `null`.
-        :param pulumi.Input[str] description: A descriptive note to help you track what the resource constrains.
-        :param pulumi.Input[str] domain: DNS name for the GTM Domain set that includes this property.
-        :param pulumi.Input[str] host_header: Optionally specifies the host header used when fetching the load object.
-        :param pulumi.Input[str] leader_string: Specifies the text that comes before the `load_object`.
-        :param pulumi.Input[float] least_squares_decay: For internal use only. Unless Akamai indicates otherwise, omit the value or set it to null.
-        :param pulumi.Input[float] max_u_multiplicative_increment: For Akamai internal use only. You can omit the value or set it to `null`.
-        :param pulumi.Input[str] name: A descriptive label for the GTM resource.
-        :param pulumi.Input[Sequence[pulumi.Input['GtmResourceResourceInstanceArgs']]] resource_instances: (multiple allowed) Contains information about the resources that constrain the properties within the data center. You can have multiple `resource_instance` entries. Requires these arguments:
-        :param pulumi.Input[str] type: Indicates the kind of `load_object` format used to determine the load on the resource.
-        :param pulumi.Input[int] upper_bound: An optional sanity check that specifies the maximum allowed value for any component of the load object.
-        :param pulumi.Input[bool] wait_on_complete: A boolean indicating whether to wait for transaction to complete. Set to `true` by default.
+        The user's street address
         """
-        if aggregation_type is not None:
-            pulumi.set(__self__, "aggregation_type", aggregation_type)
-        if constrained_property is not None:
-            pulumi.set(__self__, "constrained_property", constrained_property)
-        if decay_rate is not None:
-            pulumi.set(__self__, "decay_rate", decay_rate)
-        if description is not None:
-            pulumi.set(__self__, "description", description)
-        if domain is not None:
-            pulumi.set(__self__, "domain", domain)
-        if host_header is not None:
-            pulumi.set(__self__, "host_header", host_header)
-        if leader_string is not None:
-            pulumi.set(__self__, "leader_string", leader_string)
-        if least_squares_decay is not None:
-            pulumi.set(__self__, "least_squares_decay", least_squares_decay)
-        if load_imbalance_percentage is not None:
-            pulumi.set(__self__, "load_imbalance_percentage", load_imbalance_percentage)
-        if max_u_multiplicative_increment is not None:
-            pulumi.set(__self__, "max_u_multiplicative_increment", max_u_multiplicative_increment)
-        if name is not None:
-            pulumi.set(__self__, "name", name)
-        if resource_instances is not None:
-            pulumi.set(__self__, "resource_instances", resource_instances)
-        if type is not None:
-            pulumi.set(__self__, "type", type)
-        if upper_bound is not None:
-            pulumi.set(__self__, "upper_bound", upper_bound)
-        if wait_on_complete is not None:
-            pulumi.set(__self__, "wait_on_complete", wait_on_complete)
+        return pulumi.get(self, "address")
+
+    @address.setter
+    def address(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "address", value)
 
     @property
-    @pulumi.getter(name="aggregationType")
-    def aggregation_type(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="authGrantsJson")
+    def auth_grants_json(self) -> Optional[pulumi.Input[str]]:
         """
-        Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.
+        A user's per-group role assignments, in JSON form
         """
-        return pulumi.get(self, "aggregation_type")
+        return pulumi.get(self, "auth_grants_json")
 
-    @aggregation_type.setter
-    def aggregation_type(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "aggregation_type", value)
+    @auth_grants_json.setter
+    def auth_grants_json(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "auth_grants_json", value)
 
     @property
-    @pulumi.getter(name="constrainedProperty")
-    def constrained_property(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter
+    def city(self) -> Optional[pulumi.Input[str]]:
         """
-        Specifies the name of the property that this resource constrains, enter `**` to constrain all properties.
+        The user's city
         """
-        return pulumi.get(self, "constrained_property")
+        return pulumi.get(self, "city")
 
-    @constrained_property.setter
-    def constrained_property(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "constrained_property", value)
+    @city.setter
+    def city(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "city", value)
 
     @property
-    @pulumi.getter(name="decayRate")
-    def decay_rate(self) -> Optional[pulumi.Input[float]]:
+    @pulumi.getter(name="contactType")
+    def contact_type(self) -> Optional[pulumi.Input[str]]:
         """
-        For Akamai internal use only. You can omit the value or set it to `null`.
+        To help characterize the user, the value can be any that are available from the view-contact-types operation
         """
-        return pulumi.get(self, "decay_rate")
+        return pulumi.get(self, "contact_type")
 
-    @decay_rate.setter
-    def decay_rate(self, value: Optional[pulumi.Input[float]]):
-        pulumi.set(self, "decay_rate", value)
+    @contact_type.setter
+    def contact_type(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "contact_type", value)
 
     @property
     @pulumi.getter
-    def description(self) -> Optional[pulumi.Input[str]]:
+    def country(self) -> Optional[pulumi.Input[str]]:
         """
-        A descriptive note to help you track what the resource constrains.
+        As part of the user's location, the value can be any that are available from the view-supported-countries operation
         """
-        return pulumi.get(self, "description")
+        return pulumi.get(self, "country")
 
-    @description.setter
-    def description(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "description", value)
+    @country.setter
+    def country(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "country", value)
 
     @property
     @pulumi.getter
-    def domain(self) -> Optional[pulumi.Input[str]]:
+    def email(self) -> Optional[pulumi.Input[str]]:
+        """
+        The user's email address
+        """
+        return pulumi.get(self, "email")
+
+    @email.setter
+    def email(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "email", value)
+
+    @property
+    @pulumi.getter(name="emailUpdatePending")
+    def email_update_pending(self) -> Optional[pulumi.Input[bool]]:
         """
-        DNS name for the GTM Domain set that includes this property.
+        Indicates whether email update is pending
         """
-        return pulumi.get(self, "domain")
+        return pulumi.get(self, "email_update_pending")
 
-    @domain.setter
-    def domain(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "domain", value)
+    @email_update_pending.setter
+    def email_update_pending(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "email_update_pending", value)
 
     @property
-    @pulumi.getter(name="hostHeader")
-    def host_header(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="enableTfa")
+    def enable_tfa(self) -> Optional[pulumi.Input[bool]]:
         """
-        Optionally specifies the host header used when fetching the load object.
+        Indicates whether two-factor authentication is allowed
         """
-        return pulumi.get(self, "host_header")
+        return pulumi.get(self, "enable_tfa")
 
-    @host_header.setter
-    def host_header(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "host_header", value)
+    @enable_tfa.setter
+    def enable_tfa(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "enable_tfa", value)
 
     @property
-    @pulumi.getter(name="leaderString")
-    def leader_string(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="firstName")
+    def first_name(self) -> Optional[pulumi.Input[str]]:
         """
-        Specifies the text that comes before the `load_object`.
+        The user's first name
         """
-        return pulumi.get(self, "leader_string")
+        return pulumi.get(self, "first_name")
 
-    @leader_string.setter
-    def leader_string(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "leader_string", value)
+    @first_name.setter
+    def first_name(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "first_name", value)
 
     @property
-    @pulumi.getter(name="leastSquaresDecay")
-    def least_squares_decay(self) -> Optional[pulumi.Input[float]]:
+    @pulumi.getter(name="isLocked")
+    def is_locked(self) -> Optional[pulumi.Input[bool]]:
         """
-        For internal use only. Unless Akamai indicates otherwise, omit the value or set it to null.
+        The user's lock status
         """
-        return pulumi.get(self, "least_squares_decay")
+        return pulumi.get(self, "is_locked")
 
-    @least_squares_decay.setter
-    def least_squares_decay(self, value: Optional[pulumi.Input[float]]):
-        pulumi.set(self, "least_squares_decay", value)
+    @is_locked.setter
+    def is_locked(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "is_locked", value)
 
     @property
-    @pulumi.getter(name="loadImbalancePercentage")
-    def load_imbalance_percentage(self) -> Optional[pulumi.Input[float]]:
-        return pulumi.get(self, "load_imbalance_percentage")
+    @pulumi.getter(name="jobTitle")
+    def job_title(self) -> Optional[pulumi.Input[str]]:
+        """
+        The user's position at your company
+        """
+        return pulumi.get(self, "job_title")
 
-    @load_imbalance_percentage.setter
-    def load_imbalance_percentage(self, value: Optional[pulumi.Input[float]]):
-        pulumi.set(self, "load_imbalance_percentage", value)
+    @job_title.setter
+    def job_title(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "job_title", value)
 
     @property
-    @pulumi.getter(name="maxUMultiplicativeIncrement")
-    def max_u_multiplicative_increment(self) -> Optional[pulumi.Input[float]]:
+    @pulumi.getter(name="lastLogin")
+    def last_login(self) -> Optional[pulumi.Input[str]]:
         """
-        For Akamai internal use only. You can omit the value or set it to `null`.
+        ISO 8601 timestamp indicating when the user last logged in
         """
-        return pulumi.get(self, "max_u_multiplicative_increment")
+        return pulumi.get(self, "last_login")
 
-    @max_u_multiplicative_increment.setter
-    def max_u_multiplicative_increment(self, value: Optional[pulumi.Input[float]]):
-        pulumi.set(self, "max_u_multiplicative_increment", value)
+    @last_login.setter
+    def last_login(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "last_login", value)
+
+    @property
+    @pulumi.getter(name="lastName")
+    def last_name(self) -> Optional[pulumi.Input[str]]:
+        """
+        The user's surname
+        """
+        return pulumi.get(self, "last_name")
+
+    @last_name.setter
+    def last_name(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "last_name", value)
 
     @property
     @pulumi.getter
-    def name(self) -> Optional[pulumi.Input[str]]:
+    def lock(self) -> Optional[pulumi.Input[bool]]:
         """
-        A descriptive label for the GTM resource.
+        Flag to block a user account
         """
-        return pulumi.get(self, "name")
+        return pulumi.get(self, "lock")
 
-    @name.setter
-    def name(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "name", value)
+    @lock.setter
+    def lock(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "lock", value)
 
     @property
-    @pulumi.getter(name="resourceInstances")
-    def resource_instances(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmResourceResourceInstanceArgs']]]]:
+    @pulumi.getter(name="mobilePhone")
+    def mobile_phone(self) -> Optional[pulumi.Input[str]]:
         """
-        (multiple allowed) Contains information about the resources that constrain the properties within the data center. You can have multiple `resource_instance` entries. Requires these arguments:
+        The user's mobile phone number
         """
-        return pulumi.get(self, "resource_instances")
+        return pulumi.get(self, "mobile_phone")
 
-    @resource_instances.setter
-    def resource_instances(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmResourceResourceInstanceArgs']]]]):
-        pulumi.set(self, "resource_instances", value)
+    @mobile_phone.setter
+    def mobile_phone(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "mobile_phone", value)
+
+    @property
+    @pulumi.getter(name="passwordExpiredAfter")
+    def password_expired_after(self) -> Optional[pulumi.Input[str]]:
+        """
+        The date a user's password expires
+        """
+        return pulumi.get(self, "password_expired_after")
+
+    @password_expired_after.setter
+    def password_expired_after(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "password_expired_after", value)
 
     @property
     @pulumi.getter
-    def type(self) -> Optional[pulumi.Input[str]]:
+    def phone(self) -> Optional[pulumi.Input[str]]:
         """
-        Indicates the kind of `load_object` format used to determine the load on the resource.
+        The user's main phone number
         """
-        return pulumi.get(self, "type")
+        return pulumi.get(self, "phone")
 
-    @type.setter
-    def type(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "type", value)
+    @phone.setter
+    def phone(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "phone", value)
 
     @property
-    @pulumi.getter(name="upperBound")
-    def upper_bound(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="preferredLanguage")
+    def preferred_language(self) -> Optional[pulumi.Input[str]]:
         """
-        An optional sanity check that specifies the maximum allowed value for any component of the load object.
+        The value can be any that are available from the view-languages operation
         """
-        return pulumi.get(self, "upper_bound")
+        return pulumi.get(self, "preferred_language")
 
-    @upper_bound.setter
-    def upper_bound(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "upper_bound", value)
+    @preferred_language.setter
+    def preferred_language(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "preferred_language", value)
 
     @property
-    @pulumi.getter(name="waitOnComplete")
-    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
+    @pulumi.getter(name="secondaryEmail")
+    def secondary_email(self) -> Optional[pulumi.Input[str]]:
         """
-        A boolean indicating whether to wait for transaction to complete. Set to `true` by default.
+        The user's secondary email address
         """
-        return pulumi.get(self, "wait_on_complete")
+        return pulumi.get(self, "secondary_email")
 
-    @wait_on_complete.setter
-    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "wait_on_complete", value)
+    @secondary_email.setter
+    def secondary_email(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "secondary_email", value)
 
+    @property
+    @pulumi.getter(name="sessionTimeout")
+    def session_timeout(self) -> Optional[pulumi.Input[int]]:
+        """
+        The number of seconds it takes for the user's Control Center session to time out if there hasn't been any activity
+        """
+        return pulumi.get(self, "session_timeout")
 
-class GtmResource(pulumi.CustomResource):
-    @overload
-    def __init__(__self__,
-                 resource_name: str,
-                 opts: Optional[pulumi.ResourceOptions] = None,
-                 aggregation_type: Optional[pulumi.Input[str]] = None,
-                 constrained_property: Optional[pulumi.Input[str]] = None,
-                 decay_rate: Optional[pulumi.Input[float]] = None,
-                 description: Optional[pulumi.Input[str]] = None,
-                 domain: Optional[pulumi.Input[str]] = None,
-                 host_header: Optional[pulumi.Input[str]] = None,
-                 leader_string: Optional[pulumi.Input[str]] = None,
-                 least_squares_decay: Optional[pulumi.Input[float]] = None,
-                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
-                 max_u_multiplicative_increment: Optional[pulumi.Input[float]] = None,
-                 name: Optional[pulumi.Input[str]] = None,
-                 resource_instances: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmResourceResourceInstanceArgs']]]]] = None,
-                 type: Optional[pulumi.Input[str]] = None,
-                 upper_bound: Optional[pulumi.Input[int]] = None,
-                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
-                 __props__=None):
+    @session_timeout.setter
+    def session_timeout(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "session_timeout", value)
+
+    @property
+    @pulumi.getter
+    def state(self) -> Optional[pulumi.Input[str]]:
+        """
+        The user's state
+        """
+        return pulumi.get(self, "state")
+
+    @state.setter
+    def state(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "state", value)
+
+    @property
+    @pulumi.getter(name="tfaConfigured")
+    def tfa_configured(self) -> Optional[pulumi.Input[bool]]:
+        """
+        Indicates whether two-factor authentication is configured
+        """
+        return pulumi.get(self, "tfa_configured")
+
+    @tfa_configured.setter
+    def tfa_configured(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "tfa_configured", value)
+
+    @property
+    @pulumi.getter(name="timeZone")
+    def time_zone(self) -> Optional[pulumi.Input[str]]:
+        """
+        The user's time zone. The value can be any that are available from the view-time-zones operation
         """
-        The `GtmResource` lets you create, configure, and import a GTM resource. In GTM, a resource is anything you can measure whose scarcity affects load balancing. Examples of resources include bandwidth, CPU load average, database queries per second, or disk operations per second.
+        return pulumi.get(self, "time_zone")
 
-        > **Note** Import requires an ID with this format: `existing_domain_name`:
-        `existing_resource_name`.
+    @time_zone.setter
+    def time_zone(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "time_zone", value)
 
-        ## Example Usage
+    @property
+    @pulumi.getter(name="userName")
+    def user_name(self) -> Optional[pulumi.Input[str]]:
+        """
+        A user's `loginId`. Typically, a user's email address
+        """
+        return pulumi.get(self, "user_name")
 
-        Basic usage:
+    @user_name.setter
+    def user_name(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "user_name", value)
+
+    @property
+    @pulumi.getter(name="zipCode")
+    def zip_code(self) -> Optional[pulumi.Input[str]]:
+        """
+        The user's five-digit ZIP code
+        """
+        return pulumi.get(self, "zip_code")
 
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
+    @zip_code.setter
+    def zip_code(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "zip_code", value)
 
-        demo_resource = akamai.GtmResource("demoResource",
-            aggregation_type="latest",
-            domain="demo_domain.akadns.net",
-            type="XML load object via HTTP")
-        ```
 
+class IamUser(pulumi.CustomResource):
+    @overload
+    def __init__(__self__,
+                 resource_name: str,
+                 opts: Optional[pulumi.ResourceOptions] = None,
+                 address: Optional[pulumi.Input[str]] = None,
+                 auth_grants_json: Optional[pulumi.Input[str]] = None,
+                 city: Optional[pulumi.Input[str]] = None,
+                 contact_type: Optional[pulumi.Input[str]] = None,
+                 country: Optional[pulumi.Input[str]] = None,
+                 email: Optional[pulumi.Input[str]] = None,
+                 enable_tfa: Optional[pulumi.Input[bool]] = None,
+                 first_name: Optional[pulumi.Input[str]] = None,
+                 job_title: Optional[pulumi.Input[str]] = None,
+                 last_name: Optional[pulumi.Input[str]] = None,
+                 lock: Optional[pulumi.Input[bool]] = None,
+                 mobile_phone: Optional[pulumi.Input[str]] = None,
+                 phone: Optional[pulumi.Input[str]] = None,
+                 preferred_language: Optional[pulumi.Input[str]] = None,
+                 secondary_email: Optional[pulumi.Input[str]] = None,
+                 session_timeout: Optional[pulumi.Input[int]] = None,
+                 state: Optional[pulumi.Input[str]] = None,
+                 time_zone: Optional[pulumi.Input[str]] = None,
+                 zip_code: Optional[pulumi.Input[str]] = None,
+                 __props__=None):
+        """
+        Create a IamUser resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] aggregation_type: Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.
-        :param pulumi.Input[str] constrained_property: Specifies the name of the property that this resource constrains, enter `**` to constrain all properties.
-        :param pulumi.Input[float] decay_rate: For Akamai internal use only. You can omit the value or set it to `null`.
-        :param pulumi.Input[str] description: A descriptive note to help you track what the resource constrains.
-        :param pulumi.Input[str] domain: DNS name for the GTM Domain set that includes this property.
-        :param pulumi.Input[str] host_header: Optionally specifies the host header used when fetching the load object.
-        :param pulumi.Input[str] leader_string: Specifies the text that comes before the `load_object`.
-        :param pulumi.Input[float] least_squares_decay: For internal use only. Unless Akamai indicates otherwise, omit the value or set it to null.
-        :param pulumi.Input[float] max_u_multiplicative_increment: For Akamai internal use only. You can omit the value or set it to `null`.
-        :param pulumi.Input[str] name: A descriptive label for the GTM resource.
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmResourceResourceInstanceArgs']]]] resource_instances: (multiple allowed) Contains information about the resources that constrain the properties within the data center. You can have multiple `resource_instance` entries. Requires these arguments:
-        :param pulumi.Input[str] type: Indicates the kind of `load_object` format used to determine the load on the resource.
-        :param pulumi.Input[int] upper_bound: An optional sanity check that specifies the maximum allowed value for any component of the load object.
-        :param pulumi.Input[bool] wait_on_complete: A boolean indicating whether to wait for transaction to complete. Set to `true` by default.
+        :param pulumi.Input[str] address: The user's street address
+        :param pulumi.Input[str] auth_grants_json: A user's per-group role assignments, in JSON form
+        :param pulumi.Input[str] city: The user's city
+        :param pulumi.Input[str] contact_type: To help characterize the user, the value can be any that are available from the view-contact-types operation
+        :param pulumi.Input[str] country: As part of the user's location, the value can be any that are available from the view-supported-countries operation
+        :param pulumi.Input[str] email: The user's email address
+        :param pulumi.Input[bool] enable_tfa: Indicates whether two-factor authentication is allowed
+        :param pulumi.Input[str] first_name: The user's first name
+        :param pulumi.Input[str] job_title: The user's position at your company
+        :param pulumi.Input[str] last_name: The user's surname
+        :param pulumi.Input[bool] lock: Flag to block a user account
+        :param pulumi.Input[str] mobile_phone: The user's mobile phone number
+        :param pulumi.Input[str] phone: The user's main phone number
+        :param pulumi.Input[str] preferred_language: The value can be any that are available from the view-languages operation
+        :param pulumi.Input[str] secondary_email: The user's secondary email address
+        :param pulumi.Input[int] session_timeout: The number of seconds it takes for the user's Control Center session to time out if there hasn't been any activity
+        :param pulumi.Input[str] state: The user's state
+        :param pulumi.Input[str] time_zone: The user's time zone. The value can be any that are available from the view-time-zones operation
+        :param pulumi.Input[str] zip_code: The user's five-digit ZIP code
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: GtmResourceArgs,
+                 args: IamUserArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        The `GtmResource` lets you create, configure, and import a GTM resource. In GTM, a resource is anything you can measure whose scarcity affects load balancing. Examples of resources include bandwidth, CPU load average, database queries per second, or disk operations per second.
-
-        > **Note** Import requires an ID with this format: `existing_domain_name`:
-        `existing_resource_name`.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        demo_resource = akamai.GtmResource("demoResource",
-            aggregation_type="latest",
-            domain="demo_domain.akadns.net",
-            type="XML load object via HTTP")
-        ```
-
+        Create a IamUser resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param GtmResourceArgs args: The arguments to use to populate this resource's properties.
+        :param IamUserArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(GtmResourceArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(IamUserArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 aggregation_type: Optional[pulumi.Input[str]] = None,
-                 constrained_property: Optional[pulumi.Input[str]] = None,
-                 decay_rate: Optional[pulumi.Input[float]] = None,
-                 description: Optional[pulumi.Input[str]] = None,
-                 domain: Optional[pulumi.Input[str]] = None,
-                 host_header: Optional[pulumi.Input[str]] = None,
-                 leader_string: Optional[pulumi.Input[str]] = None,
-                 least_squares_decay: Optional[pulumi.Input[float]] = None,
-                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
-                 max_u_multiplicative_increment: Optional[pulumi.Input[float]] = None,
-                 name: Optional[pulumi.Input[str]] = None,
-                 resource_instances: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmResourceResourceInstanceArgs']]]]] = None,
-                 type: Optional[pulumi.Input[str]] = None,
-                 upper_bound: Optional[pulumi.Input[int]] = None,
-                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
+                 address: Optional[pulumi.Input[str]] = None,
+                 auth_grants_json: Optional[pulumi.Input[str]] = None,
+                 city: Optional[pulumi.Input[str]] = None,
+                 contact_type: Optional[pulumi.Input[str]] = None,
+                 country: Optional[pulumi.Input[str]] = None,
+                 email: Optional[pulumi.Input[str]] = None,
+                 enable_tfa: Optional[pulumi.Input[bool]] = None,
+                 first_name: Optional[pulumi.Input[str]] = None,
+                 job_title: Optional[pulumi.Input[str]] = None,
+                 last_name: Optional[pulumi.Input[str]] = None,
+                 lock: Optional[pulumi.Input[bool]] = None,
+                 mobile_phone: Optional[pulumi.Input[str]] = None,
+                 phone: Optional[pulumi.Input[str]] = None,
+                 preferred_language: Optional[pulumi.Input[str]] = None,
+                 secondary_email: Optional[pulumi.Input[str]] = None,
+                 session_timeout: Optional[pulumi.Input[int]] = None,
+                 state: Optional[pulumi.Input[str]] = None,
+                 time_zone: Optional[pulumi.Input[str]] = None,
+                 zip_code: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = GtmResourceArgs.__new__(GtmResourceArgs)
+            __props__ = IamUserArgs.__new__(IamUserArgs)
 
-            if aggregation_type is None and not opts.urn:
-                raise TypeError("Missing required property 'aggregation_type'")
-            __props__.__dict__["aggregation_type"] = aggregation_type
-            __props__.__dict__["constrained_property"] = constrained_property
-            __props__.__dict__["decay_rate"] = decay_rate
-            __props__.__dict__["description"] = description
-            if domain is None and not opts.urn:
-                raise TypeError("Missing required property 'domain'")
-            __props__.__dict__["domain"] = domain
-            __props__.__dict__["host_header"] = host_header
-            __props__.__dict__["leader_string"] = leader_string
-            __props__.__dict__["least_squares_decay"] = least_squares_decay
-            __props__.__dict__["load_imbalance_percentage"] = load_imbalance_percentage
-            __props__.__dict__["max_u_multiplicative_increment"] = max_u_multiplicative_increment
-            __props__.__dict__["name"] = name
-            __props__.__dict__["resource_instances"] = resource_instances
-            if type is None and not opts.urn:
-                raise TypeError("Missing required property 'type'")
-            __props__.__dict__["type"] = type
-            __props__.__dict__["upper_bound"] = upper_bound
-            __props__.__dict__["wait_on_complete"] = wait_on_complete
-        alias_opts = pulumi.ResourceOptions(aliases=[pulumi.Alias(type_="akamai:trafficmanagement/gtmResource:GtmResource")])
-        opts = pulumi.ResourceOptions.merge(opts, alias_opts)
-        super(GtmResource, __self__).__init__(
-            'akamai:index/gtmResource:GtmResource',
+            __props__.__dict__["address"] = address
+            if auth_grants_json is None and not opts.urn:
+                raise TypeError("Missing required property 'auth_grants_json'")
+            __props__.__dict__["auth_grants_json"] = auth_grants_json
+            __props__.__dict__["city"] = city
+            __props__.__dict__["contact_type"] = contact_type
+            if country is None and not opts.urn:
+                raise TypeError("Missing required property 'country'")
+            __props__.__dict__["country"] = country
+            if email is None and not opts.urn:
+                raise TypeError("Missing required property 'email'")
+            __props__.__dict__["email"] = email
+            if enable_tfa is None and not opts.urn:
+                raise TypeError("Missing required property 'enable_tfa'")
+            __props__.__dict__["enable_tfa"] = enable_tfa
+            if first_name is None and not opts.urn:
+                raise TypeError("Missing required property 'first_name'")
+            __props__.__dict__["first_name"] = first_name
+            __props__.__dict__["job_title"] = job_title
+            if last_name is None and not opts.urn:
+                raise TypeError("Missing required property 'last_name'")
+            __props__.__dict__["last_name"] = last_name
+            __props__.__dict__["lock"] = lock
+            __props__.__dict__["mobile_phone"] = mobile_phone
+            if phone is None and not opts.urn:
+                raise TypeError("Missing required property 'phone'")
+            __props__.__dict__["phone"] = phone
+            __props__.__dict__["preferred_language"] = preferred_language
+            __props__.__dict__["secondary_email"] = secondary_email
+            __props__.__dict__["session_timeout"] = session_timeout
+            __props__.__dict__["state"] = state
+            __props__.__dict__["time_zone"] = time_zone
+            __props__.__dict__["zip_code"] = zip_code
+            __props__.__dict__["email_update_pending"] = None
+            __props__.__dict__["is_locked"] = None
+            __props__.__dict__["last_login"] = None
+            __props__.__dict__["password_expired_after"] = None
+            __props__.__dict__["tfa_configured"] = None
+            __props__.__dict__["user_name"] = None
+        super(IamUser, __self__).__init__(
+            'akamai:index/iamUser:IamUser',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
-            aggregation_type: Optional[pulumi.Input[str]] = None,
-            constrained_property: Optional[pulumi.Input[str]] = None,
-            decay_rate: Optional[pulumi.Input[float]] = None,
-            description: Optional[pulumi.Input[str]] = None,
-            domain: Optional[pulumi.Input[str]] = None,
-            host_header: Optional[pulumi.Input[str]] = None,
-            leader_string: Optional[pulumi.Input[str]] = None,
-            least_squares_decay: Optional[pulumi.Input[float]] = None,
-            load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
-            max_u_multiplicative_increment: Optional[pulumi.Input[float]] = None,
-            name: Optional[pulumi.Input[str]] = None,
-            resource_instances: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmResourceResourceInstanceArgs']]]]] = None,
-            type: Optional[pulumi.Input[str]] = None,
-            upper_bound: Optional[pulumi.Input[int]] = None,
-            wait_on_complete: Optional[pulumi.Input[bool]] = None) -> 'GtmResource':
+            address: Optional[pulumi.Input[str]] = None,
+            auth_grants_json: Optional[pulumi.Input[str]] = None,
+            city: Optional[pulumi.Input[str]] = None,
+            contact_type: Optional[pulumi.Input[str]] = None,
+            country: Optional[pulumi.Input[str]] = None,
+            email: Optional[pulumi.Input[str]] = None,
+            email_update_pending: Optional[pulumi.Input[bool]] = None,
+            enable_tfa: Optional[pulumi.Input[bool]] = None,
+            first_name: Optional[pulumi.Input[str]] = None,
+            is_locked: Optional[pulumi.Input[bool]] = None,
+            job_title: Optional[pulumi.Input[str]] = None,
+            last_login: Optional[pulumi.Input[str]] = None,
+            last_name: Optional[pulumi.Input[str]] = None,
+            lock: Optional[pulumi.Input[bool]] = None,
+            mobile_phone: Optional[pulumi.Input[str]] = None,
+            password_expired_after: Optional[pulumi.Input[str]] = None,
+            phone: Optional[pulumi.Input[str]] = None,
+            preferred_language: Optional[pulumi.Input[str]] = None,
+            secondary_email: Optional[pulumi.Input[str]] = None,
+            session_timeout: Optional[pulumi.Input[int]] = None,
+            state: Optional[pulumi.Input[str]] = None,
+            tfa_configured: Optional[pulumi.Input[bool]] = None,
+            time_zone: Optional[pulumi.Input[str]] = None,
+            user_name: Optional[pulumi.Input[str]] = None,
+            zip_code: Optional[pulumi.Input[str]] = None) -> 'IamUser':
         """
-        Get an existing GtmResource resource's state with the given name, id, and optional extra
+        Get an existing IamUser resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] aggregation_type: Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.
-        :param pulumi.Input[str] constrained_property: Specifies the name of the property that this resource constrains, enter `**` to constrain all properties.
-        :param pulumi.Input[float] decay_rate: For Akamai internal use only. You can omit the value or set it to `null`.
-        :param pulumi.Input[str] description: A descriptive note to help you track what the resource constrains.
-        :param pulumi.Input[str] domain: DNS name for the GTM Domain set that includes this property.
-        :param pulumi.Input[str] host_header: Optionally specifies the host header used when fetching the load object.
-        :param pulumi.Input[str] leader_string: Specifies the text that comes before the `load_object`.
-        :param pulumi.Input[float] least_squares_decay: For internal use only. Unless Akamai indicates otherwise, omit the value or set it to null.
-        :param pulumi.Input[float] max_u_multiplicative_increment: For Akamai internal use only. You can omit the value or set it to `null`.
-        :param pulumi.Input[str] name: A descriptive label for the GTM resource.
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmResourceResourceInstanceArgs']]]] resource_instances: (multiple allowed) Contains information about the resources that constrain the properties within the data center. You can have multiple `resource_instance` entries. Requires these arguments:
-        :param pulumi.Input[str] type: Indicates the kind of `load_object` format used to determine the load on the resource.
-        :param pulumi.Input[int] upper_bound: An optional sanity check that specifies the maximum allowed value for any component of the load object.
-        :param pulumi.Input[bool] wait_on_complete: A boolean indicating whether to wait for transaction to complete. Set to `true` by default.
+        :param pulumi.Input[str] address: The user's street address
+        :param pulumi.Input[str] auth_grants_json: A user's per-group role assignments, in JSON form
+        :param pulumi.Input[str] city: The user's city
+        :param pulumi.Input[str] contact_type: To help characterize the user, the value can be any that are available from the view-contact-types operation
+        :param pulumi.Input[str] country: As part of the user's location, the value can be any that are available from the view-supported-countries operation
+        :param pulumi.Input[str] email: The user's email address
+        :param pulumi.Input[bool] email_update_pending: Indicates whether email update is pending
+        :param pulumi.Input[bool] enable_tfa: Indicates whether two-factor authentication is allowed
+        :param pulumi.Input[str] first_name: The user's first name
+        :param pulumi.Input[bool] is_locked: The user's lock status
+        :param pulumi.Input[str] job_title: The user's position at your company
+        :param pulumi.Input[str] last_login: ISO 8601 timestamp indicating when the user last logged in
+        :param pulumi.Input[str] last_name: The user's surname
+        :param pulumi.Input[bool] lock: Flag to block a user account
+        :param pulumi.Input[str] mobile_phone: The user's mobile phone number
+        :param pulumi.Input[str] password_expired_after: The date a user's password expires
+        :param pulumi.Input[str] phone: The user's main phone number
+        :param pulumi.Input[str] preferred_language: The value can be any that are available from the view-languages operation
+        :param pulumi.Input[str] secondary_email: The user's secondary email address
+        :param pulumi.Input[int] session_timeout: The number of seconds it takes for the user's Control Center session to time out if there hasn't been any activity
+        :param pulumi.Input[str] state: The user's state
+        :param pulumi.Input[bool] tfa_configured: Indicates whether two-factor authentication is configured
+        :param pulumi.Input[str] time_zone: The user's time zone. The value can be any that are available from the view-time-zones operation
+        :param pulumi.Input[str] user_name: A user's `loginId`. Typically, a user's email address
+        :param pulumi.Input[str] zip_code: The user's five-digit ZIP code
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _GtmResourceState.__new__(_GtmResourceState)
+        __props__ = _IamUserState.__new__(_IamUserState)
 
-        __props__.__dict__["aggregation_type"] = aggregation_type
-        __props__.__dict__["constrained_property"] = constrained_property
-        __props__.__dict__["decay_rate"] = decay_rate
-        __props__.__dict__["description"] = description
-        __props__.__dict__["domain"] = domain
-        __props__.__dict__["host_header"] = host_header
-        __props__.__dict__["leader_string"] = leader_string
-        __props__.__dict__["least_squares_decay"] = least_squares_decay
-        __props__.__dict__["load_imbalance_percentage"] = load_imbalance_percentage
-        __props__.__dict__["max_u_multiplicative_increment"] = max_u_multiplicative_increment
-        __props__.__dict__["name"] = name
-        __props__.__dict__["resource_instances"] = resource_instances
-        __props__.__dict__["type"] = type
-        __props__.__dict__["upper_bound"] = upper_bound
-        __props__.__dict__["wait_on_complete"] = wait_on_complete
-        return GtmResource(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["address"] = address
+        __props__.__dict__["auth_grants_json"] = auth_grants_json
+        __props__.__dict__["city"] = city
+        __props__.__dict__["contact_type"] = contact_type
+        __props__.__dict__["country"] = country
+        __props__.__dict__["email"] = email
+        __props__.__dict__["email_update_pending"] = email_update_pending
+        __props__.__dict__["enable_tfa"] = enable_tfa
+        __props__.__dict__["first_name"] = first_name
+        __props__.__dict__["is_locked"] = is_locked
+        __props__.__dict__["job_title"] = job_title
+        __props__.__dict__["last_login"] = last_login
+        __props__.__dict__["last_name"] = last_name
+        __props__.__dict__["lock"] = lock
+        __props__.__dict__["mobile_phone"] = mobile_phone
+        __props__.__dict__["password_expired_after"] = password_expired_after
+        __props__.__dict__["phone"] = phone
+        __props__.__dict__["preferred_language"] = preferred_language
+        __props__.__dict__["secondary_email"] = secondary_email
+        __props__.__dict__["session_timeout"] = session_timeout
+        __props__.__dict__["state"] = state
+        __props__.__dict__["tfa_configured"] = tfa_configured
+        __props__.__dict__["time_zone"] = time_zone
+        __props__.__dict__["user_name"] = user_name
+        __props__.__dict__["zip_code"] = zip_code
+        return IamUser(resource_name, opts=opts, __props__=__props__)
+
+    @property
+    @pulumi.getter
+    def address(self) -> pulumi.Output[str]:
+        """
+        The user's street address
+        """
+        return pulumi.get(self, "address")
 
     @property
-    @pulumi.getter(name="aggregationType")
-    def aggregation_type(self) -> pulumi.Output[str]:
+    @pulumi.getter(name="authGrantsJson")
+    def auth_grants_json(self) -> pulumi.Output[str]:
         """
-        Specifies how GTM handles different load numbers when multiple load servers are used for a data center or property.
+        A user's per-group role assignments, in JSON form
         """
-        return pulumi.get(self, "aggregation_type")
+        return pulumi.get(self, "auth_grants_json")
 
     @property
-    @pulumi.getter(name="constrainedProperty")
-    def constrained_property(self) -> pulumi.Output[Optional[str]]:
+    @pulumi.getter
+    def city(self) -> pulumi.Output[Optional[str]]:
         """
-        Specifies the name of the property that this resource constrains, enter `**` to constrain all properties.
+        The user's city
         """
-        return pulumi.get(self, "constrained_property")
+        return pulumi.get(self, "city")
 
     @property
-    @pulumi.getter(name="decayRate")
-    def decay_rate(self) -> pulumi.Output[Optional[float]]:
+    @pulumi.getter(name="contactType")
+    def contact_type(self) -> pulumi.Output[str]:
         """
-        For Akamai internal use only. You can omit the value or set it to `null`.
+        To help characterize the user, the value can be any that are available from the view-contact-types operation
         """
-        return pulumi.get(self, "decay_rate")
+        return pulumi.get(self, "contact_type")
 
     @property
     @pulumi.getter
-    def description(self) -> pulumi.Output[Optional[str]]:
+    def country(self) -> pulumi.Output[str]:
         """
-        A descriptive note to help you track what the resource constrains.
+        As part of the user's location, the value can be any that are available from the view-supported-countries operation
         """
-        return pulumi.get(self, "description")
+        return pulumi.get(self, "country")
 
     @property
     @pulumi.getter
-    def domain(self) -> pulumi.Output[str]:
+    def email(self) -> pulumi.Output[str]:
+        """
+        The user's email address
+        """
+        return pulumi.get(self, "email")
+
+    @property
+    @pulumi.getter(name="emailUpdatePending")
+    def email_update_pending(self) -> pulumi.Output[bool]:
+        """
+        Indicates whether email update is pending
+        """
+        return pulumi.get(self, "email_update_pending")
+
+    @property
+    @pulumi.getter(name="enableTfa")
+    def enable_tfa(self) -> pulumi.Output[bool]:
         """
-        DNS name for the GTM Domain set that includes this property.
+        Indicates whether two-factor authentication is allowed
         """
-        return pulumi.get(self, "domain")
+        return pulumi.get(self, "enable_tfa")
 
     @property
-    @pulumi.getter(name="hostHeader")
-    def host_header(self) -> pulumi.Output[Optional[str]]:
+    @pulumi.getter(name="firstName")
+    def first_name(self) -> pulumi.Output[str]:
         """
-        Optionally specifies the host header used when fetching the load object.
+        The user's first name
         """
-        return pulumi.get(self, "host_header")
+        return pulumi.get(self, "first_name")
 
     @property
-    @pulumi.getter(name="leaderString")
-    def leader_string(self) -> pulumi.Output[Optional[str]]:
+    @pulumi.getter(name="isLocked")
+    def is_locked(self) -> pulumi.Output[bool]:
         """
-        Specifies the text that comes before the `load_object`.
+        The user's lock status
         """
-        return pulumi.get(self, "leader_string")
+        return pulumi.get(self, "is_locked")
 
     @property
-    @pulumi.getter(name="leastSquaresDecay")
-    def least_squares_decay(self) -> pulumi.Output[Optional[float]]:
+    @pulumi.getter(name="jobTitle")
+    def job_title(self) -> pulumi.Output[Optional[str]]:
         """
-        For internal use only. Unless Akamai indicates otherwise, omit the value or set it to null.
+        The user's position at your company
         """
-        return pulumi.get(self, "least_squares_decay")
+        return pulumi.get(self, "job_title")
 
     @property
-    @pulumi.getter(name="loadImbalancePercentage")
-    def load_imbalance_percentage(self) -> pulumi.Output[Optional[float]]:
-        return pulumi.get(self, "load_imbalance_percentage")
+    @pulumi.getter(name="lastLogin")
+    def last_login(self) -> pulumi.Output[str]:
+        """
+        ISO 8601 timestamp indicating when the user last logged in
+        """
+        return pulumi.get(self, "last_login")
 
     @property
-    @pulumi.getter(name="maxUMultiplicativeIncrement")
-    def max_u_multiplicative_increment(self) -> pulumi.Output[Optional[float]]:
+    @pulumi.getter(name="lastName")
+    def last_name(self) -> pulumi.Output[str]:
         """
-        For Akamai internal use only. You can omit the value or set it to `null`.
+        The user's surname
         """
-        return pulumi.get(self, "max_u_multiplicative_increment")
+        return pulumi.get(self, "last_name")
 
     @property
     @pulumi.getter
-    def name(self) -> pulumi.Output[str]:
+    def lock(self) -> pulumi.Output[Optional[bool]]:
         """
-        A descriptive label for the GTM resource.
+        Flag to block a user account
         """
-        return pulumi.get(self, "name")
+        return pulumi.get(self, "lock")
 
     @property
-    @pulumi.getter(name="resourceInstances")
-    def resource_instances(self) -> pulumi.Output[Optional[Sequence['outputs.GtmResourceResourceInstance']]]:
+    @pulumi.getter(name="mobilePhone")
+    def mobile_phone(self) -> pulumi.Output[Optional[str]]:
         """
-        (multiple allowed) Contains information about the resources that constrain the properties within the data center. You can have multiple `resource_instance` entries. Requires these arguments:
+        The user's mobile phone number
         """
-        return pulumi.get(self, "resource_instances")
+        return pulumi.get(self, "mobile_phone")
+
+    @property
+    @pulumi.getter(name="passwordExpiredAfter")
+    def password_expired_after(self) -> pulumi.Output[str]:
+        """
+        The date a user's password expires
+        """
+        return pulumi.get(self, "password_expired_after")
 
     @property
     @pulumi.getter
-    def type(self) -> pulumi.Output[str]:
+    def phone(self) -> pulumi.Output[str]:
+        """
+        The user's main phone number
+        """
+        return pulumi.get(self, "phone")
+
+    @property
+    @pulumi.getter(name="preferredLanguage")
+    def preferred_language(self) -> pulumi.Output[str]:
+        """
+        The value can be any that are available from the view-languages operation
+        """
+        return pulumi.get(self, "preferred_language")
+
+    @property
+    @pulumi.getter(name="secondaryEmail")
+    def secondary_email(self) -> pulumi.Output[Optional[str]]:
+        """
+        The user's secondary email address
+        """
+        return pulumi.get(self, "secondary_email")
+
+    @property
+    @pulumi.getter(name="sessionTimeout")
+    def session_timeout(self) -> pulumi.Output[int]:
+        """
+        The number of seconds it takes for the user's Control Center session to time out if there hasn't been any activity
+        """
+        return pulumi.get(self, "session_timeout")
+
+    @property
+    @pulumi.getter
+    def state(self) -> pulumi.Output[Optional[str]]:
+        """
+        The user's state
+        """
+        return pulumi.get(self, "state")
+
+    @property
+    @pulumi.getter(name="tfaConfigured")
+    def tfa_configured(self) -> pulumi.Output[bool]:
+        """
+        Indicates whether two-factor authentication is configured
+        """
+        return pulumi.get(self, "tfa_configured")
+
+    @property
+    @pulumi.getter(name="timeZone")
+    def time_zone(self) -> pulumi.Output[str]:
         """
-        Indicates the kind of `load_object` format used to determine the load on the resource.
+        The user's time zone. The value can be any that are available from the view-time-zones operation
         """
-        return pulumi.get(self, "type")
+        return pulumi.get(self, "time_zone")
 
     @property
-    @pulumi.getter(name="upperBound")
-    def upper_bound(self) -> pulumi.Output[Optional[int]]:
+    @pulumi.getter(name="userName")
+    def user_name(self) -> pulumi.Output[str]:
         """
-        An optional sanity check that specifies the maximum allowed value for any component of the load object.
+        A user's `loginId`. Typically, a user's email address
         """
-        return pulumi.get(self, "upper_bound")
+        return pulumi.get(self, "user_name")
 
     @property
-    @pulumi.getter(name="waitOnComplete")
-    def wait_on_complete(self) -> pulumi.Output[Optional[bool]]:
+    @pulumi.getter(name="zipCode")
+    def zip_code(self) -> pulumi.Output[Optional[str]]:
         """
-        A boolean indicating whether to wait for transaction to complete. Set to `true` by default.
+        The user's five-digit ZIP code
         """
-        return pulumi.get(self, "wait_on_complete")
+        return pulumi.get(self, "zip_code")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/iam_blocked_user_properties.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/gtm_asmap.py`

 * *Files 23% similar despite different names*

```diff
@@ -4,287 +4,269 @@
 
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
+from . import outputs
+from ._inputs import *
 
-__all__ = ['IamBlockedUserPropertiesArgs', 'IamBlockedUserProperties']
+__all__ = ['GtmAsmapArgs', 'GtmAsmap']
 
 @pulumi.input_type
-class IamBlockedUserPropertiesArgs:
+class GtmAsmapArgs:
     def __init__(__self__, *,
-                 blocked_properties: pulumi.Input[Sequence[pulumi.Input[int]]],
-                 group_id: pulumi.Input[int],
-                 identity_id: pulumi.Input[str]):
-        """
-        The set of arguments for constructing a IamBlockedUserProperties resource.
-        :param pulumi.Input[Sequence[pulumi.Input[int]]] blocked_properties: List of properties to block for a user. The property IDs must be an integer.
-        :param pulumi.Input[int] group_id: A unique identifier for a group. Each identifier must be an integer.
-        :param pulumi.Input[str] identity_id: A unique identifier that corresponds to a user's actual profile or client ID. Each identifier must be a string.
-        """
-        pulumi.set(__self__, "blocked_properties", blocked_properties)
-        pulumi.set(__self__, "group_id", group_id)
-        pulumi.set(__self__, "identity_id", identity_id)
+                 default_datacenter: pulumi.Input['GtmAsmapDefaultDatacenterArgs'],
+                 domain: pulumi.Input[str],
+                 assignments: Optional[pulumi.Input[Sequence[pulumi.Input['GtmAsmapAssignmentArgs']]]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None):
+        """
+        The set of arguments for constructing a GtmAsmap resource.
+        """
+        pulumi.set(__self__, "default_datacenter", default_datacenter)
+        pulumi.set(__self__, "domain", domain)
+        if assignments is not None:
+            pulumi.set(__self__, "assignments", assignments)
+        if name is not None:
+            pulumi.set(__self__, "name", name)
+        if wait_on_complete is not None:
+            pulumi.set(__self__, "wait_on_complete", wait_on_complete)
 
     @property
-    @pulumi.getter(name="blockedProperties")
-    def blocked_properties(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
-        """
-        List of properties to block for a user. The property IDs must be an integer.
-        """
-        return pulumi.get(self, "blocked_properties")
-
-    @blocked_properties.setter
-    def blocked_properties(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
-        pulumi.set(self, "blocked_properties", value)
+    @pulumi.getter(name="defaultDatacenter")
+    def default_datacenter(self) -> pulumi.Input['GtmAsmapDefaultDatacenterArgs']:
+        return pulumi.get(self, "default_datacenter")
+
+    @default_datacenter.setter
+    def default_datacenter(self, value: pulumi.Input['GtmAsmapDefaultDatacenterArgs']):
+        pulumi.set(self, "default_datacenter", value)
 
     @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> pulumi.Input[int]:
-        """
-        A unique identifier for a group. Each identifier must be an integer.
-        """
-        return pulumi.get(self, "group_id")
+    @pulumi.getter
+    def domain(self) -> pulumi.Input[str]:
+        return pulumi.get(self, "domain")
+
+    @domain.setter
+    def domain(self, value: pulumi.Input[str]):
+        pulumi.set(self, "domain", value)
 
-    @group_id.setter
-    def group_id(self, value: pulumi.Input[int]):
-        pulumi.set(self, "group_id", value)
+    @property
+    @pulumi.getter
+    def assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmAsmapAssignmentArgs']]]]:
+        return pulumi.get(self, "assignments")
+
+    @assignments.setter
+    def assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmAsmapAssignmentArgs']]]]):
+        pulumi.set(self, "assignments", value)
 
     @property
-    @pulumi.getter(name="identityId")
-    def identity_id(self) -> pulumi.Input[str]:
-        """
-        A unique identifier that corresponds to a user's actual profile or client ID. Each identifier must be a string.
-        """
-        return pulumi.get(self, "identity_id")
+    @pulumi.getter
+    def name(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "name")
+
+    @name.setter
+    def name(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "name", value)
 
-    @identity_id.setter
-    def identity_id(self, value: pulumi.Input[str]):
-        pulumi.set(self, "identity_id", value)
+    @property
+    @pulumi.getter(name="waitOnComplete")
+    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "wait_on_complete")
+
+    @wait_on_complete.setter
+    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "wait_on_complete", value)
 
 
 @pulumi.input_type
-class _IamBlockedUserPropertiesState:
+class _GtmAsmapState:
     def __init__(__self__, *,
-                 blocked_properties: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
-                 group_id: Optional[pulumi.Input[int]] = None,
-                 identity_id: Optional[pulumi.Input[str]] = None):
-        """
-        Input properties used for looking up and filtering IamBlockedUserProperties resources.
-        :param pulumi.Input[Sequence[pulumi.Input[int]]] blocked_properties: List of properties to block for a user. The property IDs must be an integer.
-        :param pulumi.Input[int] group_id: A unique identifier for a group. Each identifier must be an integer.
-        :param pulumi.Input[str] identity_id: A unique identifier that corresponds to a user's actual profile or client ID. Each identifier must be a string.
-        """
-        if blocked_properties is not None:
-            pulumi.set(__self__, "blocked_properties", blocked_properties)
-        if group_id is not None:
-            pulumi.set(__self__, "group_id", group_id)
-        if identity_id is not None:
-            pulumi.set(__self__, "identity_id", identity_id)
+                 assignments: Optional[pulumi.Input[Sequence[pulumi.Input['GtmAsmapAssignmentArgs']]]] = None,
+                 default_datacenter: Optional[pulumi.Input['GtmAsmapDefaultDatacenterArgs']] = None,
+                 domain: Optional[pulumi.Input[str]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None):
+        """
+        Input properties used for looking up and filtering GtmAsmap resources.
+        """
+        if assignments is not None:
+            pulumi.set(__self__, "assignments", assignments)
+        if default_datacenter is not None:
+            pulumi.set(__self__, "default_datacenter", default_datacenter)
+        if domain is not None:
+            pulumi.set(__self__, "domain", domain)
+        if name is not None:
+            pulumi.set(__self__, "name", name)
+        if wait_on_complete is not None:
+            pulumi.set(__self__, "wait_on_complete", wait_on_complete)
 
     @property
-    @pulumi.getter(name="blockedProperties")
-    def blocked_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
-        """
-        List of properties to block for a user. The property IDs must be an integer.
-        """
-        return pulumi.get(self, "blocked_properties")
+    @pulumi.getter
+    def assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmAsmapAssignmentArgs']]]]:
+        return pulumi.get(self, "assignments")
+
+    @assignments.setter
+    def assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmAsmapAssignmentArgs']]]]):
+        pulumi.set(self, "assignments", value)
 
-    @blocked_properties.setter
-    def blocked_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
-        pulumi.set(self, "blocked_properties", value)
+    @property
+    @pulumi.getter(name="defaultDatacenter")
+    def default_datacenter(self) -> Optional[pulumi.Input['GtmAsmapDefaultDatacenterArgs']]:
+        return pulumi.get(self, "default_datacenter")
+
+    @default_datacenter.setter
+    def default_datacenter(self, value: Optional[pulumi.Input['GtmAsmapDefaultDatacenterArgs']]):
+        pulumi.set(self, "default_datacenter", value)
 
     @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> Optional[pulumi.Input[int]]:
-        """
-        A unique identifier for a group. Each identifier must be an integer.
-        """
-        return pulumi.get(self, "group_id")
+    @pulumi.getter
+    def domain(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "domain")
+
+    @domain.setter
+    def domain(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "domain", value)
 
-    @group_id.setter
-    def group_id(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "group_id", value)
+    @property
+    @pulumi.getter
+    def name(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "name")
+
+    @name.setter
+    def name(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "name", value)
 
     @property
-    @pulumi.getter(name="identityId")
-    def identity_id(self) -> Optional[pulumi.Input[str]]:
-        """
-        A unique identifier that corresponds to a user's actual profile or client ID. Each identifier must be a string.
-        """
-        return pulumi.get(self, "identity_id")
+    @pulumi.getter(name="waitOnComplete")
+    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "wait_on_complete")
 
-    @identity_id.setter
-    def identity_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "identity_id", value)
+    @wait_on_complete.setter
+    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "wait_on_complete", value)
 
 
-class IamBlockedUserProperties(pulumi.CustomResource):
+class GtmAsmap(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 blocked_properties: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
-                 group_id: Optional[pulumi.Input[int]] = None,
-                 identity_id: Optional[pulumi.Input[str]] = None,
+                 assignments: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmAsmapAssignmentArgs']]]]] = None,
+                 default_datacenter: Optional[pulumi.Input[pulumi.InputType['GtmAsmapDefaultDatacenterArgs']]] = None,
+                 domain: Optional[pulumi.Input[str]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
                  __props__=None):
         """
-        Use the `IamBlockedUserProperties` resource to remove or grant access to properties. Administrators can block a user's access to any property, overriding any available role already assigned to that user.
-
-        ## Basic usage
-
-        This example returns the policy details based on the policy ID and optionally, a version:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        example = akamai.IamBlockedUserProperties("example",
-            blocked_properties=[
-                1,
-                2,
-                3,
-                4,
-                5,
-            ],
-            group_id=12345,
-            identity_id="A-B-123456")
-        ```
-
-        ## Attributes reference
-
-        This resource doesn't return any attributes.
-
+        Create a GtmAsmap resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[Sequence[pulumi.Input[int]]] blocked_properties: List of properties to block for a user. The property IDs must be an integer.
-        :param pulumi.Input[int] group_id: A unique identifier for a group. Each identifier must be an integer.
-        :param pulumi.Input[str] identity_id: A unique identifier that corresponds to a user's actual profile or client ID. Each identifier must be a string.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: IamBlockedUserPropertiesArgs,
+                 args: GtmAsmapArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        Use the `IamBlockedUserProperties` resource to remove or grant access to properties. Administrators can block a user's access to any property, overriding any available role already assigned to that user.
-
-        ## Basic usage
-
-        This example returns the policy details based on the policy ID and optionally, a version:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        example = akamai.IamBlockedUserProperties("example",
-            blocked_properties=[
-                1,
-                2,
-                3,
-                4,
-                5,
-            ],
-            group_id=12345,
-            identity_id="A-B-123456")
-        ```
-
-        ## Attributes reference
-
-        This resource doesn't return any attributes.
-
+        Create a GtmAsmap resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param IamBlockedUserPropertiesArgs args: The arguments to use to populate this resource's properties.
+        :param GtmAsmapArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(IamBlockedUserPropertiesArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(GtmAsmapArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 blocked_properties: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
-                 group_id: Optional[pulumi.Input[int]] = None,
-                 identity_id: Optional[pulumi.Input[str]] = None,
+                 assignments: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmAsmapAssignmentArgs']]]]] = None,
+                 default_datacenter: Optional[pulumi.Input[pulumi.InputType['GtmAsmapDefaultDatacenterArgs']]] = None,
+                 domain: Optional[pulumi.Input[str]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = IamBlockedUserPropertiesArgs.__new__(IamBlockedUserPropertiesArgs)
+            __props__ = GtmAsmapArgs.__new__(GtmAsmapArgs)
 
-            if blocked_properties is None and not opts.urn:
-                raise TypeError("Missing required property 'blocked_properties'")
-            __props__.__dict__["blocked_properties"] = blocked_properties
-            if group_id is None and not opts.urn:
-                raise TypeError("Missing required property 'group_id'")
-            __props__.__dict__["group_id"] = group_id
-            if identity_id is None and not opts.urn:
-                raise TypeError("Missing required property 'identity_id'")
-            __props__.__dict__["identity_id"] = identity_id
-        super(IamBlockedUserProperties, __self__).__init__(
-            'akamai:index/iamBlockedUserProperties:IamBlockedUserProperties',
+            __props__.__dict__["assignments"] = assignments
+            if default_datacenter is None and not opts.urn:
+                raise TypeError("Missing required property 'default_datacenter'")
+            __props__.__dict__["default_datacenter"] = default_datacenter
+            if domain is None and not opts.urn:
+                raise TypeError("Missing required property 'domain'")
+            __props__.__dict__["domain"] = domain
+            __props__.__dict__["name"] = name
+            __props__.__dict__["wait_on_complete"] = wait_on_complete
+        alias_opts = pulumi.ResourceOptions(aliases=[pulumi.Alias(type_="akamai:trafficmanagement/gtmASmap:GtmASmap")])
+        opts = pulumi.ResourceOptions.merge(opts, alias_opts)
+        super(GtmAsmap, __self__).__init__(
+            'akamai:index/gtmAsmap:GtmAsmap',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
-            blocked_properties: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
-            group_id: Optional[pulumi.Input[int]] = None,
-            identity_id: Optional[pulumi.Input[str]] = None) -> 'IamBlockedUserProperties':
+            assignments: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmAsmapAssignmentArgs']]]]] = None,
+            default_datacenter: Optional[pulumi.Input[pulumi.InputType['GtmAsmapDefaultDatacenterArgs']]] = None,
+            domain: Optional[pulumi.Input[str]] = None,
+            name: Optional[pulumi.Input[str]] = None,
+            wait_on_complete: Optional[pulumi.Input[bool]] = None) -> 'GtmAsmap':
         """
-        Get an existing IamBlockedUserProperties resource's state with the given name, id, and optional extra
+        Get an existing GtmAsmap resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[Sequence[pulumi.Input[int]]] blocked_properties: List of properties to block for a user. The property IDs must be an integer.
-        :param pulumi.Input[int] group_id: A unique identifier for a group. Each identifier must be an integer.
-        :param pulumi.Input[str] identity_id: A unique identifier that corresponds to a user's actual profile or client ID. Each identifier must be a string.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _IamBlockedUserPropertiesState.__new__(_IamBlockedUserPropertiesState)
+        __props__ = _GtmAsmapState.__new__(_GtmAsmapState)
 
-        __props__.__dict__["blocked_properties"] = blocked_properties
-        __props__.__dict__["group_id"] = group_id
-        __props__.__dict__["identity_id"] = identity_id
-        return IamBlockedUserProperties(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["assignments"] = assignments
+        __props__.__dict__["default_datacenter"] = default_datacenter
+        __props__.__dict__["domain"] = domain
+        __props__.__dict__["name"] = name
+        __props__.__dict__["wait_on_complete"] = wait_on_complete
+        return GtmAsmap(resource_name, opts=opts, __props__=__props__)
 
     @property
-    @pulumi.getter(name="blockedProperties")
-    def blocked_properties(self) -> pulumi.Output[Sequence[int]]:
-        """
-        List of properties to block for a user. The property IDs must be an integer.
-        """
-        return pulumi.get(self, "blocked_properties")
+    @pulumi.getter
+    def assignments(self) -> pulumi.Output[Optional[Sequence['outputs.GtmAsmapAssignment']]]:
+        return pulumi.get(self, "assignments")
 
     @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> pulumi.Output[int]:
-        """
-        A unique identifier for a group. Each identifier must be an integer.
-        """
-        return pulumi.get(self, "group_id")
+    @pulumi.getter(name="defaultDatacenter")
+    def default_datacenter(self) -> pulumi.Output['outputs.GtmAsmapDefaultDatacenter']:
+        return pulumi.get(self, "default_datacenter")
 
     @property
-    @pulumi.getter(name="identityId")
-    def identity_id(self) -> pulumi.Output[str]:
-        """
-        A unique identifier that corresponds to a user's actual profile or client ID. Each identifier must be a string.
-        """
-        return pulumi.get(self, "identity_id")
+    @pulumi.getter
+    def domain(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "domain")
+
+    @property
+    @pulumi.getter
+    def name(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "name")
+
+    @property
+    @pulumi.getter(name="waitOnComplete")
+    def wait_on_complete(self) -> pulumi.Output[Optional[bool]]:
+        return pulumi.get(self, "wait_on_complete")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/iam_role.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/cp_code.py`

 * *Files 26% similar despite different names*

```diff
@@ -5,324 +5,359 @@
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 
-__all__ = ['IamRoleArgs', 'IamRole']
+__all__ = ['CpCodeArgs', 'CpCode']
 
 @pulumi.input_type
-class IamRoleArgs:
+class CpCodeArgs:
     def __init__(__self__, *,
-                 description: pulumi.Input[str],
-                 granted_roles: pulumi.Input[Sequence[pulumi.Input[int]]],
+                 contract: Optional[pulumi.Input[str]] = None,
+                 contract_id: Optional[pulumi.Input[str]] = None,
+                 group: Optional[pulumi.Input[str]] = None,
+                 group_id: Optional[pulumi.Input[str]] = None,
                  name: Optional[pulumi.Input[str]] = None,
-                 type: Optional[pulumi.Input[str]] = None):
+                 product: Optional[pulumi.Input[str]] = None,
+                 product_id: Optional[pulumi.Input[str]] = None):
         """
-        The set of arguments for constructing a IamRole resource.
-        :param pulumi.Input[str] description: The description for a role.
-        :param pulumi.Input[Sequence[pulumi.Input[int]]] granted_roles: The list of existing unique identifiers for the granted roles. Each identifier must be a unique integer.
-        :param pulumi.Input[str] name: The name you supply for a role.
-        :param pulumi.Input[str] type: The role type which indicates whether it's a standard role provided by Akamai or a custom role for the account
+        The set of arguments for constructing a CpCode resource.
         """
-        pulumi.set(__self__, "description", description)
-        pulumi.set(__self__, "granted_roles", granted_roles)
+        if contract is not None:
+            warnings.warn("""The setting \"contract\" has been deprecated.""", DeprecationWarning)
+            pulumi.log.warn("""contract is deprecated: The setting \"contract\" has been deprecated.""")
+        if contract is not None:
+            pulumi.set(__self__, "contract", contract)
+        if contract_id is not None:
+            pulumi.set(__self__, "contract_id", contract_id)
+        if group is not None:
+            warnings.warn("""The setting \"group\" has been deprecated.""", DeprecationWarning)
+            pulumi.log.warn("""group is deprecated: The setting \"group\" has been deprecated.""")
+        if group is not None:
+            pulumi.set(__self__, "group", group)
+        if group_id is not None:
+            pulumi.set(__self__, "group_id", group_id)
         if name is not None:
             pulumi.set(__self__, "name", name)
-        if type is not None:
-            pulumi.set(__self__, "type", type)
+        if product is not None:
+            warnings.warn("""The setting \"product\" has been deprecated.""", DeprecationWarning)
+            pulumi.log.warn("""product is deprecated: The setting \"product\" has been deprecated.""")
+        if product is not None:
+            pulumi.set(__self__, "product", product)
+        if product_id is not None:
+            pulumi.set(__self__, "product_id", product_id)
 
     @property
     @pulumi.getter
-    def description(self) -> pulumi.Input[str]:
-        """
-        The description for a role.
-        """
-        return pulumi.get(self, "description")
+    def contract(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "contract")
 
-    @description.setter
-    def description(self, value: pulumi.Input[str]):
-        pulumi.set(self, "description", value)
+    @contract.setter
+    def contract(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "contract", value)
 
     @property
-    @pulumi.getter(name="grantedRoles")
-    def granted_roles(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
-        """
-        The list of existing unique identifiers for the granted roles. Each identifier must be a unique integer.
-        """
-        return pulumi.get(self, "granted_roles")
+    @pulumi.getter(name="contractId")
+    def contract_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "contract_id")
 
-    @granted_roles.setter
-    def granted_roles(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
-        pulumi.set(self, "granted_roles", value)
+    @contract_id.setter
+    def contract_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "contract_id", value)
+
+    @property
+    @pulumi.getter
+    def group(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "group")
+
+    @group.setter
+    def group(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "group", value)
+
+    @property
+    @pulumi.getter(name="groupId")
+    def group_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "group_id")
+
+    @group_id.setter
+    def group_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "group_id", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
-        """
-        The name you supply for a role.
-        """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter
-    def type(self) -> Optional[pulumi.Input[str]]:
-        """
-        The role type which indicates whether it's a standard role provided by Akamai or a custom role for the account
-        """
-        return pulumi.get(self, "type")
+    def product(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "product")
+
+    @product.setter
+    def product(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "product", value)
+
+    @property
+    @pulumi.getter(name="productId")
+    def product_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "product_id")
 
-    @type.setter
-    def type(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "type", value)
+    @product_id.setter
+    def product_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "product_id", value)
 
 
 @pulumi.input_type
-class _IamRoleState:
+class _CpCodeState:
     def __init__(__self__, *,
-                 description: Optional[pulumi.Input[str]] = None,
-                 granted_roles: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
+                 contract: Optional[pulumi.Input[str]] = None,
+                 contract_id: Optional[pulumi.Input[str]] = None,
+                 group: Optional[pulumi.Input[str]] = None,
+                 group_id: Optional[pulumi.Input[str]] = None,
                  name: Optional[pulumi.Input[str]] = None,
-                 type: Optional[pulumi.Input[str]] = None):
+                 product: Optional[pulumi.Input[str]] = None,
+                 product_id: Optional[pulumi.Input[str]] = None):
         """
-        Input properties used for looking up and filtering IamRole resources.
-        :param pulumi.Input[str] description: The description for a role.
-        :param pulumi.Input[Sequence[pulumi.Input[int]]] granted_roles: The list of existing unique identifiers for the granted roles. Each identifier must be a unique integer.
-        :param pulumi.Input[str] name: The name you supply for a role.
-        :param pulumi.Input[str] type: The role type which indicates whether it's a standard role provided by Akamai or a custom role for the account
+        Input properties used for looking up and filtering CpCode resources.
         """
-        if description is not None:
-            pulumi.set(__self__, "description", description)
-        if granted_roles is not None:
-            pulumi.set(__self__, "granted_roles", granted_roles)
+        if contract is not None:
+            warnings.warn("""The setting \"contract\" has been deprecated.""", DeprecationWarning)
+            pulumi.log.warn("""contract is deprecated: The setting \"contract\" has been deprecated.""")
+        if contract is not None:
+            pulumi.set(__self__, "contract", contract)
+        if contract_id is not None:
+            pulumi.set(__self__, "contract_id", contract_id)
+        if group is not None:
+            warnings.warn("""The setting \"group\" has been deprecated.""", DeprecationWarning)
+            pulumi.log.warn("""group is deprecated: The setting \"group\" has been deprecated.""")
+        if group is not None:
+            pulumi.set(__self__, "group", group)
+        if group_id is not None:
+            pulumi.set(__self__, "group_id", group_id)
         if name is not None:
             pulumi.set(__self__, "name", name)
-        if type is not None:
-            pulumi.set(__self__, "type", type)
+        if product is not None:
+            warnings.warn("""The setting \"product\" has been deprecated.""", DeprecationWarning)
+            pulumi.log.warn("""product is deprecated: The setting \"product\" has been deprecated.""")
+        if product is not None:
+            pulumi.set(__self__, "product", product)
+        if product_id is not None:
+            pulumi.set(__self__, "product_id", product_id)
 
     @property
     @pulumi.getter
-    def description(self) -> Optional[pulumi.Input[str]]:
-        """
-        The description for a role.
-        """
-        return pulumi.get(self, "description")
+    def contract(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "contract")
 
-    @description.setter
-    def description(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "description", value)
+    @contract.setter
+    def contract(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "contract", value)
 
     @property
-    @pulumi.getter(name="grantedRoles")
-    def granted_roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
-        """
-        The list of existing unique identifiers for the granted roles. Each identifier must be a unique integer.
-        """
-        return pulumi.get(self, "granted_roles")
+    @pulumi.getter(name="contractId")
+    def contract_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "contract_id")
 
-    @granted_roles.setter
-    def granted_roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
-        pulumi.set(self, "granted_roles", value)
+    @contract_id.setter
+    def contract_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "contract_id", value)
+
+    @property
+    @pulumi.getter
+    def group(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "group")
+
+    @group.setter
+    def group(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "group", value)
+
+    @property
+    @pulumi.getter(name="groupId")
+    def group_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "group_id")
+
+    @group_id.setter
+    def group_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "group_id", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
-        """
-        The name you supply for a role.
-        """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter
-    def type(self) -> Optional[pulumi.Input[str]]:
-        """
-        The role type which indicates whether it's a standard role provided by Akamai or a custom role for the account
-        """
-        return pulumi.get(self, "type")
+    def product(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "product")
 
-    @type.setter
-    def type(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "type", value)
+    @product.setter
+    def product(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "product", value)
 
+    @property
+    @pulumi.getter(name="productId")
+    def product_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "product_id")
 
-class IamRole(pulumi.CustomResource):
+    @product_id.setter
+    def product_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "product_id", value)
+
+
+class CpCode(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 description: Optional[pulumi.Input[str]] = None,
-                 granted_roles: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
+                 contract: Optional[pulumi.Input[str]] = None,
+                 contract_id: Optional[pulumi.Input[str]] = None,
+                 group: Optional[pulumi.Input[str]] = None,
+                 group_id: Optional[pulumi.Input[str]] = None,
                  name: Optional[pulumi.Input[str]] = None,
-                 type: Optional[pulumi.Input[str]] = None,
+                 product: Optional[pulumi.Input[str]] = None,
+                 product_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        Use the `IamRole` resource to list and create roles for users. Roles are lists of permissions that are explicitly tied to both a user and a group. Users need roles to act on objects in a group.
-
-        ## Basic usage
-
-        This example returns information on available roles:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        example = akamai.IamRole("example",
-            description="This role will allow you to view",
-            granted_roles=2051,
-            type="custom")
-        ```
-
-        ## Attributes reference
-
-        This resource returns this attribute:
-
-        * `type` - The type indicates whether the role is `standard`, provided by Akamai, or `custom` for the account.
-
+        Create a CpCode resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] description: The description for a role.
-        :param pulumi.Input[Sequence[pulumi.Input[int]]] granted_roles: The list of existing unique identifiers for the granted roles. Each identifier must be a unique integer.
-        :param pulumi.Input[str] name: The name you supply for a role.
-        :param pulumi.Input[str] type: The role type which indicates whether it's a standard role provided by Akamai or a custom role for the account
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: IamRoleArgs,
+                 args: Optional[CpCodeArgs] = None,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        Use the `IamRole` resource to list and create roles for users. Roles are lists of permissions that are explicitly tied to both a user and a group. Users need roles to act on objects in a group.
-
-        ## Basic usage
-
-        This example returns information on available roles:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        example = akamai.IamRole("example",
-            description="This role will allow you to view",
-            granted_roles=2051,
-            type="custom")
-        ```
-
-        ## Attributes reference
-
-        This resource returns this attribute:
-
-        * `type` - The type indicates whether the role is `standard`, provided by Akamai, or `custom` for the account.
-
+        Create a CpCode resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param IamRoleArgs args: The arguments to use to populate this resource's properties.
+        :param CpCodeArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(IamRoleArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(CpCodeArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 description: Optional[pulumi.Input[str]] = None,
-                 granted_roles: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
+                 contract: Optional[pulumi.Input[str]] = None,
+                 contract_id: Optional[pulumi.Input[str]] = None,
+                 group: Optional[pulumi.Input[str]] = None,
+                 group_id: Optional[pulumi.Input[str]] = None,
                  name: Optional[pulumi.Input[str]] = None,
-                 type: Optional[pulumi.Input[str]] = None,
+                 product: Optional[pulumi.Input[str]] = None,
+                 product_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = IamRoleArgs.__new__(IamRoleArgs)
+            __props__ = CpCodeArgs.__new__(CpCodeArgs)
 
-            if description is None and not opts.urn:
-                raise TypeError("Missing required property 'description'")
-            __props__.__dict__["description"] = description
-            if granted_roles is None and not opts.urn:
-                raise TypeError("Missing required property 'granted_roles'")
-            __props__.__dict__["granted_roles"] = granted_roles
+            if contract is not None and not opts.urn:
+                warnings.warn("""The setting \"contract\" has been deprecated.""", DeprecationWarning)
+                pulumi.log.warn("""contract is deprecated: The setting \"contract\" has been deprecated.""")
+            __props__.__dict__["contract"] = contract
+            __props__.__dict__["contract_id"] = contract_id
+            if group is not None and not opts.urn:
+                warnings.warn("""The setting \"group\" has been deprecated.""", DeprecationWarning)
+                pulumi.log.warn("""group is deprecated: The setting \"group\" has been deprecated.""")
+            __props__.__dict__["group"] = group
+            __props__.__dict__["group_id"] = group_id
             __props__.__dict__["name"] = name
-            __props__.__dict__["type"] = type
-        super(IamRole, __self__).__init__(
-            'akamai:index/iamRole:IamRole',
+            if product is not None and not opts.urn:
+                warnings.warn("""The setting \"product\" has been deprecated.""", DeprecationWarning)
+                pulumi.log.warn("""product is deprecated: The setting \"product\" has been deprecated.""")
+            __props__.__dict__["product"] = product
+            __props__.__dict__["product_id"] = product_id
+        alias_opts = pulumi.ResourceOptions(aliases=[pulumi.Alias(type_="akamai:properties/cpCode:CpCode")])
+        opts = pulumi.ResourceOptions.merge(opts, alias_opts)
+        super(CpCode, __self__).__init__(
+            'akamai:index/cpCode:CpCode',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
-            description: Optional[pulumi.Input[str]] = None,
-            granted_roles: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
+            contract: Optional[pulumi.Input[str]] = None,
+            contract_id: Optional[pulumi.Input[str]] = None,
+            group: Optional[pulumi.Input[str]] = None,
+            group_id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
-            type: Optional[pulumi.Input[str]] = None) -> 'IamRole':
+            product: Optional[pulumi.Input[str]] = None,
+            product_id: Optional[pulumi.Input[str]] = None) -> 'CpCode':
         """
-        Get an existing IamRole resource's state with the given name, id, and optional extra
+        Get an existing CpCode resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] description: The description for a role.
-        :param pulumi.Input[Sequence[pulumi.Input[int]]] granted_roles: The list of existing unique identifiers for the granted roles. Each identifier must be a unique integer.
-        :param pulumi.Input[str] name: The name you supply for a role.
-        :param pulumi.Input[str] type: The role type which indicates whether it's a standard role provided by Akamai or a custom role for the account
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _IamRoleState.__new__(_IamRoleState)
+        __props__ = _CpCodeState.__new__(_CpCodeState)
 
-        __props__.__dict__["description"] = description
-        __props__.__dict__["granted_roles"] = granted_roles
+        __props__.__dict__["contract"] = contract
+        __props__.__dict__["contract_id"] = contract_id
+        __props__.__dict__["group"] = group
+        __props__.__dict__["group_id"] = group_id
         __props__.__dict__["name"] = name
-        __props__.__dict__["type"] = type
-        return IamRole(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["product"] = product
+        __props__.__dict__["product_id"] = product_id
+        return CpCode(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter
-    def description(self) -> pulumi.Output[str]:
-        """
-        The description for a role.
-        """
-        return pulumi.get(self, "description")
+    def contract(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "contract")
 
     @property
-    @pulumi.getter(name="grantedRoles")
-    def granted_roles(self) -> pulumi.Output[Sequence[int]]:
-        """
-        The list of existing unique identifiers for the granted roles. Each identifier must be a unique integer.
-        """
-        return pulumi.get(self, "granted_roles")
+    @pulumi.getter(name="contractId")
+    def contract_id(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "contract_id")
+
+    @property
+    @pulumi.getter
+    def group(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "group")
+
+    @property
+    @pulumi.getter(name="groupId")
+    def group_id(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "group_id")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
-        """
-        The name you supply for a role.
-        """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter
-    def type(self) -> pulumi.Output[str]:
-        """
-        The role type which indicates whether it's a standard role provided by Akamai or a custom role for the account
-        """
-        return pulumi.get(self, "type")
+    def product(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "product")
+
+    @property
+    @pulumi.getter(name="productId")
+    def product_id(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "product_id")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/network_list.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/network_list.py`

 * *Files 19% similar despite different names*

```diff
@@ -19,24 +19,22 @@
                  type: pulumi.Input[str],
                  contract_id: Optional[pulumi.Input[str]] = None,
                  group_id: Optional[pulumi.Input[int]] = None,
                  lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  name: Optional[pulumi.Input[str]] = None):
         """
         The set of arguments for constructing a NetworkList resource.
-        :param pulumi.Input[str] description: The description to be assigned to the network list.
-        :param pulumi.Input[str] mode: A string specifying the interpretation of the `list` parameter. Must be one of the following:
-        :param pulumi.Input[str] type: The type of the network list; must be either "IP" or "GEO".
-        :param pulumi.Input[str] contract_id: The contract ID of the network list. If supplied, group_id must also be supplied. The
-               contract_id value of an existing network list may not be modified.
-        :param pulumi.Input[int] group_id: The group ID of the network list. If supplied, contract_id must also be supplied. The
-               group_id value of an existing network list may not be modified.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] lists: A list of IP addresses or locations to be included in the list, added to an existing list, or
-               removed from an existing list.
-        :param pulumi.Input[str] name: The name to be assigned to the network list.
+        :param pulumi.Input[str] description: A description of the network list
+        :param pulumi.Input[str] mode: A string specifying the interpretation of the `list` parameter. Must be 'APPEND', 'REPLACE', or 'REMOVE'
+        :param pulumi.Input[str] type: The type of the network list; must be either 'IP' or 'GEO'
+        :param pulumi.Input[str] contract_id: contract ID
+        :param pulumi.Input[int] group_id: group ID
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] lists: A list of IP addresses or locations to be included in the list, added to an existing list, or removed from an existing
+               list
+        :param pulumi.Input[str] name: The name to be assigned to the network list
         """
         pulumi.set(__self__, "description", description)
         pulumi.set(__self__, "mode", mode)
         pulumi.set(__self__, "type", type)
         if contract_id is not None:
             pulumi.set(__self__, "contract_id", contract_id)
         if group_id is not None:
@@ -46,90 +44,88 @@
         if name is not None:
             pulumi.set(__self__, "name", name)
 
     @property
     @pulumi.getter
     def description(self) -> pulumi.Input[str]:
         """
-        The description to be assigned to the network list.
+        A description of the network list
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: pulumi.Input[str]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter
     def mode(self) -> pulumi.Input[str]:
         """
-        A string specifying the interpretation of the `list` parameter. Must be one of the following:
+        A string specifying the interpretation of the `list` parameter. Must be 'APPEND', 'REPLACE', or 'REMOVE'
         """
         return pulumi.get(self, "mode")
 
     @mode.setter
     def mode(self, value: pulumi.Input[str]):
         pulumi.set(self, "mode", value)
 
     @property
     @pulumi.getter
     def type(self) -> pulumi.Input[str]:
         """
-        The type of the network list; must be either "IP" or "GEO".
+        The type of the network list; must be either 'IP' or 'GEO'
         """
         return pulumi.get(self, "type")
 
     @type.setter
     def type(self, value: pulumi.Input[str]):
         pulumi.set(self, "type", value)
 
     @property
     @pulumi.getter(name="contractId")
     def contract_id(self) -> Optional[pulumi.Input[str]]:
         """
-        The contract ID of the network list. If supplied, group_id must also be supplied. The
-        contract_id value of an existing network list may not be modified.
+        contract ID
         """
         return pulumi.get(self, "contract_id")
 
     @contract_id.setter
     def contract_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "contract_id", value)
 
     @property
     @pulumi.getter(name="groupId")
     def group_id(self) -> Optional[pulumi.Input[int]]:
         """
-        The group ID of the network list. If supplied, contract_id must also be supplied. The
-        group_id value of an existing network list may not be modified.
+        group ID
         """
         return pulumi.get(self, "group_id")
 
     @group_id.setter
     def group_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "group_id", value)
 
     @property
     @pulumi.getter
     def lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        A list of IP addresses or locations to be included in the list, added to an existing list, or
-        removed from an existing list.
+        A list of IP addresses or locations to be included in the list, added to an existing list, or removed from an existing
+        list
         """
         return pulumi.get(self, "lists")
 
     @lists.setter
     def lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "lists", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        The name to be assigned to the network list.
+        The name to be assigned to the network list
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
@@ -145,27 +141,24 @@
                  name: Optional[pulumi.Input[str]] = None,
                  network_list_id: Optional[pulumi.Input[str]] = None,
                  sync_point: Optional[pulumi.Input[int]] = None,
                  type: Optional[pulumi.Input[str]] = None,
                  uniqueid: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering NetworkList resources.
-        :param pulumi.Input[str] contract_id: The contract ID of the network list. If supplied, group_id must also be supplied. The
-               contract_id value of an existing network list may not be modified.
-        :param pulumi.Input[str] description: The description to be assigned to the network list.
-        :param pulumi.Input[int] group_id: The group ID of the network list. If supplied, contract_id must also be supplied. The
-               group_id value of an existing network list may not be modified.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] lists: A list of IP addresses or locations to be included in the list, added to an existing list, or
-               removed from an existing list.
-        :param pulumi.Input[str] mode: A string specifying the interpretation of the `list` parameter. Must be one of the following:
-        :param pulumi.Input[str] name: The name to be assigned to the network list.
-        :param pulumi.Input[str] network_list_id: The ID of the network list.
-        :param pulumi.Input[int] sync_point: An integer that identifies the current version of the network list; this value is incremented each time
-               the list is modified.
-        :param pulumi.Input[str] type: The type of the network list; must be either "IP" or "GEO".
+        :param pulumi.Input[str] contract_id: contract ID
+        :param pulumi.Input[str] description: A description of the network list
+        :param pulumi.Input[int] group_id: group ID
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] lists: A list of IP addresses or locations to be included in the list, added to an existing list, or removed from an existing
+               list
+        :param pulumi.Input[str] mode: A string specifying the interpretation of the `list` parameter. Must be 'APPEND', 'REPLACE', or 'REMOVE'
+        :param pulumi.Input[str] name: The name to be assigned to the network list
+        :param pulumi.Input[str] network_list_id: network list ID
+        :param pulumi.Input[int] sync_point: sync point
+        :param pulumi.Input[str] type: The type of the network list; must be either 'IP' or 'GEO'
         :param pulumi.Input[str] uniqueid: unique ID
         """
         if contract_id is not None:
             pulumi.set(__self__, "contract_id", contract_id)
         if description is not None:
             pulumi.set(__self__, "description", description)
         if group_id is not None:
@@ -185,115 +178,112 @@
         if uniqueid is not None:
             pulumi.set(__self__, "uniqueid", uniqueid)
 
     @property
     @pulumi.getter(name="contractId")
     def contract_id(self) -> Optional[pulumi.Input[str]]:
         """
-        The contract ID of the network list. If supplied, group_id must also be supplied. The
-        contract_id value of an existing network list may not be modified.
+        contract ID
         """
         return pulumi.get(self, "contract_id")
 
     @contract_id.setter
     def contract_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "contract_id", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        The description to be assigned to the network list.
+        A description of the network list
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter(name="groupId")
     def group_id(self) -> Optional[pulumi.Input[int]]:
         """
-        The group ID of the network list. If supplied, contract_id must also be supplied. The
-        group_id value of an existing network list may not be modified.
+        group ID
         """
         return pulumi.get(self, "group_id")
 
     @group_id.setter
     def group_id(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "group_id", value)
 
     @property
     @pulumi.getter
     def lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        A list of IP addresses or locations to be included in the list, added to an existing list, or
-        removed from an existing list.
+        A list of IP addresses or locations to be included in the list, added to an existing list, or removed from an existing
+        list
         """
         return pulumi.get(self, "lists")
 
     @lists.setter
     def lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "lists", value)
 
     @property
     @pulumi.getter
     def mode(self) -> Optional[pulumi.Input[str]]:
         """
-        A string specifying the interpretation of the `list` parameter. Must be one of the following:
+        A string specifying the interpretation of the `list` parameter. Must be 'APPEND', 'REPLACE', or 'REMOVE'
         """
         return pulumi.get(self, "mode")
 
     @mode.setter
     def mode(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "mode", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        The name to be assigned to the network list.
+        The name to be assigned to the network list
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="networkListId")
     def network_list_id(self) -> Optional[pulumi.Input[str]]:
         """
-        The ID of the network list.
+        network list ID
         """
         return pulumi.get(self, "network_list_id")
 
     @network_list_id.setter
     def network_list_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "network_list_id", value)
 
     @property
     @pulumi.getter(name="syncPoint")
     def sync_point(self) -> Optional[pulumi.Input[int]]:
         """
-        An integer that identifies the current version of the network list; this value is incremented each time
-        the list is modified.
+        sync point
         """
         return pulumi.get(self, "sync_point")
 
     @sync_point.setter
     def sync_point(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "sync_point", value)
 
     @property
     @pulumi.getter
     def type(self) -> Optional[pulumi.Input[str]]:
         """
-        The type of the network list; must be either "IP" or "GEO".
+        The type of the network list; must be either 'IP' or 'GEO'
         """
         return pulumi.get(self, "type")
 
     @type.setter
     def type(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "type", value)
 
@@ -320,72 +310,34 @@
                  group_id: Optional[pulumi.Input[int]] = None,
                  lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  mode: Optional[pulumi.Input[str]] = None,
                  name: Optional[pulumi.Input[str]] = None,
                  type: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        Use the `NetworkList` resource to create a network list, or to modify an existing list.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        network_list = akamai.NetworkList("networkList",
-            type="IP",
-            description="network list description",
-            lists=var["list"],
-            mode="APPEND",
-            contract_id="ABC-123",
-            group_id=12345)
-        ```
-
+        Create a NetworkList resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] contract_id: The contract ID of the network list. If supplied, group_id must also be supplied. The
-               contract_id value of an existing network list may not be modified.
-        :param pulumi.Input[str] description: The description to be assigned to the network list.
-        :param pulumi.Input[int] group_id: The group ID of the network list. If supplied, contract_id must also be supplied. The
-               group_id value of an existing network list may not be modified.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] lists: A list of IP addresses or locations to be included in the list, added to an existing list, or
-               removed from an existing list.
-        :param pulumi.Input[str] mode: A string specifying the interpretation of the `list` parameter. Must be one of the following:
-        :param pulumi.Input[str] name: The name to be assigned to the network list.
-        :param pulumi.Input[str] type: The type of the network list; must be either "IP" or "GEO".
+        :param pulumi.Input[str] contract_id: contract ID
+        :param pulumi.Input[str] description: A description of the network list
+        :param pulumi.Input[int] group_id: group ID
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] lists: A list of IP addresses or locations to be included in the list, added to an existing list, or removed from an existing
+               list
+        :param pulumi.Input[str] mode: A string specifying the interpretation of the `list` parameter. Must be 'APPEND', 'REPLACE', or 'REMOVE'
+        :param pulumi.Input[str] name: The name to be assigned to the network list
+        :param pulumi.Input[str] type: The type of the network list; must be either 'IP' or 'GEO'
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: NetworkListArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        Use the `NetworkList` resource to create a network list, or to modify an existing list.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        network_list = akamai.NetworkList("networkList",
-            type="IP",
-            description="network list description",
-            lists=var["list"],
-            mode="APPEND",
-            contract_id="ABC-123",
-            group_id=12345)
-        ```
-
+        Create a NetworkList resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param NetworkListArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(NetworkListArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -452,27 +404,24 @@
         """
         Get an existing NetworkList resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] contract_id: The contract ID of the network list. If supplied, group_id must also be supplied. The
-               contract_id value of an existing network list may not be modified.
-        :param pulumi.Input[str] description: The description to be assigned to the network list.
-        :param pulumi.Input[int] group_id: The group ID of the network list. If supplied, contract_id must also be supplied. The
-               group_id value of an existing network list may not be modified.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] lists: A list of IP addresses or locations to be included in the list, added to an existing list, or
-               removed from an existing list.
-        :param pulumi.Input[str] mode: A string specifying the interpretation of the `list` parameter. Must be one of the following:
-        :param pulumi.Input[str] name: The name to be assigned to the network list.
-        :param pulumi.Input[str] network_list_id: The ID of the network list.
-        :param pulumi.Input[int] sync_point: An integer that identifies the current version of the network list; this value is incremented each time
-               the list is modified.
-        :param pulumi.Input[str] type: The type of the network list; must be either "IP" or "GEO".
+        :param pulumi.Input[str] contract_id: contract ID
+        :param pulumi.Input[str] description: A description of the network list
+        :param pulumi.Input[int] group_id: group ID
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] lists: A list of IP addresses or locations to be included in the list, added to an existing list, or removed from an existing
+               list
+        :param pulumi.Input[str] mode: A string specifying the interpretation of the `list` parameter. Must be 'APPEND', 'REPLACE', or 'REMOVE'
+        :param pulumi.Input[str] name: The name to be assigned to the network list
+        :param pulumi.Input[str] network_list_id: network list ID
+        :param pulumi.Input[int] sync_point: sync point
+        :param pulumi.Input[str] type: The type of the network list; must be either 'IP' or 'GEO'
         :param pulumi.Input[str] uniqueid: unique ID
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _NetworkListState.__new__(_NetworkListState)
 
         __props__.__dict__["contract_id"] = contract_id
@@ -487,83 +436,80 @@
         __props__.__dict__["uniqueid"] = uniqueid
         return NetworkList(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="contractId")
     def contract_id(self) -> pulumi.Output[Optional[str]]:
         """
-        The contract ID of the network list. If supplied, group_id must also be supplied. The
-        contract_id value of an existing network list may not be modified.
+        contract ID
         """
         return pulumi.get(self, "contract_id")
 
     @property
     @pulumi.getter
     def description(self) -> pulumi.Output[str]:
         """
-        The description to be assigned to the network list.
+        A description of the network list
         """
         return pulumi.get(self, "description")
 
     @property
     @pulumi.getter(name="groupId")
     def group_id(self) -> pulumi.Output[Optional[int]]:
         """
-        The group ID of the network list. If supplied, contract_id must also be supplied. The
-        group_id value of an existing network list may not be modified.
+        group ID
         """
         return pulumi.get(self, "group_id")
 
     @property
     @pulumi.getter
     def lists(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        A list of IP addresses or locations to be included in the list, added to an existing list, or
-        removed from an existing list.
+        A list of IP addresses or locations to be included in the list, added to an existing list, or removed from an existing
+        list
         """
         return pulumi.get(self, "lists")
 
     @property
     @pulumi.getter
     def mode(self) -> pulumi.Output[str]:
         """
-        A string specifying the interpretation of the `list` parameter. Must be one of the following:
+        A string specifying the interpretation of the `list` parameter. Must be 'APPEND', 'REPLACE', or 'REMOVE'
         """
         return pulumi.get(self, "mode")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        The name to be assigned to the network list.
+        The name to be assigned to the network list
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter(name="networkListId")
     def network_list_id(self) -> pulumi.Output[str]:
         """
-        The ID of the network list.
+        network list ID
         """
         return pulumi.get(self, "network_list_id")
 
     @property
     @pulumi.getter(name="syncPoint")
     def sync_point(self) -> pulumi.Output[int]:
         """
-        An integer that identifies the current version of the network list; this value is incremented each time
-        the list is modified.
+        sync point
         """
         return pulumi.get(self, "sync_point")
 
     @property
     @pulumi.getter
     def type(self) -> pulumi.Output[str]:
         """
-        The type of the network list; must be either "IP" or "GEO".
+        The type of the network list; must be either 'IP' or 'GEO'
         """
         return pulumi.get(self, "type")
 
     @property
     @pulumi.getter
     def uniqueid(self) -> pulumi.Output[str]:
         """
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/network_list_activations.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/network_list_activations.py`

 * *Files 26% similar despite different names*

```diff
@@ -18,22 +18,19 @@
                  notification_emails: pulumi.Input[Sequence[pulumi.Input[str]]],
                  sync_point: pulumi.Input[int],
                  activate: Optional[pulumi.Input[bool]] = None,
                  network: Optional[pulumi.Input[str]] = None,
                  notes: Optional[pulumi.Input[str]] = None):
         """
         The set of arguments for constructing a NetworkListActivations resource.
-        :param pulumi.Input[str] network_list_id: The ID of the network list to be activated
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notification_emails: A bracketed, comma-separated list of email addresses that will be notified when the
-               operation is complete.
-        :param pulumi.Input[int] sync_point: An integer that identifies the current version of the network list; this value is incremented each time
-               the list is modified.
-        :param pulumi.Input[str] network: The network to be used, either `STAGING` or `PRODUCTION`. If not supplied, defaults to
-               `STAGING`.
-        :param pulumi.Input[str] notes: A comment describing the activation.
+        :param pulumi.Input[str] network_list_id: Unique identifier of the network list
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notification_emails: List of email addresses of Control Center users who receive an email when activation of this list is complete
+        :param pulumi.Input[int] sync_point: Identifies the sync point of the network list to be activated
+        :param pulumi.Input[str] network: The Akamai network on which the list is activated: STAGING or PRODUCTION
+        :param pulumi.Input[str] notes: Descriptive text to accompany the activation
         """
         pulumi.set(__self__, "network_list_id", network_list_id)
         pulumi.set(__self__, "notification_emails", notification_emails)
         pulumi.set(__self__, "sync_point", sync_point)
         if activate is not None:
             warnings.warn("""The setting \"activate\" has been deprecated.""", DeprecationWarning)
             pulumi.log.warn("""activate is deprecated: The setting \"activate\" has been deprecated.""")
@@ -44,41 +41,39 @@
         if notes is not None:
             pulumi.set(__self__, "notes", notes)
 
     @property
     @pulumi.getter(name="networkListId")
     def network_list_id(self) -> pulumi.Input[str]:
         """
-        The ID of the network list to be activated
+        Unique identifier of the network list
         """
         return pulumi.get(self, "network_list_id")
 
     @network_list_id.setter
     def network_list_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "network_list_id", value)
 
     @property
     @pulumi.getter(name="notificationEmails")
     def notification_emails(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
         """
-        A bracketed, comma-separated list of email addresses that will be notified when the
-        operation is complete.
+        List of email addresses of Control Center users who receive an email when activation of this list is complete
         """
         return pulumi.get(self, "notification_emails")
 
     @notification_emails.setter
     def notification_emails(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
         pulumi.set(self, "notification_emails", value)
 
     @property
     @pulumi.getter(name="syncPoint")
     def sync_point(self) -> pulumi.Input[int]:
         """
-        An integer that identifies the current version of the network list; this value is incremented each time
-        the list is modified.
+        Identifies the sync point of the network list to be activated
         """
         return pulumi.get(self, "sync_point")
 
     @sync_point.setter
     def sync_point(self, value: pulumi.Input[int]):
         pulumi.set(self, "sync_point", value)
 
@@ -91,28 +86,27 @@
     def activate(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "activate", value)
 
     @property
     @pulumi.getter
     def network(self) -> Optional[pulumi.Input[str]]:
         """
-        The network to be used, either `STAGING` or `PRODUCTION`. If not supplied, defaults to
-        `STAGING`.
+        The Akamai network on which the list is activated: STAGING or PRODUCTION
         """
         return pulumi.get(self, "network")
 
     @network.setter
     def network(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "network", value)
 
     @property
     @pulumi.getter
     def notes(self) -> Optional[pulumi.Input[str]]:
         """
-        A comment describing the activation.
+        Descriptive text to accompany the activation
         """
         return pulumi.get(self, "notes")
 
     @notes.setter
     def notes(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "notes", value)
 
@@ -125,24 +119,20 @@
                  network_list_id: Optional[pulumi.Input[str]] = None,
                  notes: Optional[pulumi.Input[str]] = None,
                  notification_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  status: Optional[pulumi.Input[str]] = None,
                  sync_point: Optional[pulumi.Input[int]] = None):
         """
         Input properties used for looking up and filtering NetworkListActivations resources.
-        :param pulumi.Input[str] network: The network to be used, either `STAGING` or `PRODUCTION`. If not supplied, defaults to
-               `STAGING`.
-        :param pulumi.Input[str] network_list_id: The ID of the network list to be activated
-        :param pulumi.Input[str] notes: A comment describing the activation.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notification_emails: A bracketed, comma-separated list of email addresses that will be notified when the
-               operation is complete.
-        :param pulumi.Input[str] status: The string `ACTIVATED` if the activation was successful, or a string identifying the reason why the network
-               list was not activated.
-        :param pulumi.Input[int] sync_point: An integer that identifies the current version of the network list; this value is incremented each time
-               the list is modified.
+        :param pulumi.Input[str] network: The Akamai network on which the list is activated: STAGING or PRODUCTION
+        :param pulumi.Input[str] network_list_id: Unique identifier of the network list
+        :param pulumi.Input[str] notes: Descriptive text to accompany the activation
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notification_emails: List of email addresses of Control Center users who receive an email when activation of this list is complete
+        :param pulumi.Input[str] status: This network list's current activation status in the environment specified by the "network" attribute
+        :param pulumi.Input[int] sync_point: Identifies the sync point of the network list to be activated
         """
         if activate is not None:
             warnings.warn("""The setting \"activate\" has been deprecated.""", DeprecationWarning)
             pulumi.log.warn("""activate is deprecated: The setting \"activate\" has been deprecated.""")
         if activate is not None:
             pulumi.set(__self__, "activate", activate)
         if network is not None:
@@ -167,79 +157,75 @@
     def activate(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "activate", value)
 
     @property
     @pulumi.getter
     def network(self) -> Optional[pulumi.Input[str]]:
         """
-        The network to be used, either `STAGING` or `PRODUCTION`. If not supplied, defaults to
-        `STAGING`.
+        The Akamai network on which the list is activated: STAGING or PRODUCTION
         """
         return pulumi.get(self, "network")
 
     @network.setter
     def network(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "network", value)
 
     @property
     @pulumi.getter(name="networkListId")
     def network_list_id(self) -> Optional[pulumi.Input[str]]:
         """
-        The ID of the network list to be activated
+        Unique identifier of the network list
         """
         return pulumi.get(self, "network_list_id")
 
     @network_list_id.setter
     def network_list_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "network_list_id", value)
 
     @property
     @pulumi.getter
     def notes(self) -> Optional[pulumi.Input[str]]:
         """
-        A comment describing the activation.
+        Descriptive text to accompany the activation
         """
         return pulumi.get(self, "notes")
 
     @notes.setter
     def notes(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "notes", value)
 
     @property
     @pulumi.getter(name="notificationEmails")
     def notification_emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        A bracketed, comma-separated list of email addresses that will be notified when the
-        operation is complete.
+        List of email addresses of Control Center users who receive an email when activation of this list is complete
         """
         return pulumi.get(self, "notification_emails")
 
     @notification_emails.setter
     def notification_emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "notification_emails", value)
 
     @property
     @pulumi.getter
     def status(self) -> Optional[pulumi.Input[str]]:
         """
-        The string `ACTIVATED` if the activation was successful, or a string identifying the reason why the network
-        list was not activated.
+        This network list's current activation status in the environment specified by the "network" attribute
         """
         return pulumi.get(self, "status")
 
     @status.setter
     def status(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "status", value)
 
     @property
     @pulumi.getter(name="syncPoint")
     def sync_point(self) -> Optional[pulumi.Input[int]]:
         """
-        An integer that identifies the current version of the network list; this value is incremented each time
-        the list is modified.
+        Identifies the sync point of the network list to be activated
         """
         return pulumi.get(self, "sync_point")
 
     @sync_point.setter
     def sync_point(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "sync_point", value)
 
@@ -253,38 +239,31 @@
                  network: Optional[pulumi.Input[str]] = None,
                  network_list_id: Optional[pulumi.Input[str]] = None,
                  notes: Optional[pulumi.Input[str]] = None,
                  notification_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  sync_point: Optional[pulumi.Input[int]] = None,
                  __props__=None):
         """
-        Use the `NetworkListActivations` resource to activate a network list in either the STAGING or PRODUCTION
-        environment.
-
+        Create a NetworkListActivations resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] network: The network to be used, either `STAGING` or `PRODUCTION`. If not supplied, defaults to
-               `STAGING`.
-        :param pulumi.Input[str] network_list_id: The ID of the network list to be activated
-        :param pulumi.Input[str] notes: A comment describing the activation.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notification_emails: A bracketed, comma-separated list of email addresses that will be notified when the
-               operation is complete.
-        :param pulumi.Input[int] sync_point: An integer that identifies the current version of the network list; this value is incremented each time
-               the list is modified.
+        :param pulumi.Input[str] network: The Akamai network on which the list is activated: STAGING or PRODUCTION
+        :param pulumi.Input[str] network_list_id: Unique identifier of the network list
+        :param pulumi.Input[str] notes: Descriptive text to accompany the activation
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notification_emails: List of email addresses of Control Center users who receive an email when activation of this list is complete
+        :param pulumi.Input[int] sync_point: Identifies the sync point of the network list to be activated
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: NetworkListActivationsArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        Use the `NetworkListActivations` resource to activate a network list in either the STAGING or PRODUCTION
-        environment.
-
+        Create a NetworkListActivations resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param NetworkListActivationsArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(NetworkListActivationsArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -347,24 +326,20 @@
         """
         Get an existing NetworkListActivations resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] network: The network to be used, either `STAGING` or `PRODUCTION`. If not supplied, defaults to
-               `STAGING`.
-        :param pulumi.Input[str] network_list_id: The ID of the network list to be activated
-        :param pulumi.Input[str] notes: A comment describing the activation.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notification_emails: A bracketed, comma-separated list of email addresses that will be notified when the
-               operation is complete.
-        :param pulumi.Input[str] status: The string `ACTIVATED` if the activation was successful, or a string identifying the reason why the network
-               list was not activated.
-        :param pulumi.Input[int] sync_point: An integer that identifies the current version of the network list; this value is incremented each time
-               the list is modified.
+        :param pulumi.Input[str] network: The Akamai network on which the list is activated: STAGING or PRODUCTION
+        :param pulumi.Input[str] network_list_id: Unique identifier of the network list
+        :param pulumi.Input[str] notes: Descriptive text to accompany the activation
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notification_emails: List of email addresses of Control Center users who receive an email when activation of this list is complete
+        :param pulumi.Input[str] status: This network list's current activation status in the environment specified by the "network" attribute
+        :param pulumi.Input[int] sync_point: Identifies the sync point of the network list to be activated
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _NetworkListActivationsState.__new__(_NetworkListActivationsState)
 
         __props__.__dict__["activate"] = activate
         __props__.__dict__["network"] = network
@@ -380,55 +355,51 @@
     def activate(self) -> pulumi.Output[Optional[bool]]:
         return pulumi.get(self, "activate")
 
     @property
     @pulumi.getter
     def network(self) -> pulumi.Output[Optional[str]]:
         """
-        The network to be used, either `STAGING` or `PRODUCTION`. If not supplied, defaults to
-        `STAGING`.
+        The Akamai network on which the list is activated: STAGING or PRODUCTION
         """
         return pulumi.get(self, "network")
 
     @property
     @pulumi.getter(name="networkListId")
     def network_list_id(self) -> pulumi.Output[str]:
         """
-        The ID of the network list to be activated
+        Unique identifier of the network list
         """
         return pulumi.get(self, "network_list_id")
 
     @property
     @pulumi.getter
     def notes(self) -> pulumi.Output[Optional[str]]:
         """
-        A comment describing the activation.
+        Descriptive text to accompany the activation
         """
         return pulumi.get(self, "notes")
 
     @property
     @pulumi.getter(name="notificationEmails")
     def notification_emails(self) -> pulumi.Output[Sequence[str]]:
         """
-        A bracketed, comma-separated list of email addresses that will be notified when the
-        operation is complete.
+        List of email addresses of Control Center users who receive an email when activation of this list is complete
         """
         return pulumi.get(self, "notification_emails")
 
     @property
     @pulumi.getter
     def status(self) -> pulumi.Output[str]:
         """
-        The string `ACTIVATED` if the activation was successful, or a string identifying the reason why the network
-        list was not activated.
+        This network list's current activation status in the environment specified by the "network" attribute
         """
         return pulumi.get(self, "status")
 
     @property
     @pulumi.getter(name="syncPoint")
     def sync_point(self) -> pulumi.Output[int]:
         """
-        An integer that identifies the current version of the network list; this value is incremented each time
-        the list is modified.
+        Identifies the sync point of the network list to be activated
         """
         return pulumi.get(self, "sync_point")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/network_list_description.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/network_list_description.py`

 * *Files 18% similar despite different names*

```diff
@@ -15,53 +15,41 @@
 class NetworkListDescriptionArgs:
     def __init__(__self__, *,
                  description: pulumi.Input[str],
                  network_list_id: pulumi.Input[str],
                  name: Optional[pulumi.Input[str]] = None):
         """
         The set of arguments for constructing a NetworkListDescription resource.
-        :param pulumi.Input[str] description: The description to be assigned to the network list.
-        :param pulumi.Input[str] network_list_id: The unique ID of the network list to use.
-        :param pulumi.Input[str] name: The name to be assigned to the network list.
         """
         pulumi.set(__self__, "description", description)
         pulumi.set(__self__, "network_list_id", network_list_id)
         if name is not None:
             pulumi.set(__self__, "name", name)
 
     @property
     @pulumi.getter
     def description(self) -> pulumi.Input[str]:
-        """
-        The description to be assigned to the network list.
-        """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: pulumi.Input[str]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter(name="networkListId")
     def network_list_id(self) -> pulumi.Input[str]:
-        """
-        The unique ID of the network list to use.
-        """
         return pulumi.get(self, "network_list_id")
 
     @network_list_id.setter
     def network_list_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "network_list_id", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
-        """
-        The name to be assigned to the network list.
-        """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
 
@@ -69,55 +57,43 @@
 class _NetworkListDescriptionState:
     def __init__(__self__, *,
                  description: Optional[pulumi.Input[str]] = None,
                  name: Optional[pulumi.Input[str]] = None,
                  network_list_id: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering NetworkListDescription resources.
-        :param pulumi.Input[str] description: The description to be assigned to the network list.
-        :param pulumi.Input[str] name: The name to be assigned to the network list.
-        :param pulumi.Input[str] network_list_id: The unique ID of the network list to use.
         """
         if description is not None:
             pulumi.set(__self__, "description", description)
         if name is not None:
             pulumi.set(__self__, "name", name)
         if network_list_id is not None:
             pulumi.set(__self__, "network_list_id", network_list_id)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
-        """
-        The description to be assigned to the network list.
-        """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
-        """
-        The name to be assigned to the network list.
-        """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="networkListId")
     def network_list_id(self) -> Optional[pulumi.Input[str]]:
-        """
-        The unique ID of the network list to use.
-        """
         return pulumi.get(self, "network_list_id")
 
     @network_list_id.setter
     def network_list_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "network_list_id", value)
 
 
@@ -127,57 +103,26 @@
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
                  description: Optional[pulumi.Input[str]] = None,
                  name: Optional[pulumi.Input[str]] = None,
                  network_list_id: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        Use the `NetworkListDescription` resource to update the name or description of an existing network list.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        network_list_description = akamai.NetworkListDescription("networkListDescription",
-            network_list_id=var["network_list_id"],
-            description="Test network list updated description")
-        ```
-
+        Create a NetworkListDescription resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] description: The description to be assigned to the network list.
-        :param pulumi.Input[str] name: The name to be assigned to the network list.
-        :param pulumi.Input[str] network_list_id: The unique ID of the network list to use.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: NetworkListDescriptionArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        Use the `NetworkListDescription` resource to update the name or description of an existing network list.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        network_list_description = akamai.NetworkListDescription("networkListDescription",
-            network_list_id=var["network_list_id"],
-            description="Test network list updated description")
-        ```
-
+        Create a NetworkListDescription resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param NetworkListDescriptionArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(NetworkListDescriptionArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -224,44 +169,32 @@
         """
         Get an existing NetworkListDescription resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] description: The description to be assigned to the network list.
-        :param pulumi.Input[str] name: The name to be assigned to the network list.
-        :param pulumi.Input[str] network_list_id: The unique ID of the network list to use.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _NetworkListDescriptionState.__new__(_NetworkListDescriptionState)
 
         __props__.__dict__["description"] = description
         __props__.__dict__["name"] = name
         __props__.__dict__["network_list_id"] = network_list_id
         return NetworkListDescription(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter
     def description(self) -> pulumi.Output[str]:
-        """
-        The description to be assigned to the network list.
-        """
         return pulumi.get(self, "description")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
-        """
-        The name to be assigned to the network list.
-        """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter(name="networkListId")
     def network_list_id(self) -> pulumi.Output[str]:
-        """
-        The unique ID of the network list to use.
-        """
         return pulumi.get(self, "network_list_id")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/network_list_subscription.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_cps_enrollment.py`

 * *Files 25% similar despite different names*

```diff
@@ -4,235 +4,255 @@
 
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
+from . import outputs
 
-__all__ = ['NetworkListSubscriptionArgs', 'NetworkListSubscription']
-
-@pulumi.input_type
-class NetworkListSubscriptionArgs:
-    def __init__(__self__, *,
-                 network_lists: pulumi.Input[Sequence[pulumi.Input[str]]],
-                 recipients: pulumi.Input[Sequence[pulumi.Input[str]]]):
-        """
-        The set of arguments for constructing a NetworkListSubscription resource.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] network_lists: A list containing one or more IDs of the network lists to which the indicated email
-               addresses should be subscribed.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] recipients: A bracketed, comma-separated list of email addresses that will be notified of changes to any
-               of the specified network lists.
-        """
-        pulumi.set(__self__, "network_lists", network_lists)
-        pulumi.set(__self__, "recipients", recipients)
-
-    @property
-    @pulumi.getter(name="networkLists")
-    def network_lists(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
-        """
-        A list containing one or more IDs of the network lists to which the indicated email
-        addresses should be subscribed.
-        """
-        return pulumi.get(self, "network_lists")
-
-    @network_lists.setter
-    def network_lists(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
-        pulumi.set(self, "network_lists", value)
+__all__ = [
+    'GetCPSEnrollmentResult',
+    'AwaitableGetCPSEnrollmentResult',
+    'get_cps_enrollment',
+    'get_cps_enrollment_output',
+]
+
+@pulumi.output_type
+class GetCPSEnrollmentResult:
+    """
+    A collection of values returned by getCPSEnrollment.
+    """
+    def __init__(__self__, admin_contacts=None, certificate_chain_type=None, certificate_type=None, common_name=None, contract_id=None, csrs=None, dns_challenges=None, enable_multi_stacked_certificates=None, enrollment_id=None, http_challenges=None, id=None, network_configurations=None, organizations=None, registration_authority=None, sans=None, secure_network=None, signature_algorithm=None, sni_only=None, tech_contacts=None, validation_type=None):
+        if admin_contacts and not isinstance(admin_contacts, list):
+            raise TypeError("Expected argument 'admin_contacts' to be a list")
+        pulumi.set(__self__, "admin_contacts", admin_contacts)
+        if certificate_chain_type and not isinstance(certificate_chain_type, str):
+            raise TypeError("Expected argument 'certificate_chain_type' to be a str")
+        pulumi.set(__self__, "certificate_chain_type", certificate_chain_type)
+        if certificate_type and not isinstance(certificate_type, str):
+            raise TypeError("Expected argument 'certificate_type' to be a str")
+        pulumi.set(__self__, "certificate_type", certificate_type)
+        if common_name and not isinstance(common_name, str):
+            raise TypeError("Expected argument 'common_name' to be a str")
+        pulumi.set(__self__, "common_name", common_name)
+        if contract_id and not isinstance(contract_id, str):
+            raise TypeError("Expected argument 'contract_id' to be a str")
+        pulumi.set(__self__, "contract_id", contract_id)
+        if csrs and not isinstance(csrs, list):
+            raise TypeError("Expected argument 'csrs' to be a list")
+        pulumi.set(__self__, "csrs", csrs)
+        if dns_challenges and not isinstance(dns_challenges, list):
+            raise TypeError("Expected argument 'dns_challenges' to be a list")
+        pulumi.set(__self__, "dns_challenges", dns_challenges)
+        if enable_multi_stacked_certificates and not isinstance(enable_multi_stacked_certificates, bool):
+            raise TypeError("Expected argument 'enable_multi_stacked_certificates' to be a bool")
+        pulumi.set(__self__, "enable_multi_stacked_certificates", enable_multi_stacked_certificates)
+        if enrollment_id and not isinstance(enrollment_id, int):
+            raise TypeError("Expected argument 'enrollment_id' to be a int")
+        pulumi.set(__self__, "enrollment_id", enrollment_id)
+        if http_challenges and not isinstance(http_challenges, list):
+            raise TypeError("Expected argument 'http_challenges' to be a list")
+        pulumi.set(__self__, "http_challenges", http_challenges)
+        if id and not isinstance(id, str):
+            raise TypeError("Expected argument 'id' to be a str")
+        pulumi.set(__self__, "id", id)
+        if network_configurations and not isinstance(network_configurations, list):
+            raise TypeError("Expected argument 'network_configurations' to be a list")
+        pulumi.set(__self__, "network_configurations", network_configurations)
+        if organizations and not isinstance(organizations, list):
+            raise TypeError("Expected argument 'organizations' to be a list")
+        pulumi.set(__self__, "organizations", organizations)
+        if registration_authority and not isinstance(registration_authority, str):
+            raise TypeError("Expected argument 'registration_authority' to be a str")
+        pulumi.set(__self__, "registration_authority", registration_authority)
+        if sans and not isinstance(sans, list):
+            raise TypeError("Expected argument 'sans' to be a list")
+        pulumi.set(__self__, "sans", sans)
+        if secure_network and not isinstance(secure_network, str):
+            raise TypeError("Expected argument 'secure_network' to be a str")
+        pulumi.set(__self__, "secure_network", secure_network)
+        if signature_algorithm and not isinstance(signature_algorithm, str):
+            raise TypeError("Expected argument 'signature_algorithm' to be a str")
+        pulumi.set(__self__, "signature_algorithm", signature_algorithm)
+        if sni_only and not isinstance(sni_only, bool):
+            raise TypeError("Expected argument 'sni_only' to be a bool")
+        pulumi.set(__self__, "sni_only", sni_only)
+        if tech_contacts and not isinstance(tech_contacts, list):
+            raise TypeError("Expected argument 'tech_contacts' to be a list")
+        pulumi.set(__self__, "tech_contacts", tech_contacts)
+        if validation_type and not isinstance(validation_type, str):
+            raise TypeError("Expected argument 'validation_type' to be a str")
+        pulumi.set(__self__, "validation_type", validation_type)
+
+    @property
+    @pulumi.getter(name="adminContacts")
+    def admin_contacts(self) -> Sequence['outputs.GetCPSEnrollmentAdminContactResult']:
+        return pulumi.get(self, "admin_contacts")
+
+    @property
+    @pulumi.getter(name="certificateChainType")
+    def certificate_chain_type(self) -> str:
+        return pulumi.get(self, "certificate_chain_type")
+
+    @property
+    @pulumi.getter(name="certificateType")
+    def certificate_type(self) -> str:
+        return pulumi.get(self, "certificate_type")
+
+    @property
+    @pulumi.getter(name="commonName")
+    def common_name(self) -> str:
+        return pulumi.get(self, "common_name")
+
+    @property
+    @pulumi.getter(name="contractId")
+    def contract_id(self) -> str:
+        return pulumi.get(self, "contract_id")
 
     @property
     @pulumi.getter
-    def recipients(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
-        """
-        A bracketed, comma-separated list of email addresses that will be notified of changes to any
-        of the specified network lists.
-        """
-        return pulumi.get(self, "recipients")
-
-    @recipients.setter
-    def recipients(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
-        pulumi.set(self, "recipients", value)
+    def csrs(self) -> Sequence['outputs.GetCPSEnrollmentCsrResult']:
+        return pulumi.get(self, "csrs")
 
+    @property
+    @pulumi.getter(name="dnsChallenges")
+    def dns_challenges(self) -> Sequence['outputs.GetCPSEnrollmentDnsChallengeResult']:
+        return pulumi.get(self, "dns_challenges")
 
-@pulumi.input_type
-class _NetworkListSubscriptionState:
-    def __init__(__self__, *,
-                 network_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 recipients: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
-        """
-        Input properties used for looking up and filtering NetworkListSubscription resources.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] network_lists: A list containing one or more IDs of the network lists to which the indicated email
-               addresses should be subscribed.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] recipients: A bracketed, comma-separated list of email addresses that will be notified of changes to any
-               of the specified network lists.
-        """
-        if network_lists is not None:
-            pulumi.set(__self__, "network_lists", network_lists)
-        if recipients is not None:
-            pulumi.set(__self__, "recipients", recipients)
+    @property
+    @pulumi.getter(name="enableMultiStackedCertificates")
+    def enable_multi_stacked_certificates(self) -> bool:
+        return pulumi.get(self, "enable_multi_stacked_certificates")
 
     @property
-    @pulumi.getter(name="networkLists")
-    def network_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
-        """
-        A list containing one or more IDs of the network lists to which the indicated email
-        addresses should be subscribed.
-        """
-        return pulumi.get(self, "network_lists")
+    @pulumi.getter(name="enrollmentId")
+    def enrollment_id(self) -> int:
+        return pulumi.get(self, "enrollment_id")
 
-    @network_lists.setter
-    def network_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
-        pulumi.set(self, "network_lists", value)
+    @property
+    @pulumi.getter(name="httpChallenges")
+    def http_challenges(self) -> Sequence['outputs.GetCPSEnrollmentHttpChallengeResult']:
+        return pulumi.get(self, "http_challenges")
 
     @property
     @pulumi.getter
-    def recipients(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
-        """
-        A bracketed, comma-separated list of email addresses that will be notified of changes to any
-        of the specified network lists.
-        """
-        return pulumi.get(self, "recipients")
-
-    @recipients.setter
-    def recipients(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
-        pulumi.set(self, "recipients", value)
-
-
-class NetworkListSubscription(pulumi.CustomResource):
-    @overload
-    def __init__(__self__,
-                 resource_name: str,
-                 opts: Optional[pulumi.ResourceOptions] = None,
-                 network_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 recipients: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 __props__=None):
-        """
-        Use the `NetworkListSubscription` resource to specify a set of email addresses to be notified of changes to any
-        of a set of network lists.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        network_lists_filter = akamai.get_network_lists(name=var["network_list"])
-        subscribe = akamai.NetworkListSubscription("subscribe",
-            network_lists=network_lists_filter.lists,
-            recipients=["user@example.com"])
-        ```
-
-        :param str resource_name: The name of the resource.
-        :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] network_lists: A list containing one or more IDs of the network lists to which the indicated email
-               addresses should be subscribed.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] recipients: A bracketed, comma-separated list of email addresses that will be notified of changes to any
-               of the specified network lists.
-        """
-        ...
-    @overload
-    def __init__(__self__,
-                 resource_name: str,
-                 args: NetworkListSubscriptionArgs,
-                 opts: Optional[pulumi.ResourceOptions] = None):
-        """
-        Use the `NetworkListSubscription` resource to specify a set of email addresses to be notified of changes to any
-        of a set of network lists.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        network_lists_filter = akamai.get_network_lists(name=var["network_list"])
-        subscribe = akamai.NetworkListSubscription("subscribe",
-            network_lists=network_lists_filter.lists,
-            recipients=["user@example.com"])
-        ```
-
-        :param str resource_name: The name of the resource.
-        :param NetworkListSubscriptionArgs args: The arguments to use to populate this resource's properties.
-        :param pulumi.ResourceOptions opts: Options for the resource.
+    def id(self) -> str:
         """
-        ...
-    def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(NetworkListSubscriptionArgs, pulumi.ResourceOptions, *args, **kwargs)
-        if resource_args is not None:
-            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
-        else:
-            __self__._internal_init(resource_name, *args, **kwargs)
-
-    def _internal_init(__self__,
-                 resource_name: str,
-                 opts: Optional[pulumi.ResourceOptions] = None,
-                 network_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 recipients: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 __props__=None):
-        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
-        if not isinstance(opts, pulumi.ResourceOptions):
-            raise TypeError('Expected resource options to be a ResourceOptions instance')
-        if opts.id is None:
-            if __props__ is not None:
-                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = NetworkListSubscriptionArgs.__new__(NetworkListSubscriptionArgs)
-
-            if network_lists is None and not opts.urn:
-                raise TypeError("Missing required property 'network_lists'")
-            __props__.__dict__["network_lists"] = network_lists
-            if recipients is None and not opts.urn:
-                raise TypeError("Missing required property 'recipients'")
-            __props__.__dict__["recipients"] = recipients
-        super(NetworkListSubscription, __self__).__init__(
-            'akamai:index/networkListSubscription:NetworkListSubscription',
-            resource_name,
-            __props__,
-            opts)
-
-    @staticmethod
-    def get(resource_name: str,
-            id: pulumi.Input[str],
-            opts: Optional[pulumi.ResourceOptions] = None,
-            network_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-            recipients: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None) -> 'NetworkListSubscription':
+        The provider-assigned unique ID for this managed resource.
         """
-        Get an existing NetworkListSubscription resource's state with the given name, id, and optional extra
-        properties used to qualify the lookup.
+        return pulumi.get(self, "id")
 
-        :param str resource_name: The unique name of the resulting resource.
-        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
-        :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] network_lists: A list containing one or more IDs of the network lists to which the indicated email
-               addresses should be subscribed.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] recipients: A bracketed, comma-separated list of email addresses that will be notified of changes to any
-               of the specified network lists.
-        """
-        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
-
-        __props__ = _NetworkListSubscriptionState.__new__(_NetworkListSubscriptionState)
+    @property
+    @pulumi.getter(name="networkConfigurations")
+    def network_configurations(self) -> Sequence['outputs.GetCPSEnrollmentNetworkConfigurationResult']:
+        return pulumi.get(self, "network_configurations")
 
-        __props__.__dict__["network_lists"] = network_lists
-        __props__.__dict__["recipients"] = recipients
-        return NetworkListSubscription(resource_name, opts=opts, __props__=__props__)
+    @property
+    @pulumi.getter
+    def organizations(self) -> Sequence['outputs.GetCPSEnrollmentOrganizationResult']:
+        return pulumi.get(self, "organizations")
 
     @property
-    @pulumi.getter(name="networkLists")
-    def network_lists(self) -> pulumi.Output[Sequence[str]]:
-        """
-        A list containing one or more IDs of the network lists to which the indicated email
-        addresses should be subscribed.
-        """
-        return pulumi.get(self, "network_lists")
+    @pulumi.getter(name="registrationAuthority")
+    def registration_authority(self) -> str:
+        return pulumi.get(self, "registration_authority")
 
     @property
     @pulumi.getter
-    def recipients(self) -> pulumi.Output[Sequence[str]]:
-        """
-        A bracketed, comma-separated list of email addresses that will be notified of changes to any
-        of the specified network lists.
-        """
-        return pulumi.get(self, "recipients")
+    def sans(self) -> Sequence[str]:
+        return pulumi.get(self, "sans")
 
+    @property
+    @pulumi.getter(name="secureNetwork")
+    def secure_network(self) -> str:
+        return pulumi.get(self, "secure_network")
+
+    @property
+    @pulumi.getter(name="signatureAlgorithm")
+    def signature_algorithm(self) -> str:
+        return pulumi.get(self, "signature_algorithm")
+
+    @property
+    @pulumi.getter(name="sniOnly")
+    def sni_only(self) -> bool:
+        return pulumi.get(self, "sni_only")
+
+    @property
+    @pulumi.getter(name="techContacts")
+    def tech_contacts(self) -> Sequence['outputs.GetCPSEnrollmentTechContactResult']:
+        return pulumi.get(self, "tech_contacts")
+
+    @property
+    @pulumi.getter(name="validationType")
+    def validation_type(self) -> str:
+        return pulumi.get(self, "validation_type")
+
+
+class AwaitableGetCPSEnrollmentResult(GetCPSEnrollmentResult):
+    # pylint: disable=using-constant-test
+    def __await__(self):
+        if False:
+            yield self
+        return GetCPSEnrollmentResult(
+            admin_contacts=self.admin_contacts,
+            certificate_chain_type=self.certificate_chain_type,
+            certificate_type=self.certificate_type,
+            common_name=self.common_name,
+            contract_id=self.contract_id,
+            csrs=self.csrs,
+            dns_challenges=self.dns_challenges,
+            enable_multi_stacked_certificates=self.enable_multi_stacked_certificates,
+            enrollment_id=self.enrollment_id,
+            http_challenges=self.http_challenges,
+            id=self.id,
+            network_configurations=self.network_configurations,
+            organizations=self.organizations,
+            registration_authority=self.registration_authority,
+            sans=self.sans,
+            secure_network=self.secure_network,
+            signature_algorithm=self.signature_algorithm,
+            sni_only=self.sni_only,
+            tech_contacts=self.tech_contacts,
+            validation_type=self.validation_type)
+
+
+def get_cps_enrollment(enrollment_id: Optional[int] = None,
+                       opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetCPSEnrollmentResult:
+    """
+    Use this data source to access information about an existing resource.
+    """
+    __args__ = dict()
+    __args__['enrollmentId'] = enrollment_id
+    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
+    __ret__ = pulumi.runtime.invoke('akamai:index/getCPSEnrollment:getCPSEnrollment', __args__, opts=opts, typ=GetCPSEnrollmentResult).value
+
+    return AwaitableGetCPSEnrollmentResult(
+        admin_contacts=__ret__.admin_contacts,
+        certificate_chain_type=__ret__.certificate_chain_type,
+        certificate_type=__ret__.certificate_type,
+        common_name=__ret__.common_name,
+        contract_id=__ret__.contract_id,
+        csrs=__ret__.csrs,
+        dns_challenges=__ret__.dns_challenges,
+        enable_multi_stacked_certificates=__ret__.enable_multi_stacked_certificates,
+        enrollment_id=__ret__.enrollment_id,
+        http_challenges=__ret__.http_challenges,
+        id=__ret__.id,
+        network_configurations=__ret__.network_configurations,
+        organizations=__ret__.organizations,
+        registration_authority=__ret__.registration_authority,
+        sans=__ret__.sans,
+        secure_network=__ret__.secure_network,
+        signature_algorithm=__ret__.signature_algorithm,
+        sni_only=__ret__.sni_only,
+        tech_contacts=__ret__.tech_contacts,
+        validation_type=__ret__.validation_type)
+
+
+@_utilities.lift_output_func(get_cps_enrollment)
+def get_cps_enrollment_output(enrollment_id: Optional[pulumi.Input[int]] = None,
+                              opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetCPSEnrollmentResult]:
+    """
+    Use this data source to access information about an existing resource.
+    """
+    ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/properties/__init__.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/properties/__init__.py`

 * *Files identical despite different names*

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/properties/_inputs.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/properties/_inputs.py`

 * *Files 4% similar despite different names*

```diff
@@ -6,24 +6,101 @@
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from .. import _utilities
 
 __all__ = [
+    'PropertyActivationComplianceRecordArgs',
     'PropertyActivationRuleErrorArgs',
     'PropertyActivationRuleWarningArgs',
     'PropertyHostnameArgs',
     'PropertyHostnameCertStatusArgs',
     'PropertyOriginArgs',
     'PropertyRuleErrorArgs',
     'PropertyRuleWarningArgs',
 ]
 
 @pulumi.input_type
+class PropertyActivationComplianceRecordArgs:
+    def __init__(__self__, *,
+                 noncompliance_reason: pulumi.Input[str],
+                 customer_email: Optional[pulumi.Input[str]] = None,
+                 other_noncompliance_reason: Optional[pulumi.Input[str]] = None,
+                 peer_reviewed_by: Optional[pulumi.Input[str]] = None,
+                 ticket_id: Optional[pulumi.Input[str]] = None,
+                 unit_tested: Optional[pulumi.Input[bool]] = None):
+        pulumi.set(__self__, "noncompliance_reason", noncompliance_reason)
+        if customer_email is not None:
+            pulumi.set(__self__, "customer_email", customer_email)
+        if other_noncompliance_reason is not None:
+            pulumi.set(__self__, "other_noncompliance_reason", other_noncompliance_reason)
+        if peer_reviewed_by is not None:
+            pulumi.set(__self__, "peer_reviewed_by", peer_reviewed_by)
+        if ticket_id is not None:
+            pulumi.set(__self__, "ticket_id", ticket_id)
+        if unit_tested is not None:
+            pulumi.set(__self__, "unit_tested", unit_tested)
+
+    @property
+    @pulumi.getter(name="noncomplianceReason")
+    def noncompliance_reason(self) -> pulumi.Input[str]:
+        return pulumi.get(self, "noncompliance_reason")
+
+    @noncompliance_reason.setter
+    def noncompliance_reason(self, value: pulumi.Input[str]):
+        pulumi.set(self, "noncompliance_reason", value)
+
+    @property
+    @pulumi.getter(name="customerEmail")
+    def customer_email(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "customer_email")
+
+    @customer_email.setter
+    def customer_email(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "customer_email", value)
+
+    @property
+    @pulumi.getter(name="otherNoncomplianceReason")
+    def other_noncompliance_reason(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "other_noncompliance_reason")
+
+    @other_noncompliance_reason.setter
+    def other_noncompliance_reason(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "other_noncompliance_reason", value)
+
+    @property
+    @pulumi.getter(name="peerReviewedBy")
+    def peer_reviewed_by(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "peer_reviewed_by")
+
+    @peer_reviewed_by.setter
+    def peer_reviewed_by(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "peer_reviewed_by", value)
+
+    @property
+    @pulumi.getter(name="ticketId")
+    def ticket_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "ticket_id")
+
+    @ticket_id.setter
+    def ticket_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "ticket_id", value)
+
+    @property
+    @pulumi.getter(name="unitTested")
+    def unit_tested(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "unit_tested")
+
+    @unit_tested.setter
+    def unit_tested(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "unit_tested", value)
+
+
+@pulumi.input_type
 class PropertyActivationRuleErrorArgs:
     def __init__(__self__, *,
                  behavior_name: Optional[pulumi.Input[str]] = None,
                  detail: Optional[pulumi.Input[str]] = None,
                  error_location: Optional[pulumi.Input[str]] = None,
                  instance: Optional[pulumi.Input[str]] = None,
                  status_code: Optional[pulumi.Input[int]] = None,
@@ -202,59 +279,45 @@
     def __init__(__self__, *,
                  cert_provisioning_type: pulumi.Input[str],
                  cname_from: pulumi.Input[str],
                  cname_to: pulumi.Input[str],
                  cert_statuses: Optional[pulumi.Input[Sequence[pulumi.Input['PropertyHostnameCertStatusArgs']]]] = None,
                  cname_type: Optional[pulumi.Input[str]] = None,
                  edge_hostname_id: Optional[pulumi.Input[str]] = None):
-        """
-        :param pulumi.Input[str] cert_provisioning_type: The certificate's provisioning type, either the default `CPS_MANAGED` type for the custom certificates you provision with the [Certificate Provisioning System (CPS)](https://techdocs.akamai.com/cps/docs), or `DEFAULT` for certificates provisioned automatically.
-        :param pulumi.Input[str] cname_from: A string containing the original origin's hostname. For example, `"example.org"`.
-        :param pulumi.Input[str] cname_to: A string containing the hostname for edge content. For example,  `"example.org.edgesuite.net"`.
-        """
         pulumi.set(__self__, "cert_provisioning_type", cert_provisioning_type)
         pulumi.set(__self__, "cname_from", cname_from)
         pulumi.set(__self__, "cname_to", cname_to)
         if cert_statuses is not None:
             pulumi.set(__self__, "cert_statuses", cert_statuses)
         if cname_type is not None:
             pulumi.set(__self__, "cname_type", cname_type)
         if edge_hostname_id is not None:
             pulumi.set(__self__, "edge_hostname_id", edge_hostname_id)
 
     @property
     @pulumi.getter(name="certProvisioningType")
     def cert_provisioning_type(self) -> pulumi.Input[str]:
-        """
-        The certificate's provisioning type, either the default `CPS_MANAGED` type for the custom certificates you provision with the [Certificate Provisioning System (CPS)](https://techdocs.akamai.com/cps/docs), or `DEFAULT` for certificates provisioned automatically.
-        """
         return pulumi.get(self, "cert_provisioning_type")
 
     @cert_provisioning_type.setter
     def cert_provisioning_type(self, value: pulumi.Input[str]):
         pulumi.set(self, "cert_provisioning_type", value)
 
     @property
     @pulumi.getter(name="cnameFrom")
     def cname_from(self) -> pulumi.Input[str]:
-        """
-        A string containing the original origin's hostname. For example, `"example.org"`.
-        """
         return pulumi.get(self, "cname_from")
 
     @cname_from.setter
     def cname_from(self, value: pulumi.Input[str]):
         pulumi.set(self, "cname_from", value)
 
     @property
     @pulumi.getter(name="cnameTo")
     def cname_to(self) -> pulumi.Input[str]:
-        """
-        A string containing the hostname for edge content. For example,  `"example.org.edgesuite.net"`.
-        """
         return pulumi.get(self, "cname_to")
 
     @cname_to.setter
     def cname_to(self, value: pulumi.Input[str]):
         pulumi.set(self, "cname_to", value)
 
     @property
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/properties/cp_code.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/trafficmanagement/gtm_resource.py`

 * *Files 18% similar despite different names*

```diff
@@ -4,544 +4,614 @@
 
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from .. import _utilities
+from . import outputs
+from ._inputs import *
 
-__all__ = ['CpCodeArgs', 'CpCode']
+__all__ = ['GtmResourceArgs', 'GtmResource']
 
 @pulumi.input_type
-class CpCodeArgs:
+class GtmResourceArgs:
     def __init__(__self__, *,
-                 contract: Optional[pulumi.Input[str]] = None,
-                 contract_id: Optional[pulumi.Input[str]] = None,
-                 group: Optional[pulumi.Input[str]] = None,
-                 group_id: Optional[pulumi.Input[str]] = None,
+                 aggregation_type: pulumi.Input[str],
+                 domain: pulumi.Input[str],
+                 type: pulumi.Input[str],
+                 constrained_property: Optional[pulumi.Input[str]] = None,
+                 decay_rate: Optional[pulumi.Input[float]] = None,
+                 description: Optional[pulumi.Input[str]] = None,
+                 host_header: Optional[pulumi.Input[str]] = None,
+                 leader_string: Optional[pulumi.Input[str]] = None,
+                 least_squares_decay: Optional[pulumi.Input[float]] = None,
+                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
+                 max_u_multiplicative_increment: Optional[pulumi.Input[float]] = None,
                  name: Optional[pulumi.Input[str]] = None,
-                 product: Optional[pulumi.Input[str]] = None,
-                 product_id: Optional[pulumi.Input[str]] = None):
-        """
-        The set of arguments for constructing a CpCode resource.
-        :param pulumi.Input[str] contract: Replaced by `contract_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] contract_id: (Required) A contract's unique ID, including the `ctr_` prefix.
-        :param pulumi.Input[str] group: Replaced by `group_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] group_id: (Required) A group's unique ID, including the `grp_` prefix.
-        :param pulumi.Input[str] name: (Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.
-        :param pulumi.Input[str] product: Replaced by `product_id`. Maintained for legacy purposes.
-        """
-        if contract is not None:
-            warnings.warn("""The setting \"contract\" has been deprecated.""", DeprecationWarning)
-            pulumi.log.warn("""contract is deprecated: The setting \"contract\" has been deprecated.""")
-        if contract is not None:
-            pulumi.set(__self__, "contract", contract)
-        if contract_id is not None:
-            pulumi.set(__self__, "contract_id", contract_id)
-        if group is not None:
-            warnings.warn("""The setting \"group\" has been deprecated.""", DeprecationWarning)
-            pulumi.log.warn("""group is deprecated: The setting \"group\" has been deprecated.""")
-        if group is not None:
-            pulumi.set(__self__, "group", group)
-        if group_id is not None:
-            pulumi.set(__self__, "group_id", group_id)
+                 resource_instances: Optional[pulumi.Input[Sequence[pulumi.Input['GtmResourceResourceInstanceArgs']]]] = None,
+                 upper_bound: Optional[pulumi.Input[int]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None):
+        """
+        The set of arguments for constructing a GtmResource resource.
+        """
+        pulumi.set(__self__, "aggregation_type", aggregation_type)
+        pulumi.set(__self__, "domain", domain)
+        pulumi.set(__self__, "type", type)
+        if constrained_property is not None:
+            pulumi.set(__self__, "constrained_property", constrained_property)
+        if decay_rate is not None:
+            pulumi.set(__self__, "decay_rate", decay_rate)
+        if description is not None:
+            pulumi.set(__self__, "description", description)
+        if host_header is not None:
+            pulumi.set(__self__, "host_header", host_header)
+        if leader_string is not None:
+            pulumi.set(__self__, "leader_string", leader_string)
+        if least_squares_decay is not None:
+            pulumi.set(__self__, "least_squares_decay", least_squares_decay)
+        if load_imbalance_percentage is not None:
+            pulumi.set(__self__, "load_imbalance_percentage", load_imbalance_percentage)
+        if max_u_multiplicative_increment is not None:
+            pulumi.set(__self__, "max_u_multiplicative_increment", max_u_multiplicative_increment)
         if name is not None:
             pulumi.set(__self__, "name", name)
-        if product is not None:
-            warnings.warn("""The setting \"product\" has been deprecated.""", DeprecationWarning)
-            pulumi.log.warn("""product is deprecated: The setting \"product\" has been deprecated.""")
-        if product is not None:
-            pulumi.set(__self__, "product", product)
-        if product_id is not None:
-            pulumi.set(__self__, "product_id", product_id)
+        if resource_instances is not None:
+            pulumi.set(__self__, "resource_instances", resource_instances)
+        if upper_bound is not None:
+            pulumi.set(__self__, "upper_bound", upper_bound)
+        if wait_on_complete is not None:
+            pulumi.set(__self__, "wait_on_complete", wait_on_complete)
+
+    @property
+    @pulumi.getter(name="aggregationType")
+    def aggregation_type(self) -> pulumi.Input[str]:
+        return pulumi.get(self, "aggregation_type")
+
+    @aggregation_type.setter
+    def aggregation_type(self, value: pulumi.Input[str]):
+        pulumi.set(self, "aggregation_type", value)
 
     @property
     @pulumi.getter
-    def contract(self) -> Optional[pulumi.Input[str]]:
-        """
-        Replaced by `contract_id`. Maintained for legacy purposes.
-        """
-        return pulumi.get(self, "contract")
+    def domain(self) -> pulumi.Input[str]:
+        return pulumi.get(self, "domain")
 
-    @contract.setter
-    def contract(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "contract", value)
+    @domain.setter
+    def domain(self, value: pulumi.Input[str]):
+        pulumi.set(self, "domain", value)
 
     @property
-    @pulumi.getter(name="contractId")
-    def contract_id(self) -> Optional[pulumi.Input[str]]:
-        """
-        (Required) A contract's unique ID, including the `ctr_` prefix.
-        """
-        return pulumi.get(self, "contract_id")
+    @pulumi.getter
+    def type(self) -> pulumi.Input[str]:
+        return pulumi.get(self, "type")
 
-    @contract_id.setter
-    def contract_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "contract_id", value)
+    @type.setter
+    def type(self, value: pulumi.Input[str]):
+        pulumi.set(self, "type", value)
+
+    @property
+    @pulumi.getter(name="constrainedProperty")
+    def constrained_property(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "constrained_property")
+
+    @constrained_property.setter
+    def constrained_property(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "constrained_property", value)
+
+    @property
+    @pulumi.getter(name="decayRate")
+    def decay_rate(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "decay_rate")
+
+    @decay_rate.setter
+    def decay_rate(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "decay_rate", value)
 
     @property
     @pulumi.getter
-    def group(self) -> Optional[pulumi.Input[str]]:
-        """
-        Replaced by `group_id`. Maintained for legacy purposes.
-        """
-        return pulumi.get(self, "group")
+    def description(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "description")
 
-    @group.setter
-    def group(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "group", value)
+    @description.setter
+    def description(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "description", value)
 
     @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> Optional[pulumi.Input[str]]:
-        """
-        (Required) A group's unique ID, including the `grp_` prefix.
-        """
-        return pulumi.get(self, "group_id")
+    @pulumi.getter(name="hostHeader")
+    def host_header(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "host_header")
+
+    @host_header.setter
+    def host_header(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "host_header", value)
+
+    @property
+    @pulumi.getter(name="leaderString")
+    def leader_string(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "leader_string")
 
-    @group_id.setter
-    def group_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "group_id", value)
+    @leader_string.setter
+    def leader_string(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "leader_string", value)
+
+    @property
+    @pulumi.getter(name="leastSquaresDecay")
+    def least_squares_decay(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "least_squares_decay")
+
+    @least_squares_decay.setter
+    def least_squares_decay(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "least_squares_decay", value)
+
+    @property
+    @pulumi.getter(name="loadImbalancePercentage")
+    def load_imbalance_percentage(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "load_imbalance_percentage")
+
+    @load_imbalance_percentage.setter
+    def load_imbalance_percentage(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "load_imbalance_percentage", value)
+
+    @property
+    @pulumi.getter(name="maxUMultiplicativeIncrement")
+    def max_u_multiplicative_increment(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "max_u_multiplicative_increment")
+
+    @max_u_multiplicative_increment.setter
+    def max_u_multiplicative_increment(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "max_u_multiplicative_increment", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
-        """
-        (Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.
-        """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
-    @pulumi.getter
-    def product(self) -> Optional[pulumi.Input[str]]:
-        """
-        Replaced by `product_id`. Maintained for legacy purposes.
-        """
-        return pulumi.get(self, "product")
+    @pulumi.getter(name="resourceInstances")
+    def resource_instances(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmResourceResourceInstanceArgs']]]]:
+        return pulumi.get(self, "resource_instances")
+
+    @resource_instances.setter
+    def resource_instances(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmResourceResourceInstanceArgs']]]]):
+        pulumi.set(self, "resource_instances", value)
+
+    @property
+    @pulumi.getter(name="upperBound")
+    def upper_bound(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "upper_bound")
 
-    @product.setter
-    def product(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "product", value)
+    @upper_bound.setter
+    def upper_bound(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "upper_bound", value)
 
     @property
-    @pulumi.getter(name="productId")
-    def product_id(self) -> Optional[pulumi.Input[str]]:
-        return pulumi.get(self, "product_id")
+    @pulumi.getter(name="waitOnComplete")
+    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "wait_on_complete")
 
-    @product_id.setter
-    def product_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "product_id", value)
+    @wait_on_complete.setter
+    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "wait_on_complete", value)
 
 
 @pulumi.input_type
-class _CpCodeState:
+class _GtmResourceState:
     def __init__(__self__, *,
-                 contract: Optional[pulumi.Input[str]] = None,
-                 contract_id: Optional[pulumi.Input[str]] = None,
-                 group: Optional[pulumi.Input[str]] = None,
-                 group_id: Optional[pulumi.Input[str]] = None,
+                 aggregation_type: Optional[pulumi.Input[str]] = None,
+                 constrained_property: Optional[pulumi.Input[str]] = None,
+                 decay_rate: Optional[pulumi.Input[float]] = None,
+                 description: Optional[pulumi.Input[str]] = None,
+                 domain: Optional[pulumi.Input[str]] = None,
+                 host_header: Optional[pulumi.Input[str]] = None,
+                 leader_string: Optional[pulumi.Input[str]] = None,
+                 least_squares_decay: Optional[pulumi.Input[float]] = None,
+                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
+                 max_u_multiplicative_increment: Optional[pulumi.Input[float]] = None,
                  name: Optional[pulumi.Input[str]] = None,
-                 product: Optional[pulumi.Input[str]] = None,
-                 product_id: Optional[pulumi.Input[str]] = None):
-        """
-        Input properties used for looking up and filtering CpCode resources.
-        :param pulumi.Input[str] contract: Replaced by `contract_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] contract_id: (Required) A contract's unique ID, including the `ctr_` prefix.
-        :param pulumi.Input[str] group: Replaced by `group_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] group_id: (Required) A group's unique ID, including the `grp_` prefix.
-        :param pulumi.Input[str] name: (Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.
-        :param pulumi.Input[str] product: Replaced by `product_id`. Maintained for legacy purposes.
-        """
-        if contract is not None:
-            warnings.warn("""The setting \"contract\" has been deprecated.""", DeprecationWarning)
-            pulumi.log.warn("""contract is deprecated: The setting \"contract\" has been deprecated.""")
-        if contract is not None:
-            pulumi.set(__self__, "contract", contract)
-        if contract_id is not None:
-            pulumi.set(__self__, "contract_id", contract_id)
-        if group is not None:
-            warnings.warn("""The setting \"group\" has been deprecated.""", DeprecationWarning)
-            pulumi.log.warn("""group is deprecated: The setting \"group\" has been deprecated.""")
-        if group is not None:
-            pulumi.set(__self__, "group", group)
-        if group_id is not None:
-            pulumi.set(__self__, "group_id", group_id)
+                 resource_instances: Optional[pulumi.Input[Sequence[pulumi.Input['GtmResourceResourceInstanceArgs']]]] = None,
+                 type: Optional[pulumi.Input[str]] = None,
+                 upper_bound: Optional[pulumi.Input[int]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None):
+        """
+        Input properties used for looking up and filtering GtmResource resources.
+        """
+        if aggregation_type is not None:
+            pulumi.set(__self__, "aggregation_type", aggregation_type)
+        if constrained_property is not None:
+            pulumi.set(__self__, "constrained_property", constrained_property)
+        if decay_rate is not None:
+            pulumi.set(__self__, "decay_rate", decay_rate)
+        if description is not None:
+            pulumi.set(__self__, "description", description)
+        if domain is not None:
+            pulumi.set(__self__, "domain", domain)
+        if host_header is not None:
+            pulumi.set(__self__, "host_header", host_header)
+        if leader_string is not None:
+            pulumi.set(__self__, "leader_string", leader_string)
+        if least_squares_decay is not None:
+            pulumi.set(__self__, "least_squares_decay", least_squares_decay)
+        if load_imbalance_percentage is not None:
+            pulumi.set(__self__, "load_imbalance_percentage", load_imbalance_percentage)
+        if max_u_multiplicative_increment is not None:
+            pulumi.set(__self__, "max_u_multiplicative_increment", max_u_multiplicative_increment)
         if name is not None:
             pulumi.set(__self__, "name", name)
-        if product is not None:
-            warnings.warn("""The setting \"product\" has been deprecated.""", DeprecationWarning)
-            pulumi.log.warn("""product is deprecated: The setting \"product\" has been deprecated.""")
-        if product is not None:
-            pulumi.set(__self__, "product", product)
-        if product_id is not None:
-            pulumi.set(__self__, "product_id", product_id)
+        if resource_instances is not None:
+            pulumi.set(__self__, "resource_instances", resource_instances)
+        if type is not None:
+            pulumi.set(__self__, "type", type)
+        if upper_bound is not None:
+            pulumi.set(__self__, "upper_bound", upper_bound)
+        if wait_on_complete is not None:
+            pulumi.set(__self__, "wait_on_complete", wait_on_complete)
 
     @property
-    @pulumi.getter
-    def contract(self) -> Optional[pulumi.Input[str]]:
-        """
-        Replaced by `contract_id`. Maintained for legacy purposes.
-        """
-        return pulumi.get(self, "contract")
+    @pulumi.getter(name="aggregationType")
+    def aggregation_type(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "aggregation_type")
 
-    @contract.setter
-    def contract(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "contract", value)
+    @aggregation_type.setter
+    def aggregation_type(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "aggregation_type", value)
 
     @property
-    @pulumi.getter(name="contractId")
-    def contract_id(self) -> Optional[pulumi.Input[str]]:
-        """
-        (Required) A contract's unique ID, including the `ctr_` prefix.
-        """
-        return pulumi.get(self, "contract_id")
+    @pulumi.getter(name="constrainedProperty")
+    def constrained_property(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "constrained_property")
 
-    @contract_id.setter
-    def contract_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "contract_id", value)
+    @constrained_property.setter
+    def constrained_property(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "constrained_property", value)
 
     @property
-    @pulumi.getter
-    def group(self) -> Optional[pulumi.Input[str]]:
-        """
-        Replaced by `group_id`. Maintained for legacy purposes.
-        """
-        return pulumi.get(self, "group")
+    @pulumi.getter(name="decayRate")
+    def decay_rate(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "decay_rate")
 
-    @group.setter
-    def group(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "group", value)
+    @decay_rate.setter
+    def decay_rate(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "decay_rate", value)
 
     @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> Optional[pulumi.Input[str]]:
-        """
-        (Required) A group's unique ID, including the `grp_` prefix.
-        """
-        return pulumi.get(self, "group_id")
+    @pulumi.getter
+    def description(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "description")
 
-    @group_id.setter
-    def group_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "group_id", value)
+    @description.setter
+    def description(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter
-    def name(self) -> Optional[pulumi.Input[str]]:
-        """
-        (Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.
-        """
-        return pulumi.get(self, "name")
+    def domain(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "domain")
 
-    @name.setter
-    def name(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "name", value)
+    @domain.setter
+    def domain(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "domain", value)
 
     @property
-    @pulumi.getter
-    def product(self) -> Optional[pulumi.Input[str]]:
-        """
-        Replaced by `product_id`. Maintained for legacy purposes.
-        """
-        return pulumi.get(self, "product")
+    @pulumi.getter(name="hostHeader")
+    def host_header(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "host_header")
 
-    @product.setter
-    def product(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "product", value)
+    @host_header.setter
+    def host_header(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "host_header", value)
 
     @property
-    @pulumi.getter(name="productId")
-    def product_id(self) -> Optional[pulumi.Input[str]]:
-        return pulumi.get(self, "product_id")
+    @pulumi.getter(name="leaderString")
+    def leader_string(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "leader_string")
 
-    @product_id.setter
-    def product_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "product_id", value)
+    @leader_string.setter
+    def leader_string(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "leader_string", value)
 
+    @property
+    @pulumi.getter(name="leastSquaresDecay")
+    def least_squares_decay(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "least_squares_decay")
 
-warnings.warn("""akamai.properties.CpCode has been deprecated in favor of akamai.CpCode""", DeprecationWarning)
+    @least_squares_decay.setter
+    def least_squares_decay(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "least_squares_decay", value)
 
+    @property
+    @pulumi.getter(name="loadImbalancePercentage")
+    def load_imbalance_percentage(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "load_imbalance_percentage")
 
-class CpCode(pulumi.CustomResource):
-    warnings.warn("""akamai.properties.CpCode has been deprecated in favor of akamai.CpCode""", DeprecationWarning)
+    @load_imbalance_percentage.setter
+    def load_imbalance_percentage(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "load_imbalance_percentage", value)
 
-    @overload
-    def __init__(__self__,
-                 resource_name: str,
-                 opts: Optional[pulumi.ResourceOptions] = None,
-                 contract: Optional[pulumi.Input[str]] = None,
-                 contract_id: Optional[pulumi.Input[str]] = None,
-                 group: Optional[pulumi.Input[str]] = None,
-                 group_id: Optional[pulumi.Input[str]] = None,
-                 name: Optional[pulumi.Input[str]] = None,
-                 product: Optional[pulumi.Input[str]] = None,
-                 product_id: Optional[pulumi.Input[str]] = None,
-                 __props__=None):
-        """
-        The `CpCode` resource lets you create or reuse content provider (CP) codes.  CP codes track web traffic handled by Akamai servers. Akamai gives you a CP code when you purchase a product. You need this code when you activate associated properties.
+    @property
+    @pulumi.getter(name="maxUMultiplicativeIncrement")
+    def max_u_multiplicative_increment(self) -> Optional[pulumi.Input[float]]:
+        return pulumi.get(self, "max_u_multiplicative_increment")
 
-        You can create additional CP codes to support more detailed billing and reporting functions.
+    @max_u_multiplicative_increment.setter
+    def max_u_multiplicative_increment(self, value: Optional[pulumi.Input[float]]):
+        pulumi.set(self, "max_u_multiplicative_increment", value)
 
-        By default, the Akamai Provider uses your existing CP code instead of creating a new one.
+    @property
+    @pulumi.getter
+    def name(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "name")
 
-        ## Example Usage
+    @name.setter
+    def name(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "name", value)
 
-        Basic usage:
+    @property
+    @pulumi.getter(name="resourceInstances")
+    def resource_instances(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmResourceResourceInstanceArgs']]]]:
+        return pulumi.get(self, "resource_instances")
 
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
+    @resource_instances.setter
+    def resource_instances(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmResourceResourceInstanceArgs']]]]):
+        pulumi.set(self, "resource_instances", value)
 
-        cp_code = akamai.CpCode("cpCode",
-            contract_id=akamai_contract["contract"]["id"],
-            group_id=akamai_group["group"]["id"],
-            product_id="prd_Object_Delivery")
-        ```
+    @property
+    @pulumi.getter
+    def type(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "type")
 
-        Here's a real-life example that includes other data sources as dependencies:
+    @type.setter
+    def type(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "type", value)
 
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
+    @property
+    @pulumi.getter(name="upperBound")
+    def upper_bound(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "upper_bound")
 
-        group_name = "example group name"
-        cpcode_name = "My CP Code"
-        example_contract = akamai.get_contract(group_name=group_name)
-        example_group = akamai.get_group(name=group_name,
-            contract_id=example_contract.id)
-        example_cp = akamai.CpCode("exampleCp",
-            group_id=example_group.id,
-            contract_id=example_contract.id,
-            product_id="prd_Object_Delivery")
-        ```
-        ## Attributes reference
+    @upper_bound.setter
+    def upper_bound(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "upper_bound", value)
 
-        * `id` - The ID of the CP code.
+    @property
+    @pulumi.getter(name="waitOnComplete")
+    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
+        return pulumi.get(self, "wait_on_complete")
 
-        ## Import
+    @wait_on_complete.setter
+    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "wait_on_complete", value)
 
-        Basic Usagehcl resource "akamai_cp_code" "example" {
 
-        # (resource arguments)
+warnings.warn("""akamai.trafficmanagement.GtmResource has been deprecated in favor of akamai.GtmResource""", DeprecationWarning)
 
-         } You can import your Akamai CP codes using a comma-delimited string of the CP code, contract, and group IDs. You have to enter the IDs in this order`cpcode_id,contract_id,group_id` For example
 
-        ```sh
-         $ pulumi import akamai:properties/cpCode:CpCode example cpc_123,ctr_1-AB123,grp_123
-        ```
+class GtmResource(pulumi.CustomResource):
+    warnings.warn("""akamai.trafficmanagement.GtmResource has been deprecated in favor of akamai.GtmResource""", DeprecationWarning)
 
+    @overload
+    def __init__(__self__,
+                 resource_name: str,
+                 opts: Optional[pulumi.ResourceOptions] = None,
+                 aggregation_type: Optional[pulumi.Input[str]] = None,
+                 constrained_property: Optional[pulumi.Input[str]] = None,
+                 decay_rate: Optional[pulumi.Input[float]] = None,
+                 description: Optional[pulumi.Input[str]] = None,
+                 domain: Optional[pulumi.Input[str]] = None,
+                 host_header: Optional[pulumi.Input[str]] = None,
+                 leader_string: Optional[pulumi.Input[str]] = None,
+                 least_squares_decay: Optional[pulumi.Input[float]] = None,
+                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
+                 max_u_multiplicative_increment: Optional[pulumi.Input[float]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
+                 resource_instances: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmResourceResourceInstanceArgs']]]]] = None,
+                 type: Optional[pulumi.Input[str]] = None,
+                 upper_bound: Optional[pulumi.Input[int]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
+                 __props__=None):
+        """
+        Create a GtmResource resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] contract: Replaced by `contract_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] contract_id: (Required) A contract's unique ID, including the `ctr_` prefix.
-        :param pulumi.Input[str] group: Replaced by `group_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] group_id: (Required) A group's unique ID, including the `grp_` prefix.
-        :param pulumi.Input[str] name: (Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.
-        :param pulumi.Input[str] product: Replaced by `product_id`. Maintained for legacy purposes.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: Optional[CpCodeArgs] = None,
+                 args: GtmResourceArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        The `CpCode` resource lets you create or reuse content provider (CP) codes.  CP codes track web traffic handled by Akamai servers. Akamai gives you a CP code when you purchase a product. You need this code when you activate associated properties.
-
-        You can create additional CP codes to support more detailed billing and reporting functions.
-
-        By default, the Akamai Provider uses your existing CP code instead of creating a new one.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        cp_code = akamai.CpCode("cpCode",
-            contract_id=akamai_contract["contract"]["id"],
-            group_id=akamai_group["group"]["id"],
-            product_id="prd_Object_Delivery")
-        ```
-
-        Here's a real-life example that includes other data sources as dependencies:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        group_name = "example group name"
-        cpcode_name = "My CP Code"
-        example_contract = akamai.get_contract(group_name=group_name)
-        example_group = akamai.get_group(name=group_name,
-            contract_id=example_contract.id)
-        example_cp = akamai.CpCode("exampleCp",
-            group_id=example_group.id,
-            contract_id=example_contract.id,
-            product_id="prd_Object_Delivery")
-        ```
-        ## Attributes reference
-
-        * `id` - The ID of the CP code.
-
-        ## Import
-
-        Basic Usagehcl resource "akamai_cp_code" "example" {
-
-        # (resource arguments)
-
-         } You can import your Akamai CP codes using a comma-delimited string of the CP code, contract, and group IDs. You have to enter the IDs in this order`cpcode_id,contract_id,group_id` For example
-
-        ```sh
-         $ pulumi import akamai:properties/cpCode:CpCode example cpc_123,ctr_1-AB123,grp_123
-        ```
-
+        Create a GtmResource resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param CpCodeArgs args: The arguments to use to populate this resource's properties.
+        :param GtmResourceArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(CpCodeArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(GtmResourceArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 contract: Optional[pulumi.Input[str]] = None,
-                 contract_id: Optional[pulumi.Input[str]] = None,
-                 group: Optional[pulumi.Input[str]] = None,
-                 group_id: Optional[pulumi.Input[str]] = None,
+                 aggregation_type: Optional[pulumi.Input[str]] = None,
+                 constrained_property: Optional[pulumi.Input[str]] = None,
+                 decay_rate: Optional[pulumi.Input[float]] = None,
+                 description: Optional[pulumi.Input[str]] = None,
+                 domain: Optional[pulumi.Input[str]] = None,
+                 host_header: Optional[pulumi.Input[str]] = None,
+                 leader_string: Optional[pulumi.Input[str]] = None,
+                 least_squares_decay: Optional[pulumi.Input[float]] = None,
+                 load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
+                 max_u_multiplicative_increment: Optional[pulumi.Input[float]] = None,
                  name: Optional[pulumi.Input[str]] = None,
-                 product: Optional[pulumi.Input[str]] = None,
-                 product_id: Optional[pulumi.Input[str]] = None,
+                 resource_instances: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmResourceResourceInstanceArgs']]]]] = None,
+                 type: Optional[pulumi.Input[str]] = None,
+                 upper_bound: Optional[pulumi.Input[int]] = None,
+                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
                  __props__=None):
-        pulumi.log.warn("""CpCode is deprecated: akamai.properties.CpCode has been deprecated in favor of akamai.CpCode""")
+        pulumi.log.warn("""GtmResource is deprecated: akamai.trafficmanagement.GtmResource has been deprecated in favor of akamai.GtmResource""")
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = CpCodeArgs.__new__(CpCodeArgs)
+            __props__ = GtmResourceArgs.__new__(GtmResourceArgs)
 
-            if contract is not None and not opts.urn:
-                warnings.warn("""The setting \"contract\" has been deprecated.""", DeprecationWarning)
-                pulumi.log.warn("""contract is deprecated: The setting \"contract\" has been deprecated.""")
-            __props__.__dict__["contract"] = contract
-            __props__.__dict__["contract_id"] = contract_id
-            if group is not None and not opts.urn:
-                warnings.warn("""The setting \"group\" has been deprecated.""", DeprecationWarning)
-                pulumi.log.warn("""group is deprecated: The setting \"group\" has been deprecated.""")
-            __props__.__dict__["group"] = group
-            __props__.__dict__["group_id"] = group_id
+            if aggregation_type is None and not opts.urn:
+                raise TypeError("Missing required property 'aggregation_type'")
+            __props__.__dict__["aggregation_type"] = aggregation_type
+            __props__.__dict__["constrained_property"] = constrained_property
+            __props__.__dict__["decay_rate"] = decay_rate
+            __props__.__dict__["description"] = description
+            if domain is None and not opts.urn:
+                raise TypeError("Missing required property 'domain'")
+            __props__.__dict__["domain"] = domain
+            __props__.__dict__["host_header"] = host_header
+            __props__.__dict__["leader_string"] = leader_string
+            __props__.__dict__["least_squares_decay"] = least_squares_decay
+            __props__.__dict__["load_imbalance_percentage"] = load_imbalance_percentage
+            __props__.__dict__["max_u_multiplicative_increment"] = max_u_multiplicative_increment
             __props__.__dict__["name"] = name
-            if product is not None and not opts.urn:
-                warnings.warn("""The setting \"product\" has been deprecated.""", DeprecationWarning)
-                pulumi.log.warn("""product is deprecated: The setting \"product\" has been deprecated.""")
-            __props__.__dict__["product"] = product
-            __props__.__dict__["product_id"] = product_id
-        super(CpCode, __self__).__init__(
-            'akamai:properties/cpCode:CpCode',
+            __props__.__dict__["resource_instances"] = resource_instances
+            if type is None and not opts.urn:
+                raise TypeError("Missing required property 'type'")
+            __props__.__dict__["type"] = type
+            __props__.__dict__["upper_bound"] = upper_bound
+            __props__.__dict__["wait_on_complete"] = wait_on_complete
+        super(GtmResource, __self__).__init__(
+            'akamai:trafficmanagement/gtmResource:GtmResource',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
-            contract: Optional[pulumi.Input[str]] = None,
-            contract_id: Optional[pulumi.Input[str]] = None,
-            group: Optional[pulumi.Input[str]] = None,
-            group_id: Optional[pulumi.Input[str]] = None,
+            aggregation_type: Optional[pulumi.Input[str]] = None,
+            constrained_property: Optional[pulumi.Input[str]] = None,
+            decay_rate: Optional[pulumi.Input[float]] = None,
+            description: Optional[pulumi.Input[str]] = None,
+            domain: Optional[pulumi.Input[str]] = None,
+            host_header: Optional[pulumi.Input[str]] = None,
+            leader_string: Optional[pulumi.Input[str]] = None,
+            least_squares_decay: Optional[pulumi.Input[float]] = None,
+            load_imbalance_percentage: Optional[pulumi.Input[float]] = None,
+            max_u_multiplicative_increment: Optional[pulumi.Input[float]] = None,
             name: Optional[pulumi.Input[str]] = None,
-            product: Optional[pulumi.Input[str]] = None,
-            product_id: Optional[pulumi.Input[str]] = None) -> 'CpCode':
+            resource_instances: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmResourceResourceInstanceArgs']]]]] = None,
+            type: Optional[pulumi.Input[str]] = None,
+            upper_bound: Optional[pulumi.Input[int]] = None,
+            wait_on_complete: Optional[pulumi.Input[bool]] = None) -> 'GtmResource':
         """
-        Get an existing CpCode resource's state with the given name, id, and optional extra
+        Get an existing GtmResource resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] contract: Replaced by `contract_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] contract_id: (Required) A contract's unique ID, including the `ctr_` prefix.
-        :param pulumi.Input[str] group: Replaced by `group_id`. Maintained for legacy purposes.
-        :param pulumi.Input[str] group_id: (Required) A group's unique ID, including the `grp_` prefix.
-        :param pulumi.Input[str] name: (Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.
-        :param pulumi.Input[str] product: Replaced by `product_id`. Maintained for legacy purposes.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _CpCodeState.__new__(_CpCodeState)
+        __props__ = _GtmResourceState.__new__(_GtmResourceState)
 
-        __props__.__dict__["contract"] = contract
-        __props__.__dict__["contract_id"] = contract_id
-        __props__.__dict__["group"] = group
-        __props__.__dict__["group_id"] = group_id
+        __props__.__dict__["aggregation_type"] = aggregation_type
+        __props__.__dict__["constrained_property"] = constrained_property
+        __props__.__dict__["decay_rate"] = decay_rate
+        __props__.__dict__["description"] = description
+        __props__.__dict__["domain"] = domain
+        __props__.__dict__["host_header"] = host_header
+        __props__.__dict__["leader_string"] = leader_string
+        __props__.__dict__["least_squares_decay"] = least_squares_decay
+        __props__.__dict__["load_imbalance_percentage"] = load_imbalance_percentage
+        __props__.__dict__["max_u_multiplicative_increment"] = max_u_multiplicative_increment
         __props__.__dict__["name"] = name
-        __props__.__dict__["product"] = product
-        __props__.__dict__["product_id"] = product_id
-        return CpCode(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["resource_instances"] = resource_instances
+        __props__.__dict__["type"] = type
+        __props__.__dict__["upper_bound"] = upper_bound
+        __props__.__dict__["wait_on_complete"] = wait_on_complete
+        return GtmResource(resource_name, opts=opts, __props__=__props__)
 
     @property
-    @pulumi.getter
-    def contract(self) -> pulumi.Output[str]:
-        """
-        Replaced by `contract_id`. Maintained for legacy purposes.
-        """
-        return pulumi.get(self, "contract")
+    @pulumi.getter(name="aggregationType")
+    def aggregation_type(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "aggregation_type")
 
     @property
-    @pulumi.getter(name="contractId")
-    def contract_id(self) -> pulumi.Output[str]:
-        """
-        (Required) A contract's unique ID, including the `ctr_` prefix.
-        """
-        return pulumi.get(self, "contract_id")
+    @pulumi.getter(name="constrainedProperty")
+    def constrained_property(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "constrained_property")
+
+    @property
+    @pulumi.getter(name="decayRate")
+    def decay_rate(self) -> pulumi.Output[Optional[float]]:
+        return pulumi.get(self, "decay_rate")
 
     @property
     @pulumi.getter
-    def group(self) -> pulumi.Output[str]:
-        """
-        Replaced by `group_id`. Maintained for legacy purposes.
-        """
-        return pulumi.get(self, "group")
+    def description(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "description")
 
     @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> pulumi.Output[str]:
-        """
-        (Required) A group's unique ID, including the `grp_` prefix.
-        """
-        return pulumi.get(self, "group_id")
+    @pulumi.getter
+    def domain(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "domain")
+
+    @property
+    @pulumi.getter(name="hostHeader")
+    def host_header(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "host_header")
+
+    @property
+    @pulumi.getter(name="leaderString")
+    def leader_string(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "leader_string")
+
+    @property
+    @pulumi.getter(name="leastSquaresDecay")
+    def least_squares_decay(self) -> pulumi.Output[Optional[float]]:
+        return pulumi.get(self, "least_squares_decay")
+
+    @property
+    @pulumi.getter(name="loadImbalancePercentage")
+    def load_imbalance_percentage(self) -> pulumi.Output[Optional[float]]:
+        return pulumi.get(self, "load_imbalance_percentage")
+
+    @property
+    @pulumi.getter(name="maxUMultiplicativeIncrement")
+    def max_u_multiplicative_increment(self) -> pulumi.Output[Optional[float]]:
+        return pulumi.get(self, "max_u_multiplicative_increment")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
-        """
-        (Required) A descriptive label for the CP code. If you're creating a new CP code, the name can't include commas, underscores, quotes, or any of these special characters: ^ # %.
-        """
         return pulumi.get(self, "name")
 
     @property
+    @pulumi.getter(name="resourceInstances")
+    def resource_instances(self) -> pulumi.Output[Optional[Sequence['outputs.GtmResourceResourceInstance']]]:
+        return pulumi.get(self, "resource_instances")
+
+    @property
     @pulumi.getter
-    def product(self) -> pulumi.Output[str]:
-        """
-        Replaced by `product_id`. Maintained for legacy purposes.
-        """
-        return pulumi.get(self, "product")
+    def type(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "type")
+
+    @property
+    @pulumi.getter(name="upperBound")
+    def upper_bound(self) -> pulumi.Output[Optional[int]]:
+        return pulumi.get(self, "upper_bound")
 
     @property
-    @pulumi.getter(name="productId")
-    def product_id(self) -> pulumi.Output[str]:
-        return pulumi.get(self, "product_id")
+    @pulumi.getter(name="waitOnComplete")
+    def wait_on_complete(self) -> pulumi.Output[Optional[bool]]:
+        return pulumi.get(self, "wait_on_complete")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/properties/get_cp_code.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_property_include_activation.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,161 +3,154 @@
 # *** Do not edit by hand unless you're certain you know what you are doing! ***
 
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
-from .. import _utilities
+from . import _utilities
 
 __all__ = [
-    'GetCpCodeResult',
-    'AwaitableGetCpCodeResult',
-    'get_cp_code',
-    'get_cp_code_output',
+    'GetPropertyIncludeActivationResult',
+    'AwaitableGetPropertyIncludeActivationResult',
+    'get_property_include_activation',
+    'get_property_include_activation_output',
 ]
 
-warnings.warn("""akamai.properties.getCpCode has been deprecated in favor of akamai.getCpCode""", DeprecationWarning)
-
 @pulumi.output_type
-class GetCpCodeResult:
+class GetPropertyIncludeActivationResult:
     """
-    A collection of values returned by getCpCode.
+    A collection of values returned by getPropertyIncludeActivation.
     """
-    def __init__(__self__, contract=None, contract_id=None, group=None, group_id=None, id=None, name=None, product_ids=None):
-        if contract and not isinstance(contract, str):
-            raise TypeError("Expected argument 'contract' to be a str")
-        if contract is not None:
-            warnings.warn("""The setting \"contract\" has been deprecated.""", DeprecationWarning)
-            pulumi.log.warn("""contract is deprecated: The setting \"contract\" has been deprecated.""")
-
-        pulumi.set(__self__, "contract", contract)
+    def __init__(__self__, contract_id=None, group_id=None, id=None, include_id=None, name=None, network=None, note=None, notify_emails=None, version=None):
         if contract_id and not isinstance(contract_id, str):
             raise TypeError("Expected argument 'contract_id' to be a str")
         pulumi.set(__self__, "contract_id", contract_id)
-        if group and not isinstance(group, str):
-            raise TypeError("Expected argument 'group' to be a str")
-        if group is not None:
-            warnings.warn("""The setting \"group\" has been deprecated.""", DeprecationWarning)
-            pulumi.log.warn("""group is deprecated: The setting \"group\" has been deprecated.""")
-
-        pulumi.set(__self__, "group", group)
         if group_id and not isinstance(group_id, str):
             raise TypeError("Expected argument 'group_id' to be a str")
         pulumi.set(__self__, "group_id", group_id)
         if id and not isinstance(id, str):
             raise TypeError("Expected argument 'id' to be a str")
         pulumi.set(__self__, "id", id)
+        if include_id and not isinstance(include_id, str):
+            raise TypeError("Expected argument 'include_id' to be a str")
+        pulumi.set(__self__, "include_id", include_id)
         if name and not isinstance(name, str):
             raise TypeError("Expected argument 'name' to be a str")
         pulumi.set(__self__, "name", name)
-        if product_ids and not isinstance(product_ids, list):
-            raise TypeError("Expected argument 'product_ids' to be a list")
-        pulumi.set(__self__, "product_ids", product_ids)
-
-    @property
-    @pulumi.getter
-    def contract(self) -> str:
-        return pulumi.get(self, "contract")
+        if network and not isinstance(network, str):
+            raise TypeError("Expected argument 'network' to be a str")
+        pulumi.set(__self__, "network", network)
+        if note and not isinstance(note, str):
+            raise TypeError("Expected argument 'note' to be a str")
+        pulumi.set(__self__, "note", note)
+        if notify_emails and not isinstance(notify_emails, list):
+            raise TypeError("Expected argument 'notify_emails' to be a list")
+        pulumi.set(__self__, "notify_emails", notify_emails)
+        if version and not isinstance(version, str):
+            raise TypeError("Expected argument 'version' to be a str")
+        pulumi.set(__self__, "version", version)
 
     @property
     @pulumi.getter(name="contractId")
     def contract_id(self) -> str:
         return pulumi.get(self, "contract_id")
 
     @property
-    @pulumi.getter
-    def group(self) -> str:
-        return pulumi.get(self, "group")
-
-    @property
     @pulumi.getter(name="groupId")
     def group_id(self) -> str:
         return pulumi.get(self, "group_id")
 
     @property
     @pulumi.getter
     def id(self) -> str:
         """
         The provider-assigned unique ID for this managed resource.
         """
         return pulumi.get(self, "id")
 
     @property
+    @pulumi.getter(name="includeId")
+    def include_id(self) -> str:
+        return pulumi.get(self, "include_id")
+
+    @property
     @pulumi.getter
     def name(self) -> str:
         return pulumi.get(self, "name")
 
     @property
-    @pulumi.getter(name="productIds")
-    def product_ids(self) -> Sequence[str]:
-        return pulumi.get(self, "product_ids")
+    @pulumi.getter
+    def network(self) -> str:
+        return pulumi.get(self, "network")
+
+    @property
+    @pulumi.getter
+    def note(self) -> str:
+        return pulumi.get(self, "note")
 
+    @property
+    @pulumi.getter(name="notifyEmails")
+    def notify_emails(self) -> Sequence[str]:
+        return pulumi.get(self, "notify_emails")
 
-class AwaitableGetCpCodeResult(GetCpCodeResult):
+    @property
+    @pulumi.getter
+    def version(self) -> str:
+        return pulumi.get(self, "version")
+
+
+class AwaitableGetPropertyIncludeActivationResult(GetPropertyIncludeActivationResult):
     # pylint: disable=using-constant-test
     def __await__(self):
         if False:
             yield self
-        return GetCpCodeResult(
-            contract=self.contract,
+        return GetPropertyIncludeActivationResult(
             contract_id=self.contract_id,
-            group=self.group,
             group_id=self.group_id,
             id=self.id,
+            include_id=self.include_id,
             name=self.name,
-            product_ids=self.product_ids)
+            network=self.network,
+            note=self.note,
+            notify_emails=self.notify_emails,
+            version=self.version)
 
 
-def get_cp_code(contract: Optional[str] = None,
-                contract_id: Optional[str] = None,
-                group: Optional[str] = None,
-                group_id: Optional[str] = None,
-                name: Optional[str] = None,
-                opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetCpCodeResult:
+def get_property_include_activation(contract_id: Optional[str] = None,
+                                    group_id: Optional[str] = None,
+                                    include_id: Optional[str] = None,
+                                    network: Optional[str] = None,
+                                    opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetPropertyIncludeActivationResult:
     """
     Use this data source to access information about an existing resource.
-
-    :param str contract: Replaced by `contract_id`. Maintained for legacy purposes.
-    :param str contract_id: (Required) A contract's unique ID, including the `ctr_` prefix.
-    :param str group: Replaced by `group_id`. Maintained for legacy purposes.
-    :param str group_id: The group's unique ID, including the `grp_` prefix.
-    :param str name: The name of the CP code.
     """
-    pulumi.log.warn("""get_cp_code is deprecated: akamai.properties.getCpCode has been deprecated in favor of akamai.getCpCode""")
     __args__ = dict()
-    __args__['contract'] = contract
     __args__['contractId'] = contract_id
-    __args__['group'] = group
     __args__['groupId'] = group_id
-    __args__['name'] = name
+    __args__['includeId'] = include_id
+    __args__['network'] = network
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
-    __ret__ = pulumi.runtime.invoke('akamai:properties/getCpCode:getCpCode', __args__, opts=opts, typ=GetCpCodeResult).value
+    __ret__ = pulumi.runtime.invoke('akamai:index/getPropertyIncludeActivation:getPropertyIncludeActivation', __args__, opts=opts, typ=GetPropertyIncludeActivationResult).value
 
-    return AwaitableGetCpCodeResult(
-        contract=__ret__.contract,
+    return AwaitableGetPropertyIncludeActivationResult(
         contract_id=__ret__.contract_id,
-        group=__ret__.group,
         group_id=__ret__.group_id,
         id=__ret__.id,
+        include_id=__ret__.include_id,
         name=__ret__.name,
-        product_ids=__ret__.product_ids)
+        network=__ret__.network,
+        note=__ret__.note,
+        notify_emails=__ret__.notify_emails,
+        version=__ret__.version)
 
 
-@_utilities.lift_output_func(get_cp_code)
-def get_cp_code_output(contract: Optional[pulumi.Input[Optional[str]]] = None,
-                       contract_id: Optional[pulumi.Input[Optional[str]]] = None,
-                       group: Optional[pulumi.Input[Optional[str]]] = None,
-                       group_id: Optional[pulumi.Input[Optional[str]]] = None,
-                       name: Optional[pulumi.Input[str]] = None,
-                       opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetCpCodeResult]:
+@_utilities.lift_output_func(get_property_include_activation)
+def get_property_include_activation_output(contract_id: Optional[pulumi.Input[str]] = None,
+                                           group_id: Optional[pulumi.Input[str]] = None,
+                                           include_id: Optional[pulumi.Input[str]] = None,
+                                           network: Optional[pulumi.Input[str]] = None,
+                                           opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetPropertyIncludeActivationResult]:
     """
     Use this data source to access information about an existing resource.
-
-    :param str contract: Replaced by `contract_id`. Maintained for legacy purposes.
-    :param str contract_id: (Required) A contract's unique ID, including the `ctr_` prefix.
-    :param str group: Replaced by `group_id`. Maintained for legacy purposes.
-    :param str group_id: The group's unique ID, including the `grp_` prefix.
-    :param str name: The name of the CP code.
     """
-    pulumi.log.warn("""get_cp_code is deprecated: akamai.properties.getCpCode has been deprecated in favor of akamai.getCpCode""")
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/properties/get_property.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_property_include.py`

 * *Files 27% similar despite different names*

```diff
@@ -3,148 +3,151 @@
 # *** Do not edit by hand unless you're certain you know what you are doing! ***
 
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
-from .. import _utilities
+from . import _utilities
 
 __all__ = [
-    'GetPropertyResult',
-    'AwaitableGetPropertyResult',
-    'get_property',
-    'get_property_output',
+    'GetPropertyIncludeResult',
+    'AwaitableGetPropertyIncludeResult',
+    'get_property_include',
+    'get_property_include_output',
 ]
 
-warnings.warn("""akamai.properties.getProperty has been deprecated in favor of akamai.getProperty""", DeprecationWarning)
-
 @pulumi.output_type
-class GetPropertyResult:
+class GetPropertyIncludeResult:
     """
-    A collection of values returned by getProperty.
+    A collection of values returned by getPropertyInclude.
     """
-    def __init__(__self__, id=None, name=None, rules=None, version=None):
+    def __init__(__self__, contract_id=None, group_id=None, id=None, include_id=None, latest_version=None, name=None, production_version=None, staging_version=None, type=None):
+        if contract_id and not isinstance(contract_id, str):
+            raise TypeError("Expected argument 'contract_id' to be a str")
+        pulumi.set(__self__, "contract_id", contract_id)
+        if group_id and not isinstance(group_id, str):
+            raise TypeError("Expected argument 'group_id' to be a str")
+        pulumi.set(__self__, "group_id", group_id)
         if id and not isinstance(id, str):
             raise TypeError("Expected argument 'id' to be a str")
         pulumi.set(__self__, "id", id)
+        if include_id and not isinstance(include_id, str):
+            raise TypeError("Expected argument 'include_id' to be a str")
+        pulumi.set(__self__, "include_id", include_id)
+        if latest_version and not isinstance(latest_version, int):
+            raise TypeError("Expected argument 'latest_version' to be a int")
+        pulumi.set(__self__, "latest_version", latest_version)
         if name and not isinstance(name, str):
             raise TypeError("Expected argument 'name' to be a str")
         pulumi.set(__self__, "name", name)
-        if rules and not isinstance(rules, str):
-            raise TypeError("Expected argument 'rules' to be a str")
-        pulumi.set(__self__, "rules", rules)
-        if version and not isinstance(version, int):
-            raise TypeError("Expected argument 'version' to be a int")
-        pulumi.set(__self__, "version", version)
+        if production_version and not isinstance(production_version, int):
+            raise TypeError("Expected argument 'production_version' to be a int")
+        pulumi.set(__self__, "production_version", production_version)
+        if staging_version and not isinstance(staging_version, int):
+            raise TypeError("Expected argument 'staging_version' to be a int")
+        pulumi.set(__self__, "staging_version", staging_version)
+        if type and not isinstance(type, str):
+            raise TypeError("Expected argument 'type' to be a str")
+        pulumi.set(__self__, "type", type)
+
+    @property
+    @pulumi.getter(name="contractId")
+    def contract_id(self) -> str:
+        return pulumi.get(self, "contract_id")
+
+    @property
+    @pulumi.getter(name="groupId")
+    def group_id(self) -> str:
+        return pulumi.get(self, "group_id")
 
     @property
     @pulumi.getter
     def id(self) -> str:
         """
         The provider-assigned unique ID for this managed resource.
         """
         return pulumi.get(self, "id")
 
     @property
+    @pulumi.getter(name="includeId")
+    def include_id(self) -> str:
+        return pulumi.get(self, "include_id")
+
+    @property
+    @pulumi.getter(name="latestVersion")
+    def latest_version(self) -> int:
+        return pulumi.get(self, "latest_version")
+
+    @property
     @pulumi.getter
     def name(self) -> str:
         return pulumi.get(self, "name")
 
     @property
-    @pulumi.getter
-    def rules(self) -> str:
-        return pulumi.get(self, "rules")
+    @pulumi.getter(name="productionVersion")
+    def production_version(self) -> int:
+        return pulumi.get(self, "production_version")
+
+    @property
+    @pulumi.getter(name="stagingVersion")
+    def staging_version(self) -> int:
+        return pulumi.get(self, "staging_version")
 
     @property
     @pulumi.getter
-    def version(self) -> Optional[int]:
-        return pulumi.get(self, "version")
+    def type(self) -> str:
+        return pulumi.get(self, "type")
 
 
-class AwaitableGetPropertyResult(GetPropertyResult):
+class AwaitableGetPropertyIncludeResult(GetPropertyIncludeResult):
     # pylint: disable=using-constant-test
     def __await__(self):
         if False:
             yield self
-        return GetPropertyResult(
+        return GetPropertyIncludeResult(
+            contract_id=self.contract_id,
+            group_id=self.group_id,
             id=self.id,
+            include_id=self.include_id,
+            latest_version=self.latest_version,
             name=self.name,
-            rules=self.rules,
-            version=self.version)
+            production_version=self.production_version,
+            staging_version=self.staging_version,
+            type=self.type)
 
 
-def get_property(name: Optional[str] = None,
-                 version: Optional[int] = None,
-                 opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetPropertyResult:
+def get_property_include(contract_id: Optional[str] = None,
+                         group_id: Optional[str] = None,
+                         include_id: Optional[str] = None,
+                         opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetPropertyIncludeResult:
     """
-    Use the `Property` data source to query and list the property ID and rule tree based on the property name.
-
-    ## Example Usage
-
-    This example returns the property ID and rule tree based on the property name and optional version argument:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    example = akamai.get_property(name="terraform-demo",
-        version=1)
-    pulumi.export("myPropertyID", example)
-    ```
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `property_ID` - A property's unique identifier, including the `prp_` prefix.
-    * `rules` - A JSON-encoded rule tree for a given property.
-
-
-    :param str name: (Required) The property name.
-    :param int version: (Optional) The version of the property whose ID you want to list.
+    Use this data source to access information about an existing resource.
     """
-    pulumi.log.warn("""get_property is deprecated: akamai.properties.getProperty has been deprecated in favor of akamai.getProperty""")
     __args__ = dict()
-    __args__['name'] = name
-    __args__['version'] = version
+    __args__['contractId'] = contract_id
+    __args__['groupId'] = group_id
+    __args__['includeId'] = include_id
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
-    __ret__ = pulumi.runtime.invoke('akamai:properties/getProperty:getProperty', __args__, opts=opts, typ=GetPropertyResult).value
+    __ret__ = pulumi.runtime.invoke('akamai:index/getPropertyInclude:getPropertyInclude', __args__, opts=opts, typ=GetPropertyIncludeResult).value
 
-    return AwaitableGetPropertyResult(
+    return AwaitableGetPropertyIncludeResult(
+        contract_id=__ret__.contract_id,
+        group_id=__ret__.group_id,
         id=__ret__.id,
+        include_id=__ret__.include_id,
+        latest_version=__ret__.latest_version,
         name=__ret__.name,
-        rules=__ret__.rules,
-        version=__ret__.version)
+        production_version=__ret__.production_version,
+        staging_version=__ret__.staging_version,
+        type=__ret__.type)
 
 
-@_utilities.lift_output_func(get_property)
-def get_property_output(name: Optional[pulumi.Input[str]] = None,
-                        version: Optional[pulumi.Input[Optional[int]]] = None,
-                        opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetPropertyResult]:
+@_utilities.lift_output_func(get_property_include)
+def get_property_include_output(contract_id: Optional[pulumi.Input[str]] = None,
+                                group_id: Optional[pulumi.Input[str]] = None,
+                                include_id: Optional[pulumi.Input[str]] = None,
+                                opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetPropertyIncludeResult]:
     """
-    Use the `Property` data source to query and list the property ID and rule tree based on the property name.
-
-    ## Example Usage
-
-    This example returns the property ID and rule tree based on the property name and optional version argument:
-
-    ```python
-    import pulumi
-    import pulumi_akamai as akamai
-
-    example = akamai.get_property(name="terraform-demo",
-        version=1)
-    pulumi.export("myPropertyID", example)
-    ```
-    ## Attributes reference
-
-    This data source returns these attributes:
-
-    * `property_ID` - A property's unique identifier, including the `prp_` prefix.
-    * `rules` - A JSON-encoded rule tree for a given property.
-
-
-    :param str name: (Required) The property name.
-    :param int version: (Optional) The version of the property whose ID you want to list.
+    Use this data source to access information about an existing resource.
     """
-    pulumi.log.warn("""get_property is deprecated: akamai.properties.getProperty has been deprecated in favor of akamai.getProperty""")
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/properties/outputs.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/properties/outputs.py`

 * *Files 3% similar despite different names*

```diff
@@ -7,24 +7,104 @@
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from .. import _utilities
 from . import outputs
 
 __all__ = [
+    'PropertyActivationComplianceRecord',
     'PropertyActivationRuleError',
     'PropertyActivationRuleWarning',
     'PropertyHostname',
     'PropertyHostnameCertStatus',
     'PropertyOrigin',
     'PropertyRuleError',
     'PropertyRuleWarning',
 ]
 
 @pulumi.output_type
+class PropertyActivationComplianceRecord(dict):
+    @staticmethod
+    def __key_warning(key: str):
+        suggest = None
+        if key == "noncomplianceReason":
+            suggest = "noncompliance_reason"
+        elif key == "customerEmail":
+            suggest = "customer_email"
+        elif key == "otherNoncomplianceReason":
+            suggest = "other_noncompliance_reason"
+        elif key == "peerReviewedBy":
+            suggest = "peer_reviewed_by"
+        elif key == "ticketId":
+            suggest = "ticket_id"
+        elif key == "unitTested":
+            suggest = "unit_tested"
+
+        if suggest:
+            pulumi.log.warn(f"Key '{key}' not found in PropertyActivationComplianceRecord. Access the value via the '{suggest}' property getter instead.")
+
+    def __getitem__(self, key: str) -> Any:
+        PropertyActivationComplianceRecord.__key_warning(key)
+        return super().__getitem__(key)
+
+    def get(self, key: str, default = None) -> Any:
+        PropertyActivationComplianceRecord.__key_warning(key)
+        return super().get(key, default)
+
+    def __init__(__self__, *,
+                 noncompliance_reason: str,
+                 customer_email: Optional[str] = None,
+                 other_noncompliance_reason: Optional[str] = None,
+                 peer_reviewed_by: Optional[str] = None,
+                 ticket_id: Optional[str] = None,
+                 unit_tested: Optional[bool] = None):
+        pulumi.set(__self__, "noncompliance_reason", noncompliance_reason)
+        if customer_email is not None:
+            pulumi.set(__self__, "customer_email", customer_email)
+        if other_noncompliance_reason is not None:
+            pulumi.set(__self__, "other_noncompliance_reason", other_noncompliance_reason)
+        if peer_reviewed_by is not None:
+            pulumi.set(__self__, "peer_reviewed_by", peer_reviewed_by)
+        if ticket_id is not None:
+            pulumi.set(__self__, "ticket_id", ticket_id)
+        if unit_tested is not None:
+            pulumi.set(__self__, "unit_tested", unit_tested)
+
+    @property
+    @pulumi.getter(name="noncomplianceReason")
+    def noncompliance_reason(self) -> str:
+        return pulumi.get(self, "noncompliance_reason")
+
+    @property
+    @pulumi.getter(name="customerEmail")
+    def customer_email(self) -> Optional[str]:
+        return pulumi.get(self, "customer_email")
+
+    @property
+    @pulumi.getter(name="otherNoncomplianceReason")
+    def other_noncompliance_reason(self) -> Optional[str]:
+        return pulumi.get(self, "other_noncompliance_reason")
+
+    @property
+    @pulumi.getter(name="peerReviewedBy")
+    def peer_reviewed_by(self) -> Optional[str]:
+        return pulumi.get(self, "peer_reviewed_by")
+
+    @property
+    @pulumi.getter(name="ticketId")
+    def ticket_id(self) -> Optional[str]:
+        return pulumi.get(self, "ticket_id")
+
+    @property
+    @pulumi.getter(name="unitTested")
+    def unit_tested(self) -> Optional[bool]:
+        return pulumi.get(self, "unit_tested")
+
+
+@pulumi.output_type
 class PropertyActivationRuleError(dict):
     @staticmethod
     def __key_warning(key: str):
         suggest = None
         if key == "behaviorName":
             suggest = "behavior_name"
         elif key == "errorLocation":
@@ -216,51 +296,37 @@
     def __init__(__self__, *,
                  cert_provisioning_type: str,
                  cname_from: str,
                  cname_to: str,
                  cert_statuses: Optional[Sequence['outputs.PropertyHostnameCertStatus']] = None,
                  cname_type: Optional[str] = None,
                  edge_hostname_id: Optional[str] = None):
-        """
-        :param str cert_provisioning_type: The certificate's provisioning type, either the default `CPS_MANAGED` type for the custom certificates you provision with the [Certificate Provisioning System (CPS)](https://techdocs.akamai.com/cps/docs), or `DEFAULT` for certificates provisioned automatically.
-        :param str cname_from: A string containing the original origin's hostname. For example, `"example.org"`.
-        :param str cname_to: A string containing the hostname for edge content. For example,  `"example.org.edgesuite.net"`.
-        """
         pulumi.set(__self__, "cert_provisioning_type", cert_provisioning_type)
         pulumi.set(__self__, "cname_from", cname_from)
         pulumi.set(__self__, "cname_to", cname_to)
         if cert_statuses is not None:
             pulumi.set(__self__, "cert_statuses", cert_statuses)
         if cname_type is not None:
             pulumi.set(__self__, "cname_type", cname_type)
         if edge_hostname_id is not None:
             pulumi.set(__self__, "edge_hostname_id", edge_hostname_id)
 
     @property
     @pulumi.getter(name="certProvisioningType")
     def cert_provisioning_type(self) -> str:
-        """
-        The certificate's provisioning type, either the default `CPS_MANAGED` type for the custom certificates you provision with the [Certificate Provisioning System (CPS)](https://techdocs.akamai.com/cps/docs), or `DEFAULT` for certificates provisioned automatically.
-        """
         return pulumi.get(self, "cert_provisioning_type")
 
     @property
     @pulumi.getter(name="cnameFrom")
     def cname_from(self) -> str:
-        """
-        A string containing the original origin's hostname. For example, `"example.org"`.
-        """
         return pulumi.get(self, "cname_from")
 
     @property
     @pulumi.getter(name="cnameTo")
     def cname_to(self) -> str:
-        """
-        A string containing the hostname for edge content. For example,  `"example.org.edgesuite.net"`.
-        """
         return pulumi.get(self, "cname_to")
 
     @property
     @pulumi.getter(name="certStatuses")
     def cert_statuses(self) -> Optional[Sequence['outputs.PropertyHostnameCertStatus']]:
         return pulumi.get(self, "cert_statuses")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/property_include_activation.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/property_activation.py`

 * *Files 26% similar despite different names*

```diff
@@ -7,565 +7,587 @@
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from . import _utilities
 from . import outputs
 from ._inputs import *
 
-__all__ = ['PropertyIncludeActivationArgs', 'PropertyIncludeActivation']
+__all__ = ['PropertyActivationArgs', 'PropertyActivation']
 
 @pulumi.input_type
-class PropertyIncludeActivationArgs:
+class PropertyActivationArgs:
     def __init__(__self__, *,
-                 contract_id: pulumi.Input[str],
-                 group_id: pulumi.Input[str],
-                 include_id: pulumi.Input[str],
-                 network: pulumi.Input[str],
-                 notify_emails: pulumi.Input[Sequence[pulumi.Input[str]]],
+                 contacts: pulumi.Input[Sequence[pulumi.Input[str]]],
                  version: pulumi.Input[int],
+                 activation_id: Optional[pulumi.Input[str]] = None,
                  auto_acknowledge_rule_warnings: Optional[pulumi.Input[bool]] = None,
-                 compliance_record: Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordArgs']] = None,
-                 note: Optional[pulumi.Input[str]] = None):
+                 compliance_record: Optional[pulumi.Input['PropertyActivationComplianceRecordArgs']] = None,
+                 network: Optional[pulumi.Input[str]] = None,
+                 note: Optional[pulumi.Input[str]] = None,
+                 property: Optional[pulumi.Input[str]] = None,
+                 property_id: Optional[pulumi.Input[str]] = None,
+                 rule_errors: Optional[pulumi.Input[Sequence[pulumi.Input['PropertyActivationRuleErrorArgs']]]] = None,
+                 rule_warnings: Optional[pulumi.Input[Sequence[pulumi.Input['PropertyActivationRuleWarningArgs']]]] = None):
+        """
+        The set of arguments for constructing a PropertyActivation resource.
+        :param pulumi.Input[bool] auto_acknowledge_rule_warnings: automatically acknowledge all rule warnings for activation to continue. default is true
+        :param pulumi.Input['PropertyActivationComplianceRecordArgs'] compliance_record: Provides an audit record when activating on a production network
+        :param pulumi.Input[str] note: assigns a log message to the activation request
         """
-        The set of arguments for constructing a PropertyIncludeActivation resource.
-        :param pulumi.Input[str] contract_id: (Required) A contract's unique ID, including the optional `ctr_` prefix.
-        :param pulumi.Input[str] group_id: (Required) A group's unique ID, including the optional `grp_` prefix.
-        :param pulumi.Input[str] include_id: (Required) An include's unique ID with the optional `inc_` prefix.
-        :param pulumi.Input[str] network: (Required) The network for which the activation will be performed.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notify_emails: (Required) The list of email addresses to notify when the activation status changes.
-        :param pulumi.Input[int] version: (Required) The version of the include you want to activate.
-        :param pulumi.Input[bool] auto_acknowledge_rule_warnings: (Optional) Automatically acknowledge all rule warnings for activation and continue.
-        :param pulumi.Input['PropertyIncludeActivationComplianceRecordArgs'] compliance_record: Provides an audit record when activating on a production network
-        :param pulumi.Input[str] note: (Optional) A log message assigned to the activation request.
-        """
-        pulumi.set(__self__, "contract_id", contract_id)
-        pulumi.set(__self__, "group_id", group_id)
-        pulumi.set(__self__, "include_id", include_id)
-        pulumi.set(__self__, "network", network)
-        pulumi.set(__self__, "notify_emails", notify_emails)
+        pulumi.set(__self__, "contacts", contacts)
         pulumi.set(__self__, "version", version)
+        if activation_id is not None:
+            pulumi.set(__self__, "activation_id", activation_id)
         if auto_acknowledge_rule_warnings is not None:
             pulumi.set(__self__, "auto_acknowledge_rule_warnings", auto_acknowledge_rule_warnings)
         if compliance_record is not None:
             pulumi.set(__self__, "compliance_record", compliance_record)
+        if network is not None:
+            pulumi.set(__self__, "network", network)
         if note is not None:
             pulumi.set(__self__, "note", note)
-
-    @property
-    @pulumi.getter(name="contractId")
-    def contract_id(self) -> pulumi.Input[str]:
-        """
-        (Required) A contract's unique ID, including the optional `ctr_` prefix.
-        """
-        return pulumi.get(self, "contract_id")
-
-    @contract_id.setter
-    def contract_id(self, value: pulumi.Input[str]):
-        pulumi.set(self, "contract_id", value)
-
-    @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> pulumi.Input[str]:
-        """
-        (Required) A group's unique ID, including the optional `grp_` prefix.
-        """
-        return pulumi.get(self, "group_id")
-
-    @group_id.setter
-    def group_id(self, value: pulumi.Input[str]):
-        pulumi.set(self, "group_id", value)
-
-    @property
-    @pulumi.getter(name="includeId")
-    def include_id(self) -> pulumi.Input[str]:
-        """
-        (Required) An include's unique ID with the optional `inc_` prefix.
-        """
-        return pulumi.get(self, "include_id")
-
-    @include_id.setter
-    def include_id(self, value: pulumi.Input[str]):
-        pulumi.set(self, "include_id", value)
+        if property is not None:
+            warnings.warn("""The setting \"property\" has been deprecated.""", DeprecationWarning)
+            pulumi.log.warn("""property is deprecated: The setting \"property\" has been deprecated.""")
+        if property is not None:
+            pulumi.set(__self__, "property", property)
+        if property_id is not None:
+            pulumi.set(__self__, "property_id", property_id)
+        if rule_errors is not None:
+            pulumi.set(__self__, "rule_errors", rule_errors)
+        if rule_warnings is not None:
+            warnings.warn("""Rule warnings will not be set in state anymore""", DeprecationWarning)
+            pulumi.log.warn("""rule_warnings is deprecated: Rule warnings will not be set in state anymore""")
+        if rule_warnings is not None:
+            pulumi.set(__self__, "rule_warnings", rule_warnings)
 
     @property
     @pulumi.getter
-    def network(self) -> pulumi.Input[str]:
-        """
-        (Required) The network for which the activation will be performed.
-        """
-        return pulumi.get(self, "network")
-
-    @network.setter
-    def network(self, value: pulumi.Input[str]):
-        pulumi.set(self, "network", value)
-
-    @property
-    @pulumi.getter(name="notifyEmails")
-    def notify_emails(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
-        """
-        (Required) The list of email addresses to notify when the activation status changes.
-        """
-        return pulumi.get(self, "notify_emails")
-
-    @notify_emails.setter
-    def notify_emails(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
-        pulumi.set(self, "notify_emails", value)
+    def contacts(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
+        return pulumi.get(self, "contacts")
+
+    @contacts.setter
+    def contacts(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
+        pulumi.set(self, "contacts", value)
 
     @property
     @pulumi.getter
     def version(self) -> pulumi.Input[int]:
-        """
-        (Required) The version of the include you want to activate.
-        """
         return pulumi.get(self, "version")
 
     @version.setter
     def version(self, value: pulumi.Input[int]):
         pulumi.set(self, "version", value)
 
     @property
+    @pulumi.getter(name="activationId")
+    def activation_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "activation_id")
+
+    @activation_id.setter
+    def activation_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "activation_id", value)
+
+    @property
     @pulumi.getter(name="autoAcknowledgeRuleWarnings")
     def auto_acknowledge_rule_warnings(self) -> Optional[pulumi.Input[bool]]:
         """
-        (Optional) Automatically acknowledge all rule warnings for activation and continue.
+        automatically acknowledge all rule warnings for activation to continue. default is true
         """
         return pulumi.get(self, "auto_acknowledge_rule_warnings")
 
     @auto_acknowledge_rule_warnings.setter
     def auto_acknowledge_rule_warnings(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "auto_acknowledge_rule_warnings", value)
 
     @property
     @pulumi.getter(name="complianceRecord")
-    def compliance_record(self) -> Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordArgs']]:
+    def compliance_record(self) -> Optional[pulumi.Input['PropertyActivationComplianceRecordArgs']]:
         """
         Provides an audit record when activating on a production network
         """
         return pulumi.get(self, "compliance_record")
 
     @compliance_record.setter
-    def compliance_record(self, value: Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordArgs']]):
+    def compliance_record(self, value: Optional[pulumi.Input['PropertyActivationComplianceRecordArgs']]):
         pulumi.set(self, "compliance_record", value)
 
     @property
     @pulumi.getter
+    def network(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "network")
+
+    @network.setter
+    def network(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "network", value)
+
+    @property
+    @pulumi.getter
     def note(self) -> Optional[pulumi.Input[str]]:
         """
-        (Optional) A log message assigned to the activation request.
+        assigns a log message to the activation request
         """
         return pulumi.get(self, "note")
 
     @note.setter
     def note(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "note", value)
 
+    @property
+    @pulumi.getter(name="propertyId")
+    def property_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "property_id")
+
+    @property_id.setter
+    def property_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "property_id", value)
+
+    @property
+    @pulumi.getter(name="ruleErrors")
+    def rule_errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PropertyActivationRuleErrorArgs']]]]:
+        return pulumi.get(self, "rule_errors")
+
+    @rule_errors.setter
+    def rule_errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PropertyActivationRuleErrorArgs']]]]):
+        pulumi.set(self, "rule_errors", value)
+
+    @property
+    @pulumi.getter(name="ruleWarnings")
+    def rule_warnings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PropertyActivationRuleWarningArgs']]]]:
+        return pulumi.get(self, "rule_warnings")
+
+    @rule_warnings.setter
+    def rule_warnings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PropertyActivationRuleWarningArgs']]]]):
+        pulumi.set(self, "rule_warnings", value)
+
+    @property
+    @pulumi.getter
+    def property(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "property")
+
+    @property.setter
+    def property(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "property", value)
+
 
 @pulumi.input_type
-class _PropertyIncludeActivationState:
+class _PropertyActivationState:
     def __init__(__self__, *,
+                 activation_id: Optional[pulumi.Input[str]] = None,
                  auto_acknowledge_rule_warnings: Optional[pulumi.Input[bool]] = None,
-                 compliance_record: Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordArgs']] = None,
-                 contract_id: Optional[pulumi.Input[str]] = None,
-                 group_id: Optional[pulumi.Input[str]] = None,
-                 include_id: Optional[pulumi.Input[str]] = None,
+                 compliance_record: Optional[pulumi.Input['PropertyActivationComplianceRecordArgs']] = None,
+                 contacts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 errors: Optional[pulumi.Input[str]] = None,
                  network: Optional[pulumi.Input[str]] = None,
                  note: Optional[pulumi.Input[str]] = None,
-                 notify_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-                 validations: Optional[pulumi.Input[str]] = None,
-                 version: Optional[pulumi.Input[int]] = None):
-        """
-        Input properties used for looking up and filtering PropertyIncludeActivation resources.
-        :param pulumi.Input[bool] auto_acknowledge_rule_warnings: (Optional) Automatically acknowledge all rule warnings for activation and continue.
-        :param pulumi.Input['PropertyIncludeActivationComplianceRecordArgs'] compliance_record: Provides an audit record when activating on a production network
-        :param pulumi.Input[str] contract_id: (Required) A contract's unique ID, including the optional `ctr_` prefix.
-        :param pulumi.Input[str] group_id: (Required) A group's unique ID, including the optional `grp_` prefix.
-        :param pulumi.Input[str] include_id: (Required) An include's unique ID with the optional `inc_` prefix.
-        :param pulumi.Input[str] network: (Required) The network for which the activation will be performed.
-        :param pulumi.Input[str] note: (Optional) A log message assigned to the activation request.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notify_emails: (Required) The list of email addresses to notify when the activation status changes.
-        :param pulumi.Input[str] validations: The validation information in JSON format
-        :param pulumi.Input[int] version: (Required) The version of the include you want to activate.
+                 property: Optional[pulumi.Input[str]] = None,
+                 property_id: Optional[pulumi.Input[str]] = None,
+                 rule_errors: Optional[pulumi.Input[Sequence[pulumi.Input['PropertyActivationRuleErrorArgs']]]] = None,
+                 rule_warnings: Optional[pulumi.Input[Sequence[pulumi.Input['PropertyActivationRuleWarningArgs']]]] = None,
+                 status: Optional[pulumi.Input[str]] = None,
+                 version: Optional[pulumi.Input[int]] = None,
+                 warnings: Optional[pulumi.Input[str]] = None):
+        """
+        Input properties used for looking up and filtering PropertyActivation resources.
+        :param pulumi.Input[bool] auto_acknowledge_rule_warnings: automatically acknowledge all rule warnings for activation to continue. default is true
+        :param pulumi.Input['PropertyActivationComplianceRecordArgs'] compliance_record: Provides an audit record when activating on a production network
+        :param pulumi.Input[str] note: assigns a log message to the activation request
         """
+        if activation_id is not None:
+            pulumi.set(__self__, "activation_id", activation_id)
         if auto_acknowledge_rule_warnings is not None:
             pulumi.set(__self__, "auto_acknowledge_rule_warnings", auto_acknowledge_rule_warnings)
         if compliance_record is not None:
             pulumi.set(__self__, "compliance_record", compliance_record)
-        if contract_id is not None:
-            pulumi.set(__self__, "contract_id", contract_id)
-        if group_id is not None:
-            pulumi.set(__self__, "group_id", group_id)
-        if include_id is not None:
-            pulumi.set(__self__, "include_id", include_id)
+        if contacts is not None:
+            pulumi.set(__self__, "contacts", contacts)
+        if errors is not None:
+            pulumi.set(__self__, "errors", errors)
         if network is not None:
             pulumi.set(__self__, "network", network)
         if note is not None:
             pulumi.set(__self__, "note", note)
-        if notify_emails is not None:
-            pulumi.set(__self__, "notify_emails", notify_emails)
-        if validations is not None:
-            pulumi.set(__self__, "validations", validations)
+        if property is not None:
+            warnings.warn("""The setting \"property\" has been deprecated.""", DeprecationWarning)
+            pulumi.log.warn("""property is deprecated: The setting \"property\" has been deprecated.""")
+        if property is not None:
+            pulumi.set(__self__, "property", property)
+        if property_id is not None:
+            pulumi.set(__self__, "property_id", property_id)
+        if rule_errors is not None:
+            pulumi.set(__self__, "rule_errors", rule_errors)
+        if rule_warnings is not None:
+            warnings.warn("""Rule warnings will not be set in state anymore""", DeprecationWarning)
+            pulumi.log.warn("""rule_warnings is deprecated: Rule warnings will not be set in state anymore""")
+        if rule_warnings is not None:
+            pulumi.set(__self__, "rule_warnings", rule_warnings)
+        if status is not None:
+            pulumi.set(__self__, "status", status)
         if version is not None:
             pulumi.set(__self__, "version", version)
+        if warnings is not None:
+            pulumi.set(__self__, "warnings", warnings)
+
+    @property
+    @pulumi.getter(name="activationId")
+    def activation_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "activation_id")
+
+    @activation_id.setter
+    def activation_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "activation_id", value)
 
     @property
     @pulumi.getter(name="autoAcknowledgeRuleWarnings")
     def auto_acknowledge_rule_warnings(self) -> Optional[pulumi.Input[bool]]:
         """
-        (Optional) Automatically acknowledge all rule warnings for activation and continue.
+        automatically acknowledge all rule warnings for activation to continue. default is true
         """
         return pulumi.get(self, "auto_acknowledge_rule_warnings")
 
     @auto_acknowledge_rule_warnings.setter
     def auto_acknowledge_rule_warnings(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "auto_acknowledge_rule_warnings", value)
 
     @property
     @pulumi.getter(name="complianceRecord")
-    def compliance_record(self) -> Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordArgs']]:
+    def compliance_record(self) -> Optional[pulumi.Input['PropertyActivationComplianceRecordArgs']]:
         """
         Provides an audit record when activating on a production network
         """
         return pulumi.get(self, "compliance_record")
 
     @compliance_record.setter
-    def compliance_record(self, value: Optional[pulumi.Input['PropertyIncludeActivationComplianceRecordArgs']]):
+    def compliance_record(self, value: Optional[pulumi.Input['PropertyActivationComplianceRecordArgs']]):
         pulumi.set(self, "compliance_record", value)
 
     @property
-    @pulumi.getter(name="contractId")
-    def contract_id(self) -> Optional[pulumi.Input[str]]:
-        """
-        (Required) A contract's unique ID, including the optional `ctr_` prefix.
-        """
-        return pulumi.get(self, "contract_id")
-
-    @contract_id.setter
-    def contract_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "contract_id", value)
-
-    @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> Optional[pulumi.Input[str]]:
-        """
-        (Required) A group's unique ID, including the optional `grp_` prefix.
-        """
-        return pulumi.get(self, "group_id")
+    @pulumi.getter
+    def contacts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
+        return pulumi.get(self, "contacts")
 
-    @group_id.setter
-    def group_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "group_id", value)
+    @contacts.setter
+    def contacts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
+        pulumi.set(self, "contacts", value)
 
     @property
-    @pulumi.getter(name="includeId")
-    def include_id(self) -> Optional[pulumi.Input[str]]:
-        """
-        (Required) An include's unique ID with the optional `inc_` prefix.
-        """
-        return pulumi.get(self, "include_id")
+    @pulumi.getter
+    def errors(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "errors")
 
-    @include_id.setter
-    def include_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "include_id", value)
+    @errors.setter
+    def errors(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "errors", value)
 
     @property
     @pulumi.getter
     def network(self) -> Optional[pulumi.Input[str]]:
-        """
-        (Required) The network for which the activation will be performed.
-        """
         return pulumi.get(self, "network")
 
     @network.setter
     def network(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "network", value)
 
     @property
     @pulumi.getter
     def note(self) -> Optional[pulumi.Input[str]]:
         """
-        (Optional) A log message assigned to the activation request.
+        assigns a log message to the activation request
         """
         return pulumi.get(self, "note")
 
     @note.setter
     def note(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "note", value)
 
     @property
-    @pulumi.getter(name="notifyEmails")
-    def notify_emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
-        """
-        (Required) The list of email addresses to notify when the activation status changes.
-        """
-        return pulumi.get(self, "notify_emails")
+    @pulumi.getter(name="propertyId")
+    def property_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "property_id")
+
+    @property_id.setter
+    def property_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "property_id", value)
+
+    @property
+    @pulumi.getter(name="ruleErrors")
+    def rule_errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PropertyActivationRuleErrorArgs']]]]:
+        return pulumi.get(self, "rule_errors")
 
-    @notify_emails.setter
-    def notify_emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
-        pulumi.set(self, "notify_emails", value)
+    @rule_errors.setter
+    def rule_errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PropertyActivationRuleErrorArgs']]]]):
+        pulumi.set(self, "rule_errors", value)
+
+    @property
+    @pulumi.getter(name="ruleWarnings")
+    def rule_warnings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PropertyActivationRuleWarningArgs']]]]:
+        return pulumi.get(self, "rule_warnings")
+
+    @rule_warnings.setter
+    def rule_warnings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PropertyActivationRuleWarningArgs']]]]):
+        pulumi.set(self, "rule_warnings", value)
 
     @property
     @pulumi.getter
-    def validations(self) -> Optional[pulumi.Input[str]]:
-        """
-        The validation information in JSON format
-        """
-        return pulumi.get(self, "validations")
+    def status(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "status")
 
-    @validations.setter
-    def validations(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "validations", value)
+    @status.setter
+    def status(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "status", value)
 
     @property
     @pulumi.getter
     def version(self) -> Optional[pulumi.Input[int]]:
-        """
-        (Required) The version of the include you want to activate.
-        """
         return pulumi.get(self, "version")
 
     @version.setter
     def version(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "version", value)
 
+    @property
+    @pulumi.getter
+    def warnings(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "warnings")
+
+    @warnings.setter
+    def warnings(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "warnings", value)
+
+    @property
+    @pulumi.getter
+    def property(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "property")
+
+    @property.setter
+    def property(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "property", value)
 
-class PropertyIncludeActivation(pulumi.CustomResource):
+
+class PropertyActivation(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
+                 activation_id: Optional[pulumi.Input[str]] = None,
                  auto_acknowledge_rule_warnings: Optional[pulumi.Input[bool]] = None,
-                 compliance_record: Optional[pulumi.Input[pulumi.InputType['PropertyIncludeActivationComplianceRecordArgs']]] = None,
-                 contract_id: Optional[pulumi.Input[str]] = None,
-                 group_id: Optional[pulumi.Input[str]] = None,
-                 include_id: Optional[pulumi.Input[str]] = None,
+                 compliance_record: Optional[pulumi.Input[pulumi.InputType['PropertyActivationComplianceRecordArgs']]] = None,
+                 contacts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  network: Optional[pulumi.Input[str]] = None,
                  note: Optional[pulumi.Input[str]] = None,
-                 notify_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 property: Optional[pulumi.Input[str]] = None,
+                 property_id: Optional[pulumi.Input[str]] = None,
+                 rule_errors: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['PropertyActivationRuleErrorArgs']]]]] = None,
+                 rule_warnings: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['PropertyActivationRuleWarningArgs']]]]] = None,
                  version: Optional[pulumi.Input[int]] = None,
                  __props__=None):
         """
-        Use the `PropertyIncludeActivation` resource to activate your include and make available to a property.
-        You can also modify the activation time out with the `AKAMAI_ACTIVATION_TIMEOUT` environment variable, providing time in minutes. The default time out is 30 minutes.
-
-        ## Attributes reference
-
-        This resource returns this attribute:
-
-        * `validations` -The validation information in JSON format.
-
+        Create a PropertyActivation resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[bool] auto_acknowledge_rule_warnings: (Optional) Automatically acknowledge all rule warnings for activation and continue.
-        :param pulumi.Input[pulumi.InputType['PropertyIncludeActivationComplianceRecordArgs']] compliance_record: Provides an audit record when activating on a production network
-        :param pulumi.Input[str] contract_id: (Required) A contract's unique ID, including the optional `ctr_` prefix.
-        :param pulumi.Input[str] group_id: (Required) A group's unique ID, including the optional `grp_` prefix.
-        :param pulumi.Input[str] include_id: (Required) An include's unique ID with the optional `inc_` prefix.
-        :param pulumi.Input[str] network: (Required) The network for which the activation will be performed.
-        :param pulumi.Input[str] note: (Optional) A log message assigned to the activation request.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notify_emails: (Required) The list of email addresses to notify when the activation status changes.
-        :param pulumi.Input[int] version: (Required) The version of the include you want to activate.
+        :param pulumi.Input[bool] auto_acknowledge_rule_warnings: automatically acknowledge all rule warnings for activation to continue. default is true
+        :param pulumi.Input[pulumi.InputType['PropertyActivationComplianceRecordArgs']] compliance_record: Provides an audit record when activating on a production network
+        :param pulumi.Input[str] note: assigns a log message to the activation request
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: PropertyIncludeActivationArgs,
+                 args: PropertyActivationArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        Use the `PropertyIncludeActivation` resource to activate your include and make available to a property.
-        You can also modify the activation time out with the `AKAMAI_ACTIVATION_TIMEOUT` environment variable, providing time in minutes. The default time out is 30 minutes.
-
-        ## Attributes reference
-
-        This resource returns this attribute:
-
-        * `validations` -The validation information in JSON format.
-
+        Create a PropertyActivation resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param PropertyIncludeActivationArgs args: The arguments to use to populate this resource's properties.
+        :param PropertyActivationArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(PropertyIncludeActivationArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(PropertyActivationArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
+                 activation_id: Optional[pulumi.Input[str]] = None,
                  auto_acknowledge_rule_warnings: Optional[pulumi.Input[bool]] = None,
-                 compliance_record: Optional[pulumi.Input[pulumi.InputType['PropertyIncludeActivationComplianceRecordArgs']]] = None,
-                 contract_id: Optional[pulumi.Input[str]] = None,
-                 group_id: Optional[pulumi.Input[str]] = None,
-                 include_id: Optional[pulumi.Input[str]] = None,
+                 compliance_record: Optional[pulumi.Input[pulumi.InputType['PropertyActivationComplianceRecordArgs']]] = None,
+                 contacts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  network: Optional[pulumi.Input[str]] = None,
                  note: Optional[pulumi.Input[str]] = None,
-                 notify_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 property: Optional[pulumi.Input[str]] = None,
+                 property_id: Optional[pulumi.Input[str]] = None,
+                 rule_errors: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['PropertyActivationRuleErrorArgs']]]]] = None,
+                 rule_warnings: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['PropertyActivationRuleWarningArgs']]]]] = None,
                  version: Optional[pulumi.Input[int]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = PropertyIncludeActivationArgs.__new__(PropertyIncludeActivationArgs)
+            __props__ = PropertyActivationArgs.__new__(PropertyActivationArgs)
 
+            __props__.__dict__["activation_id"] = activation_id
             __props__.__dict__["auto_acknowledge_rule_warnings"] = auto_acknowledge_rule_warnings
             __props__.__dict__["compliance_record"] = compliance_record
-            if contract_id is None and not opts.urn:
-                raise TypeError("Missing required property 'contract_id'")
-            __props__.__dict__["contract_id"] = contract_id
-            if group_id is None and not opts.urn:
-                raise TypeError("Missing required property 'group_id'")
-            __props__.__dict__["group_id"] = group_id
-            if include_id is None and not opts.urn:
-                raise TypeError("Missing required property 'include_id'")
-            __props__.__dict__["include_id"] = include_id
-            if network is None and not opts.urn:
-                raise TypeError("Missing required property 'network'")
+            if contacts is None and not opts.urn:
+                raise TypeError("Missing required property 'contacts'")
+            __props__.__dict__["contacts"] = contacts
             __props__.__dict__["network"] = network
             __props__.__dict__["note"] = note
-            if notify_emails is None and not opts.urn:
-                raise TypeError("Missing required property 'notify_emails'")
-            __props__.__dict__["notify_emails"] = notify_emails
+            if property is not None and not opts.urn:
+                warnings.warn("""The setting \"property\" has been deprecated.""", DeprecationWarning)
+                pulumi.log.warn("""property is deprecated: The setting \"property\" has been deprecated.""")
+            __props__.__dict__["property"] = property
+            __props__.__dict__["property_id"] = property_id
+            __props__.__dict__["rule_errors"] = rule_errors
+            if rule_warnings is not None and not opts.urn:
+                warnings.warn("""Rule warnings will not be set in state anymore""", DeprecationWarning)
+                pulumi.log.warn("""rule_warnings is deprecated: Rule warnings will not be set in state anymore""")
+            __props__.__dict__["rule_warnings"] = rule_warnings
             if version is None and not opts.urn:
                 raise TypeError("Missing required property 'version'")
             __props__.__dict__["version"] = version
-            __props__.__dict__["validations"] = None
-        super(PropertyIncludeActivation, __self__).__init__(
-            'akamai:index/propertyIncludeActivation:PropertyIncludeActivation',
+            __props__.__dict__["errors"] = None
+            __props__.__dict__["status"] = None
+            __props__.__dict__["warnings"] = None
+        alias_opts = pulumi.ResourceOptions(aliases=[pulumi.Alias(type_="akamai:properties/propertyActivation:PropertyActivation")])
+        opts = pulumi.ResourceOptions.merge(opts, alias_opts)
+        super(PropertyActivation, __self__).__init__(
+            'akamai:index/propertyActivation:PropertyActivation',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
+            activation_id: Optional[pulumi.Input[str]] = None,
             auto_acknowledge_rule_warnings: Optional[pulumi.Input[bool]] = None,
-            compliance_record: Optional[pulumi.Input[pulumi.InputType['PropertyIncludeActivationComplianceRecordArgs']]] = None,
-            contract_id: Optional[pulumi.Input[str]] = None,
-            group_id: Optional[pulumi.Input[str]] = None,
-            include_id: Optional[pulumi.Input[str]] = None,
+            compliance_record: Optional[pulumi.Input[pulumi.InputType['PropertyActivationComplianceRecordArgs']]] = None,
+            contacts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+            errors: Optional[pulumi.Input[str]] = None,
             network: Optional[pulumi.Input[str]] = None,
             note: Optional[pulumi.Input[str]] = None,
-            notify_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
-            validations: Optional[pulumi.Input[str]] = None,
-            version: Optional[pulumi.Input[int]] = None) -> 'PropertyIncludeActivation':
+            property: Optional[pulumi.Input[str]] = None,
+            property_id: Optional[pulumi.Input[str]] = None,
+            rule_errors: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['PropertyActivationRuleErrorArgs']]]]] = None,
+            rule_warnings: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['PropertyActivationRuleWarningArgs']]]]] = None,
+            status: Optional[pulumi.Input[str]] = None,
+            version: Optional[pulumi.Input[int]] = None,
+            warnings: Optional[pulumi.Input[str]] = None) -> 'PropertyActivation':
         """
-        Get an existing PropertyIncludeActivation resource's state with the given name, id, and optional extra
+        Get an existing PropertyActivation resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[bool] auto_acknowledge_rule_warnings: (Optional) Automatically acknowledge all rule warnings for activation and continue.
-        :param pulumi.Input[pulumi.InputType['PropertyIncludeActivationComplianceRecordArgs']] compliance_record: Provides an audit record when activating on a production network
-        :param pulumi.Input[str] contract_id: (Required) A contract's unique ID, including the optional `ctr_` prefix.
-        :param pulumi.Input[str] group_id: (Required) A group's unique ID, including the optional `grp_` prefix.
-        :param pulumi.Input[str] include_id: (Required) An include's unique ID with the optional `inc_` prefix.
-        :param pulumi.Input[str] network: (Required) The network for which the activation will be performed.
-        :param pulumi.Input[str] note: (Optional) A log message assigned to the activation request.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notify_emails: (Required) The list of email addresses to notify when the activation status changes.
-        :param pulumi.Input[str] validations: The validation information in JSON format
-        :param pulumi.Input[int] version: (Required) The version of the include you want to activate.
+        :param pulumi.Input[bool] auto_acknowledge_rule_warnings: automatically acknowledge all rule warnings for activation to continue. default is true
+        :param pulumi.Input[pulumi.InputType['PropertyActivationComplianceRecordArgs']] compliance_record: Provides an audit record when activating on a production network
+        :param pulumi.Input[str] note: assigns a log message to the activation request
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _PropertyIncludeActivationState.__new__(_PropertyIncludeActivationState)
+        __props__ = _PropertyActivationState.__new__(_PropertyActivationState)
 
+        __props__.__dict__["activation_id"] = activation_id
         __props__.__dict__["auto_acknowledge_rule_warnings"] = auto_acknowledge_rule_warnings
         __props__.__dict__["compliance_record"] = compliance_record
-        __props__.__dict__["contract_id"] = contract_id
-        __props__.__dict__["group_id"] = group_id
-        __props__.__dict__["include_id"] = include_id
+        __props__.__dict__["contacts"] = contacts
+        __props__.__dict__["errors"] = errors
         __props__.__dict__["network"] = network
         __props__.__dict__["note"] = note
-        __props__.__dict__["notify_emails"] = notify_emails
-        __props__.__dict__["validations"] = validations
+        __props__.__dict__["property"] = property
+        __props__.__dict__["property_id"] = property_id
+        __props__.__dict__["rule_errors"] = rule_errors
+        __props__.__dict__["rule_warnings"] = rule_warnings
+        __props__.__dict__["status"] = status
         __props__.__dict__["version"] = version
-        return PropertyIncludeActivation(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["warnings"] = warnings
+        return PropertyActivation(resource_name, opts=opts, __props__=__props__)
+
+    @property
+    @pulumi.getter(name="activationId")
+    def activation_id(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "activation_id")
 
     @property
     @pulumi.getter(name="autoAcknowledgeRuleWarnings")
     def auto_acknowledge_rule_warnings(self) -> pulumi.Output[Optional[bool]]:
         """
-        (Optional) Automatically acknowledge all rule warnings for activation and continue.
+        automatically acknowledge all rule warnings for activation to continue. default is true
         """
         return pulumi.get(self, "auto_acknowledge_rule_warnings")
 
     @property
     @pulumi.getter(name="complianceRecord")
-    def compliance_record(self) -> pulumi.Output[Optional['outputs.PropertyIncludeActivationComplianceRecord']]:
+    def compliance_record(self) -> pulumi.Output[Optional['outputs.PropertyActivationComplianceRecord']]:
         """
         Provides an audit record when activating on a production network
         """
         return pulumi.get(self, "compliance_record")
 
     @property
-    @pulumi.getter(name="contractId")
-    def contract_id(self) -> pulumi.Output[str]:
-        """
-        (Required) A contract's unique ID, including the optional `ctr_` prefix.
-        """
-        return pulumi.get(self, "contract_id")
-
-    @property
-    @pulumi.getter(name="groupId")
-    def group_id(self) -> pulumi.Output[str]:
-        """
-        (Required) A group's unique ID, including the optional `grp_` prefix.
-        """
-        return pulumi.get(self, "group_id")
+    @pulumi.getter
+    def contacts(self) -> pulumi.Output[Sequence[str]]:
+        return pulumi.get(self, "contacts")
 
     @property
-    @pulumi.getter(name="includeId")
-    def include_id(self) -> pulumi.Output[str]:
-        """
-        (Required) An include's unique ID with the optional `inc_` prefix.
-        """
-        return pulumi.get(self, "include_id")
+    @pulumi.getter
+    def errors(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "errors")
 
     @property
     @pulumi.getter
-    def network(self) -> pulumi.Output[str]:
-        """
-        (Required) The network for which the activation will be performed.
-        """
+    def network(self) -> pulumi.Output[Optional[str]]:
         return pulumi.get(self, "network")
 
     @property
     @pulumi.getter
     def note(self) -> pulumi.Output[Optional[str]]:
         """
-        (Optional) A log message assigned to the activation request.
+        assigns a log message to the activation request
         """
         return pulumi.get(self, "note")
 
     @property
-    @pulumi.getter(name="notifyEmails")
-    def notify_emails(self) -> pulumi.Output[Sequence[str]]:
-        """
-        (Required) The list of email addresses to notify when the activation status changes.
-        """
-        return pulumi.get(self, "notify_emails")
+    @pulumi.getter(name="propertyId")
+    def property_id(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "property_id")
+
+    @property
+    @pulumi.getter(name="ruleErrors")
+    def rule_errors(self) -> pulumi.Output[Sequence['outputs.PropertyActivationRuleError']]:
+        return pulumi.get(self, "rule_errors")
+
+    @property
+    @pulumi.getter(name="ruleWarnings")
+    def rule_warnings(self) -> pulumi.Output[Sequence['outputs.PropertyActivationRuleWarning']]:
+        return pulumi.get(self, "rule_warnings")
 
     @property
     @pulumi.getter
-    def validations(self) -> pulumi.Output[str]:
-        """
-        The validation information in JSON format
-        """
-        return pulumi.get(self, "validations")
+    def status(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "status")
 
     @property
     @pulumi.getter
     def version(self) -> pulumi.Output[int]:
-        """
-        (Required) The version of the include you want to activate.
-        """
         return pulumi.get(self, "version")
 
+    @property
+    @pulumi.getter
+    def warnings(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "warnings")
+
+    @property
+    @pulumi.getter
+    def property(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "property")
+
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/provider.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/provider.py`

 * *Files 2% similar despite different names*

```diff
@@ -25,18 +25,20 @@
                  edgerc: Optional[pulumi.Input[str]] = None,
                  gtm: Optional[pulumi.Input['ProviderGtmArgs']] = None,
                  gtm_section: Optional[pulumi.Input[str]] = None,
                  networklist_section: Optional[pulumi.Input[str]] = None,
                  networks: Optional[pulumi.Input[Sequence[pulumi.Input['ProviderNetworkArgs']]]] = None,
                  papi_section: Optional[pulumi.Input[str]] = None,
                  property: Optional[pulumi.Input['ProviderPropertyArgs']] = None,
-                 property_section: Optional[pulumi.Input[str]] = None):
+                 property_section: Optional[pulumi.Input[str]] = None,
+                 request_limit: Optional[pulumi.Input[int]] = None):
         """
         The set of arguments for constructing a Provider resource.
         :param pulumi.Input[str] config_section: The section of the edgerc file to use for configuration
+        :param pulumi.Input[int] request_limit: The maximum number of API requests to be made per second (0 for no limit)
         """
         if appsec_section is not None:
             warnings.warn("""The setting \"appsec_section\" has been deprecated.""", DeprecationWarning)
             pulumi.log.warn("""appsec_section is deprecated: The setting \"appsec_section\" has been deprecated.""")
         if appsec_section is not None:
             pulumi.set(__self__, "appsec_section", appsec_section)
         if appsecs is not None:
@@ -90,14 +92,16 @@
         if property is not None:
             pulumi.set(__self__, "property", property)
         if property_section is not None:
             warnings.warn("""The setting \"property_section\" has been deprecated.""", DeprecationWarning)
             pulumi.log.warn("""property_section is deprecated: The setting \"property_section\" has been deprecated.""")
         if property_section is not None:
             pulumi.set(__self__, "property_section", property_section)
+        if request_limit is not None:
+            pulumi.set(__self__, "request_limit", request_limit)
 
     @property
     @pulumi.getter(name="appsecSection")
     def appsec_section(self) -> Optional[pulumi.Input[str]]:
         return pulumi.get(self, "appsec_section")
 
     @appsec_section.setter
@@ -221,14 +225,26 @@
         return pulumi.get(self, "property_section")
 
     @property_section.setter
     def property_section(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "property_section", value)
 
     @property
+    @pulumi.getter(name="requestLimit")
+    def request_limit(self) -> Optional[pulumi.Input[int]]:
+        """
+        The maximum number of API requests to be made per second (0 for no limit)
+        """
+        return pulumi.get(self, "request_limit")
+
+    @request_limit.setter
+    def request_limit(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "request_limit", value)
+
+    @property
     @pulumi.getter
     def property(self) -> Optional[pulumi.Input['ProviderPropertyArgs']]:
         return pulumi.get(self, "property")
 
     @property.setter
     def property(self, value: Optional[pulumi.Input['ProviderPropertyArgs']]):
         pulumi.set(self, "property", value)
@@ -250,24 +266,26 @@
                  gtm: Optional[pulumi.Input[pulumi.InputType['ProviderGtmArgs']]] = None,
                  gtm_section: Optional[pulumi.Input[str]] = None,
                  networklist_section: Optional[pulumi.Input[str]] = None,
                  networks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ProviderNetworkArgs']]]]] = None,
                  papi_section: Optional[pulumi.Input[str]] = None,
                  property: Optional[pulumi.Input[pulumi.InputType['ProviderPropertyArgs']]] = None,
                  property_section: Optional[pulumi.Input[str]] = None,
+                 request_limit: Optional[pulumi.Input[int]] = None,
                  __props__=None):
         """
         The provider type for the akamai package. By default, resources use package-wide configuration
         settings, however an explicit `Provider` instance may be created and passed during resource
         construction to achieve fine-grained programmatic control over provider settings. See the
         [documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.
 
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
         :param pulumi.Input[str] config_section: The section of the edgerc file to use for configuration
+        :param pulumi.Input[int] request_limit: The maximum number of API requests to be made per second (0 for no limit)
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: Optional[ProviderArgs] = None,
                  opts: Optional[pulumi.ResourceOptions] = None):
@@ -303,14 +321,15 @@
                  gtm: Optional[pulumi.Input[pulumi.InputType['ProviderGtmArgs']]] = None,
                  gtm_section: Optional[pulumi.Input[str]] = None,
                  networklist_section: Optional[pulumi.Input[str]] = None,
                  networks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ProviderNetworkArgs']]]]] = None,
                  papi_section: Optional[pulumi.Input[str]] = None,
                  property: Optional[pulumi.Input[pulumi.InputType['ProviderPropertyArgs']]] = None,
                  property_section: Optional[pulumi.Input[str]] = None,
+                 request_limit: Optional[pulumi.Input[int]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
@@ -357,14 +376,15 @@
                 warnings.warn("""The setting \"property\" has been deprecated.""", DeprecationWarning)
                 pulumi.log.warn("""property is deprecated: The setting \"property\" has been deprecated.""")
             __props__.__dict__["property"] = pulumi.Output.from_input(property).apply(pulumi.runtime.to_json) if property is not None else None
             if property_section is not None and not opts.urn:
                 warnings.warn("""The setting \"property_section\" has been deprecated.""", DeprecationWarning)
                 pulumi.log.warn("""property_section is deprecated: The setting \"property_section\" has been deprecated.""")
             __props__.__dict__["property_section"] = property_section
+            __props__.__dict__["request_limit"] = pulumi.Output.from_input(request_limit).apply(pulumi.runtime.to_json) if request_limit is not None else None
         super(Provider, __self__).__init__(
             'akamai',
             resource_name,
             __props__,
             opts)
 
     @property
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/trafficmanagement/__init__.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/trafficmanagement/__init__.py`

 * *Files identical despite different names*

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/trafficmanagement/get_gtm_default_datacenter.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/get_gtm_default_datacenter.py`

 * *Files 25% similar despite different names*

```diff
@@ -3,25 +3,23 @@
 # *** Do not edit by hand unless you're certain you know what you are doing! ***
 
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
-from .. import _utilities
+from . import _utilities
 
 __all__ = [
     'GetGtmDefaultDatacenterResult',
     'AwaitableGetGtmDefaultDatacenterResult',
     'get_gtm_default_datacenter',
     'get_gtm_default_datacenter_output',
 ]
 
-warnings.warn("""akamai.trafficmanagement.getGtmDefaultDatacenter has been deprecated in favor of akamai.getGtmDefaultDatacenter""", DeprecationWarning)
-
 @pulumi.output_type
 class GetGtmDefaultDatacenterResult:
     """
     A collection of values returned by getGtmDefaultDatacenter.
     """
     def __init__(__self__, datacenter=None, datacenter_id=None, domain=None, id=None, nickname=None):
         if datacenter and not isinstance(datacenter, int):
@@ -82,55 +80,31 @@
             nickname=self.nickname)
 
 
 def get_gtm_default_datacenter(datacenter: Optional[int] = None,
                                domain: Optional[str] = None,
                                opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetGtmDefaultDatacenterResult:
     """
-    Use the _get_gtm_default_datacenter_ data source to retrieve the default data center, ID, and nickname.
-
-    ## Attributes reference
-
-    This data source supports these attributes:
-
-    * `id` - The data resource ID. Enter in this format: `<domain>:default_datacenter:<datacenter_id>`.
-    * `datacenter_id` - The default data center ID.
-    * `nickname` - The default data center nickname.
-
-
-    :param int datacenter: The default is `5400`.
+    Use this data source to access information about an existing resource.
     """
-    pulumi.log.warn("""get_gtm_default_datacenter is deprecated: akamai.trafficmanagement.getGtmDefaultDatacenter has been deprecated in favor of akamai.getGtmDefaultDatacenter""")
     __args__ = dict()
     __args__['datacenter'] = datacenter
     __args__['domain'] = domain
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
-    __ret__ = pulumi.runtime.invoke('akamai:trafficmanagement/getGtmDefaultDatacenter:getGtmDefaultDatacenter', __args__, opts=opts, typ=GetGtmDefaultDatacenterResult).value
+    __ret__ = pulumi.runtime.invoke('akamai:index/getGtmDefaultDatacenter:getGtmDefaultDatacenter', __args__, opts=opts, typ=GetGtmDefaultDatacenterResult).value
 
     return AwaitableGetGtmDefaultDatacenterResult(
         datacenter=__ret__.datacenter,
         datacenter_id=__ret__.datacenter_id,
         domain=__ret__.domain,
         id=__ret__.id,
         nickname=__ret__.nickname)
 
 
 @_utilities.lift_output_func(get_gtm_default_datacenter)
 def get_gtm_default_datacenter_output(datacenter: Optional[pulumi.Input[Optional[int]]] = None,
                                       domain: Optional[pulumi.Input[str]] = None,
                                       opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetGtmDefaultDatacenterResult]:
     """
-    Use the _get_gtm_default_datacenter_ data source to retrieve the default data center, ID, and nickname.
-
-    ## Attributes reference
-
-    This data source supports these attributes:
-
-    * `id` - The data resource ID. Enter in this format: `<domain>:default_datacenter:<datacenter_id>`.
-    * `datacenter_id` - The default data center ID.
-    * `nickname` - The default data center nickname.
-
-
-    :param int datacenter: The default is `5400`.
+    Use this data source to access information about an existing resource.
     """
-    pulumi.log.warn("""get_gtm_default_datacenter is deprecated: akamai.trafficmanagement.getGtmDefaultDatacenter has been deprecated in favor of akamai.getGtmDefaultDatacenter""")
     ...
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai/trafficmanagement/gtm_a_smap.py` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai/properties/edge_host_name.py`

 * *Files 27% similar despite different names*

```diff
@@ -4,380 +4,528 @@
 
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from .. import _utilities
-from . import outputs
-from ._inputs import *
 
-__all__ = ['GtmASmapArgs', 'GtmASmap']
+__all__ = ['EdgeHostNameArgs', 'EdgeHostName']
 
 @pulumi.input_type
-class GtmASmapArgs:
+class EdgeHostNameArgs:
     def __init__(__self__, *,
-                 default_datacenter: pulumi.Input['GtmASmapDefaultDatacenterArgs'],
-                 domain: pulumi.Input[str],
-                 assignments: Optional[pulumi.Input[Sequence[pulumi.Input['GtmASmapAssignmentArgs']]]] = None,
-                 name: Optional[pulumi.Input[str]] = None,
-                 wait_on_complete: Optional[pulumi.Input[bool]] = None):
-        """
-        The set of arguments for constructing a GtmASmap resource.
-        :param pulumi.Input['GtmASmapDefaultDatacenterArgs'] default_datacenter: A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:
-        :param pulumi.Input[str] domain: The GTM Domain name for the AS map.
-        :param pulumi.Input[Sequence[pulumi.Input['GtmASmapAssignmentArgs']]] assignments: Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:
-        :param pulumi.Input[str] name: A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.
-        :param pulumi.Input[bool] wait_on_complete: A boolean that, if `true`, waits for transaction to complete.
-        """
-        pulumi.set(__self__, "default_datacenter", default_datacenter)
-        pulumi.set(__self__, "domain", domain)
-        if assignments is not None:
-            pulumi.set(__self__, "assignments", assignments)
-        if name is not None:
-            pulumi.set(__self__, "name", name)
-        if wait_on_complete is not None:
-            pulumi.set(__self__, "wait_on_complete", wait_on_complete)
+                 edge_hostname: pulumi.Input[str],
+                 ip_behavior: pulumi.Input[str],
+                 certificate: Optional[pulumi.Input[int]] = None,
+                 contract: Optional[pulumi.Input[str]] = None,
+                 contract_id: Optional[pulumi.Input[str]] = None,
+                 group: Optional[pulumi.Input[str]] = None,
+                 group_id: Optional[pulumi.Input[str]] = None,
+                 product: Optional[pulumi.Input[str]] = None,
+                 product_id: Optional[pulumi.Input[str]] = None,
+                 status_update_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 use_cases: Optional[pulumi.Input[str]] = None):
+        """
+        The set of arguments for constructing a EdgeHostName resource.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] status_update_emails: Email address that should receive updates on the IP behavior update request. Required for update operation.
+        :param pulumi.Input[str] use_cases: A JSON encoded list of use cases
+        """
+        pulumi.set(__self__, "edge_hostname", edge_hostname)
+        pulumi.set(__self__, "ip_behavior", ip_behavior)
+        if certificate is not None:
+            pulumi.set(__self__, "certificate", certificate)
+        if contract is not None:
+            warnings.warn("""The setting \"contract\" has been deprecated.""", DeprecationWarning)
+            pulumi.log.warn("""contract is deprecated: The setting \"contract\" has been deprecated.""")
+        if contract is not None:
+            pulumi.set(__self__, "contract", contract)
+        if contract_id is not None:
+            pulumi.set(__self__, "contract_id", contract_id)
+        if group is not None:
+            warnings.warn("""The setting \"group\" has been deprecated.""", DeprecationWarning)
+            pulumi.log.warn("""group is deprecated: The setting \"group\" has been deprecated.""")
+        if group is not None:
+            pulumi.set(__self__, "group", group)
+        if group_id is not None:
+            pulumi.set(__self__, "group_id", group_id)
+        if product is not None:
+            warnings.warn("""The setting \"product\" has been deprecated.""", DeprecationWarning)
+            pulumi.log.warn("""product is deprecated: The setting \"product\" has been deprecated.""")
+        if product is not None:
+            pulumi.set(__self__, "product", product)
+        if product_id is not None:
+            pulumi.set(__self__, "product_id", product_id)
+        if status_update_emails is not None:
+            pulumi.set(__self__, "status_update_emails", status_update_emails)
+        if use_cases is not None:
+            pulumi.set(__self__, "use_cases", use_cases)
+
+    @property
+    @pulumi.getter(name="edgeHostname")
+    def edge_hostname(self) -> pulumi.Input[str]:
+        return pulumi.get(self, "edge_hostname")
+
+    @edge_hostname.setter
+    def edge_hostname(self, value: pulumi.Input[str]):
+        pulumi.set(self, "edge_hostname", value)
+
+    @property
+    @pulumi.getter(name="ipBehavior")
+    def ip_behavior(self) -> pulumi.Input[str]:
+        return pulumi.get(self, "ip_behavior")
+
+    @ip_behavior.setter
+    def ip_behavior(self, value: pulumi.Input[str]):
+        pulumi.set(self, "ip_behavior", value)
 
     @property
-    @pulumi.getter(name="defaultDatacenter")
-    def default_datacenter(self) -> pulumi.Input['GtmASmapDefaultDatacenterArgs']:
-        """
-        A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:
-        """
-        return pulumi.get(self, "default_datacenter")
+    @pulumi.getter
+    def certificate(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "certificate")
 
-    @default_datacenter.setter
-    def default_datacenter(self, value: pulumi.Input['GtmASmapDefaultDatacenterArgs']):
-        pulumi.set(self, "default_datacenter", value)
+    @certificate.setter
+    def certificate(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "certificate", value)
 
     @property
     @pulumi.getter
-    def domain(self) -> pulumi.Input[str]:
-        """
-        The GTM Domain name for the AS map.
-        """
-        return pulumi.get(self, "domain")
+    def contract(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "contract")
 
-    @domain.setter
-    def domain(self, value: pulumi.Input[str]):
-        pulumi.set(self, "domain", value)
+    @contract.setter
+    def contract(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "contract", value)
+
+    @property
+    @pulumi.getter(name="contractId")
+    def contract_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "contract_id")
+
+    @contract_id.setter
+    def contract_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "contract_id", value)
 
     @property
     @pulumi.getter
-    def assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmASmapAssignmentArgs']]]]:
-        """
-        Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:
-        """
-        return pulumi.get(self, "assignments")
+    def group(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "group")
 
-    @assignments.setter
-    def assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmASmapAssignmentArgs']]]]):
-        pulumi.set(self, "assignments", value)
+    @group.setter
+    def group(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "group", value)
+
+    @property
+    @pulumi.getter(name="groupId")
+    def group_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "group_id")
+
+    @group_id.setter
+    def group_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "group_id", value)
 
     @property
     @pulumi.getter
-    def name(self) -> Optional[pulumi.Input[str]]:
+    def product(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "product")
+
+    @product.setter
+    def product(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "product", value)
+
+    @property
+    @pulumi.getter(name="productId")
+    def product_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "product_id")
+
+    @product_id.setter
+    def product_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "product_id", value)
+
+    @property
+    @pulumi.getter(name="statusUpdateEmails")
+    def status_update_emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.
+        Email address that should receive updates on the IP behavior update request. Required for update operation.
         """
-        return pulumi.get(self, "name")
+        return pulumi.get(self, "status_update_emails")
 
-    @name.setter
-    def name(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "name", value)
+    @status_update_emails.setter
+    def status_update_emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
+        pulumi.set(self, "status_update_emails", value)
 
     @property
-    @pulumi.getter(name="waitOnComplete")
-    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
+    @pulumi.getter(name="useCases")
+    def use_cases(self) -> Optional[pulumi.Input[str]]:
         """
-        A boolean that, if `true`, waits for transaction to complete.
+        A JSON encoded list of use cases
         """
-        return pulumi.get(self, "wait_on_complete")
+        return pulumi.get(self, "use_cases")
 
-    @wait_on_complete.setter
-    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "wait_on_complete", value)
+    @use_cases.setter
+    def use_cases(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "use_cases", value)
 
 
 @pulumi.input_type
-class _GtmASmapState:
+class _EdgeHostNameState:
     def __init__(__self__, *,
-                 assignments: Optional[pulumi.Input[Sequence[pulumi.Input['GtmASmapAssignmentArgs']]]] = None,
-                 default_datacenter: Optional[pulumi.Input['GtmASmapDefaultDatacenterArgs']] = None,
-                 domain: Optional[pulumi.Input[str]] = None,
-                 name: Optional[pulumi.Input[str]] = None,
-                 wait_on_complete: Optional[pulumi.Input[bool]] = None):
-        """
-        Input properties used for looking up and filtering GtmASmap resources.
-        :param pulumi.Input[Sequence[pulumi.Input['GtmASmapAssignmentArgs']]] assignments: Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:
-        :param pulumi.Input['GtmASmapDefaultDatacenterArgs'] default_datacenter: A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:
-        :param pulumi.Input[str] domain: The GTM Domain name for the AS map.
-        :param pulumi.Input[str] name: A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.
-        :param pulumi.Input[bool] wait_on_complete: A boolean that, if `true`, waits for transaction to complete.
-        """
-        if assignments is not None:
-            pulumi.set(__self__, "assignments", assignments)
-        if default_datacenter is not None:
-            pulumi.set(__self__, "default_datacenter", default_datacenter)
-        if domain is not None:
-            pulumi.set(__self__, "domain", domain)
-        if name is not None:
-            pulumi.set(__self__, "name", name)
-        if wait_on_complete is not None:
-            pulumi.set(__self__, "wait_on_complete", wait_on_complete)
+                 certificate: Optional[pulumi.Input[int]] = None,
+                 contract: Optional[pulumi.Input[str]] = None,
+                 contract_id: Optional[pulumi.Input[str]] = None,
+                 edge_hostname: Optional[pulumi.Input[str]] = None,
+                 group: Optional[pulumi.Input[str]] = None,
+                 group_id: Optional[pulumi.Input[str]] = None,
+                 ip_behavior: Optional[pulumi.Input[str]] = None,
+                 product: Optional[pulumi.Input[str]] = None,
+                 product_id: Optional[pulumi.Input[str]] = None,
+                 status_update_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 use_cases: Optional[pulumi.Input[str]] = None):
+        """
+        Input properties used for looking up and filtering EdgeHostName resources.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] status_update_emails: Email address that should receive updates on the IP behavior update request. Required for update operation.
+        :param pulumi.Input[str] use_cases: A JSON encoded list of use cases
+        """
+        if certificate is not None:
+            pulumi.set(__self__, "certificate", certificate)
+        if contract is not None:
+            warnings.warn("""The setting \"contract\" has been deprecated.""", DeprecationWarning)
+            pulumi.log.warn("""contract is deprecated: The setting \"contract\" has been deprecated.""")
+        if contract is not None:
+            pulumi.set(__self__, "contract", contract)
+        if contract_id is not None:
+            pulumi.set(__self__, "contract_id", contract_id)
+        if edge_hostname is not None:
+            pulumi.set(__self__, "edge_hostname", edge_hostname)
+        if group is not None:
+            warnings.warn("""The setting \"group\" has been deprecated.""", DeprecationWarning)
+            pulumi.log.warn("""group is deprecated: The setting \"group\" has been deprecated.""")
+        if group is not None:
+            pulumi.set(__self__, "group", group)
+        if group_id is not None:
+            pulumi.set(__self__, "group_id", group_id)
+        if ip_behavior is not None:
+            pulumi.set(__self__, "ip_behavior", ip_behavior)
+        if product is not None:
+            warnings.warn("""The setting \"product\" has been deprecated.""", DeprecationWarning)
+            pulumi.log.warn("""product is deprecated: The setting \"product\" has been deprecated.""")
+        if product is not None:
+            pulumi.set(__self__, "product", product)
+        if product_id is not None:
+            pulumi.set(__self__, "product_id", product_id)
+        if status_update_emails is not None:
+            pulumi.set(__self__, "status_update_emails", status_update_emails)
+        if use_cases is not None:
+            pulumi.set(__self__, "use_cases", use_cases)
 
     @property
     @pulumi.getter
-    def assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GtmASmapAssignmentArgs']]]]:
-        """
-        Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:
-        """
-        return pulumi.get(self, "assignments")
+    def certificate(self) -> Optional[pulumi.Input[int]]:
+        return pulumi.get(self, "certificate")
 
-    @assignments.setter
-    def assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GtmASmapAssignmentArgs']]]]):
-        pulumi.set(self, "assignments", value)
+    @certificate.setter
+    def certificate(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "certificate", value)
 
     @property
-    @pulumi.getter(name="defaultDatacenter")
-    def default_datacenter(self) -> Optional[pulumi.Input['GtmASmapDefaultDatacenterArgs']]:
-        """
-        A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:
-        """
-        return pulumi.get(self, "default_datacenter")
+    @pulumi.getter
+    def contract(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "contract")
+
+    @contract.setter
+    def contract(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "contract", value)
+
+    @property
+    @pulumi.getter(name="contractId")
+    def contract_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "contract_id")
 
-    @default_datacenter.setter
-    def default_datacenter(self, value: Optional[pulumi.Input['GtmASmapDefaultDatacenterArgs']]):
-        pulumi.set(self, "default_datacenter", value)
+    @contract_id.setter
+    def contract_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "contract_id", value)
+
+    @property
+    @pulumi.getter(name="edgeHostname")
+    def edge_hostname(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "edge_hostname")
+
+    @edge_hostname.setter
+    def edge_hostname(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "edge_hostname", value)
 
     @property
     @pulumi.getter
-    def domain(self) -> Optional[pulumi.Input[str]]:
-        """
-        The GTM Domain name for the AS map.
-        """
-        return pulumi.get(self, "domain")
+    def group(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "group")
 
-    @domain.setter
-    def domain(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "domain", value)
+    @group.setter
+    def group(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "group", value)
+
+    @property
+    @pulumi.getter(name="groupId")
+    def group_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "group_id")
+
+    @group_id.setter
+    def group_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "group_id", value)
+
+    @property
+    @pulumi.getter(name="ipBehavior")
+    def ip_behavior(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "ip_behavior")
+
+    @ip_behavior.setter
+    def ip_behavior(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "ip_behavior", value)
 
     @property
     @pulumi.getter
-    def name(self) -> Optional[pulumi.Input[str]]:
+    def product(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "product")
+
+    @product.setter
+    def product(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "product", value)
+
+    @property
+    @pulumi.getter(name="productId")
+    def product_id(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "product_id")
+
+    @product_id.setter
+    def product_id(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "product_id", value)
+
+    @property
+    @pulumi.getter(name="statusUpdateEmails")
+    def status_update_emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.
+        Email address that should receive updates on the IP behavior update request. Required for update operation.
         """
-        return pulumi.get(self, "name")
+        return pulumi.get(self, "status_update_emails")
 
-    @name.setter
-    def name(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "name", value)
+    @status_update_emails.setter
+    def status_update_emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
+        pulumi.set(self, "status_update_emails", value)
 
     @property
-    @pulumi.getter(name="waitOnComplete")
-    def wait_on_complete(self) -> Optional[pulumi.Input[bool]]:
+    @pulumi.getter(name="useCases")
+    def use_cases(self) -> Optional[pulumi.Input[str]]:
         """
-        A boolean that, if `true`, waits for transaction to complete.
+        A JSON encoded list of use cases
         """
-        return pulumi.get(self, "wait_on_complete")
+        return pulumi.get(self, "use_cases")
 
-    @wait_on_complete.setter
-    def wait_on_complete(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "wait_on_complete", value)
+    @use_cases.setter
+    def use_cases(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "use_cases", value)
 
 
-warnings.warn("""akamai.trafficmanagement.GtmASmap has been deprecated in favor of akamai.GtmAsmap""", DeprecationWarning)
+warnings.warn("""akamai.properties.EdgeHostName has been deprecated in favor of akamai.EdgeHostName""", DeprecationWarning)
 
 
-class GtmASmap(pulumi.CustomResource):
-    warnings.warn("""akamai.trafficmanagement.GtmASmap has been deprecated in favor of akamai.GtmAsmap""", DeprecationWarning)
+class EdgeHostName(pulumi.CustomResource):
+    warnings.warn("""akamai.properties.EdgeHostName has been deprecated in favor of akamai.EdgeHostName""", DeprecationWarning)
 
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 assignments: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmASmapAssignmentArgs']]]]] = None,
-                 default_datacenter: Optional[pulumi.Input[pulumi.InputType['GtmASmapDefaultDatacenterArgs']]] = None,
-                 domain: Optional[pulumi.Input[str]] = None,
-                 name: Optional[pulumi.Input[str]] = None,
-                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
+                 certificate: Optional[pulumi.Input[int]] = None,
+                 contract: Optional[pulumi.Input[str]] = None,
+                 contract_id: Optional[pulumi.Input[str]] = None,
+                 edge_hostname: Optional[pulumi.Input[str]] = None,
+                 group: Optional[pulumi.Input[str]] = None,
+                 group_id: Optional[pulumi.Input[str]] = None,
+                 ip_behavior: Optional[pulumi.Input[str]] = None,
+                 product: Optional[pulumi.Input[str]] = None,
+                 product_id: Optional[pulumi.Input[str]] = None,
+                 status_update_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 use_cases: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        Use the `GtmAsmap` resource to create, configure, and import a GTM Autonomous System (AS) map. AS mapping lets you configure a GTM property that returns a CNAME based on the AS number associated with the requester's IP address.
-
-        You can reuse maps for multiple properties or create new ones. AS maps split the Internet into multiple AS block zones. Properties that use AS maps can specify handout integers for each zone. AS mapping lets you configure a property that directs users to a specific environment or to the origin.
-
-        > **Note** Import requires an ID with this format: `existing_domain_name`:`existing_map_name`.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        demo_asmap = akamai.GtmAsmap("demoAsmap",
-            default_datacenter=akamai.GtmAsmapDefaultDatacenterArgs(
-                datacenter_id=5400,
-                nickname="All Other AS numbers",
-            ),
-            domain="demo_domain.akadns.net")
-        ```
-
+        Create a EdgeHostName resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmASmapAssignmentArgs']]]] assignments: Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:
-        :param pulumi.Input[pulumi.InputType['GtmASmapDefaultDatacenterArgs']] default_datacenter: A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:
-        :param pulumi.Input[str] domain: The GTM Domain name for the AS map.
-        :param pulumi.Input[str] name: A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.
-        :param pulumi.Input[bool] wait_on_complete: A boolean that, if `true`, waits for transaction to complete.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] status_update_emails: Email address that should receive updates on the IP behavior update request. Required for update operation.
+        :param pulumi.Input[str] use_cases: A JSON encoded list of use cases
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: GtmASmapArgs,
+                 args: EdgeHostNameArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        Use the `GtmAsmap` resource to create, configure, and import a GTM Autonomous System (AS) map. AS mapping lets you configure a GTM property that returns a CNAME based on the AS number associated with the requester's IP address.
-
-        You can reuse maps for multiple properties or create new ones. AS maps split the Internet into multiple AS block zones. Properties that use AS maps can specify handout integers for each zone. AS mapping lets you configure a property that directs users to a specific environment or to the origin.
-
-        > **Note** Import requires an ID with this format: `existing_domain_name`:`existing_map_name`.
-
-        ## Example Usage
-
-        Basic usage:
-
-        ```python
-        import pulumi
-        import pulumi_akamai as akamai
-
-        demo_asmap = akamai.GtmAsmap("demoAsmap",
-            default_datacenter=akamai.GtmAsmapDefaultDatacenterArgs(
-                datacenter_id=5400,
-                nickname="All Other AS numbers",
-            ),
-            domain="demo_domain.akadns.net")
-        ```
-
+        Create a EdgeHostName resource with the given unique name, props, and options.
         :param str resource_name: The name of the resource.
-        :param GtmASmapArgs args: The arguments to use to populate this resource's properties.
+        :param EdgeHostNameArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(GtmASmapArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(EdgeHostNameArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 assignments: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmASmapAssignmentArgs']]]]] = None,
-                 default_datacenter: Optional[pulumi.Input[pulumi.InputType['GtmASmapDefaultDatacenterArgs']]] = None,
-                 domain: Optional[pulumi.Input[str]] = None,
-                 name: Optional[pulumi.Input[str]] = None,
-                 wait_on_complete: Optional[pulumi.Input[bool]] = None,
+                 certificate: Optional[pulumi.Input[int]] = None,
+                 contract: Optional[pulumi.Input[str]] = None,
+                 contract_id: Optional[pulumi.Input[str]] = None,
+                 edge_hostname: Optional[pulumi.Input[str]] = None,
+                 group: Optional[pulumi.Input[str]] = None,
+                 group_id: Optional[pulumi.Input[str]] = None,
+                 ip_behavior: Optional[pulumi.Input[str]] = None,
+                 product: Optional[pulumi.Input[str]] = None,
+                 product_id: Optional[pulumi.Input[str]] = None,
+                 status_update_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 use_cases: Optional[pulumi.Input[str]] = None,
                  __props__=None):
-        pulumi.log.warn("""GtmASmap is deprecated: akamai.trafficmanagement.GtmASmap has been deprecated in favor of akamai.GtmAsmap""")
+        pulumi.log.warn("""EdgeHostName is deprecated: akamai.properties.EdgeHostName has been deprecated in favor of akamai.EdgeHostName""")
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = GtmASmapArgs.__new__(GtmASmapArgs)
+            __props__ = EdgeHostNameArgs.__new__(EdgeHostNameArgs)
 
-            __props__.__dict__["assignments"] = assignments
-            if default_datacenter is None and not opts.urn:
-                raise TypeError("Missing required property 'default_datacenter'")
-            __props__.__dict__["default_datacenter"] = default_datacenter
-            if domain is None and not opts.urn:
-                raise TypeError("Missing required property 'domain'")
-            __props__.__dict__["domain"] = domain
-            __props__.__dict__["name"] = name
-            __props__.__dict__["wait_on_complete"] = wait_on_complete
-        super(GtmASmap, __self__).__init__(
-            'akamai:trafficmanagement/gtmASmap:GtmASmap',
+            __props__.__dict__["certificate"] = certificate
+            if contract is not None and not opts.urn:
+                warnings.warn("""The setting \"contract\" has been deprecated.""", DeprecationWarning)
+                pulumi.log.warn("""contract is deprecated: The setting \"contract\" has been deprecated.""")
+            __props__.__dict__["contract"] = contract
+            __props__.__dict__["contract_id"] = contract_id
+            if edge_hostname is None and not opts.urn:
+                raise TypeError("Missing required property 'edge_hostname'")
+            __props__.__dict__["edge_hostname"] = edge_hostname
+            if group is not None and not opts.urn:
+                warnings.warn("""The setting \"group\" has been deprecated.""", DeprecationWarning)
+                pulumi.log.warn("""group is deprecated: The setting \"group\" has been deprecated.""")
+            __props__.__dict__["group"] = group
+            __props__.__dict__["group_id"] = group_id
+            if ip_behavior is None and not opts.urn:
+                raise TypeError("Missing required property 'ip_behavior'")
+            __props__.__dict__["ip_behavior"] = ip_behavior
+            if product is not None and not opts.urn:
+                warnings.warn("""The setting \"product\" has been deprecated.""", DeprecationWarning)
+                pulumi.log.warn("""product is deprecated: The setting \"product\" has been deprecated.""")
+            __props__.__dict__["product"] = product
+            __props__.__dict__["product_id"] = product_id
+            __props__.__dict__["status_update_emails"] = status_update_emails
+            __props__.__dict__["use_cases"] = use_cases
+        super(EdgeHostName, __self__).__init__(
+            'akamai:properties/edgeHostName:EdgeHostName',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
-            assignments: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmASmapAssignmentArgs']]]]] = None,
-            default_datacenter: Optional[pulumi.Input[pulumi.InputType['GtmASmapDefaultDatacenterArgs']]] = None,
-            domain: Optional[pulumi.Input[str]] = None,
-            name: Optional[pulumi.Input[str]] = None,
-            wait_on_complete: Optional[pulumi.Input[bool]] = None) -> 'GtmASmap':
+            certificate: Optional[pulumi.Input[int]] = None,
+            contract: Optional[pulumi.Input[str]] = None,
+            contract_id: Optional[pulumi.Input[str]] = None,
+            edge_hostname: Optional[pulumi.Input[str]] = None,
+            group: Optional[pulumi.Input[str]] = None,
+            group_id: Optional[pulumi.Input[str]] = None,
+            ip_behavior: Optional[pulumi.Input[str]] = None,
+            product: Optional[pulumi.Input[str]] = None,
+            product_id: Optional[pulumi.Input[str]] = None,
+            status_update_emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+            use_cases: Optional[pulumi.Input[str]] = None) -> 'EdgeHostName':
         """
-        Get an existing GtmASmap resource's state with the given name, id, and optional extra
+        Get an existing EdgeHostName resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['GtmASmapAssignmentArgs']]]] assignments: Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:
-        :param pulumi.Input[pulumi.InputType['GtmASmapDefaultDatacenterArgs']] default_datacenter: A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:
-        :param pulumi.Input[str] domain: The GTM Domain name for the AS map.
-        :param pulumi.Input[str] name: A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.
-        :param pulumi.Input[bool] wait_on_complete: A boolean that, if `true`, waits for transaction to complete.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] status_update_emails: Email address that should receive updates on the IP behavior update request. Required for update operation.
+        :param pulumi.Input[str] use_cases: A JSON encoded list of use cases
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _GtmASmapState.__new__(_GtmASmapState)
+        __props__ = _EdgeHostNameState.__new__(_EdgeHostNameState)
 
-        __props__.__dict__["assignments"] = assignments
-        __props__.__dict__["default_datacenter"] = default_datacenter
-        __props__.__dict__["domain"] = domain
-        __props__.__dict__["name"] = name
-        __props__.__dict__["wait_on_complete"] = wait_on_complete
-        return GtmASmap(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["certificate"] = certificate
+        __props__.__dict__["contract"] = contract
+        __props__.__dict__["contract_id"] = contract_id
+        __props__.__dict__["edge_hostname"] = edge_hostname
+        __props__.__dict__["group"] = group
+        __props__.__dict__["group_id"] = group_id
+        __props__.__dict__["ip_behavior"] = ip_behavior
+        __props__.__dict__["product"] = product
+        __props__.__dict__["product_id"] = product_id
+        __props__.__dict__["status_update_emails"] = status_update_emails
+        __props__.__dict__["use_cases"] = use_cases
+        return EdgeHostName(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter
-    def assignments(self) -> pulumi.Output[Optional[Sequence['outputs.GtmASmapAssignment']]]:
-        """
-        Contains information about the AS zone groupings of AS IDs. You can have multiple entries with this argument. If used, requires these arguments:
-        """
-        return pulumi.get(self, "assignments")
+    def certificate(self) -> pulumi.Output[Optional[int]]:
+        return pulumi.get(self, "certificate")
 
     @property
-    @pulumi.getter(name="defaultDatacenter")
-    def default_datacenter(self) -> pulumi.Output['outputs.GtmASmapDefaultDatacenter']:
-        """
-        A placeholder for all other AS zones not found in these AS zones. Requires these additional arguments:
-        """
-        return pulumi.get(self, "default_datacenter")
+    @pulumi.getter
+    def contract(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "contract")
+
+    @property
+    @pulumi.getter(name="contractId")
+    def contract_id(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "contract_id")
+
+    @property
+    @pulumi.getter(name="edgeHostname")
+    def edge_hostname(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "edge_hostname")
 
     @property
     @pulumi.getter
-    def domain(self) -> pulumi.Output[str]:
-        """
-        The GTM Domain name for the AS map.
-        """
-        return pulumi.get(self, "domain")
+    def group(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "group")
+
+    @property
+    @pulumi.getter(name="groupId")
+    def group_id(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "group_id")
+
+    @property
+    @pulumi.getter(name="ipBehavior")
+    def ip_behavior(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "ip_behavior")
 
     @property
     @pulumi.getter
-    def name(self) -> pulumi.Output[str]:
+    def product(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "product")
+
+    @property
+    @pulumi.getter(name="productId")
+    def product_id(self) -> pulumi.Output[str]:
+        return pulumi.get(self, "product_id")
+
+    @property
+    @pulumi.getter(name="statusUpdateEmails")
+    def status_update_emails(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        A descriptive label for the AS map. Properties set up for  AS mapping can use this as reference.
+        Email address that should receive updates on the IP behavior update request. Required for update operation.
         """
-        return pulumi.get(self, "name")
+        return pulumi.get(self, "status_update_emails")
 
     @property
-    @pulumi.getter(name="waitOnComplete")
-    def wait_on_complete(self) -> pulumi.Output[Optional[bool]]:
+    @pulumi.getter(name="useCases")
+    def use_cases(self) -> pulumi.Output[Optional[str]]:
         """
-        A boolean that, if `true`, waits for transaction to complete.
+        A JSON encoded list of use cases
         """
-        return pulumi.get(self, "wait_on_complete")
+        return pulumi.get(self, "use_cases")
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai.egg-info/PKG-INFO` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai.egg-info/PKG-INFO`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pulumi-akamai
-Version: 4.4.0a1680909501
+Version: 4.4.0a1681843117
 Summary: A Pulumi package for creating and managing akamai cloud resources.
 Home-page: https://pulumi.io
 License: Apache-2.0
 Project-URL: Repository, https://github.com/pulumi/pulumi-akamai
 Keywords: pulumi akamai
 Platform: UNKNOWN
 Description-Content-Type: text/markdown
```

### Comparing `pulumi_akamai-4.4.0a1680909501/pulumi_akamai.egg-info/SOURCES.txt` & `pulumi_akamai-4.4.0a1681843117/pulumi_akamai.egg-info/SOURCES.txt`

 * *Files 1% similar despite different names*

```diff
@@ -47,14 +47,15 @@
 pulumi_akamai/app_sec_slow_post_protection.py
 pulumi_akamai/app_sec_threat_intel.py
 pulumi_akamai/app_sec_version_nodes.py
 pulumi_akamai/app_sec_waf_mode.py
 pulumi_akamai/app_sec_waf_protection.py
 pulumi_akamai/app_sec_wap_selected_hostnames.py
 pulumi_akamai/appsec_advanced_settings_attack_payload_logging.py
+pulumi_akamai/appsec_advanced_settings_request_body.py
 pulumi_akamai/cloudlets_application_load_balancer.py
 pulumi_akamai/cloudlets_application_load_balancer_activation.py
 pulumi_akamai/cloudlets_policy.py
 pulumi_akamai/cloudlets_policy_activation.py
 pulumi_akamai/cp_code.py
 pulumi_akamai/cps_dv_enrollment.py
 pulumi_akamai/cps_dv_validation.py
@@ -112,14 +113,15 @@
 pulumi_akamai/get_app_sec_slow_post.py
 pulumi_akamai/get_app_sec_threat_intel.py
 pulumi_akamai/get_app_sec_tuning_recommendations.py
 pulumi_akamai/get_app_sec_version_notes.py
 pulumi_akamai/get_app_sec_waf_mode.py
 pulumi_akamai/get_app_sec_wap_selected_hostnames.py
 pulumi_akamai/get_appsec_advanced_settings_attack_payload_logging.py
+pulumi_akamai/get_appsec_advanced_settings_request_body.py
 pulumi_akamai/get_authorities_set.py
 pulumi_akamai/get_cloudlets_api_prioritization_match_rule.py
 pulumi_akamai/get_cloudlets_application_load_balancer.py
 pulumi_akamai/get_cloudlets_application_load_balancer_match_rule.py
 pulumi_akamai/get_cloudlets_audience_segmentation_match_rule.py
 pulumi_akamai/get_cloudlets_edge_redirector_match_rule.py
 pulumi_akamai/get_cloudlets_forward_rewrite_match_rule.py
@@ -163,14 +165,15 @@
 pulumi_akamai/get_property_include_activation.py
 pulumi_akamai/get_property_include_parents.py
 pulumi_akamai/get_property_include_rules.py
 pulumi_akamai/get_property_includes.py
 pulumi_akamai/get_property_products.py
 pulumi_akamai/get_property_rule_formats.py
 pulumi_akamai/get_property_rules.py
+pulumi_akamai/get_property_rules_builder.py
 pulumi_akamai/get_property_rules_template.py
 pulumi_akamai/gtm_asmap.py
 pulumi_akamai/gtm_cidrmap.py
 pulumi_akamai/gtm_datacenter.py
 pulumi_akamai/gtm_domain.py
 pulumi_akamai/gtm_geomap.py
 pulumi_akamai/gtm_property.py
```

### Comparing `pulumi_akamai-4.4.0a1680909501/setup.py` & `pulumi_akamai-4.4.0a1681843117/setup.py`

 * *Files 5% similar despite different names*

```diff
@@ -4,16 +4,16 @@
 
 import errno
 from setuptools import setup, find_packages
 from setuptools.command.install import install
 from subprocess import check_call
 
 
-VERSION = "4.4.0a1680909501"
-PLUGIN_VERSION = "4.4.0-alpha.1680909501+6a80bfd7"
+VERSION = "4.4.0a1681843117"
+PLUGIN_VERSION = "4.4.0-alpha.1681843117+5ae2d9b5"
 
 class InstallPluginCommand(install):
     def run(self):
         install.run(self)
         try:
             check_call(['pulumi', 'plugin', 'install', 'resource', 'akamai', PLUGIN_VERSION])
         except OSError as error:
```

