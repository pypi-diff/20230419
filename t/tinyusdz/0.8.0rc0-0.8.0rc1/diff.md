# Comparing `tmp/tinyusdz-0.8.0rc0.tar.gz` & `tmp/tinyusdz-0.8.0rc1.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "tinyusdz-0.8.0rc0.tar", last modified: Mon Aug  8 19:48:52 2022, max compression
+gzip compressed data, was "tinyusdz-0.8.0rc1.tar", last modified: Wed Apr 19 11:05:02 2023, max compression
```

## Comparing `tinyusdz-0.8.0rc0.tar` & `tinyusdz-0.8.0rc1.tar`

### file list

```diff
@@ -1,654 +1,690 @@
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.636596 tinyusdz-0.8.0rc0/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    23320 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/CMakeLists.txt
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1052 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/CMakeSettings.json
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1077 2022-03-10 06:11:58.000000 tinyusdz-0.8.0rc0/LICENSE
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    24197 2022-08-08 19:30:07.000000 tinyusdz-0.8.0rc0/MANIFEST.in
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)      556 2022-08-08 19:48:52.636596 tinyusdz-0.8.0rc0/PKG-INFO
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    11430 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/README.md
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.568594 tinyusdz-0.8.0rc0/cmake/
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)      748 2020-07-02 09:46:50.000000 tinyusdz-0.8.0rc0/cmake/ClangClCMakeCompileRules.cmake
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      470 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/cmake/aarch64-linux-gnu.toolchain
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)    13000 2020-07-02 09:46:50.000000 tinyusdz-0.8.0rc0/cmake/clang-cl-msvc-windows.cmake
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)    12972 2020-07-17 04:43:38.000000 tinyusdz-0.8.0rc0/cmake/clang-cl-msvc-wsl.cmake
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)     3353 2020-05-13 05:59:50.000000 tinyusdz-0.8.0rc0/cmake/ios.toolchain.cmake
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)      881 2020-05-10 06:28:26.000000 tinyusdz-0.8.0rc0/cmake/llvm-mingw-cross.cmake
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)      761 2020-05-10 07:38:35.000000 tinyusdz-0.8.0rc0/cmake/llvm-mingw-win64.cmake
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)      681 2020-05-10 07:41:22.000000 tinyusdz-0.8.0rc0/cmake/mingw64-cross.cmake
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.568594 tinyusdz-0.8.0rc0/cmake/sanitizers/
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)     2144 2020-04-04 07:59:41.000000 tinyusdz-0.8.0rc0/cmake/sanitizers/FindASan.cmake
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)     2292 2020-04-04 07:59:41.000000 tinyusdz-0.8.0rc0/cmake/sanitizers/FindMSan.cmake
--rwxr-xr-x   0 syoyo     (1000) syoyo     (1000)     3737 2020-04-04 07:59:41.000000 tinyusdz-0.8.0rc0/cmake/sanitizers/FindSanitizers.cmake
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)     2555 2020-04-04 07:59:41.000000 tinyusdz-0.8.0rc0/cmake/sanitizers/FindTSan.cmake
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)     1696 2020-04-04 07:59:41.000000 tinyusdz-0.8.0rc0/cmake/sanitizers/FindUBSan.cmake
--rwxr-xr-x   0 syoyo     (1000) syoyo     (1000)     2011 2020-04-04 07:59:41.000000 tinyusdz-0.8.0rc0/cmake/sanitizers/asan-wrapper
--rwxr-xr-x   0 syoyo     (1000) syoyo     (1000)     7684 2020-04-04 07:59:41.000000 tinyusdz-0.8.0rc0/cmake/sanitizers/sanitize-helpers.cmake
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.568594 tinyusdz-0.8.0rc0/doc/
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)      160 2021-01-11 10:40:34.000000 tinyusdz-0.8.0rc0/doc/README.md
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)      302 2021-05-06 07:13:05.000000 tinyusdz-0.8.0rc0/doc/TODO.md
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      357 2021-12-05 11:20:38.000000 tinyusdz-0.8.0rc0/doc/composition.md
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.568594 tinyusdz-0.8.0rc0/doc/docs/
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)     5976 2021-01-11 10:56:00.000000 tinyusdz-0.8.0rc0/doc/docs/index.md
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)        0 2021-01-11 10:41:30.000000 tinyusdz-0.8.0rc0/doc/macros.tex
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)      216 2021-01-11 10:41:58.000000 tinyusdz-0.8.0rc0/doc/mkdocs.yml
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)     1293 2020-04-09 06:30:05.000000 tinyusdz-0.8.0rc0/doc/preview_surface.md
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)     1937 2020-09-05 11:10:10.000000 tinyusdz-0.8.0rc0/doc/prim_format.md
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      734 2022-07-23 09:21:55.000000 tinyusdz-0.8.0rc0/doc/usdObj.md
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      279 2021-12-05 11:20:38.000000 tinyusdz-0.8.0rc0/doc/usd_sourcecode_tour.md
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1363 2022-07-23 09:21:55.000000 tinyusdz-0.8.0rc0/doc/usdc_format.md
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      675 2021-12-05 11:20:38.000000 tinyusdz-0.8.0rc0/doc/usdz_note.md
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      338 2022-08-08 12:03:34.000000 tinyusdz-0.8.0rc0/pyproject.toml
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.568594 tinyusdz-0.8.0rc0/python/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      380 2022-08-08 13:16:26.000000 tinyusdz-0.8.0rc0/python/README.md
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      247 2021-12-05 11:20:38.000000 tinyusdz-0.8.0rc0/python/test.py
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.572594 tinyusdz-0.8.0rc0/python/tinyusdz/
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.572594 tinyusdz-0.8.0rc0/python/tinyusdz/Usd/
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.572594 tinyusdz-0.8.0rc0/python/tinyusdz/Usd/Stage/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      183 2021-12-05 11:20:38.000000 tinyusdz-0.8.0rc0/python/tinyusdz/Usd/Stage/__init__.py
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)       20 2021-12-05 11:20:38.000000 tinyusdz-0.8.0rc0/python/tinyusdz/Usd/__init__.py
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.572594 tinyusdz-0.8.0rc0/python/tinyusdz/UsdGeom/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)       24 2021-12-05 11:20:38.000000 tinyusdz-0.8.0rc0/python/tinyusdz/UsdGeom/Tokens.py
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      168 2021-12-05 11:20:38.000000 tinyusdz-0.8.0rc0/python/tinyusdz/UsdGeom/__init__.py
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)       79 2021-09-11 12:14:02.000000 tinyusdz-0.8.0rc0/python/tinyusdz/UsdGeom/tmp.py
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      247 2021-09-11 12:25:48.000000 tinyusdz-0.8.0rc0/python/tinyusdz/test.py
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3088 2021-09-11 12:04:42.000000 tinyusdz-0.8.0rc0/python/tinyusdz/tmp.py
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.572594 tinyusdz-0.8.0rc0/python/tinyusdz.egg-info/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      556 2022-08-08 19:48:52.000000 tinyusdz-0.8.0rc0/python/tinyusdz.egg-info/PKG-INFO
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    22301 2022-08-08 19:48:52.000000 tinyusdz-0.8.0rc0/python/tinyusdz.egg-info/SOURCES.txt
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)        1 2022-08-08 19:48:52.000000 tinyusdz-0.8.0rc0/python/tinyusdz.egg-info/dependency_links.txt
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)        9 2022-08-08 19:48:52.000000 tinyusdz-0.8.0rc0/python/tinyusdz.egg-info/top_level.txt
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)       38 2022-08-08 19:48:52.636596 tinyusdz-0.8.0rc0/setup.cfg
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      544 2022-08-08 13:13:00.000000 tinyusdz-0.8.0rc0/setup.py
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.580594 tinyusdz-0.8.0rc0/src/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)   121255 2022-08-08 11:07:43.000000 tinyusdz-0.8.0rc0/src/ascii-parser.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    15429 2022-07-24 13:00:54.000000 tinyusdz-0.8.0rc0/src/ascii-parser.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      191 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/c-tinyusd.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      434 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/c-tinyusd.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      480 2022-08-07 13:23:02.000000 tinyusdz-0.8.0rc0/src/common-macros.inc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7914 2022-08-07 13:24:58.000000 tinyusdz-0.8.0rc0/src/crate-format.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    14147 2022-08-06 12:55:19.000000 tinyusdz-0.8.0rc0/src/crate-format.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      286 2022-07-08 09:56:27.000000 tinyusdz-0.8.0rc0/src/crate-pprint.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      299 2022-07-08 09:56:27.000000 tinyusdz-0.8.0rc0/src/crate-pprint.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)   115222 2022-08-07 13:25:40.000000 tinyusdz-0.8.0rc0/src/crate-reader.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7288 2022-07-19 09:29:27.000000 tinyusdz-0.8.0rc0/src/crate-reader.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     6670 2022-07-31 08:17:00.000000 tinyusdz-0.8.0rc0/src/crate-writer.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      206 2022-07-20 11:26:57.000000 tinyusdz-0.8.0rc0/src/crate-writer.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2041 2022-08-07 12:06:12.000000 tinyusdz-0.8.0rc0/src/define-type-trait.inc
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.584594 tinyusdz-0.8.0rc0/src/external/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1162 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/LICENSE.miniz
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1069 2022-04-16 08:52:08.000000 tinyusdz-0.8.0rc0/src/external/LICENSE.ogt_vox.md
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    13317 2022-01-23 11:42:46.000000 tinyusdz-0.8.0rc0/src/external/README.fpng.md
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.584594 tinyusdz-0.8.0rc0/src/external/better-enums/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1296 2022-07-22 10:58:54.000000 tinyusdz-0.8.0rc0/src/external/better-enums/LICENSE.md
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4022 2022-07-22 10:58:57.000000 tinyusdz-0.8.0rc0/src/external/better-enums/README.md
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    67677 2022-07-22 12:05:13.000000 tinyusdz-0.8.0rc0/src/external/better-enums/enum.h
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)   173606 2020-04-09 06:05:42.000000 tinyusdz-0.8.0rc0/src/external/dr_mp3.h
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)   225960 2020-04-09 06:05:39.000000 tinyusdz-0.8.0rc0/src/external/dr_wav.h
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.584594 tinyusdz-0.8.0rc0/src/external/fast_float/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    10767 2022-07-10 08:11:38.000000 tinyusdz-0.8.0rc0/src/external/fast_float/LICENSE-APACHE
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1079 2022-07-10 08:11:38.000000 tinyusdz-0.8.0rc0/src/external/fast_float/LICENSE-MIT
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     9769 2022-07-10 08:11:41.000000 tinyusdz-0.8.0rc0/src/external/fast_float/README.md
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.564594 tinyusdz-0.8.0rc0/src/external/fast_float/include/
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.584594 tinyusdz-0.8.0rc0/src/external/fast_float/include/fast_float/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7964 2022-07-10 08:11:33.000000 tinyusdz-0.8.0rc0/src/external/fast_float/include/fast_float/ascii_number.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    16853 2022-07-10 08:11:33.000000 tinyusdz-0.8.0rc0/src/external/fast_float/include/fast_float/bigint.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     8395 2022-07-10 08:11:33.000000 tinyusdz-0.8.0rc0/src/external/fast_float/include/fast_float/decimal_to_binary.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    13580 2022-07-10 08:11:33.000000 tinyusdz-0.8.0rc0/src/external/fast_float/include/fast_float/digit_comparison.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2503 2022-07-10 08:11:33.000000 tinyusdz-0.8.0rc0/src/external/fast_float/include/fast_float/fast_float.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    31804 2022-07-10 08:11:33.000000 tinyusdz-0.8.0rc0/src/external/fast_float/include/fast_float/fast_table.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    12370 2022-07-10 08:11:33.000000 tinyusdz-0.8.0rc0/src/external/fast_float/include/fast_float/float_common.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4185 2022-07-10 08:11:33.000000 tinyusdz-0.8.0rc0/src/external/fast_float/include/fast_float/parse_number.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    13686 2022-07-10 08:11:33.000000 tinyusdz-0.8.0rc0/src/external/fast_float/include/fast_float/simple_decimal_conversion.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)   115167 2022-03-05 07:37:03.000000 tinyusdz-0.8.0rc0/src/external/fpng.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     6285 2022-01-23 11:42:46.000000 tinyusdz-0.8.0rc0/src/external/fpng.h
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.584594 tinyusdz-0.8.0rc0/src/external/jsonhpp/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1076 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/LICENSE.MIT
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.588594 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2600 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/adl_serializer.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4687 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/byte_container_with_subtype.hpp
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.588594 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.588594 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/conversions/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    17378 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/conversions/from_json.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    37968 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/conversions/to_chars.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    14055 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/conversions/to_json.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    23999 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/exceptions.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3645 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/hash.hpp
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.588594 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/input/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    79656 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/input/binary_reader.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    17011 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/input/input_adapters.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    20619 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/input/json_sax.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    54046 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/input/lexer.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    18072 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/input/parser.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      605 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/input/position_t.hpp
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.588594 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/iterators/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      720 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/iterators/internal_iterator.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    19611 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/iterators/iter_impl.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5541 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/iterators/iteration_proxy.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1404 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/iterators/iterator_traits.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3549 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/iterators/json_reverse_iterator.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2958 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/iterators/primitive_iterator.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    31562 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/json_pointer.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1460 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/json_ref.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    35473 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/macro_scope.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      504 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/macro_unscope.hpp
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.592594 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/meta/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4523 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/meta/cpp_future.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1800 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/meta/detected.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      174 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/meta/identity_tag.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     6609 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/meta/is_sax.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    16764 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/meta/type_traits.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      244 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/meta/void_t.hpp
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.592594 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/output/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    59333 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/output/binary_writer.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3598 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/output/output_adapters.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    38644 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/output/serializer.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1698 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/string_escape.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3098 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/detail/value_t.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)   328121 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/json.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2144 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/json_fwd.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5283 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/ordered_map.hpp
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.564594 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/thirdparty/
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.592594 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/thirdparty/hedley/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    86041 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/thirdparty/hedley/hedley.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5205 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/jsonhpp/nlohmann/thirdparty/hedley/hedley_undef.hpp
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.592594 tinyusdz-0.8.0rc0/src/external/jsteemann/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    11344 2022-07-19 09:29:27.000000 tinyusdz-0.8.0rc0/src/external/jsteemann/LICENSE
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     8518 2022-07-19 09:29:27.000000 tinyusdz-0.8.0rc0/src/external/jsteemann/README.md
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7496 2022-07-20 11:00:46.000000 tinyusdz-0.8.0rc0/src/external/jsteemann/atoi.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)       55 2022-07-19 09:29:27.000000 tinyusdz-0.8.0rc0/src/external/jsteemann/modification.md
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.564594 tinyusdz-0.8.0rc0/src/external/mapbox/
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.592594 tinyusdz-0.8.0rc0/src/external/mapbox/variant/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1460 2022-07-20 07:13:21.000000 tinyusdz-0.8.0rc0/src/external/mapbox/variant/LICENSE
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1338 2022-07-20 07:13:21.000000 tinyusdz-0.8.0rc0/src/external/mapbox/variant/LICENSE_1_0.txt
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7203 2022-07-20 07:13:21.000000 tinyusdz-0.8.0rc0/src/external/mapbox/variant/README.md
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.564594 tinyusdz-0.8.0rc0/src/external/mapbox/variant/include/
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.592594 tinyusdz-0.8.0rc0/src/external/mapbox/variant/include/mapbox/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1575 2022-07-20 07:13:21.000000 tinyusdz-0.8.0rc0/src/external/mapbox/variant/include/mapbox/optional.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2632 2022-07-20 07:13:21.000000 tinyusdz-0.8.0rc0/src/external/mapbox/variant/include/mapbox/recursive_wrapper.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    33304 2022-07-20 07:13:21.000000 tinyusdz-0.8.0rc0/src/external/mapbox/variant/include/mapbox/variant.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1830 2022-07-20 07:13:21.000000 tinyusdz-0.8.0rc0/src/external/mapbox/variant/include/mapbox/variant_cast.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      912 2022-07-20 07:13:21.000000 tinyusdz-0.8.0rc0/src/external/mapbox/variant/include/mapbox/variant_io.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      946 2022-07-20 07:13:21.000000 tinyusdz-0.8.0rc0/src/external/mapbox/variant/include/mapbox/variant_visitor.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)   319866 2022-07-04 11:12:56.000000 tinyusdz-0.8.0rc0/src/external/miniz.c
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    69441 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/miniz.h
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.592594 tinyusdz-0.8.0rc0/src/external/nanobind/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2961 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/CMakeLists.txt
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1521 2022-04-16 08:52:08.000000 tinyusdz-0.8.0rc0/src/external/nanobind/LICENSE
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    24245 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/README.md
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.592594 tinyusdz-0.8.0rc0/src/external/nanobind/cmake/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     8007 2022-08-01 07:52:46.000000 tinyusdz-0.8.0rc0/src/external/nanobind/cmake/nanobind-config.cmake
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.564594 tinyusdz-0.8.0rc0/src/external/nanobind/ext/
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.592594 tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3176 2022-07-31 14:01:40.000000 tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/CMakeLists.txt
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1102 2022-07-31 14:01:40.000000 tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/LICENSE
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    21353 2022-07-31 14:01:40.000000 tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/README.md
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.592594 tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/cmake/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      407 2022-07-31 14:01:40.000000 tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/cmake/tsl-robin-mapConfig.cmake.in
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.564594 tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/include/
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.592594 tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/include/tsl/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    11773 2022-07-31 14:01:40.000000 tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/include/tsl/robin_growth_policy.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    53806 2022-07-31 14:01:40.000000 tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/include/tsl/robin_hash.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    28412 2022-07-31 14:01:40.000000 tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/include/tsl/robin_map.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    23593 2022-07-31 14:01:40.000000 tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/include/tsl/robin_set.h
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.596595 tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/tests/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1111 2022-07-31 14:01:40.000000 tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/tests/CMakeLists.txt
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3904 2022-07-31 14:01:40.000000 tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/tests/custom_allocator_tests.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1276 2022-07-31 14:01:40.000000 tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/tests/main.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3380 2022-07-31 14:01:40.000000 tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/tests/policy_tests.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    45542 2022-07-31 14:01:40.000000 tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/tests/robin_map_tests.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5791 2022-07-31 14:01:40.000000 tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/tests/robin_set_tests.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    12189 2022-07-31 14:01:40.000000 tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/tests/utils.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4623 2022-07-31 14:01:40.000000 tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/tsl-robin-map.natvis
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.564594 tinyusdz-0.8.0rc0/src/external/nanobind/include/
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.596595 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1630 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nanobind.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5218 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_accessor.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7228 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_attr.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5348 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_call.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    12016 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_cast.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    17928 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_class.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4544 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_defs.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4152 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_descr.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3259 2022-07-31 14:01:18.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_enums.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2245 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_error.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     9619 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_func.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    15009 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_lib.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1521 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_misc.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1400 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_python.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5112 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_traits.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2491 2022-07-31 14:01:18.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_tuple.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    18870 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_types.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7562 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/operators.h
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.596595 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/stl/
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.596595 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/stl/detail/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1858 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/stl/detail/nb_list.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1592 2022-07-31 14:01:18.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/stl/function.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      299 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/stl/list.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3121 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/stl/pair.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3782 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/stl/shared_ptr.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      792 2022-07-31 14:01:18.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/stl/string.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3222 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/stl/tuple.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3000 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/stl/unique_ptr.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      305 2022-07-31 14:01:18.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/stl/vector.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    11142 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/tensor.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2695 2022-07-31 14:01:18.000000 tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/trampoline.h
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.600595 tinyusdz-0.8.0rc0/src/external/nanobind/src/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4165 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/src/buffer.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    23020 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/src/common.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3379 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/src/error.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2571 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/src/implicit.cpp
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.600595 tinyusdz-0.8.0rc0/src/external/nanobind/src/nanobind/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      536 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/src/nanobind/__init__.py
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    10318 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/src/nb_enum.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    36266 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/src/nb_func.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    14587 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/src/nb_internals.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     8156 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/src/nb_internals.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    37029 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/src/nb_type.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    18463 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/src/tensor.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3724 2022-08-01 07:50:10.000000 tinyusdz-0.8.0rc0/src/external/nanobind/src/trampoline.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)   129588 2022-04-16 08:52:08.000000 tinyusdz-0.8.0rc0/src/external/ogt_vox.h
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.600595 tinyusdz-0.8.0rc0/src/external/pybind11/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    10999 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/CMakeLists.txt
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1684 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/LICENSE
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7686 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/README.rst
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.564594 tinyusdz-0.8.0rc0/src/external/pybind11/include/
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.600595 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    23979 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/attr.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7069 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/buffer_info.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    65705 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/cast.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     8458 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/chrono.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      120 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/common.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2096 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/complex.h
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.604595 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/detail/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    28337 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/detail/class.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    50335 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/detail/common.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5491 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/detail/descr.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    17981 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/detail/init.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    24008 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/detail/internals.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    42266 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/detail/type_caster_base.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1625 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/detail/typeid.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    32147 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/eigen.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    11735 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/embed.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4731 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/eval.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4695 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/functional.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     6923 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/gil.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     8862 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/iostream.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    79526 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/numpy.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     9051 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/operators.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2181 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/options.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)   126301 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/pybind11.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    92122 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/pytypes.h
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.604595 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/stl/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4185 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/stl/filesystem.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    14556 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/stl.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    27013 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/stl_bind.h
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.604595 tinyusdz-0.8.0rc0/src/external/pybind11/tools/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2350 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/tools/FindCatch.cmake
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3105 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/tools/FindEigen3.cmake
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    10890 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/tools/FindPythonLibsNew.cmake
--rwxrwxr-x   0 syoyo     (1000) syoyo     (1000)     1423 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/tools/check-style.sh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      952 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/tools/cmake_uninstall.cmake.in
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1031 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/tools/libsize.py
--rwxrwxr-x   0 syoyo     (1000) syoyo     (1000)     1282 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/tools/make_changelog.py
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    13487 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/tools/pybind11Common.cmake
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     6930 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/tools/pybind11Config.cmake.in
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     8955 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/tools/pybind11NewTools.cmake
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7862 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/tools/pybind11Tools.cmake
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)       94 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/tools/pyproject.toml
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1851 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/tools/setup_global.py.in
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1057 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/external/pybind11/tools/setup_main.py.in
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.604595 tinyusdz-0.8.0rc0/src/external/ryu/
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)     1338 2020-10-15 06:40:23.000000 tinyusdz-0.8.0rc0/src/external/ryu/LICENSE-Boost
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)    14387 2020-10-15 06:40:11.000000 tinyusdz-0.8.0rc0/src/external/ryu/README.md
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.608595 tinyusdz-0.8.0rc0/src/external/ryu/ryu/
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)     3648 2020-10-15 06:41:00.000000 tinyusdz-0.8.0rc0/src/external/ryu/ryu/common.h
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)   329074 2020-10-15 06:41:00.000000 tinyusdz-0.8.0rc0/src/external/ryu/ryu/d2fixed_full_table.h
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)    17721 2020-10-15 06:39:32.000000 tinyusdz-0.8.0rc0/src/external/ryu/ryu/d2s.c
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)    34501 2020-10-15 06:41:00.000000 tinyusdz-0.8.0rc0/src/external/ryu/ryu/d2s_full_table.h
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)    12937 2020-10-15 06:41:00.000000 tinyusdz-0.8.0rc0/src/external/ryu/ryu/d2s_intrinsics.h
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)     7434 2020-10-15 06:41:00.000000 tinyusdz-0.8.0rc0/src/external/ryu/ryu/d2s_small_table.h
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)     1745 2020-10-15 06:41:00.000000 tinyusdz-0.8.0rc0/src/external/ryu/ryu/digit_table.h
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)    11279 2020-10-15 06:39:37.000000 tinyusdz-0.8.0rc0/src/external/ryu/ryu/f2s.c
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)     3241 2020-10-15 06:41:00.000000 tinyusdz-0.8.0rc0/src/external/ryu/ryu/f2s_full_table.h
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)     4294 2020-10-15 06:41:00.000000 tinyusdz-0.8.0rc0/src/external/ryu/ryu/f2s_intrinsics.h
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)    34192 2020-10-15 06:41:00.000000 tinyusdz-0.8.0rc0/src/external/ryu/ryu/generic_128.h
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)     1360 2020-10-15 06:41:00.000000 tinyusdz-0.8.0rc0/src/external/ryu/ryu/ryu.h
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)     2721 2020-10-15 06:41:00.000000 tinyusdz-0.8.0rc0/src/external/ryu/ryu/ryu_generic_128.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1497 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/ryu/ryu/ryu_parse.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     8752 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/ryu/ryu/s2d.c
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     8997 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/ryu/ryu/s2f.c
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.608595 tinyusdz-0.8.0rc0/src/external/simple_match/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1338 2022-08-08 09:47:40.000000 tinyusdz-0.8.0rc0/src/external/simple_match/LICENSE_1_0.txt
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    11293 2022-08-08 09:47:43.000000 tinyusdz-0.8.0rc0/src/external/simple_match/README.md
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.564594 tinyusdz-0.8.0rc0/src/external/simple_match/include/
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.608595 tinyusdz-0.8.0rc0/src/external/simple_match/include/simple_match/
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.608595 tinyusdz-0.8.0rc0/src/external/simple_match/include/simple_match/implementation/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     9039 2022-08-08 09:47:49.000000 tinyusdz-0.8.0rc0/src/external/simple_match/include/simple_match/implementation/some_none.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    10854 2022-08-08 09:50:06.000000 tinyusdz-0.8.0rc0/src/external/simple_match/include/simple_match/simple_match.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      900 2022-08-08 09:47:49.000000 tinyusdz-0.8.0rc0/src/external/simple_match/include/simple_match/utility.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    10982 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/staticstruct.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    54476 2022-07-19 09:29:27.000000 tinyusdz-0.8.0rc0/src/external/staticstruct.hh
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)   267319 2020-04-09 06:50:42.000000 tinyusdz-0.8.0rc0/src/external/stb_image.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    71221 2022-08-07 13:28:24.000000 tinyusdz-0.8.0rc0/src/external/stb_image_write.h
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.608595 tinyusdz-0.8.0rc0/src/external/string_id/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      900 2022-07-03 08:00:56.000000 tinyusdz-0.8.0rc0/src/external/string_id/LICENSE
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4654 2022-07-03 08:00:56.000000 tinyusdz-0.8.0rc0/src/external/string_id/README.md
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)       29 2022-07-03 08:00:56.000000 tinyusdz-0.8.0rc0/src/external/string_id/README.mod.txt
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3201 2022-07-03 08:00:56.000000 tinyusdz-0.8.0rc0/src/external/string_id/basic_database.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      449 2022-07-03 08:00:56.000000 tinyusdz-0.8.0rc0/src/external/string_id/config.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2267 2022-07-03 08:00:56.000000 tinyusdz-0.8.0rc0/src/external/string_id/config.hpp.in
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2201 2022-08-04 09:12:38.000000 tinyusdz-0.8.0rc0/src/external/string_id/config_impl.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7752 2022-07-03 08:00:56.000000 tinyusdz-0.8.0rc0/src/external/string_id/database.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4147 2022-08-04 09:13:07.000000 tinyusdz-0.8.0rc0/src/external/string_id/database.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2747 2022-07-03 08:00:56.000000 tinyusdz-0.8.0rc0/src/external/string_id/error.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4948 2022-07-03 08:00:56.000000 tinyusdz-0.8.0rc0/src/external/string_id/error.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2134 2022-07-03 08:00:56.000000 tinyusdz-0.8.0rc0/src/external/string_id/generator.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5680 2022-07-03 08:00:56.000000 tinyusdz-0.8.0rc0/src/external/string_id/generator.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1019 2022-07-03 08:00:56.000000 tinyusdz-0.8.0rc0/src/external/string_id/hash.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1595 2022-07-03 08:00:56.000000 tinyusdz-0.8.0rc0/src/external/string_id/string_id.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5705 2022-07-03 08:00:56.000000 tinyusdz-0.8.0rc0/src/external/string_id/string_id.hpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)   166456 2022-02-26 08:10:34.000000 tinyusdz-0.8.0rc0/src/external/tiny_dng_loader.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    56982 2022-02-26 08:10:43.000000 tinyusdz-0.8.0rc0/src/external/tiny_dng_writer.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      127 2022-04-16 08:52:08.000000 tinyusdz-0.8.0rc0/src/external/tiny_gltf.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)   236767 2022-04-16 08:52:08.000000 tinyusdz-0.8.0rc0/src/external/tiny_gltf.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)       66 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/tiny_obj_loader.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)   101668 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/tiny_obj_loader.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      154 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/external/tinyexr.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)   272714 2022-04-18 11:21:39.000000 tinyusdz-0.8.0rc0/src/external/tinyexr.h
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.608595 tinyusdz-0.8.0rc0/src/external/tinyxml2/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      808 2022-04-23 10:47:49.000000 tinyusdz-0.8.0rc0/src/external/tinyxml2/LICENSE.txt
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    11410 2022-04-23 10:47:54.000000 tinyusdz-0.8.0rc0/src/external/tinyxml2/readme.md
--rwxrwxr-x   0 syoyo     (1000) syoyo     (1000)    77996 2022-04-23 10:47:47.000000 tinyusdz-0.8.0rc0/src/external/tinyxml2/tinyxml2.cpp
--rwxrwxr-x   0 syoyo     (1000) syoyo     (1000)    73783 2022-04-23 10:47:45.000000 tinyusdz-0.8.0rc0/src/external/tinyxml2/tinyxml2.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3243 2022-08-07 13:05:17.000000 tinyusdz-0.8.0rc0/src/image-loader.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      965 2022-08-07 11:30:26.000000 tinyusdz-0.8.0rc0/src/image-loader.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1991 2022-02-26 08:57:55.000000 tinyusdz-0.8.0rc0/src/image-types.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1221 2022-08-07 13:26:54.000000 tinyusdz-0.8.0rc0/src/image-writer.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1159 2022-08-07 11:35:37.000000 tinyusdz-0.8.0rc0/src/image-writer.hh
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)    15751 2019-12-26 09:53:37.000000 tinyusdz-0.8.0rc0/src/integerCoding.cpp
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)     5823 2019-12-26 09:52:36.000000 tinyusdz-0.8.0rc0/src/integerCoding.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     8112 2022-07-06 11:58:32.000000 tinyusdz-0.8.0rc0/src/io-util.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1148 2022-07-06 11:58:25.000000 tinyusdz-0.8.0rc0/src/io-util.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5883 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/lz4-compression.cc
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)     1449 2019-12-26 09:08:51.000000 tinyusdz-0.8.0rc0/src/lz4-compression.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     6911 2022-07-31 08:17:00.000000 tinyusdz-0.8.0rc0/src/math-util.inc
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.608595 tinyusdz-0.8.0rc0/src/nonstd/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    69798 2022-07-19 09:29:27.000000 tinyusdz-0.8.0rc0/src/nonstd/expected.hpp
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)    51603 2020-11-19 11:05:28.000000 tinyusdz-0.8.0rc0/src/nonstd/optional.hpp
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.612595 tinyusdz-0.8.0rc0/src/osd/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    26848 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/CMakeLists.txt
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    10038 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/LICENSE.txt
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      102 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/README.md
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.612595 tinyusdz-0.8.0rc0/src/osd/opensubdiv/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    11764 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/CMakeLists.txt
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.616595 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2953 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/CMakeLists.txt
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3901 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/bilinearPatchBuilder.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2685 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/bilinearPatchBuilder.h
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)    74986 2020-08-16 08:17:20.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/catmarkPatchBuilder.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2731 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/catmarkPatchBuilder.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2804 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/error.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3153 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/error.h
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)    70982 2020-08-16 08:17:20.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/loopPatchBuilder.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2653 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/loopPatchBuilder.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    51109 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchBasis.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4222 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchBasis.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    62921 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchBuilder.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    12981 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchBuilder.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3019 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchDescriptor.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5886 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchDescriptor.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     6586 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchMap.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     8150 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchMap.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    12368 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchParam.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    25747 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchTable.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    31014 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchTable.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    77920 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchTableFactory.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    10691 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchTableFactory.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    52215 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/primvarRefiner.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7065 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/ptexIndices.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3038 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/ptexIndices.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     6393 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/sparseMatrix.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    19388 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/stencilBuilder.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3739 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/stencilBuilder.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     8841 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/stencilTable.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    27801 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/stencilTable.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    26377 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/stencilTableFactory.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    15853 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/stencilTableFactory.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     6135 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/topologyDescriptor.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3985 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/topologyDescriptor.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    12461 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/topologyLevel.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    31960 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/topologyRefiner.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    11157 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/topologyRefiner.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    17656 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/topologyRefinerFactory.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    30830 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/topologyRefinerFactory.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2107 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/types.h
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.616595 tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1800 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/CMakeLists.txt
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5293 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/allocator.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    35809 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/bilinear.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    46301 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/catmark.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3870 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/cornerEdit.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4019 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/creaseEdit.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    33240 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/face.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4512 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/faceEdit.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5926 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/fvarData.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4721 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/fvarEdit.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    24345 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/halfedge.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5401 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/hierarchicalEdit.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2387 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/holeEdit.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    38089 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/loop.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    31625 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/mesh.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    11284 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/subdivision.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    50612 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/vertex.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     9457 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/vertexEdit.h
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.632596 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1603 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/Android.mk
--rwxrwxr-x   0 syoyo     (1000) syoyo     (1000)    10828 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/CMakeLists.txt
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3838 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/bufferDescriptor.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7173 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/clD3D11VertexBuffer.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4690 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/clD3D11VertexBuffer.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    23234 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/clEvaluator.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)   128029 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/clEvaluator.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4204 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/clGLVertexBuffer.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3928 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/clGLVertexBuffer.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     8377 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/clKernel.cl
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     6957 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/clPatchTable.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4021 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/clPatchTable.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3021 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/clVertexBuffer.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3456 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/clVertexBuffer.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4069 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuD3D11VertexBuffer.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3189 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuD3D11VertexBuffer.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    13998 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuEvaluator.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    55912 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuEvaluator.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3240 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuGLVertexBuffer.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3132 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuGLVertexBuffer.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     8318 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuKernel.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4885 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuKernel.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     6900 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuPatchTable.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4624 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuPatchTable.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2296 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuVertexBuffer.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2621 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuVertexBuffer.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4351 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cudaD3D11VertexBuffer.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3517 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cudaD3D11VertexBuffer.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    14078 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cudaEvaluator.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    57545 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cudaEvaluator.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5016 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cudaGLVertexBuffer.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3421 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cudaGLVertexBuffer.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    15404 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cudaKernel.cu
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     6562 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cudaPatchTable.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3842 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cudaPatchTable.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2692 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cudaVertexBuffer.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2718 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cudaVertexBuffer.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    13919 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/d3d11ComputeEvaluator.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     9666 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/d3d11ComputeEvaluator.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     6149 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/d3d11LegacyGregoryPatchTable.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3238 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/d3d11LegacyGregoryPatchTable.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1578 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/d3d11Mesh.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4891 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/d3d11PatchTable.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3039 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/d3d11PatchTable.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5132 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/d3d11VertexBuffer.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3269 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/d3d11VertexBuffer.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    21185 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glComputeEvaluator.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    97063 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glComputeEvaluator.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4373 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glLegacyGregoryPatchTable.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2607 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glLegacyGregoryPatchTable.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1563 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glMesh.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     6520 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glPatchTable.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4924 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glPatchTable.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3419 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glVertexBuffer.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2773 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glVertexBuffer.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    36815 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glXFBEvaluator.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)   101170 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glXFBEvaluator.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     9248 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslComputeKernel.glsl
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5735 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslPatchBSpline.glsl
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5177 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslPatchBoxSplineTriangle.glsl
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    39706 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslPatchCommon.glsl
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    28734 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslPatchCommonTess.glsl
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     6129 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslPatchGregory.glsl
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5669 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslPatchGregoryBasis.glsl
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5506 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslPatchGregoryTriangle.glsl
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    19694 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslPatchLegacy.glsl
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7557 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslPatchShaderSource.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1970 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslPatchShaderSource.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     8278 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslXFBKernel.glsl
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4131 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/hlslComputeKernel.hlsl
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5220 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/hlslPatchBSpline.hlsl
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5053 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/hlslPatchBoxSplineTriangle.hlsl
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    40195 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/hlslPatchCommon.hlsl
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    29589 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/hlslPatchCommonTess.hlsl
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     6190 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/hlslPatchGregory.hlsl
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5732 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/hlslPatchGregoryBasis.hlsl
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5499 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/hlslPatchGregoryTriangle.hlsl
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    13720 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/hlslPatchLegacy.hlsl
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5408 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/hlslPatchShaderSource.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1936 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/hlslPatchShaderSource.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    26278 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mesh.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1647 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlCommon.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)   101764 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlComputeEvaluator.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    22374 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlComputeEvaluator.mm
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    11416 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlComputeKernel.metal
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2837 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlLegacyGregoryPatchTable.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3490 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlLegacyGregoryPatchTable.mm
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1566 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlMesh.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)       27 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlMesh.mm
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7068 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchBSpline.metal
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7164 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchBoxSplineTriangle.metal
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    47039 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchCommon.metal
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    36222 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchCommonTess.metal
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     8357 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchGregory.metal
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     8603 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchGregoryBasis.metal
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     8014 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchGregoryTriangle.metal
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    13828 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchLegacy.metal
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2533 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchShaderSource.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7785 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchShaderSource.mm
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3389 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchTable.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4942 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchTable.mm
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2317 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlVertexBuffer.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2933 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlVertexBuffer.mm
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1618 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/nonCopyable.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    12296 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/ompEvaluator.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    55848 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/ompEvaluator.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    10162 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/ompKernel.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3249 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/ompKernel.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1386 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/opencl.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1792 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/opengl.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    51300 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/patchBasisCommon.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7197 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/patchBasisCommonEval.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    14090 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/patchBasisCommonTypes.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7332 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/tbbEvaluator.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    56103 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/tbbEvaluator.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    22756 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/tbbKernel.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4585 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/tbbKernel.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4432 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/types.h
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.632596 tinyusdz-0.8.0rc0/src/osd/opensubdiv/sdc/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2159 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/sdc/CMakeLists.txt
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5045 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/sdc/bilinearScheme.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    17827 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/sdc/catmarkScheme.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7473 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/sdc/crease.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    10866 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/sdc/crease.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    20982 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/sdc/loopScheme.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5321 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/sdc/options.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    29037 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/sdc/scheme.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3153 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/sdc/typeTraits.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2476 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/sdc/types.h
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.564594 tinyusdz-0.8.0rc0/src/osd/opensubdiv/tools/
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.632596 tinyusdz-0.8.0rc0/src/osd/opensubdiv/tools/stringify/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1532 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/tools/stringify/CMakeLists.txt
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2435 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/tools/stringify/main.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1263 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/version.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1555 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/version.h
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.636596 tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2515 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/CMakeLists.txt
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4712 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/array.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5059 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/componentInterfaces.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    43985 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/fvarLevel.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    16650 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/fvarLevel.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    27935 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/fvarRefinement.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4243 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/fvarRefinement.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    79674 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/level.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    35107 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/level.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    42569 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/quadRefinement.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3335 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/quadRefinement.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    48194 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/refinement.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    18593 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/refinement.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3168 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/sparseSelector.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4030 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/sparseSelector.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     6772 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/stackBuffer.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    37702 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/triRefinement.cpp
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3704 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/triRefinement.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3368 2020-04-25 14:48:29.000000 tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/types.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      422 2022-07-06 12:02:58.000000 tinyusdz-0.8.0rc0/src/path-util.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    20061 2022-07-26 13:31:26.000000 tinyusdz-0.8.0rc0/src/pprinter.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4291 2022-08-06 12:58:01.000000 tinyusdz-0.8.0rc0/src/pprinter.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     6803 2022-08-06 10:33:28.000000 tinyusdz-0.8.0rc0/src/prim-types.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    43178 2022-08-07 09:17:29.000000 tinyusdz-0.8.0rc0/src/prim-types.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      411 2022-07-31 08:17:00.000000 tinyusdz-0.8.0rc0/src/primvar.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3504 2022-08-05 16:54:34.000000 tinyusdz-0.8.0rc0/src/primvar.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      571 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/pxr-compat.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3335 2022-07-19 09:29:27.000000 tinyusdz-0.8.0rc0/src/pxr-compat.hh
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.636596 tinyusdz-0.8.0rc0/src/pxrLZ4/
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)     5031 2019-12-26 08:53:57.000000 tinyusdz-0.8.0rc0/src/pxrLZ4/README.md
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    58626 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/pxrLZ4/lz4.cpp
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)    24044 2021-08-23 11:13:09.000000 tinyusdz-0.8.0rc0/src/pxrLZ4/lz4.h
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1713 2022-08-08 19:13:52.000000 tinyusdz-0.8.0rc0/src/python-bindings.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2693 2022-07-26 11:34:04.000000 tinyusdz-0.8.0rc0/src/str-util.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7561 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/stream-reader.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7160 2022-06-10 13:05:37.000000 tinyusdz-0.8.0rc0/src/stream-writer.hh
--rw-r--r--   0 syoyo     (1000) syoyo     (1000)     9701 2020-08-17 07:25:31.000000 tinyusdz-0.8.0rc0/src/subdiv.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     3374 2022-02-26 11:39:32.000000 tinyusdz-0.8.0rc0/src/subdiv.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2176 2022-02-26 11:21:02.000000 tinyusdz-0.8.0rc0/src/texture-types.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    18909 2022-07-21 12:51:23.000000 tinyusdz-0.8.0rc0/src/tiny-any.inc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    10295 2022-07-31 08:17:00.000000 tinyusdz-0.8.0rc0/src/tiny-variant.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    16382 2022-08-07 12:54:22.000000 tinyusdz-0.8.0rc0/src/tinyusdz.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    17312 2022-08-07 12:53:32.000000 tinyusdz-0.8.0rc0/src/tinyusdz.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2518 2022-07-21 11:27:10.000000 tinyusdz-0.8.0rc0/src/token-type.hh
-drwxr-xr-x   0 syoyo     (1000) syoyo     (1000)        0 2022-08-08 19:48:52.636596 tinyusdz-0.8.0rc0/src/tydra/
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      787 2022-07-31 08:18:12.000000 tinyusdz-0.8.0rc0/src/tydra/README.md
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1445 2022-08-08 11:06:34.000000 tinyusdz-0.8.0rc0/src/tydra/render-data.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4468 2022-08-08 10:10:35.000000 tinyusdz-0.8.0rc0/src/tydra/render-data.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)        0 2022-07-31 08:17:00.000000 tinyusdz-0.8.0rc0/src/tydra/texture-loader.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2651 2022-07-14 07:10:51.000000 tinyusdz-0.8.0rc0/src/usd-to-json.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      359 2022-02-26 09:06:52.000000 tinyusdz-0.8.0rc0/src/usd-to-json.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     7771 2022-08-07 13:25:10.000000 tinyusdz-0.8.0rc0/src/usdGeom.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    14842 2022-08-06 14:01:10.000000 tinyusdz-0.8.0rc0/src/usdGeom.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      175 2022-08-06 12:57:38.000000 tinyusdz-0.8.0rc0/src/usdLux.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     2997 2022-08-06 12:56:49.000000 tinyusdz-0.8.0rc0/src/usdLux.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      361 2022-07-14 07:10:51.000000 tinyusdz-0.8.0rc0/src/usdMtlx.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      576 2022-05-18 12:19:33.000000 tinyusdz-0.8.0rc0/src/usdMtlx.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5982 2022-07-14 07:10:51.000000 tinyusdz-0.8.0rc0/src/usdObj.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      542 2021-12-05 11:20:39.000000 tinyusdz-0.8.0rc0/src/usdObj.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      333 2022-08-07 09:17:29.000000 tinyusdz-0.8.0rc0/src/usdShade.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1332 2022-08-07 09:17:29.000000 tinyusdz-0.8.0rc0/src/usdShade.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      172 2022-04-16 08:52:08.000000 tinyusdz-0.8.0rc0/src/usdVox.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      570 2022-04-16 08:52:08.000000 tinyusdz-0.8.0rc0/src/usdVox.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    71923 2022-08-07 13:23:46.000000 tinyusdz-0.8.0rc0/src/usda-reader.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     1619 2022-08-07 12:51:33.000000 tinyusdz-0.8.0rc0/src/usda-reader.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     5021 2022-08-07 12:58:07.000000 tinyusdz-0.8.0rc0/src/usda-writer.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      452 2022-08-07 12:56:22.000000 tinyusdz-0.8.0rc0/src/usda-writer.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    60874 2022-08-07 12:55:56.000000 tinyusdz-0.8.0rc0/src/usdc-reader.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      646 2022-08-07 12:51:48.000000 tinyusdz-0.8.0rc0/src/usdc-reader.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    15716 2022-08-07 13:05:48.000000 tinyusdz-0.8.0rc0/src/usdc-writer.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)      913 2022-08-07 12:58:36.000000 tinyusdz-0.8.0rc0/src/usdc-writer.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    10141 2022-07-21 13:16:54.000000 tinyusdz-0.8.0rc0/src/value-pprint.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     4255 2022-07-31 08:17:00.000000 tinyusdz-0.8.0rc0/src/value-pprint.hh
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)     8729 2022-07-31 08:17:00.000000 tinyusdz-0.8.0rc0/src/value-types.cc
--rw-rw-r--   0 syoyo     (1000) syoyo     (1000)    25615 2022-08-07 12:48:10.000000 tinyusdz-0.8.0rc0/src/value-types.hh
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.539455 tinyusdz-0.8.0rc1/
+-rw-r--r--   0 runner    (1001) docker     (123)    41037 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1052 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/CMakeSettings.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1077 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)    27297 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (123)     2236 2023-04-19 11:05:02.539455 tinyusdz-0.8.0rc1/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)    20003 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.467455 tinyusdz-0.8.0rc1/cmake/
+-rw-r--r--   0 runner    (1001) docker     (123)      748 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/cmake/ClangClCMakeCompileRules.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)      466 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/cmake/aarch64-linux-gnu.toolchain
+-rw-r--r--   0 runner    (1001) docker     (123)    13000 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/cmake/clang-cl-msvc-windows.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)    12972 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/cmake/clang-cl-msvc-wsl.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     3353 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/cmake/ios.toolchain.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)      881 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/cmake/llvm-mingw-cross.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)      761 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/cmake/llvm-mingw-win64.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)      681 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/cmake/mingw64-cross.cmake
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.467455 tinyusdz-0.8.0rc1/cmake/sanitizers/
+-rw-r--r--   0 runner    (1001) docker     (123)     2144 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/cmake/sanitizers/FindASan.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     2292 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/cmake/sanitizers/FindMSan.cmake
+-rwxr-xr-x   0 runner    (1001) docker     (123)     3737 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/cmake/sanitizers/FindSanitizers.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     2555 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/cmake/sanitizers/FindTSan.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     1696 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/cmake/sanitizers/FindUBSan.cmake
+-rwxr-xr-x   0 runner    (1001) docker     (123)     2011 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/cmake/sanitizers/asan-wrapper
+-rwxr-xr-x   0 runner    (1001) docker     (123)     7684 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/cmake/sanitizers/sanitize-helpers.cmake
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.467455 tinyusdz-0.8.0rc1/doc/
+-rw-r--r--   0 runner    (1001) docker     (123)      160 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/doc/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)      302 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/doc/TODO.md
+-rw-r--r--   0 runner    (1001) docker     (123)     1071 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/doc/composition.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.471455 tinyusdz-0.8.0rc1/doc/docs/
+-rw-r--r--   0 runner    (1001) docker     (123)     5976 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/doc/docs/index.md
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/doc/macros.tex
+-rw-r--r--   0 runner    (1001) docker     (123)      216 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/doc/mkdocs.yml
+-rw-r--r--   0 runner    (1001) docker     (123)     1409 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/doc/preview_surface.md
+-rw-r--r--   0 runner    (1001) docker     (123)     1937 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/doc/prim_format.md
+-rw-r--r--   0 runner    (1001) docker     (123)      734 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/doc/usdObj.md
+-rw-r--r--   0 runner    (1001) docker     (123)      279 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/doc/usd_sourcecode_tour.md
+-rw-r--r--   0 runner    (1001) docker     (123)     1363 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/doc/usdc_format.md
+-rw-r--r--   0 runner    (1001) docker     (123)      675 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/doc/usdz_note.md
+-rw-r--r--   0 runner    (1001) docker     (123)      369 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/pyproject.toml
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.471455 tinyusdz-0.8.0rc1/python/
+-rw-r--r--   0 runner    (1001) docker     (123)     2020 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/python/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)      291 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/python/ctusd_test.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.459455 tinyusdz-0.8.0rc1/python/pxr_compat/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.471455 tinyusdz-0.8.0rc1/python/pxr_compat/Usd/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.471455 tinyusdz-0.8.0rc1/python/pxr_compat/Usd/Stage/
+-rw-r--r--   0 runner    (1001) docker     (123)      183 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/python/pxr_compat/Usd/Stage/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)       20 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/python/pxr_compat/Usd/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.471455 tinyusdz-0.8.0rc1/python/pxr_compat/UsdGeom/
+-rw-r--r--   0 runner    (1001) docker     (123)       24 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/python/pxr_compat/UsdGeom/Tokens.py
+-rw-r--r--   0 runner    (1001) docker     (123)      168 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/python/pxr_compat/UsdGeom/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      247 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/python/test.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.471455 tinyusdz-0.8.0rc1/python/tinyusdz/
+-rw-r--r--   0 runner    (1001) docker     (123)     6350 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/python/tinyusdz/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      158 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/python/tinyusdz/version.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.471455 tinyusdz-0.8.0rc1/python/tinyusdz.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     2236 2023-04-19 11:05:02.000000 tinyusdz-0.8.0rc1/python/tinyusdz.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)    22018 2023-04-19 11:05:02.000000 tinyusdz-0.8.0rc1/python/tinyusdz.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-19 11:05:02.000000 tinyusdz-0.8.0rc1/python/tinyusdz.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        9 2023-04-19 11:05:02.000000 tinyusdz-0.8.0rc1/python/tinyusdz.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      604 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/python/tutorial.py
+-rw-r--r--   0 runner    (1001) docker     (123)      353 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/python/tutorial_001.py
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-04-19 11:05:02.539455 tinyusdz-0.8.0rc1/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)      635 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.483455 tinyusdz-0.8.0rc1/src/
+-rw-r--r--   0 runner    (1001) docker     (123)    66822 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/ascii-parser-basetype.cc
+-rw-r--r--   0 runner    (1001) docker     (123)    10816 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/ascii-parser-timesamples-array.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     6195 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/ascii-parser-timesamples.cc
+-rw-r--r--   0 runner    (1001) docker     (123)   139326 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/ascii-parser.cc
+-rw-r--r--   0 runner    (1001) docker     (123)    27392 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/ascii-parser.hh
+-rw-r--r--   0 runner    (1001) docker     (123)      731 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/asset-resolution.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     2528 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/asset-resolution.hh
+-rw-r--r--   0 runner    (1001) docker     (123)      698 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/audio-loader.cc
+-rw-r--r--   0 runner    (1001) docker     (123)      900 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/audio-loader.hh
+-rw-r--r--   0 runner    (1001) docker     (123)    46186 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/c-tinyusd.cc
+-rw-r--r--   0 runner    (1001) docker     (123)    33432 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/c-tinyusd.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4813 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/common-macros.inc
+-rw-r--r--   0 runner    (1001) docker     (123)      473 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/composition.hh
+-rw-r--r--   0 runner    (1001) docker     (123)    14820 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/crate-format.cc
+-rw-r--r--   0 runner    (1001) docker     (123)    15104 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/crate-format.hh
+-rw-r--r--   0 runner    (1001) docker     (123)      286 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/crate-pprint.cc
+-rw-r--r--   0 runner    (1001) docker     (123)      299 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/crate-pprint.hh
+-rw-r--r--   0 runner    (1001) docker     (123)   151148 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/crate-reader.cc
+-rw-r--r--   0 runner    (1001) docker     (123)    11961 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/crate-reader.hh
+-rw-r--r--   0 runner    (1001) docker     (123)     6670 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/crate-writer.cc
+-rw-r--r--   0 runner    (1001) docker     (123)      206 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/crate-writer.hh
+-rw-r--r--   0 runner    (1001) docker     (123)     2503 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/define-type-trait.inc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.487455 tinyusdz-0.8.0rc1/src/external/
+-rw-r--r--   0 runner    (1001) docker     (123)     1162 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/LICENSE.miniz
+-rw-r--r--   0 runner    (1001) docker     (123)     1069 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/LICENSE.ogt_vox.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.491455 tinyusdz-0.8.0rc1/src/external/OpenFBX/
+-rw-r--r--   0 runner    (1001) docker     (123)     1071 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/OpenFBX/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     1608 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/OpenFBX/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.491455 tinyusdz-0.8.0rc1/src/external/OpenFBX/src/
+-rw-r--r--   0 runner    (1001) docker     (123)    95264 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/OpenFBX/src/ofbx.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    12581 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/OpenFBX/src/ofbx.h
+-rw-r--r--   0 runner    (1001) docker     (123)    13317 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/README.fpng.md
+-rw-r--r--   0 runner    (1001) docker     (123)   181128 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/dr_mp3.h
+-rw-r--r--   0 runner    (1001) docker     (123)   332116 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/dr_wav.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1052 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/dtoa_milo.LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)    14493 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/dtoa_milo.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.491455 tinyusdz-0.8.0rc1/src/external/fast_float/
+-rw-r--r--   0 runner    (1001) docker     (123)    10767 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/fast_float/LICENSE-APACHE
+-rw-r--r--   0 runner    (1001) docker     (123)     1079 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/fast_float/LICENSE-MIT
+-rw-r--r--   0 runner    (1001) docker     (123)     9769 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/fast_float/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.463455 tinyusdz-0.8.0rc1/src/external/fast_float/include/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.491455 tinyusdz-0.8.0rc1/src/external/fast_float/include/fast_float/
+-rw-r--r--   0 runner    (1001) docker     (123)     7964 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/fast_float/include/fast_float/ascii_number.h
+-rw-r--r--   0 runner    (1001) docker     (123)    16853 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/fast_float/include/fast_float/bigint.h
+-rw-r--r--   0 runner    (1001) docker     (123)     8395 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/fast_float/include/fast_float/decimal_to_binary.h
+-rw-r--r--   0 runner    (1001) docker     (123)    13580 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/fast_float/include/fast_float/digit_comparison.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2503 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/fast_float/include/fast_float/fast_float.h
+-rw-r--r--   0 runner    (1001) docker     (123)    31804 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/fast_float/include/fast_float/fast_table.h
+-rw-r--r--   0 runner    (1001) docker     (123)    12370 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/fast_float/include/fast_float/float_common.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4185 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/fast_float/include/fast_float/parse_number.h
+-rw-r--r--   0 runner    (1001) docker     (123)    13686 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/fast_float/include/fast_float/simple_decimal_conversion.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.491455 tinyusdz-0.8.0rc1/src/external/filesystem/
+-rw-r--r--   0 runner    (1001) docker     (123)     1086 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/filesystem/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)    57107 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/filesystem/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.463455 tinyusdz-0.8.0rc1/src/external/filesystem/include/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.491455 tinyusdz-0.8.0rc1/src/external/filesystem/include/ghc/
+-rw-r--r--   0 runner    (1001) docker     (123)   190674 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/filesystem/include/ghc/filesystem.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2111 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/filesystem/include/ghc/fs_fwd.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1978 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/filesystem/include/ghc/fs_impl.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2685 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/filesystem/include/ghc/fs_std.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2950 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/filesystem/include/ghc/fs_std_fwd.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2464 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/filesystem/include/ghc/fs_std_impl.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.491455 tinyusdz-0.8.0rc1/src/external/floaxie/
+-rw-r--r--   0 runner    (1001) docker     (123)    11358 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     5021 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.495455 tinyusdz-0.8.0rc1/src/external/floaxie/floaxie/
+-rw-r--r--   0 runner    (1001) docker     (123)     6488 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/floaxie/atof.h
+-rw-r--r--   0 runner    (1001) docker     (123)     7883 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/floaxie/bit_ops.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1845 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/floaxie/cached_power.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1084 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/floaxie/conversion_status.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2974 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/floaxie/default_fallback.h
+-rw-r--r--   0 runner    (1001) docker     (123)    16077 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/floaxie/diy_fp.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4661 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/floaxie/fraction.h
+-rw-r--r--   0 runner    (1001) docker     (123)     6505 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/floaxie/ftoa.h
+-rw-r--r--   0 runner    (1001) docker     (123)    10337 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/floaxie/grisu.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1575 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/floaxie/huge_val.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1642 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/floaxie/integer_of_size.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1866 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/floaxie/k_comp.h
+-rw-r--r--   0 runner    (1001) docker     (123)    16756 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/floaxie/krosh.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1816 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/floaxie/memwrap.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1780 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/floaxie/powers_ten.h
+-rw-r--r--   0 runner    (1001) docker     (123)    22390 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/floaxie/powers_ten_double.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4711 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/floaxie/powers_ten_single.h
+-rw-r--r--   0 runner    (1001) docker     (123)     8131 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/floaxie/prettify.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1836 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/floaxie/print.h
+-rw-r--r--   0 runner    (1001) docker     (123)     5764 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/floaxie/static_pow.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1386 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/floaxie/floaxie/type_punning_cast.h
+-rw-r--r--   0 runner    (1001) docker     (123)   115167 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/fpng.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6285 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/fpng.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.495455 tinyusdz-0.8.0rc1/src/external/glob/
+-rw-r--r--   0 runner    (1001) docker     (123)     1063 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/glob/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     7355 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/glob/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.463455 tinyusdz-0.8.0rc1/src/external/glob/include/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.495455 tinyusdz-0.8.0rc1/src/external/glob/include/glob/
+-rw-r--r--   0 runner    (1001) docker     (123)     1596 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/glob/include/glob/glob.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.463455 tinyusdz-0.8.0rc1/src/external/glob/single_include/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.495455 tinyusdz-0.8.0rc1/src/external/glob/single_include/glob/
+-rw-r--r--   0 runner    (1001) docker     (123)    12308 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/glob/single_include/glob/glob.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.495455 tinyusdz-0.8.0rc1/src/external/glob/source/
+-rw-r--r--   0 runner    (1001) docker     (123)    11122 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/glob/source/glob.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.495455 tinyusdz-0.8.0rc1/src/external/jsonhpp/
+-rw-r--r--   0 runner    (1001) docker     (123)     1076 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/jsonhpp/LICENSE.MIT
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.495455 tinyusdz-0.8.0rc1/src/external/jsonhpp/nlohmann/
+-rw-r--r--   0 runner    (1001) docker     (123)   907858 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/jsonhpp/nlohmann/json.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6268 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/jsonhpp/nlohmann/json_fwd.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.495455 tinyusdz-0.8.0rc1/src/external/jsteemann/
+-rw-r--r--   0 runner    (1001) docker     (123)    11344 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/jsteemann/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     8518 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/jsteemann/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)     7496 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/jsteemann/atoi.h
+-rw-r--r--   0 runner    (1001) docker     (123)       55 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/jsteemann/modification.md
+-rw-r--r--   0 runner    (1001) docker     (123)    29857 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/linalg.README
+-rw-r--r--   0 runner    (1001) docker     (123)     1210 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/linalg.UNLICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)    72730 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/linalg.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.463455 tinyusdz-0.8.0rc1/src/external/mapbox/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.495455 tinyusdz-0.8.0rc1/src/external/mapbox/earcut/
+-rw-r--r--   0 runner    (1001) docker     (123)      567 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/mapbox/earcut/CHANGELOG.md
+-rw-r--r--   0 runner    (1001) docker     (123)      738 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/mapbox/earcut/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     6486 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/mapbox/earcut/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)    25024 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/mapbox/earcut/earcut.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.499455 tinyusdz-0.8.0rc1/src/external/mapbox/eternal/
+-rw-r--r--   0 runner    (1001) docker     (123)      738 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/mapbox/eternal/LICENSE.md
+-rw-r--r--   0 runner    (1001) docker     (123)     4046 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/mapbox/eternal/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.463455 tinyusdz-0.8.0rc1/src/external/mapbox/eternal/include/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.499455 tinyusdz-0.8.0rc1/src/external/mapbox/eternal/include/mapbox/
+-rw-r--r--   0 runner    (1001) docker     (123)    11603 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/mapbox/eternal/include/mapbox/eternal.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)   319866 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/miniz.c
+-rw-r--r--   0 runner    (1001) docker     (123)    69441 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/miniz.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.499455 tinyusdz-0.8.0rc1/src/external/nanobind/
+-rw-r--r--   0 runner    (1001) docker     (123)     2961 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1521 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)    24245 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.499455 tinyusdz-0.8.0rc1/src/external/nanobind/cmake/
+-rw-r--r--   0 runner    (1001) docker     (123)     8007 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/cmake/nanobind-config.cmake
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.463455 tinyusdz-0.8.0rc1/src/external/nanobind/ext/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.499455 tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/
+-rw-r--r--   0 runner    (1001) docker     (123)     3176 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1102 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)    21353 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.499455 tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/cmake/
+-rw-r--r--   0 runner    (1001) docker     (123)      407 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/cmake/tsl-robin-mapConfig.cmake.in
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.463455 tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/include/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.499455 tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/include/tsl/
+-rw-r--r--   0 runner    (1001) docker     (123)    11773 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/include/tsl/robin_growth_policy.h
+-rw-r--r--   0 runner    (1001) docker     (123)    53806 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/include/tsl/robin_hash.h
+-rw-r--r--   0 runner    (1001) docker     (123)    28412 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/include/tsl/robin_map.h
+-rw-r--r--   0 runner    (1001) docker     (123)    23593 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/include/tsl/robin_set.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.499455 tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/tests/
+-rw-r--r--   0 runner    (1001) docker     (123)     1111 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/tests/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     3904 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/tests/custom_allocator_tests.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1276 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/tests/main.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3380 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/tests/policy_tests.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    45542 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/tests/robin_map_tests.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5791 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/tests/robin_set_tests.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    12189 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/tests/utils.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4623 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/tsl-robin-map.natvis
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.463455 tinyusdz-0.8.0rc1/src/external/nanobind/include/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.503455 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/
+-rw-r--r--   0 runner    (1001) docker     (123)     1630 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nanobind.h
+-rw-r--r--   0 runner    (1001) docker     (123)     5218 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_accessor.h
+-rw-r--r--   0 runner    (1001) docker     (123)     7228 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_attr.h
+-rw-r--r--   0 runner    (1001) docker     (123)     5348 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_call.h
+-rw-r--r--   0 runner    (1001) docker     (123)    12016 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_cast.h
+-rw-r--r--   0 runner    (1001) docker     (123)    17928 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_class.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4544 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_defs.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4152 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_descr.h
+-rw-r--r--   0 runner    (1001) docker     (123)     3259 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_enums.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2245 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_error.h
+-rw-r--r--   0 runner    (1001) docker     (123)     9619 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_func.h
+-rw-r--r--   0 runner    (1001) docker     (123)    15009 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_lib.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1521 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_misc.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1400 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_python.h
+-rw-r--r--   0 runner    (1001) docker     (123)     5112 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_traits.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2491 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_tuple.h
+-rw-r--r--   0 runner    (1001) docker     (123)    18870 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_types.h
+-rw-r--r--   0 runner    (1001) docker     (123)     7562 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/operators.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.503455 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/stl/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.503455 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/stl/detail/
+-rw-r--r--   0 runner    (1001) docker     (123)     1858 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/stl/detail/nb_list.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1592 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/stl/function.h
+-rw-r--r--   0 runner    (1001) docker     (123)      299 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/stl/list.h
+-rw-r--r--   0 runner    (1001) docker     (123)     3121 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/stl/pair.h
+-rw-r--r--   0 runner    (1001) docker     (123)     3782 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/stl/shared_ptr.h
+-rw-r--r--   0 runner    (1001) docker     (123)      792 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/stl/string.h
+-rw-r--r--   0 runner    (1001) docker     (123)     3222 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/stl/tuple.h
+-rw-r--r--   0 runner    (1001) docker     (123)     3000 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/stl/unique_ptr.h
+-rw-r--r--   0 runner    (1001) docker     (123)      305 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/stl/vector.h
+-rw-r--r--   0 runner    (1001) docker     (123)    11142 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/tensor.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2695 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/trampoline.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.503455 tinyusdz-0.8.0rc1/src/external/nanobind/src/
+-rw-r--r--   0 runner    (1001) docker     (123)     4165 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/src/buffer.h
+-rw-r--r--   0 runner    (1001) docker     (123)    23020 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/src/common.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3379 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/src/error.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2571 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/src/implicit.cpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.503455 tinyusdz-0.8.0rc1/src/external/nanobind/src/nanobind/
+-rw-r--r--   0 runner    (1001) docker     (123)      536 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/src/nanobind/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10318 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/src/nb_enum.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    36266 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/src/nb_func.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    14587 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/src/nb_internals.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     8156 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/src/nb_internals.h
+-rw-r--r--   0 runner    (1001) docker     (123)    37029 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/src/nb_type.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    18463 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/src/tensor.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3724 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/nanobind/src/trampoline.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)   129647 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/ogt_vox.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.503455 tinyusdz-0.8.0rc1/src/external/pybind11/
+-rw-r--r--   0 runner    (1001) docker     (123)    10999 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1684 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     7686 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/README.rst
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.463455 tinyusdz-0.8.0rc1/src/external/pybind11/include/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.507455 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/
+-rw-r--r--   0 runner    (1001) docker     (123)    23979 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/attr.h
+-rw-r--r--   0 runner    (1001) docker     (123)     7069 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/buffer_info.h
+-rw-r--r--   0 runner    (1001) docker     (123)    65705 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/cast.h
+-rw-r--r--   0 runner    (1001) docker     (123)     8458 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/chrono.h
+-rw-r--r--   0 runner    (1001) docker     (123)      120 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/common.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2096 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/complex.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.507455 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/detail/
+-rw-r--r--   0 runner    (1001) docker     (123)    28337 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/detail/class.h
+-rw-r--r--   0 runner    (1001) docker     (123)    50335 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/detail/common.h
+-rw-r--r--   0 runner    (1001) docker     (123)     5491 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/detail/descr.h
+-rw-r--r--   0 runner    (1001) docker     (123)    17981 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/detail/init.h
+-rw-r--r--   0 runner    (1001) docker     (123)    24008 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/detail/internals.h
+-rw-r--r--   0 runner    (1001) docker     (123)    42266 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/detail/type_caster_base.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1625 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/detail/typeid.h
+-rw-r--r--   0 runner    (1001) docker     (123)    32147 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/eigen.h
+-rw-r--r--   0 runner    (1001) docker     (123)    11735 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/embed.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4731 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/eval.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4695 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/functional.h
+-rw-r--r--   0 runner    (1001) docker     (123)     6923 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/gil.h
+-rw-r--r--   0 runner    (1001) docker     (123)     8862 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/iostream.h
+-rw-r--r--   0 runner    (1001) docker     (123)    79526 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/numpy.h
+-rw-r--r--   0 runner    (1001) docker     (123)     9051 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/operators.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2181 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/options.h
+-rw-r--r--   0 runner    (1001) docker     (123)   126301 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/pybind11.h
+-rw-r--r--   0 runner    (1001) docker     (123)    92122 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/pytypes.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.507455 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/stl/
+-rw-r--r--   0 runner    (1001) docker     (123)     4185 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/stl/filesystem.h
+-rw-r--r--   0 runner    (1001) docker     (123)    14556 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/stl.h
+-rw-r--r--   0 runner    (1001) docker     (123)    27013 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/stl_bind.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.511455 tinyusdz-0.8.0rc1/src/external/pybind11/tools/
+-rw-r--r--   0 runner    (1001) docker     (123)     2350 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/tools/FindCatch.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     3105 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/tools/FindEigen3.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)    10890 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/tools/FindPythonLibsNew.cmake
+-rwxr-xr-x   0 runner    (1001) docker     (123)     1423 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/tools/check-style.sh
+-rw-r--r--   0 runner    (1001) docker     (123)      952 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/tools/cmake_uninstall.cmake.in
+-rw-r--r--   0 runner    (1001) docker     (123)     1031 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/tools/libsize.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     1282 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/tools/make_changelog.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13487 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/tools/pybind11Common.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     6930 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/tools/pybind11Config.cmake.in
+-rw-r--r--   0 runner    (1001) docker     (123)     8955 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/tools/pybind11NewTools.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)     7862 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/tools/pybind11Tools.cmake
+-rw-r--r--   0 runner    (1001) docker     (123)       94 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/tools/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (123)     1851 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/tools/setup_global.py.in
+-rw-r--r--   0 runner    (1001) docker     (123)     1057 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pybind11/tools/setup_main.py.in
+-rw-r--r--   0 runner    (1001) docker     (123)     1530 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pystring.LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)    45524 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pystring.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    22943 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/pystring.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.511455 tinyusdz-0.8.0rc1/src/external/simple_match/
+-rw-r--r--   0 runner    (1001) docker     (123)     1338 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/simple_match/LICENSE_1_0.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    11293 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/simple_match/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.463455 tinyusdz-0.8.0rc1/src/external/simple_match/include/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.511455 tinyusdz-0.8.0rc1/src/external/simple_match/include/simple_match/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.511455 tinyusdz-0.8.0rc1/src/external/simple_match/include/simple_match/implementation/
+-rw-r--r--   0 runner    (1001) docker     (123)     9039 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/simple_match/include/simple_match/implementation/some_none.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    10854 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/simple_match/include/simple_match/simple_match.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      900 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/simple_match/include/simple_match/utility.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    10982 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/staticstruct.cc
+-rw-r--r--   0 runner    (1001) docker     (123)    54476 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/staticstruct.hh
+-rw-r--r--   0 runner    (1001) docker     (123)   285855 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/stb_image.h
+-rw-r--r--   0 runner    (1001) docker     (123)   116516 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/stb_image_resize.h
+-rw-r--r--   0 runner    (1001) docker     (123)    71221 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/stb_image_write.h
+-rw-r--r--   0 runner    (1001) docker     (123)   199033 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/stb_truetype.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.511455 tinyusdz-0.8.0rc1/src/external/string_id/
+-rw-r--r--   0 runner    (1001) docker     (123)      900 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/string_id/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     4654 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/string_id/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)       29 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/string_id/README.mod.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     3201 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/string_id/basic_database.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)      449 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/string_id/config.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2267 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/string_id/config.hpp.in
+-rw-r--r--   0 runner    (1001) docker     (123)     2201 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/string_id/config_impl.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     7752 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/string_id/database.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4147 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/string_id/database.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2747 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/string_id/error.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4948 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/string_id/error.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2134 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/string_id/generator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5680 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/string_id/generator.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1019 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/string_id/hash.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1595 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/string_id/string_id.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5705 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/string_id/string_id.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4082 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/tiny-color-io.h
+-rw-r--r--   0 runner    (1001) docker     (123)   170020 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/tiny_dng_loader.h
+-rw-r--r--   0 runner    (1001) docker     (123)    72493 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/tiny_dng_writer.h
+-rw-r--r--   0 runner    (1001) docker     (123)      127 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/tiny_gltf.cc
+-rw-r--r--   0 runner    (1001) docker     (123)   242617 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/tiny_gltf.h
+-rw-r--r--   0 runner    (1001) docker     (123)       66 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/tiny_obj_loader.cc
+-rw-r--r--   0 runner    (1001) docker     (123)   105412 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/tiny_obj_loader.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1071 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/tinycolorio.LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)      154 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/tinyexr.cc
+-rw-r--r--   0 runner    (1001) docker     (123)   287741 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/tinyexr.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.511455 tinyusdz-0.8.0rc1/src/external/tinyxml2/
+-rw-r--r--   0 runner    (1001) docker     (123)      808 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/tinyxml2/LICENSE.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    11410 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/tinyxml2/readme.md
+-rwxr-xr-x   0 runner    (1001) docker     (123)    77996 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/tinyxml2/tinyxml2.cpp
+-rwxr-xr-x   0 runner    (1001) docker     (123)    73783 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/external/tinyxml2/tinyxml2.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2382 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/handle-allocator.hh
+-rw-r--r--   0 runner    (1001) docker     (123)    10007 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/image-loader.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     1981 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/image-loader.hh
+-rw-r--r--   0 runner    (1001) docker     (123)     2192 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/image-types.hh
+-rw-r--r--   0 runner    (1001) docker     (123)    20306 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/image-util.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     6666 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/image-util.hh
+-rw-r--r--   0 runner    (1001) docker     (123)     3486 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/image-writer.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     1470 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/image-writer.hh
+-rw-r--r--   0 runner    (1001) docker     (123)    15751 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/integerCoding.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     5823 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/integerCoding.h
+-rw-r--r--   0 runner    (1001) docker     (123)    14449 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/io-util.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     3660 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/io-util.hh
+-rw-r--r--   0 runner    (1001) docker     (123)     6816 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/linear-algebra.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     3549 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/linear-algebra.hh
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.511455 tinyusdz-0.8.0rc1/src/lz4/
+-rw-r--r--   0 runner    (1001) docker     (123)     1311 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/lz4/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)   113693 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/lz4/lz4.c
+-rw-r--r--   0 runner    (1001) docker     (123)    43263 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/lz4/lz4.h
+-rw-r--r--   0 runner    (1001) docker     (123)     7972 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/lz4-compression.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     1449 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/lz4-compression.hh
+-rw-r--r--   0 runner    (1001) docker     (123)     7002 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/math-util.inc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.511455 tinyusdz-0.8.0rc1/src/nonstd/
+-rw-r--r--   0 runner    (1001) docker     (123)    69952 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/nonstd/expected.hpp
+-rw-r--r--   0 runner    (1001) docker     (123)    52033 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/nonstd/optional.hpp
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.515455 tinyusdz-0.8.0rc1/src/osd/
+-rw-r--r--   0 runner    (1001) docker     (123)    28882 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    10038 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/LICENSE.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      102 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.515455 tinyusdz-0.8.0rc1/src/osd/opensubdiv/
+-rw-r--r--   0 runner    (1001) docker     (123)    15822 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/CMakeLists.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.519455 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/
+-rw-r--r--   0 runner    (1001) docker     (123)     2953 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     3901 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/bilinearPatchBuilder.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2685 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/bilinearPatchBuilder.h
+-rw-r--r--   0 runner    (1001) docker     (123)    74980 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/catmarkPatchBuilder.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2731 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/catmarkPatchBuilder.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2804 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/error.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3153 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/error.h
+-rw-r--r--   0 runner    (1001) docker     (123)    71100 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/loopPatchBuilder.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2653 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/loopPatchBuilder.h
+-rw-r--r--   0 runner    (1001) docker     (123)    51275 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchBasis.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4222 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchBasis.h
+-rw-r--r--   0 runner    (1001) docker     (123)    62973 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchBuilder.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    12997 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchBuilder.h
+-rw-r--r--   0 runner    (1001) docker     (123)     3019 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchDescriptor.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     6042 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchDescriptor.h
+-rw-r--r--   0 runner    (1001) docker     (123)     6586 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchMap.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     8150 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchMap.h
+-rw-r--r--   0 runner    (1001) docker     (123)    12368 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchParam.h
+-rw-r--r--   0 runner    (1001) docker     (123)    25747 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchTable.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    31014 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchTable.h
+-rw-r--r--   0 runner    (1001) docker     (123)    77937 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchTableFactory.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    10842 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchTableFactory.h
+-rw-r--r--   0 runner    (1001) docker     (123)    52474 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/primvarRefiner.h
+-rw-r--r--   0 runner    (1001) docker     (123)     7065 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/ptexIndices.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3038 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/ptexIndices.h
+-rw-r--r--   0 runner    (1001) docker     (123)     6393 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/sparseMatrix.h
+-rw-r--r--   0 runner    (1001) docker     (123)    19388 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/stencilBuilder.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3739 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/stencilBuilder.h
+-rw-r--r--   0 runner    (1001) docker     (123)     8841 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/stencilTable.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    27801 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/stencilTable.h
+-rw-r--r--   0 runner    (1001) docker     (123)    26398 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/stencilTableFactory.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    15853 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/stencilTableFactory.h
+-rw-r--r--   0 runner    (1001) docker     (123)     6135 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/topologyDescriptor.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3985 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/topologyDescriptor.h
+-rw-r--r--   0 runner    (1001) docker     (123)    14645 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/topologyLevel.h
+-rw-r--r--   0 runner    (1001) docker     (123)    32137 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/topologyRefiner.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    11630 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/topologyRefiner.h
+-rw-r--r--   0 runner    (1001) docker     (123)    17656 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/topologyRefinerFactory.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    31537 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/topologyRefinerFactory.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2107 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/types.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.519455 tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/
+-rw-r--r--   0 runner    (1001) docker     (123)     1800 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     5293 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/allocator.h
+-rw-r--r--   0 runner    (1001) docker     (123)    35809 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/bilinear.h
+-rw-r--r--   0 runner    (1001) docker     (123)    46301 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/catmark.h
+-rw-r--r--   0 runner    (1001) docker     (123)     3870 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/cornerEdit.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4019 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/creaseEdit.h
+-rw-r--r--   0 runner    (1001) docker     (123)    33240 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/face.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4512 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/faceEdit.h
+-rw-r--r--   0 runner    (1001) docker     (123)     5926 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/fvarData.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4721 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/fvarEdit.h
+-rw-r--r--   0 runner    (1001) docker     (123)    24345 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/halfedge.h
+-rw-r--r--   0 runner    (1001) docker     (123)     5401 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/hierarchicalEdit.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2387 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/holeEdit.h
+-rw-r--r--   0 runner    (1001) docker     (123)    38089 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/loop.h
+-rw-r--r--   0 runner    (1001) docker     (123)    31625 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/mesh.h
+-rw-r--r--   0 runner    (1001) docker     (123)    11284 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/subdivision.h
+-rw-r--r--   0 runner    (1001) docker     (123)    50612 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/vertex.h
+-rw-r--r--   0 runner    (1001) docker     (123)     9457 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/vertexEdit.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.535455 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/
+-rw-r--r--   0 runner    (1001) docker     (123)     1603 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/Android.mk
+-rwxr-xr-x   0 runner    (1001) docker     (123)    10822 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     3838 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/bufferDescriptor.h
+-rw-r--r--   0 runner    (1001) docker     (123)     7173 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/clD3D11VertexBuffer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4690 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/clD3D11VertexBuffer.h
+-rw-r--r--   0 runner    (1001) docker     (123)    23234 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/clEvaluator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)   128029 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/clEvaluator.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4204 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/clGLVertexBuffer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3928 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/clGLVertexBuffer.h
+-rw-r--r--   0 runner    (1001) docker     (123)     8377 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/clKernel.cl
+-rw-r--r--   0 runner    (1001) docker     (123)     6957 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/clPatchTable.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4021 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/clPatchTable.h
+-rw-r--r--   0 runner    (1001) docker     (123)     3021 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/clVertexBuffer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3456 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/clVertexBuffer.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4069 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuD3D11VertexBuffer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3189 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuD3D11VertexBuffer.h
+-rw-r--r--   0 runner    (1001) docker     (123)    13998 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuEvaluator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    55912 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuEvaluator.h
+-rw-r--r--   0 runner    (1001) docker     (123)     3246 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuGLVertexBuffer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3132 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuGLVertexBuffer.h
+-rw-r--r--   0 runner    (1001) docker     (123)     8318 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuKernel.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4885 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuKernel.h
+-rw-r--r--   0 runner    (1001) docker     (123)     6900 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuPatchTable.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4624 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuPatchTable.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2296 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuVertexBuffer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2621 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuVertexBuffer.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4351 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cudaD3D11VertexBuffer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3517 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cudaD3D11VertexBuffer.h
+-rw-r--r--   0 runner    (1001) docker     (123)    14078 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cudaEvaluator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    57545 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cudaEvaluator.h
+-rw-r--r--   0 runner    (1001) docker     (123)     5016 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cudaGLVertexBuffer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3421 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cudaGLVertexBuffer.h
+-rw-r--r--   0 runner    (1001) docker     (123)    15404 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cudaKernel.cu
+-rw-r--r--   0 runner    (1001) docker     (123)     6562 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cudaPatchTable.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3842 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cudaPatchTable.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2692 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cudaVertexBuffer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2718 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cudaVertexBuffer.h
+-rw-r--r--   0 runner    (1001) docker     (123)    13939 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/d3d11ComputeEvaluator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     9666 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/d3d11ComputeEvaluator.h
+-rw-r--r--   0 runner    (1001) docker     (123)     6149 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/d3d11LegacyGregoryPatchTable.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3238 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/d3d11LegacyGregoryPatchTable.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1578 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/d3d11Mesh.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4891 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/d3d11PatchTable.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3039 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/d3d11PatchTable.h
+-rw-r--r--   0 runner    (1001) docker     (123)     5132 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/d3d11VertexBuffer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3269 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/d3d11VertexBuffer.h
+-rw-r--r--   0 runner    (1001) docker     (123)    21394 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glComputeEvaluator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    97063 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glComputeEvaluator.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4373 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glLegacyGregoryPatchTable.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2607 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glLegacyGregoryPatchTable.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1563 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glMesh.h
+-rw-r--r--   0 runner    (1001) docker     (123)     6520 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glPatchTable.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4924 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glPatchTable.h
+-rw-r--r--   0 runner    (1001) docker     (123)     3431 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glVertexBuffer.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2773 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glVertexBuffer.h
+-rw-r--r--   0 runner    (1001) docker     (123)    36815 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glXFBEvaluator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)   101170 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glXFBEvaluator.h
+-rw-r--r--   0 runner    (1001) docker     (123)     9248 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslComputeKernel.glsl
+-rw-r--r--   0 runner    (1001) docker     (123)     5735 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslPatchBSpline.glsl
+-rw-r--r--   0 runner    (1001) docker     (123)     5177 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslPatchBoxSplineTriangle.glsl
+-rw-r--r--   0 runner    (1001) docker     (123)    39688 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslPatchCommon.glsl
+-rw-r--r--   0 runner    (1001) docker     (123)    28734 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslPatchCommonTess.glsl
+-rw-r--r--   0 runner    (1001) docker     (123)     6129 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslPatchGregory.glsl
+-rw-r--r--   0 runner    (1001) docker     (123)     5669 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslPatchGregoryBasis.glsl
+-rw-r--r--   0 runner    (1001) docker     (123)     5506 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslPatchGregoryTriangle.glsl
+-rw-r--r--   0 runner    (1001) docker     (123)    19694 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslPatchLegacy.glsl
+-rw-r--r--   0 runner    (1001) docker     (123)     7557 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslPatchShaderSource.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1970 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslPatchShaderSource.h
+-rw-r--r--   0 runner    (1001) docker     (123)     8278 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslXFBKernel.glsl
+-rw-r--r--   0 runner    (1001) docker     (123)     4131 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/hlslComputeKernel.hlsl
+-rw-r--r--   0 runner    (1001) docker     (123)     5220 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/hlslPatchBSpline.hlsl
+-rw-r--r--   0 runner    (1001) docker     (123)     5053 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/hlslPatchBoxSplineTriangle.hlsl
+-rw-r--r--   0 runner    (1001) docker     (123)    40195 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/hlslPatchCommon.hlsl
+-rw-r--r--   0 runner    (1001) docker     (123)    29589 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/hlslPatchCommonTess.hlsl
+-rw-r--r--   0 runner    (1001) docker     (123)     6190 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/hlslPatchGregory.hlsl
+-rw-r--r--   0 runner    (1001) docker     (123)     5732 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/hlslPatchGregoryBasis.hlsl
+-rw-r--r--   0 runner    (1001) docker     (123)     5499 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/hlslPatchGregoryTriangle.hlsl
+-rw-r--r--   0 runner    (1001) docker     (123)    13720 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/hlslPatchLegacy.hlsl
+-rw-r--r--   0 runner    (1001) docker     (123)     5408 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/hlslPatchShaderSource.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1936 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/hlslPatchShaderSource.h
+-rw-r--r--   0 runner    (1001) docker     (123)    26278 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mesh.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1647 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlCommon.h
+-rw-r--r--   0 runner    (1001) docker     (123)   101764 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlComputeEvaluator.h
+-rw-r--r--   0 runner    (1001) docker     (123)    22374 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlComputeEvaluator.mm
+-rw-r--r--   0 runner    (1001) docker     (123)    11416 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlComputeKernel.metal
+-rw-r--r--   0 runner    (1001) docker     (123)     2837 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlLegacyGregoryPatchTable.h
+-rw-r--r--   0 runner    (1001) docker     (123)     3490 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlLegacyGregoryPatchTable.mm
+-rw-r--r--   0 runner    (1001) docker     (123)     1566 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlMesh.h
+-rw-r--r--   0 runner    (1001) docker     (123)       27 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlMesh.mm
+-rw-r--r--   0 runner    (1001) docker     (123)     7068 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchBSpline.metal
+-rw-r--r--   0 runner    (1001) docker     (123)     7164 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchBoxSplineTriangle.metal
+-rw-r--r--   0 runner    (1001) docker     (123)    47039 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchCommon.metal
+-rw-r--r--   0 runner    (1001) docker     (123)    36222 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchCommonTess.metal
+-rw-r--r--   0 runner    (1001) docker     (123)     8357 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchGregory.metal
+-rw-r--r--   0 runner    (1001) docker     (123)     8603 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchGregoryBasis.metal
+-rw-r--r--   0 runner    (1001) docker     (123)     8014 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchGregoryTriangle.metal
+-rw-r--r--   0 runner    (1001) docker     (123)    13828 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchLegacy.metal
+-rw-r--r--   0 runner    (1001) docker     (123)     2533 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchShaderSource.h
+-rw-r--r--   0 runner    (1001) docker     (123)     7785 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchShaderSource.mm
+-rw-r--r--   0 runner    (1001) docker     (123)     3389 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchTable.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4942 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchTable.mm
+-rw-r--r--   0 runner    (1001) docker     (123)     2317 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlVertexBuffer.h
+-rw-r--r--   0 runner    (1001) docker     (123)     2933 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlVertexBuffer.mm
+-rw-r--r--   0 runner    (1001) docker     (123)     1618 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/nonCopyable.h
+-rw-r--r--   0 runner    (1001) docker     (123)    12296 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/ompEvaluator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    55848 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/ompEvaluator.h
+-rw-r--r--   0 runner    (1001) docker     (123)    10162 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/ompKernel.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3249 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/ompKernel.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1386 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/opencl.h
+-rw-r--r--   0 runner    (1001) docker     (123)     1792 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/opengl.h
+-rw-r--r--   0 runner    (1001) docker     (123)    51542 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/patchBasisCommon.h
+-rw-r--r--   0 runner    (1001) docker     (123)     7197 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/patchBasisCommonEval.h
+-rw-r--r--   0 runner    (1001) docker     (123)    14090 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/patchBasisCommonTypes.h
+-rw-r--r--   0 runner    (1001) docker     (123)     7332 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/tbbEvaluator.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    56103 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/tbbEvaluator.h
+-rw-r--r--   0 runner    (1001) docker     (123)    22756 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/tbbKernel.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4585 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/tbbKernel.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4432 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/types.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.535455 tinyusdz-0.8.0rc1/src/osd/opensubdiv/sdc/
+-rw-r--r--   0 runner    (1001) docker     (123)     2159 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/sdc/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     5045 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/sdc/bilinearScheme.h
+-rw-r--r--   0 runner    (1001) docker     (123)    17914 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/sdc/catmarkScheme.h
+-rw-r--r--   0 runner    (1001) docker     (123)     7473 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/sdc/crease.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    10866 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/sdc/crease.h
+-rw-r--r--   0 runner    (1001) docker     (123)    20992 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/sdc/loopScheme.h
+-rw-r--r--   0 runner    (1001) docker     (123)     5432 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/sdc/options.h
+-rw-r--r--   0 runner    (1001) docker     (123)    29037 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/sdc/scheme.h
+-rw-r--r--   0 runner    (1001) docker     (123)     3153 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/sdc/typeTraits.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     2476 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/sdc/types.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.467455 tinyusdz-0.8.0rc1/src/osd/opensubdiv/tools/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.535455 tinyusdz-0.8.0rc1/src/osd/opensubdiv/tools/stringify/
+-rw-r--r--   0 runner    (1001) docker     (123)     1532 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/tools/stringify/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     2435 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/tools/stringify/main.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1263 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/version.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     1555 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/version.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.539455 tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/
+-rw-r--r--   0 runner    (1001) docker     (123)     2515 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     4712 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/array.h
+-rw-r--r--   0 runner    (1001) docker     (123)     5059 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/componentInterfaces.h
+-rw-r--r--   0 runner    (1001) docker     (123)    43985 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/fvarLevel.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    16650 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/fvarLevel.h
+-rw-r--r--   0 runner    (1001) docker     (123)    27935 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/fvarRefinement.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4243 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/fvarRefinement.h
+-rw-r--r--   0 runner    (1001) docker     (123)    79674 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/level.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    35171 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/level.h
+-rw-r--r--   0 runner    (1001) docker     (123)    42569 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/quadRefinement.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3335 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/quadRefinement.h
+-rw-r--r--   0 runner    (1001) docker     (123)    48194 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/refinement.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)    18593 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/refinement.h
+-rw-r--r--   0 runner    (1001) docker     (123)     3168 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/sparseSelector.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     4030 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/sparseSelector.h
+-rw-r--r--   0 runner    (1001) docker     (123)     6772 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/stackBuffer.h
+-rw-r--r--   0 runner    (1001) docker     (123)    37702 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/triRefinement.cpp
+-rw-r--r--   0 runner    (1001) docker     (123)     3704 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/triRefinement.h
+-rw-r--r--   0 runner    (1001) docker     (123)     3368 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/types.h
+-rw-r--r--   0 runner    (1001) docker     (123)     4260 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/path-util.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     2269 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/path-util.hh
+-rw-r--r--   0 runner    (1001) docker     (123)      453 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/performance.cc
+-rw-r--r--   0 runner    (1001) docker     (123)      281 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/performance.hh
+-rw-r--r--   0 runner    (1001) docker     (123)    91606 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/pprinter.cc
+-rw-r--r--   0 runner    (1001) docker     (123)    11151 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/pprinter.hh
+-rw-r--r--   0 runner    (1001) docker     (123)      329 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/prim-composition.cc
+-rw-r--r--   0 runner    (1001) docker     (123)      692 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/prim-pprint.hh
+-rw-r--r--   0 runner    (1001) docker     (123)   121870 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/prim-reconstruct.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     1040 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/prim-reconstruct.hh
+-rw-r--r--   0 runner    (1001) docker     (123)    36190 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/prim-types.cc
+-rw-r--r--   0 runner    (1001) docker     (123)    83978 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/prim-types.hh
+-rw-r--r--   0 runner    (1001) docker     (123)     2354 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/primvar.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     4731 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/primvar.hh
+-rw-r--r--   0 runner    (1001) docker     (123)      571 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/pxr-compat.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     3335 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/pxr-compat.hh
+-rw-r--r--   0 runner    (1001) docker     (123)    18678 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/python-bindings.cc
+-rw-r--r--   0 runner    (1001) docker     (123)    23208 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/stage.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     8981 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/stage.hh
+-rw-r--r--   0 runner    (1001) docker     (123)     8265 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/str-util.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     8302 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/str-util.hh
+-rw-r--r--   0 runner    (1001) docker     (123)     7666 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/stream-reader.hh
+-rw-r--r--   0 runner    (1001) docker     (123)     7160 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/stream-writer.hh
+-rw-r--r--   0 runner    (1001) docker     (123)    10046 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/subdiv.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     3392 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/subdiv.hh
+-rw-r--r--   0 runner    (1001) docker     (123)     2176 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/texture-types.hh
+-rw-r--r--   0 runner    (1001) docker     (123)    19303 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/tiny-any.inc
+-rw-r--r--   0 runner    (1001) docker     (123)     2420 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/tiny-format.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     2221 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/tiny-format.hh
+-rw-r--r--   0 runner    (1001) docker     (123)    10421 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/tiny-variant.hh
+-rw-r--r--   0 runner    (1001) docker     (123)    24422 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/tinyusdz.cc
+-rw-r--r--   0 runner    (1001) docker     (123)    10242 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/tinyusdz.hh
+-rw-r--r--   0 runner    (1001) docker     (123)     4050 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/token-type.hh
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-19 11:05:02.539455 tinyusdz-0.8.0rc1/src/tydra/
+-rw-r--r--   0 runner    (1001) docker     (123)     1151 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/tydra/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)     1408 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/tydra/prim-apply.cc
+-rw-r--r--   0 runner    (1001) docker     (123)      566 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/tydra/prim-apply.hh
+-rw-r--r--   0 runner    (1001) docker     (123)    66974 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/tydra/render-data.cc
+-rw-r--r--   0 runner    (1001) docker     (123)    21590 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/tydra/render-data.hh
+-rw-r--r--   0 runner    (1001) docker     (123)    64026 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/tydra/scene-access.cc
+-rw-r--r--   0 runner    (1001) docker     (123)    12901 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/tydra/scene-access.hh
+-rw-r--r--   0 runner    (1001) docker     (123)     9216 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/tydra/shader-network.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     4013 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/tydra/shader-network.hh
+-rw-r--r--   0 runner    (1001) docker     (123)     4513 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usd-to-json.cc
+-rw-r--r--   0 runner    (1001) docker     (123)      532 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usd-to-json.hh
+-rw-r--r--   0 runner    (1001) docker     (123)     1242 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usdFbx.cc
+-rw-r--r--   0 runner    (1001) docker     (123)      560 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usdFbx.hh
+-rw-r--r--   0 runner    (1001) docker     (123)    23871 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usdGeom.cc
+-rw-r--r--   0 runner    (1001) docker     (123)    25833 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usdGeom.hh
+-rw-r--r--   0 runner    (1001) docker     (123)      175 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usdLux.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     5189 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usdLux.hh
+-rw-r--r--   0 runner    (1001) docker     (123)      361 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usdMtlx.cc
+-rw-r--r--   0 runner    (1001) docker     (123)      576 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usdMtlx.hh
+-rw-r--r--   0 runner    (1001) docker     (123)     6668 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usdObj.cc
+-rw-r--r--   0 runner    (1001) docker     (123)      542 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usdObj.hh
+-rw-r--r--   0 runner    (1001) docker     (123)      333 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usdShade.cc
+-rw-r--r--   0 runner    (1001) docker     (123)    12359 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usdShade.hh
+-rw-r--r--   0 runner    (1001) docker     (123)     1928 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usdSkel.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     8392 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usdSkel.hh
+-rw-r--r--   0 runner    (1001) docker     (123)      172 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usdVox.cc
+-rw-r--r--   0 runner    (1001) docker     (123)      570 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usdVox.hh
+-rw-r--r--   0 runner    (1001) docker     (123)    64859 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usda-reader.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     2144 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usda-reader.hh
+-rw-r--r--   0 runner    (1001) docker     (123)     1674 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usda-writer.cc
+-rw-r--r--   0 runner    (1001) docker     (123)      701 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usda-writer.hh
+-rw-r--r--   0 runner    (1001) docker     (123)    93032 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usdc-reader.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     1273 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usdc-reader.hh
+-rw-r--r--   0 runner    (1001) docker     (123)    13995 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usdc-writer.cc
+-rw-r--r--   0 runner    (1001) docker     (123)      913 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/usdc-writer.hh
+-rw-r--r--   0 runner    (1001) docker     (123)    20210 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/value-eval-util.hh
+-rw-r--r--   0 runner    (1001) docker     (123)    28105 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/value-pprint.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     9398 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/value-pprint.hh
+-rw-r--r--   0 runner    (1001) docker     (123)     4071 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/value-type-macros.inc
+-rw-r--r--   0 runner    (1001) docker     (123)    33486 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/value-types.cc
+-rw-r--r--   0 runner    (1001) docker     (123)    59147 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/value-types.hh
+-rw-r--r--   0 runner    (1001) docker     (123)    44408 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/xform.cc
+-rw-r--r--   0 runner    (1001) docker     (123)     7942 2023-04-19 11:04:49.000000 tinyusdz-0.8.0rc1/src/xform.hh
```

### Comparing `tinyusdz-0.8.0rc0/CMakeSettings.json` & `tinyusdz-0.8.0rc1/CMakeSettings.json`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/LICENSE` & `tinyusdz-0.8.0rc1/LICENSE`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/MANIFEST.in` & `tinyusdz-0.8.0rc1/MANIFEST.in`

 * *Files 4% similar despite different names*

```diff
@@ -33,34 +33,52 @@
 include python/README.md
 include python/test.py
 include python/tinyusdz/Usd/Stage/__init__.py
 include python/tinyusdz/Usd/__init__.py
 include python/tinyusdz/UsdGeom/Tokens.py
 include python/tinyusdz/UsdGeom/__init__.py
 include setup.py
+include src/asset-resolution.cc
+include src/asset-resolution.hh
 include src/ascii-parser.cc
 include src/ascii-parser.hh
+include src/ascii-parser-basetype.cc
+include src/ascii-parser-timesamples.cc
+include src/ascii-parser-timesamples-array.cc
 include src/c-tinyusd.cc
 include src/c-tinyusd.h
 include src/common-macros.inc
+include src/composition.hh
 include src/crate-format.cc
 include src/crate-format.hh
 include src/crate-pprint.cc
 include src/crate-pprint.hh
 include src/crate-reader.cc
 include src/crate-reader.hh
 include src/crate-writer.cc
 include src/crate-writer.hh
 include src/define-type-trait.inc
+include src/external/filesystem/LICENSE
+include src/external/filesystem/README.md
+include src/external/filesystem/include/ghc/filesystem.hpp
+include src/external/filesystem/include/ghc/fs_fwd.hpp
+include src/external/filesystem/include/ghc/fs_impl.hpp
+include src/external/filesystem/include/ghc/fs_std_fwd.hpp
+include src/external/filesystem/include/ghc/fs_std.hpp
+include src/external/glob/include/glob/glob.h
+include src/external/glob/LICENSE
+include src/external/glob/README.md
+include src/external/glob/single_include/glob/glob.hpp
+include src/external/glob/source/glob.cpp
+include src/external/filesystem/include/ghc/fs_std_impl.hpp
 include src/external/LICENSE.miniz
 include src/external/LICENSE.ogt_vox.md
 include src/external/README.fpng.md
-include src/external/better-enums/LICENSE.md
-include src/external/better-enums/README.md
-include src/external/better-enums/enum.h
+include src/external/dtoa_milo.h
+include src/external/dtoa_milo.LICENSE
 include src/external/dr_mp3.h
 include src/external/dr_wav.h
 include src/external/fast_float/LICENSE-APACHE
 include src/external/fast_float/LICENSE-MIT
 include src/external/fast_float/README.md
 include src/external/fast_float/include/fast_float/ascii_number.h
 include src/external/fast_float/include/fast_float/bigint.h
@@ -69,14 +87,31 @@
 include src/external/fast_float/include/fast_float/fast_float.h
 include src/external/fast_float/include/fast_float/fast_table.h
 include src/external/fast_float/include/fast_float/float_common.h
 include src/external/fast_float/include/fast_float/parse_number.h
 include src/external/fast_float/include/fast_float/simple_decimal_conversion.h
 include src/external/fpng.cpp
 include src/external/fpng.h
+include src/external/itoa
+include src/external/itoa/include
+include src/external/itoa/include/itoa
+include src/external/itoa/include/itoa/jeaiii_to_text.h
+include src/external/itoa/itoa
+include src/external/itoa/itoa/0_OLD_VERSIONS.txt
+include src/external/itoa/itoa/int_to_chars_jeaiii.h
+include src/external/itoa/itoa/itoa_jeaiii.cpp
+include src/external/itoa/itoa/to_chars.cpp
+include src/external/itoa/itoa/to_text_from_integer.h
+include src/external/itoa/LICENSE
+include src/external/itoa/README.md
+include src/external/itoa/test
+include src/external/itoa/test/main.cpp
+include src/external/itoa/test/test.sln
+include src/external/itoa/test/test.vcxproj
+include src/external/itoa/test/test.vcxproj.filters
 include src/external/jsonhpp/LICENSE.MIT
 include src/external/jsonhpp/nlohmann/adl_serializer.hpp
 include src/external/jsonhpp/nlohmann/byte_container_with_subtype.hpp
 include src/external/jsonhpp/nlohmann/detail/conversions/from_json.hpp
 include src/external/jsonhpp/nlohmann/detail/conversions/to_chars.hpp
 include src/external/jsonhpp/nlohmann/detail/conversions/to_json.hpp
 include src/external/jsonhpp/nlohmann/detail/exceptions.hpp
@@ -113,25 +148,26 @@
 include src/external/jsonhpp/nlohmann/ordered_map.hpp
 include src/external/jsonhpp/nlohmann/thirdparty/hedley/hedley.hpp
 include src/external/jsonhpp/nlohmann/thirdparty/hedley/hedley_undef.hpp
 include src/external/jsteemann/LICENSE
 include src/external/jsteemann/README.md
 include src/external/jsteemann/atoi.h
 include src/external/jsteemann/modification.md
-include src/external/mapbox/variant/LICENSE
-include src/external/mapbox/variant/LICENSE_1_0.txt
-include src/external/mapbox/variant/README.md
-include src/external/mapbox/variant/include/mapbox/optional.hpp
-include src/external/mapbox/variant/include/mapbox/recursive_wrapper.hpp
-include src/external/mapbox/variant/include/mapbox/variant.hpp
-include src/external/mapbox/variant/include/mapbox/variant_cast.hpp
-include src/external/mapbox/variant/include/mapbox/variant_io.hpp
-include src/external/mapbox/variant/include/mapbox/variant_visitor.hpp
+include src/external/linalg.README
+include src/external/linalg.UNLICENSE
+include src/external/linalg.h
 include src/external/miniz.c
 include src/external/miniz.h
+include src/external/mapbox/eternal/LICENSE.md
+include src/external/mapbox/eternal/README.md
+include src/external/mapbox/eternal/include/mapbox/eternal.hpp
+include src/external/mapbox/earcut/CHANGELOG.md
+include src/external/mapbox/earcut/earcut.hpp
+include src/external/mapbox/earcut/LICENSE
+include src/external/mapbox/earcut/README.md
 include src/external/nanobind/CMakeLists.txt
 include src/external/nanobind/LICENSE
 include src/external/nanobind/README.md
 include src/external/nanobind/cmake/nanobind-config.cmake
 include src/external/nanobind/ext/robin_map/CMakeLists.txt
 include src/external/nanobind/ext/robin_map/LICENSE
 include src/external/nanobind/ext/robin_map/README.md
@@ -186,41 +222,28 @@
 include src/external/nanobind/src/nb_func.cpp
 include src/external/nanobind/src/nb_internals.cpp
 include src/external/nanobind/src/nb_internals.h
 include src/external/nanobind/src/nb_type.cpp
 include src/external/nanobind/src/tensor.cpp
 include src/external/nanobind/src/trampoline.cpp
 include src/external/ogt_vox.h
-include src/external/ryu/LICENSE-Boost
-include src/external/ryu/README.md
-include src/external/ryu/ryu/common.h
-include src/external/ryu/ryu/d2fixed_full_table.h
-include src/external/ryu/ryu/d2s.c
-include src/external/ryu/ryu/d2s_full_table.h
-include src/external/ryu/ryu/d2s_intrinsics.h
-include src/external/ryu/ryu/d2s_small_table.h
-include src/external/ryu/ryu/digit_table.h
-include src/external/ryu/ryu/f2s.c
-include src/external/ryu/ryu/f2s_full_table.h
-include src/external/ryu/ryu/f2s_intrinsics.h
-include src/external/ryu/ryu/generic_128.h
-include src/external/ryu/ryu/ryu.h
-include src/external/ryu/ryu/ryu_generic_128.h
-include src/external/ryu/ryu/ryu_parse.h
-include src/external/ryu/ryu/s2d.c
-include src/external/ryu/ryu/s2f.c
+include src/external/pystring.cpp
+include src/external/pystring.h
+include src/external/pystring.LICENSE
 include src/external/simple_match/LICENSE_1_0.txt
 include src/external/simple_match/README.md
 include src/external/simple_match/include/simple_match/implementation/some_none.hpp
 include src/external/simple_match/include/simple_match/simple_match.hpp
 include src/external/simple_match/include/simple_match/utility.hpp
 include src/external/staticstruct.cc
 include src/external/staticstruct.hh
 include src/external/stb_image.h
+include src/external/stb_image_resize.h
 include src/external/stb_image_write.h
+include src/external/stb_truetype.h
 include src/external/string_id/LICENSE
 include src/external/string_id/README.md
 include src/external/string_id/README.mod.txt
 include src/external/string_id/basic_database.hpp
 include src/external/string_id/config.hpp
 include src/external/string_id/config.hpp.in
 include src/external/string_id/config_impl.hpp
@@ -229,35 +252,65 @@
 include src/external/string_id/error.cpp
 include src/external/string_id/error.hpp
 include src/external/string_id/generator.cpp
 include src/external/string_id/generator.hpp
 include src/external/string_id/hash.hpp
 include src/external/string_id/string_id.cpp
 include src/external/string_id/string_id.hpp
+include src/external/tiny-color-io.h
+include src/external/tinycolorio.LICENSE
 include src/external/tiny_dng_loader.h
 include src/external/tiny_dng_writer.h
 include src/external/tiny_gltf.cc
 include src/external/tiny_gltf.h
 include src/external/tiny_obj_loader.cc
 include src/external/tiny_obj_loader.h
 include src/external/tinyexr.cc
 include src/external/tinyexr.h
 include src/external/tinyxml2/LICENSE.txt
 include src/external/tinyxml2/readme.md
 include src/external/tinyxml2/tinyxml2.cpp
 include src/external/tinyxml2/tinyxml2.h
+include src/external/floaxie/README.md
+include src/external/floaxie/LICENSE
+include src/external/floaxie/floaxie/atof.h
+include src/external/floaxie/floaxie/bit_ops.h
+include src/external/floaxie/floaxie/cached_power.h
+include src/external/floaxie/floaxie/conversion_status.h
+include src/external/floaxie/floaxie/default_fallback.h
+include src/external/floaxie/floaxie/diy_fp.h
+include src/external/floaxie/floaxie/fraction.h
+include src/external/floaxie/floaxie/ftoa.h
+include src/external/floaxie/floaxie/grisu.h
+include src/external/floaxie/floaxie/huge_val.h
+include src/external/floaxie/floaxie/integer_of_size.h
+include src/external/floaxie/floaxie/k_comp.h
+include src/external/floaxie/floaxie/krosh.h
+include src/external/floaxie/floaxie/memwrap.h
+include src/external/floaxie/floaxie/powers_ten.h
+include src/external/floaxie/floaxie/powers_ten_double.h
+include src/external/floaxie/floaxie/powers_ten_single.h
+include src/external/floaxie/floaxie/prettify.h
+include src/external/floaxie/floaxie/print.h
+include src/external/floaxie/floaxie/static_pow.h
+include src/external/floaxie/floaxie/type_punning_cast.h
+include src/handle-allocator.hh
 include src/image-loader.cc
 include src/image-loader.hh
 include src/image-types.hh
+include src/image-util.cc
+include src/image-util.hh
 include src/image-writer.cc
 include src/image-writer.hh
 include src/integerCoding.cpp
 include src/integerCoding.h
 include src/io-util.cc
 include src/io-util.hh
+include src/linear-algebra.cc
+include src/linear-algebra.hh
 include src/lz4-compression.cc
 include src/lz4-compression.hh
 include src/math-util.inc
 include src/nonstd/expected.hpp
 include src/nonstd/optional.hpp
 include src/osd/CMakeLists.txt
 include src/osd/LICENSE.txt
@@ -468,62 +521,94 @@
 include src/osd/opensubdiv/vtr/refinement.h
 include src/osd/opensubdiv/vtr/sparseSelector.cpp
 include src/osd/opensubdiv/vtr/sparseSelector.h
 include src/osd/opensubdiv/vtr/stackBuffer.h
 include src/osd/opensubdiv/vtr/triRefinement.cpp
 include src/osd/opensubdiv/vtr/triRefinement.h
 include src/osd/opensubdiv/vtr/types.h
+include src/path-util.cc
 include src/path-util.hh
+include src/performance.cc
+include src/performance.hh
 include src/pprinter.cc
 include src/pprinter.hh
+include src/prim-composition.cc
+include src/prim-composition.hh
+include src/prim-pprint.hh
+include src/prim-reconstruct.cc
+include src/prim-reconstruct.hh
 include src/prim-types.cc
 include src/prim-types.hh
 include src/primvar.cc
 include src/primvar.hh
 include src/pxr-compat.cc
 include src/pxr-compat.hh
-include src/pxrLZ4/README.md
-include src/pxrLZ4/lz4.cpp
-include src/pxrLZ4/lz4.h
+include src/lz4/LICENSE
+include src/lz4/lz4.c
+include src/lz4/lz4.h
 include src/python-bindings.cc
 include src/str-util.hh
+include src/str-util.cc
 include src/stream-reader.hh
 include src/stream-writer.hh
 include src/subdiv.cc
 include src/subdiv.hh
+include src/stage.cc
+include src/stage.hh
 include src/texture-types.hh
 include src/tiny-any.inc
-include src/tiny-variant.hh
+include src/tiny-format.cc
+include src/tiny-format.hh
 include src/tinyusdz.cc
 include src/tinyusdz.hh
+include src/tiny-variant.hh
 include src/token-type.hh
 include src/tydra/README.md
+include src/tydra/prim-apply.cc
+include src/tydra/prim-apply.hh
 include src/tydra/render-data.cc
 include src/tydra/render-data.hh
-include src/tydra/texture-loader.hh
+include src/tydra/scene-access.cc
+include src/tydra/scene-access.hh
+include src/tydra/shader-network.cc
+include src/tydra/shader-network.hh
 include src/usd-to-json.cc
 include src/usd-to-json.hh
 include src/usdGeom.cc
 include src/usdGeom.hh
 include src/usdLux.cc
 include src/usdLux.hh
 include src/usdMtlx.cc
 include src/usdMtlx.hh
 include src/usdObj.cc
 include src/usdObj.hh
 include src/usdShade.cc
 include src/usdShade.hh
+include src/usdSkel.cc
+include src/usdSkel.hh
 include src/usdVox.cc
 include src/usdVox.hh
 include src/usda-reader.cc
 include src/usda-reader.hh
 include src/usda-writer.cc
 include src/usda-writer.hh
 include src/usdc-reader.cc
 include src/usdc-reader.hh
 include src/usdc-writer.cc
 include src/usdc-writer.hh
+include src/value-eval-util.hh
 include src/value-pprint.cc
 include src/value-pprint.hh
 include src/value-types.cc
 include src/value-types.hh
+include src/value-type-macros.inc
+include src/xform.hh
+include src/xform.cc
+include src/audio-loader.cc
+include src/audio-loader.hh
+include src/external/OpenFBX/LICENSE
+include src/external/OpenFBX/README.md
+include src/external/OpenFBX/src/ofbx.cpp
+include src/external/OpenFBX/src/ofbx.h
+include src/usdFbx.cc
+include src/usdFbx.hh
 recursive-include src/external/pybind11 *
```

### Comparing `tinyusdz-0.8.0rc0/cmake/ClangClCMakeCompileRules.cmake` & `tinyusdz-0.8.0rc1/cmake/ClangClCMakeCompileRules.cmake`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/cmake/clang-cl-msvc-windows.cmake` & `tinyusdz-0.8.0rc1/cmake/clang-cl-msvc-windows.cmake`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/cmake/clang-cl-msvc-wsl.cmake` & `tinyusdz-0.8.0rc1/cmake/clang-cl-msvc-wsl.cmake`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/cmake/ios.toolchain.cmake` & `tinyusdz-0.8.0rc1/cmake/ios.toolchain.cmake`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/cmake/llvm-mingw-cross.cmake` & `tinyusdz-0.8.0rc1/cmake/llvm-mingw-cross.cmake`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/cmake/llvm-mingw-win64.cmake` & `tinyusdz-0.8.0rc1/cmake/llvm-mingw-win64.cmake`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/cmake/mingw64-cross.cmake` & `tinyusdz-0.8.0rc1/cmake/mingw64-cross.cmake`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/cmake/sanitizers/FindASan.cmake` & `tinyusdz-0.8.0rc1/cmake/sanitizers/FindASan.cmake`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/cmake/sanitizers/FindMSan.cmake` & `tinyusdz-0.8.0rc1/cmake/sanitizers/FindMSan.cmake`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/cmake/sanitizers/FindSanitizers.cmake` & `tinyusdz-0.8.0rc1/cmake/sanitizers/FindSanitizers.cmake`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/cmake/sanitizers/FindTSan.cmake` & `tinyusdz-0.8.0rc1/cmake/sanitizers/FindTSan.cmake`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/cmake/sanitizers/FindUBSan.cmake` & `tinyusdz-0.8.0rc1/cmake/sanitizers/FindUBSan.cmake`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/cmake/sanitizers/asan-wrapper` & `tinyusdz-0.8.0rc1/cmake/sanitizers/asan-wrapper`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/cmake/sanitizers/sanitize-helpers.cmake` & `tinyusdz-0.8.0rc1/cmake/sanitizers/sanitize-helpers.cmake`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/doc/docs/index.md` & `tinyusdz-0.8.0rc1/doc/docs/index.md`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/doc/preview_surface.md` & `tinyusdz-0.8.0rc1/doc/preview_surface.md`

 * *Files 11% similar despite different names*

```diff
@@ -1,11 +1,13 @@
 # PreviewSurface
 
 https://graphics.pixar.com/usd/docs/UsdPreviewSurface-Proposal.html 
 
+https://github.com/PixarAnimationStudios/USD/blob/release/pxr/usdImaging/plugin/usdShaders/shaders/shaderDefs.usda
+
 ## Inputs
 
 * diffuseColor - color3f - (0.18, 0.18, 0.18)
 * emissiveColor - color3f - (0.0, 0.0, 0.0)
 * useSpeclarWorkflow - int - 0
   * 1
     * specularColor - color3f - (0.0, 0.0, 0.0)
```

### Comparing `tinyusdz-0.8.0rc0/doc/prim_format.md` & `tinyusdz-0.8.0rc1/doc/prim_format.md`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/doc/usdObj.md` & `tinyusdz-0.8.0rc1/doc/usdObj.md`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/doc/usdc_format.md` & `tinyusdz-0.8.0rc1/doc/usdc_format.md`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/doc/usdz_note.md` & `tinyusdz-0.8.0rc1/doc/usdz_note.md`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/python/tinyusdz.egg-info/SOURCES.txt` & `tinyusdz-0.8.0rc1/python/tinyusdz.egg-info/SOURCES.txt`

 * *Files 13% similar despite different names*

```diff
@@ -29,189 +29,234 @@
 doc/prim_format.md
 doc/usdObj.md
 doc/usd_sourcecode_tour.md
 doc/usdc_format.md
 doc/usdz_note.md
 doc/docs/index.md
 python/README.md
+python/ctusd_test.py
 python/test.py
-python/tinyusdz/test.py
-python/tinyusdz/tmp.py
+python/tutorial.py
+python/tutorial_001.py
+python/pxr_compat/Usd/__init__.py
+python/pxr_compat/Usd/Stage/__init__.py
+python/pxr_compat/UsdGeom/Tokens.py
+python/pxr_compat/UsdGeom/__init__.py
+python/tinyusdz/__init__.py
+python/tinyusdz/version.py
 python/tinyusdz.egg-info/PKG-INFO
 python/tinyusdz.egg-info/SOURCES.txt
 python/tinyusdz.egg-info/dependency_links.txt
 python/tinyusdz.egg-info/top_level.txt
-python/tinyusdz/Usd/__init__.py
-python/tinyusdz/Usd/Stage/__init__.py
-python/tinyusdz/UsdGeom/Tokens.py
-python/tinyusdz/UsdGeom/__init__.py
-python/tinyusdz/UsdGeom/tmp.py
+src/ascii-parser-basetype.cc
+src/ascii-parser-timesamples-array.cc
+src/ascii-parser-timesamples.cc
 src/ascii-parser.cc
 src/ascii-parser.hh
+src/asset-resolution.cc
+src/asset-resolution.hh
+src/audio-loader.cc
+src/audio-loader.hh
 src/c-tinyusd.cc
 src/c-tinyusd.h
 src/common-macros.inc
+src/composition.hh
 src/crate-format.cc
 src/crate-format.hh
 src/crate-pprint.cc
 src/crate-pprint.hh
 src/crate-reader.cc
 src/crate-reader.hh
 src/crate-writer.cc
 src/crate-writer.hh
 src/define-type-trait.inc
+src/handle-allocator.hh
 src/image-loader.cc
 src/image-loader.hh
 src/image-types.hh
+src/image-util.cc
+src/image-util.hh
 src/image-writer.cc
 src/image-writer.hh
 src/integerCoding.cpp
 src/integerCoding.h
 src/io-util.cc
 src/io-util.hh
+src/linear-algebra.cc
+src/linear-algebra.hh
 src/lz4-compression.cc
 src/lz4-compression.hh
 src/math-util.inc
+src/path-util.cc
 src/path-util.hh
+src/performance.cc
+src/performance.hh
 src/pprinter.cc
 src/pprinter.hh
+src/prim-composition.cc
+src/prim-pprint.hh
+src/prim-reconstruct.cc
+src/prim-reconstruct.hh
 src/prim-types.cc
 src/prim-types.hh
 src/primvar.cc
 src/primvar.hh
 src/pxr-compat.cc
 src/pxr-compat.hh
 src/python-bindings.cc
+src/stage.cc
+src/stage.hh
+src/str-util.cc
 src/str-util.hh
 src/stream-reader.hh
 src/stream-writer.hh
 src/subdiv.cc
 src/subdiv.hh
 src/texture-types.hh
 src/tiny-any.inc
+src/tiny-format.cc
+src/tiny-format.hh
 src/tiny-variant.hh
 src/tinyusdz.cc
 src/tinyusdz.hh
 src/token-type.hh
 src/usd-to-json.cc
 src/usd-to-json.hh
+src/usdFbx.cc
+src/usdFbx.hh
 src/usdGeom.cc
 src/usdGeom.hh
 src/usdLux.cc
 src/usdLux.hh
 src/usdMtlx.cc
 src/usdMtlx.hh
 src/usdObj.cc
 src/usdObj.hh
 src/usdShade.cc
 src/usdShade.hh
+src/usdSkel.cc
+src/usdSkel.hh
 src/usdVox.cc
 src/usdVox.hh
 src/usda-reader.cc
 src/usda-reader.hh
 src/usda-writer.cc
 src/usda-writer.hh
 src/usdc-reader.cc
 src/usdc-reader.hh
 src/usdc-writer.cc
 src/usdc-writer.hh
+src/value-eval-util.hh
 src/value-pprint.cc
 src/value-pprint.hh
+src/value-type-macros.inc
 src/value-types.cc
 src/value-types.hh
+src/xform.cc
+src/xform.hh
 src/external/LICENSE.miniz
 src/external/LICENSE.ogt_vox.md
 src/external/README.fpng.md
 src/external/dr_mp3.h
 src/external/dr_wav.h
+src/external/dtoa_milo.LICENSE
+src/external/dtoa_milo.h
 src/external/fpng.cpp
 src/external/fpng.h
+src/external/linalg.README
+src/external/linalg.UNLICENSE
+src/external/linalg.h
 src/external/miniz.c
 src/external/miniz.h
 src/external/ogt_vox.h
+src/external/pystring.LICENSE
+src/external/pystring.cpp
+src/external/pystring.h
 src/external/staticstruct.cc
 src/external/staticstruct.hh
 src/external/stb_image.h
+src/external/stb_image_resize.h
 src/external/stb_image_write.h
+src/external/stb_truetype.h
+src/external/tiny-color-io.h
 src/external/tiny_dng_loader.h
 src/external/tiny_dng_writer.h
 src/external/tiny_gltf.cc
 src/external/tiny_gltf.h
 src/external/tiny_obj_loader.cc
 src/external/tiny_obj_loader.h
+src/external/tinycolorio.LICENSE
 src/external/tinyexr.cc
 src/external/tinyexr.h
-src/external/better-enums/LICENSE.md
-src/external/better-enums/README.md
-src/external/better-enums/enum.h
+src/external/OpenFBX/LICENSE
+src/external/OpenFBX/README.md
+src/external/OpenFBX/src/ofbx.cpp
+src/external/OpenFBX/src/ofbx.h
 src/external/fast_float/LICENSE-APACHE
 src/external/fast_float/LICENSE-MIT
 src/external/fast_float/README.md
 src/external/fast_float/include/fast_float/ascii_number.h
 src/external/fast_float/include/fast_float/bigint.h
 src/external/fast_float/include/fast_float/decimal_to_binary.h
 src/external/fast_float/include/fast_float/digit_comparison.h
 src/external/fast_float/include/fast_float/fast_float.h
 src/external/fast_float/include/fast_float/fast_table.h
 src/external/fast_float/include/fast_float/float_common.h
 src/external/fast_float/include/fast_float/parse_number.h
 src/external/fast_float/include/fast_float/simple_decimal_conversion.h
+src/external/filesystem/LICENSE
+src/external/filesystem/README.md
+src/external/filesystem/include/ghc/filesystem.hpp
+src/external/filesystem/include/ghc/fs_fwd.hpp
+src/external/filesystem/include/ghc/fs_impl.hpp
+src/external/filesystem/include/ghc/fs_std.hpp
+src/external/filesystem/include/ghc/fs_std_fwd.hpp
+src/external/filesystem/include/ghc/fs_std_impl.hpp
+src/external/floaxie/LICENSE
+src/external/floaxie/README.md
+src/external/floaxie/floaxie/atof.h
+src/external/floaxie/floaxie/bit_ops.h
+src/external/floaxie/floaxie/cached_power.h
+src/external/floaxie/floaxie/conversion_status.h
+src/external/floaxie/floaxie/default_fallback.h
+src/external/floaxie/floaxie/diy_fp.h
+src/external/floaxie/floaxie/fraction.h
+src/external/floaxie/floaxie/ftoa.h
+src/external/floaxie/floaxie/grisu.h
+src/external/floaxie/floaxie/huge_val.h
+src/external/floaxie/floaxie/integer_of_size.h
+src/external/floaxie/floaxie/k_comp.h
+src/external/floaxie/floaxie/krosh.h
+src/external/floaxie/floaxie/memwrap.h
+src/external/floaxie/floaxie/powers_ten.h
+src/external/floaxie/floaxie/powers_ten_double.h
+src/external/floaxie/floaxie/powers_ten_single.h
+src/external/floaxie/floaxie/prettify.h
+src/external/floaxie/floaxie/print.h
+src/external/floaxie/floaxie/static_pow.h
+src/external/floaxie/floaxie/type_punning_cast.h
+src/external/glob/LICENSE
+src/external/glob/README.md
+src/external/glob/include/glob/glob.h
+src/external/glob/single_include/glob/glob.hpp
+src/external/glob/source/glob.cpp
 src/external/jsonhpp/LICENSE.MIT
-src/external/jsonhpp/nlohmann/adl_serializer.hpp
-src/external/jsonhpp/nlohmann/byte_container_with_subtype.hpp
 src/external/jsonhpp/nlohmann/json.hpp
 src/external/jsonhpp/nlohmann/json_fwd.hpp
-src/external/jsonhpp/nlohmann/ordered_map.hpp
-src/external/jsonhpp/nlohmann/detail/exceptions.hpp
-src/external/jsonhpp/nlohmann/detail/hash.hpp
-src/external/jsonhpp/nlohmann/detail/json_pointer.hpp
-src/external/jsonhpp/nlohmann/detail/json_ref.hpp
-src/external/jsonhpp/nlohmann/detail/macro_scope.hpp
-src/external/jsonhpp/nlohmann/detail/macro_unscope.hpp
-src/external/jsonhpp/nlohmann/detail/string_escape.hpp
-src/external/jsonhpp/nlohmann/detail/value_t.hpp
-src/external/jsonhpp/nlohmann/detail/conversions/from_json.hpp
-src/external/jsonhpp/nlohmann/detail/conversions/to_chars.hpp
-src/external/jsonhpp/nlohmann/detail/conversions/to_json.hpp
-src/external/jsonhpp/nlohmann/detail/input/binary_reader.hpp
-src/external/jsonhpp/nlohmann/detail/input/input_adapters.hpp
-src/external/jsonhpp/nlohmann/detail/input/json_sax.hpp
-src/external/jsonhpp/nlohmann/detail/input/lexer.hpp
-src/external/jsonhpp/nlohmann/detail/input/parser.hpp
-src/external/jsonhpp/nlohmann/detail/input/position_t.hpp
-src/external/jsonhpp/nlohmann/detail/iterators/internal_iterator.hpp
-src/external/jsonhpp/nlohmann/detail/iterators/iter_impl.hpp
-src/external/jsonhpp/nlohmann/detail/iterators/iteration_proxy.hpp
-src/external/jsonhpp/nlohmann/detail/iterators/iterator_traits.hpp
-src/external/jsonhpp/nlohmann/detail/iterators/json_reverse_iterator.hpp
-src/external/jsonhpp/nlohmann/detail/iterators/primitive_iterator.hpp
-src/external/jsonhpp/nlohmann/detail/meta/cpp_future.hpp
-src/external/jsonhpp/nlohmann/detail/meta/detected.hpp
-src/external/jsonhpp/nlohmann/detail/meta/identity_tag.hpp
-src/external/jsonhpp/nlohmann/detail/meta/is_sax.hpp
-src/external/jsonhpp/nlohmann/detail/meta/type_traits.hpp
-src/external/jsonhpp/nlohmann/detail/meta/void_t.hpp
-src/external/jsonhpp/nlohmann/detail/output/binary_writer.hpp
-src/external/jsonhpp/nlohmann/detail/output/output_adapters.hpp
-src/external/jsonhpp/nlohmann/detail/output/serializer.hpp
-src/external/jsonhpp/nlohmann/thirdparty/hedley/hedley.hpp
-src/external/jsonhpp/nlohmann/thirdparty/hedley/hedley_undef.hpp
 src/external/jsteemann/LICENSE
 src/external/jsteemann/README.md
 src/external/jsteemann/atoi.h
 src/external/jsteemann/modification.md
-src/external/mapbox/variant/LICENSE
-src/external/mapbox/variant/LICENSE_1_0.txt
-src/external/mapbox/variant/README.md
-src/external/mapbox/variant/include/mapbox/optional.hpp
-src/external/mapbox/variant/include/mapbox/recursive_wrapper.hpp
-src/external/mapbox/variant/include/mapbox/variant.hpp
-src/external/mapbox/variant/include/mapbox/variant_cast.hpp
-src/external/mapbox/variant/include/mapbox/variant_io.hpp
-src/external/mapbox/variant/include/mapbox/variant_visitor.hpp
+src/external/mapbox/earcut/CHANGELOG.md
+src/external/mapbox/earcut/LICENSE
+src/external/mapbox/earcut/README.md
+src/external/mapbox/earcut/earcut.hpp
+src/external/mapbox/eternal/LICENSE.md
+src/external/mapbox/eternal/README.md
+src/external/mapbox/eternal/include/mapbox/eternal.hpp
 src/external/nanobind/CMakeLists.txt
 src/external/nanobind/LICENSE
 src/external/nanobind/README.md
 src/external/nanobind/cmake/nanobind-config.cmake
 src/external/nanobind/ext/robin_map/CMakeLists.txt
 src/external/nanobind/ext/robin_map/LICENSE
 src/external/nanobind/ext/robin_map/README.md
@@ -309,32 +354,14 @@
 src/external/pybind11/tools/pybind11Common.cmake
 src/external/pybind11/tools/pybind11Config.cmake.in
 src/external/pybind11/tools/pybind11NewTools.cmake
 src/external/pybind11/tools/pybind11Tools.cmake
 src/external/pybind11/tools/pyproject.toml
 src/external/pybind11/tools/setup_global.py.in
 src/external/pybind11/tools/setup_main.py.in
-src/external/ryu/LICENSE-Boost
-src/external/ryu/README.md
-src/external/ryu/ryu/common.h
-src/external/ryu/ryu/d2fixed_full_table.h
-src/external/ryu/ryu/d2s.c
-src/external/ryu/ryu/d2s_full_table.h
-src/external/ryu/ryu/d2s_intrinsics.h
-src/external/ryu/ryu/d2s_small_table.h
-src/external/ryu/ryu/digit_table.h
-src/external/ryu/ryu/f2s.c
-src/external/ryu/ryu/f2s_full_table.h
-src/external/ryu/ryu/f2s_intrinsics.h
-src/external/ryu/ryu/generic_128.h
-src/external/ryu/ryu/ryu.h
-src/external/ryu/ryu/ryu_generic_128.h
-src/external/ryu/ryu/ryu_parse.h
-src/external/ryu/ryu/s2d.c
-src/external/ryu/ryu/s2f.c
 src/external/simple_match/LICENSE_1_0.txt
 src/external/simple_match/README.md
 src/external/simple_match/include/simple_match/simple_match.hpp
 src/external/simple_match/include/simple_match/utility.hpp
 src/external/simple_match/include/simple_match/implementation/some_none.hpp
 src/external/string_id/LICENSE
 src/external/string_id/README.md
@@ -352,14 +379,17 @@
 src/external/string_id/hash.hpp
 src/external/string_id/string_id.cpp
 src/external/string_id/string_id.hpp
 src/external/tinyxml2/LICENSE.txt
 src/external/tinyxml2/readme.md
 src/external/tinyxml2/tinyxml2.cpp
 src/external/tinyxml2/tinyxml2.h
+src/lz4/LICENSE
+src/lz4/lz4.c
+src/lz4/lz4.h
 src/nonstd/expected.hpp
 src/nonstd/optional.hpp
 src/osd/CMakeLists.txt
 src/osd/LICENSE.txt
 src/osd/README.md
 src/osd/opensubdiv/CMakeLists.txt
 src/osd/opensubdiv/version.cpp
@@ -567,14 +597,16 @@
 src/osd/opensubdiv/vtr/refinement.h
 src/osd/opensubdiv/vtr/sparseSelector.cpp
 src/osd/opensubdiv/vtr/sparseSelector.h
 src/osd/opensubdiv/vtr/stackBuffer.h
 src/osd/opensubdiv/vtr/triRefinement.cpp
 src/osd/opensubdiv/vtr/triRefinement.h
 src/osd/opensubdiv/vtr/types.h
-src/pxrLZ4/README.md
-src/pxrLZ4/lz4.cpp
-src/pxrLZ4/lz4.h
 src/tydra/README.md
+src/tydra/prim-apply.cc
+src/tydra/prim-apply.hh
 src/tydra/render-data.cc
 src/tydra/render-data.hh
-src/tydra/texture-loader.hh
+src/tydra/scene-access.cc
+src/tydra/scene-access.hh
+src/tydra/shader-network.cc
+src/tydra/shader-network.hh
```

### Comparing `tinyusdz-0.8.0rc0/setup.py` & `tinyusdz-0.8.0rc1/setup.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,15 +2,16 @@
 import pathlib
 
 # skbuild = python setuptools with Cmake support
 from skbuild import setup
 
 setup(
     name='tinyusdz',
-    version='0.8.0rc0',
+    version='0.8.0rc1',
     author='Light Transport Entertainment Inc.',
     author_email='lighttransport.eth@mail3.me',
     package_dir={'tinyusdz': 'python'}, # Use `python` folder 
-    cmake_args=['-DTINYUSDZ_WITH_PYTHON=1', '-DTINYUSDZ_BUILD_EXAMPLES=Off', '-DTINYUSDZ_BUILD_TESTS=Off', '-DTINYUSDZ_WITH_TOOL_USDA_PARSER=Off'],
+    cmake_args=['-DTINYUSDZ_WITH_PYTHON=1', '-DTINYUSDZ_BUILD_EXAMPLES=Off', '-DTINYUSDZ_BUILD_TESTS=Off', '-DTINYUSDZ_WITH_TOOL_USDA_PARSER=Off', '-DTINYUSDZ_WITH_TOOL_USDC_PARSER=Off'],
     long_description=open("./python/README.md", 'r').read(),
+    long_description_content_type='text/markdown',
     license='MIT',
 )
```

### Comparing `tinyusdz-0.8.0rc0/src/ascii-parser.cc` & `tinyusdz-0.8.0rc1/src/ascii-parser.cc`

 * *Files 22% similar despite different names*

```diff
@@ -1,59 +1,60 @@
-// SPDX-License-Identifier: MIT
-// Copyright 2021 - Present, Syoyo Fujita.
+// SPDX-License-Identifier: Apache 2.0
+// Copyright 2021 - 2022, Syoyo Fujita.
+// Copyright 2023 - Present, Light Transport Entertainment, Inc.
 //
-// TODO:
-//   - [ ] List-up TODOs :-)
+// To reduce compilation time and sections generated in .obj(object file),
+// We split implementaion to multiple of .cc for ascii-parser.hh
 
 #ifdef _MSC_VER
 #ifndef NOMINMAX
 #define NOMINMAX
 #endif
 #endif
-
+//
+#include <cstdio>
 #include <algorithm>
 #include <atomic>
-#include <cassert>
+//#include <cassert>
 #include <cstdlib>
 #include <fstream>
 #include <iostream>
 #include <iterator>
 #include <map>
 #include <set>
 #include <sstream>
 #include <stack>
 #if defined(__wasi__)
 #else
-#include <thread>
 #include <mutex>
+#include <thread>
 #endif
 #include <vector>
 
 #include "ascii-parser.hh"
 #include "str-util.hh"
+#include "path-util.hh"
+#include "tiny-format.hh"
 
 //
 #if !defined(TINYUSDZ_DISABLE_MODULE_USDA_READER)
 
 //
 
 #ifdef __clang__
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Weverything"
 #endif
 
 // external
-//#include "ryu/ryu.h"
-//#include "ryu/ryu_parse.h"
 
-#include "external/jsteemann/atoi.h"
-#include "fast_float/fast_float.h"
+//#include "external/fast_float/include/fast_float/fast_float.h"
+//#include "external/jsteemann/atoi.h"
+//#include "external/simple_match/include/simple_match/simple_match.hpp"
 #include "nonstd/expected.hpp"
-#include "simple_match/simple_match.hpp"
-//#include "nonstd/optional.hpp"
 
 //
 
 #ifdef __clang__
 #pragma clang diagnostic pop
 #endif
 
@@ -69,257 +70,404 @@
 #include "prim-types.hh"
 #include "str-util.hh"
 #include "stream-reader.hh"
 #include "tinyusdz.hh"
 #include "value-pprint.hh"
 #include "value-types.hh"
 
+#if 0
 // s = std::string
 #define PUSH_ERROR_AND_RETURN(s)                                     \
   do {                                                               \
     std::ostringstream ss_e;                                         \
     ss_e << __FILE__ << ":" << __func__ << "():" << __LINE__ << " "; \
     ss_e << s;                                                       \
     PushError(ss_e.str());                                           \
     return false;                                                    \
   } while (0)
 
-#if 1
 #define PUSH_WARN(s)                                                 \
   do {                                                               \
     std::ostringstream ss_w;                                         \
     ss_w << __FILE__ << ":" << __func__ << "():" << __LINE__ << " "; \
     ss_w << s;                                                       \
     PushWarn(ss_w.str());                                            \
   } while (0)
 #endif
 
-#if 0
-#define SLOG_INFO                                                         \
-  do {                                                                    \
-    std::cout << __FILE__ << ":" << __func__ << "():" << __LINE__ << " "; \
-  } while (0);                                                            \
-  std::cout
-
-#define LOG_DEBUG(s)                                                     \
-  do {                                                                   \
-    std::ostringstream ss;                                               \
-    ss << "[debug] " << __FILE__ << ":" << __func__ << "():" << __LINE__ \
-       << " ";                                                           \
-    ss << s;                                                             \
-    std::cout << ss.str() << "\n";                                       \
-  } while (0)
-
-#define LOG_INFO(s)                                                     \
-  do {                                                                  \
-    std::ostringstream ss;                                              \
-    ss << "[info] " << __FILE__ << ":" << __func__ << "():" << __LINE__ \
-       << " ";                                                          \
-    ss << s;                                                            \
-    std::cout << ss.str() << "\n";                                      \
-  } while (0)
-
-#define LOG_WARN(s)                                                     \
-  do {                                                                  \
-    std::ostringstream ss;                                              \
-    ss << "[warn] " << __FILE__ << ":" << __func__ << "():" << __LINE__ \
-       << " ";                                                          \
-    std::cout << ss.str() << "\n";                                      \
-  } while (0)
-
-#define LOG_ERROR(s)                                                     \
-  do {                                                                   \
-    std::ostringstream ss;                                               \
-    ss << "[error] " << __FILE__ << ":" << __func__ << "():" << __LINE__ \
-       << " ";                                                           \
-    std::cerr << s;                                                      \
-  } while (0)
-
-#define LOG_FATAL(s)                                               \
-  do {                                                             \
-    std::ostringstream ss;                                         \
-    ss << __FILE__ << ":" << __func__ << "():" << __LINE__ << " "; \
-    std::cerr << s;                                                \
-    std::exit(-1);                                                 \
-  } while (0)
-#endif
-
 #include "common-macros.inc"
 
 namespace tinyusdz {
 
 namespace ascii {
 
-// T = better-enum class
-template<typename T>
-std::string enum_join(const std::string &sep)
-{
-  std::ostringstream ss;
-
-  // quote with "
-  ss << quote(T::_names()[0], "\"");
-
-  for (size_t i = 1; i < T::_size(); i++) {
-    ss << sep << quote(T::_names()[i], "\"");
-  }
-
-  return ss.str();
-}
-
-struct Identifier : std::string {
-  // using std::string;
-};
-
-struct PathIdentifier : std::string {
-  // using std::string;
-};
+constexpr auto kRel = "rel";
+constexpr auto kTimeSamplesSuffix = ".timeSamples";
+constexpr auto kConnectSuffix = ".connect";
+
+constexpr auto kAscii = "[ASCII]";
+
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<bool>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<int32_t>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::int2>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::int3>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::int4>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<uint32_t>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::uint2>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::uint3>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::uint4>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<int64_t>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<uint64_t>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::half>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::half2>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::half3>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::half4>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<float>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::float2>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::float3>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::float4>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<double>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::double2>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::double3>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::double4>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::quath>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::quatf>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::quatd>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::texcoord2h>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::texcoord2f>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::texcoord2d>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::texcoord3h>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::texcoord3f>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::texcoord3d>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::point3h>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::point3f>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::point3d>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::normal3h>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::normal3f>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::normal3d>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::vector3h>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::vector3f>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::vector3d>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::color3h>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::color3f>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::color3d>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::color4h>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::color4f>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::color4d>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::matrix2d>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::matrix3d>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::matrix4d>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::token>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::StringData>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<std::string>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<Reference>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<Path>> *result);
+extern template bool AsciiParser::ParseBasicTypeArray(std::vector<nonstd::optional<value::AssetPath>> *result);
+
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<bool> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<int32_t> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::int2> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::int3> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::int4> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<uint32_t> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::uint2> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::uint3> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::uint4> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<int64_t> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<uint64_t> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::half> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::half2> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::half3> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::half4> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<float> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::float2> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::float3> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::float4> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<double> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::double2> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::double3> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::double4> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::quath> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::quatf> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::quatd> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::texcoord2h> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::texcoord2f> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::texcoord2d> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::texcoord3h> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::texcoord3f> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::texcoord3d> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::point3h> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::point3f> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::point3d> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::normal3h> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::normal3f> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::normal3d> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::vector3h> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::vector3f> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::vector3d> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::color3h> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::color3f> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::color3d> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::color4h> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::color4f> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::color4d> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::matrix2d> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::matrix3d> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::matrix4d> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::token> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::StringData> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<std::string> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<Reference> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<Path> *result);
+extern  template bool AsciiParser::ParseBasicTypeArray(std::vector<value::AssetPath> *result);
 
 static void RegisterStageMetas(
     std::map<std::string, AsciiParser::VariableDef> &metas) {
   metas.clear();
   metas["doc"] = AsciiParser::VariableDef(value::kString, "doc");
+  metas["documentation"] =
+      AsciiParser::VariableDef(value::kString, "doc");  // alias to 'doc'
+
+  metas["comment"] = AsciiParser::VariableDef(value::kString, "comment");
 
   // TODO: both support float and double?
   metas["metersPerUnit"] =
       AsciiParser::VariableDef(value::kDouble, "metersPerUnit");
   metas["timeCodesPerSecond"] =
       AsciiParser::VariableDef(value::kDouble, "timeCodesPerSecond");
+  metas["framesPerSecond"] =
+      AsciiParser::VariableDef(value::kDouble, "framesPerSecond");
+
+  metas["startTimeCode"] =
+      AsciiParser::VariableDef(value::kDouble, "startTimeCode");
+  metas["endTimeCode"] =
+      AsciiParser::VariableDef(value::kDouble, "endTimeCode");
 
-  metas["defaultPrim"] =
-      AsciiParser::VariableDef(value::kString, "defaultPrim");
-  metas["upAxis"] = AsciiParser::VariableDef(value::kString, "upAxis");
+  metas["defaultPrim"] = AsciiParser::VariableDef(value::kToken, "defaultPrim");
+  metas["upAxis"] = AsciiParser::VariableDef(value::kToken, "upAxis");
   metas["customLayerData"] =
       AsciiParser::VariableDef(value::kDictionary, "customLayerData");
 
   // Composition arc.
   // Type can be array. i.e. asset, asset[]
-  metas["subLayers"] = AsciiParser::VariableDef(value::kAssetPath, "subLayers");
-}
-
-// T = better-enums
-template<class T>
-class OneOf
-{
- public:
-  nonstd::expected<bool, std::string> operator()(const std::string &name) {
-    // strip double quotation.
-    std::string identifier = unwrap(name);
-
-    if (auto p = T::_from_string_nothrow(identifier.c_str())) {
-      return true;
-    }
+  metas["subLayers"] = AsciiParser::VariableDef(value::kAssetPath, "subLayers",
+                                                /* allow array type */ true);
 
-    std::string err_msg = "Must be one of " + enum_join<T>(", ") + " but got \"" + name + "\"";
+  // USDZ extension
+  metas["autoPlay"] = AsciiParser::VariableDef(value::kBool, "autoPlay");
+  metas["playbackMode"] = AsciiParser::VariableDef(value::kToken, "playbackMode");
 
-    return nonstd::make_unexpected(err_msg);
-  }
-};
+}
 
 static void RegisterPrimMetas(
     std::map<std::string, AsciiParser::VariableDef> &metas) {
   metas.clear();
 
-  metas["kind"] = AsciiParser::VariableDef(value::kString, "kind", OneOf<Kind>());
+  metas["kind"] = AsciiParser::VariableDef(value::kToken, "kind");
+  metas["doc"] = AsciiParser::VariableDef(value::kString, "doc");
+
+  //
+  // Composition arcs -----------------------
+  //
 
-  // Composition arcs
   // Type can be array. i.e. path, path[]
-  metas["references"] =
-      AsciiParser::VariableDef(value::kAssetPath, "references");
-  metas["inherits"] = AsciiParser::VariableDef(value::kAssetPath, "inherits");
-  metas["payload"] = AsciiParser::VariableDef(value::kAssetPath, "payload");
+  metas["references"] = AsciiParser::VariableDef("Reference", "references",
+                                                 /* allow array type */ true);
 
+  // TODO: Use relatioship type?
+  metas["inherits"] = AsciiParser::VariableDef(value::kPath, "inherits", true);
+  metas["payload"] = AsciiParser::VariableDef("Reference", "payload", true);
   metas["specializes"] =
-      AsciiParser::VariableDef(value::kRelationship, "specializes");
-  metas["variantSets"] =
-      AsciiParser::VariableDef(value::kDictionary, "variantSets");
+      AsciiParser::VariableDef(value::kPath, "specializes", true);
+
+  // Use `string`
+  metas["variantSets"] = AsciiParser::VariableDef(value::kString, "variantSets",
+                                                  /* allow array type */ true);
+
+  // Parse as dict. TODO: Use ParseVariants()
+  metas["variants"] = AsciiParser::VariableDef(value::kDictionary, "variants");
+
+  // ------------------------------------------
 
   metas["assetInfo"] =
       AsciiParser::VariableDef(value::kDictionary, "assetInfo");
   metas["customData"] =
       AsciiParser::VariableDef(value::kDictionary, "customData");
-  metas["variants"] = AsciiParser::VariableDef(value::kDictionary, "variants");
 
   metas["active"] = AsciiParser::VariableDef(value::kBool, "active");
+  metas["hidden"] = AsciiParser::VariableDef(value::kBool, "hidden");
+
+  // ListOp
+  metas["apiSchemas"] = AsciiParser::VariableDef(
+      value::Add1DArraySuffix(value::kToken), "apiSchemas");
+
+  // USDZ extension
+  metas["sceneName"] = AsciiParser::VariableDef(value::kString, "sceneName");
+
+  // Omniverse extension
+  // Builtin from pxrUSD 23.xx?
+  metas["displayName"] = AsciiParser::VariableDef(value::kString, "displayName");
+}
+
+static void RegisterPropMetas(
+    std::map<std::string, AsciiParser::VariableDef> &metas) {
+  metas.clear();
+
+  metas["doc"] = AsciiParser::VariableDef(value::kString, "doc");
+  metas["active"] = AsciiParser::VariableDef(value::kBool, "active");
+  metas["hidden"] = AsciiParser::VariableDef(value::kBool, "hidden");
+  metas["customData"] =
+      AsciiParser::VariableDef(value::kDictionary, "customData");
 
   // usdSkel
   metas["elementSize"] = AsciiParser::VariableDef(value::kInt, "elementSize");
 
- // ListOp
-  metas["apiSchemas"] = AsciiParser::VariableDef(
-      value::Add1DArraySuffix(value::kString), "apiSchemas");
+  // usdSkel?
+  metas["weight"] = AsciiParser::VariableDef(value::kDouble, "weight");
+
+  // usdShade?
+  metas["colorSpace"] = AsciiParser::VariableDef(value::kInt, "colorSpace");
+
+  metas["interpolation"] = AsciiParser::VariableDef(value::kToken, "interpolation");
+
+  metas["bindMaterialAs"] = AsciiParser::VariableDef(value::kToken, "bindMaterialAs");
 }
 
+
 static void RegisterPrimAttrTypes(std::set<std::string> &d) {
   d.clear();
 
   d.insert(value::kBool);
 
+  d.insert(value::kInt64);
+
   d.insert(value::kInt);
   d.insert(value::kInt2);
   d.insert(value::kInt3);
   d.insert(value::kInt4);
 
+  d.insert(value::kUInt64);
+
+  d.insert(value::kUInt);
+  d.insert(value::kUInt2);
+  d.insert(value::kUInt3);
+  d.insert(value::kUInt4);
+
   d.insert(value::kFloat);
   d.insert(value::kFloat2);
   d.insert(value::kFloat3);
   d.insert(value::kFloat4);
 
   d.insert(value::kDouble);
   d.insert(value::kDouble2);
   d.insert(value::kDouble3);
   d.insert(value::kDouble4);
 
+  d.insert(value::kHalf);
+  d.insert(value::kHalf2);
+  d.insert(value::kHalf3);
+  d.insert(value::kHalf4);
+
+  d.insert(value::kQuath);
+  d.insert(value::kQuatf);
+  d.insert(value::kQuatd);
+
   d.insert(value::kNormal3f);
   d.insert(value::kPoint3f);
+  d.insert(value::kTexCoord2h);
+  d.insert(value::kTexCoord3h);
+  d.insert(value::kTexCoord4h);
   d.insert(value::kTexCoord2f);
+  d.insert(value::kTexCoord3f);
+  d.insert(value::kTexCoord4f);
+  d.insert(value::kTexCoord2d);
+  d.insert(value::kTexCoord3d);
+  d.insert(value::kTexCoord4d);
   d.insert(value::kVector3f);
+  d.insert(value::kVector4f);
+  d.insert(value::kColor3h);
   d.insert(value::kColor3f);
+  d.insert(value::kColor3d);
+  d.insert(value::kColor4h);
+  d.insert(value::kColor4f);
+  d.insert(value::kColor4d);
 
   // It looks no `matrixNf` type for USDA
-  //d.insert(value::kMatrix2f);
-  //d.insert(value::kMatrix3f);
-  //d.insert(value::kMatrix4f);
+  // d.insert(value::kMatrix2f);
+  // d.insert(value::kMatrix3f);
+  // d.insert(value::kMatrix4f);
 
   d.insert(value::kMatrix2d);
   d.insert(value::kMatrix3d);
   d.insert(value::kMatrix4d);
 
   d.insert(value::kToken);
   d.insert(value::kString);
 
   d.insert(value::kRelationship);
   d.insert(value::kAssetPath);
 
   d.insert(value::kDictionary);
 
+  // variantSet. Require special treatment.
+  d.insert("variantSet");
+
   // TODO: Add more types...
 }
 
-static void RegisterPrimTypes(std::set<std::string> &d)
-{
+static void RegisterPrimTypes(std::set<std::string> &d) {
   d.insert("Xform");
   d.insert("Sphere");
   d.insert("Cube");
+  d.insert("Cone");
   d.insert("Cylinder");
+  d.insert("Capsule");
   d.insert("BasisCurves");
   d.insert("Mesh");
+  d.insert("Points");
+  d.insert("GeomSubset");
   d.insert("Scope");
   d.insert("Material");
   d.insert("NodeGraph");
   d.insert("Shader");
   d.insert("SphereLight");
   d.insert("DomeLight");
+  d.insert("DiskLight");
+  d.insert("DistantLight");
+  d.insert("CylinderLight");
+  // d.insert("PortalLight");
   d.insert("Camera");
   d.insert("SkelRoot");
   d.insert("Skeleton");
+  d.insert("SkelAnimation");
+  d.insert("BlendShape");
+
+  d.insert("GPrim");
+}
 
+// TinyUSDZ does not allow user-defined API schema at the moment
+// (Primarily for security reason, secondary it requires re-design of Prim
+// classes to support user-defined API schema)
+static void RegisterAPISchemas(std::set<std::string> &d) {
+  d.insert("MaterialBindingAPI");
+  d.insert("SkelBindingAPI");
+
+  // TODO:
+  // d.insert("PhysicsCollisionAPI");
+  // d.insert("PhysicsRigidBodyAPI");
+
+  // TODO: Support Multi-apply API(`CollectionAPI`)
+  // d.insert("PhysicsLimitAPI");
+  // d.insert("PhysicsDriveAPI");
+  // d.insert("CollectionAPI");
 }
 
 namespace {
 
+#if 0 // TODO: Remove
 // parseInt
 // 0 = success
 // -1 = bad input
 // -2 = overflow
 // -3 = underflow
 int parseInt(const std::string &s, int *out_result) {
   size_t n = s.size();
@@ -368,22 +516,18 @@
     (*out_result) = -int(result);
   } else {
     (*out_result) = int(result);
   }
 
   return 0;  // OK
 }
+#endif
 
 }  // namespace
 
-struct ErrorDiagnositc {
-  std::string err;
-  int line_row = -1;
-  int line_col = -1;
-};
 
 namespace {
 
 using ReferenceList = std::vector<std::pair<ListEditQual, Reference>>;
 
 // https://www.techiedelight.com/trim-string-cpp-remove-leading-trailing-spaces/
 std::string TrimString(const std::string &str) {
@@ -420,2167 +564,1186 @@
   return startsWith(str, "outputs:");
 }
 
 inline bool is_digit(char x) {
   return (static_cast<unsigned int>((x) - '0') < static_cast<unsigned int>(10));
 }
 
+#if 0 // TODO: Remove
 static nonstd::expected<float, std::string> ParseFloat(const std::string &s) {
-#if 0
-  // Pase with Ryu.
-  float value;
-  Status stat = s2f_n(s.data(), int(s.size()), &value);
-  if (stat == SUCCESS) {
-    return value;
-  }
-
-  if (stat == INPUT_TOO_SHORT) {
-    return nonstd::make_unexpected("Input floating point literal is too short");
-  } else if (stat == INPUT_TOO_LONG) {
-    return nonstd::make_unexpected("Input floating point literal is too long");
-  } else if (stat == MALFORMED_INPUT) {
-    return nonstd::make_unexpected("Malformed input floating point literal");
-  }
-
-  return nonstd::make_unexpected("Unexpected error in ParseFloat");
-#else
   // Parse with fast_float
   float result;
   auto ans = fast_float::from_chars(s.data(), s.data() + s.size(), result);
   if (ans.ec != std::errc()) {
     // Current `fast_float` implementation does not report detailed parsing err.
     return nonstd::make_unexpected("Parse failed.");
   }
 
   return result;
-#endif
 }
 
 static nonstd::expected<double, std::string> ParseDouble(const std::string &s) {
-#if 0
-  // Pase with Ryu.
-  double value;
-  Status stat = s2d_n(s.data(), int(s.size()), &value);
-  if (stat == SUCCESS) {
-    return value;
-  }
-
-  if (stat == INPUT_TOO_SHORT) {
-    return nonstd::make_unexpected("Input floating point literal is too short");
-  } else if (stat == INPUT_TOO_LONG) {
-    // fallback to our float parser.
-  } else if (stat == MALFORMED_INPUT) {
-    return nonstd::make_unexpected("Malformed input floating point literal");
-  }
-
-  if (tryParseDouble(s.c_str(), s.c_str() + s.size(), &value)) {
-    return value;
-  }
-
-  return nonstd::make_unexpected("Failed to parse floating-point value.");
-#else
   // Parse with fast_float
   double result;
   auto ans = fast_float::from_chars(s.data(), s.data() + s.size(), result);
   if (ans.ec != std::errc()) {
     // Current `fast_float` implementation does not report detailed parsing err.
     return nonstd::make_unexpected("Parse failed.");
   }
 
   return result;
-#endif
 }
+#endif
 
 void AsciiParser::SetBaseDir(const std::string &str) { _base_dir = str; }
 
 void AsciiParser::SetStream(StreamReader *sr) { _sr = sr; }
 
 std::string AsciiParser::GetError() {
   if (err_stack.empty()) {
     return std::string();
   }
 
+
   std::stringstream ss;
   while (!err_stack.empty()) {
-    ErrorDiagnositc diag = err_stack.top();
+    ErrorDiagnostic diag = err_stack.top();
 
-    ss << "Near line " << diag.cursor.row << ", col " << diag.cursor.col
-       << ": ";
-    ss << diag.err << "\n";
+    ss << "err_stack[" << (err_stack.size() - 1) << "] USDA source near line " << (diag.cursor.row + 1) << ", col "
+       << (diag.cursor.col + 1) << ": ";
+    ss << diag.err; // assume message contains newline.
 
     err_stack.pop();
   }
 
   return ss.str();
 }
 
 std::string AsciiParser::GetWarning() {
   if (warn_stack.empty()) {
     return std::string();
   }
 
   std::stringstream ss;
   while (!warn_stack.empty()) {
-    ErrorDiagnositc diag = warn_stack.top();
+    ErrorDiagnostic diag = warn_stack.top();
 
-    ss << "Near line " << diag.cursor.row << ", col " << diag.cursor.col
-       << ": ";
-    ss << diag.err << "\n";
+    ss << "USDA source near line " << (diag.cursor.row + 1) << ", col "
+       << (diag.cursor.col + 1) << ": ";
+    ss << diag.err; // assume message contains newline.
 
     warn_stack.pop();
   }
 
   return ss.str();
 }
 
-//
-// -- Parse
-//
-
-template <>
-bool AsciiParser::ParseMatrix(value::matrix2d *result) {
-  // Assume column major(OpenGL style).
-
-  if (!Expect('(')) {
-    return false;
-  }
-
-  std::vector<std::array<double, 2>> content;
-  if (!SepBy1TupleType<double, 2>(',', &content)) {
-    return false;
-  }
-
-  if (content.size() != 2) {
-    PushError("# of rows in matrix2d must be 2, but got " +
-              std::to_string(content.size()) + "\n");
-    return false;
-  }
-
-  if (!Expect(')')) {
-    return false;
-  }
-
-  for (size_t i = 0; i < 2; i++) {
-    result->m[i][0] = content[i][0];
-    result->m[i][1] = content[i][1];
-  }
-
-  return true;
-}
-
-template <>
-bool AsciiParser::ParseMatrix(value::matrix3d *result) {
-  // Assume column major(OpenGL style).
-
-  if (!Expect('(')) {
-    return false;
-  }
-
-  std::vector<std::array<double, 3>> content;
-  if (!SepBy1TupleType<double, 3>(',', &content)) {
-    return false;
-  }
-
-  if (content.size() != 3) {
-    PushError("# of rows in matrix3d must be 3, but got " +
-              std::to_string(content.size()) + "\n");
-    return false;
-  }
-
-  if (!Expect(')')) {
-    return false;
-  }
-
-  for (size_t i = 0; i < 3; i++) {
-    result->m[i][0] = content[i][0];
-    result->m[i][1] = content[i][1];
-    result->m[i][2] = content[i][2];
-  }
-
-  return true;
-}
-
-template <>
-bool AsciiParser::ParseMatrix(value::matrix4d *result) {
-  // Assume column major(OpenGL style).
-
-  if (!Expect('(')) {
-    return false;
-  }
-
-  std::vector<std::array<double, 4>> content;
-  if (!SepBy1TupleType<double, 4>(',', &content)) {
-    return false;
-  }
-
-  if (content.size() != 4) {
-    PushError("# of rows in matrix4d must be 4, but got " +
-              std::to_string(content.size()) + "\n");
-    return false;
-  }
-
-  if (!Expect(')')) {
-    return false;
-  }
+// -- end basic
 
-  for (size_t i = 0; i < 4; i++) {
-    result->m[i][0] = content[i][0];
-    result->m[i][1] = content[i][1];
-    result->m[i][2] = content[i][2];
-    result->m[i][3] = content[i][3];
-  }
 
-  return true;
-}
+// types: Allowd in dict.
+// std::string is not included since its represented as StringData or std::string.
+// TODO: Include timecode?
+#define APPLY_TO_METAVARIABLE_TYPE(__FUNC) \
+  __FUNC(value::token)         \
+  __FUNC(bool)                 \
+  __FUNC(value::half)                 \
+  __FUNC(value::half2)                \
+  __FUNC(value::half3)                \
+  __FUNC(value::half4)                \
+  __FUNC(int32_t)              \
+  __FUNC(uint32_t)             \
+  __FUNC(value::int2)                 \
+  __FUNC(value::int3)                 \
+  __FUNC(value::int4)                 \
+  __FUNC(value::uint2)                \
+  __FUNC(value::uint3)                \
+  __FUNC(value::uint4)                \
+  __FUNC(int64_t)              \
+  __FUNC(uint64_t)             \
+  __FUNC(float)                \
+  __FUNC(value::float2)               \
+  __FUNC(value::float3)               \
+  __FUNC(value::float4)               \
+  __FUNC(double)               \
+  __FUNC(value::double2)              \
+  __FUNC(value::double3)              \
+  __FUNC(value::double4)              \
+  __FUNC(value::matrix2d)             \
+  __FUNC(value::matrix3d)             \
+  __FUNC(value::matrix4d)             \
+  __FUNC(value::quath)                \
+  __FUNC(value::quatf)                \
+  __FUNC(value::quatd)                \
+  __FUNC(value::normal3h)             \
+  __FUNC(value::normal3f)             \
+  __FUNC(value::normal3d)             \
+  __FUNC(value::vector3h)             \
+  __FUNC(value::vector3f)             \
+  __FUNC(value::vector3d)             \
+  __FUNC(value::point3h)              \
+  __FUNC(value::point3f)              \
+  __FUNC(value::point3d)              \
+  __FUNC(value::color3f)              \
+  __FUNC(value::color3d)              \
+  __FUNC(value::color4f)              \
+  __FUNC(value::color4d)              \
+  __FUNC(value::texcoord2h)           \
+  __FUNC(value::texcoord2f)           \
+  __FUNC(value::texcoord2d)           \
+  __FUNC(value::texcoord3h)           \
+  __FUNC(value::texcoord3f)           \
+  __FUNC(value::texcoord3d)
 
-template <>
-bool AsciiParser::ReadBasicType(value::matrix2d *value) {
-  if (value) {
-    return ParseMatrix(value);
-  } else {
-    return false;
-  }
-}
 
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<value::matrix2d> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
+bool AsciiParser::ParseDictElement(std::string *out_key,
+                                   MetaVariable *out_var) {
+  (void)out_key;
+  (void)out_var;
 
-  value::matrix2d v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
-  }
+  // dict_element: type (array_qual?) name '=' value
+  //           ;
 
-  return false;
-}
+  std::string type_name;
 
-template <>
-bool AsciiParser::ReadBasicType(value::matrix3d *value) {
-  if (value) {
-    return ParseMatrix(value);
-  } else {
+  if (!ReadIdentifier(&type_name)) {
     return false;
   }
-}
-
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<value::matrix3d> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
-
-  value::matrix3d v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
-  }
 
-  return false;
-}
-
-template <>
-bool AsciiParser::ReadBasicType(value::matrix4d *value) {
-  if (value) {
-    return ParseMatrix(value);
-  } else {
+  if (!SkipWhitespace()) {
     return false;
   }
-}
-
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<value::matrix4d> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
 
-  value::matrix4d v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
-  }
-
-  return false;
-}
-
-#if 0 // No `matrixNf` in USDA?
-template<>
-bool AsciiParser::ReadBasicType(value::matrix4f *value) {
-  if (value) {
-    return ParseMatrix(value);
-  } else {
-    return false;
+  if (!IsSupportedPrimAttrType(type_name)) {
+    PUSH_ERROR_AND_RETURN("Unknown or unsupported type `" + type_name + "`\n");
   }
-}
 
-template<>
-bool AsciiParser::ReadBasicType(
-    nonstd::optional<value::matrix4f> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
+  // Has array qualifier? `[]`
+  bool array_qual = false;
+  {
+    char c0, c1;
+    if (!Char1(&c0)) {
+      return false;
+    }
 
-  value::matrix4f v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
-  }
+    if (c0 == '[') {
+      if (!Char1(&c1)) {
+        return false;
+      }
 
-  return false;
-}
-#endif
+      if (c1 == ']') {
+        array_qual = true;
+      } else {
+        // Invalid syntax
+        PUSH_ERROR_AND_RETURN("Invalid syntax found.");
+      }
 
-///
-/// Parse the array of tuple. some may be None(e.g. `float3`: [(0, 1, 2),
-/// None, (2, 3, 4), ...] )
-///
-template <typename T, size_t N>
-bool AsciiParser::ParseTupleArray(
-    std::vector<nonstd::optional<std::array<T, N>>> *result) {
-  if (!Expect('[')) {
-    return false;
+    } else {
+      if (!Rewind(1)) {
+        return false;
+      }
+    }
   }
 
-  if (!SepBy1TupleType<T, N>(',', result)) {
+  if (!SkipWhitespace()) {
     return false;
   }
 
-  if (!Expect(']')) {
-    return false;
+  std::string key_name;
+  if (!ReadIdentifier(&key_name)) {
+    // string literal is also supported. e.g. "0"
+    if (ReadStringLiteral(&key_name)) {
+      // ok
+    } else {
+      PUSH_ERROR_AND_RETURN("Failed to parse dictionary key identifier.\n");
+    }
   }
 
-  return true;
-}
-
-///
-/// Parse the array of tuple(e.g. `float3`: [(0, 1, 2), (2, 3, 4), ...] )
-///
-template <typename T, size_t N>
-bool AsciiParser::ParseTupleArray(std::vector<std::array<T, N>> *result) {
-  (void)result;
-
-  if (!Expect('[')) {
+  if (!SkipWhitespace()) {
     return false;
   }
 
-  if (!SepBy1TupleType<T, N>(',', result)) {
+  if (!Expect('=')) {
     return false;
   }
 
-  if (!Expect(']')) {
+  if (!SkipWhitespace()) {
     return false;
   }
 
-  return true;
-}
-
-template <>
-bool AsciiParser::ReadBasicType(Identifier *value) {
-  return ReadIdentifier(value);
-}
-
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<Identifier> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
-
-  Identifier v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
-  }
-
-  return false;
-}
-
-template <>
-bool AsciiParser::ReadBasicType(std::string *value) {
-  return ReadStringLiteral(value);
-}
-
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<std::string> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
-
-  std::string v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
-  }
-
-  return false;
-}
-
-template <>
-bool AsciiParser::ReadBasicType(PathIdentifier *value) {
-  return ReadPathIdentifier(value);
-}
-
+  uint32_t tyid = value::GetTypeId(type_name);
 
-template <>
-bool AsciiParser::ReadBasicType(bool *value) {
-  // 'true', 'false', '0' or '1'
-  {
-    std::string tok;
+  primvar::PrimVar var;
 
-    auto loc = CurrLoc();
-    bool ok = ReadIdentifier(&tok);
+  //
+  // Supports limited types for customData/Dictionary.
+  //
 
-    if (ok) {
-      if (tok == "true") {
-        (*value) = true;
-        return true;
-      } else if (tok == "false") {
-        (*value) = false;
-        return true;
+#if 0
+  // TODO: support more types
+  if (type_name == value::kBool) {
+    bool val;
+    if (!ReadBasicType(&val)) {
+      PUSH_ERROR_AND_RETURN("Failed to parse `bool`");
+    }
+    var.set_value(val);
+  } else if (type_name == value::kInt) {
+    if (array_qual) {
+      std::vector<int32_t> vss;
+      if (!ParseBasicTypeArray(&vss)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `int[]`");
       }
+      var.set_value(vss);
+    } else {
+      int32_t val;
+      if (!ReadBasicType(&val)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `int`");
+      }
+      var.set_value(val);
     }
-
-    // revert
-    SeekTo(loc);
-  }
-
-  char sc;
-  if (!_sr->read1(&sc)) {
-    return false;
-  }
-  _curr_cursor.col++;
-
-  // sign or [0-9]
-  if (sc == '0') {
-    (*value) = false;
-    return true;
-  } else if (sc == '1') {
-    (*value) = true;
-    return true;
-  } else {
-    PushError("'0' or '1' expected.\n");
-    return false;
-  }
-}
-
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<bool> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
-
-  bool v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
-  }
-
-  return false;
-}
-
-template <>
-bool AsciiParser::ReadBasicType(int *value) {
-  std::stringstream ss;
-
-  // head character
-  bool has_sign = false;
-  // bool negative = false;
-  {
-    char sc;
-    if (!_sr->read1(&sc)) {
-      return false;
+  } else if (type_name == value::kInt2) {
+    if (array_qual) {
+      std::vector<value::int2> vss;
+      if (!ParseBasicTypeArray(&vss)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `int2[]`");
+      }
+      var.set_value(vss);
+    } else {
+      value::int2 str;
+      if (!ReadBasicType(&str)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `int2`");
+      }
+      var.set_value(str);
     }
-    _curr_cursor.col++;
-
-    // sign or [0-9]
-    if (sc == '+') {
-      // negative = false;
-      has_sign = true;
-    } else if (sc == '-') {
-      // negative = true;
-      has_sign = true;
-    } else if ((sc >= '0') && (sc <= '9')) {
-      // ok
+  } else if (type_name == value::kUInt) {
+    if (array_qual) {
+      std::vector<uint32_t> vss;
+      if (!ParseBasicTypeArray(&vss)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `uint[]`");
+      }
+      var.set_value(vss);
     } else {
-      PushError("Sign or 0-9 expected, but got '" + std::to_string(sc) +
-                "'.\n");
-      return false;
+      uint32_t val;
+      if (!ReadBasicType(&val)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `uint`");
+      }
+      var.set_value(val);
     }
-
-    ss << sc;
-  }
-
-  while (!_sr->eof()) {
-    char c;
-    if (!_sr->read1(&c)) {
-      return false;
+  } else if (type_name == value::kFloat) {
+    if (array_qual) {
+      std::vector<float> vss;
+      if (!ParseBasicTypeArray(&vss)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `float[]`");
+      }
+      var.set_value(vss);
+    } else {
+      float val;
+      if (!ReadBasicType(&val)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `float`");
+      }
+      var.set_value(val);
     }
-
-    if ((c >= '0') && (c <= '9')) {
-      ss << c;
+  } else if (type_name == value::kFloat2) {
+    if (array_qual) {
+      std::vector<value::float2> vss;
+      if (!ParseBasicTypeArray(&vss)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `float2[]`");
+      }
+      var.set_value(vss);
     } else {
-      _sr->seek_from_current(-1);
-      break;
+      value::float2 str;
+      if (!ReadBasicType(&str)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `float2`");
+      }
+      var.set_value(str);
     }
-  }
-
-  if (has_sign && (ss.str().size() == 1)) {
-    // sign only
-    PushError("Integer value expected but got sign character only.\n");
-    return false;
-  }
-
-  if ((ss.str().size() > 1) && (ss.str()[0] == '0')) {
-    PushError("Zero padded integer value is not allowed.\n");
-    return false;
-  }
-
-  // std::cout << "ReadInt token: " << ss.str() << "\n";
-
-  int int_value;
-  int err = parseInt(ss.str(), &int_value);
-  if (err != 0) {
-    if (err == -1) {
-      PushError("Invalid integer input: `" + ss.str() + "`\n");
-      return false;
-    } else if (err == -2) {
-      PushError("Integer overflows: `" + ss.str() + "`\n");
-      return false;
-    } else if (err == -3) {
-      PushError("Integer underflows: `" + ss.str() + "`\n");
-      return false;
+  } else if (type_name == value::kFloat3) {
+    if (array_qual) {
+      std::vector<value::float3> vss;
+      if (!ParseBasicTypeArray(&vss)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `float3[]`");
+      }
+      var.set_value(vss);
     } else {
-      PushError("Unknown parseInt error.\n");
-      return false;
+      value::float3 str;
+      if (!ReadBasicType(&str)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `float3`");
+      }
+      var.set_value(str);
     }
-  }
-
-  (*value) = int_value;
-
-  return true;
-}
-
-template <>
-bool AsciiParser::ReadBasicType(uint32_t *value) {
-  std::stringstream ss;
-
-  // head character
-  bool has_sign = false;
-  bool negative = false;
-  {
-    char sc;
-    if (!_sr->read1(&sc)) {
-      return false;
+  } else if (type_name == value::kDouble) {
+    if (array_qual) {
+      std::vector<double> vss;
+      if (!ParseBasicTypeArray(&vss)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `double[]`");
+      }
+      var.set_value(vss);
+    } else {
+      double str;
+      if (!ReadBasicType(&str)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `double`");
+      }
+      var.set_value(str);
     }
-    _curr_cursor.col++;
-
-    // sign or [0-9]
-    if (sc == '+') {
-      negative = false;
-      has_sign = true;
-    } else if (sc == '-') {
-      negative = true;
-      has_sign = true;
-    } else if ((sc >= '0') && (sc <= '9')) {
-      // ok
+  } else if (type_name == value::kDouble3) {
+    if (array_qual) {
+      std::vector<value::double3> vss;
+      if (!ParseBasicTypeArray(&vss)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `double3[]`");
+      }
+      var.set_value(vss);
     } else {
-      PushError("Sign or 0-9 expected, but got '" + std::to_string(sc) +
-                "'.\n");
-      return false;
+      value::double3 str;
+      if (!ReadBasicType(&str)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `double3`");
+      }
+      var.set_value(str);
     }
-
-    ss << sc;
-  }
-
-  if (negative) {
-    PushError("Unsigned value expected but got '-' sign.");
-    return false;
-  }
-
-  while (!_sr->eof()) {
-    char c;
-    if (!_sr->read1(&c)) {
-      return false;
+  } else if (type_name == value::kString) {
+    if (array_qual) {
+      std::vector<value::StringData> strs;
+      if (!ParseBasicTypeArray(&strs)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `string[]`");
+      }
+      var.set_value(strs);
+    } else {
+      value::StringData str;
+      if (!ReadBasicType(&str)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `string`");
+      }
+      var.set_value(str);
     }
-
-    if ((c >= '0') && (c <= '9')) {
-      ss << c;
+  } else if (type_name == "token") {
+    if (array_qual) {
+      std::vector<value::token> toks;
+      if (!ParseBasicTypeArray(&toks)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `token[]`");
+      }
+      var.set_value(toks);
     } else {
-      _sr->seek_from_current(-1);
-      break;
+      value::token tok;
+      if (!ReadBasicType(&tok)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `token`");
+      }
+      var.set_value(tok);
     }
-  }
-
-  if (has_sign && (ss.str().size() == 1)) {
-    // sign only
-    PushError("Integer value expected but got sign character only.\n");
-    return false;
-  }
-
-  if ((ss.str().size() > 1) && (ss.str()[0] == '0')) {
-    PushError("Zero padded integer value is not allowed.\n");
-    return false;
-  }
-
-  // std::cout << "ReadInt token: " << ss.str() << "\n";
+  } else if (type_name == "dictionary") {
+    CustomDataType dict;
 
-#if defined(__cpp_exceptions) || defined(__EXCEPTIONS)
-  try {
-    (*value) = std::stoull(ss.str());
-  } catch (const std::invalid_argument &e) {
-    (void)e;
-    PushError("Not an 64bit unsigned integer literal.\n");
-    return false;
-  } catch (const std::out_of_range &e) {
-    (void)e;
-    PushError("64bit unsigned integer value out of range.\n");
-    return false;
+    DCOUT("Parse dictionary");
+    if (!ParseDict(&dict)) {
+      PUSH_ERROR_AND_RETURN("Failed to parse `dictionary`");
+    }
+    var.set_value(dict);
+  } else {
+    PUSH_ERROR_AND_RETURN("TODO: type = " + type_name);
   }
-  return true;
 #else
-  // use jsteemann/atoi
-  int retcode = 0;
-  auto result = jsteemann::atoi<uint32_t>(
-      ss.str().c_str(), ss.str().c_str() + ss.str().size(), retcode);
-  DCOUT("sz = " << ss.str().size());
-  DCOUT("ss = " << ss.str() << ", retcode = " << retcode << ", result = " << result);
-  if (retcode == jsteemann::SUCCESS) {
-    (*value) = result;
-    return true;
-  } else if (retcode == jsteemann::INVALID_INPUT) {
-    PushError("Not an 32bit unsigned integer literal.\n");
-    return false;
-  } else if (retcode == jsteemann::INVALID_NEGATIVE_SIGN) {
-    PushError("Negative sign `-` specified for uint32 integer.\n");
-    return false;
-  } else if (retcode == jsteemann::VALUE_OVERFLOW) {
-    PushError("Integer value overflows.\n");
-    return false;
-  }
-
-  PushError("Invalid integer literal\n");
-  return false;
-#endif
-}
 
-template <>
-bool AsciiParser::ReadBasicType(uint64_t *value) {
-  std::stringstream ss;
-
-  // head character
-  bool has_sign = false;
-  bool negative = false;
-  {
-    char sc;
-    if (!_sr->read1(&sc)) {
-      return false;
-    }
-    _curr_cursor.col++;
+  // TODO: Unify ParseMetaValue()
 
-    // sign or [0-9]
-    if (sc == '+') {
-      negative = false;
-      has_sign = true;
-    } else if (sc == '-') {
-      negative = true;
-      has_sign = true;
-    } else if ((sc >= '0') && (sc <= '9')) {
-      // ok
+#define PARSE_BASE_TYPE(__ty) case value::TypeTraits<__ty>::type_id(): { \
+    if (array_qual) { \
+      std::vector<__ty> vss; \
+      if (!ParseBasicTypeArray(&vss)) { \
+        PUSH_ERROR_AND_RETURN(fmt::format("Failed to parse a value of type `{}[]`", value::TypeTraits<__ty>::type_name())); \
+      } \
+      var.set_value(vss); \
+    } else { \
+      __ty val; \
+      if (!ReadBasicType(&val)) { \
+        PUSH_ERROR_AND_RETURN(fmt::format("Failed to parse a value of type `{}`", value::TypeTraits<__ty>::type_name())); \
+      } \
+      var.set_value(val); \
+    } \
+    break; \
+  }
+
+  switch (tyid) {
+  APPLY_TO_METAVARIABLE_TYPE(PARSE_BASE_TYPE)
+  case value::TYPE_ID_STRING: {
+    if (array_qual) {
+      std::vector<value::StringData> strs;
+      if (!ParseBasicTypeArray(&strs)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `string[]`");
+      }
+      var.set_value(strs);
     } else {
-      PushError("Sign or 0-9 expected, but got '" + std::to_string(sc) +
-                "'.\n");
-      return false;
+      value::StringData str;
+      if (!ReadBasicType(&str)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `string`");
+      }
+      var.set_value(str);
     }
-
-    ss << sc;
+    break;
   }
-
-  if (negative) {
-    PushError("Unsigned value expected but got '-' sign.");
-    return false;
-  }
-
-  while (!_sr->eof()) {
-    char c;
-    if (!_sr->read1(&c)) {
-      return false;
-    }
-
-    if ((c >= '0') && (c <= '9')) {
-      ss << c;
+  case value::TYPE_ID_ASSET_PATH: {
+    if (array_qual) {
+      std::vector<value::AssetPath> arrs;
+      if (!ParseBasicTypeArray(&arrs)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `asset[]`");
+      }
+      var.set_value(arrs);
     } else {
-      _sr->seek_from_current(-1);
-      break;
+      value::AssetPath asset;
+      if (!ReadBasicType(&asset)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `asset`");
+      }
+      var.set_value(asset);
     }
+    break;
   }
+  case value::TYPE_ID_DICT: {
+    CustomDataType dict;
 
-  if (has_sign && (ss.str().size() == 1)) {
-    // sign only
-    PushError("Integer value expected but got sign character only.\n");
-    return false;
+    DCOUT("Parse dictionary");
+    if (!ParseDict(&dict)) {
+      PUSH_ERROR_AND_RETURN("Failed to parse `dictionary`");
+    }
+    var.set_value(dict);
+    break;
   }
-
-  if ((ss.str().size() > 1) && (ss.str()[0] == '0')) {
-    PushError("Zero padded integer value is not allowed.\n");
-    return false;
+  default: {
+    PUSH_ERROR_AND_RETURN("Unsupported or invalid type for Metadatum:" + type_name);
   }
-
-  // std::cout << "ReadInt token: " << ss.str() << "\n";
-
-  // TODO(syoyo): Use ryu parse.
-#if defined(__cpp_exceptions) || defined(__EXCEPTIONS)
-  try {
-    (*value) = std::stoull(ss.str());
-  } catch (const std::invalid_argument &e) {
-    (void)e;
-    PushError("Not an 64bit unsigned integer literal.\n");
-    return false;
-  } catch (const std::out_of_range &e) {
-    (void)e;
-    PushError("64bit unsigned integer value out of range.\n");
-    return false;
   }
 
-  return true;
-#else
-  // use jsteemann/atoi
-  int retcode;
-  auto result = jsteemann::atoi<uint64_t>(
-      ss.str().c_str(), ss.str().c_str() + ss.str().size(), retcode);
-  if (retcode == jsteemann::SUCCESS) {
-    (*value) = result;
-    return true;
-  } else if (retcode == jsteemann::INVALID_INPUT) {
-    PushError("Not an 32bit unsigned integer literal.\n");
-    return false;
-  } else if (retcode == jsteemann::INVALID_NEGATIVE_SIGN) {
-    PushError("Negative sign `-` specified for uint32 integer.\n");
-    return false;
-  } else if (retcode == jsteemann::VALUE_OVERFLOW) {
-    PushError("Integer value overflows.\n");
-    return false;
-  }
+#undef PARSE_BASE_TYPE
 
-  PushError("Invalid integer literal\n");
-  return false;
 #endif
 
-  // std::cout << "read int ok\n";
-}
-
-template <>
-bool AsciiParser::ReadBasicType(value::float2 *value) {
-  return ParseBasicTypeTuple(value);
-}
-
-template <>
-bool AsciiParser::ReadBasicType(value::float3 *value) {
-  return ParseBasicTypeTuple(value);
-}
-
-template <>
-bool AsciiParser::ReadBasicType(value::point3f *value) {
-  value::float3 v;
-  if (ParseBasicTypeTuple(&v)) {
-    value->x = v[0];
-    value->y = v[1];
-    value->z = v[2];
-    return true;
-  }
-  return false;
-}
-
-template <>
-bool AsciiParser::ReadBasicType(value::normal3f *value) {
-  value::float3 v;
-  if (ParseBasicTypeTuple(&v)) {
-    value->x = v[0];
-    value->y = v[1];
-    value->z = v[2];
-    return true;
-  }
-  return false;
-}
+  MetaVariable metavar;
+  metavar.set_value(key_name, var.value_raw());
 
-template <>
-bool AsciiParser::ReadBasicType(value::float4 *value) {
-  return ParseBasicTypeTuple(value);
-}
+  DCOUT("key: " << key_name << ", type: " << type_name);
 
-template <>
-bool AsciiParser::ReadBasicType(value::double2 *value) {
-  return ParseBasicTypeTuple(value);
-}
+  (*out_key) = key_name;
+  (*out_var) = metavar;
 
-template <>
-bool AsciiParser::ReadBasicType(value::double3 *value) {
-  return ParseBasicTypeTuple(value);
+  return true;
 }
 
-template <>
-bool AsciiParser::ReadBasicType(value::point3d *value) {
-  value::double3 v;
-  if (ParseBasicTypeTuple(&v)) {
-    value->x = v[0];
-    value->y = v[1];
-    value->z = v[2];
-    return true;
-  }
-  return false;
-}
+bool AsciiParser::MaybeCustom() {
+  std::string tok;
 
-template <>
-bool AsciiParser::ReadBasicType(value::color3f *value) {
-  value::float3 v;
-  if (ParseBasicTypeTuple(&v)) {
-    value->r = v[0];
-    value->g = v[1];
-    value->b = v[2];
-    return true;
-  }
-  return false;
-}
+  auto loc = CurrLoc();
+  bool ok = ReadIdentifier(&tok);
 
-template <>
-bool AsciiParser::ReadBasicType(value::color3d *value) {
-  value::double3 v;
-  if (ParseBasicTypeTuple(&v)) {
-    value->r = v[0];
-    value->g = v[1];
-    value->b = v[2];
-    return true;
+  if (!ok) {
+    // revert
+    SeekTo(loc);
+    return false;
   }
-  return false;
-}
 
-template <>
-bool AsciiParser::ReadBasicType(value::color4f *value) {
-  value::float3 v;
-  if (ParseBasicTypeTuple(&v)) {
-    value->r = v[0];
-    value->g = v[1];
-    value->b = v[2];
-    value->a = v[3];
+  if (tok == "custom") {
+    // cosume `custom` token.
     return true;
   }
-  return false;
-}
 
-template <>
-bool AsciiParser::ReadBasicType(value::color4d *value) {
-  value::double4 v;
-  if (ParseBasicTypeTuple(&v)) {
-    value->r = v[0];
-    value->g = v[1];
-    value->b = v[2];
-    value->a = v[3];
-    return true;
-  }
+  // revert
+  SeekTo(loc);
   return false;
 }
 
-template <>
-bool AsciiParser::ReadBasicType(value::normal3d *value) {
-  value::double3 v;
-  if (ParseBasicTypeTuple(&v)) {
-    value->x = v[0];
-    value->y = v[1];
-    value->z = v[2];
-    return true;
+bool AsciiParser::ParseDict(std::map<std::string, MetaVariable> *out_dict) {
+  // '{' (type name '=' value)+ '}'
+  if (!Expect('{')) {
+    return false;
   }
-  return false;
-}
-
-template <>
-bool AsciiParser::ReadBasicType(value::double4 *value) {
-  return ParseBasicTypeTuple(value);
-}
-
-///
-/// Parses 1 or more occurences of value with basic type 'T', separated by
-/// `sep`
-///
-template <typename T>
-bool AsciiParser::SepBy1BasicType(const char sep,
-                                  std::vector<nonstd::optional<T>> *result) {
-  result->clear();
 
   if (!SkipWhitespaceAndNewline()) {
     return false;
   }
 
-  {
-    nonstd::optional<T> value;
-    if (!ReadBasicType(&value)) {
-      PushError("Not starting with the value of requested type.\n");
-      return false;
-    }
-
-    result->push_back(value);
-  }
-
-  while (!_sr->eof()) {
-    // sep
-    if (!SkipWhitespaceAndNewline()) {
-      return false;
-    }
-
+  while (!Eof()) {
     char c;
-    if (!_sr->read1(&c)) {
-      return false;
-    }
-
-    if (c != sep) {
-      // end
-      _sr->seek_from_current(-1);  // unwind single char
-      break;
-    }
-
-    if (!SkipWhitespaceAndNewline()) {
+    if (!Char1(&c)) {
       return false;
     }
 
-    nonstd::optional<T> value;
-    if (!ReadBasicType(&value)) {
+    if (c == '}') {
       break;
-    }
-
-    result->push_back(value);
-  }
-
-  if (result->empty()) {
-    PushError("Empty array.\n");
-    return false;
-  }
-
-  return true;
-}
-
-///
-/// Parses 1 or more occurences of value with basic type 'T', separated by
-/// `sep`
-///
-template <typename T>
-bool AsciiParser::SepBy1BasicType(const char sep, std::vector<T> *result) {
-  result->clear();
-
-  if (!SkipWhitespaceAndNewline()) {
-    return false;
-  }
-
-  {
-    T value;
-    if (!ReadBasicType(&value)) {
-      PushError("Not starting with the value of requested type.\n");
-      return false;
-    }
-
-    result->push_back(value);
-  }
-
-  while (!_sr->eof()) {
-    // sep
-    if (!SkipWhitespaceAndNewline()) {
-      return false;
-    }
+    } else {
+      if (!Rewind(1)) {
+        return false;
+      }
 
-    char c;
-    if (!_sr->read1(&c)) {
-      return false;
-    }
+      std::string key;
+      MetaVariable var;
+      if (!ParseDictElement(&key, &var)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse dict element.");
+      }
 
-    if (c != sep) {
-      // end
-      _sr->seek_from_current(-1);  // unwind single char
-      break;
-    }
+      if (!SkipWhitespaceAndNewline()) {
+        return false;
+      }
 
-    if (!SkipWhitespaceAndNewline()) {
-      return false;
-    }
+      if (!var.is_valid()) {
+        PUSH_ERROR_AND_RETURN("Invalid Dict element(probably internal issue).");
+      }
 
-    T value;
-    if (!ReadBasicType(&value)) {
-      break;
+      DCOUT("Add to dict: " << key);
+      (*out_dict)[key] = var;
     }
-
-    result->push_back(value);
   }
 
-  if (result->empty()) {
-    PushError("Empty array.\n");
+  if (!SkipWhitespaceAndNewline()) {
     return false;
   }
 
   return true;
 }
 
-///
-/// Parses 1 or more occurences of value with tuple type 'T', separated by
-/// `sep`
-///
-template <typename T, size_t N>
-bool AsciiParser::SepBy1TupleType(
-    const char sep, std::vector<nonstd::optional<std::array<T, N>>> *result) {
-  result->clear();
+bool AsciiParser::ParseVariantsElement(std::string *out_key,
+                                       std::string *out_var) {
+  // variants_element: string name '=' value
+  //           ;
 
-  if (!SkipWhitespaceAndNewline()) {
+  std::string type_name;
+
+  if (!ReadIdentifier(&type_name)) {
     return false;
   }
 
-  if (MaybeNone()) {
-    result->push_back(nonstd::nullopt);
-  } else {
-    std::array<T, N> value;
-    if (!ParseBasicTypeTuple<T, N>(&value)) {
-      PushError("Not starting with the tuple value of requested type.\n");
-      return false;
-    }
-
-    result->push_back(value);
+  // must be `string`
+  if (type_name != value::kString) {
+    PUSH_ERROR_AND_RETURN(
+        "TinyUSDZ only accepts type `string` for `variants` element.");
   }
 
-  while (!_sr->eof()) {
-    if (!SkipWhitespaceAndNewline()) {
-      return false;
-    }
-
-    char c;
-    if (!_sr->read1(&c)) {
-      return false;
-    }
-
-    if (c != sep) {
-      // end
-      _sr->seek_from_current(-1);  // unwind single char
-      break;
-    }
-
-    if (!SkipWhitespaceAndNewline()) {
-      return false;
-    }
+  if (!SkipWhitespace()) {
+    return false;
+  }
 
-    if (MaybeNone()) {
-      result->push_back(nonstd::nullopt);
+  std::string key_name;
+  if (!ReadIdentifier(&key_name)) {
+    // string literal is also supported. e.g. "0"
+    if (ReadStringLiteral(&key_name)) {
+      // ok
     } else {
-      std::array<T, N> value;
-      if (!ParseBasicTypeTuple<T, N>(&value)) {
-        break;
-      }
-      result->push_back(value);
+      PUSH_ERROR_AND_RETURN("Failed to parse dictionary key identifier.\n");
     }
   }
 
-  if (result->empty()) {
-    PushError("Empty array.\n");
+  if (!SkipWhitespace()) {
     return false;
   }
 
-  return true;
-}
-
-///
-/// Parses 1 or more occurences of value with tuple type 'T', separated by
-/// `sep`
-///
-template <typename T, size_t N>
-bool AsciiParser::SepBy1TupleType(const char sep,
-                                  std::vector<std::array<T, N>> *result) {
-  result->clear();
-
-  if (!SkipWhitespaceAndNewline()) {
+  if (!Expect('=')) {
     return false;
   }
 
-  {
-    std::array<T, N> value;
-    if (!ParseBasicTypeTuple<T, N>(&value)) {
-      PushError("Not starting with the tuple value of requested type.\n");
-      return false;
-    }
-
-    result->push_back(value);
-  }
-
-  while (!_sr->eof()) {
-    if (!SkipWhitespaceAndNewline()) {
-      return false;
-    }
-
-    char c;
-    if (!_sr->read1(&c)) {
-      return false;
-    }
-
-    if (c != sep) {
-      // end
-      _sr->seek_from_current(-1);  // unwind single char
-      break;
-    }
-
-    if (!SkipWhitespaceAndNewline()) {
-      return false;
-    }
-
-    std::array<T, N> value;
-    if (!ParseBasicTypeTuple<T, N>(&value)) {
-      break;
-    }
-
-    result->push_back(value);
-  }
-
-  if (result->empty()) {
-    PushError("Empty array.\n");
+  if (!SkipWhitespace()) {
     return false;
   }
 
-  return true;
-}
-
-///
-/// Parse '[', Sep1By(','), ']'
-///
-template <typename T>
-bool AsciiParser::ParseBasicTypeArray(
-    std::vector<nonstd::optional<T>> *result) {
-  if (!Expect('[')) {
-    return false;
+  std::string var;
+  if (!ReadBasicType(&var)) {
+    PUSH_ERROR_AND_RETURN("Failed to parse `string`");
   }
 
-  if (!SepBy1BasicType<T>(',', result)) {
-    return false;
-  }
+  DCOUT("key: " << key_name << ", value: " << var);
 
-  if (!Expect(']')) {
-    return false;
-  }
+  (*out_key) = key_name;
+  (*out_var) = var;
 
   return true;
 }
 
-///
-/// Parse '[', Sep1By(','), ']'
-///
-template <typename T>
-bool AsciiParser::ParseBasicTypeArray(std::vector<T> *result) {
-  if (!Expect('[')) {
-    return false;
-  }
-
-  if (!SepBy1BasicType<T>(',', result)) {
-    return false;
-  }
-
-  if (!Expect(']')) {
+bool AsciiParser::ParseVariants(VariantSelectionMap *out_map) {
+  // '{' (string name '=' value)+ '}'
+  if (!Expect('{')) {
     return false;
   }
-  return true;
-}
-
-///
-/// Parses 1 or more occurences of asset references, separated by
-/// `sep`
-/// TODO: Parse LayerOffset: e.g. `(offset = 10; scale = 2)`
-///
-template <>
-bool AsciiParser::SepBy1BasicType(const char sep,
-                                  std::vector<Reference> *result) {
-  result->clear();
 
   if (!SkipWhitespaceAndNewline()) {
     return false;
   }
 
-  {
-    Reference ref;
-    bool triple_deliminated{false};
-
-    if (!ParseReference(&ref, &triple_deliminated)) {
-      PushError("Failed to parse Reference.\n");
-      return false;
-    }
-
-    (void)triple_deliminated;
-
-    result->push_back(ref);
-  }
-
-  while (!_sr->eof()) {
-    // sep
-    if (!SkipWhitespaceAndNewline()) {
-      return false;
-    }
-
+  while (!Eof()) {
     char c;
-    if (!_sr->read1(&c)) {
-      return false;
-    }
-
-    if (c != sep) {
-      // end
-      _sr->seek_from_current(-1);  // unwind single char
-      break;
-    }
-
-    if (!SkipWhitespaceAndNewline()) {
+    if (!Char1(&c)) {
       return false;
     }
 
-    Reference ref;
-    bool triple_deliminated{false};
-    if (!ParseReference(&ref, &triple_deliminated)) {
+    if (c == '}') {
       break;
-    }
-
-    (void)triple_deliminated;
-    result->push_back(ref);
-  }
-
-  if (result->empty()) {
-    PushError("Empty array.\n");
-    return false;
-  }
+    } else {
+      if (!Rewind(1)) {
+        return false;
+      }
 
-  return true;
-}
+      std::string key;
+      std::string var;
+      if (!ParseVariantsElement(&key, &var)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse an element of `variants`.");
+      }
 
-bool AsciiParser::ParsePurpose(Purpose *result) {
-  if (!result) {
-    return false;
-  }
+      if (!SkipWhitespaceAndNewline()) {
+        return false;
+      }
 
-  if (!SkipCommentAndWhitespaceAndNewline()) {
-    return false;
+      DCOUT("Add to variants: " << key);
+      (*out_map)[key] = var;
+    }
   }
 
-  std::string str;
-  if (!ReadStringLiteral(&str)) {
+  if (!SkipWhitespaceAndNewline()) {
     return false;
   }
 
-  if (str == "\"default\"") {
-    (*result) = Purpose::Default;
-  } else if (str == "\"render\"") {
-    (*result) = Purpose::Render;
-  } else if (str == "\"proxy\"") {
-    (*result) = Purpose::Proxy;
-  } else if (str == "\"guide\"") {
-    (*result) = Purpose::Guide;
-  } else {
-    PUSH_ERROR_AND_RETURN("Invalid purpose value: " + str + "\n");
-  }
-
   return true;
 }
 
-template <typename T, size_t N>
-bool AsciiParser::ParseBasicTypeTuple(std::array<T, N> *result) {
-  if (!Expect('(')) {
-    return false;
-  }
+// 'None'
+bool AsciiParser::MaybeNone() {
+  std::vector<char> buf;
 
-  std::vector<T> values;
-  if (!SepBy1BasicType<T>(',', &values)) {
-    return false;
-  }
+  auto loc = CurrLoc();
 
-  if (!Expect(')')) {
+  if (!CharN(4, &buf)) {
+    SeekTo(loc);
     return false;
   }
 
-  if (values.size() != N) {
-    std::string msg = "The number of tuple elements must be " +
-                      std::to_string(N) + ", but got " +
-                      std::to_string(values.size()) + "\n";
-    PushError(msg);
-    return false;
+  if ((buf[0] == 'N') && (buf[1] == 'o') && (buf[2] == 'n') &&
+      (buf[3] == 'e')) {
+    // got it
+    return true;
   }
 
-  for (size_t i = 0; i < N; i++) {
-    (*result)[i] = values[i];
-  }
+  SeekTo(loc);
 
-  return true;
+  return false;
 }
 
-template <typename T, size_t N>
-bool AsciiParser::ParseBasicTypeTuple(
-    nonstd::optional<std::array<T, N>> *result) {
-  if (MaybeNone()) {
-    (*result) = nonstd::nullopt;
-    return true;
-  }
-
-  if (!Expect('(')) {
+bool AsciiParser::MaybeListEditQual(tinyusdz::ListEditQual *qual) {
+  if (!SkipWhitespace()) {
     return false;
   }
 
-  std::vector<T> values;
-  if (!SepBy1BasicType<T>(',', &values)) {
-    return false;
-  }
+  std::string tok;
 
-  if (!Expect(')')) {
+  auto loc = CurrLoc();
+  if (!ReadIdentifier(&tok)) {
+    SeekTo(loc);
     return false;
   }
 
-  if (values.size() != N) {
-    PUSH_ERROR_AND_RETURN("The number of tuple elements must be " +
-                          std::to_string(N) + ", but got " +
-                          std::to_string(values.size()));
-  }
-
-  std::array<T, N> ret;
-  for (size_t i = 0; i < N; i++) {
-    ret[i] = values[i];
+  if (tok == "prepend") {
+    DCOUT("`prepend` list edit qualifier.");
+    (*qual) = tinyusdz::ListEditQual::Prepend;
+  } else if (tok == "append") {
+    DCOUT("`append` list edit qualifier.");
+    (*qual) = tinyusdz::ListEditQual::Append;
+  } else if (tok == "add") {
+    DCOUT("`add` list edit qualifier.");
+    (*qual) = tinyusdz::ListEditQual::Add;
+  } else if (tok == "delete") {
+    DCOUT("`delete` list edit qualifier.");
+    (*qual) = tinyusdz::ListEditQual::Delete;
+  } else if (tok == "order") {
+    DCOUT("`order` list edit qualifier.");
+    (*qual) = tinyusdz::ListEditQual::Order;
+  } else {
+    DCOUT("No ListEdit qualifier.");
+    // unqualified
+    // rewind
+    SeekTo(loc);
+    (*qual) = tinyusdz::ListEditQual::ResetToExplicit;
   }
 
-  (*result) = ret;
-
-  return true;
-}
-
-///
-/// Parse array of asset references
-/// Allow non-list version
-///
-template <>
-bool AsciiParser::ParseBasicTypeArray(std::vector<Reference> *result) {
   if (!SkipWhitespace()) {
     return false;
   }
 
-  char c;
-  if (!Char1(&c)) {
-    return false;
-  }
-
-  if (c != '[') {
-    Rewind(1);
-
-    DCOUT("Guess non-list version");
-    // Guess non-list version
-    Reference ref;
-    bool triple_deliminated{false};
-    if (!ParseReference(&ref, &triple_deliminated)) {
-      return false;
-    }
-
-    (void)triple_deliminated;
-    result->clear();
-    result->push_back(ref);
-
-  } else {
-    if (!SepBy1BasicType(',', result)) {
-      return false;
-    }
-
-    if (!Expect(']')) {
-      return false;
-    }
-  }
-
   return true;
 }
 
-template <typename T>
-bool AsciiParser::MaybeNonFinite(T *out) {
-  auto loc = CurrLoc();
-
-  // "-inf", "inf" or "nan"
-  std::vector<char> buf(4);
-  if (!CharN(3, &buf)) {
+bool AsciiParser::MaybeVariability(tinyusdz::Variability *variability, bool *varying_authored) {
+  if (!SkipWhitespace()) {
     return false;
   }
-  SeekTo(loc);
-
-  if ((buf[0] == 'i') && (buf[1] == 'n') && (buf[2] == 'f')) {
-    (*out) = std::numeric_limits<T>::infinity();
-    return true;
-  }
 
-  if ((buf[0] == 'n') && (buf[1] == 'a') && (buf[2] == 'n')) {
-    (*out) = std::numeric_limits<T>::quiet_NaN();
-    return true;
-  }
-
-  bool ok = CharN(4, &buf);
-  SeekTo(loc);
-
-  if (ok) {
-    if ((buf[0] == '-') && (buf[1] == 'i') && (buf[2] == 'n') &&
-        (buf[3] == 'f')) {
-      (*out) = -std::numeric_limits<T>::infinity();
-      return true;
-    }
-
-    // NOTE: support "-nan"?
-  }
-
-  return false;
-}
+  std::string tok;
 
-template <>
-bool AsciiParser::ReadBasicType(value::texcoord2f *value) {
-  if (!Expect('(')) {
+  auto loc = CurrLoc();
+  if (!ReadIdentifier(&tok)) {
+    SeekTo(loc);
     return false;
   }
 
-  std::vector<float> values;
-  if (!SepBy1BasicType<float>(',', &values)) {
-    return false;
+  if (tok == "uniform") {
+    (*variability) = tinyusdz::Variability::Uniform;
+    (*varying_authored) = false;
+  } else if (tok == "varying") {
+    (*variability) = tinyusdz::Variability::Varying;
+    (*varying_authored) = true;
+  } else {
+    (*varying_authored) = false;
+    // rewind
+    SeekTo(loc);
   }
 
-  if (!Expect(')')) {
+  if (!SkipWhitespace()) {
     return false;
   }
 
-  if (values.size() != 2) {
-    std::string msg = "The number of tuple elements must be " +
-                      std::to_string(2) + ", but got " +
-                      std::to_string(values.size()) + "\n";
-    PUSH_ERROR_AND_RETURN(msg);
-  }
-
-  value->s = values[0];
-  value->t = values[1];
-
   return true;
 }
 
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<value::texcoord2f> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
-
-  value::texcoord2f v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
-  }
-
-  return false;
-}
-
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<value::float2> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
-
-  value::float2 v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
-  }
-
-  return false;
-}
-
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<value::float3> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
-
-  value::float3 v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
-  }
-
-  return false;
-}
-
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<value::float4> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
-
-  value::float4 v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
-  }
-
-  return false;
-}
-
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<value::double2> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
-
-  value::double2 v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
-  }
-
-  return false;
-}
-
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<value::double3> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
-
-  value::double3 v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
-  }
-
-  return false;
-}
-
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<value::double4> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
-
-  value::double4 v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
-  }
-
-  return false;
-}
-
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<value::point3f> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
-
-  value::point3f v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
-  }
-
-  return false;
-}
-
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<value::point3d> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
-
-  value::point3d v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
-  }
-
-  return false;
-}
-
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<value::normal3f> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
-
-  value::normal3f v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
-  }
-
-  return false;
-}
-
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<value::normal3d> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
-
-  value::normal3d v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
-  }
-
-  return false;
-}
-
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<value::color3f> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
-
-  value::color3f v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
-  }
-
-  return false;
-}
-
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<value::color4f> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
-
-  value::color4f v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
-  }
-
-  return false;
+bool AsciiParser::IsSupportedPrimType(const std::string &ty) {
+  return _supported_prim_types.count(ty);
 }
 
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<value::color3d> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
-
-  value::color3d v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
-  }
 
-  return false;
+bool AsciiParser::IsSupportedPrimAttrType(const std::string &ty) {
+  return _supported_prim_attr_types.count(ty);
 }
 
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<value::color4d> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
-
-  value::color4d v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
-  }
-
-  return false;
+bool AsciiParser::IsSupportedAPISchema(const std::string &ty) {
+  return _supported_api_schemas.count(ty);
 }
 
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<int> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
+bool AsciiParser::ReadStringLiteral(std::string *literal) {
+  std::stringstream ss;
 
-  int v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
+  char c0;
+  if (!Char1(&c0)) {
+    return false;
   }
 
-  return false;
-}
+  // TODO: Allow triple-quotated string?
 
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<uint32_t> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
+  bool single_quote{false};
 
-  uint32_t v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
+  if (c0 == '"') {
+    // ok
+  } else if (c0 == '\'') {
+    // ok
+    single_quote = true;
+  } else {
+    DCOUT("c0 = " << c0);
+    PUSH_ERROR_AND_RETURN(
+        "String or Token literal expected but it does not start with \" or '");
   }
 
-  return false;
-}
+  bool end_with_quotation{false};
 
-template <>
-bool AsciiParser::ReadBasicType(float *value) {
-  // -inf, inf, nan
-  {
-    float v;
-    if (MaybeNonFinite(&v)) {
-      (*value) = v;
-      return true;
+  while (!Eof()) {
+    char c;
+    if (!Char1(&c)) {
+      // this should not happen.
+      return false;
     }
-  }
-
-  std::string value_str;
-  if (!LexFloat(&value_str)) {
-    PUSH_ERROR_AND_RETURN("Failed to lex floating value literal.");
-  }
 
-  auto flt = ParseFloat(value_str);
-  if (flt) {
-    (*value) = flt.value();
-  } else {
-    PUSH_ERROR_AND_RETURN("Failed to parse floating value.");
-  }
-
-  return true;
-}
+    if ((c == '\n') || (c == '\r')) {
+      PUSH_ERROR_AND_RETURN("New line in string literal.");
+    }
 
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<float> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
+    if (single_quote) {
+      if (c == '\'') {
+        end_with_quotation = true;
+        break;
+      }
+    } else if (c == '"') {
+      end_with_quotation = true;
+      break;
+    }
 
-  float v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
+    ss << c;
   }
 
-  return false;
-}
-
-template <>
-bool AsciiParser::ReadBasicType(double *value) {
-  // -inf, inf, nan
-  {
-    double v;
-    if (MaybeNonFinite(&v)) {
-      (*value) = v;
-      return true;
-    }
+  if (!end_with_quotation) {
+    PUSH_ERROR_AND_RETURN(
+        fmt::format("String literal expected but it does not end with {}.",
+                    single_quote ? "'" : "\""));
   }
 
-  std::string value_str;
-  if (!LexFloat(&value_str)) {
-    PUSH_ERROR_AND_RETURN("Failed to lex floating value literal.");
-  }
+  (*literal) = ss.str();
 
-  auto flt = ParseDouble(value_str);
-  if (!flt) {
-    PUSH_ERROR_AND_RETURN("Failed to parse floating value.");
-  } else {
-    (*value) = flt.value();
-  }
+  _curr_cursor.col += int(literal->size() + 2);  // +2 for quotation chars
 
   return true;
 }
 
-template <>
-bool AsciiParser::ReadBasicType(nonstd::optional<double> *value) {
-  if (MaybeNone()) {
-    (*value) = nonstd::nullopt;
-    return true;
-  }
+bool AsciiParser::MaybeString(value::StringData *str) {
+  std::stringstream ss;
 
-  double v;
-  if (ReadBasicType(&v)) {
-    (*value) = v;
-    return true;
+  if (!str) {
+    return false;
   }
 
-  return false;
-}
-
-// -- end basic
-
-bool AsciiParser::ParseDictElement(std::string *out_key,
-                                   MetaVariable *out_var) {
-  (void)out_key;
-  (void)out_var;
-
-  // dict_element: type (array_qual?) name '=' value
-  //           ;
-
-  std::string type_name;
+  auto loc = CurrLoc();
+  auto start_cursor = _curr_cursor;
 
-  if (!ReadIdentifier(&type_name)) {
+  char c0;
+  if (!Char1(&c0)) {
+    SeekTo(loc);
     return false;
   }
 
-  if (!SkipWhitespace()) {
+  // ' or " allowed.
+  if ((c0 != '"') && (c0 != '\'')) {
+    SeekTo(loc);
     return false;
   }
 
-  if (!IsSupportedPrimAttrType(type_name)) {
-    PUSH_ERROR_AND_RETURN("Unknown or unsupported type `" + type_name + "`\n");
-  }
+  bool single_quote = (c0 == '\'');
 
-  // Has array qualifier? `[]`
-  bool array_qual = false;
-  {
-    char c0, c1;
-    if (!Char1(&c0)) {
+  bool end_with_quotation{false};
+
+  while (!Eof()) {
+    char c;
+    if (!Char1(&c)) {
+      // this should not happen.
+      SeekTo(loc);
       return false;
     }
 
-    if (c0 == '[') {
-      if (!Char1(&c1)) {
-        return false;
-      }
+    if ((c == '\n') || (c == '\r')) {
+      SeekTo(loc);
+      return false;
+    }
 
-      if (c1 == ']') {
-        array_qual = true;
-      } else {
-        // Invalid syntax
-        PushError("Invalid syntax found.\n");
+    if (c == '\\') {
+      // escaped quote? \" \'
+      char nc;
+      if (!LookChar1(&nc)) {
         return false;
       }
 
-    } else {
-      if (!Rewind(1)) {
-        return false;
+      if (nc == '\'') {
+        ss << "'";
+        _sr->seek_from_current(1); // advance 1 char
+        continue;
+      } else if (nc == '"') {
+        ss << "\"";
+        _sr->seek_from_current(1); // advance 1 char
+        continue;
       }
     }
-  }
-
-  if (!SkipWhitespace()) {
-    return false;
-  }
 
-  std::string key_name;
-  if (!ReadIdentifier(&key_name)) {
-    // string literal is also supported. e.g. "0"
-    if (ReadStringLiteral(&key_name)) {
-      // ok
+    if (single_quote) {
+      if (c == '\'') {
+        end_with_quotation = true;
+        break;
+      }
     } else {
-      PushError("Failed to parse dictionary key identifier.\n");
-      return false;
+      if (c == '"') {
+        end_with_quotation = true;
+        break;
+      }
     }
-  }
-
-  if (!SkipWhitespace()) {
-    return false;
-  }
 
-  if (!Expect('=')) {
-    return false;
+    ss << c;
   }
 
-  if (!SkipWhitespace()) {
+  if (!end_with_quotation) {
+    SeekTo(loc);
     return false;
   }
 
-  //
-  // Supports limited types for customData/Dictionary.
-  // TODO: array_qual
-  //
-  MetaVariable var;
-  if (type_name == value::kBool) {
-    bool val;
-    if (!ReadBasicType(&val)) {
-      PUSH_ERROR_AND_RETURN("Failed to parse `bool`");
-    }
-    var.value = val;
-  } else if (type_name == "float") {
-    float val;
-    if (!ReadBasicType(&val)) {
-      PUSH_ERROR_AND_RETURN("Failed to parse `float`");
-    }
-    var.value = val;
-  } else if (type_name == "string") {
-    std::string str;
-    if (!ReadStringLiteral(&str)) {
-      PUSH_ERROR_AND_RETURN("Failed to parse `string`");
-    }
-    var.value = str;
-  } else if (type_name == "token") {
-    if (array_qual) {
-      std::vector<std::string> strs;
-      if (!ParseBasicTypeArray(&strs)) {
-        PUSH_ERROR_AND_RETURN("Failed to parse `token[]`");
-      }
-      std::vector<value::token> toks;
-      for (auto item : strs) {
-        toks.push_back(value::token(item));
-      }
-      var.value = toks;
-    } else {
-      std::string str;
-      if (!ReadStringLiteral(&str)) {
-        PUSH_ERROR_AND_RETURN("Failed to parse `token`");
-      }
-      value::token tok(str);
-      var.value = tok;
-    }
-  } else if (type_name == "dictionary") {
-    std::map<std::string, MetaVariable> dict;
+  DCOUT("Single quoted string found. col " << start_cursor.col << ", row "
+                                           << start_cursor.row);
 
-    if (!ParseDict(&dict)) {
-      PUSH_ERROR_AND_RETURN("Failed to parse `dictionary`");
-    }
-  } else {
-    PUSH_ERROR_AND_RETURN("TODO: type = " + type_name);
-  }
+  size_t displayed_string_len = ss.str().size();
+  str->value = unescapeControlSequence(ss.str());
+  str->line_col = start_cursor.col;
+  str->line_row = start_cursor.row;
+  str->is_triple_quoted = false;
 
-  (*out_key) = key_name;
-  (*out_var) = var;
+  _curr_cursor.col += int(displayed_string_len + 2);  // +2 for quotation chars
 
   return true;
 }
 
-bool AsciiParser::MaybeCustom() {
-  std::string tok;
+bool AsciiParser::MaybeTripleQuotedString(value::StringData *str) {
+  std::stringstream ss;
 
   auto loc = CurrLoc();
-  bool ok = ReadIdentifier(&tok);
+  auto start_cursor = _curr_cursor;
 
-  if (!ok) {
-    // revert
+  std::vector<char> triple_quote;
+  if (!CharN(3, &triple_quote)) {
     SeekTo(loc);
     return false;
   }
 
-  if (tok == "custom") {
-    // cosume `custom` token.
-    return true;
+  if (triple_quote.size() != 3) {
+    SeekTo(loc);
+    return false;
   }
 
-  // revert
-  SeekTo(loc);
-  return false;
-}
+  bool single_quote = false;
 
-bool AsciiParser::ParseDict(std::map<std::string, MetaVariable> *out_dict) {
-  // '{' (type name '=' value)+ '}'
-  if (!Expect('{')) {
+  if (triple_quote[0] == '"' && triple_quote[1] == '"' &&
+      triple_quote[2] == '"') {
+    // ok
+  } else if (triple_quote[0] == '\'' && triple_quote[1] == '\'' &&
+             triple_quote[2] == '\'') {
+    // ok
+    single_quote = true;
+  } else {
+    SeekTo(loc);
     return false;
   }
 
-  if (!SkipWhitespaceAndNewline()) {
-    return false;
-  }
+  // Read until next triple-quote `"""` or "'''"
+  std::stringstream str_buf;
+
+  auto locinfo = _curr_cursor;
+
+  int single_quote_count = 0;  // '
+  int double_quote_count = 0;  // "
 
-  while (!_sr->eof()) {
+  bool got_closing_triple_quote{false};
+
+  while (!Eof()) {
     char c;
+
     if (!Char1(&c)) {
+      SeekTo(loc);
       return false;
     }
 
-    if (c == '}') {
-      break;
-    } else {
-      if (!Rewind(1)) {
-        return false;
-      }
+    // Seek \""" or \'''
+    // Unescape '\'
+    if (c == '\\') {
+#if 0
+      if (single_quote) {
+        std::vector<char> buf(3, '\0');
+        if (!LookCharN(3, &buf)) {
+          // at least 3 chars should be read
+          return false;
+        }
 
-      std::string key;
-      MetaVariable var;
-      if (!ParseDictElement(&key, &var)) {
-        PUSH_ERROR_AND_RETURN("Failed to parse dict element.");
-      }
+        if (buf[0] == '\'' &&
+            buf[1] == '\'' &&
+            buf[2] == '\'') {
+          str_buf << "'''";
+          // advance
+          _sr->seek_from_current(3);
+          locinfo.col += 3;
+          continue;
+        }
+      } else {
+        std::vector<char> buf(3, '\0');
+        if (!LookCharN(3, &buf)) {
+          // at least 3 chars should be read
+          return false;
+        }
 
-      if (!SkipWhitespaceAndNewline()) {
+        if (buf[0] == '"' &&
+            buf[1] == '"' &&
+            buf[2] == '"') {
+          str_buf << "\"\"\"";
+          // advance
+          _sr->seek_from_current(3);
+          locinfo.col += 3;
+          continue;
+        }
+      }
+#else
+      std::vector<char> buf(3, '\0');
+      if (!LookCharN(3, &buf)) {
+        // at least 3 chars should be read
         return false;
       }
 
-      assert(var.valid());
-
-      (*out_dict)[key] = var;
+      if (buf[0] == '\'' &&
+          buf[1] == '\'' &&
+          buf[2] == '\'') {
+        str_buf << "'''";
+        // advance
+        _sr->seek_from_current(3);
+        locinfo.col += 3;
+        continue;
+      } else if (buf[0] == '"' &&
+            buf[1] == '"' &&
+            buf[2] == '"') {
+          str_buf << "\"\"\"";
+          // advance
+          _sr->seek_from_current(3);
+          locinfo.col += 3;
+          continue;
+      }
+#endif
     }
-  }
-
-  if (!SkipWhitespaceAndNewline()) {
-    return false;
-  }
-
-  return true;
-}
-
-// 'None'
-bool AsciiParser::MaybeNone() {
-  std::vector<char> buf;
-
-  auto loc = CurrLoc();
-
-  if (!CharN(4, &buf)) {
-    SeekTo(loc);
-    return false;
-  }
 
-  if ((buf[0] == 'N') && (buf[1] == 'o') && (buf[2] == 'n') &&
-      (buf[3] == 'e')) {
-    // got it
-    return true;
-  }
+    str_buf << c;
 
-  SeekTo(loc);
+    if (c == '"') {
+      double_quote_count++;
+      single_quote_count = 0;
+    } else if (c == '\'') {
+      double_quote_count = 0;
+      single_quote_count++;
+    } else {
+      double_quote_count = 0;
+      single_quote_count = 0;
+    }
 
-  return false;
-}
 
-bool AsciiParser::MaybeListEditQual(tinyusdz::ListEditQual *qual) {
-  if (!SkipWhitespace()) {
-    return false;
-  }
+    // Update loc info
+    locinfo.col++;
+    if (c == '\n') {
+      locinfo.col = 0;
+      locinfo.row++;
+    } else if (c == '\r') {
+      // CRLF?
+      if (_sr->tell() < (_sr->size() - 1)) {
+        char d;
+        if (!Char1(&d)) {
+          // this should not happen.
+          SeekTo(loc);
+          return false;
+        }
 
-  std::string tok;
+        if (d == '\n') {
+          // CRLF
+          str_buf << d;
+        } else {
+          // unwind 1 char
+          if (!_sr->seek_from_current(-1)) {
+            // this should not happen.
+            SeekTo(loc);
+            return false;
+          }
+        }
+      }
+      locinfo.col = 0;
+      locinfo.row++;
+    }
 
-  auto loc = CurrLoc();
-  if (!ReadIdentifier(&tok)) {
-    return false;
+    if (double_quote_count == 3) {
+      // got '"""'
+      if (single_quote) {
+        // continue
+      } else {
+        got_closing_triple_quote = true;
+        break;
+      }
+    }
+    if (single_quote_count == 3) {
+      // got '''
+      if (double_quote_count) {
+        // continue
+      } else {
+        got_closing_triple_quote = true;
+        break;
+      }
+    }
   }
 
-  if (tok == "prepend") {
-    (*qual) = tinyusdz::ListEditQual::Prepend;
-  } else if (tok == "append") {
-    (*qual) = tinyusdz::ListEditQual::Append;
-  } else if (tok == "add") {
-    (*qual) = tinyusdz::ListEditQual::Add;
-  } else if (tok == "delete") {
-    (*qual) = tinyusdz::ListEditQual::Delete;
-  } else {
-    // unqualified
-    // rewind
+  if (!got_closing_triple_quote) {
     SeekTo(loc);
-    (*qual) = tinyusdz::ListEditQual::ResetToExplicit;
-  }
-
-  return true;
-}
-
-bool AsciiParser::IsSupportedPrimType(const std::string &ty) {
-  return _supported_prim_types.count(ty);
-}
-
-
-bool AsciiParser::IsSupportedPrimAttrType(const std::string &ty) {
-  return _supported_prim_attr_types.count(ty);
-}
-
-bool AsciiParser::ReadStringLiteral(std::string *literal) {
-  std::stringstream ss;
-
-  char c0;
-  if (!_sr->read1(&c0)) {
     return false;
   }
 
-  if (c0 != '"') {
-    DCOUT("c0 = " << c0);
-    PUSH_ERROR_AND_RETURN(
-        "String literal expected but it does not start with '\"'");
-  }
-
-  bool end_with_quotation{false};
+  DCOUT("single_quote = " << single_quote);
+  DCOUT("Triple quoted string found. col " << start_cursor.col << ", row "
+                                           << start_cursor.row);
 
-  while (!_sr->eof()) {
-    char c;
-    if (!_sr->read1(&c)) {
-      // this should not happen.
-      return false;
-    }
+  // remove last '"""' or '''
+  str->single_quote = single_quote;
+  std::string s = str_buf.str();
+  if (s.size() > 3) {  // just in case
+    s.erase(s.size() - 3);
+  }
 
-    if (c == '"') {
-      end_with_quotation = true;
-      break;
-    }
+  DCOUT("str = " << s);
 
-    ss << c;
-  }
+  str->value = unescapeControlSequence(s);
 
-  if (!end_with_quotation) {
-    PUSH_ERROR_AND_RETURN(
-        "String literal expected but it does not end with '\"'");
-  }
+  DCOUT("unescape str = " << str->value);
 
-  (*literal) = ss.str();
+  str->line_col = start_cursor.col;
+  str->line_row = start_cursor.row;
+  str->is_triple_quoted = true;
 
-  _curr_cursor.col += int(literal->size() + 2);  // +2 for quotation chars
+  _curr_cursor = locinfo;
 
   return true;
 }
 
 bool AsciiParser::ReadPrimAttrIdentifier(std::string *token) {
-  // Example: xformOp:transform
+  // Example:
+  // - xformOp:transform
+  // - primvars:uvmap1
 
   std::stringstream ss;
 
-  while (!_sr->eof()) {
+  while (!Eof()) {
     char c;
-    if (!_sr->read1(&c)) {
+    if (!Char1(&c)) {
       // this should not happen.
       return false;
     }
 
     if (c == '_') {
       // ok
     } else if (c == ':') {  // namespace
       // ':' must lie in the middle of string literal
       if (ss.str().size() == 0) {
-        PushError("PrimAttr name must not starts with `:`\n");
-        return false;
+        PUSH_ERROR_AND_RETURN("PrimAttr name must not starts with `:`");
       }
     } else if (c == '.') {  // delimiter for `connect`
       // '.' must lie in the middle of string literal
       if (ss.str().size() == 0) {
-        PushError("PrimAttr name must not starts with `.`\n");
-        return false;
+        PUSH_ERROR_AND_RETURN("PrimAttr name must not starts with `.`");
       }
-    } else if (!std::isalpha(int(c))) {
+    } else if (std::isalnum(int(c))) {
+      // number must not be allowed for the first char.
+      if (ss.str().size() == 0) {
+        if (!std::isalpha(int(c))) {
+          PUSH_ERROR_AND_RETURN("PrimAttr name must not starts with number.");
+        }
+      }
+    } else {
       _sr->seek_from_current(-1);
       break;
     }
 
     _curr_cursor.col++;
 
     ss << c;
   }
 
   // ':' must lie in the middle of string literal
   if (ss.str().back() == ':') {
-    PushError("PrimAttr name must not ends with `:`\n");
+    PUSH_ERROR_AND_RETURN("PrimAttr name must not ends with `:`\n");
     return false;
   }
 
   // '.' must lie in the middle of string literal
   if (ss.str().back() == '.') {
-    PushError("PrimAttr name must not ends with `.`\n");
+    PUSH_ERROR_AND_RETURN("PrimAttr name must not ends with `.`\n");
     return false;
   }
 
   // Currently we only support '.connect'
   std::string tok = ss.str();
 
   if (contains(tok, '.')) {
-    if (endsWith(tok, ".connect")) {
-      PushError(
-          "Must ends with `.connect` when a name contains punctuation `.`");
-      return false;
+    if (endsWith(tok, ".connect") || endsWith(tok, ".timeSamples")) {
+      // OK
+    } else {
+      PUSH_ERROR_AND_RETURN_TAG(
+          kAscii, fmt::format("Must ends with `.connect` or `.timeSamples` for "
+                              "attrbute name: `{}`",
+                              tok));
+    }
+
+    // Multiple `.` is not allowed(e.g. attr.connect.timeSamples)
+    if (counts(tok, '.') > 1) {
+      PUSH_ERROR_AND_RETURN_TAG(
+          kAscii, fmt::format("Attribute identifier `{}` containing multiple "
+                              "`.` is not allowed.",
+                              tok));
     }
   }
 
   (*token) = ss.str();
   DCOUT("primAttr identifier = " << (*token));
   return true;
 }
@@ -2588,44 +1751,44 @@
 bool AsciiParser::ReadIdentifier(std::string *token) {
   // identifier = (`_` | [a-zA-Z]) (`_` | [a-zA-Z0-9]+)
   std::stringstream ss;
 
   // The first character.
   {
     char c;
-    if (!_sr->read1(&c)) {
+    if (!Char1(&c)) {
       // this should not happen.
       DCOUT("read1 failed.");
       return false;
     }
 
     if (c == '_') {
       // ok
     } else if (!std::isalpha(int(c))) {
-      DCOUT("Invalid identiefier.");
+      DCOUT(fmt::format("Invalid identiefier: '{}'", c));
       _sr->seek_from_current(-1);
       return false;
     }
     _curr_cursor.col++;
 
     ss << c;
   }
 
-  while (!_sr->eof()) {
+  while (!Eof()) {
     char c;
-    if (!_sr->read1(&c)) {
+    if (!Char1(&c)) {
       // this should not happen.
       return false;
     }
 
     if (c == '_') {
       // ok
     } else if (!std::isalnum(int(c))) {
       _sr->seek_from_current(-1);
-      break; // end of identifier(e.g. ' ')
+      break;  // end of identifier(e.g. ' ')
     }
 
     _curr_cursor.col++;
 
     ss << c;
   }
 
@@ -2641,27 +1804,19 @@
     return false;
   }
 
   if (!SkipWhitespace()) {
     return false;
   }
 
-  // Must start with '/'
-  if (!Expect('/')) {
-    PushError("Path identifier must start with '/'");
-    return false;
-  }
-
-  ss << '/';
-
   // read until '>'
   bool ok = false;
-  while (!_sr->eof()) {
+  while (!Eof()) {
     char c;
-    if (!_sr->read1(&c)) {
+    if (!Char1(&c)) {
       // this should not happen.
       return false;
     }
 
     if (c == '>') {
       // end
       ok = true;
@@ -2680,28 +1835,28 @@
   (*path_identifier) = TrimString(ss.str());
   // std::cout << "PathIdentifier: " << (*path_identifier) << "\n";
 
   return true;
 }
 
 bool AsciiParser::SkipUntilNewline() {
-  while (!_sr->eof()) {
+  while (!Eof()) {
     char c;
-    if (!_sr->read1(&c)) {
+    if (!Char1(&c)) {
       // this should not happen.
       return false;
     }
 
     if (c == '\n') {
       break;
     } else if (c == '\r') {
       // CRLF?
       if (_sr->tell() < (_sr->size() - 1)) {
         char d;
-        if (!_sr->read1(&d)) {
+        if (!Char1(&d)) {
           // this should not happen.
           return false;
         }
 
         if (d == '\n') {
           break;
         }
@@ -2725,25 +1880,37 @@
   return true;
 }
 
 // metadata_opt := string_literal '\n'
 //              |  var '=' value '\n'
 //
 bool AsciiParser::ParseStageMetaOpt() {
+  // Maybe string-only comment.
+  // Comment cannot have multiple lines. The last one wins
+  {
+    value::StringData str;
+    if (MaybeTripleQuotedString(&str)) {
+      _stage_metas.comment = str;
+      return true;
+    } else if (MaybeString(&str)) {
+      _stage_metas.comment = str;
+      return true;
+    }
+  }
 
   std::string varname;
   if (!ReadIdentifier(&varname)) {
     return false;
   }
 
   DCOUT("varname = " << varname);
 
   if (!IsStageMeta(varname)) {
     std::string msg = "'" + varname + "' is not a Stage Metadata variable.\n";
-    PushError(msg);
+    PUSH_ERROR_AND_RETURN(msg);
     return false;
   }
 
   if (!Expect('=')) {
     PUSH_ERROR_AND_RETURN("'=' expected in Stage Metadata opt.");
     return false;
   }
@@ -2751,276 +1918,228 @@
   if (!SkipWhitespace()) {
     return false;
   }
 
   const VariableDef &vardef = _supported_stage_metas.at(varname);
   MetaVariable var;
   if (!ParseMetaValue(vardef, &var)) {
-    PushError("Failed to parse meta value.\n");
+    PUSH_ERROR_AND_RETURN("Failed to parse meta value.\n");
     return false;
   }
+  var.set_name(varname);
 
-  if (varname == "defaultPrim" ) {
-    if (auto pv = var.value.get_value<std::string>()) {
-      DCOUT("defaultPrim = " << pv.value());
-      _stage_metas.defaultPrim = pv.value();
+  if (varname == "defaultPrim") {
+    value::token tok;
+    if (var.get_value(&tok)) {
+      DCOUT("defaultPrim = " << tok);
+      _stage_metas.defaultPrim = tok;
     } else {
-      PUSH_ERROR_AND_RETURN("`defaultPrim` isn't a string value.");
+      PUSH_ERROR_AND_RETURN("`defaultPrim` isn't a token value.");
     }
   } else if (varname == "subLayers") {
-    if (auto pv = var.value.get_value<std::vector<std::string>>()) {
-      DCOUT("subLayers = " << pv.value());
-      for (const auto &item : pv.value()) {
-          _stage_metas.subLayers.push_back(item);
+    std::vector<value::AssetPath> paths;
+    if (var.get_value(&paths)) {
+      DCOUT("subLayers = " << paths);
+      for (const auto &item : paths) {
+        _stage_metas.subLayers.push_back(item);
       }
     } else {
-      PUSH_ERROR_AND_RETURN("`subLayers` isn't an array of string values.");
+      PUSH_ERROR_AND_RETURN("`subLayers` isn't an array of asset path");
     }
   } else if (varname == "upAxis") {
-    if (auto pv = var.value.get_value<std::string>()) {
+    if (auto pv = var.get_value<value::token>()) {
       DCOUT("upAxis = " << pv.value());
-      const std::string s = pv.value();
+      const std::string s = pv.value().str();
       if (s == "X") {
         _stage_metas.upAxis = Axis::X;
       } else if (s == "Y") {
         _stage_metas.upAxis = Axis::Y;
       } else if (s == "Z") {
         _stage_metas.upAxis = Axis::Z;
       } else {
-        PUSH_ERROR_AND_RETURN("Invalid `upAxis` value. Must be \"X\", \"Y\" or \"Z\", but got \"" + s + "\"(Note: Case sensitive)");
+        PUSH_ERROR_AND_RETURN(
+            "Invalid `upAxis` value. Must be \"X\", \"Y\" or \"Z\", but got "
+            "\"" +
+            s + "\"(Note: Case sensitive)");
       }
     } else {
-      PUSH_ERROR_AND_RETURN("`upAxis` isn't a string value.");
-    }
-  } else if (varname == "doc") {
-    if (auto pv = var.value.get_value<std::string>()) {
-      DCOUT("doc = " << pv.value());
+      PUSH_ERROR_AND_RETURN("`upAxis` isn't a token value.");
+    }
+  } else if ((varname == "doc") || (varname == "documentation")) {
+    // `documentation` will be shorten to `doc`
+    if (auto pv = var.get_value<value::StringData>()) {
+      DCOUT("doc = " << to_string(pv.value()));
       _stage_metas.doc = pv.value();
+    } else if (auto pvs = var.get_value<std::string>()) {
+      value::StringData sdata;
+      sdata.value = pvs.value();
+      sdata.is_triple_quoted = false;
+      _stage_metas.doc = sdata;
     } else {
-      PUSH_ERROR_AND_RETURN("`doc` isn't a string value.");
+      PUSH_ERROR_AND_RETURN(fmt::format("`{}` isn't a string value.", varname));
     }
   } else if (varname == "metersPerUnit") {
-    DCOUT("ty = " << var.value.type_name());
-    if (auto pv = var.value.get_value<float>()) {
+    DCOUT("ty = " << var.type_name());
+    if (auto pv = var.get_value<float>()) {
       DCOUT("metersPerUnit = " << pv.value());
       _stage_metas.metersPerUnit = double(pv.value());
-    } else if (auto pvd = var.value.get_value<double>()) {
+    } else if (auto pvd = var.get_value<double>()) {
       DCOUT("metersPerUnit = " << pvd.value());
       _stage_metas.metersPerUnit = pvd.value();
     } else {
       PUSH_ERROR_AND_RETURN("`metersPerUnit` isn't a floating-point value.");
     }
   } else if (varname == "timeCodesPerSecond") {
-    DCOUT("ty = " << var.value.type_name());
-    if (auto pv = var.value.get_value<float>()) {
+    DCOUT("ty = " << var.type_name());
+    if (auto pv = var.get_value<float>()) {
       DCOUT("metersPerUnit = " << pv.value());
       _stage_metas.timeCodesPerSecond = double(pv.value());
-    } else if (auto pvd = var.value.get_value<double>()) {
+    } else if (auto pvd = var.get_value<double>()) {
       DCOUT("metersPerUnit = " << pvd.value());
       _stage_metas.timeCodesPerSecond = pvd.value();
     } else {
-      PUSH_ERROR_AND_RETURN("`timeCodesPerSecond` isn't a floating-point value.");
+      PUSH_ERROR_AND_RETURN(
+          "`timeCodesPerSecond` isn't a floating-point value.");
     }
-  } else {
-    DCOUT("TODO: Stage meta: " << varname);
-    PUSH_WARN("TODO: Stage meta: " << varname);
-  }
-
-
-#if 0 // Load subLayers in usda-reader
-  // Load subLayers
-  if (sublayers.size()) {
-    // Create another USDA parser.
-
-    for (size_t i = 0; i < sublayers.size(); i++) {
-      std::string filepath = io::JoinPath(_base_dir, sublayers[i]);
-
-      std::vector<uint8_t> data;
-      std::string err;
-      if (!io::ReadWholeFile(&data, &err, filepath, /* max_filesize */ 0)) {
-        PUSH_ERROR_AND_RETURN("Failed to read file: " + filepath);
-      }
-
-      tinyusdz::StreamReader sr(data.data(), data.size(),
-                                /* swap endian */ false);
-      tinyusdz::ascii::AsciiParser parser(&sr);
-
-      std::string base_dir = io::GetBaseDir(filepath);
-
-      parser.SetBaseDir(base_dir);
-
-      {
-        bool ret = parser.Parse(tinyusdz::ascii::LOAD_STATE_SUBLAYER);
-
-        if (!ret) {
-          PUSH_WARN("Failed to parse .usda: " << parser.GetError());
+  } else if (varname == "startTimeCode") {
+    if (auto pv = var.get_value<float>()) {
+      DCOUT("startTimeCode = " << pv.value());
+      _stage_metas.startTimeCode = double(pv.value());
+    } else if (auto pvd = var.get_value<double>()) {
+      DCOUT("startTimeCode = " << pvd.value());
+      _stage_metas.startTimeCode = pvd.value();
+    }
+  } else if (varname == "endTimeCode") {
+    if (auto pv = var.get_value<float>()) {
+      DCOUT("endTimeCode = " << pv.value());
+      _stage_metas.endTimeCode = double(pv.value());
+    } else if (auto pvd = var.get_value<double>()) {
+      DCOUT("endTimeCode = " << pvd.value());
+      _stage_metas.endTimeCode = pvd.value();
+    }
+  } else if (varname == "framesPerSecond") {
+    if (auto pv = var.get_value<float>()) {
+      DCOUT("framesPerSecond = " << pv.value());
+      _stage_metas.framesPerSecond = double(pv.value());
+    } else if (auto pvd = var.get_value<double>()) {
+      DCOUT("framesPerSecond = " << pvd.value());
+      _stage_metas.framesPerSecond = pvd.value();
+    }
+  } else if (varname == "apiSchemas") {
+    // TODO: ListEdit qualifer check
+    if (auto pv = var.get_value<std::vector<value::token>>()) {
+      for (auto &item : pv.value()) {
+        if (IsSupportedAPISchema(item.str())) {
+          // OK
+        } else {
+          PUSH_ERROR_AND_RETURN("\"" << item.str()
+                                     << "\" is not supported(at the moment) "
+                                        "for `apiSchemas` in TinyUSDZ.");
         }
       }
+    } else {
+      PUSH_ERROR_AND_RETURN("`apiSchemas` isn't an `token[]` type.");
     }
-
-    // TODO: Merge/Import subLayer.
-  }
-#endif
-
-#if 0 // TODO
-    if (var.type == "string") {
-      std::string value;
-      std::cout << "read string literal\n";
-      if (!ReadStringLiteral(&value)) {
-        std::string msg = "String literal expected for `" + var.name + "`.\n";
-        PushError(msg);
-        return false;
-      }
-    } else if (var.type == "int[]") {
-      std::vector<int> values;
-      if (!ParseBasicTypeArray<int>(&values)) {
-        // std::string msg = "Array of int values expected for `" + var.name +
-        // "`.\n"; PushError(msg);
-        return false;
-      }
-
-      for (size_t i = 0; i < values.size(); i++) {
-        std::cout << "int[" << i << "] = " << values[i] << "\n";
-      }
-    } else if (var.type == "float[]") {
-      std::vector<float> values;
-      if (!ParseBasicTypeArray<float>(&values)) {
-        return false;
-      }
-
-      for (size_t i = 0; i < values.size(); i++) {
-        std::cout << "float[" << i << "] = " << values[i] << "\n";
-      }
-    } else if (var.type == "float3[]") {
-      std::vector<std::array<float, 3>> values;
-      if (!ParseTupleArray<float, 3>(&values)) {
-        return false;
-      }
-
-      for (size_t i = 0; i < values.size(); i++) {
-        std::cout << "float[" << i << "] = " << values[i][0] << ", "
-                  << values[i][1] << ", " << values[i][2] << "\n";
-      }
-    } else if (var.type == "float") {
-      std::string fval;
-      std::string ferr;
-      if (!LexFloat(&fval, &ferr)) {
-        std::string msg =
-            "Floating point literal expected for `" + var.name + "`.\n";
-        if (!ferr.empty()) {
-          msg += ferr;
-        }
-        PushError(msg);
-        return false;
-      }
-      std::cout << "float : " << fval << "\n";
-      float value;
-      if (!ParseFloat(fval, &value, &ferr)) {
-        std::string msg =
-            "Failed to parse floating point literal for `" + var.name + "`.\n";
-        if (!ferr.empty()) {
-          msg += ferr;
-        }
-        PushError(msg);
-        return false;
-      }
-      std::cout << "parsed float : " << value << "\n";
-
-    } else if (var.type == "int3") {
-      std::array<int, 3> values;
-      if (!ParseBasicTypeTuple<int, 3>(&values)) {
-        // std::string msg = "Array of int values expected for `" + var.name +
-        // "`.\n"; PushError(msg);
-        return false;
-      }
-
-      for (size_t i = 0; i < values.size(); i++) {
-        std::cout << "int[" << i << "] = " << values[i] << "\n";
-      }
-    } else if (var.type == "object") {
-      // TODO: support nested parameter.
+  } else if (varname == "customLayerData") {
+    if (auto pv = var.get_value<CustomDataType>()) {
+      _stage_metas.customLayerData = pv.value();
+    } else {
+      PUSH_ERROR_AND_RETURN("`customLayerData` isn't a dictionary value.");
+    }
+  } else if (varname == "comment") {
+    if (auto pv = var.get_value<value::StringData>()) {
+      DCOUT("comment = " << to_string(pv.value()));
+      _stage_metas.comment = pv.value();
+    } else if (auto pvs = var.get_value<std::string>()) {
+      value::StringData sdata;
+      sdata.value = pvs.value();
+      sdata.is_triple_quoted = false;
+      _stage_metas.comment = sdata;
+    } else {
+      PUSH_ERROR_AND_RETURN(fmt::format("`{}` isn't a string value.", varname));
     }
-#endif
+  } else {
+    DCOUT("TODO: Stage meta: " << varname);
+    PUSH_WARN("TODO: Stage meta: " << varname);
+  }
 
   return true;
 }
 
 // Parse Stage meta
 // meta = ( metadata_opt )
 //      ;
 bool AsciiParser::ParseStageMetas() {
-
   if (!Expect('(')) {
     return false;
   }
 
-  if (!SkipWhitespaceAndNewline()) {
+  if (!SkipCommentAndWhitespaceAndNewline()) {
     return false;
   }
 
-  while (!_sr->eof()) {
+  while (!Eof()) {
     char c;
     if (!LookChar1(&c)) {
       return false;
     }
 
     if (c == ')') {
       if (!SeekTo(CurrLoc() + 1)) {
         return false;
       }
 
-      if (!SkipWhitespaceAndNewline()) {
+      if (!SkipCommentAndWhitespaceAndNewline()) {
         return false;
       }
 
       DCOUT("Stage metas end");
 
       // end
       return true;
 
     } else {
-      DCOUT("aaa not");
       if (!SkipWhitespace()) {
         // eof
         return false;
       }
 
       if (!ParseStageMetaOpt()) {
         // parse error
         return false;
       }
     }
 
-    if (!SkipWhitespaceAndNewline()) {
+    if (!SkipCommentAndWhitespaceAndNewline()) {
       return false;
     }
   }
 
   DCOUT("ParseStageMetas end");
   return true;
 }
 
 // `#` style comment
 bool AsciiParser::ParseSharpComment() {
   char c;
-  if (!_sr->read1(&c)) {
+  if (!Char1(&c)) {
     // eol
     return false;
   }
 
   if (c != '#') {
     return false;
   }
 
   return true;
 }
 
 // Fetch 1 char. Do not change input stream position.
 bool AsciiParser::LookChar1(char *c) {
-  if (!_sr->read1(c)) {
+  if (!Char1(c)) {
     return false;
   }
 
   Rewind(1);
 
   return true;
 }
@@ -3060,25 +2179,27 @@
   }
 
   return true;
 }
 
 uint64_t AsciiParser::CurrLoc() { return _sr->tell(); }
 
-bool AsciiParser::SeekTo(size_t pos) {
+bool AsciiParser::SeekTo(uint64_t pos) {
   if (!_sr->seek_set(pos)) {
     return false;
   }
 
   return true;
 }
 
 bool AsciiParser::PushParserState() {
   // Stack size must be less than the number of input bytes.
-  assert(parse_stack.size() < _sr->size());
+  if (parse_stack.size() >= _sr->size()) {
+    PUSH_ERROR_AND_RETURN_TAG(kAscii, "Parser state stack become too deep.");
+  }
 
   uint64_t loc = _sr->tell();
 
   ParseState state;
   state.loc = int64_t(loc);
   parse_stack.push(state);
 
@@ -3094,17 +2215,17 @@
 
   parse_stack.pop();
 
   return true;
 }
 
 bool AsciiParser::SkipWhitespace() {
-  while (!_sr->eof()) {
+  while (!Eof()) {
     char c;
-    if (!_sr->read1(&c)) {
+    if (!Char1(&c)) {
       // this should not happen.
       return false;
     }
     _curr_cursor.col++;
 
     if ((c == ' ') || (c == '\t') || (c == '\f')) {
       // continue
@@ -3118,36 +2239,40 @@
     return false;
   }
   _curr_cursor.col--;
 
   return true;
 }
 
-bool AsciiParser::SkipWhitespaceAndNewline() {
-  while (!_sr->eof()) {
+bool AsciiParser::SkipWhitespaceAndNewline(const bool allow_semicolon) {
+  // USDA also allow C-style ';' as a newline separator.
+  while (!Eof()) {
     char c;
-    if (!_sr->read1(&c)) {
+    if (!Char1(&c)) {
       // this should not happen.
       return false;
     }
 
     // printf("sws c = %c\n", c);
 
     if ((c == ' ') || (c == '\t') || (c == '\f')) {
       _curr_cursor.col++;
       // continue
+    } else if (allow_semicolon && (c == ';')) {
+      _curr_cursor.col++;
+      // continue
     } else if (c == '\n') {
       _curr_cursor.col = 0;
       _curr_cursor.row++;
       // continue
     } else if (c == '\r') {
       // CRLF?
       if (_sr->tell() < (_sr->size() - 1)) {
         char d;
-        if (!_sr->read1(&d)) {
+        if (!Char1(&d)) {
           // this should not happen.
           return false;
         }
 
         if (d == '\n') {
           // CRLF
         } else {
@@ -3169,40 +2294,44 @@
       break;
     }
   }
 
   return true;
 }
 
-bool AsciiParser::SkipCommentAndWhitespaceAndNewline() {
-  while (!_sr->eof()) {
+bool AsciiParser::SkipCommentAndWhitespaceAndNewline(const bool allow_semicolon) {
+  // Skip multiple line of comments.
+  while (!Eof()) {
     char c;
-    if (!_sr->read1(&c)) {
+    if (!Char1(&c)) {
       // this should not happen.
       return false;
     }
 
     // printf("sws c = %c\n", c);
 
     if (c == '#') {
       if (!SkipUntilNewline()) {
         return false;
       }
     } else if ((c == ' ') || (c == '\t') || (c == '\f')) {
       _curr_cursor.col++;
       // continue
+    } else if (allow_semicolon && (c == ';')) {
+      _curr_cursor.col++;
+      // continue
     } else if (c == '\n') {
       _curr_cursor.col = 0;
       _curr_cursor.row++;
       // continue
     } else if (c == '\r') {
       // CRLF?
       if (_sr->tell() < (_sr->size() - 1)) {
         char d;
-        if (!_sr->read1(&d)) {
+        if (!Char1(&d)) {
           // this should not happen.
           return false;
         }
 
         if (d == '\n') {
           // CRLF
         } else {
@@ -3231,281 +2360,43 @@
 
 bool AsciiParser::Expect(char expect_c) {
   if (!SkipWhitespace()) {
     return false;
   }
 
   char c;
-  if (!_sr->read1(&c)) {
+  if (!Char1(&c)) {
     // this should not happen.
     return false;
   }
 
   bool ret = (c == expect_c);
 
   if (!ret) {
     std::string msg = "Expected `" + std::string(&expect_c, 1) + "` but got `" +
                       std::string(&c, 1) + "`\n";
-    PushError(msg);
+    PUSH_ERROR_AND_RETURN(msg);
 
     // unwind
     _sr->seek_from_current(-1);
   } else {
     _curr_cursor.col++;
   }
 
   return ret;
 }
 
-//
-// -- impl ParseTimeSampleData
-//
-
-template<>
-value::TimeSamples AsciiParser::ConvertToTimeSamples(
-  const TimeSampleData<float> &ts) {
-
-  value::TimeSamples dst;
-
-  for (const auto &item : ts) {
-
-    dst.times.push_back(std::get<0>(item));
-
-    if (item.second) {
-      dst.values.push_back(item.second.value());
-    } else {
-      // Blocked.
-      dst.values.push_back(value::Block());
-    }
-  }
-
-  return dst;
-}
-
-#if 0
-template<>
-bool AsciiParser::ParseTimeSamples(
-    nonstd::optional<value::float2> *out_value) {
-  nonstd::optional<std::array<float, 2>> value;
-  if (!ParseBasicTypeTuple(&value)) {
-    return false;
-  }
-
-  (*out_value) = value;
-
-  return true;
-}
-
-template<>
-bool AsciiParser::ParseTimeSampleData(
-    nonstd::optional<value::float3> *out_value) {
-  nonstd::optional<std::array<float, 3>> value;
-  if (!ParseBasicTypeTuple(&value)) {
-    return false;
-  }
-
-  (*out_value) = value;
-
-  return true;
-}
-
-template<>
-bool AsciiParser::ParseTimeSampleData(
-    nonstd::optional<value::float4> *out_value) {
-  nonstd::optional<std::array<float, 4>> value;
-  if (!ParseBasicTypeTuple(&value)) {
-    return false;
-  }
-
-  (*out_value) = value;
-
-  return true;
-}
-
-template<>
-bool AsciiParser::ParseTimeSampleData(nonstd::optional<float> *out_value) {
-  nonstd::optional<float> value;
-  if (!ReadBasicType(&value)) {
-    return false;
-  }
-
-  (*out_value) = value;
-
-  return true;
-}
-
-template<>
-bool AsciiParser::ParseTimeSampleData(
-    nonstd::optional<double> *out_value) {
-  nonstd::optional<double> value;
-  if (!ReadBasicType(&value)) {
-    return false;
-  }
-
-  (*out_value) = value;
-
-  return true;
-}
-
-template<>
-bool AsciiParser::ParseTimeSampleData(
-    nonstd::optional<value::double2> *out_value) {
-  nonstd::optional<value::double2> value;
-  if (!ParseBasicTypeTuple(&value)) {
-    return false;
-  }
-
-  (*out_value) = value;
-
-  return true;
-}
-
-template<>
-bool AsciiParser::ParseTimeSampleData(
-    nonstd::optional<value::double3> *out_value) {
-  nonstd::optional<value::double3> value;
-  if (!ParseBasicTypeTuple(&value)) {
-    return false;
-  }
-
-  (*out_value) = value;
-
-  return true;
-}
-
-template<>
-bool AsciiParser::ParseTimeSampleData(
-    nonstd::optional<value::double4> *out_value) {
-  nonstd::optional<value::double4> value;
-  if (!ParseBasicTypeTuple(&value)) {
-    return false;
-  }
-
-  (*out_value) = value;
-
-  return true;
-}
-
-template<>
-bool AsciiParser::ParseTimeSampleData(
-    nonstd::optional<std::vector<value::float3>> *out_value) {
-  if (MaybeNone()) {
-    (*out_value) = nonstd::nullopt;
-    return true;
-  }
-
-  std::vector<std::array<float, 3>> value;
-  if (!ParseTupleArray(&value)) {
-    return false;
-  }
-
-  (*out_value) = value;
-
-  return true;
-}
-
-template<>
-bool AsciiParser::ParseTimeSampleData(
-    nonstd::optional<std::vector<value::double3>> *out_value) {
-  if (MaybeNone()) {
-    (*out_value) = nonstd::nullopt;
-    return true;
-  }
-
-  std::vector<std::array<double, 3>> value;
-  if (!ParseTupleArray(&value)) {
-    return false;
-  }
-
-  (*out_value) = value;
-
-  return true;
-}
-
-template<>
-bool AsciiParser::ParseTimeSampleData(
-    nonstd::optional<std::vector<float>> *out_value) {
-  if (MaybeNone()) {
-    (*out_value) = nonstd::nullopt;
-    return true;
-  }
-
-  std::vector<float> value;
-  if (!ParseBasicTypeArray(&value)) {
-    return false;
-  }
-
-  (*out_value) = value;
-
-  return true;
-}
-
-template<>
-bool AsciiParser::ParseTimeSampleData(
-    nonstd::optional<std::vector<double>> *out_value) {
-  if (MaybeNone()) {
-    (*out_value) = nonstd::nullopt;
-    return true;
-  }
-
-  std::vector<double> value;
-  if (!ParseBasicTypeArray(&value)) {
-    return false;
-  }
-
-  (*out_value) = value;
-
-  return true;
-}
-
-
-template<>
-bool AsciiParser::ParseTimeSampleData(
-    nonstd::optional<std::vector<value::matrix4d>> *out_value) {
-  if (MaybeNone()) {
-    (*out_value) = nonstd::nullopt;
-  }
-
-  std::vector<value::matrix4d> value;
-  if (!ParseBasicTypeArray(&value)) {
-    return false;
-  }
-
-  (*out_value) = value;
-
-  return true;
-}
-
-template<>
-bool AsciiParser::ParseTimeSampleData(
-    nonstd::optional<value::matrix4d> *out_value) {
-  if (MaybeNone()) {
-    (*out_value) = nonstd::nullopt;
-  }
-
-  value::matrix4d value;
-  if (!ReadBasicType(&value)) {
-    return false;
-  }
-
-  (*out_value) = value;
-
-
-  return true;
-}
-#endif
-
 // Parse magic
 // #usda FLOAT
 bool AsciiParser::ParseMagicHeader() {
   if (!SkipWhitespace()) {
     return false;
   }
 
-  if (_sr->eof()) {
+  if (Eof()) {
     return false;
   }
 
   {
     char magic[6];
     if (!_sr->read(6, 6, reinterpret_cast<uint8_t *>(magic))) {
       // eol
@@ -3516,16 +2407,14 @@
         (magic[3] == 'd') && (magic[4] == 'a') && (magic[5] == ' ')) {
       // ok
     } else {
       PUSH_ERROR_AND_RETURN(
           "Magic header must start with `#usda `(at least single whitespace "
           "after 'a') but got `" +
           std::string(magic, 6));
-
-      return false;
     }
   }
 
   if (!SkipWhitespace()) {
     // eof
     return false;
   }
@@ -3554,23 +2443,25 @@
 bool AsciiParser::ParseCustomMetaValue() {
   // type identifier '=' value
 
   // return ParseAttributeMeta();
   PUSH_ERROR_AND_RETURN("TODO");
 }
 
-// TODO: Return Path
-bool AsciiParser::ParseReference(Reference *out, bool *triple_deliminated) {
+bool AsciiParser::ParseAssetIdentifier(value::AssetPath *out,
+                                       bool *triple_deliminated) {
+  // '..' or "..." are also allowed.
   // @...@
-  // or @@@...@@@ (Triple '@'-deliminated asset references)
-  // And optionally followed by prim path.
+  // or @@@...@@@ (Triple '@'-deliminated asset identifier.)
+  // @@@ = Path containing '@'. '@@@' in Path is encoded as '\@@@'
+  //
   // Example:
   //   @bora@
   //   @@@bora@@@
-  //   @bora@</dora>
+  //   @@@bora\@@@dora@@@
 
   // TODO: Correctly support escape characters
 
   // look ahead.
   std::vector<char> buf;
   uint64_t curr = _sr->tell();
   bool maybe_triple{false};
@@ -3584,97 +2475,159 @@
       maybe_triple = true;
     }
   }
 
   bool valid{false};
 
   if (!maybe_triple) {
-    // std::cout << "maybe single-'@' asset reference\n";
+    // delimiter = " ' @
 
     SeekTo(curr);
     char s;
     if (!Char1(&s)) {
       return false;
     }
 
-    if (s != '@') {
+    char delim = s;
+
+    if ((s == '@') || (s == '\'') || (s == '"')) {
+      // ok
+    } else {
       std::string sstr{s};
-      PUSH_ERROR_AND_RETURN("Reference must start with '@', but got '" + sstr +
+      PUSH_ERROR_AND_RETURN("Asset must start with '@', '\'' or '\"', but got '" + sstr +
                             "'");
     }
 
     std::string tok;
 
-    // Read until '@'
+    // Read until next delimiter
     bool found_delimiter = false;
-    while (!_sr->eof()) {
+    while (!Eof()) {
       char c;
 
       if (!Char1(&c)) {
         return false;
       }
 
-      if (c == '@') {
+      if (c == delim) {
         found_delimiter = true;
         break;
       }
 
       tok += c;
     }
 
     if (found_delimiter) {
-      out->asset_path = tok;
+      (*out) = tok;
       (*triple_deliminated) = false;
 
       valid = true;
     }
 
   } else {
     bool found_delimiter{false};
+    bool escape_sequence{false};
     int at_cnt{0};
     std::string tok;
 
     // Read until '@@@' appears
-    while (!_sr->eof()) {
+    // Need to escaped '@@@'("\\@@@")
+    while (!Eof()) {
       char c;
 
       if (!Char1(&c)) {
         return false;
       }
 
+      if (c == '\\') {
+        escape_sequence = true;
+      }
+
       if (c == '@') {
         at_cnt++;
       } else {
         at_cnt--;
         if (at_cnt < 0) {
           at_cnt = 0;
         }
       }
 
       tok += c;
 
       if (at_cnt == 3) {
-        // Got it. '@@@'
-        found_delimiter = true;
-        break;
+        if (escape_sequence) {
+          // Still in path identifier...
+          // Unescape "\\@@@"
+
+          if (tok.size() > 3) {            // this should be true.
+            if (endsWith(tok, "\\@@@")) {  // this also should be true.
+              tok.erase(tok.size() - 4);
+              tok.append("@@@");
+            }
+          }
+          at_cnt = 0;
+          escape_sequence = false;
+        } else {
+          // Got it. '@@@'
+          found_delimiter = true;
+          break;
+        }
       }
     }
 
     if (found_delimiter) {
-      out->asset_path = tok;
+      // remote last '@@@'
+      (*out) = removeSuffix(tok, "@@@");
       (*triple_deliminated) = true;
 
       valid = true;
     }
   }
 
-  if (!valid) {
+  return valid;
+}
+
+// TODO: Return Path
+bool AsciiParser::ParseReference(Reference *out, bool *triple_deliminated) {
+  /*
+    Asset reference = AsssetIdentifier + optially followd by prim path
+
+    AssetIdentifier could be empty(self-reference?)
+
+    Example:
+     "bora"
+     @bora@
+     @bora@</dora>
+     </bora>
+  */
+
+  if (!SkipWhitespaceAndNewline()) {
     return false;
   }
 
+  // Parse AssetIdentifier
+  {
+    char nc;
+    if (!LookChar1(&nc)) {
+      return false;
+    }
+
+    if (nc == '<') {
+      // No Asset Identifier.
+      out->asset_path = value::AssetPath("");
+    } else {
+
+      value::AssetPath ap;
+      if (!ParseAssetIdentifier(&ap, triple_deliminated)) {
+        PUSH_ERROR_AND_RETURN_TAG(kAscii, "Failed to parse asset path identifier.");
+      }
+      out->asset_path = ap;
+    }
+  }
+
   // Parse optional prim_path
   if (!SkipWhitespace()) {
     return false;
   }
 
   {
     char c;
@@ -3688,190 +2641,425 @@
       }
 
       std::string path;
       if (!ReadPathIdentifier(&path)) {
         return false;
       }
 
-      out->prim_path = path;
+      out->prim_path = Path(path, "");
     } else {
       if (!Rewind(1)) {
         return false;
       }
     }
   }
 
   return true;
 }
 
-bool AsciiParser::ParseMetaValue(const VariableDef &def,
-                                 MetaVariable *outvar) {
-  const std::string vartype = def.type;
+bool AsciiParser::ParseMetaValue(const VariableDef &def, MetaVariable *outvar) {
+  std::string vartype = def.type;
   const std::string varname = def.name;
 
   MetaVariable var;
 
+  bool array_qual{false};
+
+  if (endsWith(vartype, "[]")) {
+    vartype = removeSuffix(vartype, "[]");
+    array_qual = true;
+  } else if (def.allow_array_type) { // variable can be array
+    // Seek '['
+    char c;
+    if (LookChar1(&c)) {
+      if (c == '[') {
+        array_qual = true;
+      }
+    }
+  }
+
+
+
+#if 0
   // TODO: Refactor.
   if (vartype == value::kBool) {
     bool value;
     if (!ReadBasicType(&value)) {
       PUSH_ERROR_AND_RETURN("Boolean value expected for `" + varname + "`.");
     }
     DCOUT("bool = " << value);
 
-    var.value = value;
-  } else if (vartype == value::kString) {
+    var.set_value(value);
+  } else if (vartype == value::kToken) {
+    if (is_array_type) {
+      std::vector<value::token> value;
+      if (!ParseBasicTypeArray(&value)) {
+        PUSH_ERROR_AND_RETURN_TAG(
+            kAscii, fmt::format("token[] expected for `{}`.", varname));
+      }
+      DCOUT("token[] = " << value);
 
-    std::string value;
-    DCOUT("parse meta = " << value);
-    if (!ReadStringLiteral(&value)) {
-      std::string msg = "String literal expected for `" + varname + "`.\n";
-      PushError(msg);
+      var.set_value(value);
+    } else {
+      value::token value;
+      if (!ReadBasicType(&value)) {
+        std::string msg = "Token expected for `" + varname + "`.\n";
+        PUSH_ERROR_AND_RETURN(msg);
+        return false;
+      }
+      DCOUT("token = " << value);
+
+      var.set_value(value);
+    }
+#if 0
+  } else if (vartype == "token[]") {
+    std::vector<value::token> value;
+    if (!ParseBasicTypeArray(&value)) {
+      std::string msg = "Token array expected for `" + varname + "`.\n";
+      PUSH_ERROR_AND_RETURN(msg);
       return false;
     }
-    DCOUT("string = " << value);
+    // TODO
+    // DCOUT("token[] = " << to_string(value));
 
-    auto ret = def.post_parse_handler(value);
-    if (!ret) {
-      DCOUT("error = " << ret.error());
-      PUSH_ERROR_AND_RETURN("Invalid string for `" + varname + "`. " + ret.error());
-    }
+    var.set_value(value);
+#endif
+  } else if (vartype == value::kString) {
+    if (is_array_type) {
+      std::vector<value::StringData> value;
+      if (!ParseBasicTypeArray(&value)) {
+        PUSH_ERROR_AND_RETURN_TAG(
+            kAscii, fmt::format("string[] expected for `{}`.", varname));
+      }
+      DCOUT("string[] = " << value);
 
-    var.value = value;
-  } else if (vartype == "string[]") {
-    std::vector<std::string> values;
-    if (!ParseBasicTypeArray(&values)) {
-      return false;
+      var.set_value(value);
+    } else {
+      value::StringData sdata;
+      if (MaybeTripleQuotedString(&sdata)) {
+        var.set_value(sdata);
+      } else {
+        std::string value;
+        if (!ReadStringLiteral(&value)) {
+          PUSH_ERROR_AND_RETURN("String literal expected for `" + varname + "`.");
+        }
+        var.set_value(value);
+      }
     }
 
-    var.value = values;
+#if 0 // no ref
   } else if (vartype == "ref[]") {
     std::vector<Reference> values;
     if (!ParseBasicTypeArray(&values)) {
       PUSH_ERROR_AND_RETURN("Array of Reference expected for `" + varname +
                             "`.");
     }
 
-    var.value = values;
+    var.set_value(values);
 
+#endif
   } else if (vartype == "int[]") {
-    std::vector<int> values;
-    if (!ParseBasicTypeArray<int>(&values)) {
+    std::vector<int32_t> values;
+    if (!ParseBasicTypeArray(&values)) {
       // std::string msg = "Array of int values expected for `" + var.name +
-      // "`.\n"; PushError(msg);
+      // "`.\n"; PUSH_ERROR_AND_RETURN(msg);
       return false;
     }
 
     for (size_t i = 0; i < values.size(); i++) {
       DCOUT("int[" << i << "] = " << values[i]);
     }
 
-    var.value = values;
+    var.set_value(values);
   } else if (vartype == "float[]") {
     std::vector<float> values;
-    if (!ParseBasicTypeArray<float>(&values)) {
+    if (!ParseBasicTypeArray(&values)) {
       return false;
     }
 
-    var.value = values;
+    var.set_value(values);
+  } else if (vartype == "float2[]") {
+    std::vector<value::float2> values;
+    if (!ParseBasicTypeArray(&values)) {
+      return false;
+    }
+
+    var.set_value(values);
   } else if (vartype == "float3[]") {
-    std::vector<std::array<float, 3>> values;
-    if (!ParseTupleArray<float, 3>(&values)) {
+    std::vector<value::float3> values;
+    if (!ParseBasicTypeArray(&values)) {
       return false;
     }
 
-    var.value = values;
+    var.set_value(values);
+  } else if (vartype == "float4[]") {
+    std::vector<value::float4> values;
+    if (!ParseBasicTypeArray(&values)) {
+      return false;
+    }
+
+    var.set_value(values);
   } else if (vartype == "double[]") {
     std::vector<double> values;
-    if (!ParseBasicTypeArray<double>(&values)) {
+    if (!ParseBasicTypeArray(&values)) {
       return false;
     }
 
-    var.value = values;
+    var.set_value(values);
+  } else if (vartype == "double2[]") {
+    std::vector<value::double2> values;
+    if (!ParseBasicTypeArray(&values)) {
+      return false;
+    }
+
+    var.set_value(values);
   } else if (vartype == "double3[]") {
     std::vector<value::double3> values;
-    if (!ParseTupleArray(&values)) {
+    if (!ParseBasicTypeArray(&values)) {
       return false;
     }
 
-    var.value = values;
-  } else if (vartype == value::kFloat) {
-    std::string fval;
-    std::string ferr;
-    if (!LexFloat(&fval)) {
-      PUSH_ERROR_AND_RETURN("Floating point literal expected for `" + varname +
-                            "`.");
-    }
-    auto ret = ParseFloat(fval);
-    if (!ret) {
-      PUSH_ERROR_AND_RETURN("Failed to parse floating point literal for `" +
-                            varname + "`.");
+    var.set_value(values);
+  } else if (vartype == "double4[]") {
+    std::vector<value::double4> values;
+    if (!ParseBasicTypeArray(&values)) {
+      return false;
     }
 
-    var.value = ret.value();
+    var.set_value(values);
+  } else if (vartype == value::kFloat) {
+    float value;
+    if (!ReadBasicType(&value)) {
+      return false;
+    }
+    var.set_value(value);
   } else if (vartype == value::kDouble) {
-    std::string fval;
-    std::string ferr;
-    if (!LexFloat(&fval)) {
-      PUSH_ERROR_AND_RETURN("Floating point literal expected for `" + varname +
-                            "`.");
+    double value;
+    if (!ReadBasicType(&value)) {
+      return false;
     }
-    auto ret = ParseDouble(fval);
-    if (!ret) {
-      PUSH_ERROR_AND_RETURN("Failed to parse floating point literal for `" +
-                            varname + "`.");
+    var.set_value(value);
+  } else if (vartype == "int2") {
+    value::int2 value;
+    if (!ReadBasicType(&value)) {
+      return false;
     }
 
-    var.value = ret.value();
+    var.set_value(value);
 
   } else if (vartype == "int3") {
-    std::array<int, 3> values;
-    if (!ParseBasicTypeTuple<int, 3>(&values)) {
-      // std::string msg = "Array of int values expected for `" + var.name +
-      // "`.\n"; PushError(msg);
+    value::int3 value;
+    if (!ReadBasicType(&value)) {
       return false;
     }
 
-    var.value = values;
-  } else if (vartype == value::kDictionary) {
-    DCOUT("dict type");
-    if (!Expect('{')) {
-      PushError("'{' expected.\n");
+    var.set_value(value);
+  } else if (vartype == "int4") {
+    value::int4 value;
+    if (!ReadBasicType(&value)) {
       return false;
     }
 
-    while (!_sr->eof()) {
-      if (!SkipWhitespaceAndNewline()) {
-        return false;
+    var.set_value(value);
+  } else if (vartype == value::kPath) {
+    if (is_array_type) {
+      std::vector<Path> paths;
+      if (!ParseBasicTypeArray(&paths)) {
+        PUSH_ERROR_AND_RETURN_TAG(
+            kAscii,
+            fmt::format("Failed to parse `{}` in Prim metadatum.", def.name));
+      }
+      var.set_value(paths);
+
+    } else {
+      Path path;
+      if (!ReadBasicType(&path)) {
+        PUSH_ERROR_AND_RETURN_TAG(
+            kAscii,
+            fmt::format("Failed to parse `{}` in Prim metadatum.", def.name));
+      }
+      var.set_value(path);
+    }
+
+  } else if (vartype == value::kAssetPath) {
+    if (is_array_type) {
+      std::vector<value::AssetPath> paths;
+      if (!ParseBasicTypeArray(&paths)) {
+        PUSH_ERROR_AND_RETURN_TAG(
+            kAscii,
+            fmt::format("Failed to parse `{}` in Prim metadataum.", def.name));
+      }
+      var.set_value(paths);
+    } else {
+      value::AssetPath asset_path;
+      if (!ReadBasicType(&asset_path)) {
+        PUSH_ERROR_AND_RETURN_TAG(
+            kAscii,
+            fmt::format("Failed to parse `{}` in Prim metadataum.", def.name));
+      }
+      var.set_value(asset_path);
+    }
+  } else if (vartype == "Reference") {
+    if (is_array_type) {
+      std::vector<Reference> refs;
+      if (!ParseBasicTypeArray(&refs)) {
+        PUSH_ERROR_AND_RETURN_TAG(
+            kAscii,
+            fmt::format("Failed to parse `{}` in Prim metadataum.", def.name));
+      }
+      var.set_value(refs);
+    } else {
+      nonstd::optional<Reference> ref;
+      if (!ReadBasicType(&ref)) {
+        PUSH_ERROR_AND_RETURN_TAG(
+            kAscii,
+            fmt::format("Failed to parse `{}` in Prim metadataum.", def.name));
       }
-
-      char c;
-      if (!Char1(&c)) {
-        return false;
+      if (ref) {
+        var.set_value(ref.value());
+      } else {
+        // None
+        var.set_value(value::ValueBlock());
       }
+    }
+  } else if (vartype == value::kDictionary) {
+    DCOUT("Parse dict in meta.");
+    CustomDataType dict;
+    if (!ParseDict(&dict)) {
+      PUSH_ERROR_AND_RETURN("Failed to parse `dictionary` data in metadataum.");
+    }
+    var.set_value(dict);
+  } else {
+    PUSH_ERROR_AND_RETURN("TODO: vartype = " + vartype);
+  }
+#else
 
-      if (c == '}') {
-        break;
+
+  // refactored version
+  uint32_t tyid = value::GetTypeId(vartype);
+
+#define PARSE_BASE_TYPE(__ty) case value::TypeTraits<__ty>::type_id(): { \
+    if (array_qual) { \
+      std::vector<__ty> vss; \
+      if (!ParseBasicTypeArray(&vss)) { \
+        PUSH_ERROR_AND_RETURN(fmt::format("Failed to parse a value of type `{}[]`", value::TypeTraits<__ty>::type_name())); \
+      } \
+      var.set_value(vss); \
+    } else { \
+      __ty val; \
+      if (!ReadBasicType(&val)) { \
+        PUSH_ERROR_AND_RETURN(fmt::format("Failed to parse a value of type `{}`", value::TypeTraits<__ty>::type_name())); \
+      } \
+      var.set_value(val); \
+    } \
+    break; \
+  }
+
+  // Special treatment for "Reference"
+  // FIXME: use assetPath for "Reference"?
+  if (vartype == "Reference") {
+    if (array_qual) {
+      std::vector<Reference> refs;
+      if (!ParseBasicTypeArray(&refs)) {
+        PUSH_ERROR_AND_RETURN_TAG(
+            kAscii,
+            fmt::format("Failed to parse `{}` in Prim metadataum.", def.name));
+      }
+      var.set_value(refs);
+    } else {
+      nonstd::optional<Reference> ref;
+      if (!ReadBasicType(&ref)) {
+        PUSH_ERROR_AND_RETURN_TAG(
+            kAscii,
+            fmt::format("Failed to parse `{}` in Prim metadataum.", def.name));
+      }
+      if (ref) {
+        var.set_value(ref.value());
       } else {
-        if (!Rewind(1)) {
-          return false;
+        // None
+        var.set_value(value::ValueBlock());
+      }
+    }
+  } else if (vartype == value::kPath) {
+    if (array_qual) {
+      std::vector<Path> paths;
+      if (!ParseBasicTypeArray(&paths)) {
+        PUSH_ERROR_AND_RETURN_TAG(
+            kAscii,
+            fmt::format("Failed to parse `{}` in Prim metadatum.", def.name));
+      }
+      var.set_value(paths);
+
+    } else {
+      Path path;
+      if (!ReadBasicType(&path)) {
+        PUSH_ERROR_AND_RETURN_TAG(
+            kAscii,
+            fmt::format("Failed to parse `{}` in Prim metadatum.", def.name));
+      }
+      var.set_value(path);
+    }
+  } else {
+    switch (tyid) {
+    APPLY_TO_METAVARIABLE_TYPE(PARSE_BASE_TYPE)
+    case value::TYPE_ID_STRING: {
+      if (array_qual) {
+        std::vector<std::string> strs;
+        if (!ParseBasicTypeArray(&strs)) {
+          PUSH_ERROR_AND_RETURN("Failed to parse `string[]`");
         }
-
-        if (!ParseCustomMetaValue()) {
-          PushError("Failed to parse meta definition.\n");
-          return false;
+        var.set_value(strs);
+      } else {
+        std::string str;
+        if (!ReadBasicType(&str)) {
+          PUSH_ERROR_AND_RETURN("Failed to parse `string`");
+        }
+        var.set_value(str);
+      }
+      break;
+    }
+    case value::TYPE_ID_ASSET_PATH: {
+      if (array_qual) {
+        std::vector<value::AssetPath> arrs;
+        if (!ParseBasicTypeArray(&arrs)) {
+          PUSH_ERROR_AND_RETURN("Failed to parse `asset[]`");
+        }
+        var.set_value(arrs);
+      } else {
+        value::AssetPath asset;
+        if (!ReadBasicType(&asset)) {
+          PUSH_ERROR_AND_RETURN("Failed to parse `asset`");
         }
+        var.set_value(asset);
       }
+      break;
     }
+    case value::TYPE_ID_DICT: {
+      CustomDataType dict;
 
-    PUSH_WARN("TODO: Implement object type(customData)");
-  } else {
-    PUSH_ERROR_AND_RETURN("TODO: vartype = " + vartype);
+      DCOUT("Parse dictionary");
+      if (!ParseDict(&dict)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse `dictionary`");
+      }
+      var.set_value(dict);
+      break;
+    }
+    default: {
+      std::string tyname = vartype;
+      if (array_qual) {
+        tyname += "[]";
+      }
+      PUSH_ERROR_AND_RETURN("Unsupported or invalid type for Metadatum:" + tyname);
+    }
+    }
   }
 
+#undef PARSE_BASE_TYPE
+#endif
+
   (*outvar) = var;
 
   return true;
 }
 
 bool AsciiParser::LexFloat(std::string *result) {
   // FLOATVAL : ('+' or '-')? FLOAT
@@ -3884,27 +3072,27 @@
 
   std::stringstream ss;
 
   bool has_sign{false};
   bool leading_decimal_dots{false};
   {
     char sc;
-    if (!_sr->read1(&sc)) {
+    if (!Char1(&sc)) {
       return false;
     }
     _curr_cursor.col++;
 
     ss << sc;
 
     // sign, '.' or [0-9]
     if ((sc == '+') || (sc == '-')) {
       has_sign = true;
 
       char c;
-      if (!_sr->read1(&c)) {
+      if (!Char1(&c)) {
         return false;
       }
 
       if (c == '.') {
         // ok. something like `+.7`, `-.53`
         leading_decimal_dots = true;
         _curr_cursor.col++;
@@ -3928,48 +3116,48 @@
   (void)has_sign;
 
   // 1. Read the integer part
   char curr;
   if (!leading_decimal_dots) {
     // std::cout << "1 read int part: ss = " << ss.str() << "\n";
 
-    while (!_sr->eof()) {
-      if (!_sr->read1(&curr)) {
+    while (!Eof()) {
+      if (!Char1(&curr)) {
         return false;
       }
 
       // std::cout << "1 curr = " << curr << "\n";
       if ((curr >= '0') && (curr <= '9')) {
         // continue
         ss << curr;
       } else {
         _sr->seek_from_current(-1);
         break;
       }
     }
   }
 
-  if (_sr->eof()) {
+  if (Eof()) {
     (*result) = ss.str();
     return true;
   }
 
-  if (!_sr->read1(&curr)) {
+  if (!Char1(&curr)) {
     return false;
   }
 
   // std::cout << "before 2: ss = " << ss.str() << ", curr = " << curr <<
   // "\n";
 
   // 2. Read the decimal part
   if (curr == '.') {
     ss << curr;
 
-    while (!_sr->eof()) {
-      if (!_sr->read1(&curr)) {
+    while (!Eof()) {
+      if (!Char1(&curr)) {
         return false;
       }
 
       if ((curr >= '0') && (curr <= '9')) {
         ss << curr;
       } else {
         break;
@@ -3981,25 +3169,25 @@
   } else {
     // end
     (*result) = ss.str();
     _sr->seek_from_current(-1);
     return true;
   }
 
-  if (_sr->eof()) {
+  if (Eof()) {
     (*result) = ss.str();
     return true;
   }
 
   // 3. Read the exponent part
   bool has_exp_sign{false};
   if ((curr == 'e') || (curr == 'E')) {
     ss << curr;
 
-    if (!_sr->read1(&curr)) {
+    if (!Char1(&curr)) {
       return false;
     }
 
     if ((curr == '+') || (curr == '-')) {
       // exp sign
       ss << curr;
       has_exp_sign = true;
@@ -4008,28 +3196,27 @@
       // ok
       ss << curr;
     } else {
       // Empty E is not allowed.
       PUSH_ERROR_AND_RETURN("Empty `E' is not allowed.");
     }
 
-    while (!_sr->eof()) {
-      if (!_sr->read1(&curr)) {
+    while (!Eof()) {
+      if (!Char1(&curr)) {
         return false;
       }
 
       if ((curr >= '0') && (curr <= '9')) {
         // ok
         ss << curr;
 
       } else if ((curr == '+') || (curr == '-')) {
         if (has_exp_sign) {
           // No multiple sign characters
           PUSH_ERROR_AND_RETURN("No multiple exponential sign characters.");
-          return false;
         }
 
         ss << curr;
         has_exp_sign = true;
       } else {
         // end
         _sr->seek_from_current(-1);
@@ -4049,15 +3236,33 @@
   if (_supported_stage_metas.count(name)) {
     return _supported_stage_metas.at(name);
   }
 
   return nonstd::nullopt;
 }
 
-bool AsciiParser::ParseStageMeta(std::tuple<ListEditQual, MetaVariable> *out) {
+nonstd::optional<AsciiParser::VariableDef> AsciiParser::GetPrimMetaDefinition(
+    const std::string &name) {
+  if (_supported_prim_metas.count(name)) {
+    return _supported_prim_metas.at(name);
+  }
+
+  return nonstd::nullopt;
+}
+
+nonstd::optional<AsciiParser::VariableDef> AsciiParser::GetPropMetaDefinition(
+    const std::string &name) {
+  if (_supported_prop_metas.count(name)) {
+    return _supported_prop_metas.at(name);
+  }
+
+  return nonstd::nullopt;
+}
+
+bool AsciiParser::ParseStageMeta(std::pair<ListEditQual, MetaVariable> *out) {
   if (!SkipCommentAndWhitespaceAndNewline()) {
     return false;
   }
 
   tinyusdz::ListEditQual qual{ListEditQual::ResetToExplicit};
   if (!MaybeListEditQual(&qual)) {
     return false;
@@ -4082,15 +3287,15 @@
   }
 
   if (!SkipWhitespaceAndNewline()) {
     return false;
   }
 
   if (!Expect('=')) {
-    PushError("`=` expected.");
+    PUSH_ERROR_AND_RETURN("`=` expected.");
     return false;
   }
 
   if (!SkipWhitespaceAndNewline()) {
     return false;
   }
 
@@ -4099,128 +3304,54 @@
     // This should not happen though;
     return false;
   }
 
   auto vardef = (*pvardef);
 
   MetaVariable var;
-  var.name = varname;
-
-  if (vardef.type == "path") {
-    std::string value;
-    if (!ReadPathIdentifier(&value)) {
-      PushError("Failed to parse path identifier");
-      return false;
-    }
-
-    var.value = value;
-
-  } else if (vardef.type == "path[]") {
-    std::vector<PathIdentifier> value;
-    if (!ParseBasicTypeArray(&value)) {
-      PushError("Failed to parse array of path identifier");
-
-      std::cout << __LINE__ << " ParsePathIdentifierArray failed\n";
-      return false;
-    }
-
-    // std::vector<Path> paths;
-    // MetaVariable::Array arr;
-    // for (const auto &v : value) {
-    //   std::cout << "  " << v << "\n";
-    //   MetaVariable _var;
-    //   _var.value = v;
-    //   arr.values.push_back(_var);
-    // }
-
-    // var.value = arr;
-    PUSH_ERROR_AND_RETURN("TODO: Implement");
-
-  } else if (vardef.type == "ref[]") {
-    std::vector<Reference> value;
-    if (!ParseBasicTypeArray(&value)) {
-      PushError("Failed to parse array of assert reference");
-
-      return false;
-    }
-
-    var.value = value;
-
-  } else if (vardef.type == "string") {
-    std::string value;
-    if (!ReadStringLiteral(&value)) {
-      std::cout << __LINE__ << " ReadStringLiteral failed\n";
-      return false;
-    }
-
-    std::cout << "vardef.type: " << vardef.type << ", name = " << varname
-              << "\n";
-    var.value = value;
-  } else if (vardef.type == "string[]") {
-    std::vector<std::string> value;
-    if (!ParseBasicTypeArray(&value)) {
-      PUSH_ERROR_AND_RETURN("ReadStringArray failed.");
-      return false;
-    }
-
-    DCOUT("vardef.type: " << vardef.type << ", name = " << varname);
-    var.value = value;
-
-  } else if (vardef.type == value::kBool) {
-    bool value;
-    if (!ReadBasicType(&value)) {
-      PUSH_ERROR_AND_RETURN("ReadBool failed.");
-    }
-
-    DCOUT("vardef.type: " << vardef.type << ", name = " << varname);
-    var.value = value;
-
-  } else {
-    PUSH_ERROR_AND_RETURN("TODO: varname " + varname + ", type " + vardef.type);
+  if (!ParseMetaValue(vardef, &var)) {
+    return false;
   }
+  var.set_name(varname);
 
   std::get<0>(*out) = qual;
   std::get<1>(*out) = var;
 
   return true;
 }
 
-#if 0
-nonstd::optional<AsciiParser::PrimMetas> AsciiParser::ReconstructPrimMetas(
-    std::map<std::string, std::tuple<ListEditQual, MetaVariable>> &args) {
-  PrimMetas metas;
-
-  {
-    auto it = args.find(kKind);
-    if (it != args.end()) {
-      if (auto s = std::get<1>(it->second).get_value<std::string>()) {
-      }
-
-      if (auto v = Kind::_from_string_nothrow() {
-        metas.kind = v.value();
-      } else {
-        return nonstd::nullopt;
-      }
-    }
+nonstd::optional<std::pair<ListEditQual, MetaVariable>>
+AsciiParser::ParsePrimMeta() {
+  if (!SkipCommentAndWhitespaceAndNewline()) {
+    return nonstd::nullopt;
   }
 
+  tinyusdz::ListEditQual qual{ListEditQual::ResetToExplicit};
 
-  return metas;
+  // May be string only(varname is "comment")
+  // For some reason, string-only data is just stored in `MetaVariable` and
+  // reconstructed in ReconstructPrimMeta in usda-reader.cc later
+  //
+  {
+    value::StringData sdata;
+    if (MaybeTripleQuotedString(&sdata)) {
+      MetaVariable var;
+      // empty name
+      var.set_value("comment", sdata);
 
-}
-#endif
+      return std::make_pair(qual, var);
 
-nonstd::optional<std::tuple<ListEditQual, MetaVariable>>
-AsciiParser::ParsePrimMeta() {
+    } else if (MaybeString(&sdata)) {
+      MetaVariable var;
+      var.set_value("comment", sdata);
 
-  if (!SkipCommentAndWhitespaceAndNewline()) {
-    return nonstd::nullopt;
+      return std::make_pair(qual, var);
+    }
   }
 
-  tinyusdz::ListEditQual qual{ListEditQual::ResetToExplicit};
   if (!MaybeListEditQual(&qual)) {
     return nonstd::nullopt;
   }
 
   DCOUT("list-edit qual: " << tinyusdz::to_string(qual));
 
   if (!SkipWhitespaceAndNewline()) {
@@ -4231,65 +3362,51 @@
   if (!ReadIdentifier(&varname)) {
     return nonstd::nullopt;
   }
 
   DCOUT("Identifier = " << varname);
 
   if (!IsPrimMeta(varname)) {
-    std::string msg = "'" + varname + "' is not a Prim Metadata variable.\n";
-    PushError(msg);
+    std::string msg = "'" + varname + "' is not a Prim Metadata variable.";
+    PUSH_ERROR(msg);
     return nonstd::nullopt;
   }
 
   if (!Expect('=')) {
-    PushError("'=' expected in Prim Metadata line.\n");
+    PUSH_ERROR("'=' expected in Prim Metadata line.");
     return nonstd::nullopt;
   }
   SkipWhitespace();
 
-  const VariableDef &vardef = _supported_prim_metas.at(varname);
-  MetaVariable var;
-  if (!ParseMetaValue(vardef, &var)) {
-    PushError("Failed to parse Prim meta value.\n");
+  if (auto pv = GetPrimMetaDefinition(varname)) {
+    MetaVariable var;
+    const auto vardef = pv.value();
+    if (!ParseMetaValue(vardef, &var)) {
+      PUSH_ERROR("Failed to parse Prim meta value.");
+      return nonstd::nullopt;
+    }
+    var.set_name(varname);
+
+    return std::make_pair(qual, var);
+  } else {
+    PUSH_ERROR(fmt::format("Unsupported/unimplemented PrimSpec metadata {}", varname));
     return nonstd::nullopt;
   }
 
-  return std::make_tuple(qual, var);
 }
 
 bool AsciiParser::ParsePrimMetas(
-    std::map<std::string, std::tuple<ListEditQual, MetaVariable>> *args) {
+    PrimMetaMap *args) {
   // '(' args ')'
   // args = list of argument, separated by newline.
 
-  if (!SkipWhitespaceAndNewline()) {
-    DCOUT("SkipWhitespaceAndNewline failed.");
+  if (!Expect('(')) {
     return false;
   }
 
-  // The first character.
-  {
-    char c;
-    if (!Char1(&c)) {
-      // this should not happen.
-      return false;
-    }
-
-    DCOUT("c = " << c);
-
-    if (c == '(') {
-      DCOUT("def args start");
-      // ok
-    } else {
-      _sr->seek_from_current(-1);
-      //DCOUT("Unknown c");
-      //return false;
-    }
-  }
-
   if (!SkipCommentAndWhitespaceAndNewline()) {
     // std::cout << "skip comment/whitespace/nl failed\n";
     DCOUT("SkipCommentAndWhitespaceAndNewline failed.");
     return false;
   }
 
   while (!Eof()) {
@@ -4300,29 +3417,34 @@
 
     char s;
     if (!Char1(&s)) {
       return false;
     }
 
     if (s == ')') {
-      DCOUT("def args end");
+      DCOUT("Prim meta end");
       // End
       break;
     }
 
     Rewind(1);
 
     DCOUT("Start PrimMeta parse.");
 
-    // ty = std::tuple<ListEditQual, MetaVariable>;
+    // ty = std::pair<ListEditQual, MetaVariable>;
     if (auto m = ParsePrimMeta()) {
-      DCOUT("arg: list-edit qual = " << tinyusdz::to_string(std::get<0>(m.value()))
-                                     << ", name = " << std::get<1>(m.value()).name);
+      DCOUT("PrimMeta: list-edit qual = "
+            << tinyusdz::to_string(std::get<0>(m.value()))
+            << ", name = " << std::get<1>(m.value()).get_name());
+
+      if (std::get<1>(m.value()).get_name().empty()) {
+        PUSH_ERROR_AND_RETURN("[InternalError] Metadataum name is empty.");
+      }
 
-      (*args)[std::get<1>(m.value()).name] = m.value();
+      (*args)[std::get<1>(m.value()).get_name()] = m.value();
     } else {
       PUSH_ERROR_AND_RETURN("Failed to parse Meta value.");
     }
   }
 
   return true;
 }
@@ -4335,100 +3457,164 @@
   if (!SkipWhitespace()) {
     return false;
   }
 
   // The first character.
   {
     char c;
-    if (!_sr->read1(&c)) {
+    if (!Char1(&c)) {
       // this should not happen.
       return false;
     }
 
     if (c == '(') {
       // ok
     } else {
       _sr->seek_from_current(-1);
 
       // Still ok. No meta
+      DCOUT("No attribute meta.");
       return true;
     }
   }
 
   if (!SkipWhitespaceAndNewline()) {
     return false;
   }
 
-  while (!_sr->eof()) {
+  while (!Eof()) {
     char c;
     if (!Char1(&c)) {
       return false;
     }
 
     if (c == ')') {
       // end meta
       break;
     } else {
       if (!Rewind(1)) {
         return false;
       }
 
-      std::string token;
-      if (!ReadIdentifier(&token)) {
-        return false;
+      // May be string only
+      {
+        value::StringData sdata;
+        if (MaybeTripleQuotedString(&sdata)) {
+          out_meta->stringData.push_back(sdata);
+
+          DCOUT("Add triple-quoted string to attr meta:" << to_string(sdata));
+          if (!SkipWhitespaceAndNewline()) {
+            return false;
+          }
+          continue;
+        } else if (MaybeString(&sdata)) {
+          out_meta->stringData.push_back(sdata);
+
+          DCOUT("Add string to attr meta:" << to_string(sdata));
+          if (!SkipWhitespaceAndNewline()) {
+            return false;
+          }
+          continue;
+        }
       }
 
-      if ((token != "interpolation") && (token != "customData") &&
-          (token != "elementSize")) {
-        PushError(
-            "Currently only `interpolation`, `elementSize` or `customData` "
-            "is supported but "
-            "got: " +
-            token);
+      std::string varname;
+      if (!ReadIdentifier(&varname)) {
         return false;
       }
 
+      DCOUT("Property/Attribute meta name: " << varname);
+
+      bool supported = _supported_prop_metas.count(varname);
+      if (!supported) {
+        PUSH_ERROR_AND_RETURN_TAG(kAscii,
+            fmt::format("Unsupported Property metadatum name: {}", varname));
+      }
+
       if (!SkipWhitespaceAndNewline()) {
         return false;
       }
 
       if (!Expect('=')) {
         return false;
       }
 
       if (!SkipWhitespaceAndNewline()) {
         return false;
       }
 
-      if (token == "interpolation") {
+      //
+      // First-class predefind prop metas.
+      //
+      if (varname == "interpolation") {
         std::string value;
         if (!ReadStringLiteral(&value)) {
           return false;
         }
 
+        DCOUT("Got `interpolation` meta : " << value);
         out_meta->interpolation = InterpolationFromString(value);
-      } else if (token == "elementSize") {
+      } else if (varname == "elementSize") {
         uint32_t value;
         if (!ReadBasicType(&value)) {
           PUSH_ERROR_AND_RETURN("Failed to parse `elementSize`");
         }
 
+        DCOUT("Got `elementSize` meta : " << value);
         out_meta->elementSize = value;
-      } else if (token == "customData") {
-        std::map<std::string, MetaVariable> dict;
+      } else if (varname == "colorSpace") {
+        value::token tok;
+        if (!ReadBasicType(&tok)) {
+          PUSH_ERROR_AND_RETURN("Failed to parse `colorSpace`");
+        }
+        // Add as custom meta value.
+        MetaVariable metavar;
+        metavar.set_value("colorSpace", tok);
+        out_meta->meta.emplace("colorSpace", metavar);
+      } else if (varname == "customData") {
+        CustomDataType dict;
 
         if (!ParseDict(&dict)) {
           return false;
         }
 
+        DCOUT("Got `customData` meta");
         out_meta->customData = dict;
 
+      } else if (varname == "bindMaterialAs") {
+        value::token tok;
+        if (!ReadBasicType(&tok)) {
+          PUSH_ERROR_AND_RETURN("Failed to parse `bindMaterialAs`");
+        }
+        if ((tok.str() == kWeaderThanDescendants) || (tok.str() == kStrongerThanDescendants)) {
+          // ok
+        } else {
+          // still valid though
+          PUSH_WARN("Unsupported token for bindMaterialAs: " << tok.str());
+        }
+        DCOUT("bindMaterialAs: " << tok);
+        out_meta->bindMaterialAs = tok;
       } else {
-        // ???
-        return false;
+        if (auto pv = GetPropMetaDefinition(varname)) {
+          // Parse as generic metadata variable
+          MetaVariable metavar;
+          const auto &vardef = pv.value();
+
+          if (!ParseMetaValue(vardef, &metavar)) {
+            return false;
+          }
+          metavar.set_name(varname);
+
+          // add to custom meta
+          out_meta->meta.emplace(varname, metavar);
+
+        } else {
+          // This should not happen though.
+          PUSH_ERROR_AND_RETURN_TAG(kAscii, fmt::format("[InternalErrror] Failed to parse Property metadataum `{}`", varname));
+        }
       }
 
       if (!SkipWhitespaceAndNewline()) {
         return false;
       }
     }
   }
@@ -4452,145 +3638,389 @@
 }
 
 //
 // -- Impl
 //
 
 ///
-/// Parse rel string
+/// Parse `rel`
 ///
-bool AsciiParser::ParseRel(Rel *result) {
-  PathIdentifier value;
-  if (!ReadBasicType(&value)) {
+bool AsciiParser::ParseRelationship(Relationship *result) {
+  char c;
+  if (!LookChar1(&c)) {
     return false;
   }
 
-  result->path = value;
+  if (c == '<') {
+    // Path
+    Path value;
+    if (!ReadBasicType(&value)) {
+      PUSH_ERROR_AND_RETURN("Failed to parse Path.");
+    }
+
+    // Resolve relative path here.
+    // NOTE: Internally, USD(Crate) does not allow relative path.
+    Path base_prim_path(GetCurrentPrimPath(), "");
+    Path abs_path;
+    std::string err;
+    if (!pathutil::ResolveRelativePath(base_prim_path, value, &abs_path, &err)) {
+      PUSH_ERROR_AND_RETURN(fmt::format("Invalid relative Path: {}. error = {}", value, err));
+    }
+
+    result->set(abs_path);
+  } else if (c == '[') {
+    // PathVector
+    std::vector<Path> values;
+    if (!ParseBasicTypeArray(&values)) {
+      PUSH_ERROR_AND_RETURN("Failed to parse PathVector.");
+    }
+
+    // Resolve relative path here.
+    // NOTE: Internally, USD(Crate) does not allow relative path.
+    for (size_t i = 0; i < values.size(); i++) {
+      Path base_prim_path(GetCurrentPrimPath(), "");
+      Path abs_path;
+      if (!pathutil::ResolveRelativePath(base_prim_path, values[i], &abs_path)) {
+        PUSH_ERROR_AND_RETURN(fmt::format("Invalid relative Path: {}.", values[i].full_path_name()));
+      }
+
+      // replace
+      values[i] = abs_path;
+    }
+
+    result->set(values);
+  } else if (c == 'N') {
+    // None
+    nonstd::optional<Path> value;
+    if (!ReadBasicType(&value)) {
+      PUSH_ERROR_AND_RETURN("Failed to parse None.");
+    }
+
+    // Should be empty.
+    if (value.has_value()) {
+      PUSH_ERROR_AND_RETURN("Failed to parse None.");
+    }
+
+    result->set_blocked();
+  } else {
+    PUSH_ERROR_AND_RETURN("Unexpected char \"" + std::to_string(c) +
+                          "\" found. Expects Path or PathVector.");
+  }
 
   if (!SkipWhitespaceAndNewline()) {
     return false;
   }
 
   return true;
 }
 
 template <typename T>
 bool AsciiParser::ParseBasicPrimAttr(bool array_qual,
                                      const std::string &primattr_name,
-                                     PrimAttrib *out_attr) {
-  PrimAttrib attr;
+                                     Attribute *out_attr) {
+  Attribute attr;
+  primvar::PrimVar var;
+  bool blocked{false};
 
   if (array_qual) {
-    if (value::TypeTrait<T>::type_name() == "bool") {
-      PushError("Array of bool type is not supported.");
-      return false;
+    if (MaybeNone()) {
     } else {
       std::vector<T> value;
       if (!ParseBasicTypeArray(&value)) {
         PUSH_ERROR_AND_RETURN("Failed to parse " +
-                  std::string(value::TypeTrait<T>::type_name()) + " array.");
-        return false;
+                              std::string(value::TypeTraits<T>::type_name()) +
+                              " array.");
       }
 
-      DCOUT("Got it: ty = " + std::string(value::TypeTrait<T>::type_name()) +
+      // Empty array allowed.
+      DCOUT("Got it: ty = " + std::string(value::TypeTraits<T>::type_name()) +
             ", sz = " + std::to_string(value.size()));
-      attr.var.set_scalar(value);
+      var.set_value(value);
     }
 
   } else if (hasConnect(primattr_name)) {
-    std::string value;  // TODO: Path
+    std::string value;  // TODO: Use Path
     if (!ReadPathIdentifier(&value)) {
-      PushError("Failed to parse path identifier for `token`.\n");
-      return false;
+      PUSH_ERROR_AND_RETURN("Failed to parse path identifier.");
     }
 
-    attr.var.set_scalar(value);  // TODO: set as `Path` type
+    // validate.
+    Path connectionPath = pathutil::FromString(value);
+    if (!connectionPath.is_valid()) {
+      PUSH_ERROR_AND_RETURN(fmt::format("Invalid connectionPath: {}.", value));
+    }
+
+    // Resolve relative path here.
+    // NOTE: Internally, USD(Crate) does not allow relative path.
+    Path base_prim_path(GetCurrentPrimPath(), "");
+    Path abs_path;
+    if (!pathutil::ResolveRelativePath(base_prim_path, connectionPath, &abs_path)) {
+      PUSH_ERROR_AND_RETURN(fmt::format("Invalid relative Path: {}.", value));
+    }
+
+    // TODO: Use Path
+    var.set_value(abs_path.full_path_name());
   } else {
     nonstd::optional<T> value;
     if (!ReadBasicType(&value)) {
-      PUSH_ERROR_AND_RETURN("Failed to parse " + std::string(value::TypeTrait<T>::type_name()));
-      return false;
+      PUSH_ERROR_AND_RETURN("Failed to parse " +
+                            std::string(value::TypeTraits<T>::type_name()));
     }
 
     if (value) {
-      DCOUT("ParseBasicPrimAttr: " << value::TypeTrait<T>::type_name() << " = "
+      DCOUT("ParseBasicPrimAttr: " << value::TypeTraits<T>::type_name() << " = "
                                    << (*value));
 
-      // TODO: TimeSampled
-      value::TimeSamples ts;
-      ts.values.push_back(*value);
-      attr.var.var = ts;
+      var.set_value(value.value());
 
     } else {
+      blocked = true;
       // std::cout << "ParseBasicPrimAttr: " <<
-      // value::TypeTrait<T>::type_name()
+      // value::TypeTraits<T>::type_name()
       //           << " = None\n";
     }
   }
 
-  // optional: interpolation parameter
+  // optional: attribute meta.
   AttrMeta meta;
   if (!ParseAttrMeta(&meta)) {
-    PUSH_ERROR_AND_RETURN("Failed to parse PrimAttrib meta.");
+    PUSH_ERROR_AND_RETURN("Failed to parse Attribute meta.");
   }
-  attr.meta = meta;
+  attr.metas() = meta;
 
-  // if (meta.count("interpolation")) {
-  //   const MetaVariable &var = meta.at("interpolation");
-  //   auto p = var.value.get_value<value::token>();
-  //   if (p) {
-  //     attr.interpolation =
-  //     tinyusdz::InterpolationFromString(p.value().str());
-  //   }
-  // }
+  if (blocked) {
+    // There is still have a type for ValueBlock.
+    value::ValueBlock noneval;
+    attr.set_value(noneval);
+    attr.set_blocked(true);
+    if (array_qual) {
+      attr.set_type_name(value::TypeTraits<T>::type_name() + "[]");
+    } else {
+      attr.set_type_name(value::TypeTraits<T>::type_name());
+    }
+  } else {
+    attr.set_var(std::move(var));
+  }
 
   (*out_attr) = std::move(attr);
 
   return true;
 }
 
-// bool ParsePrimAttr(std::map<std::string, MetaVariable> *props) {
-bool AsciiParser::ParsePrimAttr(std::map<std::string, Property> *props) {
-  // prim_attr : (custom?) uniform type (array_qual?) name '=' value
+bool AsciiParser::ParsePrimProps(std::map<std::string, Property> *props, std::vector<value::token> *propNames) {
+
+
+  // prim_prop : (custom?) (variability?) type (array_qual?) name '=' value
   //           | (custom?) type (array_qual?) name '=' value interpolation?
-  //           | (custom?) uniform type (array_qual?) name interpolation?
+  //           | (custom?) (variability?) type (array_qual?) name interpolation?
+  //           | (custom?) (listeditqual?) (variability?) rel attr_name = None
+  //           | (custom?) (listeditqual?) (variability?) rel attr_name = string meta
+  //           | (custom?) (listeditqual?) (variability?) rel attr_name = path meta
+  //           | (custom?) (listeditqual?) (variability?) rel attr_name = pathvector meta
+  //           | (custom?) (listeditqual?) (variability?) rel attr_name meta
   //           ;
 
+  // NOTE:
+  //  custom append varying ... is not allowed.
+  //  append varying custom ... is not allowed.
+  //  append custom varying ... is allowed(decomposed into `custom varying ...` and `append varying ...`
+
+  // Skip comment
+  if (!SkipCommentAndWhitespaceAndNewline()) {
+    return false;
+  }
+
+  // Parse `custom`
   bool custom_qual = MaybeCustom();
 
   if (!SkipWhitespace()) {
     return false;
   }
 
-  bool uniform_qual{false};
+  ListEditQual listop_qual;
+  if (!MaybeListEditQual(&listop_qual)) {
+    return false;
+  }
+
+  // `custom` then listop is not allowed.
+  if (listop_qual != ListEditQual::ResetToExplicit) {
+    if (custom_qual) {
+      PUSH_ERROR_AND_RETURN("`custom` then ListEdit qualifier is not allowed.");
+    }
+
+    // listop then `custom` is allowed.
+    custom_qual = MaybeCustom();
+  }
+
+  bool varying_authored{false};
+  tinyusdz::Variability variability{tinyusdz::Variability::Varying};
+
+  if (!MaybeVariability(&variability, &varying_authored)) {
+    return false;
+  }
+  DCOUT("variability = " << to_string(variability) << ", varying_authored " << varying_authored);
+
   std::string type_name;
 
   if (!ReadIdentifier(&type_name)) {
     return false;
   }
 
   if (!SkipWhitespace()) {
     return false;
   }
 
-  if (type_name == "uniform") {
-    uniform_qual = true;
+  DCOUT("type_name = " << type_name);
+
+  // `uniform` or `varying`
+
+  // Relation('rel')
+  if (type_name == kRel) {
+    DCOUT("relation");
+
+    if (variability == Variability::Uniform) {
+      PUSH_ERROR_AND_RETURN(
+          "Explicit `uniform` variability keyword is not allowed for Relationship.");
+    }
+
+    // - prim_identifier
+    // - prim_identifier, '(' metadataum ')'
+    // - prim_identifier, '=', (None|string|path|pathvector)
+    // NOTE: There should be no 'uniform rel'
+
+    std::string attr_name;
+
+    if (!ReadPrimAttrIdentifier(&attr_name)) {
+      PUSH_ERROR_AND_RETURN(
+          "Attribute name(Identifier) expected but got non-identifier.");
+    }
+
+    if (!SkipWhitespace()) {
+      return false;
+    }
+
+    char c;
+    if (!LookChar1(&c)) {
+      return false;
+    }
+
+    nonstd::optional<AttrMeta> metap;
+
+    if (c == '(') {
+      // FIXME: Implement Relation specific metadatum parser?
+      AttrMeta meta;
+      if (!ParseAttrMeta(&meta)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse metadataum.");
+      }
+
+      metap = meta;
+
+      if (!LookChar1(&c)) {
+        return false;
+      }
+
+    }
+
+    if (c != '=') {
+      DCOUT("Relationship with no target: " << attr_name);
+
+      // No targets. Define only.
+      Property p(type_name, custom_qual);
+      p.set_property_type(Property::Type::NoTargetsRelation);
+      p.set_listedit_qual(listop_qual);
+
+      if (varying_authored) {
+        p.relationship().set_varying_authored();
+      }
+
+      if (metap) {
+        // TODO: metadataum for Rel
+        p.relationship().metas() = metap.value();
+      }
+
+      (*props)[attr_name] = p;
+
+      return true;
+    }
+
+    // has targets
+    if (!Expect('=')) {
+      return false;
+    }
+
+    if (metap) {
+      PUSH_ERROR_AND_RETURN_TAG(kAscii, "Syntax error. Property metadatum must be defined after `=` and relationship target(s).");
+    }
+
+    if (!SkipWhitespaceAndNewline()) {
+      return false;
+    }
+
+    if (MaybeNone()) {
+      return true;
+    }
+
+    Relationship rel;
+    if (!ParseRelationship(&rel)) {
+      PUSH_ERROR_AND_RETURN("Failed to parse `rel` property.");
+    }
+
+    if (!SkipWhitespace()) {
+    }
 
-    // next token should be type
-    if (!ReadIdentifier(&type_name)) {
-      PushError("`type` identifier expected but got non-identifier\n");
+    if (!LookChar1(&c)) {
       return false;
     }
 
-    // `type_name` is then overwritten.
+    if (c == '(') {
+
+      if (metap) {
+        PUSH_ERROR_AND_RETURN_TAG(kAscii, "[InternalError] parser error.");
+      }
+
+      AttrMeta meta;
+
+      // FIXME: Implement Relation specific metadatum parser?
+      if (!ParseAttrMeta(&meta)) {
+        PUSH_ERROR_AND_RETURN("Failed to parse metadataum.");
+      }
+
+      metap = meta;
+
+    }
+
+    DCOUT("Relationship with target: " << attr_name);
+    Property p(rel, custom_qual);
+    p.set_listedit_qual(listop_qual);
+
+    if (varying_authored) {
+      p.relationship().set_varying_authored();
+    }
+
+    if (metap) {
+      p.relationship().metas() = metap.value();
+    }
+
+    (*props)[attr_name] = p;
+
+    return true;
+  }
+
+  //
+  // Attrib.
+  //
+
+  if (listop_qual != ListEditQual::ResetToExplicit) {
+    PUSH_ERROR_AND_RETURN_TAG(
+        kAscii, "List editing qualifier is not allowed for Attribute.");
   }
 
   if (!IsSupportedPrimAttrType(type_name)) {
     PUSH_ERROR_AND_RETURN("Unknown or unsupported primtive attribute type `" +
-                          type_name + "`\n");
+                          type_name);
   }
 
   // Has array qualifier? `[]`
   bool array_qual = false;
   {
     char c0, c1;
     if (!Char1(&c0)) {
@@ -4602,16 +4032,15 @@
         return false;
       }
 
       if (c1 == ']') {
         array_qual = true;
       } else {
         // Invalid syntax
-        PushError("Invalid syntax found.\n");
-        return false;
+        PUSH_ERROR_AND_RETURN("Invalid syntax found.");
       }
 
     } else {
       if (!Rewind(1)) {
         return false;
       }
     }
@@ -4626,577 +4055,764 @@
     PUSH_ERROR_AND_RETURN("Failed to parse primAttr identifier.");
   }
 
   if (!SkipWhitespace()) {
     return false;
   }
 
-  // output node?
-  if (type_name == "token" && hasOutputs(primattr_name) &&
-      !hasConnect(primattr_name)) {
-    // ok
-    return true;
-  }
+  bool isTimeSample = endsWith(primattr_name, kTimeSamplesSuffix);
+  bool isConnection = endsWith(primattr_name, kConnectSuffix);
 
-  bool isTimeSample = endsWith(primattr_name, ".timeSamples");
+  // Remove suffix
+  std::string attr_name = primattr_name;
+  if (isTimeSample) {
+    attr_name = removeSuffix(primattr_name, kTimeSamplesSuffix);
+  }
+  if (isConnection) {
+    attr_name = removeSuffix(primattr_name, kConnectSuffix);
+  }
 
   bool define_only = false;
   {
     char c;
     if (!Char1(&c)) {
       return false;
     }
 
     if (c != '=') {
       // Define only(e.g. output variable)
       define_only = true;
     }
   }
 
+  DCOUT("define only:" << define_only);
+
   if (define_only) {
-    // TODO:
+#if 0
+    if (isConnection || isTimeSample) {
+      PUSH_ERROR_AND_RETURN("`.connect` or `.timeSamples` suffix provided, but no target/values provided.");
+    }
+#endif
+
+    Rewind(1);
+
+    // optional: attribute meta.
+    AttrMeta meta;
+    if (!ParseAttrMeta(&meta)) {
+      PUSH_ERROR_AND_RETURN("Failed to parse Attribute meta.");
+    }
+
+    DCOUT("Define only property = " + primattr_name);
+
+    // Empty Attribute. type info only
+    Property p(type_name, custom_qual);
 
-    // attr.custom = custom_qual;
-    // attr.uniform = uniform_qual;
-    // attr.name = primattr_name;
-
-    // DCOUT("primattr_name = " + primattr_name);
-
-    //// FIXME
-    //{
-    //  (*props)[primattr_name].rel = rel;
-    //  (*props)[primattr_name].is_rel = true;
-    //}
+    p.attribute().variability() = variability;
+    if (varying_authored) {
+      p.attribute().set_varying_authored();
+    }
+
+    p.attribute().metas() = meta;
+
+    (*props)[attr_name] = p;
 
     return true;
   }
 
   // Continue to parse argument
   if (!SkipWhitespace()) {
     return false;
   }
 
-  //
-  // TODO(syoyo): Refactror and implement value parser dispatcher.
-  //
-  if (isTimeSample) {
-      if (type_name == "float") {
-        if (auto pv = TryParseTimeSamples<float>()) {
-          value::TimeSamples ts = ConvertToTimeSamples<float>(pv.value());
+  bool value_blocked{false};
 
-          PUSH_ERROR_AND_RETURN("TODO");
-        }
+  if (MaybeNone()) {
+    value_blocked = true;
+  }
 
-        // TODO: Implement
+  if (isConnection) {
+    // atribute connection
+    DCOUT("isConnection");
 
-        //Property prop;
-        //prop.attrib.timeSampledValue = values;
-        //std::cout << "timeSample float:" << primattr_name << " = " << to_string(values) << "\n";
-        //(*props)[primattr_name] = var;
+    Path path;
+    if (!value_blocked) {
+      // Target Must be Path
+      if (!ReadBasicType(&path)) {
+        PUSH_ERROR_AND_RETURN("Path expected for .connect target.");
+      }
+    }
 
-#if 0  // TODO
-      } else if (type_name == "double") {
-        TimeSampledDataDouble values;
-        if (!ParseTimeSamples(&values)) {
-          return false;
-        }
+    // Resolve relative path.
+    Path base_abs_path(GetCurrentPrimPath(), "");
+    Path abs_path;
+    std::string err;
+    if (!pathutil::ResolveRelativePath(base_abs_path, path, &abs_path, &err)) {
+      PUSH_ERROR_AND_RETURN(fmt::format("Invalid relative Path: {}. error = {}", path.full_path_name(), err));
+    }
 
-        MetaVariable var;
-        var.timeSampledValue = values;
-        (*props)[primattr_name] = var;
+    Property p(abs_path, /* value typename */ type_name, custom_qual);
+    if (value_blocked) {
+      p.attribute().set_blocked(true);
+    }
 
-      } else if (type_name == "float3") {
-        TimeSampledDataFloat3 values;
-        if (!ParseTimeSamples(&values)) {
-          return false;
-        }
+    p.attribute().variability() = variability;
+    if (varying_authored) {
+      p.attribute().set_varying_authored();
+    }
 
-        MetaVariable var;
-        var.timeSampledValue = values;
-        (*props)[primattr_name] = var;
-      } else if (type_name == "double3") {
-        TimeSampledDataDouble3 values;
-        if (!ParseTimeSamples(&values)) {
-          return false;
-        }
+    (*props)[attr_name] = p;
 
-        MetaVariable var;
-        var.timeSampledValue = values;
-        (*props)[primattr_name] = var;
-      } else if (type_name == "matrix4d") {
-        TimeSampledDatavalue::matrix4d values;
-        if (!ParseTimeSamples(&values)) {
-          return false;
-        }
+    DCOUT(fmt::format("Added {} as a attribute connection.", primattr_name));
 
-        MetaVariable var;
-        var.timeSampledValue = values;
-        (*props)[primattr_name] = var;
+    return true;
 
-      } else {
-        PushError(std::to_string(__LINE__) + " : TODO: timeSamples type " + type_name);
-        return false;
+  } else if (isTimeSample) {
+    // float.timeSamples = None is not supported
+    if (value_blocked) {
+      PUSH_ERROR_AND_RETURN("ValueBlock to .timeSamples is not supported.");
+    }
+
+    //
+    // TODO(syoyo): Refactror and implement value parser dispatcher.
+    //
+    if (array_qual) {
+      DCOUT("timeSample data. type = " << type_name << "[]");
+    } else {
+      DCOUT("timeSample data. type = " << type_name);
+    }
+
+    value::TimeSamples ts;
+    if (array_qual) {
+      if (!ParseTimeSamplesOfArray(type_name, &ts)) {
+        PUSH_ERROR_AND_RETURN_TAG(kAscii, fmt::format("Failed to parse TimeSamples of type {}[]", type_name));
       }
-#else
-      } else {
-        PUSH_ERROR_AND_RETURN(" : TODO: timeSamples type " + type_name);
+    } else {
+      if (!ParseTimeSamples(type_name, &ts)) {
+        PUSH_ERROR_AND_RETURN_TAG(kAscii, fmt::format("Failed to parse TimeSamples of type {}", type_name));
       }
-#endif
+    }
 
-    PUSH_ERROR_AND_RETURN("TODO: timeSamples type " + type_name);
-    return false;
+    //std::string varname = removeSuffix(primattr_name, ".timeSamples");
+    Attribute attr;
+    primvar::PrimVar var;
+    var.set_timesamples(ts);
 
-  } else {
-    PrimAttrib attr;
-    Rel rel;
+    attr.name() = attr_name;
+    attr.set_var(std::move(var));
 
-    bool is_rel = false;
+    attr.variability() = variability;
+    if (varying_authored) {
+      attr.set_varying_authored();
+    }
 
-    if (type_name == value::kBool) {
-      if (!ParseBasicPrimAttr<bool>(array_qual, primattr_name, &attr)) {
-        return false;
-      }
-    } else if (type_name == "float") {
-      if (!ParseBasicPrimAttr<float>(array_qual, primattr_name, &attr)) {
-        return false;
-      }
-    } else if (type_name == "int") {
-      if (!ParseBasicPrimAttr<int>(array_qual, primattr_name, &attr)) {
-        return false;
-      }
-    } else if (type_name == "double") {
-      if (!ParseBasicPrimAttr<double>(array_qual, primattr_name, &attr)) {
-        return false;
-      }
-    } else if (type_name == "string") {
-      if (!ParseBasicPrimAttr<std::string>(array_qual, primattr_name, &attr)) {
-        return false;
-      }
-    } else if (type_name == "token") {
-      if (!ParseBasicPrimAttr<std::string>(array_qual, primattr_name, &attr)) {
-        return false;
-      }
-    } else if (type_name == "float2") {
-      if (!ParseBasicPrimAttr<value::float2>(array_qual, primattr_name,
-                                             &attr)) {
-        return false;
-      }
-    } else if (type_name == "float3") {
-      if (!ParseBasicPrimAttr<value::float3>(array_qual, primattr_name,
-                                             &attr)) {
-        return false;
-      }
-    } else if (type_name == "float4") {
-      if (!ParseBasicPrimAttr<value::float4>(array_qual, primattr_name,
-                                             &attr)) {
-        return false;
-      }
-    } else if (type_name == "double2") {
-      if (!ParseBasicPrimAttr<value::double2>(array_qual, primattr_name,
-                                              &attr)) {
-        return false;
-      }
-    } else if (type_name == "double3") {
-      if (!ParseBasicPrimAttr<value::double3>(array_qual, primattr_name,
-                                              &attr)) {
-        return false;
-      }
-    } else if (type_name == "double4") {
-      if (!ParseBasicPrimAttr<value::double4>(array_qual, primattr_name,
-                                              &attr)) {
-        return false;
-      }
-    } else if (type_name == "point3f") {
-      DCOUT("point3f, array_qual = " + std::to_string(array_qual));
-      if (!ParseBasicPrimAttr<value::point3f>(array_qual, primattr_name,
-                                              &attr)) {
-        DCOUT("Failed to parse point3f data.");
-        return false;
-      }
-    } else if (type_name == "color3f") {
-      if (!ParseBasicPrimAttr<value::color3f>(array_qual, primattr_name,
-                                              &attr)) {
-        return false;
-      }
-    } else if (type_name == "color4f") {
-      if (!ParseBasicPrimAttr<value::color4f>(array_qual, primattr_name,
-                                              &attr)) {
-        return false;
-      }
-    } else if (type_name == "point3d") {
-      if (!ParseBasicPrimAttr<value::point3d>(array_qual, primattr_name,
-                                              &attr)) {
-        return false;
-      }
-    } else if (type_name == "normal3f") {
-      DCOUT("normal3f, array_qual = " + std::to_string(array_qual));
-      if (!ParseBasicPrimAttr<value::normal3f>(array_qual, primattr_name,
+    DCOUT("timeSamples primattr: type = " << type_name
+                                          << ", name = " << attr_name);
+
+    Property p(attr, custom_qual);
+    p.set_property_type(Property::Type::Attrib);
+    (*props)[attr_name] = p;
+
+    return true;
+
+  } else {
+    Attribute attr;
+    if (!value_blocked) {
+
+      // TODO: Refactor. ParseAttrMeta is currently called inside
+      // ParseBasicPrimAttr()
+      if (type_name == value::kBool) {
+        if (!ParseBasicPrimAttr<bool>(array_qual, primattr_name, &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kInt) {
+        if (!ParseBasicPrimAttr<int>(array_qual, primattr_name, &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kInt2) {
+        if (!ParseBasicPrimAttr<value::int2>(array_qual, primattr_name, &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kInt3) {
+        if (!ParseBasicPrimAttr<value::int3>(array_qual, primattr_name, &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kInt4) {
+        if (!ParseBasicPrimAttr<value::int4>(array_qual, primattr_name, &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kUInt) {
+        if (!ParseBasicPrimAttr<uint32_t>(array_qual, primattr_name, &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kUInt2) {
+        if (!ParseBasicPrimAttr<value::uint2>(array_qual, primattr_name, &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kUInt3) {
+        if (!ParseBasicPrimAttr<value::uint3>(array_qual, primattr_name, &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kUInt4) {
+        if (!ParseBasicPrimAttr<value::uint4>(array_qual, primattr_name, &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kInt64) {
+        if (!ParseBasicPrimAttr<int64_t>(array_qual, primattr_name, &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kUInt64) {
+        if (!ParseBasicPrimAttr<uint64_t>(array_qual, primattr_name, &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kDouble) {
+        if (!ParseBasicPrimAttr<double>(array_qual, primattr_name, &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kString) {
+        if (!ParseBasicPrimAttr<value::StringData>(array_qual, primattr_name, &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kToken) {
+        if (!ParseBasicPrimAttr<value::token>(array_qual, primattr_name, &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kHalf) {
+        if (!ParseBasicPrimAttr<value::half>(array_qual, primattr_name, &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kHalf2) {
+        if (!ParseBasicPrimAttr<value::half2>(array_qual, primattr_name, &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kHalf3) {
+        if (!ParseBasicPrimAttr<value::half3>(array_qual, primattr_name, &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kHalf4) {
+        if (!ParseBasicPrimAttr<value::half4>(array_qual, primattr_name, &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kFloat) {
+        if (!ParseBasicPrimAttr<float>(array_qual, primattr_name, &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kFloat2) {
+        if (!ParseBasicPrimAttr<value::float2>(array_qual, primattr_name,
                                                &attr)) {
-        DCOUT("Failed to parse normal3f data.");
-        return false;
-      }
-      DCOUT("Got it");
-    } else if (type_name == "normal3d") {
-      if (!ParseBasicPrimAttr<value::normal3d>(array_qual, primattr_name,
+          return false;
+        }
+      } else if (type_name == value::kFloat3) {
+        if (!ParseBasicPrimAttr<value::float3>(array_qual, primattr_name,
                                                &attr)) {
-        return false;
-      }
-    } else if (type_name == "color3d") {
-      if (!ParseBasicPrimAttr<value::color3d>(array_qual, primattr_name,
-                                              &attr)) {
-        return false;
-      }
-    } else if (type_name == "color4d") {
-      if (!ParseBasicPrimAttr<value::color4d>(array_qual, primattr_name,
-                                              &attr)) {
-        return false;
-      }
-    } else if (type_name == "matrix2d") {
-      if (!ParseBasicPrimAttr<value::matrix2d>(array_qual, primattr_name,
+          return false;
+        }
+      } else if (type_name == value::kFloat4) {
+        if (!ParseBasicPrimAttr<value::float4>(array_qual, primattr_name,
                                                &attr)) {
-        return false;
-      }
-    } else if (type_name == "matrix3d") {
-      if (!ParseBasicPrimAttr<value::matrix3d>(array_qual, primattr_name,
+          return false;
+        }
+      } else if (type_name == value::kDouble2) {
+        if (!ParseBasicPrimAttr<value::double2>(array_qual, primattr_name,
+                                                &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kDouble3) {
+        if (!ParseBasicPrimAttr<value::double3>(array_qual, primattr_name,
+                                                &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kDouble4) {
+        if (!ParseBasicPrimAttr<value::double4>(array_qual, primattr_name,
+                                                &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kPoint3f) {
+        if (!ParseBasicPrimAttr<value::point3f>(array_qual, primattr_name,
+                                                &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kColor3f) {
+        if (!ParseBasicPrimAttr<value::color3f>(array_qual, primattr_name,
+                                                &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kColor4f) {
+        if (!ParseBasicPrimAttr<value::color4f>(array_qual, primattr_name,
+                                                &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kPoint3d) {
+        if (!ParseBasicPrimAttr<value::point3d>(array_qual, primattr_name,
+                                                &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kNormal3f) {
+        if (!ParseBasicPrimAttr<value::normal3f>(array_qual, primattr_name,
+                                                 &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kNormal3d) {
+        if (!ParseBasicPrimAttr<value::normal3d>(array_qual, primattr_name,
+                                                 &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kVector3f) {
+        if (!ParseBasicPrimAttr<value::vector3f>(array_qual, primattr_name,
+                                                 &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kVector3d) {
+        if (!ParseBasicPrimAttr<value::vector3d>(array_qual, primattr_name,
+                                                 &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kColor3d) {
+        if (!ParseBasicPrimAttr<value::color3d>(array_qual, primattr_name,
+                                                &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kColor4d) {
+        if (!ParseBasicPrimAttr<value::color4d>(array_qual, primattr_name,
+                                                &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kMatrix2d) {
+        if (!ParseBasicPrimAttr<value::matrix2d>(array_qual, primattr_name,
                                                &attr)) {
-        return false;
-      }
-    } else if (type_name == "matrix4d") {
-      if (!ParseBasicPrimAttr<value::matrix4d>(array_qual, primattr_name,
+          return false;
+        }
+      } else if (type_name == value::kFloat3) {
+        if (!ParseBasicPrimAttr<value::float3>(array_qual, primattr_name,
                                                &attr)) {
-        return false;
-      }
+          return false;
+        }
+      } else if (type_name == value::kFloat4) {
+        if (!ParseBasicPrimAttr<value::float4>(array_qual, primattr_name,
+                                               &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kDouble2) {
+        if (!ParseBasicPrimAttr<value::double2>(array_qual, primattr_name,
+                                                &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kDouble3) {
+        if (!ParseBasicPrimAttr<value::double3>(array_qual, primattr_name,
+                                                &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kDouble4) {
+        if (!ParseBasicPrimAttr<value::double4>(array_qual, primattr_name,
+                                                &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kPoint3f) {
+        if (!ParseBasicPrimAttr<value::point3f>(array_qual, primattr_name,
+                                                &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kColor3f) {
+        if (!ParseBasicPrimAttr<value::color3f>(array_qual, primattr_name,
+                                                &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kColor4f) {
+        if (!ParseBasicPrimAttr<value::color4f>(array_qual, primattr_name,
+                                                &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kPoint3d) {
+        if (!ParseBasicPrimAttr<value::point3d>(array_qual, primattr_name,
+                                                &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kNormal3f) {
+        if (!ParseBasicPrimAttr<value::normal3f>(array_qual, primattr_name,
+                                                 &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kNormal3d) {
+        if (!ParseBasicPrimAttr<value::normal3d>(array_qual, primattr_name,
+                                                 &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kVector3f) {
+        if (!ParseBasicPrimAttr<value::vector3f>(array_qual, primattr_name,
+                                                 &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kVector3d) {
+        if (!ParseBasicPrimAttr<value::vector3d>(array_qual, primattr_name,
+                                                 &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kColor3d) {
+        if (!ParseBasicPrimAttr<value::color3d>(array_qual, primattr_name,
+                                                &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kColor4d) {
+        if (!ParseBasicPrimAttr<value::color4d>(array_qual, primattr_name,
+                                                &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kMatrix2d) {
+        if (!ParseBasicPrimAttr<value::matrix2d>(array_qual, primattr_name,
+                                                 &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kMatrix3d) {
+        if (!ParseBasicPrimAttr<value::matrix3d>(array_qual, primattr_name,
+                                                 &attr)) {
+          return false;
+        }
+      } else if (type_name == value::kMatrix4d) {
+        if (!ParseBasicPrimAttr<value::matrix4d>(array_qual, primattr_name,
+                                                 &attr)) {
+          return false;
+        }
 
-    } else if (type_name == value::kRelationship) {
-      if (!ParseRel(&rel)) {
-        PushError("Failed to parse value with type `rel`.\n");
-        return false;
-      }
+      } else if (type_name == value::kTexCoord2f) {
+        if (!ParseBasicPrimAttr<value::texcoord2f>(array_qual, primattr_name,
+                                                   &attr)) {
+          PUSH_ERROR_AND_RETURN("Failed to parse texCoord2f data.");
+        }
 
-      is_rel = true;
-    } else if (type_name == value::kTexCoord2f) {
-      if (!ParseBasicPrimAttr<value::texcoord2f>(array_qual, primattr_name,
-                                                 &attr)) {
-        PUSH_ERROR_AND_RETURN("Failed to parse texCoord2f data.");
-      }
+      } else if (type_name == value::kAssetPath) {
+        Reference asset_ref;
+        bool triple_deliminated{false};
+        if (!ParseReference(&asset_ref, &triple_deliminated)) {
+          PUSH_ERROR_AND_RETURN("Failed to parse `asset` data.");
+        }
 
-    } else if (type_name == value::kAssetPath) {
-      Reference asset_ref;
-      bool triple_deliminated{false};
-      if (!ParseReference(&asset_ref, &triple_deliminated)) {
-        PUSH_ERROR_AND_RETURN("Failed to parse `asset` data.");
-      }
+        DCOUT("Asset path = " << asset_ref.asset_path);
+        value::AssetPath assetp(asset_ref.asset_path);
+        primvar::PrimVar var;
+        var.set_value(assetp);
+        attr.set_var(std::move(var));
+
+        // optional: attribute meta.
+        AttrMeta meta;
+        if (!ParseAttrMeta(&meta)) {
+          PUSH_ERROR_AND_RETURN("Failed to parse Attribute meta.");
+        }
+        attr.metas() = meta;
 
-      value::asset_path assetp(asset_ref.asset_path);
-      attr.var.set_scalar(assetp);
+      } else {
+        PUSH_ERROR_AND_RETURN("TODO: type = " + type_name);
+      }
+    }
 
-    } else {
-      PUSH_ERROR_AND_RETURN("TODO: type = " + type_name);
+    attr.variability() = variability;
+    if (varying_authored) {
+      attr.set_varying_authored();
     }
 
-    attr.uniform = uniform_qual;
-    attr.name = primattr_name;
+    if (value_blocked) {
+      if (array_qual) {
+        attr.set_type_name(type_name + "[]");
+      } else {
+        attr.set_type_name(type_name);
+      }
+      attr.set_blocked(true);
+    }
 
-    DCOUT("primattr_name = " + primattr_name);
+    attr.set_name(primattr_name);
 
-    (*props)[primattr_name].is_custom = custom_qual;
+    DCOUT("primattr: type = " << type_name << ", name = " << primattr_name);
 
-    if (is_rel) {
-      (*props)[primattr_name].rel = rel;
-      (*props)[primattr_name].is_rel = true;
+    Property p(attr, custom_qual);
 
-    } else {
-      (*props)[primattr_name].attrib = attr;
-    }
+    (*props)[primattr_name] = p;
 
     return true;
   }
 }
 
-bool AsciiParser::ParseProperty(std::map<std::string, Property> *props) {
+// propNames stores list of property name in its appearance order.
+bool AsciiParser::ParseProperties(std::map<std::string, Property> *props, std::vector<value::token> *propNames) {
   // property : primm_attr
   //          | 'rel' name '=' path
   //          ;
 
   if (!SkipWhitespace()) {
     return false;
   }
 
   // rel?
   {
-    size_t loc = CurrLoc();
+    uint64_t loc = CurrLoc();
     std::string tok;
 
     if (!ReadIdentifier(&tok)) {
       return false;
     }
 
     if (tok == "rel") {
       PUSH_ERROR_AND_RETURN("TODO: Parse rel");
     } else {
       SeekTo(loc);
     }
   }
 
   // attribute
-  return ParsePrimAttr(props);
+  return ParsePrimProps(props, propNames);
 }
 
-std::string AsciiParser::GetCurrentPath() {
+std::string AsciiParser::GetCurrentPrimPath() {
   if (_path_stack.empty()) {
     return "/";
   }
 
   return _path_stack.top();
 }
 
 //
 // -- ctor, dtor
 //
 
-AsciiParser::AsciiParser() {
-  Setup();
-}
+AsciiParser::AsciiParser() { Setup(); }
 
-AsciiParser::AsciiParser(StreamReader *sr) : _sr(sr) {
-  Setup();
-}
+AsciiParser::AsciiParser(StreamReader *sr) : _sr(sr) { Setup(); }
 
 void AsciiParser::Setup() {
   RegisterStageMetas(_supported_stage_metas);
   RegisterPrimMetas(_supported_prim_metas);
+  RegisterPropMetas(_supported_prop_metas);
   RegisterPrimAttrTypes(_supported_prim_attr_types);
   RegisterPrimTypes(_supported_prim_types);
+  RegisterAPISchemas(_supported_api_schemas);
 }
 
 AsciiParser::~AsciiParser() {}
 
 bool AsciiParser::CheckHeader() { return ParseMagicHeader(); }
 
 bool AsciiParser::IsPrimMeta(const std::string &name) {
   return _supported_prim_metas.count(name) ? true : false;
 }
 
 bool AsciiParser::IsStageMeta(const std::string &name) {
   return _supported_stage_metas.count(name) ? true : false;
 }
 
-///
-/// Parse `class` block.
-///
-bool AsciiParser::ParseClassBlock() {
-  if (!SkipWhitespaceAndNewline()) {
+bool AsciiParser::ParseVariantSet(const int64_t primIdx,
+                                  const int64_t parentPrimIdx,
+                                  const uint32_t depth,
+                                  std::map<std::string, VariantContent> *variantSetOut) {
+
+  if (!variantSetOut) {
+    PUSH_ERROR_AND_RETURN_TAG(kAscii, "[InternalError] variantSetOut arg is nullptr.");
+  }
+  
+  // variantSet =
+  // {
+  //   "variantName0" ( metas ) { ... }
+  //   "variantName1" ( metas ) { ... }
+  //   ...
+  // }
+  if (!Expect('{')) {
     return false;
   }
 
-  {
-    std::string tok;
-    if (!ReadIdentifier(&tok)) {
-      return false;
-    }
-
-    if (tok != "class") {
-      PushError("`class` is expected.");
-      return false;
-    }
-  }
-
-  if (!SkipWhitespaceAndNewline()) {
+  if (!SkipCommentAndWhitespaceAndNewline()) {
     return false;
   }
 
-  std::string target;
+  std::map<std::string, VariantContent> variantContentMap;
 
-  if (!ReadBasicType(&target)) {
-    return false;
-  }
+  // for each variantStatement
+  while (!Eof()) {
+    {
+      char c;
+      if (!Char1(&c)) {
+        return false;
+      }
 
-  if (!SkipWhitespaceAndNewline()) {
-    return false;
-  }
+      if (c == '}') {
+        // end
+        break;
+      }
 
-  std::map<std::string, std::tuple<ListEditQual, MetaVariable>> metas;
-  if (!ParsePrimMetas(&metas)) {
-    return false;
-  }
+      Rewind(1);
+    }
 
-  if (!Expect('{')) {
-    return false;
-  }
+    // string
+    std::string variantName;
+    if (!ReadBasicType(&variantName)) {
+      PUSH_ERROR_AND_RETURN_TAG(
+          kAscii, "Failed to parse variant name for `variantSet` statement.");
+    }
 
-  if (!SkipWhitespaceAndNewline()) {
-    return false;
-  }
+    if (!SkipWhitespace()) {
+      return false;
+    }
 
-  {
-    std::string path = GetCurrentPath();
-    if (path == "/") {
-      path += target;
-    } else {
-      path += "/" + target;
+    // Optional: PrimSpec meta
+    PrimMetaMap metas;
+    {
+      char mc;
+      if (!LookChar1(&mc)) {
+        return false;
+      }
+
+      if (mc == '(') {
+        if (!ParsePrimMetas(&metas)) {
+          PUSH_ERROR_AND_RETURN_TAG(kAscii, "Failed to parse PrimSpec metas in variant statement.");
+        }
+      }
     }
-    PushPath(path);
-  }
 
-  // TODO: Support nested 'class'?
+    if (!Expect('{')) {
+      return false;
+    }
 
-  // expect = '}'
-  //        | def_block
-  //        | prim_attr+
-  std::map<std::string, Property> props;
-  while (!_sr->eof()) {
-    char c;
-    if (!Char1(&c)) {
+    if (!SkipCommentAndWhitespaceAndNewline()) {
       return false;
     }
 
-    if (c == '}') {
-      // end block
-      break;
-    } else {
+    VariantContent variantContent;
+
+    while (!Eof()) {
+      {
+        char c;
+        if (!Char1(&c)) {
+          return false;
+        }
+
+        if (c == '}') {
+          DCOUT("End block in variantSet stmt.");
+          // end block
+          break;
+        }
+      }
+
       if (!Rewind(1)) {
         return false;
       }
 
+      DCOUT("Read first token in VariantSet stmt");
       Identifier tok;
       if (!ReadBasicType(&tok)) {
-        return false;
+        PUSH_ERROR_AND_RETURN(
+            "Failed to parse an identifier in variantSet block statement.");
       }
 
       if (!Rewind(tok.size())) {
         return false;
       }
 
+      if (tok == "variantSet") {
+        PUSH_ERROR_AND_RETURN("Nested `variantSet` is not supported yet.");
+      }
+
+      Specifier child_spec{Specifier::Invalid};
       if (tok == "def") {
+        child_spec = Specifier::Def;
+      } else if (tok == "over") {
+        child_spec = Specifier::Over;
+      } else if (tok == "class") {
+        child_spec = Specifier::Class;
+      }
+
+      // No specifier => Assume properties only.
+      // Has specifier => Prim
+      if (child_spec != Specifier::Invalid) {
+        // FIXME: Assign idx dedicated for variant.
+        int64_t idx = _prim_idx_assign_fun(parentPrimIdx);
+        DCOUT("enter parseBlock in variantSet. spec = " << to_string(child_spec) << ", idx = "
+                                        << idx << ", rootIdx = " << primIdx);
+
         // recusive call
-        if (!ParseDefBlock()) {
-          return false;
+        if (!ParseBlock(child_spec, idx, primIdx, depth + 1, /* in_variantStmt */true)) {
+          PUSH_ERROR_AND_RETURN(
+              fmt::format("`{}` block parse failed.", to_string(child_spec)));
         }
+        DCOUT(fmt::format("Done parse `{}` block.", to_string(child_spec)));
+
+        DCOUT(fmt::format("Add primIdx {} to variant {}", idx, variantName));
+        variantContent.primIndices.push_back(idx);
+
       } else {
-        // Assume PrimAttr
-        if (!ParsePrimAttr(&props)) {
-          return false;
+        DCOUT("Enter ParsePrimProps.");
+        if (!ParsePrimProps(&variantContent.props, &variantContent.properties)) {
+          PUSH_ERROR_AND_RETURN("Failed to parse Prim attribute.");
         }
+        DCOUT(fmt::format("Done parse ParsePrimProps."));
       }
 
       if (!SkipWhitespaceAndNewline()) {
         return false;
       }
     }
-  }
-
-  Klass klass;
-  for (const auto &prop : props) {
-    // TODO: list-edit qual
-    klass.props[prop.first] = prop.second;
-  }
-
-  // TODO: Check key existance.
-  _klasses[GetCurrentPath()] = klass;
-
-  PopPath();
-
-  return true;
-}
-
-///
-/// Parse `over` block.
-///
-bool AsciiParser::ParseOverBlock() {
-  std::string tok;
-
-  if (!SkipWhitespaceAndNewline()) {
-    return false;
-  }
-
-  if (!ReadIdentifier(&tok)) {
-    return false;
-  }
-
-  if (tok != "over") {
-    PushError("`over` is expected.");
-    return false;
-  }
-
-  if (!SkipWhitespaceAndNewline()) {
-    return false;
-  }
-
-  std::string target;
 
-  if (!ReadBasicType(&target)) {
-    return false;
-  }
-
-  if (!SkipWhitespaceAndNewline()) {
-    return false;
-  }
-
-  std::map<std::string, std::tuple<ListEditQual, MetaVariable>> metas;
-  if (!ParsePrimMetas(&metas)) {
-    return false;
-  }
-
-  {
-    std::string path = GetCurrentPath();
-    if (path == "/") {
-      path += target;
-    } else {
-      path += "/" + target;
+    if (!SkipWhitespaceAndNewline()) {
+      return false;
     }
-    PushPath(path);
-  }
-
-  if (!Expect('{')) {
-    return false;
-  }
-
-  if (!SkipWhitespaceAndNewline()) {
-    return false;
-  }
 
-  // TODO: Parse block content
+    DCOUT(fmt::format("variantSet item {} parsed.", variantName));
 
-  if (!Expect('}')) {
-    return false;
+    variantContent.metas = metas;
+    variantContentMap.emplace(variantName, variantContent);
   }
 
-  PopPath();
+  (*variantSetOut) = std::move(variantContentMap); 
 
   return true;
 }
 
 ///
-/// Parse `def` block.
-///
-/// def = `def` prim_type? token metas? { ... }
+/// Parse block.
 ///
+/// block = spec prim_type? token metas? { ... }
 /// metas = '(' args ')'
 ///
-/// TODO: Support `def` without type(i.e. actual definition is defined in
-/// another USD file or referenced USD)
+/// spec = `def`, `over` or `class`
 ///
-bool AsciiParser::ParseDefBlock(uint32_t nestlevel) {
-
-  DCOUT("ParseDefBlock");
+///
+bool AsciiParser::ParseBlock(const Specifier spec, const int64_t primIdx,
+                             const int64_t parentPrimIdx,
+                             const uint32_t depth,
+                             const bool in_variantStaement) {
+  DCOUT("ParseBlock");
 
   if (!SkipCommentAndWhitespaceAndNewline()) {
     DCOUT("SkipCommentAndWhitespaceAndNewline failed");
     return false;
   }
 
   Identifier def;
   if (!ReadIdentifier(&def)) {
     DCOUT("ReadIdentifier failed");
     return false;
   }
-  DCOUT("def = " << def);
+  DCOUT("spec = " << def);
+
+  if ((def == "def") || (def == "over") || (def == "class")) {
+    // ok
+  } else {
+    PUSH_ERROR_AND_RETURN("Invalid specifier.");
+  }
 
-  if (def != "def") {
-    PUSH_ERROR_AND_RETURN("`def` is expected.");
+  // Ensure spec and def is same.
+  if (def == "def") {
+    if (spec != Specifier::Def) {
+      PUSH_ERROR_AND_RETURN_TAG(
+          kAscii, "Internal error. Invalid Specifier token combination. def = " << def << ", spec = " << to_string(spec));
+    }
+  } else if (def == "over") {
+    if (spec != Specifier::Over) {
+      PUSH_ERROR_AND_RETURN_TAG(
+          kAscii, "Internal error. Invalid Specifier token combination. def = " << def << ", spec = " << to_string(spec));
+    }
+  } else if (def == "class") {
+    if (spec != Specifier::Class) {
+      PUSH_ERROR_AND_RETURN_TAG(
+          kAscii, "Internal error. Invalid Specifier token combination. def = " << def << ", spec = " << to_string(spec));
+    }
   }
 
   if (!SkipWhitespaceAndNewline()) {
     return false;
   }
 
   // look ahead
@@ -5223,40 +4839,44 @@
 
   DCOUT("has_primtype = " << has_primtype);
 
   if (has_primtype) {
     if (!ReadIdentifier(&prim_type)) {
       return false;
     }
-
+#if 0
     if (!IsSupportedPrimType(prim_type)) {
       std::string msg =
           "`" + prim_type +
           "` is not a defined Prim type(or not supported in TinyUSDZ)\n";
-      PushError(msg);
+      PUSH_ERROR_AND_RETURN(msg);
       return false;
     }
+#endif
   }
 
   if (!SkipWhitespaceAndNewline()) {
     return false;
   }
 
   std::string prim_name;
   if (!ReadBasicType(&prim_name)) {
     return false;
   }
 
   DCOUT("prim name = " << prim_name);
+  if (!ValidatePrimElementName(prim_name)) {
+    PUSH_ERROR_AND_RETURN_TAG(kAscii, "Prim name contains invalid chacracter.");
+  }
 
   if (!SkipWhitespaceAndNewline()) {
     return false;
   }
 
-  std::map<std::string, std::tuple<ListEditQual, MetaVariable>> in_metas;
+  std::map<std::string, std::pair<ListEditQual, MetaVariable>> in_metas;
   {
     // look ahead
     char c;
     if (!LookChar1(&c)) {
       return false;
     }
 
@@ -5282,349 +4902,368 @@
     return false;
   }
 
   if (!SkipWhitespaceAndNewline()) {
     return false;
   }
 
-  std::vector<std::pair<ListEditQual, Reference>> references;
-  DCOUT("`references.count` = " + std::to_string(in_metas.count("references")));
-
-  if (in_metas.count("references")) {
-    // TODO
-    // references = GetReferences(args["references"]);
-    // DCOUT("`references.size` = " + std::to_string(references.size()));
-  }
-
-#if 0
-  if (auto v = ReconstructPrimMetas(in_metas)) {
-    DCOUT("TODO: ");
-  } else {
-    return false;
-  }
-#endif
-
   std::map<std::string, Property> props;
+  std::vector<value::token> propNames;
+  VariantSetList variantSetList;
 
   {
-    std::string path = GetCurrentPath();
-    if (path == "/") {
-      path += prim_name;
+    std::string full_path = GetCurrentPrimPath();
+    if (full_path == "/") {
+      full_path += prim_name;
     } else {
-      path += "/" + prim_name;
+      full_path += "/" + prim_name;
     }
-    PushPath(path);
+    PushPrimPath(full_path);
   }
 
   // expect = '}'
   //        | def_block
   //        | prim_attr+
-  while (!_sr->eof()) {
+  //        | variantSet '{' ... '}'
+  while (!Eof()) {
+    if (!SkipCommentAndWhitespaceAndNewline()) {
+      return false;
+    }
+
     char c;
     if (!Char1(&c)) {
       return false;
     }
 
     if (c == '}') {
       // end block
       break;
     } else {
       if (!Rewind(1)) {
         return false;
       }
 
+      DCOUT("Read stmt token");
       Identifier tok;
       if (!ReadBasicType(&tok)) {
-        return false;
+        // maybe ';'?
+
+        if (LookChar1(&c)) {
+          if (c == ';') {
+            PUSH_ERROR_AND_RETURN(
+                "Semicolon is not allowd in `def` block statement.");
+          }
+        }
+        PUSH_ERROR_AND_RETURN(
+            "Failed to parse an identifier in `def` block statement.");
+      }
+
+      if (tok == "variantSet") {
+        if (!SkipWhitespace()) {
+          return false;
+        }
+
+        std::string variantName;
+        if (!ReadBasicType(&variantName)) {
+          PUSH_ERROR_AND_RETURN("Failed to parse `variantSet` statement.");
+        }
+
+        DCOUT("variantName = " << variantName);
+
+        if (!SkipWhitespace()) {
+          return false;
+        }
+
+        if (!Expect('=')) {
+          return false;
+        }
+
+        if (!SkipWhitespace()) {
+          return false;
+        }
+
+        std::map<std::string, VariantContent> vmap;
+        if (!ParseVariantSet(primIdx, parentPrimIdx, depth, &vmap)) {
+          PUSH_ERROR_AND_RETURN("Failed to parse `variantSet` statement.");
+        }
+
+        variantSetList.emplace(variantName, vmap);
+
+        continue;
       }
 
       if (!Rewind(tok.size())) {
         return false;
       }
 
+      Specifier child_spec{Specifier::Invalid};
       if (tok == "def") {
+        child_spec = Specifier::Def;
+      } else if (tok == "over") {
+        child_spec = Specifier::Over;
+      } else if (tok == "class") {
+        child_spec = Specifier::Class;
+      }
+
+      if (child_spec != Specifier::Invalid) {
+        int64_t idx = _prim_idx_assign_fun(parentPrimIdx);
+        DCOUT("enter parseDef. spec = " << to_string(child_spec) << ", idx = "
+                                        << idx << ", rootIdx = " << primIdx);
+
         // recusive call
-        if (!ParseDefBlock(nestlevel + 1)) {
-          PUSH_ERROR_AND_RETURN("`def` block parse failed.");
+        if (!ParseBlock(child_spec, idx, primIdx, depth + 1)) {
+          PUSH_ERROR_AND_RETURN(
+              fmt::format("`{}` block parse failed.", to_string(child_spec)));
         }
+        DCOUT(fmt::format("Done parse `{}` block.", to_string(child_spec)));
       } else {
+        DCOUT("Enter ParsePrimProps.");
         // Assume PrimAttr
-        if (!ParsePrimAttr(&props)) {
+        if (!ParsePrimProps(&props, &propNames)) {
           PUSH_ERROR_AND_RETURN("Failed to parse Prim attribute.");
         }
       }
 
       if (!SkipWhitespaceAndNewline()) {
         return false;
       }
     }
   }
 
-  if (prim_type.empty()) {
-    // No Prim type specified. Treat it as GPrim
-
-#if 0  // TODO
-    if (IsToplevel()) {
-      if (references.size()) {
-        // Infer prim type from referenced asset.
-
-        if (references.size() > 1) {
-          PUSH_ERROR_AND_RETURN("TODO: multiple references\n");
-        }
-
-        auto it = references.begin();
-        const Reference &ref = it->second;
-        std::string filepath = ref.asset_path;
-
-        // usdOBJ?
-        if (endsWith(filepath, ".obj")) {
-          prim_type = "geom_mesh";
-        } else {
-          if (!io::IsAbsPath(filepath)) {
-            filepath = io::JoinPath(_base_dir, ref.asset_path);
-          }
+  std::string pTy = prim_type;
 
-          if (_reference_cache.count(filepath)) {
-            LOG_ERROR("TODO: Use cached info");
-          }
-
-          DCOUT("Reading references: " + filepath);
+  if (IsToplevel()) {
 
-          std::vector<uint8_t> data;
-          std::string err;
-          if (!io::ReadWholeFile(&data, &err, filepath,
-                                 /* max_filesize */ 0)) {
-            PUSH_ERROR_AND_RETURN("Failed to read file: " + filepath);
-          }
-
-          tinyusdz::StreamReader sr(data.data(), data.size(),
-                                    /* swap endian */ false);
-#if 0  // TODO
-            tinyusdz::ascii::AsciiParser parser(&sr);
-
-            std::string base_dir = io::GetBaseDir(filepath);
-
-            parser.SetBaseDir(base_dir);
-
-            {
-              bool ret = parser.Parse(tinyusdz::ascii::LOAD_STATE_REFERENCE);
-
-              if (!ret) {
-                PUSH_WARN("Failed to parse .usda: " << parser.GetError());
-              } else {
-                DCOUT("`references` load ok.");
-              }
-            }
-#else
-          USDAReader reader(sr);
-#endif
+    if (prim_type.empty()) {
+      // No Prim type specified. Treat it as Model
 
-#if 0  // TODO
-            std::string defaultPrim = parser.GetDefaultPrimName();
+      pTy = "Model";
+    }
 
-            DCOUT("defaultPrim: " + parser.GetDefaultPrimName());
+    if (!_prim_construct_fun_map.count(pTy)) {
+      if (_option.allow_unknown_prim) {
+        // Unknown Prim type specified. Treat it as Model
+        // Prim's type name will be storead in Model::prim_type_name
+        pTy = "Model";
+      }
+    }
 
-            const std::vector<GPrim> &root_nodes = parser.GetGPrims();
-            if (root_nodes.empty()) {
-              LOG_WARN("USD file does not contain any Prim node.");
-            } else {
-              size_t default_idx =
-                  0;  // Use the first element when corresponding defaultPrim
-                      // node is not found.
-
-              auto node_it = std::find_if(root_nodes.begin(), root_nodes.end(),
-                                          [defaultPrim](const GPrim &a) {
-                                            return !defaultPrim.empty() &&
-                                                   (a.name == defaultPrim);
-                                          });
-
-              if (node_it != root_nodes.end()) {
-                default_idx =
-                    size_t(std::distance(root_nodes.begin(), node_it));
-              }
-
-              DCOUT("defaultPrim node: " + root_nodes[default_idx].name);
-              for (size_t i = 0; i < root_nodes.size(); i++) {
-                DCOUT("root nodes: " + root_nodes[i].name);
-              }
+    if (_prim_construct_fun_map.count(pTy)) {
+      auto construct_fun = _prim_construct_fun_map[pTy];
 
-              // Store result to cache
-              _reference_cache[filepath] = {default_idx, root_nodes};
+      Path fullpath(GetCurrentPrimPath(), "");
+      Path pname(prim_name, "");
+      nonstd::expected<bool, std::string> ret = construct_fun(
+          fullpath, spec, prim_type, pname, primIdx, parentPrimIdx, props, in_metas, variantSetList);
 
-              prim_type = root_nodes[default_idx].prim_type;
-              DCOUT("Infered prim type: " + prim_type);
-            }
-#else
-          PUSH_WARN("TODO: References");
-#endif
-        }
+      if (!ret) {
+        // construction failed.
+        PUSH_ERROR_AND_RETURN("Constructing Prim type `" + pTy +
+                              "` failed: " + ret.error());
       }
+
     } else {
-      // Unknown or unresolved node type
-      LOG_ERROR("TODO: unresolved node type\n");
+      PUSH_WARN(fmt::format(
+          "TODO: Unsupported/Unimplemented Prim type: `{}`. Skipping parsing.",
+          pTy));
     }
-#endif
   } else {
+    // Load scene as PrimSpec tree
+    if (_primspec_fun) {
+      Path fullpath(GetCurrentPrimPath(), "");
+      Path pname(prim_name, "");
+
+      // pass prim_type as is(empty = empty string)
+      nonstd::expected<bool, std::string> ret = _primspec_fun(
+          fullpath, spec, prim_type, pname, primIdx, parentPrimIdx, props, in_metas, variantSetList);
 
-    if (_prim_construct_fun_map.count(prim_type)) {
-
-      auto construct_fun = _prim_construct_fun_map[prim_type];
-
-      Path path(GetCurrentPath());
-      if (!construct_fun(path, props, references)) {
+      if (!ret) {
         // construction failed.
-        PUSH_ERROR_AND_RETURN("Constructing " + prim_type + " failed.");
+        PUSH_ERROR_AND_RETURN(fmt::format("Constructing PrimSpec typeName `{}`, elementName `{}` failed: {}", prim_type, prim_name, ret.error()));
       }
-
+    } else {
+      PUSH_ERROR_AND_RETURN_TAG(kAscii, "[Internal Error] PrimSpec handler is not found.");
     }
   }
 
-  PopPath();
+  PopPrimPath();
 
   return true;
 }
 
 ///
 /// Parser entry point
-/// TODO: Refactor
+/// TODO: Refactor and use unified code path regardless of LoadState.
 ///
-bool AsciiParser::Parse(LoadState state) {
-
-  _sub_layered = (state == LoadState::SUBLAYER);
-  _referenced = (state == LoadState::REFERENCE);
-  _payloaded = (state == LoadState::PAYLOAD);
+bool AsciiParser::Parse(LoadState state, const AsciiParserOption &parser_option) {
+  _sub_layered = (state == LoadState::Sublayer);
+  _referenced = (state == LoadState::Reference);
+  _payloaded = (state == LoadState::Payload);
+  _option = parser_option;
 
   bool header_ok = ParseMagicHeader();
   if (!header_ok) {
-    PushError("Failed to parse USDA magic header.\n");
-    return false;
+    PUSH_ERROR_AND_RETURN("Failed to parse USDA magic header.\n");
   }
 
   SkipCommentAndWhitespaceAndNewline();
 
+  if (Eof()) {
+    // Empty USDA
+    return true;
+  }
+
   {
     char c;
     if (!LookChar1(&c)) {
       return false;
     }
 
     if (c == '(') {
       // stage meta.
+      // TODO: We could skip parsing stage meta in flatten(composition) mode.
       if (!ParseStageMetas()) {
         PUSH_ERROR_AND_RETURN("Failed to parse Stage metas.");
       }
     }
   }
 
-  if (_stage_meta_process_fun) {
+  if (IsToplevel() && _stage_meta_process_fun) {
     DCOUT("StageMeta callback.");
-    _stage_meta_process_fun(_stage_metas);
+    bool ret = _stage_meta_process_fun(_stage_metas);
+    if (!ret) {
+      PUSH_ERROR_AND_RETURN("Failed to reconstruct Stage metas.");
+    }
   }
 
-  PushPath("/");
+  PushPrimPath("/");
 
   // parse blocks
-  while (!_sr->eof()) {
+  while (!Eof()) {
     if (!SkipCommentAndWhitespaceAndNewline()) {
       return false;
     }
 
-    if (_sr->eof()) {
+    if (Eof()) {
       // Whitespaces in the end of line.
       break;
     }
 
     // Look ahead token
     auto curr_loc = _sr->tell();
 
     Identifier tok;
     if (!ReadBasicType(&tok)) {
-      PushError("Identifier expected.\n");
-      return false;
+      PUSH_ERROR_AND_RETURN("Identifier expected.\n");
     }
 
     // Rewind
     if (!SeekTo(curr_loc)) {
       return false;
     }
 
+    Specifier spec{Specifier::Invalid};
     if (tok == "def") {
-      bool block_ok = ParseDefBlock();
-      if (!block_ok) {
-        PushError("Failed to parse `def` block.\n");
-        return false;
-      }
+      spec = Specifier::Def;
     } else if (tok == "over") {
-      bool block_ok = ParseOverBlock();
-      if (!block_ok) {
-        PushError("Failed to parse `over` block.\n");
-        return false;
-      }
+      spec = Specifier::Over;
     } else if (tok == "class") {
-      bool block_ok = ParseClassBlock();
-      if (!block_ok) {
-        PushError("Failed to parse `class` block.\n");
-        return false;
-      }
+      spec = Specifier::Class;
     } else {
-      PushError("Unknown token '" + tok + "'");
-      return false;
+      PUSH_ERROR_AND_RETURN("Invalid specifier token '" + tok + "'");
+    }
+
+    int64_t primIdx = _prim_idx_assign_fun(-1);
+    DCOUT("Enter parseDef. primIdx = " << primIdx
+                                       << ", parentPrimIdx = root(-1)");
+    bool block_ok = ParseBlock(spec, primIdx, /* parent */ -1, /* depth */0, /* in_variantStmt */false);
+    if (!block_ok) {
+      PUSH_ERROR_AND_RETURN("Failed to parse `def` block.");
     }
   }
 
   return true;
 }
 
-}  // namespace ascii
-}  // namespace tinyusdz
+bool ParseUnregistredValue(const std::string &_typeName, const std::string &str, value::Value *value, std::string *err) {
+  if (!value) {
+    if (err) {
+      (*err) += "`value` argument is nullptr.\n";
+    }
+    return false;
+  }
 
-#else  // TINYUSDZ_DISABLE_MODULE_USDA_READER
+  bool array_qual = false;
+  std::string typeName = _typeName;
+  if (endsWith(typeName, "[]")) {
+    typeName = removeSuffix(typeName, "[]");
+    array_qual = true;
+  }
 
-#if 0
-#endif
+  nonstd::optional<uint32_t> typeId = value::TryGetTypeId(typeName);
 
-#if 0
-// Extract array of References from Variable.
-ReferenceList GetReferences(
-    const std::tuple<ListEditQual, value::any_value> &_var) {
-  ReferenceList result;
-
-  ListEditQual qual = std::get<0>(_var);
-
-  auto var = std::get<1>(_var);
-
-  SDCOUT << "GetReferences. var.name = " << var.name << "\n";
-
-  if (var.IsArray()) {
-    DCOUT("IsArray");
-    auto parr = var.as_array();
-    if (parr) {
-      DCOUT("parr");
-      for (const auto &v : parr->values) {
-        DCOUT("Maybe Value");
-        if (v.IsValue()) {
-          DCOUT("Maybe Reference");
-          if (auto pref = nonstd::get_if<Reference>(v.as_value())) {
-            DCOUT("Got it");
-            result.push_back({qual, *pref});
-          }
-        }
-      }
+  if (!typeId) {
+    if (err) {
+      (*err) += "Unsupported type: " + typeName + "\n";
     }
-  } else if (var.IsValue()) {
-    DCOUT("IsValue");
-    if (auto pv = var.as_value()) {
-      DCOUT("Maybe Reference");
-      if (auto pas = nonstd::get_if<Reference>(pv)) {
-        DCOUT("Got it");
-        result.push_back({qual, *pas});
-      }
+    return false;
+  }
+
+  tinyusdz::StreamReader sr(reinterpret_cast<const uint8_t *>(str.data()), str.size(), /* swap endian */ false);
+  tinyusdz::ascii::AsciiParser parser(&sr);
+
+#define PARSE_BASE_TYPE(__ty) case value::TypeTraits<__ty>::type_id(): { \
+    if (array_qual) { \
+      std::vector<__ty> vss; \
+      if (!parser.ParseBasicTypeArray(&vss)) { \
+        if (err) { \
+          (*err) = fmt::format("Failed to parse a value of type `{}[]`", value::TypeTraits<__ty>::type_name()); \
+        } \
+        return false; \
+      } \
+      dst = vss; \
+    } else { \
+      __ty val; \
+      if (!parser.ReadBasicType(&val)) { \
+        if (err) { \
+          (*err) = fmt::format("Failed to parse a value of type `{}`", value::TypeTraits<__ty>::type_name()); \
+        } \
+        return false; \
+      } \
+      dst = val; \
+    } \
+    break; \
+  }
+
+  value::Value dst;
+
+
+  switch (typeId.value()) {
+  PARSE_BASE_TYPE(value::uint2)
+  PARSE_BASE_TYPE(value::uint3)
+  PARSE_BASE_TYPE(value::uint4)
+  default: {
+    if (err) {
+      (*err) = fmt::format("Unsupported or unimplemeneted type `{}`", typeName);
     }
-  } else {
-    DCOUT("Unknown var type: " + Variable::type_name(var));
+    return false;
+  }
   }
 
-  return result;
+  (*value) = std::move(dst);
+
+  return true;
+}
+
+}  // namespace ascii
+}  // namespace tinyusdz
+
+#else  // TINYUSDZ_DISABLE_MODULE_USDA_READER
+
+bool ParseUnregistredValue(const std::string &typeName, const std::string &str, value::Value *value, std::string *err) {
+  if (err) {
+    (*err) += "USDA_READER module is disabled.\n";
+  }
+  return false;
 }
-#endif
 
 #endif  // TINYUSDZ_DISABLE_MODULE_USDA_READER
```

### Comparing `tinyusdz-0.8.0rc0/src/ascii-parser.hh` & `tinyusdz-0.8.0rc1/src/usdc-writer.cc`

 * *Files 24% similar despite different names*

```diff
@@ -1,646 +1,597 @@
 // SPDX-License-Identifier: MIT
-// Copyright 2021 - Present, Syoyo Fujita.
+// Copyright 2022 - Present Syoyo Fujita.
 //
-// USD ASCII parser
 
-#pragma once
+#include "usdc-writer.hh"
 
-#include <clocale>
-#include <stack>
-#include <functional>
+#if !defined(TINYUSDZ_DISABLE_MODULE_USDC_WRITER)
 
-#include "stream-reader.hh"
-#include "tinyusdz.hh"
-
-#include "external/better-enums/enum.h"
+#if defined(_MSC_VER) || defined(__MINGW32__)
+#if defined(__clang__)
+// No need to define NOMINMAX for llvm-mingw
+#else
+#ifndef NOMINMAX
+#define NOMINMAX
+#endif
+#endif
 
-//
-#ifdef __clang__
+#if defined(__clang__)
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Weverything"
 #endif
 
-// external
-#include "nonstd/expected.hpp"
 
-//
-#ifdef __clang__
-#pragma clang diagnostic pop
+#ifndef WIN32_LEAN_AND_MEAN
+#define WIN32_LEAN_AND_MEAN
 #endif
 
+#include <windows.h>  // include API for expanding a file path
 
-namespace tinyusdz {
+#if defined(__clang__)
+#pragma clang diagnostic pop
+#endif
 
-namespace ascii {
+#endif
 
-// keywords
-constexpr auto kUniform = "uniform";
-constexpr auto kToken = "token";
-
-// Prim name
-constexpr auto kGPrim = "GPrim";
-constexpr auto kGeomMesh = "Mesh";
-constexpr auto kGeomSubset = "GeomSubset";
-constexpr auto kGeomCone = "Cone";
-constexpr auto kGeomCube = "Cube";
-constexpr auto kLuxSphereLight = "SphereLight";
-constexpr auto kLuxDomeLight = "DomeLight";
-constexpr auto kMaterial = "Mateiral";
-constexpr auto kShader = "Shader";
-
-// Frequently used attr/meta keywords
-constexpr auto kKind = "kind";
-constexpr auto kInterpolation = "interpolation";
-
-enum class LoadState {
-  TOPLEVEL,   // toplevel .usda input
-  SUBLAYER,   // .usda is read by 'subLayers'
-  REFERENCE,  // .usda is read by `references`
-  PAYLOAD,    // .usda is read by `payload`
-};
 
-// Prim Kind
-// https://graphics.pixar.com/usd/release/glossary.html#usdglossary-kind
-#if 0
-enum class Kind {
-  Model,  // "model"
-  Group,  // "group"
-  Assembly, // "assembly"
-  Component, // "component"
-  Subcomponent, // "subcomponent"
-};
-#else
+#include <fstream>
+#include <iostream>
+#include <sstream>
+
+#include "crate-format.hh"
+#include "io-util.hh"
+#include "lz4-compression.hh"
+#include "token-type.hh"
 
-#ifdef __clang__
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Weverything"
-#endif
+#include "common-macros.inc"
 
-BETTER_ENUM(Kind, int, model, group, assembly, component, subcomponent);
+namespace tinyusdz {
+namespace usdc {
 
-#ifdef __clang__
-#pragma clang diagnostic pop
-#endif
+namespace {
 
-#endif
+constexpr size_t kSectionNameMaxLength = 15;
 
+#ifdef _WIN32
+std::wstring UTF8ToWchar(const std::string &str) {
+  int wstr_size =
+      MultiByteToWideChar(CP_UTF8, 0, str.data(), int(str.size()), nullptr, 0);
+  std::wstring wstr(size_t(wstr_size), 0);
+  MultiByteToWideChar(CP_UTF8, 0, str.data(), int(str.size()), &wstr[0],
+                      int(wstr.size()));
+  return wstr;
+}
 
-///
-/// Test if input file is USDA ascii format.
-///
-bool IsUSDA(const std::string &filename, size_t max_filesize = 0);
+#if 0
+std::string WcharToUTF8(const std::wstring &wstr) {
+  int str_size = WideCharToMultiByte(CP_UTF8, 0, wstr.data(), int(wstr.size()),
+                                     nullptr, 0, nullptr, nullptr);
+  std::string str(size_t(str_size), 0);
+  WideCharToMultiByte(CP_UTF8, 0, wstr.data(), int(wstr.size()), &str[0],
+                      int(str.size()), nullptr, nullptr);
+  return str;
+}
+#endif
+#endif
 
+struct Section {
+  Section() { memset(this, 0, sizeof(*this)); }
+  Section(char const *name, int64_t start, int64_t size);
+  char name[kSectionNameMaxLength + 1];
+  int64_t start, size;  // byte offset to section info and its data size
+};
 
+//
+// TOC = list of sections.
+//
+struct TableOfContents {
+  // Section const *GetSection(SectionName) const;
+  // int64_t GetMinimumSectionStart() const;
+  std::vector<Section> sections;
+};
 
-class AsciiParser {
+//struct Field {
+//  // FIXME(syoyo): Do we need 4 bytes padding as done in pxrUSD?
+//  // uint32_t padding_;
+//
+//  crate::TokenIndex token_index;
+//  crate::ValueRep value_rep;
+//};
 
- public:
+#if 0
+// For unordered_map
 
-  struct PrimMetas {
-    // Frequently used prim metas
-    nonstd::optional<Kind> kind;
-
-    value::dict customData; // `customData`
-  };
-
-  struct StageMetas {
-    ///
-    /// Predefined Stage metas
-    ///
-    std::vector<std::string> subLayers;
-    std::string defaultPrim;
-    std::string doc;
-    nonstd::optional<Axis> upAxis; // not specified = nullopt
-    nonstd::optional<double> metersPerUnit;
-    nonstd::optional<double> timeCodesPerSecond;
-
-    value::dict customData; // `customData`(non-predefined Stage metas).
-  };
-
-  struct ParseState {
-    int64_t loc{-1};  // byte location in StreamReder
-  };
-
-  struct Cursor {
-    int row{0};
-    int col{0};
-  };
+// https://stackoverflow.com/questions/8513911/how-to-create-a-good-hash-combine-with-64-bit-output-inspired-by-boosthash-co
+// From CityHash code.
+template <class T>
+inline void hash_combine(std::size_t &seed, const T &v) {
+#ifdef __wasi__  // 32bit platform
+  // Use boost version.
+  std::hash<T> hasher;
+  seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
+#else
+  std::hash<T> hasher;
+  const uint64_t kMul = 0x9ddfea08eb382d69ULL;
+  std::size_t a = (hasher(v) ^ seed) * kMul;
+  a ^= (a >> 47);
+  std::size_t b = (seed ^ a) * kMul;
+  b ^= (b >> 47);
+  seed = b * kMul;
+#endif
+}
 
-  struct ErrorDiagnositc {
-    std::string err;
-    Cursor cursor;
-  };
+struct PathHasher {
+  size_t operator()(const Path &path) const {
+    size_t seed = std::hash<std::string>()(path.GetPrimPart());
+    hash_combine(seed, std::hash<std::string>()(path.GetPropPart()));
+    hash_combine(seed, std::hash<std::string>()(path.GetLocalPart()));
+    hash_combine(seed, std::hash<bool>()(path.IsValid()));
 
-  void PushError(const std::string &msg) {
-    ErrorDiagnositc diag;
-    diag.cursor.row = _curr_cursor.row;
-    diag.cursor.col = _curr_cursor.col;
-    diag.err = msg;
-    err_stack.push(diag);
+    return seed;
   }
+};
 
-  // This function is used to cancel recent parsing error.
-  void PopError() {
-    if (!err_stack.empty()) {
-      err_stack.pop();
-    }
-  }
+struct PathKeyEqual {
+  bool operator()(const Path &lhs, const Path &rhs) const {
+    bool ret = lhs.GetPrimPart() == rhs.GetPrimPart();
+    ret &= lhs.GetPropPart() == rhs.GetPropPart();
+    ret &= lhs.GetLocalPart() == rhs.GetLocalPart();
+    ret &= lhs.IsValid() == rhs.IsValid();
 
-  void PushWarn(const std::string &msg) {
-    ErrorDiagnositc diag;
-    diag.cursor.row = _curr_cursor.row;
-    diag.cursor.col = _curr_cursor.col;
-    diag.err = msg;
-    warn_stack.push(diag);
+    return ret;
   }
+};
 
-  // This function is used to cancel recent parsing warning.
-  void PopWarn() {
-    if (!warn_stack.empty()) {
-      warn_stack.pop();
-    }
-  }
+struct FieldHasher {
+  size_t operator()(const Field &field) const {
+    size_t seed = std::hash<uint32_t>()(field.token_index.value);
+    hash_combine(seed, std::hash<uint64_t>()(field.value_rep.GetData()));
 
-  bool IsStageMeta(const std::string &name);
-  bool IsPrimMeta(const std::string &name);
+    return seed;
+  }
+};
 
+struct FieldKeyEqual {
+  bool operator()(const Field &lhs, const Field &rhs) const {
+    bool ret = lhs.token_index == rhs.token_index;
+    ret &= lhs.value_rep == rhs.value_rep;
 
-  class VariableDef {
-   public:
-    // Handler functor in post parsing stage.
-    // e.g. Check input string is a valid one: one of "common", "group", "assembly", "component" or "subcomponent" for "kind" metadata
-    using PostParseHandler = std::function<nonstd::expected<bool, std::string>(const std::string &)>;
+    return ret;
+  }
+};
 
-    static nonstd::expected<bool, std::string> DefaultPostParseHandler(const std::string &) {
-      return true;
+struct FieldSetHasher {
+  size_t operator()(const std::vector<crate::FieldIndex> &fieldset) const {
+    if (fieldset.empty()) {
+      return 0;
     }
 
-    std::string type;
-    std::string name;
-
-    PostParseHandler post_parse_handler;
+    size_t seed = std::hash<uint32_t>()(fieldset[0].value);
+    for (size_t i = 1; i < fieldset.size(); i++) {
+      hash_combine(seed, std::hash<uint32_t>()(fieldset[i].value));
+    }
 
-    VariableDef() = default;
+    return seed;
+  }
+};
+#endif
 
-    VariableDef(const std::string &t, const std::string &n, PostParseHandler ph = DefaultPostParseHandler)
-        : type(t), name(n), post_parse_handler(ph) {}
+class Packer {
+ public:
+  crate::TokenIndex AddToken(const Token &token);
+  crate::StringIndex AddString(const std::string &str);
+  crate::PathIndex AddPath(const Path &path);
+  crate::FieldIndex AddField(const crate::Field &field);
+  crate::FieldSetIndex AddFieldSet(
+      const std::vector<crate::FieldIndex> &field_indices);
 
-    VariableDef(const VariableDef &rhs) = default;
-    VariableDef &operator=(const VariableDef &rhs) = default;
+  const std::vector<Token> &GetTokens() const { return tokens_; }
 
-    //VariableDef &operator=(const VariableDef &rhs) {
-    //  type = rhs.type;
-    //  name = rhs.name;
-    //  parse_handler = rhs.parse_handler;
+ private:
+  std::unordered_map<Token, crate::TokenIndex, TokenHasher, TokenKeyEqual>
+      token_to_index_map;
+  std::unordered_map<std::string, crate::StringIndex> string_to_index_map;
+  std::unordered_map<Path, crate::PathIndex, crate::PathHasher, crate::PathKeyEqual>
+      path_to_index_map;
+  std::unordered_map<crate::Field, crate::FieldIndex, crate::FieldHasher, crate::FieldKeyEqual>
+      field_to_index_map;
+  std::unordered_map<std::vector<crate::FieldIndex>, crate::FieldSetIndex,
+                     crate::FieldSetHasher>
+      fieldset_to_index_map;
+
+  std::vector<Token> tokens_;
+  std::vector<std::string> strings_;
+  std::vector<Path> paths_;
+  std::vector<crate::Field> fields_;
+  std::vector<crate::FieldIndex>
+      fieldsets_;  // flattened 1D array of FieldSets. Each span is terminated
+                   // by Index()(= ~0)
+};
 
-    //  return *this;
-    //}
-  };
+crate::TokenIndex Packer::AddToken(const Token &token) {
+  if (token_to_index_map.count(token)) {
+    return token_to_index_map[token];
+  }
 
-  AsciiParser();
-  AsciiParser(tinyusdz::StreamReader *sr);
+  // index = size of umap
+  token_to_index_map[token] = crate::TokenIndex(uint32_t(tokens_.size()));
+  tokens_.emplace_back(token);
+
+  return token_to_index_map[token];
+}
+
+crate::StringIndex Packer::AddString(const std::string &str) {
+  if (string_to_index_map.count(str)) {
+    return string_to_index_map[str];
+  }
 
-  AsciiParser(const AsciiParser &rhs) = delete;
-  AsciiParser(AsciiParser &&rhs) = delete;
+  // index = size of umap
+  string_to_index_map[str] = crate::StringIndex(uint32_t(strings_.size()));
+  strings_.emplace_back(str);
+
+  return string_to_index_map[str];
+}
+
+crate::PathIndex Packer::AddPath(const Path &path) {
+  if (path_to_index_map.count(path)) {
+    return path_to_index_map[path];
+  }
 
-  ~AsciiParser();
-
-  ///
-  /// Stage Meta construction callback function
-  ///
-  using StageMetaProcessFunction = std::function<bool(const StageMetas& metas)>;
-
-  ///
-  /// Register Stage metadatum processing callback function.
-  /// Called when after parsing Stage metadatum.
-  ///
-  void RegisterStageMetaProcessFunction(StageMetaProcessFunction fun) {
-    _stage_meta_process_fun = fun;
-  }
-
-  ///
-  /// Prim Meta construction callback function
-  ///
-  using PrimMetaProcessFunction = std::function<bool(const PrimMetas& metas)>;
-
-
-  ///
-  /// Prim construction callback function
-  /// TODO: use std::function?
-  ///
-  using PrimConstructFunction = std::function<bool(const Path &path, const std::map<std::string, Property> &properties,
-    std::vector<std::pair<ListEditQual, Reference>> &references)>;
-
-  ///
-  /// Register Prim construction callback function.
-  /// Example: "Xform", ReconstrctXform
-  ///
-  void RegisterPrimConstructFunction(const std::string &prim_type, PrimConstructFunction fun) {
-    _prim_construct_fun_map[prim_type] = fun;
-  }
-
-  ///
-  /// Base filesystem directory to search asset files.
-  ///
-  void SetBaseDir(const std::string &base_dir);
-
-  ///
-  /// Set ASCII data stream
-  ///
-  void SetStream(tinyusdz::StreamReader *sr);
-
-  ///
-  /// Check if header data is USDA
-  ///
-  bool CheckHeader();
-
-  ///
-  /// Parser entry point
-  ///
-  bool Parse(LoadState state = LoadState::TOPLEVEL);
-
-  // TODO: ParseBasicType?
-  bool ParsePurpose(Purpose *result);
-
-  ///
-  /// Return true but `value` is set to nullopt for `None`(Attribute Blocked)
-  ///
-  template <typename T>
-  bool ReadBasicType(nonstd::optional<T> *value);
-
-  template <typename T>
-  bool ReadBasicType(T *value);
-
-  template<typename T>
-  bool ParseMatrix(T *result);
-
-  ///
-  /// Parse '(', Sep1By(','), ')'
-  ///
-  template <typename T, size_t N>
-  bool ParseBasicTypeTuple(std::array<T, N> *result);
-
-  ///
-  /// Parse '(', Sep1By(','), ')'
-  /// Can have `None`
-  ///
-  template <typename T, size_t N>
-  bool ParseBasicTypeTuple(nonstd::optional<std::array<T, N>> *result);
-
-  template <typename T, size_t N>
-  bool ParseTupleArray(std::vector<std::array<T, N>> *result);
-
-  ///
-  /// Parse the array of tuple. some may be None(e.g. `float3`: [(0, 1, 2),
-  /// None, (2, 3, 4), ...] )
-  ///
-  template <typename T, size_t N>
-  bool ParseTupleArray(std::vector<nonstd::optional<std::array<T, N>>> *result);
-
-  template <typename T>
-  bool SepBy1BasicType(const char sep, std::vector<T> *result);
-
-  ///
-  /// Parse '[', Sep1By(','), ']'
-  ///
-  template <typename T>
-  bool ParseBasicTypeArray(std::vector<nonstd::optional<T>> *result);
-
-  ///
-  /// Parse '[', Sep1By(','), ']'
-  ///
-  template <typename T>
-  bool ParseBasicTypeArray(std::vector<T> *result);
-
-  ///
-  /// Parses 1 or more occurences of value with basic type 'T', separated by
-  /// `sep`
-  ///
-  template <typename T>
-  bool SepBy1BasicType(const char sep,
-                       std::vector<nonstd::optional<T>> *result);
-
-  ///
-  /// Parses 1 or more occurences of tuple values with type 'T', separated by
-  /// `sep`. Allows 'None'
-  ///
-  template <typename T, size_t N>
-  bool SepBy1TupleType(const char sep,
-                       std::vector<nonstd::optional<std::array<T, N>>> *result);
-
-  ///
-  /// Parses 1 or more occurences of tuple values with type 'T', separated by
-  /// `sep`
-  ///
-  template <typename T, size_t N>
-  bool SepBy1TupleType(const char sep, std::vector<std::array<T, N>> *result);
+  // index = size of umap
+  path_to_index_map[path] = crate::PathIndex(uint32_t(paths_.size()));
+  paths_.emplace_back(path);
+
+  return path_to_index_map[path];
+}
+
+crate::FieldIndex Packer::AddField(const crate::Field &field) {
+  if (field_to_index_map.count(field)) {
+    return field_to_index_map[field];
+  }
 
-  bool ParseDictElement(std::string *out_key, MetaVariable *out_var);
-  bool ParseDict(std::map<std::string, MetaVariable> *out_dict);
+  // index = size of umap
+  field_to_index_map[field] = crate::FieldIndex(uint32_t(fields_.size()));
+  fields_.emplace_back(field);
+
+  return field_to_index_map[field];
+}
+
+crate::FieldSetIndex Packer::AddFieldSet(
+    const std::vector<crate::FieldIndex> &fieldset) {
+  if (fieldset_to_index_map.count(fieldset)) {
+    return fieldset_to_index_map[fieldset];
+  }
 
-  bool MaybeListEditQual(tinyusdz::ListEditQual *qual);
+  // index = size of umap = star index of FieldSet span.
+  fieldset_to_index_map[fieldset] =
+      crate::FieldSetIndex(uint32_t(fieldsets_.size()));
 
-#if 0
-  ///
-  ///
-  ///
-  std::string GetDefaultPrimName() const;
-
-  ///
-  /// Get parsed toplevel "def" nodes(GPrim)
-  ///
-  std::vector<GPrim> GetGPrims();
-#endif
-  class PrimIterator;
-  using const_iterator = PrimIterator;
-  const_iterator begin() const;
-  const_iterator end() const;
-  
-
-  ///
-  /// Get error message(when `Parse` failed)
-  ///
-  std::string GetError();
-
-  ///
-  /// Get warning message(warnings in `Parse`)
-  ///
-  std::string GetWarning();
+  fieldsets_.insert(fieldsets_.end(), fieldset.begin(), fieldset.end());
+  fieldsets_.push_back(crate::FieldIndex());  // terminator(~0)
 
-#if 0
-  ///
-  /// Get as scene
-  ///
-  const HighLevelScene& GetHighLevelScene() const;
-#endif
+  return fieldset_to_index_map[fieldset];
+}
 
-  // Return the flag if the .usda is read from `references`
-  bool IsReferenced() { return _referenced; }
+class Writer {
+ public:
+  Writer(const Stage &stage) : stage_(stage) {}
 
-  // Return the flag if the .usda is read from `subLayers`
-  bool IsSubLayered() { return _sub_layered; }
+  const Stage &stage_;
 
-  // Return the flag if the .usda is read from `payload`
-  bool IsPayloaded() { return _payloaded; }
+  const std::string &GetError() const { return err_; }
+  const std::string &GetWarning() const { return warn_; }
 
-  // Return true if the .udsa is read in the top layer(stage)
-  bool IsToplevel() {
-    return !IsReferenced() && !IsSubLayered() && !IsPayloaded();
+  void PushError(const std::string &s) {
+    err_ += s;
   }
 
-  bool MaybeNone();
-  bool MaybeCustom();
-
-  template <typename T>
-  bool MaybeNonFinite(T *out);
+  void PushWarn(const std::string &s) {
+    warn_ += s;
+  }
 
-  bool LexFloat(std::string *result);
+  bool WriteHeader(uint64_t toc_offset) {
+    char magic[8];
+    magic[0] = 'P';
+    magic[1] = 'X';
+    magic[2] = 'R';
+    magic[3] = '-';
+    magic[4] = 'U';
+    magic[5] = 'S';
+    magic[6] = 'D';
+    magic[7] = 'C';
+
+    uint8_t version[8];  // Only first 3 bytes are used.
+    version[0] = 0;
+    version[1] = 8;
+    version[2] = 0;
+
+    std::array<uint8_t, 88> header;
+    memset(&header, 0, 88);
+
+    memcpy(&header[0], magic, 8);
+    memcpy(&header[8], version, 8);
+    memcpy(&header[16], &toc_offset, 8);
 
-  bool Expect(char expect_c);
+    oss_.write(reinterpret_cast<const char *>(&header[0]), 88);
 
-  bool ReadStringLiteral(std::string *literal);  // identifier wrapped with '"'
-  bool ReadPrimAttrIdentifier(std::string *token);
-  bool ReadIdentifier(std::string *token);  // no '"'
-  bool ReadPathIdentifier(
-      std::string *path_identifier);  // '<' + identifier + '>'
+    return true;
+  }
 
-  /// Parse magic
-  /// #usda FLOAT
-  bool ParseMagicHeader();
+  bool WriteTokens() {
+    // Build single string separated by '\0', then compress it with lz4
+    std::ostringstream oss;
 
-  bool SkipWhitespace();
-  bool SkipWhitespaceAndNewline();
-  bool SkipCommentAndWhitespaceAndNewline();
-  bool SkipUntilNewline();
+    auto tokens = packer_.GetTokens();
 
-  // bool ParseAttributeMeta();
-  bool ParseAttrMeta(AttrMeta *out_meta);
+    for (size_t i = 0; i < tokens.size(); i++) {
+      oss << tokens[i].str();
 
-#if 0
-  nonstd::optional<PrimMetas> ReconstructPrimMetas(
-      std::map<std::string, std::tuple<ListEditQual, MetaVariable>> &args);
-#endif
+      if (i != (tokens.size() - 1)) {
+        oss.put('\0');  // separator
+      }
+    }
+    // Last string does not terminated with `\0'
 
-  bool ParsePrimMetas(
-      std::map<std::string, std::tuple<ListEditQual, MetaVariable>> *args);
+    // compress
+    size_t input_bytes = oss.str().size();
+    if (input_bytes == 0) {
+      PUSH_ERROR("Invalid data size.");
+      return false;
+    }
 
-  bool ParseMetaValue(const VariableDef &def,
-                      MetaVariable *outvar);
+    std::vector<char> buf;
+    buf.resize(LZ4Compression::GetCompressedBufferSize(input_bytes));
 
-  bool ParseStageMetaOpt();
-  // Parsed Stage metadatum is stored in this instance.
-  bool ParseStageMetas();
+    std::string err;
+    size_t n = LZ4Compression::CompressToBuffer(oss.str().data(), buf.data(),
+                                                input_bytes, &err);
 
-  bool ParseCustomMetaValue();
+    (void)n;
 
-  // TODO: Return Path
-  bool ParseReference(Reference *out, bool *triple_deliminated);
+    if (!err.empty()) {
+      PUSH_ERROR(err);
+      return false;
+    }
 
-  // `#` style comment
-  bool ParseSharpComment();
+    return true;
+  }
 
-  bool IsSupportedPrimAttrType(const std::string &ty);
-  bool IsSupportedPrimType(const std::string &ty);
+  bool WriteStrings() { return false; }
 
-  bool Eof() { return _sr->eof(); }
+  bool WriteFields() { return false; }
 
-  bool ParseRel(Rel *result);
-  bool ParseProperty(std::map<std::string, Property> *props);
+  bool WriteFieldSets() { return false; }
 
+  bool WritePaths() { return false; }
 
-  //
-  // Look***() : Fetch chars but do not change input stream position.
-  //
+  bool WriteSpecs() { return false; }
 
-  bool LookChar1(char *c);
-  bool LookCharN(size_t n, std::vector<char> *nc);
+  bool WriteTOC() {
+    uint64_t num_sections = toc_.sections.size();
 
-  bool Char1(char *c);
-  bool CharN(size_t n, std::vector<char> *nc);
+    DCOUT("# of sections = " << std::to_string(num_sections));
 
-  bool Rewind(size_t offset);
-  uint64_t CurrLoc();
-  bool SeekTo(size_t pos);
+    if (num_sections == 0) {
+      err_ += "Zero sections in TOC.\n";
+      return false;
+    }
 
-  bool PushParserState();
-  bool PopParserState(ParseState *state);
+    // # of sections
+    oss_.write(reinterpret_cast<const char *>(&num_sections), 8);
 
-  //
-  // Valid after ParseStageMetas() --------------
-  //
-  StageMetas GetStageMetas() const {
-    return _stage_metas;
+    return true;
   }
 
-  bool ParseClassBlock();
-  bool ParseOverBlock();
-  bool ParseDefBlock(uint32_t nestlevel = 0);
-
-  // --------------------------------------------
-
- private:
+  bool Write() {
+    //
+    //  - TOC
+    //  - Tokens
+    //  - Strings
+    //  - Fields
+    //  - FieldSets
+    //  - Paths
+    //  - Specs
+    //
+
+    if (!WriteTokens()) {
+      PUSH_ERROR("Failed to write Tokens.");
+      return false;
+    }
 
-  ///
-  /// Do common setups. Assume called in ctor.
-  ///
-  void Setup();
+    if (!WriteStrings()) {
+      PUSH_ERROR("Failed to write Strings.");
+      return false;
+    }
 
-  //template<typename T>
-  //bool ParseTimeSampleData(nonstd::optional<T> *out_value);
+    if (!WriteFields()) {
+      PUSH_ERROR("Failed to write Fields.");
+      return false;
+    }
 
-  template<typename T>
-  using TimeSampleData = std::vector<std::pair<double, nonstd::optional<T>>>;
+    if (!WriteFieldSets()) {
+      PUSH_ERROR("Failed to write FieldSets.");
+      return false;
+    }
 
-  ///
-  /// Convert TimeSampleData<T> to TimeSamples(type-erased TimeSample Sdata struct)
-  ///
-  template<typename T>
-  value::TimeSamples ConvertToTimeSamples(
-      const TimeSampleData<T> &in);
+    if (!WritePaths()) {
+      PUSH_ERROR("Failed to write Paths.");
+      return false;
+    }
 
-  template <typename T>
-  nonstd::optional<TimeSampleData<T>> TryParseTimeSamples() {
-    // timeSamples = '{' (int : T), + '}'
+    if (!WriteSpecs()) {
+      PUSH_ERROR("Failed to write Specs.");
+      return false;
+    }
 
-    TimeSampleData<T> data;
+    // TODO(syoyo): Add feature to support writing unknown section(custom user
+    // data)
+    // if (!WriteUnknownSections()) {
+    //  PUSH_ERROR("Failed to write custom sections.");
+    //  return false;
+    //}
 
-    if (!Expect('{')) {
-      return nonstd::nullopt;
+    const uint64_t toc_offset = static_cast<uint64_t>(oss_.tellp());
+    if (!WriteTOC()) {
+      PUSH_ERROR("Failed to write TOC.");
+      return false;
     }
 
-    if (!SkipWhitespaceAndNewline()) {
-      return nonstd::nullopt;
+    // write header
+    oss_.seekp(0, std::ios::beg);
+    if (!WriteHeader(toc_offset)) {
+      PUSH_ERROR("Failed to write Header.");
+      return false;
     }
 
-    while (!Eof()) {
-      char c;
-      if (!Char1(&c)) {
-        return nonstd::nullopt;
-      }
+    return true;
+  }
 
-      if (c == '}') {
-        break;
-      }
+  // Get serialized USDC binary data
+  bool GetOutput(std::vector<uint8_t> *output) {
+    if (!err_.empty()) {
+      return false;
+    }
 
-      Rewind(1);
+    (void)output;
 
-      double timeVal;
-      // -inf, inf and nan are handled.
-      if (!ReadBasicType(&timeVal)) {
-        PushError("Parse time value failed.");
-        return nonstd::nullopt;
-      }
+    // TODO
+    return false;
+  }
 
-      if (!SkipWhitespace()) {
-        return nonstd::nullopt;
-      }
+ private:
+  Writer() = delete;
+  Writer(const Writer &) = delete;
 
-      if (!Expect(':')) {
-        return nonstd::nullopt;
-      }
+  TableOfContents toc_;
 
-      if (!SkipWhitespace()) {
-        return nonstd::nullopt;
-      }
+  Packer packer_;
 
-      nonstd::optional<T> value;
-      if (!ReadBasicType(&value)) {
-        return nonstd::nullopt;
-      }
+  //
+  // Serialized data
+  //
+  std::ostringstream oss_;
 
-      // It looks the last item also requires ','
-      if (!Expect(',')) {
-        return nonstd::nullopt;
-      }
+  std::string err_;
+  std::string warn_;
+};
 
-      if (!SkipWhitespaceAndNewline()) {
-        return nonstd::nullopt;
-      }
+}  // namespace
 
-      data.push_back({timeVal, value});
-    }
+bool SaveAsUSDCToFile(const std::string &filename, const Stage &stage,
+                      std::string *warn, std::string *err) {
+#ifdef __ANDROID__
+  (void)filename;
+  (void)stage;
+  (void)warn;
 
-    return std::move(data);
+  if (err) {
+    (*err) += "Saving USDC to a file is not supported for Android platform(at the moment).\n";
   }
+  return false;
+#else
 
+  std::vector<uint8_t> output;
 
-  nonstd::optional<std::tuple<ListEditQual, MetaVariable>> ParsePrimMeta();
-  bool ParsePrimAttr(std::map<std::string, Property> *props);
-
-  template <typename T>
-  bool ParseBasicPrimAttr(bool array_qual,
-                                       const std::string &primattr_name,
-                                       PrimAttrib *out_attr);
-
-
-  bool ParseStageMeta(std::tuple<ListEditQual, MetaVariable> *out);
-  nonstd::optional<VariableDef> GetStageMetaDefinition(const std::string &name);
+  if (!SaveAsUSDCToMemory(stage, &output, warn, err)) {
+    return false;
+  }
 
-  std::string GetCurrentPath();
-  bool PathStackDepth() { return _path_stack.size(); }
-  void PushPath(const std::string &p) { _path_stack.push(p); }
-  void PopPath() {
-    if (!_path_stack.empty()) {
-      _path_stack.pop();
+#ifdef _WIN32
+#if defined(_MSC_VER) || defined(__GLIBCXX__) || defined(__clang__)
+  FILE *fp = nullptr;
+  errno_t fperr = _wfopen_s(&fp, UTF8ToWchar(filename).c_str(), L"wb");
+  if (fperr != 0) {
+    if (err) {
+      // TODO: WChar
+      (*err) += "Failed to open file to write.\n";
     }
+    return false;
   }
+#else
+  FILE *fp = nullptr;
+  errno_t fperr = fopen_s(&fp, filename.c_str(), "wb");
+  if (fperr != 0) {
+    if (err) {
+      (*err) += "Failed to open file `" + filename + "` to write.\n";
+    }
+    return false;
+  }
+#endif
 
-  const tinyusdz::StreamReader *_sr = nullptr;
-
-  nonstd::optional<VariableDef> GetPrimMeta(const std::string &arg);
+#else
+  FILE *fp = fopen(filename.c_str(), "wb");
+  if (fp == nullptr) {
+    if (err) {
+      (*err) += "Failed to open file `" + filename + "` to write.\n";
+    }
+    return false;
+  }
+#endif
 
-  // "class" defs
-  std::map<std::string, Klass> _klasses;
-  std::stack<std::string> _path_stack;
+  size_t n = fwrite(output.data(), /* size */ 1, /* count */ output.size(), fp);
+  if (n < output.size()) {
+    // TODO: Retry writing data when n < output.size()
 
-#if 0
-  // Cache of loaded `references`
-  // <filename, {defaultPrim index, list of root nodes in referenced usd file}>
-  std::map<std::string, std::pair<uint32_t, std::vector<GPrim>>>
-        _reference_cache;
+    if (err) {
+      (*err) += "Failed to write data to a file.\n";
+    }
+    return false;
+  }
 
-    // toplevel "def" defs
-    std::vector<GPrim> _gprims;
+  return true;
 #endif
+}
 
-  Cursor _curr_cursor;
+bool SaveAsUSDCToMemory(const Stage &stage, std::vector<uint8_t> *output,
+                        std::string *warn, std::string *err) {
+  (void)warn;
+  (void)output;
 
-  // Supported Prim types
-  std::set<std::string> _supported_prim_types;
-  std::set<std::string> _supported_prim_attr_types;
+  // TODO
+  Writer writer(stage);
 
-  // Supported metadataum for Stage
-  std::map<std::string, VariableDef> _supported_stage_metas;
+  if (err) {
+    (*err) += "USDC writer is not yet implemented.\n";
+  }
+
+  return false;
+}
 
-  // Supported metadataum for Prim.
-  std::map<std::string, VariableDef> _supported_prim_metas;
+}  // namespace usdc
+}  // namespace tinyusdz
 
-  std::stack<ErrorDiagnositc> err_stack;
-  std::stack<ErrorDiagnositc> warn_stack;
-  std::stack<ParseState> parse_stack;
+#else
 
-  float _version{1.0f};
+namespace tinyusdz {
+namespace usdc {
 
-  // load flags
-  bool _sub_layered{false};
-  bool _referenced{false};
-  bool _payloaded{false};
+bool SaveAsUSDCToFile(const std::string &filename, const Scene &scene,
+                      std::string *warn, std::string *err) {
+  (void)filename;
+  (void)scene;
+  (void)warn;
 
-  std::string _base_dir;
+  if (err) {
+    (*err) = "USDC writer feature is disabled in this build.\n";
+  }
 
-  StageMetas _stage_metas;
+  return false;
+}
 
-  //
-  // Callbacks
-  //
-  StageMetaProcessFunction _stage_meta_process_fun;
-  PrimMetaProcessFunction _prim_meta_process_fun;
-  std::map<std::string, PrimConstructFunction> _prim_construct_fun_map;
+bool SaveAsUSDCToMemory(const Scene &scene, std::vector<uint8_t> *output,
+                        std::string *warn, std::string *err) {
+  (void)scene;
+  (void)output;
+  (void)warn;
 
-  // class Impl;
-  // Impl *_impl;
-};
+  if (err) {
+    (*err) = "USDC writer feature is disabled in this build.\n";
+  }
 
-}  // namespace ascii
+  return false;
+}
 
+}  // namespace usdc
 }  // namespace tinyusdz
+
+#endif
```

### Comparing `tinyusdz-0.8.0rc0/src/crate-format.hh` & `tinyusdz-0.8.0rc1/src/crate-format.hh`

 * *Files 2% similar despite different names*

```diff
@@ -29,14 +29,15 @@
 namespace crate {
 
 constexpr size_t kMinCompressedArraySize = 16;
 constexpr size_t kSectionNameMaxLength = 15;
 
 constexpr char kTokenVector[] = "TokenVector";
 constexpr char kStringVector[] = "StringVector";
+constexpr char kPathVector[] = "PathVector";
 
 
 // -- from USD ----------------------------------------------------------------
 
 //
 // Copyright 2016 Pixar
 //
@@ -163,62 +164,76 @@
 
 //
 // Spec describes the relation of a path(i.e. node) and field(e.g. vertex data)
 //
 struct Spec {
   Index path_index;
   Index fieldset_index;
-  SpecType spec_type;
+  SpecType spec_type; // Must be 32bit
 };
 
+static_assert(sizeof(Spec) == (4 * 3), "sizeof(Spec) must be 12");
+
 struct Section {
   Section() { memset(this, 0, sizeof(*this)); }
   Section(char const *name, int64_t start, int64_t size);
   char name[kSectionNameMaxLength + 1];
   int64_t start, size;  // byte offset to section info and its data size
 };
 
 // For unordered_map
 
 // https://stackoverflow.com/questions/8513911/how-to-create-a-good-hash-combine-with-64-bit-output-inspired-by-boosthash-co
 // From CityHash code.
+
 template <class T>
-inline void hash_combine(std::size_t &seed, const T &v) {
-#ifdef __wasi__  // 32bit platform
+inline void hash_combine_impl32(std::size_t &seed, const T &v)
+{
   // Use boost version.
   std::hash<T> hasher;
   seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
+}
+
+template <class T>
+inline void hash_combine(std::size_t &seed, const T &v) {
+#if defined(__wasi__)  // 32bit platform
+  hash_combine_impl32(seed, v);
 #else
-  std::hash<T> hasher;
-  const uint64_t kMul = 0x9ddfea08eb382d69ULL;
-  std::size_t a = (hasher(v) ^ seed) * kMul;
-  a ^= (a >> 47);
-  std::size_t b = (seed ^ a) * kMul;
-  b ^= (b >> 47);
-  seed = b * kMul;
+  if (sizeof(std::size_t) == 4) {
+    hash_combine_impl32(seed, v);
+  } else {
+    // Assume 64bit
+    std::hash<T> hasher;
+    const uint64_t kMul = 0x9ddfea08eb382d69ULL;
+    uint64_t a = (hasher(v) ^ seed) * kMul;
+    a ^= (a >> 47);
+    uint64_t b = (seed ^ a) * kMul;
+    b ^= (b >> 47);
+    seed = size_t(b * kMul);
+  }
 #endif
 }
 
 struct PathHasher {
   size_t operator()(const Path &path) const {
-    size_t seed = std::hash<std::string>()(path.GetPrimPart());
-    hash_combine(seed, std::hash<std::string>()(path.GetPropPart()));
-    hash_combine(seed, std::hash<std::string>()(path.GetLocalPart()));
-    hash_combine(seed, std::hash<bool>()(path.IsValid()));
+    size_t seed = std::hash<std::string>()(path.prim_part());
+    hash_combine(seed, std::hash<std::string>()(path.prop_part()));
+    //hash_combine(seed, std::hash<std::string>()(path.GetLocalPart()));
+    hash_combine(seed, std::hash<bool>()(path.is_valid()));
 
     return seed;
   }
 };
 
 struct PathKeyEqual {
   bool operator()(const Path &lhs, const Path &rhs) const {
-    bool ret = lhs.GetPrimPart() == rhs.GetPrimPart();
-    ret &= lhs.GetPropPart() == rhs.GetPropPart();
-    ret &= lhs.GetLocalPart() == rhs.GetLocalPart();
-    ret &= lhs.IsValid() == rhs.IsValid();
+    bool ret = lhs.prim_part() == rhs.prim_part();
+    ret &= lhs.prop_part() == rhs.prop_part();
+    //ret &= lhs.GetLocalPart() == rhs.GetLocalPart();
+    ret &= lhs.is_valid() == rhs.is_valid();
 
     return ret;
   }
 };
 
 struct FieldHasher {
   size_t operator()(const Field &field) const {
@@ -325,52 +340,53 @@
   CRATE_DATA_TYPE_VARIANT_SELECTION_MAP = 45,
   CRATE_DATA_TYPE_TIME_SAMPLES = 46,
   CRATE_DATA_TYPE_PAYLOAD = 47,
   CRATE_DATA_TYPE_DOUBLE_VECTOR = 48,
   CRATE_DATA_TYPE_LAYER_OFFSET_VECTOR = 49,
   CRATE_DATA_TYPE_STRING_VECTOR = 50,
   CRATE_DATA_TYPE_VALUE_BLOCK = 51,
-  CRATE_DATA_TYPE_VALUE = 52,
-  CRATE_DATA_TYPE_UNREGISTERED_VALUE = 53,
+  CRATE_DATA_TYPE_VALUE = 52, // Contains ValueRep
+  CRATE_DATA_TYPE_UNREGISTERED_VALUE = 53, // String or Dict
   CRATE_DATA_TYPE_UNREGISTERED_VALUE_LIST_OP = 54,
   CRATE_DATA_TYPE_PAYLOAD_LIST_OP = 55,
   CRATE_DATA_TYPE_TIME_CODE = 56,
 
   NumDataTypes // terminator
 };
 
 class CrateDataType
 {
  public:
   CrateDataType() = default;
 
-  CrateDataType(const std::string &s, CrateDataTypeId did, bool a)
+  CrateDataType(const char *s, CrateDataTypeId did, bool a)
     : name(s), dtype_id(did), supports_array(a) {
   }
 
   CrateDataType(const CrateDataType &rhs) = default;
   CrateDataType &operator=(const CrateDataType&rhs) = default;
 
-  std::string name; // name of CrateDatatType
+  const char *name{nullptr}; // name of CrateDatatType. Constant symbol. TODO: Use string_view.
   CrateDataTypeId dtype_id{CrateDataTypeId::CRATE_DATA_TYPE_INVALID};
   bool supports_array{false};
 };
 
 std::string GetCrateDataTypeRepr(CrateDataType dty); // for debug cout
 
 nonstd::expected<CrateDataType, std::string> GetCrateDataType(int32_t type_id);
 std::string GetCrateDataTypeName(int32_t type_id);
 std::string GetCrateDataTypeName(CrateDataTypeId type_id);
 
+// TODO: Use PrimVar?
 class CrateValue {
  public:
-  typedef std::map<std::string, CrateValue> Dictionary;
+  //typedef std::map<std::string, CrateValue> Dictionary;
 
-  std::string GetTypeName() const;
-  uint32_t GetTypeId() const;
+  //std::string GetTypeName() const;
+  //uint32_t GetTypeId() const;
 
 #define SET_TYPE_SCALAR(__ty) void Set(const __ty& v) { value_ = v; }
 #define SET_TYPE_1D(__ty) void Set(const std::vector<__ty> &v) { value_ = v; }
 
 #define SET_TYPE_LIST(__FUNC) \
   __FUNC(int64_t) \
   __FUNC(uint64_t) \
@@ -396,76 +412,98 @@
   __FUNC(value::double4) \
   __FUNC(value::quath) \
   __FUNC(value::quatf) \
   __FUNC(value::quatd) \
   __FUNC(value::matrix2d) \
   __FUNC(value::matrix3d) \
   __FUNC(value::matrix4d) \
-  __FUNC(value::asset_path) \
+  __FUNC(value::AssetPath) \
   __FUNC(value::token) \
   __FUNC(std::string)
 
 
+  // Note: Use bool and std::vector<bool> as-is in C++ layer, but its serialized as 8bit in Crate binary.
   SET_TYPE_SCALAR(bool)
+  SET_TYPE_1D(bool)
+
   SET_TYPE_SCALAR(Specifier)
   SET_TYPE_SCALAR(Permission)
   SET_TYPE_SCALAR(Variability)
   SET_TYPE_SCALAR(value::dict)
 
+  SET_TYPE_SCALAR(value::ValueBlock)
+
   SET_TYPE_SCALAR(ListOp<value::token>)
   SET_TYPE_SCALAR(ListOp<std::string>)
   SET_TYPE_SCALAR(ListOp<Path>)
   SET_TYPE_SCALAR(ListOp<Reference>)
   SET_TYPE_SCALAR(ListOp<int32_t>)
   SET_TYPE_SCALAR(ListOp<uint32_t>)
   SET_TYPE_SCALAR(ListOp<int64_t>)
   SET_TYPE_SCALAR(ListOp<uint64_t>)
   SET_TYPE_SCALAR(ListOp<Payload>)
 
   SET_TYPE_SCALAR(std::vector<Path>)
   // vector<double> is defined in SET_TYPE_LIST(SET_TYPE_1D)
   //SET_TYPE_SCALAR(std::vector<double>)
   SET_TYPE_SCALAR(std::vector<LayerOffset>)
+  SET_TYPE_SCALAR(Payload)
+  SET_TYPE_SCALAR(VariantSelectionMap)
 
   SET_TYPE_SCALAR(value::TimeSamples)
-  SET_TYPE_SCALAR(Dictionary)
+  SET_TYPE_SCALAR(CustomDataType) // for (type-restricted) dist
 
   SET_TYPE_LIST(SET_TYPE_SCALAR)
 
 
   SET_TYPE_LIST(SET_TYPE_1D)
 
+#if 0 // TODO: Unsafe so Remove
   // Useful function to retrieve concrete value with type T.
   // Undefined behavior(usually will triger segmentation fault) when
   // type-mismatch. (We don't throw exception)
   template <class T>
   const T value() const {
     //return (*reinterpret_cast<const T *>(value_.value()));
-    return linb::any_cast<const T>(value_);
+    //return linb::any_cast<const T>(value_);
+    return value_.value<T>();
   }
+#endif
 
   // Type-safe way to get concrete value.
   template <class T>
   nonstd::optional<T> get_value() const {
-    if (value::TypeTrait<T>::type_id == value_.type_id()) {
-      return std::move(value<T>());
-    } else if (value::TypeTrait<T>::underlying_type_id == value_.underlying_type_id()) {
-      // `roll` type. Can be able to cast to underlying type since the memory
-      // layout does not change.
-      return std::move(value<T>());
-    }
-    return nonstd::nullopt;
+    return value_.get_value<T>();
+  }
+
+  // Return null when type-mismatch
+  template <class T>
+  const T *as() const {
+    return value_.as<T>();
+  }
+
+  std::string type_name() const {
+    return value_.type_name();
+  }
+
+  uint32_t type_id() const {
+    return value_.type_id();
+  }
+
+  const value::Value &get_raw() const {
+    return value_;
   }
 
  private:
-  // TODO: Use value::Value?
-  linb::any value_;
+  value::Value value_;
 };
 
-
+// In-memory storage for a single "spec" -- prim, property, etc.
+using FieldValuePair = std::pair<std::string, crate::CrateValue>;
+using FieldValuePairVector = std::vector<FieldValuePair>;
 
 struct StdHashWrapper {
     template <class T>
     inline size_t operator()(const T &val) const {
         return std::hash<T>()(val);
     }
 };
@@ -474,15 +512,15 @@
 } // namespace crate
 
 namespace value {
 
 #include "define-type-trait.inc"
 
 // synonym to `value::dict`
-DEFINE_TYPE_TRAIT(crate::CrateValue::Dictionary, "dict", TYPE_ID_DICT, 1);
+//DEFINE_TYPE_TRAIT(crate::CrateValue::Dictionary, "dict", TYPE_ID_DICT, 1);
 
 #undef DEFINE_TYPE_TRAIT
 #undef DEFINE_ROLE_TYPE_TRAIT
 
 } // namespace value
 
 } // namespace tinyusdz
```

### Comparing `tinyusdz-0.8.0rc0/src/crate-reader.cc` & `tinyusdz-0.8.0rc1/src/crate-reader.cc`

 * *Files 21% similar despite different names*

```diff
@@ -27,14 +27,16 @@
 #include "path-util.hh"
 #include "pprinter.hh"
 #include "prim-types.hh"
 #include "stream-reader.hh"
 #include "tinyusdz.hh"
 #include "value-pprint.hh"
 #include "value-types.hh"
+#include "tiny-format.hh"
+#include "str-util.hh"
 
 //
 #ifdef __clang__
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Weverything"
 #endif
 
@@ -42,134 +44,81 @@
 
 #ifdef __clang__
 #pragma clang diagnostic pop
 #endif
 
 //
 
-#ifdef TINYUSDZ_PRODUCTION_BUILD
-// Do not include full filepath for privacy.
-#define PUSH_ERROR(s)                                                \
-  {                                                                  \
-    std::ostringstream ss;                                           \
-    ss << "[crate-reader] " << __func__ << "():" << __LINE__ << " "; \
-    ss << s;                                                         \
-    _err += ss.str() + "\n";                                         \
-  }                                                                  \
-  while (0)
-
-#define PUSH_WARN(s)                                                 \
-  {                                                                  \
-    std::ostringstream ss;                                           \
-    ss << "[crate-reader] " << __func__ << "():" << __LINE__ << " "; \
-    ss << s;                                                         \
-    _warn += ss.str() + "\n";                                        \
-  }                                                                  \
-  while (0)
-#else
-#define PUSH_ERROR(s)                                              \
-  {                                                                \
-    std::ostringstream ss;                                         \
-    ss << __FILE__ << ":" << __func__ << "():" << __LINE__ << " "; \
-    ss << s;                                                       \
-    _err += ss.str() + "\n";                                       \
-  }                                                                \
-  while (0)
-
-#define PUSH_WARN(s)                                               \
-  {                                                                \
-    std::ostringstream ss;                                         \
-    ss << __FILE__ << ":" << __func__ << "():" << __LINE__ << " "; \
-    ss << s;                                                       \
-    _warn += ss.str() + "\n";                                      \
-  }                                                                \
-  while (0)
-#endif
-
 #include "common-macros.inc"
 
 namespace tinyusdz {
 namespace crate {
 
-constexpr auto kTypeName = "typeName";
-constexpr auto kToken = "Token";
-constexpr auto kDefault = "default";
-
-namespace {
-
-template <class Int>
-static inline bool ReadCompressedInts(const StreamReader *sr, Int *out,
-                                      size_t size) {
-  // TODO(syoyo): Error check
-  using Compressor =
-      typename std::conditional<sizeof(Int) == 4, Usd_IntegerCompression,
-                                Usd_IntegerCompression64>::type;
-  std::vector<char> compBuffer(Compressor::GetCompressedBufferSize(size));
-  uint64_t compSize;
-  if (!sr->read8(&compSize)) {
-    return false;
-  }
-
-  if (!sr->read(size_t(compSize), size_t(compSize),
-                reinterpret_cast<uint8_t *>(compBuffer.data()))) {
-    return false;
-  }
-  std::string err;
-  bool ret = Compressor::DecompressFromBuffer(
-      compBuffer.data(), size_t(compSize), out, size, &err);
-  (void)err;
+//constexpr auto kTypeName = "typeName";
+//constexpr auto kToken = "Token";
+//constexpr auto kDefault = "default";
+
+#define kTag "[Crate]"
+
+#define CHECK_MEMORY_USAGE(__nbytes) do { \
+  _memoryUsage += (__nbytes); \
+  if (_memoryUsage > _config.maxMemoryBudget) { \
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Reached to max memory budget."); \
+  }  \
+  } while(0)
+
+#define REDUCE_MEMORY_USAGE(__nbytes) do { \
+  if (_memoryUsage < (__nbytes)) { \
+    _memoryUsage -= (__nbytes); \
+  } \
+  } while(0)
 
-  return ret;
-}
 
-static inline bool ReadIndices(const StreamReader *sr,
-                               std::vector<crate::Index> *indices) {
-  // TODO(syoyo): Error check
-  uint64_t n;
-  if (!sr->read8(&n)) {
-    return false;
-  }
-
-  DCOUT("ReadIndices: n = " << n);
-
-  indices->resize(size_t(n));
-  size_t datalen = size_t(n) * sizeof(crate::Index);
-
-  if (datalen != sr->read(datalen, datalen,
-                          reinterpret_cast<uint8_t *>(indices->data()))) {
-    return false;
-  }
-
-  return true;
-}
-
-} // namespace 
+#if 0
+//
+// Impl(TODO)
+//
+class CrateReader::Impl
+{
+ public:
+  Impl();
+};
+#endif
 
 //
 // --
 //
-CrateReader::CrateReader(StreamReader *sr, int num_threads) : _sr(sr) {
-  if (num_threads == -1) {
+CrateReader::CrateReader(StreamReader *sr, const CrateReaderConfig &config) : _sr(sr), _impl(nullptr) {
+  _config = config;
+  if (_config.numThreads == -1) {
 #if defined(__wasi__)
 #else
-    num_threads = (std::max)(1, int(std::thread::hardware_concurrency()));
-    PUSH_WARN("# of thread to use: " << std::to_string(num_threads));
+    _config.numThreads = (std::max)(1, int(std::thread::hardware_concurrency()));
+    PUSH_WARN("# of thread to use: " << std::to_string(_config.numThreads));
 #endif
   }
 
+
 #if defined(__wasi__)
   PUSH_WARN("Threading is disabled for WASI build.");
-  num_threads = 1;
-#endif
+  _config.numThreads = 1;
+#else
 
   // Limit to 1024 threads.
-  _num_threads = (std::min)(1024, num_threads);
+  _config.numThreads = (std::min)(1024, _config.numThreads);
+#endif
+
+  //_impl = new Impl();
+
 }
 
-CrateReader::~CrateReader() {}
+CrateReader::~CrateReader() {
+  //delete _impl;
+  //_impl = nullptr;
+}
 
 std::string CrateReader::GetError() { return _err; }
 
 std::string CrateReader::GetWarning() { return _warn; }
 
 bool CrateReader::HasField(const std::string &key) const {
   // Simple linear search
@@ -180,56 +129,69 @@
       }
     }
   }
   return false;
 }
 
 nonstd::optional<crate::Field> CrateReader::GetField(crate::Index index) const {
-  if (index.value <= _fields.size()) {
+
+  if (index.value < _fields.size()) {
     return _fields[index.value];
   } else {
     return nonstd::nullopt;
   }
 }
 
 const nonstd::optional<value::token> CrateReader::GetToken(
     crate::Index token_index) const {
-  if (token_index.value <= _tokens.size()) {
+  if (token_index.value < _tokens.size()) {
     return _tokens[token_index.value];
   } else {
     return nonstd::nullopt;
   }
 }
 
 // Get string token from string index.
 const nonstd::optional<value::token> CrateReader::GetStringToken(
     crate::Index string_index) const {
-  if (string_index.value <= _string_indices.size()) {
+
+  if (string_index.value < _string_indices.size()) {
     crate::Index s_idx = _string_indices[string_index.value];
     return GetToken(s_idx);
   } else {
     PUSH_ERROR("String index out of range: " +
                std::to_string(string_index.value));
     return value::token();
   }
 }
 
 nonstd::optional<Path> CrateReader::GetPath(crate::Index index) const {
-  if (index.value <= _paths.size()) {
+
+  if (index.value < _paths.size()) {
     // ok
   } else {
     return nonstd::nullopt;
   }
 
   return _paths[index.value];
 }
 
+nonstd::optional<Path> CrateReader::GetElementPath(crate::Index index) const {
+  if (index.value < _elemPaths.size()) {
+    // ok
+  } else {
+    return nonstd::nullopt;
+  }
+
+  return _elemPaths[index.value];
+}
+
 nonstd::optional<std::string> CrateReader::GetPathString(
     crate::Index index) const {
-  if (index.value <= _paths.size()) {
+  if (index.value < _paths.size()) {
     // ok
   } else {
     return nonstd::nullopt;
   }
 
   const Path &p = _paths[index.value];
 
@@ -239,38 +201,77 @@
 bool CrateReader::ReadIndex(crate::Index *i) {
   // string is serialized as StringIndex
   uint32_t value;
   if (!_sr->read4(&value)) {
     PUSH_ERROR("Failed to read Index");
     return false;
   }
+
+  CHECK_MEMORY_USAGE(sizeof(uint32_t));
+
   (*i) = crate::Index(value);
   return true;
 }
 
+bool CrateReader::ReadIndices(std::vector<crate::Index> *indices) {
+  uint64_t n;
+  if (!_sr->read8(&n)) {
+    return false;
+  }
+
+  if (n > _config.maxNumIndices) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Too many indices.");
+  }
+
+  if (n == 0) {
+    return true;
+  }
+
+  DCOUT("ReadIndices: n = " << n);
+
+  size_t datalen = size_t(n) * sizeof(crate::Index);
+
+  if (datalen > _sr->size()) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Indices data exceeds USDC size.");
+  }
+
+  CHECK_MEMORY_USAGE(datalen);
+
+  indices->resize(size_t(n));
+
+  if (datalen != _sr->read(datalen, datalen,
+                          reinterpret_cast<uint8_t *>(indices->data()))) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read Indices array.");
+  }
+
+  return true;
+}
+
 bool CrateReader::ReadString(std::string *s) {
   // string is serialized as StringIndex
   crate::Index string_index;
   if (!ReadIndex(&string_index)) {
     PUSH_ERROR("Failed to read Index for string data.");
     return false;
   }
 
   if (auto tok = GetStringToken(string_index)) {
     (*s) = tok.value().str();
+    CHECK_MEMORY_USAGE(s->size());
     return true;
   }
 
+
   PUSH_ERROR("Invalid StringIndex.");
   return false;
 }
 
 nonstd::optional<std::string> CrateReader::GetSpecString(
     crate::Index index) const {
-  if (index.value <= _specs.size()) {
+  if (index.value < _specs.size()) {
     // ok
   } else {
     return nonstd::nullopt;
   }
 
   const crate::Spec &spec = _specs[index.value];
 
@@ -288,129 +289,135 @@
 
 bool CrateReader::ReadValueRep(crate::ValueRep *rep) {
   if (!_sr->read8(reinterpret_cast<uint64_t *>(rep))) {
     PUSH_ERROR("Failed to read ValueRep.");
     return false;
   }
 
-  DCOUT("value = " << rep->GetData());
+  CHECK_MEMORY_USAGE(sizeof(uint64_t));
+
+  DCOUT("ValueRep value = " << rep->GetData());
 
   return true;
 }
 
+template <class Int>
+bool CrateReader::ReadCompressedInts(Int *out,
+                                     size_t num_ints) {
+  if (num_ints > _config.maxInts) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "# of ints too large.");
+  }
+
+  using Compressor =
+      typename std::conditional<sizeof(Int) == 4, Usd_IntegerCompression,
+                                Usd_IntegerCompression64>::type;
+
+
+  // TODO: Read compressed data from _sr directly
+  size_t compBufferSize = Compressor::GetCompressedBufferSize(num_ints);
+  CHECK_MEMORY_USAGE(compBufferSize);
+
+  uint64_t compSize;
+  if (!_sr->read8(&compSize)) {
+    return false;
+  }
+
+  if (compSize > compBufferSize) {
+    // Truncate
+    // TODO: return error?
+    compSize = compBufferSize;
+  }
+
+  if (compSize > _sr->size()) {
+    return false;
+  }
+
+  if (compSize < 4) {
+    // Too small
+    return false;
+  }
+
+  std::vector<char> compBuffer;
+  compBuffer.resize(compBufferSize);
+  if (!_sr->read(size_t(compSize), size_t(compSize),
+                reinterpret_cast<uint8_t *>(compBuffer.data()))) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read compressedInts.");
+  }
+
+  bool ret = Compressor::DecompressFromBuffer(
+      compBuffer.data(), size_t(compSize), out, num_ints, &_err);
+
+  REDUCE_MEMORY_USAGE(compBufferSize);
+
+  return ret;
+}
+
 template <typename T>
 bool CrateReader::ReadIntArray(bool is_compressed, std::vector<T> *d) {
-  if (!is_compressed) {
-    size_t length;
-    // < ver 0.7.0  use 32bit
-    if ((_version[0] == 0) && ((_version[1] < 7))) {
-      uint32_t n;
-      if (!_sr->read4(&n)) {
-        // PUSH_ERROR("Failed to read the number of array elements.");
-        return false;
-      }
-      length = size_t(n);
-    } else {
-      uint64_t n;
-      if (!_sr->read8(&n)) {
-        //_err += "Failed to read the number of array elements.\n";
-        return false;
-      }
 
-      length = size_t(n);
+  size_t length{0}; // uncompressed array elements.
+  // < ver 0.7.0  use 32bit
+  if ((_version[0] == 0) && ((_version[1] < 7))) {
+    uint32_t n;
+    if (!_sr->read4(&n)) {
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read the number of array elements.");
+    }
+    length = size_t(n);
+  } else {
+    uint64_t n;
+    if (!_sr->read8(&n)) {
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read the number of array elements.");
+      return false;
     }
 
-    d->resize(length);
+    DCOUT("array.len = " << n);
+    length = size_t(n);
+  }
+
+  DCOUT("array.len = " << length);
+  if (length == 0) {
+    d->clear();
+    return true;
+  }
+
+  if (length > _config.maxArrayElements) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Too large array elements.");
+  }
+
+  CHECK_MEMORY_USAGE(sizeof(T) * length);
+
+  d->resize(length);
+
+  if (!is_compressed) {
 
     // TODO(syoyo): Zero-copy
     if (!_sr->read(sizeof(T) * length, sizeof(T) * length,
                    reinterpret_cast<uint8_t *>(d->data()))) {
-      //_err += "Failed to read integer array data.\n";
-      return false;
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read integer array data.");
     }
 
     return true;
 
   } else {
-    size_t length;
-    // < ver 0.7.0  use 32bit
-    if ((_version[0] == 0) && ((_version[1] < 7))) {
-      uint32_t n;
-      if (!_sr->read4(&n)) {
-        //_err += "Failed to read the number of array elements.\n";
-        return false;
-      }
-      length = size_t(n);
-    } else {
-      uint64_t n;
-      if (!_sr->read8(&n)) {
-        //_err += "Failed to read the number of array elements.\n";
-        return false;
-      }
-
-      length = size_t(n);
-    }
-
-    DCOUT("array.len = " << length);
-
-    d->resize(length);
 
     if (length < crate::kMinCompressedArraySize) {
       size_t sz = sizeof(T) * length;
-      // Not stored in compressed.
-      // reader.ReadContiguous(odata, osize);
+      // Not stored in compressed for smaller data
       if (!_sr->read(sz, sz, reinterpret_cast<uint8_t *>(d->data()))) {
-        PUSH_ERROR("Failed to read uncompressed array data.");
-        return false;
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read uncompressed integer array data.");
       }
       return true;
     }
 
-    return ReadCompressedInts(_sr, d->data(), d->size());
+    return ReadCompressedInts(d->data(), d->size());
   }
 }
 
 bool CrateReader::ReadHalfArray(bool is_compressed,
                                 std::vector<value::half> *d) {
-  if (!is_compressed) {
-    size_t length;
-    // < ver 0.7.0  use 32bit
-    if ((_version[0] == 0) && ((_version[1] < 7))) {
-      uint32_t n;
-      if (!_sr->read4(&n)) {
-        _err += "Failed to read the number of array elements.\n";
-        return false;
-      }
-      length = size_t(n);
-    } else {
-      uint64_t n;
-      if (!_sr->read8(&n)) {
-        _err += "Failed to read the number of array elements.\n";
-        return false;
-      }
-
-      length = size_t(n);
-    }
-
-    d->resize(length);
-
-    // TODO(syoyo): Zero-copy
-    if (!_sr->read(sizeof(uint16_t) * length, sizeof(uint16_t) * length,
-                   reinterpret_cast<uint8_t *>(d->data()))) {
-      _err += "Failed to read half array data.\n";
-      return false;
-    }
-
-    return true;
-  }
-
-  //
-  // compressed data is represented by integers or look-up table.
-  //
-
   size_t length;
   // < ver 0.7.0  use 32bit
   if ((_version[0] == 0) && ((_version[1] < 7))) {
     uint32_t n;
     if (!_sr->read4(&n)) {
       _err += "Failed to read the number of array elements.\n";
       return false;
@@ -422,117 +429,108 @@
       _err += "Failed to read the number of array elements.\n";
       return false;
     }
 
     length = size_t(n);
   }
 
-  DCOUT("array.len = " << length);
+  if (length > _config.maxArrayElements) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Too many array elements.");
+  }
+
+  CHECK_MEMORY_USAGE(length * sizeof(uint16_t));
 
   d->resize(length);
 
-  if (length < crate::kMinCompressedArraySize) {
-    size_t sz = sizeof(uint16_t) * length;
-    // Not stored in compressed.
-    // reader.ReadContiguous(odata, osize);
-    if (!_sr->read(sz, sz, reinterpret_cast<uint8_t *>(d->data()))) {
-      _err += "Failed to read uncompressed array data.\n";
-      return false;
-    }
-    return true;
-  }
+  if (!is_compressed) {
 
-  // Read the code
-  char code;
-  if (!_sr->read1(&code)) {
-    _err += "Failed to read the code.\n";
-    return false;
-  }
 
-  if (code == 'i') {
-    // Compressed integers.
-    std::vector<int32_t> ints(length);
-    if (!ReadCompressedInts(_sr, ints.data(), ints.size())) {
-      _err += "Failed to read compressed ints in ReadHalfArray.\n";
-      return false;
-    }
-    for (size_t i = 0; i < length; i++) {
-      float f = float(ints[i]);
-      value::half h = float_to_half_full(f);
-      (*d)[i] = h;
-    }
-  } else if (code == 't') {
-    // Lookup table & indexes.
-    uint32_t lutSize;
-    if (!_sr->read4(&lutSize)) {
-      _err += "Failed to read lutSize in ReadHalfArray.\n";
+    // TODO(syoyo): Zero-copy
+    if (!_sr->read(sizeof(uint16_t) * length, sizeof(uint16_t) * length,
+                   reinterpret_cast<uint8_t *>(d->data()))) {
+      _err += "Failed to read half array data.\n";
       return false;
     }
 
-    std::vector<value::half> lut(lutSize);
-    if (!_sr->read(sizeof(value::half) * lutSize, sizeof(value::half) * lutSize,
-                   reinterpret_cast<uint8_t *>(lut.data()))) {
-      _err += "Failed to read lut table in ReadHalfArray.\n";
-      return false;
-    }
+    return true;
+  } else {
 
-    std::vector<uint32_t> indexes(length);
-    if (!ReadCompressedInts(_sr, indexes.data(), indexes.size())) {
-      _err += "Failed to read lut indices in ReadHalfArray.\n";
-      return false;
-    }
+    //
+    // compressed data is represented by integers or look-up table.
+    //
 
-    auto o = d->data();
-    for (auto index : indexes) {
-      *o++ = lut[index];
+    if (length < crate::kMinCompressedArraySize) {
+      size_t sz = sizeof(uint16_t) * length;
+      // Not stored in compressed.
+      // reader.ReadContiguous(odata, osize);
+      if (!_sr->read(sz, sz, reinterpret_cast<uint8_t *>(d->data()))) {
+        _err += "Failed to read uncompressed array data.\n";
+        return false;
+      }
+      return true;
     }
-  } else {
-    _err += "Invalid code. Data is currupted\n";
-    return false;
-  }
 
-  return true;
-}
+    // Read the code
+    char code;
+    if (!_sr->read1(&code)) {
+      _err += "Failed to read the code.\n";
+      return false;
+    }
 
-bool CrateReader::ReadFloatArray(bool is_compressed, std::vector<float> *d) {
-  if (!is_compressed) {
-    size_t length;
-    // < ver 0.7.0  use 32bit
-    if ((_version[0] == 0) && ((_version[1] < 7))) {
-      uint32_t n;
-      if (!_sr->read4(&n)) {
-        _err += "Failed to read the number of array elements.\n";
+    if (code == 'i') {
+      // Compressed integers.
+      std::vector<int32_t> ints;
+      ints.resize(length);
+      if (!ReadCompressedInts(ints.data(), ints.size())) {
+        _err += "Failed to read compressed ints in ReadHalfArray.\n";
         return false;
       }
-      length = size_t(n);
-    } else {
-      uint64_t n;
-      if (!_sr->read8(&n)) {
-        _err += "Failed to read the number of array elements.\n";
+      for (size_t i = 0; i < length; i++) {
+        float f = float(ints[i]);
+        value::half h = value::float_to_half_full(f);
+        (*d)[i] = h;
+      }
+    } else if (code == 't') {
+      // Lookup table & indexes.
+      uint32_t lutSize;
+      if (!_sr->read4(&lutSize)) {
+        _err += "Failed to read lutSize in ReadHalfArray.\n";
         return false;
       }
 
-      length = size_t(n);
-    }
+      std::vector<value::half> lut;
+      lut.resize(lutSize);
+      if (!_sr->read(sizeof(value::half) * lutSize, sizeof(value::half) * lutSize,
+                     reinterpret_cast<uint8_t *>(lut.data()))) {
+        _err += "Failed to read lut table in ReadHalfArray.\n";
+        return false;
+      }
 
-    d->resize(length);
+      std::vector<uint32_t> indexes;
+      indexes.resize(length);
+      if (!ReadCompressedInts(indexes.data(), indexes.size())) {
+        _err += "Failed to read lut indices in ReadHalfArray.\n";
+        return false;
+      }
 
-    // TODO(syoyo): Zero-copy
-    if (!_sr->read(sizeof(float) * length, sizeof(float) * length,
-                   reinterpret_cast<uint8_t *>(d->data()))) {
-      _err += "Failed to read float array data.\n";
+      auto o = d->data();
+      for (auto index : indexes) {
+        *o++ = lut[index];
+      }
+    } else {
+      _err += "Invalid code. Data is currupted\n";
       return false;
     }
 
     return true;
   }
 
-  //
-  // compressed data is represented by integers or look-up table.
-  //
+}
+
+bool CrateReader::ReadFloatArray(bool is_compressed, std::vector<float> *d) {
 
   size_t length;
   // < ver 0.7.0  use 32bit
   if ((_version[0] == 0) && ((_version[1] < 7))) {
     uint32_t n;
     if (!_sr->read4(&n)) {
       _err += "Failed to read the number of array elements.\n";
@@ -545,113 +543,103 @@
       _err += "Failed to read the number of array elements.\n";
       return false;
     }
 
     length = size_t(n);
   }
 
-  DCOUT("array.len = " << length);
+  if (length > _config.maxArrayElements) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Too many array elements.");
+  }
+
+  CHECK_MEMORY_USAGE(length * sizeof(float));
 
   d->resize(length);
 
-  if (length < crate::kMinCompressedArraySize) {
-    size_t sz = sizeof(float) * length;
-    // Not stored in compressed.
-    // reader.ReadContiguous(odata, osize);
-    if (!_sr->read(sz, sz, reinterpret_cast<uint8_t *>(d->data()))) {
-      _err += "Failed to read uncompressed array data.\n";
+  if (!is_compressed) {
+
+    // TODO(syoyo): Zero-copy
+    if (!_sr->read(sizeof(float) * length, sizeof(float) * length,
+                   reinterpret_cast<uint8_t *>(d->data()))) {
+      _err += "Failed to read float array data.\n";
       return false;
     }
+
     return true;
-  }
+  } else {
 
-  // Read the code
-  char code;
-  if (!_sr->read1(&code)) {
-    _err += "Failed to read the code.\n";
-    return false;
-  }
+    //
+    // compressed data is represented by integers or look-up table.
+    //
 
-  if (code == 'i') {
-    // Compressed integers.
-    std::vector<int32_t> ints(length);
-    if (!ReadCompressedInts(_sr, ints.data(), ints.size())) {
-      _err += "Failed to read compressed ints in ReadFloatArray.\n";
-      return false;
-    }
-    std::copy(ints.begin(), ints.end(), d->data());
-  } else if (code == 't') {
-    // Lookup table & indexes.
-    uint32_t lutSize;
-    if (!_sr->read4(&lutSize)) {
-      _err += "Failed to read lutSize in ReadFloatArray.\n";
-      return false;
-    }
-
-    std::vector<float> lut(lutSize);
-    if (!_sr->read(sizeof(float) * lutSize, sizeof(float) * lutSize,
-                   reinterpret_cast<uint8_t *>(lut.data()))) {
-      _err += "Failed to read lut table in ReadFloatArray.\n";
-      return false;
+    if (length < crate::kMinCompressedArraySize) {
+      size_t sz = sizeof(float) * length;
+      // Not stored in compressed.
+      // reader.ReadContiguous(odata, osize);
+      if (!_sr->read(sz, sz, reinterpret_cast<uint8_t *>(d->data()))) {
+        _err += "Failed to read uncompressed array data.\n";
+        return false;
+      }
+      return true;
     }
 
-    std::vector<uint32_t> indexes(length);
-    if (!ReadCompressedInts(_sr, indexes.data(), indexes.size())) {
-      _err += "Failed to read lut indices in ReadFloatArray.\n";
+    // Read the code
+    char code;
+    if (!_sr->read1(&code)) {
+      _err += "Failed to read the code.\n";
       return false;
     }
 
-    auto o = d->data();
-    for (auto index : indexes) {
-      *o++ = lut[index];
-    }
-  } else {
-    _err += "Invalid code. Data is currupted\n";
-    return false;
-  }
-
-  return true;
-}
-
-bool CrateReader::ReadDoubleArray(bool is_compressed, std::vector<double> *d) {
-  if (!is_compressed) {
-    size_t length;
-    // < ver 0.7.0  use 32bit
-    if ((_version[0] == 0) && ((_version[1] < 7))) {
-      uint32_t n;
-      if (!_sr->read4(&n)) {
-        _err += "Failed to read the number of array elements.\n";
+    if (code == 'i') {
+      // Compressed integers.
+      std::vector<int32_t> ints;
+      ints.resize(length);
+      if (!ReadCompressedInts(ints.data(), ints.size())) {
+        _err += "Failed to read compressed ints in ReadFloatArray.\n";
         return false;
       }
-      length = size_t(n);
-    } else {
-      uint64_t n;
-      if (!_sr->read8(&n)) {
-        _err += "Failed to read the number of array elements.\n";
+      std::copy(ints.begin(), ints.end(), d->data());
+    } else if (code == 't') {
+      // Lookup table & indexes.
+      uint32_t lutSize;
+      if (!_sr->read4(&lutSize)) {
+        _err += "Failed to read lutSize in ReadFloatArray.\n";
         return false;
       }
 
-      length = size_t(n);
-    }
+      std::vector<float> lut;
+      lut.resize(lutSize);
+      if (!_sr->read(sizeof(float) * lutSize, sizeof(float) * lutSize,
+                     reinterpret_cast<uint8_t *>(lut.data()))) {
+        _err += "Failed to read lut table in ReadFloatArray.\n";
+        return false;
+      }
 
-    d->resize(length);
+      std::vector<uint32_t> indexes;
+      indexes.resize(length);
+      if (!ReadCompressedInts(indexes.data(), indexes.size())) {
+        _err += "Failed to read lut indices in ReadFloatArray.\n";
+        return false;
+      }
 
-    // TODO(syoyo): Zero-copy
-    if (!_sr->read(sizeof(double) * length, sizeof(double) * length,
-                   reinterpret_cast<uint8_t *>(d->data()))) {
-      _err += "Failed to read double array data.\n";
+      auto o = d->data();
+      for (auto index : indexes) {
+        *o++ = lut[index];
+      }
+    } else {
+      _err += "Invalid code. Data is currupted\n";
       return false;
     }
 
     return true;
   }
 
-  //
-  // compressed data is represented by integers or look-up table.
-  //
+}
+
+bool CrateReader::ReadDoubleArray(bool is_compressed, std::vector<double> *d) {
 
   size_t length;
   // < ver 0.7.0  use 32bit
   if ((_version[0] == 0) && ((_version[1] < 7))) {
     uint32_t n;
     if (!_sr->read4(&n)) {
       _err += "Failed to read the number of array elements.\n";
@@ -664,194 +652,272 @@
       _err += "Failed to read the number of array elements.\n";
       return false;
     }
 
     length = size_t(n);
   }
 
-  DCOUT("array.len = " << length);
+  if (length > _config.maxArrayElements) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Too many array elements.");
+  }
+
+  CHECK_MEMORY_USAGE(length * sizeof(double));
 
   d->resize(length);
 
-  if (length < crate::kMinCompressedArraySize) {
-    size_t sz = sizeof(double) * length;
-    // Not stored in compressed.
-    // reader.ReadContiguous(odata, osize);
-    if (!_sr->read(sz, sz, reinterpret_cast<uint8_t *>(d->data()))) {
-      _err += "Failed to read uncompressed array data.\n";
+  if (!is_compressed) {
+
+    // TODO(syoyo): Zero-copy
+    if (!_sr->read(sizeof(double) * length, sizeof(double) * length,
+                   reinterpret_cast<uint8_t *>(d->data()))) {
+      _err += "Failed to read double array data.\n";
       return false;
     }
+
     return true;
-  }
+  } else {
 
-  // Read the code
-  char code;
-  if (!_sr->read1(&code)) {
-    _err += "Failed to read the code.\n";
-    return false;
-  }
+    //
+    // compressed data is represented by integers or look-up table.
+    //
 
-  if (code == 'i') {
-    // Compressed integers.
-    std::vector<int32_t> ints(length);
-    if (!ReadCompressedInts(_sr, ints.data(), ints.size())) {
-      _err += "Failed to read compressed ints in ReadDoubleArray.\n";
-      return false;
-    }
-    std::copy(ints.begin(), ints.end(), d->data());
-  } else if (code == 't') {
-    // Lookup table & indexes.
-    uint32_t lutSize;
-    if (!_sr->read4(&lutSize)) {
-      _err += "Failed to read lutSize in ReadDoubleArray.\n";
-      return false;
+    d->resize(length);
+
+    if (length < crate::kMinCompressedArraySize) {
+      size_t sz = sizeof(double) * length;
+      // Not stored in compressed.
+      // reader.ReadContiguous(odata, osize);
+      if (!_sr->read(sz, sz, reinterpret_cast<uint8_t *>(d->data()))) {
+        _err += "Failed to read uncompressed array data.\n";
+        return false;
+      }
+      return true;
     }
 
-    std::vector<double> lut(lutSize);
-    if (!_sr->read(sizeof(double) * lutSize, sizeof(double) * lutSize,
-                   reinterpret_cast<uint8_t *>(lut.data()))) {
-      _err += "Failed to read lut table in ReadDoubleArray.\n";
+    // Read the code
+    char code;
+    if (!_sr->read1(&code)) {
+      _err += "Failed to read the code.\n";
       return false;
     }
 
-    std::vector<uint32_t> indexes(length);
-    if (!ReadCompressedInts(_sr, indexes.data(), indexes.size())) {
-      _err += "Failed to read lut indices in ReadDoubleArray.\n";
+    if (code == 'i') {
+      // Compressed integers.
+      std::vector<int32_t> ints;
+      ints.resize(length);
+      if (!ReadCompressedInts(ints.data(), ints.size())) {
+        _err += "Failed to read compressed ints in ReadDoubleArray.\n";
+        return false;
+      }
+      std::copy(ints.begin(), ints.end(), d->data());
+    } else if (code == 't') {
+      // Lookup table & indexes.
+      uint32_t lutSize;
+      if (!_sr->read4(&lutSize)) {
+        _err += "Failed to read lutSize in ReadDoubleArray.\n";
+        return false;
+      }
+
+      std::vector<double> lut;
+      lut.resize(lutSize);
+      if (!_sr->read(sizeof(double) * lutSize, sizeof(double) * lutSize,
+                     reinterpret_cast<uint8_t *>(lut.data()))) {
+        _err += "Failed to read lut table in ReadDoubleArray.\n";
+        return false;
+      }
+
+      std::vector<uint32_t> indexes;
+      indexes.resize(length);
+      if (!ReadCompressedInts(indexes.data(), indexes.size())) {
+        _err += "Failed to read lut indices in ReadDoubleArray.\n";
+        return false;
+      }
+
+      auto o = d->data();
+      for (auto index : indexes) {
+        *o++ = lut[index];
+      }
+    } else {
+      _err += "Invalid code. Data is currupted\n";
       return false;
     }
 
-    auto o = d->data();
-    for (auto index : indexes) {
-      *o++ = lut[index];
-    }
-  } else {
-    _err += "Invalid code. Data is currupted\n";
-    return false;
+    return true;
   }
-
-  return true;
 }
 
 bool CrateReader::ReadTimeSamples(value::TimeSamples *d) {
-  (void)d;
 
-  // TODO(syoyo): Deferred loading of TimeSamples?(See USD's implementation)
+  // Layout
+  //
+  // - `times`(double[])
+  // - NumValueReps(int64)
+  // - ArrayOfValueRep
+  //
+
+  // TODO(syoyo): Deferred loading of TimeSamples?(See USD's implementation for details)
 
   DCOUT("ReadTimeSamples: offt before tell = " << _sr->tell());
 
   // 8byte for the offset for recursive value. See RecursiveRead() in
-  // crateFile.cpp for details.
+  // https://github.com/PixarAnimationStudios/USD/blob/release/pxr/usd/usd/crateFile.cpp for details.
   int64_t offset{0};
   if (!_sr->read8(&offset)) {
-    _err += "Failed to read the offset for value in Dictionary.\n";
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read the offset for value in Dictionary.");
     return false;
   }
 
   DCOUT("TimeSample times value offset = " << offset);
   DCOUT("TimeSample tell = " << _sr->tell());
 
   // -8 to compensate sizeof(offset)
   if (!_sr->seek_from_current(offset - 8)) {
-    _err += "Failed to seek to TimeSample times. Invalid offset value: " +
-            std::to_string(offset) + "\n";
-    return false;
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to seek to TimeSample times. Invalid offset value: " +
+            std::to_string(offset));
   }
 
   // TODO(syoyo): Deduplicate times?
 
-  crate::ValueRep rep{0};
-  if (!ReadValueRep(&rep)) {
-    _err += "Failed to read ValueRep for TimeSample' times element.\n";
-    return false;
+  crate::ValueRep times_rep{0};
+  if (!ReadValueRep(&times_rep)) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read ValueRep for TimeSample' `times` element.");
   }
 
   // Save offset
-  size_t values_offset = _sr->tell();
+  auto values_offset = _sr->tell();
 
-  crate::CrateValue value;
-  if (!UnpackValueRep(rep, &value)) {
-    _err += "Failed to unpack value of TimeSample's times element.\n";
-    return false;
+  // TODO: Enable Check if  type `double[]`
+#if 0
+  if (times_rep.GetType() == crate::CrateDataTypeId::CRATE_DATA_TYPE_DOUBLE_VECTOR) {
+    // ok
+  } else if ((times_rep.GetType() == crate::CrateDataTypeId::CRATE_DATA_TYPE_DOUBOLE) && times_rep.IsArray()) {
+    // ok
+  } else {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, fmt::format("`times` value must be type `double[]`, but got type `{}`", times_rep.GetTypeName()));
+  }
+#endif
+
+  crate::CrateValue times_value;
+  if (!UnpackValueRep(times_rep, &times_value)) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to unpack value of TimeSample's `times` element.");
   }
 
   // must be an array of double.
-  DCOUT("TimeSample times:" << value.GetTypeName());
-  DCOUT("TODO: Parse TimeSample values");
+  DCOUT("TimeSample times:" << times_value.type_name());
+
+  std::vector<double> times;
+  if (auto pv = times_value.get_value<std::vector<double>>()) {
+    times = pv.value();
+    DCOUT("`times` = " << times);
+  } else {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, fmt::format("`times` in TimeSamples must be type `double[]`, but got type `{}`", times_value.type_name()));
+  }
 
   //
-  // Parse values for TimeSamples.
-  // TODO(syoyo): Delayed loading of values.
+  // Parse values(elements) of TimeSamples.
   //
 
   // seek position will be changed in `_UnpackValueRep`, so revert it.
   if (!_sr->seek_set(values_offset)) {
-    _err += "Failed to seek to TimeSamples values.\n";
-    return false;
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to seek to TimeSamples values.");
   }
 
   // 8byte for the offset for recursive value. See RecursiveRead() in
   // crateFile.cpp for details.
   if (!_sr->read8(&offset)) {
-    _err += "Failed to read the offset for value in TimeSamples.\n";
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read the offset for value in TimeSamples.");
     return false;
   }
 
   DCOUT("TimeSample value offset = " << offset);
   DCOUT("TimeSample tell = " << _sr->tell());
 
   // -8 to compensate sizeof(offset)
   if (!_sr->seek_from_current(offset - 8)) {
-    _err += "Failed to seek to TimeSample values. Invalid offset value: " +
-            std::to_string(offset) + "\n";
-    return false;
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to seek to TimeSample values. Invalid offset value: " + std::to_string(offset));
   }
 
   uint64_t num_values{0};
   if (!_sr->read8(&num_values)) {
-    _err += "Failed to read the number of values from TimeSamples.\n";
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read the number of values from TimeSamples.");
     return false;
   }
 
   DCOUT("Number of values = " << num_values);
 
-  _warn += "TODO: Decode TimeSample's values\n";
+  if (times.size() != num_values) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "# of `times` elements and # of values in Crate differs.");
+  }
+
+  for (size_t i = 0; i < num_values; i++) {
+
+    crate::ValueRep rep;
+    if (!ReadValueRep(&rep)) {
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read ValueRep for TimeSample' value element.");
+    }
+
+    auto next_vrep_loc = _sr->tell();
+
+    ///
+    /// Type check of the content of `value` will be done at ReconstructPrim() in usdc-reader.cc.
+    ///
+    crate::CrateValue value;
+    if (!UnpackValueRep(rep, &value)) {
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to unpack value of TimeSample's value element.");
+    }
+
+    d->add_sample(times[i], value.get_raw());
+
+    // UnpackValueRep() will change StreamReader's read position.
+    // Revert to next ValueRep location here.
+    _sr->seek_set(next_vrep_loc);
+  }
 
   // Move to next location.
   // sizeof(uint64) = sizeof(ValueRep)
   if (!_sr->seek_from_current(int64_t(sizeof(uint64_t) * num_values))) {
-    _err += "Failed to seek over TimeSamples's values.\n";
-    return false;
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to seek over TimeSamples's values.");
   }
 
+
   return true;
 }
 
 bool CrateReader::ReadStringArray(std::vector<std::string> *d) {
   // array data is not compressed
   auto ReadFn = [this](std::vector<std::string> &result) -> bool {
     uint64_t n;
     if (!_sr->read8(&n)) {
       PUSH_ERROR("Failed to read # of elements.");
       return false;
     }
 
+    if (n > _config.maxArrayElements) {
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Too many array elements.");
+    }
+
+    CHECK_MEMORY_USAGE(size_t(n) * sizeof(crate::Index));
+
     std::vector<crate::Index> ivalue(static_cast<size_t>(n));
 
     if (!_sr->read(size_t(n) * sizeof(crate::Index),
                    size_t(n) * sizeof(crate::Index),
                    reinterpret_cast<uint8_t *>(ivalue.data()))) {
       PUSH_ERROR("Failed to read STRING_VECTOR data.");
       return false;
     }
 
     // reconstruct
+    CHECK_MEMORY_USAGE(size_t(n) * sizeof(void *));
     result.resize(static_cast<size_t>(n));
     for (size_t i = 0; i < n; i++) {
       if (auto v = GetStringToken(ivalue[i])) {
-        result[i] = v.value().str();
+        std::string s = v.value().str();
+        CHECK_MEMORY_USAGE(s.size());
+        result[i] = s;
       } else {
         PUSH_ERROR("Invalid StringIndex.");
       }
     }
 
     return true;
   };
@@ -862,23 +928,155 @@
   }
 
   (*d) = items;
 
   return true;
 }
 
+bool CrateReader::ReadReference(Reference *d) {
+
+  if (!d) {
+    return false;
+  }
+
+  // assetPath : string
+  // primPath : Path
+  // layerOffset : LayerOffset
+  // customData : Dict
+
+  std::string assetPath;
+  if (!ReadString(&assetPath)) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read assetPath in Reference ValueRep.");
+  }
+
+  crate::PathIndex index;
+  if (!ReadIndex(&index)) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read primPath Index in Reference ValueRep.");
+  }
+
+  auto path = GetPath(index);
+  if (!path) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Invalid Path index in Reference ValueRep.");
+  }
+
+  LayerOffset layerOffset;
+  if (!ReadLayerOffset(&layerOffset)) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read LayerOffset in Reference ValueRep.");
+  }
+
+  CustomDataType customData;
+  if (!ReadCustomData(&customData)) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read CustomData(Dict) in Reference ValueRep.");
+  }
+
+  d->asset_path = assetPath;
+  d->prim_path = path.value();
+  d->layerOffset = layerOffset;
+  d->customData = customData;
+
+  return true;
+}
+
+bool CrateReader::ReadPayload(Payload *d) {
+
+  if (!d) {
+    return false;
+  }
+
+  // assetPath : string
+  // primPath : Path
+
+  std::string assetPath;
+  if (!ReadString(&assetPath)) {
+    return false;
+  }
+
+
+  crate::PathIndex index;
+  if (!ReadIndex(&index)) {
+    return false;
+  }
+
+  auto path = GetPath(index);
+  if (!path) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Invalid Path index in Payload ValueRep.");
+  }
+
+  // LayerOffset from 0.8.0
+  if (VersionGreaterThanOrEqualTo_0_8_0()) {
+    LayerOffset layerOffset;
+    if (!ReadLayerOffset(&layerOffset)) {
+      return false;
+    }
+    d->_layer_offset = layerOffset;
+  }
+
+  d->asset_path = assetPath;
+  d->_prim_path = path.value();
+
+  return true;
+}
+
+bool CrateReader::ReadLayerOffset(LayerOffset *d) {
+  static_assert(sizeof(LayerOffset) == 8 * 2, "LayerOffset must be 16bytes");
+
+  // double x 2
+  if (!_sr->read(sizeof(double), sizeof(double), reinterpret_cast<uint8_t *>(&(d->_offset)))) {
+    return false;
+  }
+  if (!_sr->read(sizeof(double), sizeof(double), reinterpret_cast<uint8_t *>(&(d->_scale)))) {
+    return false;
+  }
+
+  return true;
+}
+
+bool CrateReader::ReadLayerOffsetArray(std::vector<LayerOffset> *d) {
+  // array data is not compressed
+
+  uint64_t n;
+  if (!_sr->read8(&n)) {
+    PUSH_ERROR("Failed to read # of elements.");
+    return false;
+  }
+
+  if (n > _config.maxArrayElements) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Too many array elements.");
+  }
+
+  CHECK_MEMORY_USAGE(size_t(n) * sizeof(LayerOffset));
+
+  d->resize(size_t(n));
+
+  if (!_sr->read(size_t(n) * sizeof(LayerOffset),
+                 size_t(n) * sizeof(LayerOffset),
+                 reinterpret_cast<uint8_t *>(d->data()))) {
+    PUSH_ERROR("Failed to read LayerOffset[] data.");
+    return false;
+  }
+
+  return true;
+}
+
 bool CrateReader::ReadPathArray(std::vector<Path> *d) {
   // array data is not compressed
   auto ReadFn = [this](std::vector<Path> &result) -> bool {
     uint64_t n;
     if (!_sr->read8(&n)) {
       _err += "Failed to read # of elements in ListOp.\n";
       return false;
     }
 
+    if (n > _config.maxArrayElements) {
+      _err += "Too many Path array elements.\n";
+      return false;
+    }
+
+    CHECK_MEMORY_USAGE(size_t(n) * sizeof(crate::Index));
+
     std::vector<crate::Index> ivalue(static_cast<size_t>(n));
 
     if (!_sr->read(size_t(n) * sizeof(crate::Index),
                    size_t(n) * sizeof(crate::Index),
                    reinterpret_cast<uint8_t *>(ivalue.data()))) {
       _err += "Failed to read ListOp data.\n";
       return false;
@@ -925,14 +1123,21 @@
   auto ReadFn = [this](std::vector<value::token> &result) -> bool {
     uint64_t n;
     if (!_sr->read8(&n)) {
       _err += "Failed to read # of elements in ListOp.\n";
       return false;
     }
 
+    if (n > _config.maxArrayElements) {
+      _err += "Too many ListOp elements.\n";
+      return false;
+    }
+
+    CHECK_MEMORY_USAGE(size_t(n) * sizeof(crate::Index));
+
     std::vector<crate::Index> ivalue(static_cast<size_t>(n));
 
     if (!_sr->read(size_t(n) * sizeof(crate::Index),
                    size_t(n) * sizeof(crate::Index),
                    reinterpret_cast<uint8_t *>(ivalue.data()))) {
       _err += "Failed to read ListOp data.\n";
       return false;
@@ -1010,34 +1215,154 @@
 
     d->SetOrderedItems(items);
   }
 
   return true;
 }
 
+bool CrateReader::ReadStringListOp(ListOp<std::string> *d) {
+  // read ListOpHeader
+  ListOpHeader h;
+  if (!_sr->read1(&h.bits)) {
+    _err += "Failed to read ListOpHeader\n";
+    return false;
+  }
+
+  if (h.IsExplicit()) {
+    d->ClearAndMakeExplicit();
+  }
+
+  // array data is not compressed
+  auto ReadFn = [this](std::vector<std::string> &result) -> bool {
+    uint64_t n;
+    if (!_sr->read8(&n)) {
+      _err += "Failed to read # of elements in ListOp.\n";
+      return false;
+    }
+
+    if (n > _config.maxArrayElements) {
+      _err += "Too many ListOp elements.\n";
+      return false;
+    }
+
+    CHECK_MEMORY_USAGE(size_t(n) * sizeof(crate::Index));
+
+    std::vector<crate::Index> ivalue(static_cast<size_t>(n));
+
+    if (!_sr->read(size_t(n) * sizeof(crate::Index),
+                   size_t(n) * sizeof(crate::Index),
+                   reinterpret_cast<uint8_t *>(ivalue.data()))) {
+      _err += "Failed to read ListOp data.\n";
+      return false;
+    }
+
+    // reconstruct
+    result.resize(static_cast<size_t>(n));
+    for (size_t i = 0; i < n; i++) {
+      if (auto v = GetStringToken(ivalue[i])) {
+        result[i] = v.value().str();
+      } else {
+        return false;
+      }
+    }
+
+    return true;
+  };
+
+  if (h.HasExplicitItems()) {
+    std::vector<std::string> items;
+    if (!ReadFn(items)) {
+      _err += "Failed to read ListOp::ExplicitItems.\n";
+      return false;
+    }
+
+    d->SetExplicitItems(items);
+  }
+
+  if (h.HasAddedItems()) {
+    std::vector<std::string> items;
+    if (!ReadFn(items)) {
+      _err += "Failed to read ListOp::AddedItems.\n";
+      return false;
+    }
+
+    d->SetAddedItems(items);
+  }
+
+  if (h.HasPrependedItems()) {
+    std::vector<std::string> items;
+    if (!ReadFn(items)) {
+      _err += "Failed to read ListOp::PrependedItems.\n";
+      return false;
+    }
+
+    d->SetPrependedItems(items);
+  }
+
+  if (h.HasAppendedItems()) {
+    std::vector<std::string> items;
+    if (!ReadFn(items)) {
+      _err += "Failed to read ListOp::AppendedItems.\n";
+      return false;
+    }
+
+    d->SetAppendedItems(items);
+  }
+
+  if (h.HasDeletedItems()) {
+    std::vector<std::string> items;
+    if (!ReadFn(items)) {
+      _err += "Failed to read ListOp::DeletedItems.\n";
+      return false;
+    }
+
+    d->SetDeletedItems(items);
+  }
+
+  if (h.HasOrderedItems()) {
+    std::vector<std::string> items;
+    if (!ReadFn(items)) {
+      _err += "Failed to read ListOp::OrderedItems.\n";
+      return false;
+    }
+
+    d->SetOrderedItems(items);
+  }
+
+  return true;
+}
+
 bool CrateReader::ReadPathListOp(ListOp<Path> *d) {
   // read ListOpHeader
   ListOpHeader h;
   if (!_sr->read1(&h.bits)) {
     PUSH_ERROR("Failed to read ListOpHeader.");
     return false;
   }
 
   if (h.IsExplicit()) {
+    DCOUT("IsExplicit()");
     d->ClearAndMakeExplicit();
   }
 
   // array data is not compressed
   auto ReadFn = [this](std::vector<Path> &result) -> bool {
     uint64_t n;
     if (!_sr->read8(&n)) {
       PUSH_ERROR("Failed to read # of elements in ListOp.");
       return false;
     }
 
+    if (n > _config.maxArrayElements) {
+      _err += "Too many ListOp elements.\n";
+      return false;
+    }
+
+    CHECK_MEMORY_USAGE(size_t(n) * sizeof(crate::Index));
+
     std::vector<crate::Index> ivalue(static_cast<size_t>(n));
 
     if (!_sr->read(size_t(n) * sizeof(crate::Index),
                    size_t(n) * sizeof(crate::Index),
                    reinterpret_cast<uint8_t *>(ivalue.data()))) {
       PUSH_ERROR("Failed to read ListOp data..");
       return false;
@@ -1116,72 +1441,286 @@
 
     d->SetOrderedItems(items);
   }
 
   return true;
 }
 
-bool CrateReader::ReadDictionary(crate::CrateValue::Dictionary *d) {
-  crate::CrateValue::Dictionary dict;
+template<>
+bool CrateReader::ReadArray(std::vector<Reference> *d) {
+
+  if (!d) {
+    return false;
+  }
+
+  uint64_t n;
+  if (!_sr->read8(&n)) {
+    return false;
+  }
+
+  if (n > _config.maxArrayElements) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Too many array elements.");
+  }
+
+  CHECK_MEMORY_USAGE(sizeof(Reference) * n);
+
+  for (size_t i = 0; i < n; i++) {
+    Reference p;
+    if (!ReadReference(&p)) {
+      return false;
+    }
+    d->emplace_back(p);
+  }
+
+  return true;
+}
+
+template<>
+bool CrateReader::ReadArray(std::vector<Payload> *d) {
+
+  if (!d) {
+    return false;
+  }
+
+  uint64_t n;
+  if (!_sr->read8(&n)) {
+    return false;
+  }
+
+  if (n > _config.maxArrayElements) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Too many array elements.");
+  }
+
+  CHECK_MEMORY_USAGE(sizeof(Payload) * n);
+
+  for (size_t i = 0; i < n; i++) {
+    Payload p;
+    if (!ReadPayload(&p)) {
+      return false;
+    }
+    d->emplace_back(p);
+  }
+
+  return true;
+}
+
+// T = int, uint, int64, uint64
+template<typename T>
+//typename std::enable_if<CrateReader::IsIntType<T>::value, bool>::type
+bool CrateReader::ReadArray(std::vector<T> *d) {
+
+  if (!d) {
+    return false;
+  }
+
+  uint64_t n;
+  if (!_sr->read8(&n)) {
+    return false;
+  }
+
+  if (n > _config.maxArrayElements) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Too many array elements.");
+  }
+
+  if (n == 0) {
+    return true;
+  }
+
+  CHECK_MEMORY_USAGE(sizeof(T) * size_t(n));
+
+  d->resize(size_t(n));
+  if (_sr->read(sizeof(T) * n, sizeof(T) * size_t(n), reinterpret_cast<uint8_t *>(d->data()))) {
+    return false;
+  }
+
+  return true;
+}
+
+template<typename T>
+bool CrateReader::ReadListOp(ListOp<T> *d) {
+  // read ListOpHeader
+  ListOpHeader h;
+  if (!_sr->read1(&h.bits)) {
+    PUSH_ERROR("Failed to read ListOpHeader.");
+    return false;
+  }
+
+  if (h.IsExplicit()) {
+    d->ClearAndMakeExplicit();
+  }
+
+  //
+  // NOTE: array data is not compressed even for Int type
+  //
+
+  if (h.HasExplicitItems()) {
+    std::vector<T> items;
+    if (!ReadArray(&items)) {
+      _err += "Failed to read ListOp::ExplicitItems.\n";
+      return false;
+    }
+
+    d->SetExplicitItems(items);
+  }
+
+  if (h.HasAddedItems()) {
+    std::vector<T> items;
+    if (!ReadArray(&items)) {
+      _err += "Failed to read ListOp::AddedItems.\n";
+      return false;
+    }
+
+    d->SetAddedItems(items);
+  }
+
+  if (h.HasPrependedItems()) {
+    std::vector<T> items;
+    if (!ReadArray(&items)) {
+      _err += "Failed to read ListOp::PrependedItems.\n";
+      return false;
+    }
+
+    d->SetPrependedItems(items);
+  }
+
+  if (h.HasAppendedItems()) {
+    std::vector<T> items;
+    if (!ReadArray(&items)) {
+      _err += "Failed to read ListOp::AppendedItems.\n";
+      return false;
+    }
+
+    d->SetAppendedItems(items);
+  }
+
+  if (h.HasDeletedItems()) {
+    std::vector<T> items;
+    if (!ReadArray(&items)) {
+      _err += "Failed to read ListOp::DeletedItems.\n";
+      return false;
+    }
+
+    d->SetDeletedItems(items);
+  }
+
+  if (h.HasOrderedItems()) {
+    std::vector<T> items;
+    if (!ReadArray(&items)) {
+      _err += "Failed to read ListOp::OrderedItems.\n";
+      return false;
+    }
+
+    d->SetOrderedItems(items);
+  }
+
+  return true;
+}
+
+
+bool CrateReader::ReadVariantSelectionMap(VariantSelectionMap *d) {
+
+  if (!d) {
+    return false;
+  }
+
+  // map<string, string>
+
+  // n
+  // [key, value] * n
+
+  uint64_t sz;
+  if (!_sr->read8(&sz)) {
+    _err += "Failed to read the number of elements for VariantsMap data.\n";
+    return false;
+  }
+
+  if (sz > _config.maxVariantsMapElements) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "The number of elements for VariantsMap data is too large. Max = " << std::to_string(_config.maxVariantsMapElements) << ", but got " << std::to_string(sz));
+  }
+
+  for (size_t i = 0; i < sz; i++) {
+    std::string key;
+    if (!ReadString(&key)) {
+      return false;
+    }
+
+    std::string value;
+    if (!ReadString(&value)) {
+      return false;
+    }
+
+    // TODO: Duplicate key check?
+    d->emplace(key, value);
+  }
+
+  return true;
+}
+
+bool CrateReader::ReadCustomData(CustomDataType *d) {
+  CustomDataType dict;
   uint64_t sz;
   if (!_sr->read8(&sz)) {
     _err += "Failed to read the number of elements for Dictionary data.\n";
     return false;
   }
 
+  if (sz > _config.maxDictElements) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "The number of elements for Dictionary data is too large. Max = " << std::to_string(_config.maxDictElements) << ", but got " << std::to_string(sz));
+  }
+
   DCOUT("# o elements in dict" << sz);
 
   while (sz--) {
     // key(StringIndex)
     std::string key;
 
     if (!ReadString(&key)) {
-      _err += "Failed to read key string for Dictionary element.\n";
-      return false;
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read key string for Dictionary element.");
     }
 
     // 8byte for the offset for recursive value. See RecursiveRead() in
     // crateFile.cpp for details.
     int64_t offset{0};
     if (!_sr->read8(&offset)) {
-      _err += "Failed to read the offset for value in Dictionary.\n";
-      return false;
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read the offset for value in Dictionary.");
     }
 
     // -8 to compensate sizeof(offset)
     if (!_sr->seek_from_current(offset - 8)) {
-      _err +=
-          "Failed to seek. Invalid offset value: " + std::to_string(offset) +
-          "\n";
-      return false;
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to seek. Invalid offset value: " + std::to_string(offset));
     }
 
     DCOUT("key = " << key);
 
     crate::ValueRep rep{0};
     if (!ReadValueRep(&rep)) {
-      _err += "Failed to read value for Dictionary element.\n";
-      return false;
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read value for Dictionary element.");
     }
 
     DCOUT("vrep =" << crate::GetCrateDataTypeName(rep.GetType()));
 
-    size_t saved_position = _sr->tell();
+    auto saved_position = _sr->tell();
 
     crate::CrateValue value;
     if (!UnpackValueRep(rep, &value)) {
-      _err += "Failed to unpack value of Dictionary element.\n";
-      return false;
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to unpack value of Dictionary element.");
     }
 
-    dict[key] = value;
+    if (dict.count(key)) {
+      // Duplicated key. maybe ok?
+    }
+    // CrateValue -> MetaVariable
+    MetaVariable var;
+
+    var.set_value(key, value.get_raw());
+
+    dict[key] = var;
 
     if (!_sr->seek_set(saved_position)) {
-      _err += "Failed to set seek in ReadDict\n";
-      return false;
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to set seek.");
     }
   }
 
   (*d) = std::move(dict);
   return true;
 }
 
@@ -1226,15 +1765,15 @@
       return true;
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_ASSET_PATH: {
       // AssetPath = std::string(storage format is TokenIndex).
       if (auto v = GetToken(crate::Index(d))) {
         std::string str = v.value().str();
 
-        value::asset_path assetp(str);
+        value::AssetPath assetp(str);
         value->Set(assetp);
         return true;
       } else {
         PUSH_ERROR("Invalid Index for AssetPath.");
         return false;
       }
     }
@@ -1458,17 +1997,17 @@
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_VEC3F:
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_VEC3H: {
       // Value is represented in int8
       int8_t data[3];
       memcpy(&data, &d, 3);
 
       value::half3 v;
-      v[0] = float_to_half_full(float(data[0]));
-      v[1] = float_to_half_full(float(data[1]));
-      v[2] = float_to_half_full(float(data[2]));
+      v[0] = value::float_to_half_full(float(data[0]));
+      v[1] = value::float_to_half_full(float(data[1]));
+      v[2] = value::float_to_half_full(float(data[2]));
 
       DCOUT("value.half3 = " << v);
 
       value->Set(v);
 
       return true;
     }
@@ -1524,18 +2063,18 @@
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_VEC4H: {
       // Value is represented in int8
       int8_t data[4];
       memcpy(&data, &d, 4);
 
       value::half4 v;
-      v[0] = float_to_half_full(float(data[0]));
-      v[1] = float_to_half_full(float(data[0]));
-      v[2] = float_to_half_full(float(data[0]));
-      v[3] = float_to_half_full(float(data[0]));
+      v[0] = value::float_to_half_full(float(data[0]));
+      v[1] = value::float_to_half_full(float(data[0]));
+      v[2] = value::float_to_half_full(float(data[0]));
+      v[3] = value::float_to_half_full(float(data[0]));
 
       DCOUT("value.vec4h = " << v);
 
       value->Set(v);
 
       return true;
     }
@@ -1555,39 +2094,51 @@
       value->Set(v);
 
       return true;
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_DICTIONARY: {
       // empty dict is allowed
       // TODO: empty(zero value) check?
-      crate::CrateValue::Dictionary dict;
+      //crate::CrateValue::Dictionary dict;
+      CustomDataType dict; // use CustomDataType for Dict
       value->Set(dict);
       return true;
     }
+    case crate::CrateDataTypeId::CRATE_DATA_TYPE_VALUE_BLOCK: {
+      // Guess No content for ValueBlock
+      value::ValueBlock block;
+      value->Set(block);
+      return true;
+    }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_TOKEN_LIST_OP:
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_STRING_LIST_OP:
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_PATH_LIST_OP:
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_REFERENCE_LIST_OP:
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_INT_LIST_OP:
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_INT64_LIST_OP:
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_UINT_LIST_OP:
-    case crate::CrateDataTypeId::CRATE_DATA_TYPE_UINT64_LIST_OP:
+    case crate::CrateDataTypeId::CRATE_DATA_TYPE_UINT64_LIST_OP: {
+      PUSH_ERROR_AND_RETURN_TAG(kTag, fmt::format("ListOp data type `{}` cannot be inlined.",
+          crate::GetCrateDataTypeName(dty.dtype_id)));
+    }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_PATH_VECTOR:
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_TOKEN_VECTOR:
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_VARIANT_SELECTION_MAP:
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_TIME_SAMPLES:
-    case crate::CrateDataTypeId::CRATE_DATA_TYPE_PAYLOAD:
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_DOUBLE_VECTOR:
+    case crate::CrateDataTypeId::CRATE_DATA_TYPE_PAYLOAD:
+    case crate::CrateDataTypeId::CRATE_DATA_TYPE_PAYLOAD_LIST_OP:
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_LAYER_OFFSET_VECTOR:
-    case crate::CrateDataTypeId::CRATE_DATA_TYPE_STRING_VECTOR:
-    case crate::CrateDataTypeId::CRATE_DATA_TYPE_VALUE_BLOCK:
+    case crate::CrateDataTypeId::CRATE_DATA_TYPE_STRING_VECTOR: {
+      PUSH_ERROR_AND_RETURN_TAG(kTag, fmt::format("Data type `{}` cannot be inlined.",
+          crate::GetCrateDataTypeName(dty.dtype_id)));
+    }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_VALUE:
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_UNREGISTERED_VALUE:
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_UNREGISTERED_VALUE_LIST_OP:
-    case crate::CrateDataTypeId::CRATE_DATA_TYPE_PAYLOAD_LIST_OP:
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_TIME_CODE: {
       PUSH_ERROR(
           "Invalid data type(or maybe not supported in TinyUSDZ yet) for "
           "Inlined value: " +
           crate::GetCrateDataTypeName(dty.dtype_id));
       return false;
     }
@@ -1620,14 +2171,15 @@
 
 bool CrateReader::UnpackValueRep(const crate::ValueRep &rep,
                                  crate::CrateValue *value) {
   if (rep.IsInlined()) {
     return UnpackInlinedValueRep(rep, value);
   }
 
+  DCOUT("ValueRep type value = " << rep.GetType());
   auto tyRet = crate::GetCrateDataType(rep.GetType());
   if (!tyRet) {
     PUSH_ERROR(tyRet.error());
   }
 
   const auto dty = tyRet.value();
 
@@ -1665,53 +2217,104 @@
     PUSH_ERROR("Invalid offset.");
     return false;
   }
 
   switch (dty.dtype_id) {
     case crate::CrateDataTypeId::NumDataTypes:
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_INVALID: {
+      DCOUT("dtype_id = " << to_string(uint32_t(dty.dtype_id)));
       PUSH_ERROR("`Invalid` DataType.");
       return false;
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_BOOL: {
       COMPRESS_UNSUPPORTED_CHECK(dty)
       NON_ARRAY_UNSUPPORTED_CHECK(dty)
 
       if (rep.IsArray()) {
-        TODO_IMPLEMENT(dty)
+        std::vector<bool> v;
+
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
+
+        // bool is encoded as 8bit value.
+
+        uint64_t n;
+        if (!_sr->read8(&n)) {
+          PUSH_ERROR("Failed to read the number of array elements.");
+          return false;
+        }
+
+        if (n > _config.maxAssetPathElements) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, fmt::format("# of bool array too large. TinyUSDZ limites it up to {}", _config.maxAssetPathElements));
+        }
+
+        CHECK_MEMORY_USAGE(n * sizeof(uint8_t));
+
+        std::vector<uint8_t> data(static_cast<size_t>(n));
+        if (!_sr->read(size_t(n) * sizeof(uint8_t),
+                       size_t(n) * sizeof(uint8_t),
+                       reinterpret_cast<uint8_t *>(data.data()))) {
+          PUSH_ERROR("Failed to read bool array.");
+          return false;
+        }
+
+        // to std::vector<bool>, whose underlying storage may use 1bit.
+        v.resize(size_t(n));
+        for (size_t i = 0; i < n; i++) {
+          v[i] = data[i] ? true : false;
+        }
+
+        value->Set(v);
+        return true;
+
       } else {
-        return false;
+        // non array bool should be inline encoded.
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "bool value must be inlined.");
       }
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_ASSET_PATH: {
       COMPRESS_UNSUPPORTED_CHECK(dty)
       NON_ARRAY_UNSUPPORTED_CHECK(dty)
 
       if (rep.IsArray()) {
+
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(std::vector<value::AssetPath>());
+          return true;
+        }
+
         // AssetPath = std::string(storage format is TokenIndex).
         uint64_t n;
         if (!_sr->read8(&n)) {
           PUSH_ERROR("Failed to read the number of array elements.");
           return false;
         }
 
+        if (n > _config.maxAssetPathElements) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, fmt::format("# of AssetPaths too large. TinyUSDZ limites it up to {}", _config.maxAssetPathElements));
+        }
+
+        CHECK_MEMORY_USAGE(n * sizeof(crate::Index));
+
         std::vector<crate::Index> v(static_cast<size_t>(n));
         if (!_sr->read(size_t(n) * sizeof(crate::Index),
                        size_t(n) * sizeof(crate::Index),
                        reinterpret_cast<uint8_t *>(v.data()))) {
           PUSH_ERROR("Failed to read TokenIndex array.");
           return false;
         }
 
-        std::vector<value::asset_path> apaths(static_cast<size_t>(n));
+        std::vector<value::AssetPath> apaths(static_cast<size_t>(n));
 
         for (size_t i = 0; i < n; i++) {
           if (auto tokv = GetToken(v[i])) {
             DCOUT("Token[" << i << "] = " << tokv.value());
-            apaths[i] = value::asset_path(tokv.value().str());
+            apaths[i] = value::AssetPath(tokv.value().str());
           } else {
             return false;
           }
         }
 
         value->Set(apaths);
         return true;
@@ -1720,21 +2323,34 @@
       }
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_TOKEN: {
       COMPRESS_UNSUPPORTED_CHECK(dty)
       NON_ARRAY_UNSUPPORTED_CHECK(dty)
 
       if (rep.IsArray()) {
+
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(std::vector<value::token>());
+          return true;
+        }
+
         uint64_t n;
         if (!_sr->read8(&n)) {
           PUSH_ERROR("Failed to read the number of array elements.");
           return false;
         }
 
-        std::vector<crate::Index> v(static_cast<size_t>(n));
+        if (n > _config.maxArrayElements) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, fmt::format("Token array too large. TinyUSDZ limites it up to {}", _config.maxArrayElements));
+        }
+
+        CHECK_MEMORY_USAGE(n * sizeof(crate::Index));
+
+        std::vector<crate::Index> v;
+        v.resize(static_cast<size_t>(n));
         if (!_sr->read(size_t(n) * sizeof(crate::Index),
                        size_t(n) * sizeof(crate::Index),
                        reinterpret_cast<uint8_t *>(v.data()))) {
           PUSH_ERROR("Failed to read TokenIndex array.");
           return false;
         }
 
@@ -1761,14 +2377,20 @@
       if (rep.IsArray()) {
         uint64_t n;
         if (!_sr->read8(&n)) {
           PUSH_ERROR("Failed to read the number of array elements.");
           return false;
         }
 
+        if (n > _config.maxArrayElements) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, fmt::format("String array too large. TinyUSDZ limites it up to {}", _config.maxArrayElements));
+        }
+
+        CHECK_MEMORY_USAGE(n * sizeof(crate::Index));
+
         std::vector<crate::Index> v(static_cast<size_t>(n));
         if (!_sr->read(size_t(n) * sizeof(crate::Index),
                        size_t(n) * sizeof(crate::Index),
                        reinterpret_cast<uint8_t *>(v.data()))) {
           PUSH_ERROR("Failed to read TokenIndex array.");
           return false;
         }
@@ -1805,58 +2427,70 @@
       TODO_IMPLEMENT(dty)
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_INT: {
       NON_ARRAY_UNSUPPORTED_CHECK(dty)
 
       if (rep.IsArray()) {
         std::vector<int32_t> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
         if (!ReadIntArray(rep.IsCompressed(), &v)) {
           PUSH_ERROR("Failed to read Int array.");
           return false;
         }
 
         if (v.empty()) {
           PUSH_ERROR("Empty int array.");
           return false;
         }
 
-        DCOUT("IntArray = " << v);
+        DCOUT("IntArray = " << value::print_array_snipped(v));
 
         value->Set(v);
         return true;
       } else {
         return false;
       }
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_UINT: {
       NON_ARRAY_UNSUPPORTED_CHECK(dty)
 
       if (rep.IsArray()) {
         std::vector<uint32_t> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
         if (!ReadIntArray(rep.IsCompressed(), &v)) {
           PUSH_ERROR("Failed to read UInt array.");
           return false;
         }
 
         if (v.empty()) {
           PUSH_ERROR("Empty uint array.");
           return false;
         }
 
-        DCOUT("UIntArray = " << v);
+        DCOUT("UIntArray = " << value::print_array_snipped(v));
 
         value->Set(v);
         return true;
       } else {
         return false;
       }
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_INT64: {
       if (rep.IsArray()) {
         std::vector<int64_t> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
         if (!ReadIntArray(rep.IsCompressed(), &v)) {
           PUSH_ERROR("Failed to read Int64 array.");
           return false;
         }
 
         if (v.empty()) {
           PUSH_ERROR("Empty int64 array.");
@@ -1866,14 +2500,16 @@
         DCOUT("Int64Array = " << v);
 
         value->Set(v);
         return true;
       } else {
         COMPRESS_UNSUPPORTED_CHECK(dty)
 
+        CHECK_MEMORY_USAGE(sizeof(int64_t));
+
         int64_t v;
         if (!_sr->read(sizeof(int64_t), sizeof(int64_t),
                        reinterpret_cast<uint8_t *>(&v))) {
           PUSH_ERROR("Failed to read int64 data.");
           return false;
         }
 
@@ -1882,31 +2518,38 @@
         value->Set(v);
         return true;
       }
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_UINT64: {
       if (rep.IsArray()) {
         std::vector<uint64_t> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
+
         if (!ReadIntArray(rep.IsCompressed(), &v)) {
           PUSH_ERROR("Failed to read UInt64 array.");
           return false;
         }
 
         if (v.empty()) {
           PUSH_ERROR("Empty uint64 array.");
           return false;
         }
 
-        DCOUT("UInt64Array = " << v);
+        DCOUT("UInt64Array = " << value::print_array_snipped(v));
 
         value->Set(v);
         return true;
       } else {
         COMPRESS_UNSUPPORTED_CHECK(dty)
 
+        CHECK_MEMORY_USAGE(sizeof(uint64_t));
+
         uint64_t v;
         if (!_sr->read(sizeof(uint64_t), sizeof(uint64_t),
                        reinterpret_cast<uint8_t *>(&v))) {
           PUSH_ERROR("Failed to read uint64 data.");
           return false;
         }
 
@@ -1915,14 +2558,18 @@
         value->Set(v);
         return true;
       }
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_HALF: {
       if (rep.IsArray()) {
         std::vector<value::half> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
         if (!ReadHalfArray(rep.IsCompressed(), &v)) {
           PUSH_ERROR("Failed to read half array value.");
           return false;
         }
 
         value->Set(v);
 
@@ -1931,46 +2578,56 @@
         PUSH_ERROR("Non-inlined, non-array Half value is invalid.");
         return false;
       }
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_FLOAT: {
       if (rep.IsArray()) {
         std::vector<float> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
         if (!ReadFloatArray(rep.IsCompressed(), &v)) {
           PUSH_ERROR("Failed to read float array value.");
           return false;
         }
 
-        DCOUT("FloatArray = " << v);
+        DCOUT("FloatArray = " << value::print_array_snipped(v));
 
         value->Set(v);
 
         return true;
       } else {
         COMPRESS_UNSUPPORTED_CHECK(dty)
 
         PUSH_ERROR("Non-inlined, non-array Float value is not supported.");
         return false;
       }
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_DOUBLE: {
       if (rep.IsArray()) {
         std::vector<double> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
         if (!ReadDoubleArray(rep.IsCompressed(), &v)) {
           PUSH_ERROR("Failed to read Double value.");
           return false;
         }
 
-        DCOUT("DoubleArray = " << v);
+        DCOUT("DoubleArray = " << value::print_array_snipped(v));
         value->Set(v);
 
         return true;
       } else {
         COMPRESS_UNSUPPORTED_CHECK(dty)
 
+        CHECK_MEMORY_USAGE(sizeof(double));
+
         double v;
         if (!_sr->read_double(&v)) {
           PUSH_ERROR("Failed to read Double value.");
           return false;
         }
 
         DCOUT("Double " << v);
@@ -1980,33 +2637,53 @@
         return true;
       }
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_MATRIX2D: {
       COMPRESS_UNSUPPORTED_CHECK(dty)
 
       if (rep.IsArray()) {
+        std::vector<value::matrix2d> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
+
         uint64_t n;
         if (!_sr->read8(&n)) {
           PUSH_ERROR("Failed to read the number of array elements.");
           return false;
         }
 
-        std::vector<value::matrix2d> v(static_cast<size_t>(n));
+        if (n == 0) {
+          value->Set(v);
+          return true;
+        }
+
+        if (n > _config.maxArrayElements) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, "Array size too large.");
+        }
+
+        CHECK_MEMORY_USAGE(n * sizeof(value::matrix2d));
+
+
+        v.resize(static_cast<size_t>(n));
         if (!_sr->read(size_t(n) * sizeof(value::matrix2d),
                        size_t(n) * sizeof(value::matrix2d),
                        reinterpret_cast<uint8_t *>(v.data()))) {
           PUSH_ERROR("Failed to read Matrix2d array.");
           return false;
         }
 
         value->Set(v);
 
       } else {
         static_assert(sizeof(value::matrix2d) == (8 * 4), "");
 
+        CHECK_MEMORY_USAGE(sizeof(value::matrix2d));
+
         value::matrix4d v;
         if (!_sr->read(sizeof(value::matrix2d), sizeof(value::matrix2d),
                        reinterpret_cast<uint8_t *>(v.m))) {
           _err += "Failed to read value of `matrix2d` type\n";
           return false;
         }
 
@@ -2017,34 +2694,53 @@
 
       return true;
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_MATRIX3D: {
       COMPRESS_UNSUPPORTED_CHECK(dty)
 
       if (rep.IsArray()) {
+        std::vector<value::matrix3d> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
+
         uint64_t n;
         if (!_sr->read8(&n)) {
           PUSH_ERROR("Failed to read the number of array elements.");
           return false;
         }
 
-        std::vector<value::matrix3d> v(static_cast<size_t>(n));
+        if (n == 0) {
+          value->Set(v);
+          return true;
+        }
+
+        if (n > _config.maxArrayElements) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, "Array size too large.");
+        }
+
+        CHECK_MEMORY_USAGE(n * sizeof(value::matrix3d));
+
+        v.resize(static_cast<size_t>(n));
         if (!_sr->read(size_t(n) * sizeof(value::matrix3d),
                        size_t(n) * sizeof(value::matrix3d),
                        reinterpret_cast<uint8_t *>(v.data()))) {
           PUSH_ERROR("Failed to read Matrix3d array.");
           return false;
         }
 
         value->Set(v);
 
       } else {
         static_assert(sizeof(value::matrix3d) == (8 * 9), "");
 
-        value::matrix4d v;
+        CHECK_MEMORY_USAGE(sizeof(value::matrix3d));
+
+        value::matrix3d v;
         if (!_sr->read(sizeof(value::matrix3d), sizeof(value::matrix3d),
                        reinterpret_cast<uint8_t *>(v.m))) {
           _err += "Failed to read value of `matrix3d` type\n";
           return false;
         }
 
         DCOUT("value.matrix3d = " << v);
@@ -2055,33 +2751,52 @@
       return true;
     }
 
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_MATRIX4D: {
       COMPRESS_UNSUPPORTED_CHECK(dty)
 
       if (rep.IsArray()) {
+        std::vector<value::matrix4d> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
         uint64_t n;
+
         if (!_sr->read8(&n)) {
           PUSH_ERROR("Failed to read the number of array elements.");
           return false;
         }
 
-        std::vector<value::matrix4d> v(static_cast<size_t>(n));
+        if (n == 0) {
+          value->Set(v);
+          return true;
+        }
+
+        if (n > _config.maxArrayElements) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, "Array size too large.");
+        }
+
+        CHECK_MEMORY_USAGE(n * sizeof(value::matrix4d));
+
+        v.resize(static_cast<size_t>(n));
         if (!_sr->read(size_t(n) * sizeof(value::matrix4d),
                        size_t(n) * sizeof(value::matrix4d),
                        reinterpret_cast<uint8_t *>(v.data()))) {
           PUSH_ERROR("Failed to read Matrix4d array.");
           return false;
         }
 
         value->Set(v);
 
       } else {
         static_assert(sizeof(value::matrix4d) == (8 * 16), "");
 
+        CHECK_MEMORY_USAGE(sizeof(value::matrix4d));
+
         value::matrix4d v;
         if (!_sr->read(sizeof(value::matrix4d), sizeof(value::matrix4d),
                        reinterpret_cast<uint8_t *>(v.m))) {
           _err += "Failed to read value of `matrix4d` type\n";
           return false;
         }
 
@@ -2090,35 +2805,53 @@
         value->Set(v);
       }
 
       return true;
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_QUATD: {
       if (rep.IsArray()) {
+        std::vector<value::quatd> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
         uint64_t n;
         if (!_sr->read8(&n)) {
           PUSH_ERROR("Failed to read the number of array elements.");
           return false;
         }
 
-        std::vector<value::quatd> v(static_cast<size_t>(n));
+        if (n == 0) {
+          value->Set(v);
+          return true;
+        }
+
+        if (n > _config.maxArrayElements) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, "Array size too large.");
+        }
+
+        CHECK_MEMORY_USAGE(n * sizeof(value::quatd));
+
+        v.resize(static_cast<size_t>(n));
         if (!_sr->read(size_t(n) * sizeof(value::quatd),
                        size_t(n) * sizeof(value::quatd),
                        reinterpret_cast<uint8_t *>(v.data()))) {
           PUSH_ERROR("Failed to read Quatf array.");
           return false;
         }
 
         DCOUT("Quatf[] = " << v);
 
         value->Set(v);
 
       } else {
         COMPRESS_UNSUPPORTED_CHECK(dty)
 
+        CHECK_MEMORY_USAGE(sizeof(value::quatd));
+
         value::quatd v;
         if (!_sr->read(sizeof(value::quatd), sizeof(value::quatd),
                        reinterpret_cast<uint8_t *>(&v))) {
           _err += "Failed to read Quatd value\n";
           return false;
         }
 
@@ -2126,35 +2859,53 @@
         value->Set(v);
       }
 
       return true;
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_QUATF: {
       if (rep.IsArray()) {
+        std::vector<value::quatf> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
         uint64_t n;
         if (!_sr->read8(&n)) {
           PUSH_ERROR("Failed to read the number of array elements.");
           return false;
         }
 
-        std::vector<value::quatf> v(static_cast<size_t>(n));
+        if (n == 0) {
+          value->Set(v);
+          return true;
+        }
+
+        if (n > _config.maxArrayElements) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, "Array size too large.");
+        }
+
+        CHECK_MEMORY_USAGE(n * sizeof(value::quatf));
+
+        v.resize(static_cast<size_t>(n));
         if (!_sr->read(size_t(n) * sizeof(value::quatf),
                        size_t(n) * sizeof(value::quatf),
                        reinterpret_cast<uint8_t *>(v.data()))) {
           PUSH_ERROR("Failed to read Quatf array.");
           return false;
         }
 
         DCOUT("Quatf[] = " << v);
 
         value->Set(v);
 
       } else {
         COMPRESS_UNSUPPORTED_CHECK(dty)
 
+        CHECK_MEMORY_USAGE(sizeof(value::quatf));
+
         value::quatf v;
         if (!_sr->read(sizeof(value::quatf), sizeof(value::quatf),
                        reinterpret_cast<uint8_t *>(&v))) {
           _err += "Failed to read Quatf value\n";
           return false;
         }
 
@@ -2162,35 +2913,53 @@
         value->Set(v);
       }
 
       return true;
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_QUATH: {
       if (rep.IsArray()) {
+        std::vector<value::quath> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
         uint64_t n;
         if (!_sr->read8(&n)) {
           PUSH_ERROR("Failed to read the number of array elements.");
           return false;
         }
 
-        std::vector<value::quath> v(static_cast<size_t>(n));
+        if (n == 0) {
+          value->Set(v);
+          return true;
+        }
+
+        if (n > _config.maxArrayElements) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, "Array size too large.");
+        }
+
+        CHECK_MEMORY_USAGE(n * sizeof(value::quath));
+
+        v.resize(static_cast<size_t>(n));
         if (!_sr->read(size_t(n) * sizeof(value::quath),
                        size_t(n) * sizeof(value::quath),
                        reinterpret_cast<uint8_t *>(v.data()))) {
           PUSH_ERROR("Failed to read Quath array.");
           return false;
         }
 
         DCOUT("Quath[] = " << v);
 
         value->Set(v);
 
       } else {
         COMPRESS_UNSUPPORTED_CHECK(dty)
 
+        CHECK_MEMORY_USAGE(sizeof(value::quath));
+
         value::quath v;
         if (!_sr->read(sizeof(value::quath), sizeof(value::quath),
                        reinterpret_cast<uint8_t *>(&v))) {
           _err += "Failed to read Quath value\n";
           return false;
         }
 
@@ -2200,33 +2969,51 @@
 
       return true;
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_VEC2D: {
       COMPRESS_UNSUPPORTED_CHECK(dty)
 
       if (rep.IsArray()) {
+        std::vector<value::double2> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
+
         uint64_t n;
         if (!_sr->read8(&n)) {
           PUSH_ERROR("Failed to read the number of array elements.");
           return false;
         }
 
-        std::vector<value::double2> v(static_cast<size_t>(n));
+        if (n == 0) {
+          value->Set(v);
+          return true;
+        }
+
+        if (n > _config.maxArrayElements) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, "Array size too large.");
+        }
+
+        CHECK_MEMORY_USAGE(n * sizeof(value::double2));
+
+        v.resize(static_cast<size_t>(n));
         if (!_sr->read(size_t(n) * sizeof(value::double2),
                        size_t(n) * sizeof(value::double2),
                        reinterpret_cast<uint8_t *>(v.data()))) {
           PUSH_ERROR("Failed to read double2 array.");
           return false;
         }
 
-        DCOUT("double2 = " << v);
+        DCOUT("double2[] = " << value::print_array_snipped(v));
 
         value->Set(v);
         return true;
       } else {
+        CHECK_MEMORY_USAGE(sizeof(value::double2));
         value::double2 v;
         if (!_sr->read(sizeof(value::double2), sizeof(value::double2),
                        reinterpret_cast<uint8_t *>(&v))) {
           PUSH_ERROR("Failed to read double2 data.");
           return false;
         }
 
@@ -2237,33 +3024,51 @@
       }
     }
 
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_VEC2F: {
       COMPRESS_UNSUPPORTED_CHECK(dty)
 
       if (rep.IsArray()) {
+        std::vector<value::float2> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
+
         uint64_t n;
         if (!_sr->read8(&n)) {
           PUSH_ERROR("Failed to read the number of array elements.");
           return false;
         }
 
-        std::vector<value::float2> v(static_cast<size_t>(n));
+        if (n > _config.maxArrayElements) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, "Array size too large.");
+        }
+
+        if (n == 0) {
+          value->Set(v);
+          return true;
+        }
+
+        CHECK_MEMORY_USAGE(n * sizeof(value::float2));
+
+        v.resize(static_cast<size_t>(n));
         if (!_sr->read(size_t(n) * sizeof(value::float2),
                        size_t(n) * sizeof(value::float2),
                        reinterpret_cast<uint8_t *>(v.data()))) {
           PUSH_ERROR("Failed to read float2 array.");
           return false;
         }
 
-        DCOUT("float2 = " << v);
+        DCOUT("float2[] = " << value::print_array_snipped(v));
 
         value->Set(v);
         return true;
       } else {
+        CHECK_MEMORY_USAGE(sizeof(value::float2));
         value::float2 v;
         if (!_sr->read(sizeof(value::float2), sizeof(value::float2),
                        reinterpret_cast<uint8_t *>(&v))) {
           PUSH_ERROR("Failed to read float2 data.");
           return false;
         }
 
@@ -2274,32 +3079,44 @@
       }
     }
 
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_VEC2H: {
       COMPRESS_UNSUPPORTED_CHECK(dty)
 
       if (rep.IsArray()) {
+        std::vector<value::half2> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
         uint64_t n;
         if (!_sr->read8(&n)) {
           PUSH_ERROR("Failed to read the number of array elements.");
           return false;
         }
 
-        std::vector<value::half2> v(static_cast<size_t>(n));
+        if (n > _config.maxArrayElements) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, "Array size too large.");
+        }
+
+        CHECK_MEMORY_USAGE(n * sizeof(value::half2));
+
+        v.resize(static_cast<size_t>(n));
         if (!_sr->read(size_t(n) * sizeof(value::half2),
                        size_t(n) * sizeof(value::half2),
                        reinterpret_cast<uint8_t *>(v.data()))) {
           PUSH_ERROR("Failed to read half2 array.");
           return false;
         }
 
-        DCOUT("half2 = " << v);
+        DCOUT("half2[] = " << value::print_array_snipped(v));
         value->Set(v);
 
       } else {
+        CHECK_MEMORY_USAGE(sizeof(value::half2));
         value::half2 v;
         if (!_sr->read(sizeof(value::half2), sizeof(value::half2),
                        reinterpret_cast<uint8_t *>(&v))) {
           PUSH_ERROR("Failed to read half2");
           return false;
         }
 
@@ -2310,32 +3127,44 @@
 
       return true;
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_VEC2I: {
       COMPRESS_UNSUPPORTED_CHECK(dty)
 
       if (rep.IsArray()) {
+        std::vector<value::int2> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
         uint64_t n;
         if (!_sr->read8(&n)) {
           PUSH_ERROR("Failed to read the number of array elements.");
           return false;
         }
 
-        std::vector<value::int2> v(static_cast<size_t>(n));
+        if (n > _config.maxArrayElements) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, "Array size too large.");
+        }
+
+        CHECK_MEMORY_USAGE(n * sizeof(value::int2));
+
+        v.resize(static_cast<size_t>(n));
         if (!_sr->read(size_t(n) * sizeof(value::int2),
                        size_t(n) * sizeof(value::int2),
                        reinterpret_cast<uint8_t *>(v.data()))) {
           PUSH_ERROR("Failed to read int2 array.");
           return false;
         }
 
-        DCOUT("int2 = " << v);
+        DCOUT("int2[] = " << value::print_array_snipped(v));
         value->Set(v);
 
       } else {
+        CHECK_MEMORY_USAGE(sizeof(value::int2));
         value::int2 v;
         if (!_sr->read(sizeof(value::int2), sizeof(value::int2),
                        reinterpret_cast<uint8_t *>(&v))) {
           PUSH_ERROR("Failed to read int2");
           return false;
         }
 
@@ -2346,32 +3175,44 @@
 
       return true;
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_VEC3D: {
       COMPRESS_UNSUPPORTED_CHECK(dty)
 
       if (rep.IsArray()) {
+        std::vector<value::double3> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
         uint64_t n;
         if (!_sr->read8(&n)) {
           PUSH_ERROR("Failed to read the number of array elements.");
           return false;
         }
 
-        std::vector<value::double3> v(static_cast<size_t>(n));
+        if (n > _config.maxArrayElements) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, "Array size too large.");
+        }
+
+        CHECK_MEMORY_USAGE(n * sizeof(value::double3));
+
+        v.resize(static_cast<size_t>(n));
         if (!_sr->read(size_t(n) * sizeof(value::double3),
                        size_t(n) * sizeof(value::double3),
                        reinterpret_cast<uint8_t *>(v.data()))) {
           PUSH_ERROR("Failed to read double3 array.");
           return false;
         }
 
-        DCOUT("double3 = " << v);
+        DCOUT("double3[] = " << value::print_array_snipped(v));
         value->Set(v);
 
       } else {
+        CHECK_MEMORY_USAGE(sizeof(value::double3));
         value::double3 v;
         if (!_sr->read(sizeof(value::double3), sizeof(value::double3),
                        reinterpret_cast<uint8_t *>(&v))) {
           PUSH_ERROR("Failed to read double3");
           return false;
         }
 
@@ -2382,32 +3223,45 @@
 
       return true;
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_VEC3F: {
       COMPRESS_UNSUPPORTED_CHECK(dty)
 
       if (rep.IsArray()) {
+        std::vector<value::float3> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
+
         uint64_t n;
         if (!_sr->read8(&n)) {
           PUSH_ERROR("Failed to read the number of array elements.");
           return false;
         }
 
-        std::vector<value::float3> v(static_cast<size_t>(n));
+        if (n > _config.maxArrayElements) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, "Array size too large.");
+        }
+
+        CHECK_MEMORY_USAGE(n * sizeof(value::float3));
+
+        v.resize(static_cast<size_t>(n));
         if (!_sr->read(size_t(n) * sizeof(value::float3),
                        size_t(n) * sizeof(value::float3),
                        reinterpret_cast<uint8_t *>(v.data()))) {
           PUSH_ERROR("Failed to read float3 array.");
           return false;
         }
 
-        DCOUT("float3f = " << v);
+        DCOUT("float3f[] = " << value::print_array_snipped(v));
         value->Set(v);
 
       } else {
+        CHECK_MEMORY_USAGE(sizeof(value::float3));
         value::float3 v;
         if (!_sr->read(sizeof(value::float3), sizeof(value::float3),
                        reinterpret_cast<uint8_t *>(&v))) {
           PUSH_ERROR("Failed to read float3");
           return false;
         }
 
@@ -2419,32 +3273,44 @@
       return true;
     }
 
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_VEC3H: {
       COMPRESS_UNSUPPORTED_CHECK(dty)
 
       if (rep.IsArray()) {
+        std::vector<value::half3> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
         uint64_t n;
         if (!_sr->read8(&n)) {
           PUSH_ERROR("Failed to read the number of array elements.");
           return false;
         }
 
-        std::vector<value::half3> v(static_cast<size_t>(n));
+        if (n > _config.maxArrayElements) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, "Array size too large.");
+        }
+
+        CHECK_MEMORY_USAGE(n * sizeof(value::half3));
+
+        v.resize(static_cast<size_t>(n));
         if (!_sr->read(size_t(n) * sizeof(value::half3),
                        size_t(n) * sizeof(value::half3),
                        reinterpret_cast<uint8_t *>(v.data()))) {
           PUSH_ERROR("Failed to read half3 array.");
           return false;
         }
 
-        DCOUT("half3 = " << v);
+        DCOUT("half3[] = " << value::print_array_snipped(v));
         value->Set(v);
 
       } else {
+        CHECK_MEMORY_USAGE(sizeof(value::half3));
         value::half3 v;
         if (!_sr->read(sizeof(value::half3), sizeof(value::half3),
                        reinterpret_cast<uint8_t *>(&v))) {
           PUSH_ERROR("Failed to read half3");
           return false;
         }
 
@@ -2455,32 +3321,44 @@
 
       return true;
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_VEC3I: {
       COMPRESS_UNSUPPORTED_CHECK(dty)
 
       if (rep.IsArray()) {
+        std::vector<value::int3> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
         uint64_t n;
         if (!_sr->read8(&n)) {
           PUSH_ERROR("Failed to read the number of array elements.");
           return false;
         }
 
-        std::vector<value::int3> v(static_cast<size_t>(n));
+        if (n > _config.maxArrayElements) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, "Array size too large.");
+        }
+
+        CHECK_MEMORY_USAGE(n * sizeof(value::int3));
+
+        v.resize(static_cast<size_t>(n));
         if (!_sr->read(size_t(n) * sizeof(value::int3),
                        size_t(n) * sizeof(value::int3),
                        reinterpret_cast<uint8_t *>(v.data()))) {
           PUSH_ERROR("Failed to read int3 array.");
           return false;
         }
 
-        DCOUT("int3 = " << v);
+        DCOUT("int3[] = " << value::print_array_snipped(v));
         value->Set(v);
 
       } else {
+        CHECK_MEMORY_USAGE(sizeof(value::int3));
         value::int3 v;
         if (!_sr->read(sizeof(value::int3), sizeof(value::int3),
                        reinterpret_cast<uint8_t *>(&v))) {
           PUSH_ERROR("Failed to read int3");
           return false;
         }
 
@@ -2491,32 +3369,44 @@
 
       return true;
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_VEC4D: {
       COMPRESS_UNSUPPORTED_CHECK(dty)
 
       if (rep.IsArray()) {
+        std::vector<value::double4> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
         uint64_t n;
         if (!_sr->read8(&n)) {
           PUSH_ERROR("Failed to read the number of array elements.");
           return false;
         }
 
-        std::vector<value::double4> v(static_cast<size_t>(n));
+        if (n > _config.maxArrayElements) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, "Array size too large.");
+        }
+
+        CHECK_MEMORY_USAGE(n * sizeof(value::double4));
+
+        v.resize(static_cast<size_t>(n));
         if (!_sr->read(size_t(n) * sizeof(value::double4),
                        size_t(n) * sizeof(value::double4),
                        reinterpret_cast<uint8_t *>(v.data()))) {
           PUSH_ERROR("Failed to read double4 array.");
           return false;
         }
 
-        DCOUT("double4 = " << v);
+        DCOUT("double4[] = " << value::print_array_snipped(v));
         value->Set(v);
 
       } else {
+        CHECK_MEMORY_USAGE(sizeof(value::double4));
         value::double4 v;
         if (!_sr->read(sizeof(value::double4), sizeof(value::double4),
                        reinterpret_cast<uint8_t *>(&v))) {
           PUSH_ERROR("Failed to read double4");
           return false;
         }
 
@@ -2527,32 +3417,44 @@
 
       return true;
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_VEC4F: {
       COMPRESS_UNSUPPORTED_CHECK(dty)
 
       if (rep.IsArray()) {
+        std::vector<value::float4> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
         uint64_t n;
         if (!_sr->read8(&n)) {
           PUSH_ERROR("Failed to read the number of array elements.");
           return false;
         }
 
-        std::vector<value::float4> v(static_cast<size_t>(n));
+        if (n > _config.maxArrayElements) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, "Array size too large.");
+        }
+
+        CHECK_MEMORY_USAGE(n * sizeof(value::float4));
+
+        v.resize(static_cast<size_t>(n));
         if (!_sr->read(size_t(n) * sizeof(value::float4),
                        size_t(n) * sizeof(value::float4),
                        reinterpret_cast<uint8_t *>(v.data()))) {
           PUSH_ERROR("Failed to read float4 array.");
           return false;
         }
 
-        DCOUT("float4 = " << v);
+        DCOUT("float4[] = " << value::print_array_snipped(v));
         value->Set(v);
 
       } else {
+        CHECK_MEMORY_USAGE(sizeof(value::float4));
         value::float4 v;
         if (!_sr->read(sizeof(value::float4), sizeof(value::float4),
                        reinterpret_cast<uint8_t *>(&v))) {
           PUSH_ERROR("Failed to read float4");
           return false;
         }
 
@@ -2563,32 +3465,44 @@
 
       return true;
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_VEC4H: {
       COMPRESS_UNSUPPORTED_CHECK(dty)
 
       if (rep.IsArray()) {
+        std::vector<value::half4> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
         uint64_t n;
         if (!_sr->read8(&n)) {
           PUSH_ERROR("Failed to read the number of array elements.");
           return false;
         }
 
-        std::vector<value::half4> v(static_cast<size_t>(n));
+        if (n > _config.maxArrayElements) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, "Array size too large.");
+        }
+
+        CHECK_MEMORY_USAGE(n * sizeof(value::half4));
+
+        v.resize(static_cast<size_t>(n));
         if (!_sr->read(size_t(n) * sizeof(value::half4),
                        size_t(n) * sizeof(value::half4),
                        reinterpret_cast<uint8_t *>(v.data()))) {
           PUSH_ERROR("Failed to read half4 array.");
           return false;
         }
 
-        DCOUT("half4 = " << v);
+        DCOUT("half4[] = " << value::print_array_snipped(v));
         value->Set(v);
 
       } else {
+        CHECK_MEMORY_USAGE(sizeof(value::half4));
         value::half4 v;
         if (!_sr->read(sizeof(value::half4), sizeof(value::half4),
                        reinterpret_cast<uint8_t *>(&v))) {
           PUSH_ERROR("Failed to read half4");
           return false;
         }
 
@@ -2599,32 +3513,44 @@
 
       return true;
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_VEC4I: {
       COMPRESS_UNSUPPORTED_CHECK(dty)
 
       if (rep.IsArray()) {
+        std::vector<value::int4> v;
+        if (rep.GetPayload() == 0) { // empty array
+          value->Set(v);
+          return true;
+        }
         uint64_t n;
         if (!_sr->read8(&n)) {
           PUSH_ERROR("Failed to read the number of array elements.");
           return false;
         }
 
-        std::vector<value::int4> v(static_cast<size_t>(n));
+        if (n > _config.maxArrayElements) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, "Array size too large.");
+        }
+
+        CHECK_MEMORY_USAGE(n * sizeof(value::int4));
+
+        v.resize(static_cast<size_t>(n));
         if (!_sr->read(size_t(n) * sizeof(value::int4),
                        size_t(n) * sizeof(value::int4),
                        reinterpret_cast<uint8_t *>(v.data()))) {
           PUSH_ERROR("Failed to read int4 array.");
           return false;
         }
 
-        DCOUT("int4 = " << v);
+        DCOUT("int4[] = " << value::print_array_snipped(v));
         value->Set(v);
 
       } else {
+        CHECK_MEMORY_USAGE(sizeof(value::int4));
         value::int4 v;
         if (!_sr->read(sizeof(value::int4), sizeof(value::int4),
                        reinterpret_cast<uint8_t *>(&v))) {
           PUSH_ERROR("Failed to read int4");
           return false;
         }
 
@@ -2635,17 +3561,18 @@
 
       return true;
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_DICTIONARY: {
       COMPRESS_UNSUPPORTED_CHECK(dty)
       ARRAY_UNSUPPORTED_CHECK(dty)
 
-      crate::CrateValue::Dictionary dict;
+      //crate::CrateValue::Dictionary dict;
+      CustomDataType dict;
 
-      if (!ReadDictionary(&dict)) {
+      if (!ReadCustomData(&dict)) {
         _err += "Failed to read Dictionary value\n";
         return false;
       }
 
       DCOUT("Dict. nelems = " << dict.size());
 
       value->Set(dict);
@@ -2675,14 +3602,25 @@
         return false;
       }
 
       value->Set(lst);
 
       return true;
     }
+    case crate::CrateDataTypeId::CRATE_DATA_TYPE_STRING_LIST_OP: {
+      ListOp<std::string> lst;
+
+      if (!ReadStringListOp(&lst)) {
+        PUSH_ERROR("Failed to read StringListOp data");
+        return false;
+      }
+
+      value->Set(lst);
+      return true;
+    }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_PATH_VECTOR: {
       COMPRESS_UNSUPPORTED_CHECK(dty)
 
       std::vector<Path> v;
       if (!ReadPathArray(&v)) {
         _err += "Failed to read PathVector value\n";
         return false;
@@ -2699,14 +3637,20 @@
       // std::vector<Index>
       uint64_t n;
       if (!_sr->read8(&n)) {
         PUSH_ERROR("Failed to read TokenVector value.");
         return false;
       }
 
+      if (n > _config.maxArrayElements) {
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "Array size too large.");
+      }
+
+      CHECK_MEMORY_USAGE(n * sizeof(crate::Index));
+
       std::vector<crate::Index> indices(static_cast<size_t>(n));
       if (!_sr->read(static_cast<size_t>(n) * sizeof(crate::Index),
                      static_cast<size_t>(n) * sizeof(crate::Index),
                      reinterpret_cast<uint8_t *>(indices.data()))) {
         PUSH_ERROR("Failed to read TokenVector value.");
         return false;
       }
@@ -2729,16 +3673,15 @@
       return true;
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_TIME_SAMPLES: {
       COMPRESS_UNSUPPORTED_CHECK(dty)
 
       value::TimeSamples ts;
       if (!ReadTimeSamples(&ts)) {
-        _err += "Failed to read TimeSamples data\n";
-        return false;
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read TimeSamples data");
       }
 
       value->Set(ts);
 
       return true;
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_DOUBLE_VECTOR: {
@@ -2755,42 +3698,271 @@
       return true;
     }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_STRING_VECTOR: {
       COMPRESS_UNSUPPORTED_CHECK(dty)
 
       std::vector<std::string> v;
       if (!ReadStringArray(&v)) {
-        _err += "Failed to read StringVector value\n";
-        return false;
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read StringVector value");
       }
 
       DCOUT("StringArray = " << v);
 
       value->Set(v);
 
       return true;
     }
-    case crate::CrateDataTypeId::CRATE_DATA_TYPE_STRING_LIST_OP:
-    case crate::CrateDataTypeId::CRATE_DATA_TYPE_REFERENCE_LIST_OP:
-    case crate::CrateDataTypeId::CRATE_DATA_TYPE_INT_LIST_OP:
-    case crate::CrateDataTypeId::CRATE_DATA_TYPE_INT64_LIST_OP:
-    case crate::CrateDataTypeId::CRATE_DATA_TYPE_UINT_LIST_OP:
-    case crate::CrateDataTypeId::CRATE_DATA_TYPE_UINT64_LIST_OP:
-    case crate::CrateDataTypeId::CRATE_DATA_TYPE_VARIANT_SELECTION_MAP:
-    case crate::CrateDataTypeId::CRATE_DATA_TYPE_PAYLOAD:
-    case crate::CrateDataTypeId::CRATE_DATA_TYPE_LAYER_OFFSET_VECTOR:
-    case crate::CrateDataTypeId::CRATE_DATA_TYPE_VALUE_BLOCK:
-    case crate::CrateDataTypeId::CRATE_DATA_TYPE_VALUE:
-    case crate::CrateDataTypeId::CRATE_DATA_TYPE_UNREGISTERED_VALUE:
+    case crate::CrateDataTypeId::CRATE_DATA_TYPE_VARIANT_SELECTION_MAP: {
+      COMPRESS_UNSUPPORTED_CHECK(dty)
+
+      VariantSelectionMap m;
+      if (!ReadVariantSelectionMap(&m)) {
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read VariantSelectionMap value");
+      }
+
+      DCOUT("VariantSelectionMap = " << print_variantSelectionMap(m, 0));
+
+      value->Set(m);
+
+      return true;
+    }
+    case crate::CrateDataTypeId::CRATE_DATA_TYPE_LAYER_OFFSET_VECTOR: {
+      COMPRESS_UNSUPPORTED_CHECK(dty)
+      // LayerOffset[]
+
+      std::vector<LayerOffset> v;
+      if (!ReadLayerOffsetArray(&v)) {
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read LayerOffsetVector value");
+      }
+
+      DCOUT("LayerOffsetVector = " << v);
+
+      value->Set(v);
+
+      return true;
+
+    }
+    case crate::CrateDataTypeId::CRATE_DATA_TYPE_PAYLOAD: {
+      COMPRESS_UNSUPPORTED_CHECK(dty)
+
+      // Payload
+      Payload v;
+      if (!ReadPayload(&v)) {
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read Payload value");
+      }
+
+      DCOUT("Payload = " << v);
+
+      value->Set(v);
+      return true;
+    }
+    case crate::CrateDataTypeId::CRATE_DATA_TYPE_PAYLOAD_LIST_OP: {
+      ListOp<Payload> lst;
+
+      if (!ReadListOp(&lst)) {
+        PUSH_ERROR("Failed to read PayloadListOp data");
+        return false;
+      }
+
+      value->Set(lst);
+      return true;
+    }
+    case crate::CrateDataTypeId::CRATE_DATA_TYPE_REFERENCE_LIST_OP: {
+      ListOp<Reference> lst;
+
+      if (!ReadListOp(&lst)) {
+        PUSH_ERROR("Failed to read ReferenceListOp data");
+        return false;
+      }
+
+      value->Set(lst);
+      return true;
+    }
+    case crate::CrateDataTypeId::CRATE_DATA_TYPE_INT_LIST_OP: {
+      ListOp<int32_t> lst;
+
+      if (!ReadListOp(&lst)) {
+        PUSH_ERROR("Failed to read IntListOp data");
+        return false;
+      }
+
+      value->Set(lst);
+      return true;
+    }
+    case crate::CrateDataTypeId::CRATE_DATA_TYPE_INT64_LIST_OP: {
+      ListOp<int64_t> lst;
+
+      if (!ReadListOp(&lst)) {
+        PUSH_ERROR("Failed to read Int64ListOp data");
+        return false;
+      }
+
+      value->Set(lst);
+      return true;
+    }
+    case crate::CrateDataTypeId::CRATE_DATA_TYPE_UINT_LIST_OP: {
+      ListOp<uint32_t> lst;
+
+      if (!ReadListOp(&lst)) {
+        PUSH_ERROR("Failed to read UIntListOp data");
+        return false;
+      }
+
+      value->Set(lst);
+      return true;
+    }
+    case crate::CrateDataTypeId::CRATE_DATA_TYPE_UINT64_LIST_OP: {
+      ListOp<uint64_t> lst;
+
+      if (!ReadListOp(&lst)) {
+        PUSH_ERROR("Failed to read UInt64ListOp data");
+        return false;
+      }
+
+      value->Set(lst);
+      return true;
+    }
+    case crate::CrateDataTypeId::CRATE_DATA_TYPE_VALUE_BLOCK: {
+      PUSH_ERROR(
+          "ValueBlock must be defined in Inlined ValueRep.");
+      return false;
+    }
+    case crate::CrateDataTypeId::CRATE_DATA_TYPE_VALUE: {
+
+      crate::ValueRep local_rep{0};
+      if (!ReadValueRep(&local_rep)) {
+        PUSH_ERROR(
+            "Failed to read ValueRep for VALUE type.");
+        return false;
+      }
+
+      if (unpackRecursionGuard.size() > _config.maxValueRecursion) {
+        // To many recursive stacks. We report error
+        PUSH_ERROR(
+            "Too many recursion when decoding generic VALUE data.");
+        return false;
+      }
+
+      // TODO: use crate::ValueRep for set container type.
+      if (unpackRecursionGuard.count(local_rep.GetData())) {
+        // Recursion detected.
+        PUSH_ERROR(
+            "Corrupted Value data detected.");
+        return false;
+      } else {
+        crate::CrateValue local_val;
+        bool ret = UnpackValueRep(local_rep, &local_val);
+        if (!ret) {
+          return false;
+        }
+
+        (*value) = local_val;
+
+        unpackRecursionGuard.erase(local_rep.GetData());
+        return true;
+      }
+    }
+    case crate::CrateDataTypeId::CRATE_DATA_TYPE_UNREGISTERED_VALUE: {
+      COMPRESS_UNSUPPORTED_CHECK(dty)
+      ARRAY_UNSUPPORTED_CHECK(dty)
+
+      // 8byte for the offset for recursive value. See RecursiveRead() in
+      // https://github.com/PixarAnimationStudios/USD/blob/release/pxr/usd/usd/crateFile.cpp for details.
+      int64_t local_offset{0};
+      if (!_sr->read8(&local_offset)) {
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read the offset for value in Dictionary.");
+        return false;
+      }
+
+      DCOUT("UnregisteredValue  offset = " << local_offset);
+      DCOUT("tell = " << _sr->tell());
+
+      // -8 to compensate sizeof(offset)
+      if (!_sr->seek_from_current(local_offset - 8)) {
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to seek to UNREGISTERD_VALUE content. Invalid offset value: " +
+                std::to_string(local_offset));
+      }
+
+      uint64_t saved_position = _sr->tell();
+
+      crate::ValueRep local_rep{0};
+      if (!ReadValueRep(&local_rep)) {
+        PUSH_ERROR(
+            "Failed to read ValueRep for UNREGISTERED_VALUE type.");
+        return false;
+      }
+
+      auto local_tyRet = crate::GetCrateDataType(local_rep.GetType());
+      if (!local_tyRet) {
+        PUSH_ERROR(local_tyRet.error());
+        return false;
+      }
+
+      const auto local_dty = local_tyRet.value();
+
+      // Should be STRING or DICTIONARY for UNREGISTERED_VALUE.
+      if (local_dty.dtype_id == crate::CrateDataTypeId::CRATE_DATA_TYPE_STRING) {
+        COMPRESS_UNSUPPORTED_CHECK(local_dty)
+        ARRAY_UNSUPPORTED_CHECK(local_dty)
+
+        if (local_rep.IsInlined()) {
+          uint32_t local_d = (local_rep.GetPayload() & ((1ull << (sizeof(uint32_t) * 8)) - 1));
+          if (auto v = GetStringToken(crate::Index(local_d))) {
+            std::string str = v.value().str();
+
+            DCOUT("UNREGISTERED_VALUE.string = " << str);
+
+            // NOTE: string may contain double-quotes.
+            // We remove it at here, but it'd be better not to do it.
+            std::string unquoted = unwrap(str);
+            value->Set(unquoted);
+
+            if (!_sr->seek_set(saved_position)) {
+              PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to set seek.");
+            }
+            return true;
+          } else {
+            PUSH_ERROR("Failed to decode String.");
+            return false;
+          }
+        } else {
+          PUSH_ERROR("String value must be inlined.");
+          return false;
+        }
+
+      } else if (local_dty.dtype_id == crate::CrateDataTypeId::CRATE_DATA_TYPE_DICTIONARY) {
+        COMPRESS_UNSUPPORTED_CHECK(local_dty)
+        ARRAY_UNSUPPORTED_CHECK(local_dty)
+
+        CustomDataType dict;
+
+        if (local_rep.IsInlined()) {
+          // empty dict
+        }  else{
+          if (!ReadCustomData(&dict)) {
+            _err += "Failed to read Dictionary value\n";
+            return false;
+          }
+        }
+        value->Set(dict);
+        if (!_sr->seek_set(saved_position)) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to set seek.");
+        }
+        return true;
+
+      } else {
+        PUSH_ERROR_AND_RETURN(fmt::format("UNREGISTERD_VALUE type must be string or dictionary, but got other data type: {}(id {}).", GetCrateDataTypeName(local_dty.dtype_id), local_rep.GetType()));
+      }
+
+    }
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_UNREGISTERED_VALUE_LIST_OP:
-    case crate::CrateDataTypeId::CRATE_DATA_TYPE_PAYLOAD_LIST_OP:
     case crate::CrateDataTypeId::CRATE_DATA_TYPE_TIME_CODE: {
       PUSH_ERROR(
           "Invalid data type(or maybe not supported in TinyUSDZ yet) for "
-          "Inlined value: " +
+          "Uninlined value: " +
           crate::GetCrateDataTypeName(dty.dtype_id));
       return false;
     }
   }
 
 #undef TODO_IMPLEMENT
 #undef COMPRESS_UNSUPPORTED_CHECK
@@ -2799,127 +3971,268 @@
   // Never should reach here.
   return false;
 }
 
 bool CrateReader::BuildDecompressedPathsImpl(
     std::vector<uint32_t> const &pathIndexes,
     std::vector<int32_t> const &elementTokenIndexes,
-    std::vector<int32_t> const &jumps, size_t curIndex, Path parentPath) {
+    std::vector<int32_t> const &jumps,
+    std::vector<bool> &visit_table,
+    size_t curIndex, Path parentPath) {
   bool hasChild = false, hasSibling = false;
   do {
     auto thisIndex = curIndex++;
-    if (parentPath.IsEmpty()) {
+    DCOUT("thisIndex = " << thisIndex << ", pathIndexes.size = " << pathIndexes.size());
+    if (parentPath.is_empty()) {
       // root node.
       // Assume single root node in the scene.
       DCOUT("paths[" << pathIndexes[thisIndex]
                      << "] is parent. name = " << parentPath.full_path_name());
-      parentPath = Path::AbsoluteRootPath();
-      _paths[pathIndexes[thisIndex]] = parentPath;
+      parentPath = Path::make_root_path();
+
+      if (thisIndex >= pathIndexes.size()) {
+        PUSH_ERROR("Index exceeds pathIndexes.size()");
+        return false;
+      }
+
+      size_t idx = pathIndexes[thisIndex];
+      if (idx >= _paths.size()) {
+        PUSH_ERROR("Index is out-of-range");
+        return false;
+      }
+
+      if (idx < visit_table.size()) {
+        if (visit_table[idx]) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, "Circular referencing of Path index tree detected. Invalid Paths data.");
+        }
+      }
+
+      _paths[idx] = parentPath;
+      visit_table[idx] = true;
     } else {
-      int32_t tokenIndex = elementTokenIndexes[thisIndex];
-      bool isPrimPropertyPath = tokenIndex < 0;
-      tokenIndex = std::abs(tokenIndex);
+      if (thisIndex >= elementTokenIndexes.size()) {
+        PUSH_ERROR("Index exceeds elementTokenIndexes.size()");
+        return false;
+      }
+      int32_t _tokenIndex = elementTokenIndexes[thisIndex];
+      DCOUT("elementTokenIndex = " << _tokenIndex);
+      bool isPrimPropertyPath = _tokenIndex < 0;
+      // ~0 returns -2147483648, so cast to uint32
+      uint32_t tokenIndex = uint32_t(isPrimPropertyPath ? -_tokenIndex : _tokenIndex);
 
-      DCOUT("tokenIndex = " << tokenIndex);
-      if (tokenIndex >= int32_t(_tokens.size())) {
+      DCOUT("tokenIndex = " << tokenIndex << ", _tokens.size = " << _tokens.size());
+      if (tokenIndex >= _tokens.size()) {
         PUSH_ERROR("Invalid tokenIndex in BuildDecompressedPathsImpl.");
         return false;
       }
       auto const &elemToken = _tokens[size_t(tokenIndex)];
       DCOUT("elemToken = " << elemToken);
       DCOUT("[" << pathIndexes[thisIndex] << "].append = " << elemToken);
 
-      // full path
-      _paths[pathIndexes[thisIndex]] =
+      size_t idx = pathIndexes[thisIndex];
+      if (idx >= _paths.size()) {
+        PUSH_ERROR("Index is out-of-range");
+        return false;
+      }
+
+      if (idx >= _elemPaths.size()) {
+        PUSH_ERROR("Index is out-of-range");
+        return false;
+      }
+
+      if (idx < visit_table.size()) {
+        if (visit_table[idx]) {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, "Circular referencing of Path index tree detected. Invalid Paths data.");
+        }
+      }
+
+      // Reconstruct full path
+      _paths[idx] =
           isPrimPropertyPath ? parentPath.AppendProperty(elemToken.str())
-                             : parentPath.AppendElement(elemToken.str());
+                             : parentPath.AppendElement(elemToken.str()); // prim, variantSelection, etc.
 
-      // also set local path for 'primChildren' check
-      _paths[pathIndexes[thisIndex]].SetLocalPart(elemToken.str());
+      // also set leaf path for 'primChildren' check
+      _elemPaths[idx] = Path(elemToken.str(), "");
+      //_paths[pathIndexes[thisIndex]].SetLocalPart(elemToken.str());
+
+      visit_table[idx] = true;
     }
 
     // If we have either a child or a sibling but not both, then just
     // continue to the neighbor.  If we have both then spawn a task for the
     // sibling and do the child ourself.  We think that our path trees tend
     // to be broader more often than deep.
 
+    if (thisIndex >= jumps.size()) {
+      PUSH_ERROR("Index is out-of-range");
+      return false;
+    }
+
     hasChild = (jumps[thisIndex] > 0) || (jumps[thisIndex] == -1);
     hasSibling = (jumps[thisIndex] >= 0);
+    DCOUT("hasChild = " << hasChild << ", hasSibling = " << hasSibling);
 
     if (hasChild) {
       if (hasSibling) {
         // NOTE(syoyo): This recursive call can be parallelized
         auto siblingIndex = thisIndex + size_t(jumps[thisIndex]);
-        if (!BuildDecompressedPathsImpl(pathIndexes, elementTokenIndexes, jumps,
+        if (!BuildDecompressedPathsImpl(pathIndexes, elementTokenIndexes, jumps, visit_table,
                                         siblingIndex, parentPath)) {
           return false;
         }
       }
+
+      size_t idx = pathIndexes[thisIndex];
+      if (idx >= _paths.size()) {
+        PUSH_ERROR("Index is out-of-range");
+        return false;
+      }
+
       // Have a child (may have also had a sibling). Reset parent path.
-      parentPath = _paths[pathIndexes[thisIndex]];
+      parentPath = _paths[idx];
     }
     // If we had only a sibling, we just continue since the parent path is
     // unchanged and the next thing in the reader stream is the sibling's
     // header.
   } while (hasChild || hasSibling);
 
   return true;
 }
 
-// TODO(syoyo): Refactor
+// TODO(syoyo): Refactor. Code is mostly identical to BuildDecompressedPathsImpl
 bool CrateReader::BuildNodeHierarchy(
     std::vector<uint32_t> const &pathIndexes,
     std::vector<int32_t> const &elementTokenIndexes,
-    std::vector<int32_t> const &jumps, size_t curIndex,
+    std::vector<int32_t> const &jumps,
+    std::vector<bool> &visit_table, /* inout */
+    size_t curIndex,
     int64_t parentNodeIndex) {
   bool hasChild = false, hasSibling = false;
 
   // NOTE: Need to indirectly lookup index through pathIndexes[] when accessing
   // `_nodes`
   do {
     auto thisIndex = curIndex++;
     DCOUT("thisIndex = " << thisIndex << ", curIndex = " << curIndex);
     if (parentNodeIndex == -1) {
       // root node.
       // Assume single root node in the scene.
-      assert(thisIndex == 0);
+      //assert(thisIndex == 0);
+      if (thisIndex != 0) {
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "TODO: Multiple root nodes.");
+      }
 
-      Node root(parentNodeIndex, _paths[pathIndexes[thisIndex]]);
+      if (thisIndex >= pathIndexes.size()) {
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "Index out-of-range.");
+      }
 
-      _nodes[pathIndexes[thisIndex]] = root;
+      size_t pathIdx = pathIndexes[thisIndex];
+      if (pathIdx >= _paths.size()) {
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "PathIndex out-of-range.");
+      }
+
+      if (pathIdx >= _nodes.size()) {
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "PathIndex out-of-range.");
+      }
+
+      if (pathIdx >= visit_table.size()) {
+        // This should not be happan though
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "[InternalError] out-of-range.");
+      }
+
+      if (visit_table[pathIdx]) {
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "Circular referencing detected. Invalid Prim tree representation.");
+      }
+
+      Node root(parentNodeIndex, _paths[pathIdx]);
+
+      _nodes[pathIdx] = root;
+      visit_table[pathIdx] = true;
 
       parentNodeIndex = int64_t(thisIndex);
 
     } else {
       if (parentNodeIndex >= int64_t(_nodes.size())) {
-        return false;
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "Parent Index out-of-range.");
+      }
+
+      if (parentNodeIndex >= int64_t(pathIndexes.size())) {
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "Parent Index out-of-range.");
+      }
+
+      if (thisIndex >= pathIndexes.size()) {
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "Index out-of-range.");
       }
 
       DCOUT("Hierarchy. parent[" << pathIndexes[size_t(parentNodeIndex)]
                                  << "].add_child = " << pathIndexes[thisIndex]);
 
-      Node node(parentNodeIndex, _paths[pathIndexes[thisIndex]]);
+      size_t pathIdx = pathIndexes[thisIndex];
+      if (pathIdx >= _paths.size()) {
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "PathIndex out-of-range.");
+      }
+
+      if (pathIdx >= _nodes.size()) {
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "PathIndex out-of-range.");
+      }
+
+      if (pathIdx >= visit_table.size()) {
+        // This should not be happan though
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "[InternalError] out-of-range.");
+      }
+
+      if (visit_table[pathIdx]) {
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "Circular referencing detected. Invalid Prim tree representation.");
+      }
+
+      Node node(parentNodeIndex, _paths[pathIdx]);
+
+      // Ensure parent is not set yet.
+      if (_nodes[pathIdx].GetParent() != -2) {
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "???: Maybe corrupted path hierarchy?.");
+      }
 
-      assert(_nodes[size_t(pathIndexes[thisIndex])].GetParent() == -2);
+      _nodes[pathIdx] = node;
+      visit_table[pathIdx] = true;
 
-      _nodes[size_t(pathIndexes[thisIndex])] = node;
+      if (pathIdx >= _elemPaths.size()) {
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "PathIndex out-of-range.");
+      }
 
-      std::string name = _paths[pathIndexes[thisIndex]].local_path_name();
+      //std::string name = _paths[pathIndexes[thisIndex]].local_path_name();
+      std::string name = _elemPaths[pathIdx].full_path_name();
       DCOUT("childName = " << name);
-      _nodes[size_t(pathIndexes[size_t(parentNodeIndex)])].AddChildren(
-          name, pathIndexes[thisIndex]);
+
+      size_t parentNodeIdx = size_t(parentNodeIndex);
+      if (parentNodeIdx >= pathIndexes.size()) {
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "ParentNodeIdx out-of-range.");
+      }
+
+      size_t parentPathIdx = pathIndexes[parentNodeIdx];
+      if (parentPathIdx >= _nodes.size()) {
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "PathIndex out-of-range.");
+      }
+
+      if (!_nodes[parentPathIdx].AddChildren(
+          name, pathIdx)) {
+        PUSH_ERROR_AND_RETURN_TAG(kTag, "Invalid path index.");
+      }
+    }
+
+    if (thisIndex >= jumps.size()) {
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Index is out-of-range");
     }
 
     hasChild = (jumps[thisIndex] > 0) || (jumps[thisIndex] == -1);
     hasSibling = (jumps[thisIndex] >= 0);
 
     if (hasChild) {
       if (hasSibling) {
         auto siblingIndex = thisIndex + size_t(jumps[thisIndex]);
-        if (!BuildNodeHierarchy(pathIndexes, elementTokenIndexes, jumps,
+        if (!BuildNodeHierarchy(pathIndexes, elementTokenIndexes, jumps, visit_table,
                                 siblingIndex, parentNodeIndex)) {
           return false;
         }
       }
       // Have a child (may have also had a sibling). Reset parent node index
       parentNodeIndex = int64_t(thisIndex);
       DCOUT("parentNodeIndex = " << parentNodeIndex);
@@ -2928,155 +4241,206 @@
     // unchanged and the next thing in the reader stream is the sibling's
     // header.
   } while (hasChild || hasSibling);
 
   return true;
 }
 
-bool CrateReader::ReadCompressedPaths(const uint64_t ref_num_paths) {
+bool CrateReader::ReadCompressedPaths(const uint64_t maxNumPaths) {
   std::vector<uint32_t> pathIndexes;
   std::vector<int32_t> elementTokenIndexes;
   std::vector<int32_t> jumps;
 
   // Read number of encoded paths.
-  uint64_t numPaths;
-  if (!_sr->read8(&numPaths)) {
-    _err += "Failed to read the number of paths.\n";
+  uint64_t numEncodedPaths;
+  if (!_sr->read8(&numEncodedPaths)) {
+    _err += "Failed to read the number of encoded paths.\n";
     return false;
   }
 
-  if (ref_num_paths != numPaths) {
-    _err += "Size mismatch of numPaths at `PATHS` section.\n";
+  DCOUT("maxNumPaths : " << maxNumPaths);
+  DCOUT("numEncodedPaths : " << numEncodedPaths);
+
+  // Number of compressed paths could be less than maxNumPaths,
+  // but should not be greater.
+  if (maxNumPaths < numEncodedPaths) {
+    _err += "Size mismatch of numEncodedPaths at `PATHS` section.\n";
     return false;
   }
 
-  DCOUT("numPaths : " << numPaths);
 
-  pathIndexes.resize(static_cast<size_t>(numPaths));
-  elementTokenIndexes.resize(static_cast<size_t>(numPaths));
-  jumps.resize(static_cast<size_t>(numPaths));
+  // 3 = pathIndex, elementTokenIndex, jump
+  CHECK_MEMORY_USAGE(size_t(numEncodedPaths) * sizeof(int32_t) * 3);
+
+  pathIndexes.resize(static_cast<size_t>(numEncodedPaths));
+  elementTokenIndexes.resize(static_cast<size_t>(numEncodedPaths));
+  jumps.resize(static_cast<size_t>(numEncodedPaths));
+
+  size_t compBufferSize = Usd_IntegerCompression::GetCompressedBufferSize(static_cast<size_t>(numEncodedPaths));
+  size_t workspaceBufferSize = Usd_IntegerCompression::GetDecompressionWorkingSpaceSize(static_cast<size_t>(numEncodedPaths));
+  CHECK_MEMORY_USAGE(compBufferSize);
+  CHECK_MEMORY_USAGE(workspaceBufferSize);
 
   // Create temporary space for decompressing.
-  std::vector<char> compBuffer(Usd_IntegerCompression::GetCompressedBufferSize(
-      static_cast<size_t>(numPaths)));
-  std::vector<char> workingSpace(
-      Usd_IntegerCompression::GetDecompressionWorkingSpaceSize(
-          static_cast<size_t>(numPaths)));
+  std::vector<char> compBuffer(compBufferSize);
+  std::vector<char> workingSpace(workspaceBufferSize);
 
   // pathIndexes.
   {
-    uint64_t pathIndexesSize;
-    if (!_sr->read8(&pathIndexesSize)) {
+    uint64_t compPathIndexesSize;
+    if (!_sr->read8(&compPathIndexesSize)) {
       _err += "Failed to read pathIndexesSize.\n";
       return false;
     }
 
-    if (pathIndexesSize !=
-        _sr->read(size_t(pathIndexesSize), size_t(pathIndexesSize),
+    if (compPathIndexesSize > compBufferSize) {
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Invalid Compressed PathIndexes size.");
+    }
+
+    CHECK_MEMORY_USAGE(size_t(compPathIndexesSize));
+
+    if (compPathIndexesSize !=
+        _sr->read(size_t(compPathIndexesSize), size_t(compPathIndexesSize),
                   reinterpret_cast<uint8_t *>(compBuffer.data()))) {
-      _err += "Failed to read pathIndexes data.\n";
+      _err += "Failed to read compressed pathIndexes data.\n";
       return false;
     }
 
     DCOUT("comBuffer.size = " << compBuffer.size());
-    DCOUT("pathIndexesSize = " << pathIndexesSize);
+    DCOUT("compPathIndexesSize = " << compPathIndexesSize);
 
     std::string err;
     Usd_IntegerCompression::DecompressFromBuffer(
-        compBuffer.data(), size_t(pathIndexesSize), pathIndexes.data(),
-        size_t(numPaths), &err, workingSpace.data());
+        compBuffer.data(), size_t(compPathIndexesSize), pathIndexes.data(),
+        size_t(numEncodedPaths), &err, workingSpace.data());
     if (!err.empty()) {
       _err += "Failed to decode pathIndexes\n" + err;
       return false;
     }
   }
 
   // elementTokenIndexes.
   {
-    uint64_t elementTokenIndexesSize;
-    if (!_sr->read8(&elementTokenIndexesSize)) {
+    uint64_t compElementTokenIndexesSize;
+    if (!_sr->read8(&compElementTokenIndexesSize)) {
       _err += "Failed to read elementTokenIndexesSize.\n";
       return false;
     }
 
-    if (elementTokenIndexesSize !=
-        _sr->read(size_t(elementTokenIndexesSize),
-                  size_t(elementTokenIndexesSize),
+    if (compElementTokenIndexesSize > compBufferSize) {
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Invalid Compressed elementTokenIndexes size.");
+    }
+
+    CHECK_MEMORY_USAGE(size_t(compElementTokenIndexesSize));
+
+    if (compElementTokenIndexesSize !=
+        _sr->read(size_t(compElementTokenIndexesSize),
+                  size_t(compElementTokenIndexesSize),
                   reinterpret_cast<uint8_t *>(compBuffer.data()))) {
       PUSH_ERROR("Failed to read elementTokenIndexes data.");
       return false;
     }
 
     std::string err;
     Usd_IntegerCompression::DecompressFromBuffer(
-        compBuffer.data(), size_t(elementTokenIndexesSize),
-        elementTokenIndexes.data(), size_t(numPaths), &err,
+        compBuffer.data(), size_t(compElementTokenIndexesSize),
+        elementTokenIndexes.data(), size_t(numEncodedPaths), &err,
         workingSpace.data());
 
     if (!err.empty()) {
       PUSH_ERROR("Failed to decode elementTokenIndexes.");
       return false;
     }
   }
 
   // jumps.
   {
-    uint64_t jumpsSize;
-    if (!_sr->read8(&jumpsSize)) {
-      PUSH_ERROR("Failed to read jumpsSize.");
+    uint64_t compJumpsSize;
+    if (!_sr->read8(&compJumpsSize)) {
+      PUSH_ERROR("Failed to read compressed jumpsSize.");
       return false;
     }
 
-    if (jumpsSize !=
-        _sr->read(size_t(jumpsSize), size_t(jumpsSize),
+    if (compJumpsSize > compBufferSize) {
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Invalid Compressed elementTokenIndexes size.");
+    }
+
+    CHECK_MEMORY_USAGE(size_t(compJumpsSize));
+
+    if (compJumpsSize !=
+        _sr->read(size_t(compJumpsSize), size_t(compJumpsSize),
                   reinterpret_cast<uint8_t *>(compBuffer.data()))) {
-      PUSH_ERROR("Failed to read jumps data.");
+      PUSH_ERROR("Failed to read compressed jumps data.");
       return false;
     }
 
     std::string err;
     Usd_IntegerCompression::DecompressFromBuffer(
-        compBuffer.data(), size_t(jumpsSize), jumps.data(), size_t(numPaths),
+        compBuffer.data(), size_t(compJumpsSize), jumps.data(), size_t(numEncodedPaths),
         &err, workingSpace.data());
 
     if (!err.empty()) {
       PUSH_ERROR("Failed to decode jumps.");
       return false;
     }
   }
 
-  _paths.resize(static_cast<size_t>(numPaths));
+#ifdef TINYUSDZ_LOCAL_DEBUG_PRINT
+  for (size_t i = 0; i < pathIndexes.size(); i++) {
+    DCOUT("pathIndexes[" << i << "] = " << pathIndexes[i]);
+  }
+
+  for (size_t i = 0; i < elementTokenIndexes.size(); i++) {
+    std::stringstream ss;
+    ss << "elementTokenIndexes[" << i << "] = " << elementTokenIndexes[i];
+    int32_t tokIdx = elementTokenIndexes[i];
+    if (tokIdx < 0) {
+      // Property Path. Need to negate it.
+      tokIdx = -tokIdx;
+    }
+    if (auto tokv = GetToken(crate::Index(uint32_t(tokIdx)))) {
+      ss << "(" << tokv.value() << ")";
+    }
+    ss << "\n";
+    DCOUT(ss.str());
+  }
 
-  _nodes.resize(static_cast<size_t>(numPaths));
+  for (size_t i = 0; i < jumps.size(); i++) {
+    DCOUT(fmt::format("jumps[{}] = {}", i, jumps[i]));
+  }
+#endif
+
+  // For circular tree check
+  std::vector<bool> visit_table;
+  CHECK_MEMORY_USAGE(_paths.size()); // TODO: divide by 8?
+
+  // `_paths` is already initialized just before calling this ReadCompressedPaths
+  visit_table.resize(_paths.size());
+  for (size_t i = 0; i < visit_table.size(); i++) {
+    visit_table[i] = false;
+  }
 
   // Now build the paths.
-  if (!BuildDecompressedPathsImpl(pathIndexes, elementTokenIndexes, jumps,
+  if (!BuildDecompressedPathsImpl(pathIndexes, elementTokenIndexes, jumps, visit_table,
                                   /* curIndex */ 0, Path())) {
     return false;
   }
 
   // Now build node hierarchy.
-  if (!BuildNodeHierarchy(pathIndexes, elementTokenIndexes, jumps,
-                          /* curIndex */ 0, /* parent node index */ -1)) {
-    return false;
-  }
 
-#ifdef TINYUSDZ_LOCAL_DEBUG_PRINT
-  for (size_t i = 0; i < pathIndexes.size(); i++) {
-    std::cout << "pathIndexes[" << i << "] = " << pathIndexes[i] << "\n";
+  // Circular referencing check should be done in BuildDecompressedPathsImpl,
+  // but do check it again just in case.
+  for (size_t i = 0; i < visit_table.size(); i++) {
+    visit_table[i] = false;
   }
-
-  for (auto item : elementTokenIndexes) {
-    std::cout << "elementTokenIndexes " << item << "\n";
+  if (!BuildNodeHierarchy(pathIndexes, elementTokenIndexes, jumps, visit_table,
+                          /* curIndex */ 0, /* parent node index */ -1)) {
+    return false;
   }
 
-  for (auto item : jumps) {
-    std::cout << "jumps " << item << "\n";
-  }
-#endif
 
   return true;
 }
 
 bool CrateReader::ReadSection(crate::Section *s) {
   size_t name_len = crate::kSectionNameMaxLength + 1;
 
@@ -3087,91 +4451,152 @@
   }
 
   if (!_sr->read8(&s->start)) {
     _err += "Failed to read section.start.\n";
     return false;
   }
 
+  if (size_t(s->start) > _sr->size()) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Section start offset exceeds USDC file size.");
+  }
+
   if (!_sr->read8(&s->size)) {
     _err += "Failed to read section.size.\n";
     return false;
   }
 
+  if (size_t(s->start + s->size) > _sr->size()) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Section end offset exceeds USDC file size.");
+  }
+
+
   return true;
 }
 
 bool CrateReader::ReadTokens() {
   if ((_tokens_index < 0) || (_tokens_index >= int64_t(_toc.sections.size()))) {
-    _err += "Invalid index for `TOKENS` section.\n";
-    return false;
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Invalid index for `TOKENS` section.");
   }
 
   if ((_version[0] == 0) && (_version[1] < 4)) {
-    _err += "Version must be 0.4.0 or later, but got " +
-            std::to_string(_version[0]) + "." + std::to_string(_version[1]) +
-            "." + std::to_string(_version[2]) + "\n";
-    return false;
+    PUSH_ERROR_AND_RETURN_TAG(kTag, fmt::format("Version must be 0.4.0 or later, but got {}.{}.{}",
+      _version[0], _version[1], _version[2]));
   }
 
   const crate::Section &sec = _toc.sections[size_t(_tokens_index)];
   if (!_sr->seek_set(uint64_t(sec.start))) {
-    _err += "Failed to move to `TOKENS` section.\n";
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to move to `TOKENS` section.");
     return false;
   }
 
+  if (sec.size < 4) {
+     PUSH_ERROR_AND_RETURN_TAG(kTag, fmt::format("`TOKENS` section data size is zero or too small."));
+  }
+
   DCOUT("sec.start = " << sec.start);
+  DCOUT("sec.size = " << sec.size);
 
   // # of tokens.
-  uint64_t n;
-  if (!_sr->read8(&n)) {
-    _err += "Failed to read # of tokens at `TOKENS` section.\n";
-    return false;
+  uint64_t num_tokens;
+  if (!_sr->read8(&num_tokens)) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read # of tokens at `TOKENS` section.");
+  }
+
+  DCOUT("# of tokens = " << num_tokens);
+
+  if (num_tokens == 0) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Empty tokens.");
+  }
+
+  if (num_tokens > _config.maxNumTokens) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Too many Tokens.");
   }
 
   // Tokens are lz4 compressed starting from version 0.4.0
 
   // Compressed token data.
   uint64_t uncompressedSize;
   if (!_sr->read8(&uncompressedSize)) {
-    _err += "Failed to read uncompressedSize at `TOKENS` section.\n";
-    return false;
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read uncompressedSize at `TOKENS` section.");
+  }
+
+  DCOUT("uncompressedSize = " << uncompressedSize);
+
+
+  // Must be larger than len(';-)') + all empty string case.
+  // 3 = ';-)'
+  // num_tokens = '\0' delimiter
+  if ((3 + num_tokens) > uncompressedSize) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "`TOKENS` section corrupted.");
+  }
+
+  // At least min size should be 16 both for compress and uncompress.
+  if (uncompressedSize < 4) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "uncompressedSize too small or zero bytes.");
+  }
+
+  // TODO uncompressdSize check.
+  if (uncompressedSize > _sr->size()) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "uncompressedSize exceeds input USDC size.");
   }
 
   uint64_t compressedSize;
   if (!_sr->read8(&compressedSize)) {
-    _err += "Failed to read compressedSize at `TOKENS` section.\n";
-    return false;
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read compressedSize at `TOKENS` section.");
   }
 
-  DCOUT("# of tokens = " << n << ", uncompressedSize = " << uncompressedSize
-                         << ", compressedSize = " << compressedSize);
+  DCOUT("compressedSize = " << compressedSize);
+
+  if (compressedSize < 4) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "compressedSize is too small or zero bytes.");
+  }
 
+  if (compressedSize > _sr->size()) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Compressed data size exceeds input file size.");
+  }
+
+  if (size_t(compressedSize) > size_t(sec.size)) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Compressed data size exceeds `TOKENS` section size.");
+  }
+
+  // To combat with heap-buffer flow in lz4 cuased by corrupted lz4 compressed data,
+  // We allocate same size of uncompressedSize(or larger one),
+  // And further, extra 128 bytes for safety(LZ4_FAST_DEC_LOOP does 16 bytes stride memcpy)
+
+  uint64_t bufSize = (std::max)(compressedSize, uncompressedSize);
+  CHECK_MEMORY_USAGE(bufSize+128);
+  CHECK_MEMORY_USAGE(uncompressedSize);
+
+
+  // dst
   std::vector<char> chars(static_cast<size_t>(uncompressedSize));
-  std::vector<char> compressed(static_cast<size_t>(compressedSize));
+  memset(chars.data(), 0, chars.size());
+
+  std::vector<char> compressed(static_cast<size_t>(bufSize + 128));
+  memset(compressed.data(), 0, compressed.size());
 
   if (compressedSize !=
       _sr->read(size_t(compressedSize), size_t(compressedSize),
                 reinterpret_cast<uint8_t *>(compressed.data()))) {
-    _err += "Failed to read compressed data at `TOKENS` section.\n";
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read compressed data at `TOKENS` section.");
     return false;
   }
 
   if (uncompressedSize !=
       LZ4Compression::DecompressFromBuffer(compressed.data(), chars.data(),
                                            size_t(compressedSize),
                                            size_t(uncompressedSize), &_err)) {
-    _err += "Failed to decompress data of Tokens.\n";
-    return false;
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to decompress data of Tokens.");
   }
 
   // Split null terminated string into _tokens.
   const char *ps = chars.data();
   const char *pe = chars.data() + chars.size();
-  const char *p = ps;
-  size_t n_remain = size_t(n);
+  const char *pcurr = ps;
+  size_t nbytes_remain = size_t(chars.size());
 
   auto my_strnlen = [](const char *s, const size_t max_length) -> size_t {
     if (!s) return 0;
 
     size_t i = 0;
     for (; i < max_length; i++) {
       if (s[i] == '\0') {
@@ -3181,59 +4606,79 @@
 
     // null character not found.
     return i;
   };
 
   // TODO(syoyo): Check if input string has exactly `n` tokens(`n` null
   // characters)
-  for (size_t i = 0; i < n; i++) {
-    size_t len = my_strnlen(p, n_remain);
+  for (size_t i = 0; i < num_tokens; i++) {
+    DCOUT("n_remain = " << nbytes_remain);
+
+    size_t len = my_strnlen(pcurr, nbytes_remain);
+    DCOUT("len = " << len);
 
-    if ((p + len) > pe) {
+    if ((pcurr + (len+1)) > pe) {
       _err += "Invalid token string array.\n";
       return false;
     }
 
     std::string str;
     if (len > 0) {
-      str = std::string(p, len);
+      str = std::string(pcurr, len);
+    } else {
+      // Empty string allowed
+      str = std::string();
     }
 
-    p += len + 1;  // +1 = '\0'
-    n_remain = size_t(pe - p);
-    assert(p <= pe);
-    if (p > pe) {
+    pcurr += len + 1;  // +1 = '\0'
+    nbytes_remain = size_t(pe - pcurr);
+    if (pcurr > pe) {
       _err += "Invalid token string array.\n";
       return false;
     }
 
     value::token tok(str);
 
     DCOUT("token[" << i << "] = " << tok);
     _tokens.push_back(tok);
+
+    if (nbytes_remain == 0) {
+      // reached to the string buffer end.
+      break;
+    }
+  }
+
+  if (_tokens.size() != num_tokens) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, fmt::format("The number of tokens parsed {} does not match the requested one {}", _tokens.size(), num_tokens));
   }
 
   return true;
 }
 
 bool CrateReader::ReadStrings() {
   if ((_strings_index < 0) ||
       (_strings_index >= int64_t(_toc.sections.size()))) {
     _err += "Invalid index for `STRINGS` section.\n";
     return false;
   }
 
   const crate::Section &s = _toc.sections[size_t(_strings_index)];
 
+  if (s.size == 0) {
+    // empty `STRINGS`?
+    return true;
+  }
+
   if (!_sr->seek_set(uint64_t(s.start))) {
     _err += "Failed to move to `STRINGS` section.\n";
     return false;
   }
 
-  if (!ReadIndices(_sr, &_string_indices)) {
+  // `STRINGS` are not compressed.
+  if (!ReadIndices(&_string_indices)) {
     _err += "Failed to read StringIndex array.\n";
     return false;
   }
 
   for (size_t i = 0; i < _string_indices.size(); i++) {
     DCOUT("StringIndex[" << i << "] = " << _string_indices[i].value);
   }
@@ -3252,99 +4697,118 @@
             std::to_string(_version[0]) + "." + std::to_string(_version[1]) +
             "." + std::to_string(_version[2]) + "\n";
     return false;
   }
 
   const crate::Section &s = _toc.sections[size_t(_fields_index)];
 
+  if (s.size == 0) {
+    // accepts Empty FIELDS size.
+    return true;
+  }
+
   if (!_sr->seek_set(uint64_t(s.start))) {
     _err += "Failed to move to `FIELDS` section.\n";
     return false;
   }
 
   uint64_t num_fields;
   if (!_sr->read8(&num_fields)) {
     _err += "Failed to read # of fields at `FIELDS` section.\n";
     return false;
   }
 
-  _fields.resize(static_cast<size_t>(num_fields));
+  DCOUT("num_fields = " << num_fields);
 
-  // indices
-  {
-    std::vector<char> comp_buffer(
-        Usd_IntegerCompression::GetCompressedBufferSize(
-            static_cast<size_t>(num_fields)));
-    // temp buffer for decompress
-    std::vector<uint32_t> tmp;
-    tmp.resize(static_cast<size_t>(num_fields));
+  if (num_fields == 0) {
+    // Fields may be empty, so OK
+    return true;
+  }
 
-    uint64_t fields_size;
-    if (!_sr->read8(&fields_size)) {
-      _err += "Failed to read field legnth at `FIELDS` section.\n";
-      return false;
-    }
+  if (num_fields > _config.maxNumFields) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Too many fields in `FIELDS` section.");
+  }
 
-    if (fields_size !=
-        _sr->read(size_t(fields_size), size_t(fields_size),
-                  reinterpret_cast<uint8_t *>(comp_buffer.data()))) {
-      _err += "Failed to read field data at `FIELDS` section.\n";
-      return false;
+  if (sizeof(void *) == 4) {
+    // 32bit
+    if (num_fields > std::numeric_limits<int32_t>::max() / sizeof(uint32_t)) {
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Too many fields in `FIELDS` section.");
     }
+  }
 
-    std::string err;
-    DCOUT("fields_size = " << fields_size << ", tmp.size = " << tmp.size()
-                           << ", num_fields = " << num_fields);
-    Usd_IntegerCompression::DecompressFromBuffer(
-        comp_buffer.data(), size_t(fields_size), tmp.data(), size_t(num_fields),
-        &err);
+  CHECK_MEMORY_USAGE(size_t(num_fields) * sizeof(Field));
 
-    if (!err.empty()) {
-      _err += err;
-      return false;
+  _fields.resize(static_cast<size_t>(num_fields));
+
+  // indices
+  {
+
+    CHECK_MEMORY_USAGE(size_t(num_fields) * sizeof(uint32_t));
+
+    std::vector<uint32_t> tmp;
+    tmp.resize(size_t(num_fields));
+    if (!ReadCompressedInts(tmp.data(), size_t(num_fields))) {
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read Field token_index array.");
     }
 
     for (size_t i = 0; i < num_fields; i++) {
       _fields[i].token_index.value = tmp[i];
     }
+
+    REDUCE_MEMORY_USAGE(size_t(num_fields) * sizeof(uint32_t));
+
   }
 
-  // Value reps
+  // Value reps(LZ4 compressed)
   {
-    uint64_t reps_size;
+    uint64_t reps_size; // compressed size
     if (!_sr->read8(&reps_size)) {
-      _err += "Failed to read reps legnth at `FIELDS` section.\n";
-      return false;
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read value reps legnth at `FIELDS` section.");
     }
 
+    if (reps_size > size_t(s.size)) {
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Invalid byte size of Value reps data.");
+    }
+
+    if (reps_size > _sr->size()) {
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Compressed Value reps size exceeds USDC data.");
+    }
+
+    CHECK_MEMORY_USAGE(size_t(reps_size));
+
+    // TODO: Decompress from _sr directly.
     std::vector<char> comp_buffer(static_cast<size_t>(reps_size));
 
     if (reps_size !=
         _sr->read(size_t(reps_size), size_t(reps_size),
                   reinterpret_cast<uint8_t *>(comp_buffer.data()))) {
-      _err += "Failed to read reps data at `FIELDS` section.\n";
-      return false;
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read reps data at `FIELDS` section.");
     }
 
     // reps datasize = LZ4 compressed. uncompressed size = num_fields * 8 bytes
+    size_t uncompressed_size = size_t(num_fields) * sizeof(uint64_t);
+    CHECK_MEMORY_USAGE(uncompressed_size);
+
     std::vector<uint64_t> reps_data;
     reps_data.resize(static_cast<size_t>(num_fields));
 
-    size_t uncompressed_size = size_t(num_fields) * sizeof(uint64_t);
 
     if (uncompressed_size != LZ4Compression::DecompressFromBuffer(
                                  comp_buffer.data(),
                                  reinterpret_cast<char *>(reps_data.data()),
                                  size_t(reps_size), uncompressed_size, &_err)) {
-      return false;
+      PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read Fields ValueRep data.");
     }
 
     for (size_t i = 0; i < num_fields; i++) {
       _fields[i].value_rep = crate::ValueRep(reps_data[i]);
     }
+
+    REDUCE_MEMORY_USAGE(uncompressed_size);
+    REDUCE_MEMORY_USAGE(size_t(reps_size)); // comp_buffer
   }
 
   DCOUT("num_fields = " << num_fields);
   for (size_t i = 0; i < num_fields; i++) {
     if (auto tokv = GetToken(_fields[i].token_index)) {
       DCOUT("field[" << i << "] name = " << tokv.value()
                      << ", value = " << _fields[i].value_rep.GetStringRepr());
@@ -3377,41 +4841,69 @@
 
   uint64_t num_fieldsets;
   if (!_sr->read8(&num_fieldsets)) {
     _err += "Failed to read # of fieldsets at `FIELDSETS` section.\n";
     return false;
   }
 
+  if (num_fieldsets == 0) {
+    // At least 1 FieldIndex(separator(~0)) must exist.
+    PUSH_ERROR("`FIELDSETS` is empty.");
+    return false;
+  }
+
+  if (num_fieldsets > _config.maxNumFieldSets) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Too many FieldSets");
+  }
+
+  CHECK_MEMORY_USAGE(size_t(num_fieldsets) * sizeof(uint32_t));
+
   _fieldset_indices.resize(static_cast<size_t>(num_fieldsets));
 
   // Create temporary space for decompressing.
-  std::vector<char> comp_buffer(Usd_IntegerCompression::GetCompressedBufferSize(
-      static_cast<size_t>(num_fieldsets)));
+  size_t compBufferSize = Usd_IntegerCompression::GetCompressedBufferSize(
+      static_cast<size_t>(num_fieldsets));
+
+  CHECK_MEMORY_USAGE(compBufferSize);
+
+  std::vector<char> comp_buffer;
+  comp_buffer.resize(compBufferSize);
+
+  CHECK_MEMORY_USAGE(sizeof(uint32_t) * size_t(num_fieldsets));
+  std::vector<uint32_t> tmp;
+  tmp.resize(static_cast<size_t>(num_fieldsets));
+
+  size_t workBufferSize = Usd_IntegerCompression::GetDecompressionWorkingSpaceSize(
+          static_cast<size_t>(num_fieldsets));
 
-  std::vector<uint32_t> tmp(static_cast<size_t>(num_fieldsets));
-  std::vector<char> working_space(
-      Usd_IntegerCompression::GetDecompressionWorkingSpaceSize(
-          static_cast<size_t>(num_fieldsets)));
+  CHECK_MEMORY_USAGE(workBufferSize);
+  std::vector<char> working_space;
+  working_space.resize(workBufferSize);
 
   uint64_t fsets_size;
   if (!_sr->read8(&fsets_size)) {
-    _err += "Failed to read fieldsets size at `FIELDSETS` section.\n";
-    return false;
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read fieldsets size at `FIELDSETS` section.");
   }
 
   DCOUT("num_fieldsets = " << num_fieldsets << ", fsets_size = " << fsets_size
                            << ", comp_buffer.size = " << comp_buffer.size());
 
-  assert(fsets_size < comp_buffer.size());
+  if (fsets_size > comp_buffer.size()) {
+    // Maybe corrupted?
+    fsets_size = comp_buffer.size();
+  }
+
+  if (fsets_size > _sr->size()) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "FieldSets compressed data exceeds USDC data.");
+  }
 
   if (fsets_size !=
       _sr->read(size_t(fsets_size), size_t(fsets_size),
                 reinterpret_cast<uint8_t *>(comp_buffer.data()))) {
-    _err += "Failed to read fieldsets data at `FIELDSETS` section.\n";
-    return false;
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Failed to read fieldsets data at `FIELDSETS` section.");
   }
 
   std::string err;
   Usd_IntegerCompression::DecompressFromBuffer(
       comp_buffer.data(), size_t(fsets_size), tmp.data(), size_t(num_fieldsets),
       &err, working_space.data());
 
@@ -3421,14 +4913,17 @@
   }
 
   for (size_t i = 0; i != num_fieldsets; ++i) {
     DCOUT("fieldset_index[" << i << "] = " << tmp[i]);
     _fieldset_indices[i].value = tmp[i];
   }
 
+  REDUCE_MEMORY_USAGE(workBufferSize);
+  REDUCE_MEMORY_USAGE(compBufferSize);
+
   return true;
 }
 
 bool CrateReader::BuildLiveFieldSets() {
   for (auto fsBegin = _fieldset_indices.begin(),
             fsEnd = std::find(fsBegin, _fieldset_indices.end(), crate::Index());
        fsBegin != _fieldset_indices.end();
@@ -3505,36 +5000,65 @@
 
   uint64_t num_specs;
   if (!_sr->read8(&num_specs)) {
     PUSH_ERROR("Failed to read # of specs size at `SPECS` section.");
     return false;
   }
 
+  if (num_specs > _config.maxNumSpecifiers) {
+    PUSH_ERROR("Too many specs in `SPECS` section.");
+    return false;
+  }
+
+  if (num_specs == 0) {
+    // At least 1 Spec(Root Prim '/') must exist.
+    PUSH_ERROR("`SPECS` is empty.");
+    return false;
+  }
+
   DCOUT("num_specs " << num_specs);
 
+  CHECK_MEMORY_USAGE(size_t(num_specs) * sizeof(Spec));
+
   _specs.resize(static_cast<size_t>(num_specs));
 
+  // TODO: Memory size check
+
   // Create temporary space for decompressing.
-  std::vector<char> comp_buffer(Usd_IntegerCompression::GetCompressedBufferSize(
-      static_cast<size_t>(num_specs)));
+  size_t compBufferSize= Usd_IntegerCompression::GetCompressedBufferSize(
+      static_cast<size_t>(num_specs));
+
+  CHECK_MEMORY_USAGE(compBufferSize);
+
+  std::vector<char> comp_buffer;
+  comp_buffer.resize(compBufferSize);
+
+  CHECK_MEMORY_USAGE(size_t(num_specs) * sizeof(uint32_t)); // tmp
 
   std::vector<uint32_t> tmp(static_cast<size_t>(num_specs));
-  std::vector<char> working_space(
-      Usd_IntegerCompression::GetDecompressionWorkingSpaceSize(
-          static_cast<size_t>(num_specs)));
+
+  size_t workBufferSize= Usd_IntegerCompression::GetDecompressionWorkingSpaceSize(
+          static_cast<size_t>(num_specs));
+
+  CHECK_MEMORY_USAGE(workBufferSize);
+  std::vector<char> working_space;
+  working_space.resize(workBufferSize);
 
   // path indices
   {
     uint64_t path_indexes_size;
     if (!_sr->read8(&path_indexes_size)) {
       PUSH_ERROR("Failed to read path indexes size at `SPECS` section.");
       return false;
     }
 
-    assert(path_indexes_size < comp_buffer.size());
+    if (path_indexes_size > comp_buffer.size()) {
+      // Maybe corrupted?
+      path_indexes_size = comp_buffer.size();
+    }
 
     if (path_indexes_size !=
         _sr->read(size_t(path_indexes_size), size_t(path_indexes_size),
                   reinterpret_cast<uint8_t *>(comp_buffer.data()))) {
       PUSH_ERROR("Failed to read path indexes data at `SPECS` section.");
       return false;
     }
@@ -3557,15 +5081,18 @@
   {
     uint64_t fset_indexes_size;
     if (!_sr->read8(&fset_indexes_size)) {
       PUSH_ERROR("Failed to read fieldset indexes size at `SPECS` section.");
       return false;
     }
 
-    assert(fset_indexes_size < comp_buffer.size());
+    if (fset_indexes_size > comp_buffer.size()) {
+      // Maybe corrupted?
+      fset_indexes_size = comp_buffer.size();
+    }
 
     if (fset_indexes_size !=
         _sr->read(size_t(fset_indexes_size), size_t(fset_indexes_size),
                   reinterpret_cast<uint8_t *>(comp_buffer.data()))) {
       PUSH_ERROR("Failed to read fieldset indexes data at `SPECS` section.");
       return false;
     }
@@ -3588,15 +5115,18 @@
   {
     uint64_t spectype_size;
     if (!_sr->read8(&spectype_size)) {
       PUSH_ERROR("Failed to read spectype size at `SPECS` section.");
       return false;
     }
 
-    assert(spectype_size < comp_buffer.size());
+    if (spectype_size > comp_buffer.size()) {
+      // Maybe corrupted?
+      spectype_size = comp_buffer.size();
+    }
 
     if (spectype_size !=
         _sr->read(size_t(spectype_size), size_t(spectype_size),
                   reinterpret_cast<uint8_t *>(comp_buffer.data()))) {
       PUSH_ERROR("Failed to read spectype data at `SPECS` section.");
       return false;
     }
@@ -3623,14 +5153,18 @@
                   << tinyusdz::to_string(_specs[i].spec_type));
     if (auto specstr = GetSpecString(crate::Index(uint32_t(i)))) {
       DCOUT("spec[" << i << "] string_repr = " << specstr.value());
     }
   }
 #endif
 
+  REDUCE_MEMORY_USAGE(compBufferSize);
+  REDUCE_MEMORY_USAGE(workBufferSize);
+  REDUCE_MEMORY_USAGE(size_t(num_specs) * sizeof(uint32_t)); // tmp
+
   return true;
 }
 
 bool CrateReader::ReadPaths() {
   if ((_paths_index < 0) || (_paths_index >= int64_t(_toc.sections.size()))) {
     PUSH_ERROR("Invalid index for `PATHS` section.");
     return false;
@@ -3652,24 +5186,41 @@
 
   uint64_t num_paths;
   if (!_sr->read8(&num_paths)) {
     PUSH_ERROR("Failed to read # of paths at `PATHS` section.");
     return false;
   }
 
+  if (num_paths == 0) {
+    // At least root path exits.
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "`PATHS` is empty.");
+  }
+
+  if (num_paths > _config.maxNumPaths) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "Too many Paths in `PATHS` section.");
+  }
+
+  CHECK_MEMORY_USAGE(size_t(num_paths) * sizeof(Path)); // conservative estimation
+  CHECK_MEMORY_USAGE(size_t(num_paths) * sizeof(Path)); // conservative estimation
+  CHECK_MEMORY_USAGE(size_t(num_paths) * sizeof(Node)); // conservative estimation
+
+  _paths.resize(static_cast<size_t>(num_paths));
+  _elemPaths.resize(static_cast<size_t>(num_paths));
+  _nodes.resize(static_cast<size_t>(num_paths));
+
   if (!ReadCompressedPaths(num_paths)) {
     PUSH_ERROR("Failed to read compressed paths.");
     return false;
   }
 
 #ifdef TINYUSDZ_LOCAL_DEBUG_PRINT
-  std::cout << "# of paths " << _paths.size() << "\n";
+  DCOUT("# of paths " << _paths.size());
 
   for (size_t i = 0; i < _paths.size(); i++) {
-    std::cout << "path[" << i << "] = " << _paths[i].full_path_name() << "\n";
+    DCOUT("path[" << i << "] = " << _paths[i].full_path_name());
   }
 #endif
 
   return true;
 }
 
 bool CrateReader::ReadBootStrap() {
@@ -3704,14 +5255,22 @@
   if ((version[0] == 0) && (version[1] < 4)) {
     PUSH_ERROR("Version must be 0.4.0 or later, but got " +
                std::to_string(version[0]) + "." + std::to_string(version[1]) +
                "." + std::to_string(version[2]));
     return false;
   }
 
+  // Currently up to 0.9.0
+  if ((version[0] == 0) && (version[1] < 10)) {
+    // ok
+  } else {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, fmt::format("Unsupported version {}.{}.{}. TinyUSDZ supports version up to 0.9.0",
+      _version[0], _version[1], _version[2]));
+  }
+
   _toc_offset = 0;
   if (!_sr->read8(&_toc_offset)) {
     PUSH_ERROR("Failed to read TOC offset.");
     return false;
   }
 
   if ((_toc_offset <= 88) || (_toc_offset >= int64_t(_sr->size()))) {
@@ -3722,14 +5281,17 @@
 
   DCOUT("toc offset = " << _toc_offset);
 
   return true;
 }
 
 bool CrateReader::ReadTOC() {
+
+  DCOUT(fmt::format("Memory budget: {} bytes", _config.maxMemoryBudget));
+
   if ((_toc_offset <= 88) || (_toc_offset >= int64_t(_sr->size()))) {
     PUSH_ERROR("Invalid toc offset.");
     return false;
   }
 
   if (!_sr->seek_set(uint64_t(_toc_offset))) {
     PUSH_ERROR("Failed to move to TOC offset.");
@@ -3738,29 +5300,61 @@
 
   // read # of sections.
   uint64_t num_sections{0};
   if (!_sr->read8(&num_sections)) {
     PUSH_ERROR("Failed to read TOC(# of sections).");
     return false;
   }
+  if (num_sections >= _config.maxTOCSections) {
+    PUSH_ERROR_AND_RETURN_TAG(kTag, "# of sections are too large.");
+  }
 
   DCOUT("toc sections = " << num_sections);
 
   _toc.sections.resize(static_cast<size_t>(num_sections));
 
+  CHECK_MEMORY_USAGE(num_sections * sizeof(Section));
+
   for (size_t i = 0; i < num_sections; i++) {
     if (!ReadSection(&_toc.sections[i])) {
       PUSH_ERROR("Failed to read TOC section at " + std::to_string(i));
       return false;
     }
     DCOUT("section[" << i << "] name = " << _toc.sections[i].name
                      << ", start = " << _toc.sections[i].start
                      << ", size = " << _toc.sections[i].size);
 
-    // find index
+    if (_toc.sections[i].start < 0) {
+      PUSH_ERROR_AND_RETURN_TAG(kTag, fmt::format("Invalid section start byte offset."));
+    }
+
+    if (_toc.sections[i].size <= 0) {
+      PUSH_ERROR_AND_RETURN_TAG(kTag, fmt::format("Invalid or empty section size."));
+    }
+
+    if (size_t(_toc.sections[i].size) > _sr->size()) {
+      PUSH_ERROR_AND_RETURN_TAG(kTag, fmt::format("Section size exceeds input USDC data size."));
+    }
+
+    if (size_t(_toc.sections[i].start) > _sr->size()) {
+      PUSH_ERROR_AND_RETURN_TAG(kTag, fmt::format("Section start byte offset exceeds input USDC data size."));
+    }
+
+    // TODO: handle integer overflow.
+    size_t end_offset = size_t(_toc.sections[i].start + _toc.sections[i].size);
+    if (sizeof(void *) == 4) { // 32bit
+      if (end_offset > std::numeric_limits<int32_t>::max()) {
+        PUSH_ERROR_AND_RETURN_TAG(kTag, fmt::format("Section end offset exceeds 32bit max."));
+      }
+    }
+    if (end_offset > _sr->size()) {
+      PUSH_ERROR_AND_RETURN_TAG(kTag, fmt::format("Section byte offset + size exceeds input USDC data size."));
+    }
+
+
     if (0 == strncmp(_toc.sections[i].name, "TOKENS",
                      crate::kSectionNameMaxLength)) {
       _tokens_index = int64_t(i);
     } else if (0 == strncmp(_toc.sections[i].name, "STRINGS",
                             crate::kSectionNameMaxLength)) {
       _strings_index = int64_t(i);
     } else if (0 == strncmp(_toc.sections[i].name, "FIELDS",
@@ -3774,25 +5368,26 @@
       _specs_index = int64_t(i);
     } else if (0 == strncmp(_toc.sections[i].name, "PATHS",
                             crate::kSectionNameMaxLength)) {
       _paths_index = int64_t(i);
     }
   }
 
+  DCOUT("TOC read success");
   return true;
 }
 
 ///
 /// Find if a field with (`name`, `tyname`) exists in FieldValuePairVector.
 ///
 bool CrateReader::HasFieldValuePair(const FieldValuePairVector &fvs,
                                     const std::string &name,
                                     const std::string &tyname) {
   for (const auto &fv : fvs) {
-    if ((fv.first == name) && (fv.second.GetTypeName() == tyname)) {
+    if ((fv.first == name) && (fv.second.type_name() == tyname)) {
       return true;
     }
   }
 
   return false;
 }
 
@@ -3807,240 +5402,38 @@
       return true;
     }
   }
 
   return false;
 }
 
-nonstd::expected<CrateReader::FieldValuePair, std::string>
+nonstd::expected<FieldValuePair, std::string>
 CrateReader::GetFieldValuePair(const FieldValuePairVector &fvs,
                                const std::string &name,
                                const std::string &tyname) {
   for (const auto &fv : fvs) {
-    if ((fv.first == name) && (fv.second.GetTypeName() == tyname)) {
+    if ((fv.first == name) && (fv.second.type_name() == tyname)) {
       return fv;
     }
   }
 
   return nonstd::make_unexpected("FieldValuePair not found with name: `" +
                                  name + "` and specified type: `" + tyname +
                                  "`");
 }
 
-nonstd::expected<CrateReader::FieldValuePair, std::string>
+nonstd::expected<FieldValuePair, std::string>
 CrateReader::GetFieldValuePair(const FieldValuePairVector &fvs,
                                const std::string &name) {
   for (const auto &fv : fvs) {
     if (fv.first == name) {
       return fv;
     }
   }
 
   return nonstd::make_unexpected("FieldValuePair not found with name: `" +
                                  name + "`");
 }
 
-bool CrateReader::ParseAttribute(const FieldValuePairVector &fvs,
-                                 PrimAttrib *attr,
-                                 const std::string &prop_name) {
-  bool success = false;
-
-  DCOUT("fvs.size = " << fvs.size());
-
-  bool has_connection{false};
-
-  Variability variability{Variability::Varying};
-  Interpolation interpolation{Interpolation::Invalid};
-
-  // Check if required field exists.
-  if (!HasFieldValuePair(fvs, kTypeName, kToken)) {
-    PUSH_ERROR(
-        "\"typeName\" field with `token` type must exist for Attribute data.");
-    return false;
-  }
-
-  if (!HasField(kDefault)) {
-    PUSH_ERROR("\"default\" field must exist for Attribute data.");
-    return false;
-  }
-
-  //
-  // Parse properties
-  //
-  for (const auto &fv : fvs) {
-    DCOUT("===  fvs.first " << fv.first
-                            << ", second: " << fv.second.GetTypeName());
-    if ((fv.first == "typeName") && (fv.second.GetTypeName() == "Token")) {
-      attr->type_name = fv.second.value<value::token>().str();
-      DCOUT("typeName: " << attr->type_name);
-    } else if (fv.first == "default") {
-      // Nothing to do at there. Process `default` in the later
-      continue;
-    } else if (fv.first == "targetPaths") {
-      // e.g. connection to Material.
-      const ListOp<Path> paths = fv.second.value<ListOp<Path>>();
-
-      DCOUT("ListOp<Path> = " << to_string(paths));
-      // Currently we only support single explicit path.
-      if ((paths.GetExplicitItems().size() == 1)) {
-        const Path &path = paths.GetExplicitItems()[0];
-        (void)path;
-
-        DCOUT("full path: " << path.full_path_name());
-        DCOUT("local path: " << path.local_path_name());
-
-        attr->var.set_scalar(path.full_path_name());  // TODO: store `Path`
-
-        has_connection = true;
-
-      } else {
-        return false;
-      }
-    } else if (fv.first == "connectionPaths") {
-      // e.g. connection to texture file.
-      const ListOp<Path> paths = fv.second.value<ListOp<Path>>();
-
-      DCOUT("ListOp<Path> = " << to_string(paths));
-
-      // Currently we only support single explicit path.
-      if ((paths.GetExplicitItems().size() == 1)) {
-        const Path &path = paths.GetExplicitItems()[0];
-        (void)path;
-
-        DCOUT("full path: " << path.full_path_name());
-        DCOUT("local path: " << path.local_path_name());
-
-        attr->var.set_scalar(path.full_path_name());  // TODO: store `Path`
-
-        has_connection = true;
-
-      } else {
-        return false;
-      }
-    } else if ((fv.first == "variablity") &&
-               (fv.second.GetTypeName() == "Variability")) {
-      variability = fv.second.value<Variability>();
-    } else if ((fv.first == "interpolation") &&
-               (fv.second.GetTypeName() == "Token")) {
-      interpolation =
-          InterpolationFromString(fv.second.value<value::token>().str());
-    } else {
-      DCOUT("TODO: name: " << fv.first
-                           << ", type: " << fv.second.GetTypeName());
-    }
-  }
-
-  attr->variability = variability;
-  attr->meta.interpolation = interpolation;
-
-  //
-  // Decode value(stored in "default" field)
-  //
-  const auto fvRet = GetFieldValuePair(fvs, kDefault);
-  if (!fvRet) {
-    // This code path should not happen. Just in case.
-    PUSH_ERROR("`default` field not found.");
-    return false;
-  }
-  const auto fv = fvRet.value();
-
-  auto add1DArraySuffix = [](const std::string &a) -> std::string {
-    return a + "[]";
-  };
-
-  {
-    if (fv.first == "default") {
-      attr->name = prop_name;
-
-      DCOUT("fv.second.GetTypeName = " << fv.second.GetTypeName());
-
-#define PROC_SCALAR(__tyname, __ty)                             \
-  }                                                             \
-  else if (fv.second.GetTypeName() == __tyname) {               \
-    auto ret = fv.second.get_value<__ty>();                     \
-    if (!ret) {                                                 \
-      PUSH_ERROR("Failed to decode " << __tyname << " value."); \
-      return false;                                             \
-    }                                                           \
-    attr->var.set_scalar(ret.value());                          \
-    success = true;
-
-#define PROC_ARRAY(__tyname, __ty)                                  \
-  }                                                                 \
-  else if (fv.second.GetTypeName() == add1DArraySuffix(__tyname)) { \
-    auto ret = fv.second.get_value<std::vector<__ty>>();            \
-    if (!ret) {                                                     \
-      PUSH_ERROR("Failed to decode " << __tyname << "[] value.");   \
-      return false;                                                 \
-    }                                                               \
-    attr->var.set_scalar(ret.value());                              \
-    success = true;
-
-      if (0) {  // dummy
-        PROC_SCALAR(value::kFloat, float)
-        PROC_SCALAR(value::kBool, bool)
-        PROC_SCALAR(value::kInt, int)
-        PROC_SCALAR(value::kFloat2, value::float2)
-        PROC_SCALAR(value::kFloat3, value::float3)
-        PROC_SCALAR(value::kFloat4, value::float4)
-        PROC_SCALAR(value::kHalf2, value::half2)
-        PROC_SCALAR(value::kHalf3, value::half3)
-        PROC_SCALAR(value::kHalf4, value::half4)
-        PROC_SCALAR(value::kToken, value::token)
-        PROC_SCALAR(value::kAssetPath, value::asset_path)
-
-        PROC_SCALAR(value::kMatrix2d, value::matrix2d)
-        PROC_SCALAR(value::kMatrix3d, value::matrix3d)
-        PROC_SCALAR(value::kMatrix4d, value::matrix4d)
-
-        // It seems `token[]` is defined as `TokenVector` in CrateData.
-        // We tret it as scalar
-        PROC_SCALAR("TokenVector", std::vector<value::token>)
-
-        // TODO(syoyo): Use constexpr concat
-        PROC_ARRAY(value::kInt, int32_t)
-        PROC_ARRAY(value::kUInt, uint32_t)
-        PROC_ARRAY(value::kFloat, float)
-        PROC_ARRAY(value::kFloat2, value::float2)
-        PROC_ARRAY(value::kFloat3, value::float3)
-        PROC_ARRAY(value::kFloat4, value::float4)
-        PROC_ARRAY(value::kToken, value::token)
-
-        PROC_ARRAY(value::kMatrix2d, value::matrix2d)
-        PROC_ARRAY(value::kMatrix3d, value::matrix3d)
-        PROC_ARRAY(value::kMatrix4d, value::matrix4d)
-
-        PROC_ARRAY(value::kPoint3h, value::point3h)
-        PROC_ARRAY(value::kPoint3f, value::point3f)
-        PROC_ARRAY(value::kPoint3d, value::point3d)
-
-        PROC_ARRAY(value::kVector3h, value::vector3h)
-        PROC_ARRAY(value::kVector3f, value::vector3f)
-        PROC_ARRAY(value::kVector3d, value::vector3d)
-
-        PROC_ARRAY(value::kNormal3h, value::normal3h)
-        PROC_ARRAY(value::kNormal3f, value::normal3f)
-        PROC_ARRAY(value::kNormal3d, value::normal3d)
-
-        // PROC_ARRAY("Vec2fArray", value::float2)
-        // PROC_ARRAY("Vec3fArray", value::float3)
-        // PROC_ARRAY("Vec4fArray", value::float4)
-        // PROC_ARRAY("IntArray", int)
-        // PROC_ARRAY(kTokenArray, value::token)
-
-      } else {
-        PUSH_ERROR("TODO: " + fv.second.GetTypeName());
-      }
-    }
-  }
-
-  if (!success && has_connection) {
-    // Attribute has a connection(has a path and no `default` field)
-    success = true;
-  }
-
-  return success;
-}
-
 
 }  // namespace crate
 }  // namespace tinyusdz
```

### Comparing `tinyusdz-0.8.0rc0/src/crate-writer.cc` & `tinyusdz-0.8.0rc1/src/crate-writer.cc`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/define-type-trait.inc` & `tinyusdz-0.8.0rc1/src/define-type-trait.inc`

 * *Files 22% similar despite different names*

```diff
@@ -1,31 +1,38 @@
-#define DEFINE_TYPE_TRAIT(__dty, __name, __tyid, __nc)           \
-  template <>                                                    \
-  struct TypeTrait<__dty> {                                      \
-    using value_type = __dty;                                    \
-    using value_underlying_type = __dty;                         \
-    static constexpr uint32_t ndim = 0; /* array dim */          \
-    static constexpr uint32_t size = sizeof(__dty);              \
-    static constexpr uint32_t ncomp =                            \
-        __nc; /* the number of components(e.g. float3 => 3) */   \
-    static constexpr uint32_t type_id = __tyid;                  \
-    static constexpr uint32_t underlying_type_id = __tyid;       \
-    static std::string type_name() { return __name; }            \
-    static std::string underlying_type_name() { return __name; } \
+// TODO: Use (inline) constexpr for C++17
+// TODO: Deprecate ndim()
+#define DEFINE_TYPE_TRAIT(__dty, __name, __tyid, __nc)                \
+  template <>                                                         \
+  struct TypeTraits<__dty> {                                          \
+    using value_type = __dty;                                         \
+    using value_underlying_type = __dty;                              \
+    static constexpr uint32_t ndim() { return 0; } /* array dim */    \
+    static constexpr uint32_t size() { return sizeof(__dty); }        \
+    static constexpr uint32_t ncomp() {                               \
+      return __nc;                                                    \
+    } /* the number of components(e.g. extent = 2) */                 \
+    static constexpr uint32_t type_id() { return __tyid; }            \
+    static constexpr uint32_t underlying_type_id() { return __tyid; } \
+    static std::string type_name() { return __name; }                 \
+    static std::string underlying_type_name() { return __name; }      \
+    static bool is_role_type() { return false; }      \
   }
 
 // `role` type. Requies underlying type.
-#define DEFINE_ROLE_TYPE_TRAIT(__dty, __name, __tyid, __uty)                  \
-  template <>                                                                 \
-  struct TypeTrait<__dty> {                                                   \
-    using value_type = __dty;                                                 \
-    using value_underlying_type = TypeTrait<__uty>::value_type;               \
-    static constexpr uint32_t ndim = 0; /* array dim */                       \
-    static constexpr uint32_t size = TypeTrait<__uty>::size;                  \
-    static constexpr uint32_t ncomp = TypeTrait<__uty>::ncomp;                \
-    static constexpr uint32_t type_id = __tyid;                               \
-    static constexpr uint32_t underlying_type_id = TypeTrait<__uty>::type_id; \
-    static std::string type_name() { return __name; }                         \
-    static std::string underlying_type_name() {                               \
-      return TypeTrait<__uty>::type_name();                                   \
-    }                                                                         \
+#define DEFINE_ROLE_TYPE_TRAIT(__dty, __name, __tyid, __uty)                 \
+  template <>                                                                \
+  struct TypeTraits<__dty> {                                                 \
+    using value_type = __dty;                                                \
+    using value_underlying_type = TypeTraits<__uty>::value_type;             \
+    static constexpr uint32_t ndim() { return 0; } /* array dim */           \
+    static constexpr uint32_t size() { return TypeTraits<__uty>::size(); }   \
+    static constexpr uint32_t ncomp() { return TypeTraits<__uty>::ncomp(); } \
+    static constexpr uint32_t type_id() { return __tyid; }                   \
+    static constexpr uint32_t underlying_type_id() {                         \
+      return TypeTraits<__uty>::type_id();                                     \
+    }                                                                        \
+    static std::string type_name() { return __name; }                        \
+    static std::string underlying_type_name() {                              \
+      return TypeTraits<__uty>::type_name();                                 \
+    }                                                                        \
+    static bool is_role_type() { return true; }      \
   }
```

### Comparing `tinyusdz-0.8.0rc0/src/external/LICENSE.miniz` & `tinyusdz-0.8.0rc1/src/external/LICENSE.miniz`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/LICENSE.ogt_vox.md` & `tinyusdz-0.8.0rc1/src/external/LICENSE.ogt_vox.md`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/README.fpng.md` & `tinyusdz-0.8.0rc1/src/external/README.fpng.md`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/better-enums/LICENSE.md` & `tinyusdz-0.8.0rc1/src/lz4/LICENSE`

 * *Files 8% similar despite different names*

```diff
@@ -1,19 +1,20 @@
-Copyright (c) 2012-2021, Anton Bachin
+LZ4 Library
+Copyright (c) 2011-2020, Yann Collet
 All rights reserved.
 
 Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
-1. Redistributions of source code must retain the above copyright notice, this
-list of conditions and the following disclaimer.
+* Redistributions of source code must retain the above copyright notice, this
+  list of conditions and the following disclaimer.
 
-2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation and/or
-other materials provided with the distribution.
+* Redistributions in binary form must reproduce the above copyright notice, this
+  list of conditions and the following disclaimer in the documentation and/or
+  other materials provided with the distribution.
 
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
```

### Comparing `tinyusdz-0.8.0rc0/src/external/dr_mp3.h` & `tinyusdz-0.8.0rc1/src/external/dr_mp3.h`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 /*
 MP3 audio decoder. Choice of public domain or MIT-0. See license statements at the end of this file.
-dr_mp3 - v0.6.1 - 2020-04-05
+dr_mp3 - v0.6.34 - 2022-09-17
 
 David Reid - mackron@gmail.com
 
 GitHub: https://github.com/mackron/dr_libs
 
 Based on minimp3 (https://github.com/lieff/minimp3) which is where the real work was done. See the bottom of this file for differences between minimp3 and dr_mp3.
 */
@@ -86,50 +86,57 @@
 #ifndef dr_mp3_h
 #define dr_mp3_h
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
+#define DRMP3_STRINGIFY(x)      #x
+#define DRMP3_XSTRINGIFY(x)     DRMP3_STRINGIFY(x)
+
+#define DRMP3_VERSION_MAJOR     0
+#define DRMP3_VERSION_MINOR     6
+#define DRMP3_VERSION_REVISION  34
+#define DRMP3_VERSION_STRING    DRMP3_XSTRINGIFY(DRMP3_VERSION_MAJOR) "." DRMP3_XSTRINGIFY(DRMP3_VERSION_MINOR) "." DRMP3_XSTRINGIFY(DRMP3_VERSION_REVISION)
+
 #include <stddef.h> /* For size_t. */
 
-/* Sized types. Prefer built-in types. Fall back to stdint. */
-#ifdef _MSC_VER
-    #if defined(__clang__)
+/* Sized types. */
+typedef   signed char           drmp3_int8;
+typedef unsigned char           drmp3_uint8;
+typedef   signed short          drmp3_int16;
+typedef unsigned short          drmp3_uint16;
+typedef   signed int            drmp3_int32;
+typedef unsigned int            drmp3_uint32;
+#if defined(_MSC_VER) && !defined(__clang__)
+    typedef   signed __int64    drmp3_int64;
+    typedef unsigned __int64    drmp3_uint64;
+#else
+    #if defined(__clang__) || (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)))
         #pragma GCC diagnostic push
-        #pragma GCC diagnostic ignored "-Wlanguage-extension-token"
-        #pragma GCC diagnostic ignored "-Wlong-long"        
-        #pragma GCC diagnostic ignored "-Wc++11-long-long"
-    #endif
-    typedef   signed __int8  drmp3_int8;
-    typedef unsigned __int8  drmp3_uint8;
-    typedef   signed __int16 drmp3_int16;
-    typedef unsigned __int16 drmp3_uint16;
-    typedef   signed __int32 drmp3_int32;
-    typedef unsigned __int32 drmp3_uint32;
-    typedef   signed __int64 drmp3_int64;
-    typedef unsigned __int64 drmp3_uint64;
-    #if defined(__clang__)
+        #pragma GCC diagnostic ignored "-Wlong-long"
+        #if defined(__clang__)
+            #pragma GCC diagnostic ignored "-Wc++11-long-long"
+        #endif
+    #endif
+    typedef   signed long long  drmp3_int64;
+    typedef unsigned long long  drmp3_uint64;
+    #if defined(__clang__) || (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)))
         #pragma GCC diagnostic pop
     #endif
+#endif
+#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__)) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(_M_ARM64) || defined(__powerpc64__)
+    typedef drmp3_uint64        drmp3_uintptr;
 #else
-    #include <stdint.h>
-    typedef int8_t           drmp3_int8;
-    typedef uint8_t          drmp3_uint8;
-    typedef int16_t          drmp3_int16;
-    typedef uint16_t         drmp3_uint16;
-    typedef int32_t          drmp3_int32;
-    typedef uint32_t         drmp3_uint32;
-    typedef int64_t          drmp3_int64;
-    typedef uint64_t         drmp3_uint64;
-#endif
-typedef drmp3_uint8          drmp3_bool8;
-typedef drmp3_uint32         drmp3_bool32;
-#define DRMP3_TRUE           1
-#define DRMP3_FALSE          0
+    typedef drmp3_uint32        drmp3_uintptr;
+#endif
+typedef drmp3_uint8             drmp3_bool8;
+typedef drmp3_uint32            drmp3_bool32;
+#define DRMP3_TRUE              1
+#define DRMP3_FALSE             0
 
 #if !defined(DRMP3_API)
     #if defined(DRMP3_DLL)
         #if defined(_WIN32)
             #define DRMP3_DLL_IMPORT  __declspec(dllimport)
             #define DRMP3_DLL_EXPORT  __declspec(dllexport)
             #define DRMP3_DLL_PRIVATE static
@@ -224,61 +231,66 @@
     I've had a bug report where GCC is emitting warnings about functions possibly not being inlineable. This warning happens when
     the __attribute__((always_inline)) attribute is defined without an "inline" statement. I think therefore there must be some
     case where "__inline__" is not always defined, thus the compiler emitting these warnings. When using -std=c89 or -ansi on the
     command line, we cannot use the "inline" keyword and instead need to use "__inline__". In an attempt to work around this issue
     I am using "__inline__" only when we're compiling in strict ANSI mode.
     */
     #if defined(__STRICT_ANSI__)
-        #define DRMP3_INLINE __inline__ __attribute__((always_inline))
+        #define DRMP3_GNUC_INLINE_HINT __inline__
+    #else
+        #define DRMP3_GNUC_INLINE_HINT inline
+    #endif
+
+    #if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 2)) || defined(__clang__)
+        #define DRMP3_INLINE DRMP3_GNUC_INLINE_HINT __attribute__((always_inline))
     #else
-        #define DRMP3_INLINE inline __attribute__((always_inline))
+        #define DRMP3_INLINE DRMP3_GNUC_INLINE_HINT
     #endif
+#elif defined(__WATCOMC__)
+    #define DRMP3_INLINE __inline
 #else
     #define DRMP3_INLINE
 #endif
 
+
+DRMP3_API void drmp3_version(drmp3_uint32* pMajor, drmp3_uint32* pMinor, drmp3_uint32* pRevision);
+DRMP3_API const char* drmp3_version_string(void);
+
+
 /*
 Low Level Push API
 ==================
 */
 typedef struct
 {
     int frame_bytes, channels, hz, layer, bitrate_kbps;
 } drmp3dec_frame_info;
 
 typedef struct
 {
     float mdct_overlap[2][9*32], qmf_state[15*2*32];
     int reserv, free_format_bytes;
-    unsigned char header[4], reserv_buf[511];
+    drmp3_uint8 header[4], reserv_buf[511];
 } drmp3dec;
 
 /* Initializes a low level decoder. */
 DRMP3_API void drmp3dec_init(drmp3dec *dec);
 
 /* Reads a frame from a low level decoder. */
-DRMP3_API int drmp3dec_decode_frame(drmp3dec *dec, const unsigned char *mp3, int mp3_bytes, void *pcm, drmp3dec_frame_info *info);
+DRMP3_API int drmp3dec_decode_frame(drmp3dec *dec, const drmp3_uint8 *mp3, int mp3_bytes, void *pcm, drmp3dec_frame_info *info);
 
 /* Helper for converting between f32 and s16. */
 DRMP3_API void drmp3dec_f32_to_s16(const float *in, drmp3_int16 *out, size_t num_samples);
 
 
 
 /*
 Main API (Pull API)
 ===================
 */
-#ifndef DRMP3_DEFAULT_CHANNELS
-#define DRMP3_DEFAULT_CHANNELS      2
-#endif
-#ifndef DRMP3_DEFAULT_SAMPLE_RATE
-#define DRMP3_DEFAULT_SAMPLE_RATE   44100
-#endif
-
-
 typedef enum
 {
     drmp3_seek_origin_start,
     drmp3_seek_origin_current
 } drmp3_seek_origin;
 
 typedef struct
@@ -330,15 +342,14 @@
     drmp3_uint32 channels;
     drmp3_uint32 sampleRate;
 } drmp3_config;
 
 typedef struct
 {
     drmp3dec decoder;
-    drmp3dec_frame_info frameInfo;
     drmp3_uint32 channels;
     drmp3_uint32 sampleRate;
     drmp3_read_proc onRead;
     drmp3_seek_proc onSeek;
     void* pUserData;
     drmp3_allocation_callbacks allocationCallbacks;
     drmp3_uint32 mp3FrameChannels;      /* The number of channels in the currently loaded MP3 frame. Internal use only. */
@@ -348,14 +359,15 @@
     drmp3_uint8 pcmFrames[sizeof(float)*DRMP3_MAX_SAMPLES_PER_FRAME];  /* <-- Multipled by sizeof(float) to ensure there's enough room for DR_MP3_FLOAT_OUTPUT. */
     drmp3_uint64 currentPCMFrame;       /* The current PCM frame, globally, based on the output sample rate. Mainly used for seeking. */
     drmp3_uint64 streamCursor;          /* The current byte the decoder is sitting on in the raw stream. */
     drmp3_seek_point* pSeekPoints;      /* NULL by default. Set with drmp3_bind_seek_table(). Memory is owned by the client. dr_mp3 will never attempt to free this pointer. */
     drmp3_uint32 seekPointCount;        /* The number of items in pSeekPoints. When set to 0 assumes to no seek table. Defaults to zero. */
     size_t dataSize;
     size_t dataCapacity;
+    size_t dataConsumed;
     drmp3_uint8* pData;
     drmp3_bool32 atEnd : 1;
     struct
     {
         const drmp3_uint8* pData;
         size_t dataSize;
         size_t currentReadPos;
@@ -505,18 +517,41 @@
  ************************************************************************************************************************************************************
 
  IMPLEMENTATION
 
  ************************************************************************************************************************************************************
  ************************************************************************************************************************************************************/
 #if defined(DR_MP3_IMPLEMENTATION) || defined(DRMP3_IMPLEMENTATION)
+#ifndef dr_mp3_c
+#define dr_mp3_c
+
 #include <stdlib.h>
 #include <string.h>
 #include <limits.h> /* For INT_MAX */
 
+DRMP3_API void drmp3_version(drmp3_uint32* pMajor, drmp3_uint32* pMinor, drmp3_uint32* pRevision)
+{
+    if (pMajor) {
+        *pMajor = DRMP3_VERSION_MAJOR;
+    }
+
+    if (pMinor) {
+        *pMinor = DRMP3_VERSION_MINOR;
+    }
+
+    if (pRevision) {
+        *pRevision = DRMP3_VERSION_REVISION;
+    }
+}
+
+DRMP3_API const char* drmp3_version_string(void)
+{
+    return DRMP3_VERSION_STRING;
+}
+
 /* Disable SIMD when compiling with TCC for now. */
 #if defined(__TINYC__)
 #define DR_MP3_NO_SIMD
 #endif
 
 #define DRMP3_OFFSET_PTR(p, offset) ((void*)((drmp3_uint8*)(p) + (offset)))
 
@@ -556,20 +591,20 @@
 #define DRMP3_MAX_SCFI                    ((DRMP3_MAX_SCF + 3) & ~3)
 
 #define DRMP3_MIN(a, b)           ((a) > (b) ? (b) : (a))
 #define DRMP3_MAX(a, b)           ((a) < (b) ? (b) : (a))
 
 #if !defined(DR_MP3_NO_SIMD)
 
-#if !defined(DR_MP3_ONLY_SIMD) && (defined(_M_X64) || defined(_M_ARM64) || defined(__x86_64__) || defined(__aarch64__))
+#if !defined(DR_MP3_ONLY_SIMD) && (defined(_M_X64) || defined(__x86_64__) || defined(__aarch64__) || defined(_M_ARM64))
 /* x64 always have SSE2, arm64 always have neon, no need for generic code */
 #define DR_MP3_ONLY_SIMD
 #endif
 
-#if ((defined(_MSC_VER) && _MSC_VER >= 1400) && (defined(_M_IX86) || defined(_M_X64))) || ((defined(__i386__) || defined(__x86_64__)) && defined(__SSE2__))
+#if ((defined(_MSC_VER) && _MSC_VER >= 1400) && defined(_M_X64)) || ((defined(__i386) || defined(_M_IX86) || defined(__i386__) || defined(__x86_64__)) && ((defined(_M_IX86_FP) && _M_IX86_FP == 2) || defined(__SSE2__)))
 #if defined(_MSC_VER)
 #include <intrin.h>
 #endif
 #include <emmintrin.h>
 #define DRMP3_HAVE_SSE 1
 #define DRMP3_HAVE_SIMD 1
 #define DRMP3_VSTORE _mm_storeu_ps
@@ -606,15 +641,15 @@
     __asm__ __volatile__(
         "cpuid"
         : "=a" (CPUInfo[0]), "=b" (CPUInfo[1]), "=c" (CPUInfo[2]), "=d" (CPUInfo[3])
         : "a" (InfoType));
 #endif
 }
 #endif
-static int drmp3_have_simd()
+static int drmp3_have_simd(void)
 {
 #ifdef DR_MP3_ONLY_SIMD
     return 1;
 #else
     static int g_have_simd;
     int CPUInfo[4];
 #ifdef MINIMP3_TEST
@@ -632,30 +667,30 @@
         return g_have_simd - 1;
     }
 
 end:
     return g_have_simd - 1;
 #endif
 }
-#elif defined(__ARM_NEON) || defined(__aarch64__)
+#elif defined(__ARM_NEON) || defined(__aarch64__) || defined(_M_ARM64)
 #include <arm_neon.h>
 #define DRMP3_HAVE_SSE 0
 #define DRMP3_HAVE_SIMD 1
 #define DRMP3_VSTORE vst1q_f32
 #define DRMP3_VLD vld1q_f32
 #define DRMP3_VSET vmovq_n_f32
 #define DRMP3_VADD vaddq_f32
 #define DRMP3_VSUB vsubq_f32
 #define DRMP3_VMUL vmulq_f32
 #define DRMP3_VMAC(a, x, y) vmlaq_f32(a, x, y)
 #define DRMP3_VMSB(a, x, y) vmlsq_f32(a, x, y)
 #define DRMP3_VMUL_S(x, s)  vmulq_f32(x, vmovq_n_f32(s))
 #define DRMP3_VREV(x) vcombine_f32(vget_high_f32(vrev64q_f32(x)), vget_low_f32(vrev64q_f32(x)))
 typedef float32x4_t drmp3_f4;
-static int drmp3_have_simd()
+static int drmp3_have_simd(void)
 {   /* TODO: detect neon for !DR_MP3_ONLY_SIMD */
     return 1;
 }
 #else
 #define DRMP3_HAVE_SSE 0
 #define DRMP3_HAVE_SIMD 0
 #ifdef DR_MP3_ONLY_SIMD
@@ -665,14 +700,52 @@
 
 #else
 
 #define DRMP3_HAVE_SIMD 0
 
 #endif
 
+#if defined(__ARM_ARCH) && (__ARM_ARCH >= 6) && !defined(__aarch64__) && !defined(_M_ARM64)
+#define DRMP3_HAVE_ARMV6 1
+static __inline__ __attribute__((always_inline)) drmp3_int32 drmp3_clip_int16_arm(drmp3_int32 a)
+{
+    drmp3_int32 x = 0;
+    __asm__ ("ssat %0, #16, %1" : "=r"(x) : "r"(a));
+    return x;
+}
+#else
+#define DRMP3_HAVE_ARMV6 0
+#endif
+
+
+/* Standard library stuff. */
+#ifndef DRMP3_ASSERT
+#include <assert.h>
+#define DRMP3_ASSERT(expression) assert(expression)
+#endif
+#ifndef DRMP3_COPY_MEMORY
+#define DRMP3_COPY_MEMORY(dst, src, sz) memcpy((dst), (src), (sz))
+#endif
+#ifndef DRMP3_MOVE_MEMORY
+#define DRMP3_MOVE_MEMORY(dst, src, sz) memmove((dst), (src), (sz))
+#endif
+#ifndef DRMP3_ZERO_MEMORY
+#define DRMP3_ZERO_MEMORY(p, sz) memset((p), 0, (sz))
+#endif
+#define DRMP3_ZERO_OBJECT(p) DRMP3_ZERO_MEMORY((p), sizeof(*(p)))
+#ifndef DRMP3_MALLOC
+#define DRMP3_MALLOC(sz) malloc((sz))
+#endif
+#ifndef DRMP3_REALLOC
+#define DRMP3_REALLOC(p, sz) realloc((p), (sz))
+#endif
+#ifndef DRMP3_FREE
+#define DRMP3_FREE(p) free((p))
+#endif
+
 typedef struct
 {
     const drmp3_uint8 *buf;
     int pos, limit;
 } drmp3_bs;
 
 typedef struct
@@ -931,15 +1004,15 @@
     }
     return group_size*4;
 }
 
 static void drmp3_L12_apply_scf_384(drmp3_L12_scale_info *sci, const float *scf, float *dst)
 {
     int i, k;
-    memcpy(dst + 576 + sci->stereo_bands*18, dst + sci->stereo_bands*18, (sci->total_bands - sci->stereo_bands)*18*sizeof(float));
+    DRMP3_COPY_MEMORY(dst + 576 + sci->stereo_bands*18, dst + sci->stereo_bands*18, (sci->total_bands - sci->stereo_bands)*18*sizeof(float));
     for (i = 0; i < sci->total_bands; i++, dst += 18, scf += 6)
     {
         for (k = 0; k < 12; k++)
         {
             dst[k + 0]   *= scf[0];
             dst[k + 576] *= scf[3];
         }
@@ -1076,22 +1149,22 @@
 {
     int i, k;
     for (i = 0; i < 4 && scf_count[i]; i++, scfsi *= 2)
     {
         int cnt = scf_count[i];
         if (scfsi & 8)
         {
-            memcpy(scf, ist_pos, cnt);
+            DRMP3_COPY_MEMORY(scf, ist_pos, cnt);
         } else
         {
             int bits = scf_size[i];
             if (!bits)
             {
-                memset(scf, 0, cnt);
-                memset(ist_pos, 0, cnt);
+                DRMP3_ZERO_MEMORY(scf, cnt);
+                DRMP3_ZERO_MEMORY(ist_pos, cnt);
             } else
             {
                 int max_scf = (scfsi < 0) ? (1 << bits) - 1 : -1;
                 for (k = 0; k < cnt; k++)
                 {
                     int s = drmp3_bs_get_bits(bitbuf, bits);
                     ist_pos[k] = (drmp3_uint8)(s == max_scf ? -1 : s);
@@ -1224,15 +1297,15 @@
         -251,-892,-2058,-2620,-2828,-2957,-3023,-3039,1041,1041,1040,1040,769,769,769,769,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,256,-511,-527,-543,-559,1530,-575,-591,1528,1527,1407,1526,1391,1023,1023,1023,1023,1525,1375,1268,1268,1103,1103,1087,1087,1039,1039,1523,-604,815,815,815,815,510,495,509,479,508,463,507,447,431,505,415,399,-734,-782,1262,-815,1259,1244,-831,1258,1228,-847,-863,1196,-879,1253,987,987,748,-767,493,493,462,477,414,414,686,669,478,446,461,445,474,429,487,458,412,471,1266,1264,1009,1009,799,799,-1019,-1276,-1452,-1581,-1677,-1757,-1821,-1886,-1933,-1997,1257,1257,1483,1468,1512,1422,1497,1406,1467,1496,1421,1510,1134,1134,1225,1225,1466,1451,1374,1405,1252,1252,1358,1480,1164,1164,1251,1251,1238,1238,1389,1465,-1407,1054,1101,-1423,1207,-1439,830,830,1248,1038,1237,1117,1223,1148,1236,1208,411,426,395,410,379,269,1193,1222,1132,1235,1221,1116,976,976,1192,1162,1177,1220,1131,1191,963,963,-1647,961,780,-1663,558,558,994,993,437,408,393,407,829,978,813,797,947,-1743,721,721,377,392,844,950,828,890,706,706,812,859,796,960,948,843,934,874,571,571,-1919,690,555,689,421,346,539,539,944,779,918,873,932,842,903,888,570,570,931,917,674,674,-2575,1562,-2591,1609,-2607,1654,1322,1322,1441,1441,1696,1546,1683,1593,1669,1624,1426,1426,1321,1321,1639,1680,1425,1425,1305,1305,1545,1668,1608,1623,1667,1592,1638,1666,1320,1320,1652,1607,1409,1409,1304,1304,1288,1288,1664,1637,1395,1395,1335,1335,1622,1636,1394,1394,1319,1319,1606,1621,1392,1392,1137,1137,1137,1137,345,390,360,375,404,373,1047,-2751,-2767,-2783,1062,1121,1046,-2799,1077,-2815,1106,1061,789,789,1105,1104,263,355,310,340,325,354,352,262,339,324,1091,1076,1029,1090,1060,1075,833,833,788,788,1088,1028,818,818,803,803,561,561,531,531,816,771,546,546,289,274,288,258,
         -253,-317,-381,-446,-478,-509,1279,1279,-811,-1179,-1451,-1756,-1900,-2028,-2189,-2253,-2333,-2414,-2445,-2511,-2526,1313,1298,-2559,1041,1041,1040,1040,1025,1025,1024,1024,1022,1007,1021,991,1020,975,1019,959,687,687,1018,1017,671,671,655,655,1016,1015,639,639,758,758,623,623,757,607,756,591,755,575,754,559,543,543,1009,783,-575,-621,-685,-749,496,-590,750,749,734,748,974,989,1003,958,988,973,1002,942,987,957,972,1001,926,986,941,971,956,1000,910,985,925,999,894,970,-1071,-1087,-1102,1390,-1135,1436,1509,1451,1374,-1151,1405,1358,1480,1420,-1167,1507,1494,1389,1342,1465,1435,1450,1326,1505,1310,1493,1373,1479,1404,1492,1464,1419,428,443,472,397,736,526,464,464,486,457,442,471,484,482,1357,1449,1434,1478,1388,1491,1341,1490,1325,1489,1463,1403,1309,1477,1372,1448,1418,1433,1476,1356,1462,1387,-1439,1475,1340,1447,1402,1474,1324,1461,1371,1473,269,448,1432,1417,1308,1460,-1711,1459,-1727,1441,1099,1099,1446,1386,1431,1401,-1743,1289,1083,1083,1160,1160,1458,1445,1067,1067,1370,1457,1307,1430,1129,1129,1098,1098,268,432,267,416,266,400,-1887,1144,1187,1082,1173,1113,1186,1066,1050,1158,1128,1143,1172,1097,1171,1081,420,391,1157,1112,1170,1142,1127,1065,1169,1049,1156,1096,1141,1111,1155,1080,1126,1154,1064,1153,1140,1095,1048,-2159,1125,1110,1137,-2175,823,823,1139,1138,807,807,384,264,368,263,868,838,853,791,867,822,852,837,866,806,865,790,-2319,851,821,836,352,262,850,805,849,-2399,533,533,835,820,336,261,578,548,563,577,532,532,832,772,562,562,547,547,305,275,560,515,290,290,288,258 };
     static const drmp3_uint8 tab32[] = { 130,162,193,209,44,28,76,140,9,9,9,9,9,9,9,9,190,254,222,238,126,94,157,157,109,61,173,205};
     static const drmp3_uint8 tab33[] = { 252,236,220,204,188,172,156,140,124,108,92,76,60,44,28,12 };
     static const drmp3_int16 tabindex[2*16] = { 0,32,64,98,0,132,180,218,292,364,426,538,648,746,0,1126,1460,1460,1460,1460,1460,1460,1460,1460,1842,1842,1842,1842,1842,1842,1842,1842 };
     static const drmp3_uint8 g_linbits[] =  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,6,8,10,13,4,5,6,7,8,9,11,13 };
 
-#define DRMP3_PEEK_BITS(n)    (bs_cache >> (32 - n))
+#define DRMP3_PEEK_BITS(n)    (bs_cache >> (32 - (n)))
 #define DRMP3_FLUSH_BITS(n)   { bs_cache <<= (n); bs_sh += (n); }
 #define DRMP3_CHECK_BITS      while (bs_sh >= 0) { bs_cache |= (drmp3_uint32)*bs_next_ptr++ << bs_sh; bs_sh -= 8; }
 #define DRMP3_BSPOS           ((bs_next_ptr - bs->buf)*8 - 24 + bs_sh)
 
     float one = 0.0f;
     int ireg = 0, big_val_cnt = gr_info->big_values;
     const drmp3_uint8 *sfb = gr_info->sfbtab;
@@ -1343,20 +1416,30 @@
 }
 
 static void drmp3_L3_midside_stereo(float *left, int n)
 {
     int i = 0;
     float *right = left + 576;
 #if DRMP3_HAVE_SIMD
-    if (drmp3_have_simd()) for (; i < n - 3; i += 4)
+    if (drmp3_have_simd())
     {
-        drmp3_f4 vl = DRMP3_VLD(left + i);
-        drmp3_f4 vr = DRMP3_VLD(right + i);
-        DRMP3_VSTORE(left + i, DRMP3_VADD(vl, vr));
-        DRMP3_VSTORE(right + i, DRMP3_VSUB(vl, vr));
+        for (; i < n - 3; i += 4)
+        {
+            drmp3_f4 vl = DRMP3_VLD(left + i);
+            drmp3_f4 vr = DRMP3_VLD(right + i);
+            DRMP3_VSTORE(left + i, DRMP3_VADD(vl, vr));
+            DRMP3_VSTORE(right + i, DRMP3_VSUB(vl, vr));
+        }
+#ifdef __GNUC__
+        /* Workaround for spurious -Waggressive-loop-optimizations warning from gcc.
+         * For more info see: https://github.com/lieff/minimp3/issues/88
+         */
+        if (__builtin_constant_p(n % 4 == 0) && n % 4 == 0)
+            return;
+#endif
     }
 #endif
     for (; i < n; i++)
     {
         float a = left[i];
         float b = right[i];
         left[i] = a + b;
@@ -1458,15 +1541,15 @@
         for (i = 0; i < len; i++, src++)
         {
             *dst++ = src[0*len];
             *dst++ = src[1*len];
             *dst++ = src[2*len];
         }
     }
-    memcpy(grbuf, scratch, (dst - scratch)*sizeof(float));
+    DRMP3_COPY_MEMORY(grbuf, scratch, (dst - scratch)*sizeof(float));
 }
 
 static void drmp3_L3_antialias(float *grbuf, int nbands)
 {
     static const float g_aa[2][8] = {
         {0.85749293f,0.88174200f,0.94962865f,0.98331459f,0.99551782f,0.99916056f,0.99989920f,0.99999316f},
         {0.51449576f,0.47173197f,0.31337745f,0.18191320f,0.09457419f,0.04096558f,0.01419856f,0.00369997f}
@@ -1627,16 +1710,16 @@
 }
 
 static void drmp3_L3_imdct_short(float *grbuf, float *overlap, int nbands)
 {
     for (;nbands > 0; nbands--, overlap += 9, grbuf += 18)
     {
         float tmp[18];
-        memcpy(tmp, grbuf, sizeof(tmp));
-        memcpy(grbuf, overlap, 6*sizeof(float));
+        DRMP3_COPY_MEMORY(tmp, grbuf, sizeof(tmp));
+        DRMP3_COPY_MEMORY(grbuf, overlap, 6*sizeof(float));
         drmp3_L3_imdct12(tmp, grbuf + 6, overlap + 6);
         drmp3_L3_imdct12(tmp + 1, grbuf + 12, overlap + 6);
         drmp3_L3_imdct12(tmp + 2, overlap, overlap + 6);
     }
 }
 
 static void drmp3_L3_change_sign(float *grbuf)
@@ -1672,25 +1755,25 @@
     if (remains > DRMP3_MAX_BITRESERVOIR_BYTES)
     {
         pos += remains - DRMP3_MAX_BITRESERVOIR_BYTES;
         remains = DRMP3_MAX_BITRESERVOIR_BYTES;
     }
     if (remains > 0)
     {
-        memmove(h->reserv_buf, s->maindata + pos, remains);
+        DRMP3_MOVE_MEMORY(h->reserv_buf, s->maindata + pos, remains);
     }
     h->reserv = remains;
 }
 
 static int drmp3_L3_restore_reservoir(drmp3dec *h, drmp3_bs *bs, drmp3dec_scratch *s, int main_data_begin)
 {
     int frame_bytes = (bs->limit - bs->pos)/8;
     int bytes_have = DRMP3_MIN(h->reserv, main_data_begin);
-    memcpy(s->maindata, h->reserv_buf + DRMP3_MAX(0, h->reserv - main_data_begin), DRMP3_MIN(h->reserv, main_data_begin));
-    memcpy(s->maindata + bytes_have, bs->buf + bs->pos/8, frame_bytes);
+    DRMP3_COPY_MEMORY(s->maindata, h->reserv_buf + DRMP3_MAX(0, h->reserv - main_data_begin), DRMP3_MIN(h->reserv, main_data_begin));
+    DRMP3_COPY_MEMORY(s->maindata + bytes_have, bs->buf + bs->pos/8, frame_bytes);
     drmp3_bs_init(&s->bs, s->maindata, bytes_have + frame_bytes);
     return h->reserv >= main_data_begin;
 }
 
 static void drmp3_L3_decode(drmp3dec *h, drmp3dec_scratch *s, drmp3_L3_gr_info *gr_info, int nch)
 {
     int ch;
@@ -1782,15 +1865,15 @@
         }
 
         if (k > n - 3)
         {
 #if DRMP3_HAVE_SSE
 #define DRMP3_VSAVE2(i, v) _mm_storel_pi((__m64 *)(void*)&y[i*18], v)
 #else
-#define DRMP3_VSAVE2(i, v) vst1_f32((float32_t *)&y[i*18],  vget_low_f32(v))
+#define DRMP3_VSAVE2(i, v) vst1_f32((float32_t *)&y[(i)*18],  vget_low_f32(v))
 #endif
             for (i = 0; i < 7; i++, y += 4*18)
             {
                 drmp3_f4 s = DRMP3_VADD(t[3][i], t[3][i + 1]);
                 DRMP3_VSAVE2(0, t[0][i]);
                 DRMP3_VSAVE2(1, DRMP3_VADD(t[2][i], s));
                 DRMP3_VSAVE2(2, DRMP3_VADD(t[1][i], t[1][i + 1]));
@@ -1798,15 +1881,15 @@
             }
             DRMP3_VSAVE2(0, t[0][7]);
             DRMP3_VSAVE2(1, DRMP3_VADD(t[2][7], t[3][7]));
             DRMP3_VSAVE2(2, t[1][7]);
             DRMP3_VSAVE2(3, t[3][7]);
         } else
         {
-#define DRMP3_VSAVE4(i, v) DRMP3_VSTORE(&y[i*18], v)
+#define DRMP3_VSAVE4(i, v) DRMP3_VSTORE(&y[(i)*18], v)
             for (i = 0; i < 7; i++, y += 4*18)
             {
                 drmp3_f4 s = DRMP3_VADD(t[3][i], t[3][i + 1]);
                 DRMP3_VSAVE4(0, t[0][i]);
                 DRMP3_VSAVE4(1, DRMP3_VADD(t[2][i], s));
                 DRMP3_VSAVE4(2, DRMP3_VADD(t[1][i], t[1][i + 1]));
                 DRMP3_VSAVE4(3, DRMP3_VADD(t[2][1 + i], s));
@@ -1815,15 +1898,15 @@
             DRMP3_VSAVE4(1, DRMP3_VADD(t[2][7], t[3][7]));
             DRMP3_VSAVE4(2, t[1][7]);
             DRMP3_VSAVE4(3, t[3][7]);
         }
     } else
 #endif
 #ifdef DR_MP3_ONLY_SIMD
-    {}
+    {} /* for HAVE_SIMD=1, MINIMP3_ONLY_SIMD=1 case we do not need non-intrinsic "else" branch */
 #else
     for (; k < n; k++)
     {
         float t[4][8], *x, *y = grbuf + k;
 
         for (x = t[0], i = 0; i < 8; i++, x++)
         {
@@ -1884,19 +1967,25 @@
 
 #ifndef DR_MP3_FLOAT_OUTPUT
 typedef drmp3_int16 drmp3d_sample_t;
 
 static drmp3_int16 drmp3d_scale_pcm(float sample)
 {
     drmp3_int16 s;
+#if DRMP3_HAVE_ARMV6
+    drmp3_int32 s32 = (drmp3_int32)(sample + .5f);
+    s32 -= (s32 < 0);
+    s = (drmp3_int16)drmp3_clip_int16_arm(s32);
+#else
     if (sample >=  32766.5) return (drmp3_int16) 32767;
     if (sample <= -32767.5) return (drmp3_int16)-32768;
     s = (drmp3_int16)(sample + .5f);
     s -= (s < 0);   /* away from zero, to be compliant */
-    return (drmp3_int16)s;
+#endif
+    return s;
 }
 #else
 typedef float drmp3d_sample_t;
 
 static float drmp3d_scale_pcm(float sample)
 {
     return sample*(1.f/32768.f);
@@ -2015,15 +2104,19 @@
             vst1_lane_s16(dstl + (17 + i)*nch, pcmb, 0);
             vst1_lane_s16(dstr + (47 - i)*nch, pcma, 3);
             vst1_lane_s16(dstr + (49 + i)*nch, pcmb, 3);
             vst1_lane_s16(dstl + (47 - i)*nch, pcma, 2);
             vst1_lane_s16(dstl + (49 + i)*nch, pcmb, 2);
 #endif
 #else
+        #if DRMP3_HAVE_SSE
             static const drmp3_f4 g_scale = { 1.0f/32768.0f, 1.0f/32768.0f, 1.0f/32768.0f, 1.0f/32768.0f };
+        #else
+            const drmp3_f4 g_scale = vdupq_n_f32(1.0f/32768.0f);
+        #endif
             a = DRMP3_VMUL(a, g_scale);
             b = DRMP3_VMUL(b, g_scale);
 #if DRMP3_HAVE_SSE
             _mm_store_ss(dstr + (15 - i)*nch, _mm_shuffle_ps(a, a, _MM_SHUFFLE(1, 1, 1, 1)));
             _mm_store_ss(dstr + (17 + i)*nch, _mm_shuffle_ps(b, b, _MM_SHUFFLE(1, 1, 1, 1)));
             _mm_store_ss(dstl + (15 - i)*nch, _mm_shuffle_ps(a, a, _MM_SHUFFLE(0, 0, 0, 0)));
             _mm_store_ss(dstl + (17 + i)*nch, _mm_shuffle_ps(b, b, _MM_SHUFFLE(0, 0, 0, 0)));
@@ -2042,15 +2135,15 @@
             vst1q_lane_f32(dstl + (49 + i)*nch, b, 2);
 #endif
 #endif /* DR_MP3_FLOAT_OUTPUT */
         }
     } else
 #endif
 #ifdef DR_MP3_ONLY_SIMD
-    {}
+    {} /* for HAVE_SIMD=1, MINIMP3_ONLY_SIMD=1 case we do not need non-intrinsic "else" branch */
 #else
     for (i = 14; i >= 0; i--)
     {
 #define DRMP3_LOAD(k) float w0 = *w++; float w1 = *w++; float *vz = &zlin[4*i - k*64]; float *vy = &zlin[4*i - (15 - k)*64];
 #define DRMP3_S0(k) { int j; DRMP3_LOAD(k); for (j = 0; j < 4; j++) b[j]  = vz[j]*w1 + vy[j]*w0, a[j]  = vz[j]*w0 - vy[j]*w1; }
 #define DRMP3_S1(k) { int j; DRMP3_LOAD(k); for (j = 0; j < 4; j++) b[j] += vz[j]*w1 + vy[j]*w0, a[j] += vz[j]*w0 - vy[j]*w1; }
 #define DRMP3_S2(k) { int j; DRMP3_LOAD(k); for (j = 0; j < 4; j++) b[j] += vz[j]*w1 + vy[j]*w0, a[j] += vy[j]*w1 - vz[j]*w0; }
@@ -2083,15 +2176,15 @@
 {
     int i;
     for (i = 0; i < nch; i++)
     {
         drmp3d_DCT_II(grbuf + 576*i, nbands);
     }
 
-    memcpy(lins, qmf_state, sizeof(float)*15*64);
+    DRMP3_COPY_MEMORY(lins, qmf_state, sizeof(float)*15*64);
 
     for (i = 0; i < nbands; i += 2)
     {
         drmp3d_synth(grbuf + i, pcm + 32*nch*i, nch, lins + i*64);
     }
 #ifndef DR_MP3_NONSTANDARD_BUT_LOGICAL
     if (nch == 1)
@@ -2099,15 +2192,15 @@
         for (i = 0; i < 15*64; i += 2)
         {
             qmf_state[i] = lins[nbands*64 + i];
         }
     } else
 #endif
     {
-        memcpy(qmf_state, lins + nbands*64, sizeof(float)*15*64);
+        DRMP3_COPY_MEMORY(qmf_state, lins + nbands*64, sizeof(float)*15*64);
     }
 }
 
 static int drmp3d_match_frame(const drmp3_uint8 *hdr, int mp3_bytes, int frame_bytes)
 {
     int i, nmatch;
     for (i = 0, nmatch = 0; nmatch < DRMP3_MAX_FRAME_SYNC_MATCHES; nmatch++)
@@ -2160,15 +2253,15 @@
 }
 
 DRMP3_API void drmp3dec_init(drmp3dec *dec)
 {
     dec->header[0] = 0;
 }
 
-DRMP3_API int drmp3dec_decode_frame(drmp3dec *dec, const unsigned char *mp3, int mp3_bytes, void *pcm, drmp3dec_frame_info *info)
+DRMP3_API int drmp3dec_decode_frame(drmp3dec *dec, const drmp3_uint8 *mp3, int mp3_bytes, void *pcm, drmp3dec_frame_info *info)
 {
     int i = 0, igr, frame_size = 0, success = 1;
     const drmp3_uint8 *hdr;
     drmp3_bs bs_frame[1];
     drmp3dec_scratch scratch;
 
     if (mp3_bytes > 4 && dec->header[0] == 0xff && drmp3_hdr_compare(dec->header, mp3))
@@ -2177,25 +2270,25 @@
         if (frame_size != mp3_bytes && (frame_size + DRMP3_HDR_SIZE > mp3_bytes || !drmp3_hdr_compare(mp3, mp3 + frame_size)))
         {
             frame_size = 0;
         }
     }
     if (!frame_size)
     {
-        memset(dec, 0, sizeof(drmp3dec));
+        DRMP3_ZERO_MEMORY(dec, sizeof(drmp3dec));
         i = drmp3d_find_frame(mp3, mp3_bytes, &dec->free_format_bytes, &frame_size);
         if (!frame_size || i + frame_size > mp3_bytes)
         {
             info->frame_bytes = i;
             return 0;
         }
     }
 
     hdr = mp3 + i;
-    memcpy(dec->header, hdr, DRMP3_HDR_SIZE);
+    DRMP3_COPY_MEMORY(dec->header, hdr, DRMP3_HDR_SIZE);
     info->frame_bytes = i + frame_size;
     info->channels = DRMP3_HDR_IS_MONO(hdr) ? 1 : 2;
     info->hz = drmp3_hdr_sample_rate_hz(hdr);
     info->layer = 4 - DRMP3_HDR_GET_LAYER(hdr);
     info->bitrate_kbps = drmp3_hdr_bitrate_kbps(hdr);
 
     drmp3_bs_init(bs_frame, hdr + DRMP3_HDR_SIZE, frame_size - DRMP3_HDR_SIZE);
@@ -2213,15 +2306,15 @@
             return 0;
         }
         success = drmp3_L3_restore_reservoir(dec, bs_frame, &scratch, main_data_begin);
         if (success && pcm != NULL)
         {
             for (igr = 0; igr < (DRMP3_HDR_TEST_MPEG1(hdr) ? 2 : 1); igr++, pcm = DRMP3_OFFSET_PTR(pcm, sizeof(drmp3d_sample_t)*576*info->channels))
             {
-                memset(scratch.grbuf[0], 0, 576*2*sizeof(float));
+                DRMP3_ZERO_MEMORY(scratch.grbuf[0], 576*2*sizeof(float));
                 drmp3_L3_decode(dec, &scratch, scratch.gr_info + igr*info->channels, info->channels);
                 drmp3d_synth_granule(dec->qmf_state, scratch.grbuf[0], 18, info->channels, (drmp3d_sample_t*)pcm, scratch.syn[0]);
             }
         }
         drmp3_L3_save_reservoir(dec, &scratch);
     } else
     {
@@ -2232,23 +2325,23 @@
 
         if (pcm == NULL) {
             return drmp3_hdr_frame_samples(hdr);
         }
 
         drmp3_L12_read_scale_info(hdr, bs_frame, sci);
 
-        memset(scratch.grbuf[0], 0, 576*2*sizeof(float));
+        DRMP3_ZERO_MEMORY(scratch.grbuf[0], 576*2*sizeof(float));
         for (i = 0, igr = 0; igr < 3; igr++)
         {
             if (12 == (i += drmp3_L12_dequantize_granule(scratch.grbuf[0] + i, bs_frame, sci, info->layer | 1)))
             {
                 i = 0;
                 drmp3_L12_apply_scf_384(sci, sci->scf + igr, scratch.grbuf[0]);
                 drmp3d_synth_granule(dec->qmf_state, scratch.grbuf[0], 12, info->channels, (drmp3d_sample_t*)pcm, scratch.syn[0]);
-                memset(scratch.grbuf[0], 0, 576*2*sizeof(float));
+                DRMP3_ZERO_MEMORY(scratch.grbuf[0], 576*2*sizeof(float));
                 pcm = DRMP3_OFFSET_PTR(pcm, sizeof(drmp3d_sample_t)*384*info->channels);
             }
             if (bs_frame->pos > bs_frame->limit)
             {
                 drmp3dec_init(dec);
                 return 0;
             }
@@ -2318,16 +2411,14 @@
 
 
 /************************************************************************************************************************************************************
 
  Main Public API
 
  ************************************************************************************************************************************************************/
-#include <math.h>   /* For sin() and exp(). */
-
 #if defined(SIZE_MAX)
     #define DRMP3_SIZE_MAX  SIZE_MAX
 #else
     #if defined(_WIN64) || defined(_LP64) || defined(__LP64__)
         #define DRMP3_SIZE_MAX  ((drmp3_uint64)0xFFFFFFFFFFFFFFFF)
     #else
         #define DRMP3_SIZE_MAX  0xFFFFFFFF
@@ -2335,42 +2426,25 @@
 #endif
 
 /* Options. */
 #ifndef DRMP3_SEEK_LEADING_MP3_FRAMES
 #define DRMP3_SEEK_LEADING_MP3_FRAMES   2
 #endif
 
+#define DRMP3_MIN_DATA_CHUNK_SIZE   16384
 
-/* Standard library stuff. */
-#ifndef DRMP3_ASSERT
-#include <assert.h>
-#define DRMP3_ASSERT(expression) assert(expression)
-#endif
-#ifndef DRMP3_COPY_MEMORY
-#define DRMP3_COPY_MEMORY(dst, src, sz) memcpy((dst), (src), (sz))
-#endif
-#ifndef DRMP3_ZERO_MEMORY
-#define DRMP3_ZERO_MEMORY(p, sz) memset((p), 0, (sz))
-#endif
-#define DRMP3_ZERO_OBJECT(p) DRMP3_ZERO_MEMORY((p), sizeof(*(p)))
-#ifndef DRMP3_MALLOC
-#define DRMP3_MALLOC(sz) malloc((sz))
-#endif
-#ifndef DRMP3_REALLOC
-#define DRMP3_REALLOC(p, sz) realloc((p), (sz))
-#endif
-#ifndef DRMP3_FREE
-#define DRMP3_FREE(p) free((p))
+/* The size in bytes of each chunk of data to read from the MP3 stream. minimp3 recommends at least 16K, but in an attempt to reduce data movement I'm making this slightly larger. */
+#ifndef DRMP3_DATA_CHUNK_SIZE
+#define DRMP3_DATA_CHUNK_SIZE  (DRMP3_MIN_DATA_CHUNK_SIZE*4)
 #endif
 
+
 #define DRMP3_COUNTOF(x)        (sizeof(x) / sizeof(x[0]))
 #define DRMP3_CLAMP(x, lo, hi)  (DRMP3_MAX(lo, DRMP3_MIN(x, hi)))
 
-#define DRMP3_DATA_CHUNK_SIZE  16384    /* The size in bytes of each chunk of data to read from the MP3 stream. minimp3 recommends 16K. */
-
 #ifndef DRMP3_PI_D
 #define DRMP3_PI_D    3.14159265358979323846264
 #endif
 
 #define DRMP3_DEFAULT_RESAMPLER_LPF_ORDER   2
 
 static DRMP3_INLINE float drmp3_mix_f32(float x, float y, float a)
@@ -2401,32 +2475,14 @@
         }
     }
 
     return a;
 }
 
 
-static DRMP3_INLINE double drmp3_sin(double x)
-{
-    /* TODO: Implement custom sin(x). */
-    return sin(x);
-}
-
-static DRMP3_INLINE double drmp3_exp(double x)
-{
-    /* TODO: Implement custom exp(x). */
-    return exp(x);
-}
-
-static DRMP3_INLINE double drmp3_cos(double x)
-{
-    return drmp3_sin((DRMP3_PI_D*0.5) - x);
-}
-
-
 static void* drmp3__malloc_default(size_t sz, void* pUserData)
 {
     (void)pUserData;
     return DRMP3_MALLOC(sz);
 }
 
 static void* drmp3__realloc_default(void* p, size_t sz, void* pUserData)
@@ -2438,16 +2494,14 @@
 static void drmp3__free_default(void* p, void* pUserData)
 {
     (void)pUserData;
     DRMP3_FREE(p);
 }
 
 
-/* Only used without DR_MP3_NO_STDIO. */
-#ifndef DR_MP3_NO_STDIO
 static void* drmp3__malloc_from_callbacks(size_t sz, const drmp3_allocation_callbacks* pAllocationCallbacks)
 {
     if (pAllocationCallbacks == NULL) {
         return NULL;
     }
 
     if (pAllocationCallbacks->onMalloc != NULL) {
@@ -2457,15 +2511,14 @@
     /* Try using realloc(). */
     if (pAllocationCallbacks->onRealloc != NULL) {
         return pAllocationCallbacks->onRealloc(NULL, sz, pAllocationCallbacks->pUserData);
     }
 
     return NULL;
 }
-#endif
 
 static void* drmp3__realloc_from_callbacks(void* p, size_t szNew, size_t szOld, const drmp3_allocation_callbacks* pAllocationCallbacks)
 {
     if (pAllocationCallbacks == NULL) {
         return NULL;
     }
 
@@ -2574,33 +2627,39 @@
         }
     }
 
     return DRMP3_TRUE;
 }
 
 
-static drmp3_uint32 drmp3_decode_next_frame_ex(drmp3* pMP3, drmp3d_sample_t* pPCMFrames, drmp3_bool32 discard)
+static drmp3_uint32 drmp3_decode_next_frame_ex__callbacks(drmp3* pMP3, drmp3d_sample_t* pPCMFrames)
 {
     drmp3_uint32 pcmFramesRead = 0;
 
     DRMP3_ASSERT(pMP3 != NULL);
     DRMP3_ASSERT(pMP3->onRead != NULL);
 
     if (pMP3->atEnd) {
         return 0;
     }
 
     for (;;) {
         drmp3dec_frame_info info;
-        size_t leftoverDataSize;
 
-        /* minimp3 recommends doing data submission in 16K chunks. If we don't have at least 16K bytes available, get more. */
-        if (pMP3->dataSize < DRMP3_DATA_CHUNK_SIZE) {
+        /* minimp3 recommends doing data submission in chunks of at least 16K. If we don't have at least 16K bytes available, get more. */
+        if (pMP3->dataSize < DRMP3_MIN_DATA_CHUNK_SIZE) {
             size_t bytesRead;
 
+            /* First we need to move the data down. */
+            if (pMP3->pData != NULL) {
+                DRMP3_MOVE_MEMORY(pMP3->pData, pMP3->pData + pMP3->dataConsumed, pMP3->dataSize);
+            }
+
+            pMP3->dataConsumed = 0;
+
             if (pMP3->dataCapacity < DRMP3_DATA_CHUNK_SIZE) {
                 drmp3_uint8* pNewData;
                 size_t newDataCap;
 
                 newDataCap = DRMP3_DATA_CHUNK_SIZE;
 
                 pNewData = (drmp3_uint8*)drmp3__realloc_from_callbacks(pMP3->pData, newDataCap, pMP3->dataCapacity, &pMP3->allocationCallbacks);
@@ -2624,38 +2683,41 @@
         }
 
         if (pMP3->dataSize > INT_MAX) {
             pMP3->atEnd = DRMP3_TRUE;
             return 0; /* File too big. */
         }
 
-        pcmFramesRead = drmp3dec_decode_frame(&pMP3->decoder, pMP3->pData, (int)pMP3->dataSize, pPCMFrames, &info);    /* <-- Safe size_t -> int conversion thanks to the check above. */
+        DRMP3_ASSERT(pMP3->pData != NULL);
+        DRMP3_ASSERT(pMP3->dataCapacity > 0);
+
+        pcmFramesRead = drmp3dec_decode_frame(&pMP3->decoder, pMP3->pData + pMP3->dataConsumed, (int)pMP3->dataSize, pPCMFrames, &info);    /* <-- Safe size_t -> int conversion thanks to the check above. */
 
         /* Consume the data. */
-        leftoverDataSize = (pMP3->dataSize - (size_t)info.frame_bytes);
         if (info.frame_bytes > 0) {
-            memmove(pMP3->pData, pMP3->pData + info.frame_bytes, leftoverDataSize);
-            pMP3->dataSize = leftoverDataSize;
+            pMP3->dataConsumed += (size_t)info.frame_bytes;
+            pMP3->dataSize     -= (size_t)info.frame_bytes;
         }
 
-        /*
-        pcmFramesRead will be equal to 0 if decoding failed. If it is zero and info.frame_bytes > 0 then we have successfully
-        decoded the frame. A special case is if we are wanting to discard the frame, in which case we return successfully.
-        */
-        if (pcmFramesRead > 0 || (info.frame_bytes > 0 && discard)) {
+        /* pcmFramesRead will be equal to 0 if decoding failed. If it is zero and info.frame_bytes > 0 then we have successfully decoded the frame. */
+        if (pcmFramesRead > 0) {
             pcmFramesRead = drmp3_hdr_frame_samples(pMP3->decoder.header);
             pMP3->pcmFramesConsumedInMP3Frame = 0;
             pMP3->pcmFramesRemainingInMP3Frame = pcmFramesRead;
             pMP3->mp3FrameChannels = info.channels;
             pMP3->mp3FrameSampleRate = info.hz;
             break;
         } else if (info.frame_bytes == 0) {
+            /* Need more data. minimp3 recommends doing data submission in 16K chunks. */
             size_t bytesRead;
 
-            /* Need more data. minimp3 recommends doing data submission in 16K chunks. */
+            /* First we need to move the data down. */
+            DRMP3_MOVE_MEMORY(pMP3->pData, pMP3->pData + pMP3->dataConsumed, pMP3->dataSize);
+            pMP3->dataConsumed = 0;
+
             if (pMP3->dataCapacity == pMP3->dataSize) {
                 /* No room. Expand. */
                 drmp3_uint8* pNewData;
                 size_t newDataCap;
 
                 newDataCap = pMP3->dataCapacity + DRMP3_DATA_CHUNK_SIZE;
 
@@ -2678,18 +2740,63 @@
             pMP3->dataSize += bytesRead;
         }
     };
 
     return pcmFramesRead;
 }
 
+static drmp3_uint32 drmp3_decode_next_frame_ex__memory(drmp3* pMP3, drmp3d_sample_t* pPCMFrames)
+{
+    drmp3_uint32 pcmFramesRead = 0;
+    drmp3dec_frame_info info;
+
+    DRMP3_ASSERT(pMP3 != NULL);
+    DRMP3_ASSERT(pMP3->memory.pData != NULL);
+
+    if (pMP3->atEnd) {
+        return 0;
+    }
+
+    for (;;) {
+        pcmFramesRead = drmp3dec_decode_frame(&pMP3->decoder, pMP3->memory.pData + pMP3->memory.currentReadPos, (int)(pMP3->memory.dataSize - pMP3->memory.currentReadPos), pPCMFrames, &info);
+        if (pcmFramesRead > 0) {
+            pcmFramesRead = drmp3_hdr_frame_samples(pMP3->decoder.header);
+            pMP3->pcmFramesConsumedInMP3Frame  = 0;
+            pMP3->pcmFramesRemainingInMP3Frame = pcmFramesRead;
+            pMP3->mp3FrameChannels             = info.channels;
+            pMP3->mp3FrameSampleRate           = info.hz;
+            break;
+        } else if (info.frame_bytes > 0) {
+            /* No frames were read, but it looks like we skipped past one. Read the next MP3 frame. */
+            pMP3->memory.currentReadPos += (size_t)info.frame_bytes;
+        } else {
+            /* Nothing at all was read. Abort. */
+            break;
+        }
+    }
+
+    /* Consume the data. */
+    pMP3->memory.currentReadPos += (size_t)info.frame_bytes;
+
+    return pcmFramesRead;
+}
+
+static drmp3_uint32 drmp3_decode_next_frame_ex(drmp3* pMP3, drmp3d_sample_t* pPCMFrames)
+{
+    if (pMP3->memory.pData != NULL && pMP3->memory.dataSize > 0) {
+        return drmp3_decode_next_frame_ex__memory(pMP3, pPCMFrames);
+    } else {
+        return drmp3_decode_next_frame_ex__callbacks(pMP3, pPCMFrames);
+    }
+}
+
 static drmp3_uint32 drmp3_decode_next_frame(drmp3* pMP3)
 {
     DRMP3_ASSERT(pMP3 != NULL);
-    return drmp3_decode_next_frame_ex(pMP3, (drmp3d_sample_t*)pMP3->pcmFrames, DRMP3_FALSE);
+    return drmp3_decode_next_frame_ex(pMP3, (drmp3d_sample_t*)pMP3->pcmFrames);
 }
 
 #if 0
 static drmp3_uint32 drmp3_seek_next_frame(drmp3* pMP3)
 {
     drmp3_uint32 pcmFrameCount;
 
@@ -2723,16 +2830,16 @@
     pMP3->allocationCallbacks = drmp3_copy_allocation_callbacks_or_defaults(pAllocationCallbacks);
 
     if (pMP3->allocationCallbacks.onFree == NULL || (pMP3->allocationCallbacks.onMalloc == NULL && pMP3->allocationCallbacks.onRealloc == NULL)) {
         return DRMP3_FALSE;    /* Invalid allocation callbacks. */
     }
 
     /* Decode the first frame to confirm that it is indeed a valid MP3 stream. */
-    if (!drmp3_decode_next_frame(pMP3)) {
-        drmp3_uninit(pMP3);
+    if (drmp3_decode_next_frame(pMP3) == 0) {
+        drmp3__free_from_callbacks(pMP3->pData, &pMP3->allocationCallbacks);    /* The call above may have allocated memory. Need to make sure it's freed before aborting. */
         return DRMP3_FALSE; /* Not a valid MP3 stream. */
     }
 
     pMP3->channels   = pMP3->mp3FrameChannels;
     pMP3->sampleRate = pMP3->mp3FrameSampleRate;
 
     return DRMP3_TRUE;
@@ -3226,27 +3333,27 @@
     #endif
         default: return DRMP3_ERROR;
     }
 }
 
 static drmp3_result drmp3_fopen(FILE** ppFile, const char* pFilePath, const char* pOpenMode)
 {
-#if _MSC_VER && _MSC_VER >= 1400
+#if defined(_MSC_VER) && _MSC_VER >= 1400
     errno_t err;
 #endif
 
     if (ppFile != NULL) {
         *ppFile = NULL;  /* Safety. */
     }
 
     if (pFilePath == NULL || pOpenMode == NULL || ppFile == NULL) {
         return DRMP3_INVALID_ARGS;
     }
 
-#if _MSC_VER && _MSC_VER >= 1400
+#if defined(_MSC_VER) && _MSC_VER >= 1400
     err = fopen_s(ppFile, pFilePath, pOpenMode);
     if (err != 0) {
         return drmp3_result_from_errno(err);
     }
 #else
 #if defined(_WIN32) || defined(__APPLE__)
     *ppFile = fopen(pFilePath, pOpenMode);
@@ -3273,20 +3380,21 @@
 /*
 _wfopen() isn't always available in all compilation environments.
 
     * Windows only.
     * MSVC seems to support it universally as far back as VC6 from what I can tell (haven't checked further back).
     * MinGW-64 (both 32- and 64-bit) seems to support it.
     * MinGW wraps it in !defined(__STRICT_ANSI__).
+    * OpenWatcom wraps it in !defined(_NO_EXT_KEYS).
 
 This can be reviewed as compatibility issues arise. The preference is to use _wfopen_s() and _wfopen() as opposed to the wcsrtombs()
 fallback, so if you notice your compiler not detecting this properly I'm happy to look at adding support.
 */
 #if defined(_WIN32)
-    #if defined(_MSC_VER) || defined(__MINGW64__) || !defined(__STRICT_ANSI__)
+    #if defined(_MSC_VER) || defined(__MINGW64__) || (!defined(__STRICT_ANSI__) && !defined(_NO_EXT_KEYS))
         #define DRMP3_HAS_WFOPEN
     #endif
 #endif
 
 static drmp3_result drmp3_wfopen(FILE** ppFile, const wchar_t* pFilePath, const wchar_t* pOpenMode, const drmp3_allocation_callbacks* pAllocationCallbacks)
 {
     if (ppFile != NULL) {
@@ -3311,18 +3419,31 @@
             return drmp3_result_from_errno(errno);
         }
     #endif
         (void)pAllocationCallbacks;
     }
 #else
     /*
-    Use fopen() on anything other than Windows. Requires a conversion. This is annoying because fopen() is locale specific. The only real way I can
-    think of to do this is with wcsrtombs(). Note that wcstombs() is apparently not thread-safe because it uses a static global mbstate_t object for
-    maintaining state. I've checked this with -std=c89 and it works, but if somebody get's a compiler error I'll look into improving compatibility.
+    Use fopen() on anything other than Windows. Requires a conversion. This is annoying because
+	fopen() is locale specific. The only real way I can think of to do this is with wcsrtombs(). Note
+	that wcstombs() is apparently not thread-safe because it uses a static global mbstate_t object for
+    maintaining state. I've checked this with -std=c89 and it works, but if somebody get's a compiler
+	error I'll look into improving compatibility.
     */
+
+	/*
+	Some compilers don't support wchar_t or wcsrtombs() which we're using below. In this case we just
+	need to abort with an error. If you encounter a compiler lacking such support, add it to this list
+	and submit a bug report and it'll be added to the library upstream.
+	*/
+	#if defined(__DJGPP__)
+	{
+		/* Nothing to do here. This will fall through to the error check below. */
+	}
+	#else
     {
         mbstate_t mbs;
         size_t lenMB;
         const wchar_t* pFilePathTemp = pFilePath;
         char* pFilePathMB = NULL;
         char pOpenModeMB[32] = {0};
 
@@ -3356,14 +3477,15 @@
             }
         }
 
         *ppFile = fopen(pFilePathMB, pOpenModeMB);
 
         drmp3__free_from_callbacks(pFilePathMB, pAllocationCallbacks);
     }
+	#endif
 
     if (*ppFile == NULL) {
         return DRMP3_ERROR;
     }
 #endif
 
     return DRMP3_SUCCESS;
@@ -3379,42 +3501,62 @@
 static drmp3_bool32 drmp3__on_seek_stdio(void* pUserData, int offset, drmp3_seek_origin origin)
 {
     return fseek((FILE*)pUserData, offset, (origin == drmp3_seek_origin_current) ? SEEK_CUR : SEEK_SET) == 0;
 }
 
 DRMP3_API drmp3_bool32 drmp3_init_file(drmp3* pMP3, const char* pFilePath, const drmp3_allocation_callbacks* pAllocationCallbacks)
 {
+    drmp3_bool32 result;
     FILE* pFile;
+
     if (drmp3_fopen(&pFile, pFilePath, "rb") != DRMP3_SUCCESS) {
         return DRMP3_FALSE;
     }
 
-    return drmp3_init(pMP3, drmp3__on_read_stdio, drmp3__on_seek_stdio, (void*)pFile, pAllocationCallbacks);
+    result = drmp3_init(pMP3, drmp3__on_read_stdio, drmp3__on_seek_stdio, (void*)pFile, pAllocationCallbacks);
+    if (result != DRMP3_TRUE) {
+        fclose(pFile);
+        return result;
+    }
+
+    return DRMP3_TRUE;
 }
 
 DRMP3_API drmp3_bool32 drmp3_init_file_w(drmp3* pMP3, const wchar_t* pFilePath, const drmp3_allocation_callbacks* pAllocationCallbacks)
 {
+    drmp3_bool32 result;
     FILE* pFile;
+
     if (drmp3_wfopen(&pFile, pFilePath, L"rb", pAllocationCallbacks) != DRMP3_SUCCESS) {
         return DRMP3_FALSE;
     }
 
-    return drmp3_init(pMP3, drmp3__on_read_stdio, drmp3__on_seek_stdio, (void*)pFile, pAllocationCallbacks);
+    result = drmp3_init(pMP3, drmp3__on_read_stdio, drmp3__on_seek_stdio, (void*)pFile, pAllocationCallbacks);
+    if (result != DRMP3_TRUE) {
+        fclose(pFile);
+        return result;
+    }
+
+    return DRMP3_TRUE;
 }
 #endif
 
 DRMP3_API void drmp3_uninit(drmp3* pMP3)
 {
     if (pMP3 == NULL) {
         return;
     }
     
 #ifndef DR_MP3_NO_STDIO
     if (pMP3->onRead == drmp3__on_read_stdio) {
-        fclose((FILE*)pMP3->pUserData);
+        FILE* pFile = (FILE*)pMP3->pUserData;
+        if (pFile != NULL) {
+            fclose(pFile);
+            pMP3->pUserData = NULL; /* Make sure the file handle is cleared to NULL to we don't attempt to close it a second time. */
+        }
     }
 #endif
 
     drmp3__free_from_callbacks(pMP3->pData, &pMP3->allocationCallbacks);
 }
 
 #if defined(DR_MP3_FLOAT_OUTPUT)
@@ -3494,14 +3636,15 @@
             /* s16 */
             drmp3_int16* pFramesOutS16 = (drmp3_int16*)DRMP3_OFFSET_PTR(pBufferOut,          sizeof(drmp3_int16) * totalFramesRead                   * pMP3->channels);
             drmp3_int16* pFramesInS16  = (drmp3_int16*)DRMP3_OFFSET_PTR(&pMP3->pcmFrames[0], sizeof(drmp3_int16) * pMP3->pcmFramesConsumedInMP3Frame * pMP3->mp3FrameChannels);
             DRMP3_COPY_MEMORY(pFramesOutS16, pFramesInS16, sizeof(drmp3_int16) * framesToConsume * pMP3->channels);
         #endif
         }
 
+        pMP3->currentPCMFrame              += framesToConsume;
         pMP3->pcmFramesConsumedInMP3Frame  += framesToConsume;
         pMP3->pcmFramesRemainingInMP3Frame -= framesToConsume;
         totalFramesRead                    += framesToConsume;
         framesToRead                       -= framesToConsume;
 
         if (framesToRead == 0) {
             break;
@@ -3546,15 +3689,15 @@
             }
 
             framesJustRead = drmp3_read_pcm_frames_raw(pMP3, framesToReadNow, pTempS16);
             if (framesJustRead == 0) {
                 break;
             }
 
-            drmp3_s16_to_f32((float*)DRMP3_OFFSET_PTR(pBufferOut, sizeof(drmp3_int16) * totalPCMFramesRead * pMP3->channels), pTempS16, framesJustRead * pMP3->channels);
+            drmp3_s16_to_f32((float*)DRMP3_OFFSET_PTR(pBufferOut, sizeof(float) * totalPCMFramesRead * pMP3->channels), pTempS16, framesJustRead * pMP3->channels);
             totalPCMFramesRead += framesJustRead;
         }
 
         return totalPCMFramesRead;
     }
 #endif
 }
@@ -3728,16 +3871,16 @@
 
         /* Pass in non-null for the last frame because we want to ensure the sample rate converter is preloaded correctly. */
         pPCMFrames = NULL;
         if (iMP3Frame == seekPoint.mp3FramesToDiscard-1) {
             pPCMFrames = (drmp3d_sample_t*)pMP3->pcmFrames;
         }
 
-        /* We first need to decode the next frame, and then we need to flush the resampler. */
-        pcmFramesRead = drmp3_decode_next_frame_ex(pMP3, pPCMFrames, DRMP3_TRUE);
+        /* We first need to decode the next frame. */
+        pcmFramesRead = drmp3_decode_next_frame_ex(pMP3, pPCMFrames);
         if (pcmFramesRead == 0) {
             return DRMP3_FALSE;
         }
     }
 
     /* We seeked to an MP3 frame in the raw stream so we need to make sure the current PCM frame is set correctly. */
     pMP3->currentPCMFrame = seekPoint.pcmFrameIndex - seekPoint.pcmFramesToDiscard;
@@ -3769,15 +3912,14 @@
 }
 
 DRMP3_API drmp3_bool32 drmp3_get_mp3_and_pcm_frame_count(drmp3* pMP3, drmp3_uint64* pMP3FrameCount, drmp3_uint64* pPCMFrameCount)
 {
     drmp3_uint64 currentPCMFrame;
     drmp3_uint64 totalPCMFrameCount;
     drmp3_uint64 totalMP3FrameCount;
-    float totalPCMFrameCountFractionalPart;
 
     if (pMP3 == NULL) {
         return DRMP3_FALSE;
     }
 
     /*
     The way this works is we move back to the start of the stream, iterate over each MP3 frame and calculate the frame count based
@@ -3795,33 +3937,23 @@
     if (!drmp3_seek_to_start_of_stream(pMP3)) {
         return DRMP3_FALSE;
     }
 
     totalPCMFrameCount = 0;
     totalMP3FrameCount = 0;
 
-    totalPCMFrameCountFractionalPart = 0; /* <-- With resampling there will be a fractional part to each MP3 frame that we need to accumulate. */
     for (;;) {
-        drmp3_uint32 pcmFramesInCurrentMP3FrameIn;
-        float srcRatio;
-        float pcmFramesInCurrentMP3FrameOutF;
-        drmp3_uint32 pcmFramesInCurrentMP3FrameOut;
+        drmp3_uint32 pcmFramesInCurrentMP3Frame;
 
-        pcmFramesInCurrentMP3FrameIn = drmp3_decode_next_frame_ex(pMP3, NULL, DRMP3_FALSE);
-        if (pcmFramesInCurrentMP3FrameIn == 0) {
+        pcmFramesInCurrentMP3Frame = drmp3_decode_next_frame_ex(pMP3, NULL);
+        if (pcmFramesInCurrentMP3Frame == 0) {
             break;
         }
 
-        srcRatio = (float)pMP3->mp3FrameSampleRate / (float)pMP3->sampleRate;
-        DRMP3_ASSERT(srcRatio > 0);
-
-        pcmFramesInCurrentMP3FrameOutF = totalPCMFrameCountFractionalPart + (pcmFramesInCurrentMP3FrameIn / srcRatio);
-        pcmFramesInCurrentMP3FrameOut  = (drmp3_uint32)pcmFramesInCurrentMP3FrameOutF;
-        totalPCMFrameCountFractionalPart = pcmFramesInCurrentMP3FrameOutF - pcmFramesInCurrentMP3FrameOut;
-        totalPCMFrameCount += pcmFramesInCurrentMP3FrameOut;
+        totalPCMFrameCount += pcmFramesInCurrentMP3Frame;
         totalMP3FrameCount += 1;
     }
 
     /* Finally, we need to seek back to where we were. */
     if (!drmp3_seek_to_start_of_stream(pMP3)) {
         return DRMP3_FALSE;
     }
@@ -3946,15 +4078,15 @@
 
             /* The byte position of the next frame will be the stream's cursor position, minus whatever is sitting in the buffer. */
             DRMP3_ASSERT(pMP3->streamCursor >= pMP3->dataSize);
             mp3FrameInfo[iMP3Frame].bytePos       = pMP3->streamCursor - pMP3->dataSize;
             mp3FrameInfo[iMP3Frame].pcmFrameIndex = runningPCMFrameCount;
 
             /* We need to get information about this frame so we can know how many samples it contained. */
-            pcmFramesInCurrentMP3FrameIn = drmp3_decode_next_frame_ex(pMP3, NULL, DRMP3_FALSE);
+            pcmFramesInCurrentMP3FrameIn = drmp3_decode_next_frame_ex(pMP3, NULL);
             if (pcmFramesInCurrentMP3FrameIn == 0) {
                 return DRMP3_FALSE; /* This should never happen. */
             }
 
             drmp3__accumulate_running_pcm_frame_count(pMP3, pcmFramesInCurrentMP3FrameIn, &runningPCMFrameCount, &runningPCMFrameCountFractionalPart);
         }
 
@@ -3990,15 +4122,15 @@
                     mp3FrameInfo[DRMP3_COUNTOF(mp3FrameInfo)-1].bytePos       = pMP3->streamCursor - pMP3->dataSize;
                     mp3FrameInfo[DRMP3_COUNTOF(mp3FrameInfo)-1].pcmFrameIndex = runningPCMFrameCount;
 
                     /*
                     Go to the next MP3 frame. This shouldn't ever fail, but just in case it does we just set the seek point and break. If it happens, it
                     should only ever do it for the last seek point.
                     */
-                    pcmFramesInCurrentMP3FrameIn = drmp3_decode_next_frame_ex(pMP3, NULL, DRMP3_TRUE);
+                    pcmFramesInCurrentMP3FrameIn = drmp3_decode_next_frame_ex(pMP3, NULL);
                     if (pcmFramesInCurrentMP3FrameIn == 0) {
                         pSeekPoints[iSeekPoint].seekPosInBytes     = mp3FrameInfo[0].bytePos;
                         pSeekPoints[iSeekPoint].pcmFrameIndex      = nextTargetPCMFrame;
                         pSeekPoints[iSeekPoint].mp3FramesToDiscard = DRMP3_SEEK_LEADING_MP3_FRAMES;
                         pSeekPoints[iSeekPoint].pcmFramesToDiscard = (drmp3_uint16)(nextTargetPCMFrame - mp3FrameInfo[DRMP3_SEEK_LEADING_MP3_FRAMES-1].pcmFrameIndex);
                         break;
                     }
@@ -4046,17 +4178,14 @@
     drmp3_uint64 totalFramesRead = 0;
     drmp3_uint64 framesCapacity = 0;
     float* pFrames = NULL;
     float temp[4096];
 
     DRMP3_ASSERT(pMP3 != NULL);
 
-    pConfig->channels   = pMP3->channels;
-    pConfig->sampleRate = pMP3->sampleRate;
-
     for (;;) {
         drmp3_uint64 framesToReadRightNow = DRMP3_COUNTOF(temp) / pMP3->channels;
         drmp3_uint64 framesJustRead = drmp3_read_pcm_frames_f32(pMP3, framesToReadRightNow, temp);
         if (framesJustRead == 0) {
             break;
         }
 
@@ -4070,15 +4199,15 @@
             newFramesCap = framesCapacity * 2;
             if (newFramesCap < totalFramesRead + framesJustRead) {
                 newFramesCap = totalFramesRead + framesJustRead;
             }
 
             oldFramesBufferSize = framesCapacity * pMP3->channels * sizeof(float);
             newFramesBufferSize = newFramesCap   * pMP3->channels * sizeof(float);
-            if (newFramesBufferSize > DRMP3_SIZE_MAX) {
+            if (newFramesBufferSize > (drmp3_uint64)DRMP3_SIZE_MAX) {
                 break;
             }
 
             pNewFrames = (float*)drmp3__realloc_from_callbacks(pFrames, (size_t)newFramesBufferSize, (size_t)oldFramesBufferSize, &pMP3->allocationCallbacks);
             if (pNewFrames == NULL) {
                 drmp3__free_from_callbacks(pFrames, &pMP3->allocationCallbacks);
                 break;
@@ -4094,15 +4223,15 @@
         /* If the number of frames we asked for is less that what we actually read it means we've reached the end. */
         if (framesJustRead != framesToReadRightNow) {
             break;
         }
     }
 
     if (pConfig != NULL) {
-        pConfig->channels = pMP3->channels;
+        pConfig->channels   = pMP3->channels;
         pConfig->sampleRate = pMP3->sampleRate;
     }
 
     drmp3_uninit(pMP3);
 
     if (pTotalFrameCount) {
         *pTotalFrameCount = totalFramesRead;
@@ -4116,17 +4245,14 @@
     drmp3_uint64 totalFramesRead = 0;
     drmp3_uint64 framesCapacity = 0;
     drmp3_int16* pFrames = NULL;
     drmp3_int16 temp[4096];
 
     DRMP3_ASSERT(pMP3 != NULL);
 
-    pConfig->channels   = pMP3->channels;
-    pConfig->sampleRate = pMP3->sampleRate;
-
     for (;;) {
         drmp3_uint64 framesToReadRightNow = DRMP3_COUNTOF(temp) / pMP3->channels;
         drmp3_uint64 framesJustRead = drmp3_read_pcm_frames_s16(pMP3, framesToReadRightNow, temp);
         if (framesJustRead == 0) {
             break;
         }
 
@@ -4140,15 +4266,15 @@
             newFramesCap = framesCapacity * 2;
             if (newFramesCap < totalFramesRead + framesJustRead) {
                 newFramesCap = totalFramesRead + framesJustRead;
             }
 
             oldFramesBufferSize = framesCapacity * pMP3->channels * sizeof(drmp3_int16);
             newFramesBufferSize = newFramesCap   * pMP3->channels * sizeof(drmp3_int16);
-            if (newFramesBufferSize > DRMP3_SIZE_MAX) {
+            if (newFramesBufferSize > (drmp3_uint64)DRMP3_SIZE_MAX) {
                 break;
             }
 
             pNewFrames = (drmp3_int16*)drmp3__realloc_from_callbacks(pFrames, (size_t)newFramesBufferSize, (size_t)oldFramesBufferSize, &pMP3->allocationCallbacks);
             if (pNewFrames == NULL) {
                 drmp3__free_from_callbacks(pFrames, &pMP3->allocationCallbacks);
                 break;
@@ -4164,15 +4290,15 @@
         /* If the number of frames we asked for is less that what we actually read it means we've reached the end. */
         if (framesJustRead != framesToReadRightNow) {
             break;
         }
     }
 
     if (pConfig != NULL) {
-        pConfig->channels = pMP3->channels;
+        pConfig->channels   = pMP3->channels;
         pConfig->sampleRate = pMP3->sampleRate;
     }
 
     drmp3_uninit(pMP3);
 
     if (pTotalFrameCount) {
         *pTotalFrameCount = totalFramesRead;
@@ -4260,15 +4386,16 @@
     if (pAllocationCallbacks != NULL) {
         drmp3__free_from_callbacks(p, pAllocationCallbacks);
     } else {
         drmp3__free_default(p, NULL);
     }
 }
 
-#endif /*DR_MP3_IMPLEMENTATION*/
+#endif  /* dr_mp3_c */
+#endif  /*DR_MP3_IMPLEMENTATION*/
 
 /*
 DIFFERENCES BETWEEN minimp3 AND dr_mp3
 ======================================
 - First, keep in mind that minimp3 (https://github.com/lieff/minimp3) is where all the real work was done. All of the
   code relating to the actual decoding remains mostly unmodified, apart from some namespacing changes.
 - dr_mp3 adds a pulling style API which allows you to deliver raw data via callbacks. So, rather than pushing data
@@ -4345,14 +4472,126 @@
     drmp3_open_file_and_read_f32()   -> drmp3_open_file_and_read_pcm_frames_f32()
     drmp3_open_file_and_read_s16()   -> drmp3_open_file_and_read_pcm_frames_s16()
 */
 
 /*
 REVISION HISTORY
 ================
+v0.6.34 - 2022-09-17
+  - Fix compilation with DJGPP.
+  - Fix compilation when compiling with x86 with no SSE2.
+  - Remove an unnecessary variable from the drmp3 structure.
+
+v0.6.33 - 2022-04-10
+  - Fix compilation error with the MSVC ARM64 build.
+  - Fix compilation error on older versions of GCC.
+  - Remove some unused functions.
+
+v0.6.32 - 2021-12-11
+  - Fix a warning with Clang.
+
+v0.6.31 - 2021-08-22
+  - Fix a bug when loading from memory.
+
+v0.6.30 - 2021-08-16
+  - Silence some warnings.
+  - Replace memory operations with DRMP3_* macros.
+
+v0.6.29 - 2021-08-08
+  - Bring up to date with minimp3.
+
+v0.6.28 - 2021-07-31
+  - Fix platform detection for ARM64.
+  - Fix a compilation error with C89.
+
+v0.6.27 - 2021-02-21
+  - Fix a warning due to referencing _MSC_VER when it is undefined.
+
+v0.6.26 - 2021-01-31
+  - Bring up to date with minimp3.
+
+v0.6.25 - 2020-12-26
+  - Remove DRMP3_DEFAULT_CHANNELS and DRMP3_DEFAULT_SAMPLE_RATE which are leftovers from some removed APIs.
+
+v0.6.24 - 2020-12-07
+  - Fix a typo in version date for 0.6.23.
+
+v0.6.23 - 2020-12-03
+  - Fix an error where a file can be closed twice when initialization of the decoder fails.
+
+v0.6.22 - 2020-12-02
+  - Fix an error where it's possible for a file handle to be left open when initialization of the decoder fails.
+
+v0.6.21 - 2020-11-28
+  - Bring up to date with minimp3.
+
+v0.6.20 - 2020-11-21
+  - Fix compilation with OpenWatcom.
+
+v0.6.19 - 2020-11-13
+  - Minor code clean up.
+
+v0.6.18 - 2020-11-01
+  - Improve compiler support for older versions of GCC.
+
+v0.6.17 - 2020-09-28
+  - Bring up to date with minimp3.
+
+v0.6.16 - 2020-08-02
+  - Simplify sized types.
+
+v0.6.15 - 2020-07-25
+  - Fix a compilation warning.
+
+v0.6.14 - 2020-07-23
+  - Fix undefined behaviour with memmove().
+
+v0.6.13 - 2020-07-06
+  - Fix a bug when converting from s16 to f32 in drmp3_read_pcm_frames_f32().
+
+v0.6.12 - 2020-06-23
+  - Add include guard for the implementation section.
+
+v0.6.11 - 2020-05-26
+  - Fix use of uninitialized variable error.
+
+v0.6.10 - 2020-05-16
+  - Add compile-time and run-time version querying.
+    - DRMP3_VERSION_MINOR
+    - DRMP3_VERSION_MAJOR
+    - DRMP3_VERSION_REVISION
+    - DRMP3_VERSION_STRING
+    - drmp3_version()
+    - drmp3_version_string()
+
+v0.6.9 - 2020-04-30
+  - Change the `pcm` parameter of drmp3dec_decode_frame() to a `const drmp3_uint8*` for consistency with internal APIs.
+
+v0.6.8 - 2020-04-26
+  - Optimizations to decoding when initializing from memory.
+
+v0.6.7 - 2020-04-25
+  - Fix a compilation error with DR_MP3_NO_STDIO
+  - Optimization to decoding by reducing some data movement.
+
+v0.6.6 - 2020-04-23
+  - Fix a minor bug with the running PCM frame counter.
+
+v0.6.5 - 2020-04-19
+  - Fix compilation error on ARM builds.
+
+v0.6.4 - 2020-04-19
+  - Bring up to date with changes to minimp3.
+
+v0.6.3 - 2020-04-13
+  - Fix some pedantic warnings.
+
+v0.6.2 - 2020-04-10
+  - Fix a crash in drmp3_open_*_and_read_pcm_frames_*() if the output config object is NULL.
+
 v0.6.1 - 2020-04-05
   - Fix warnings.
 
 v0.6.0 - 2020-04-04
   - API CHANGE: Remove the pConfig parameter from the following APIs:
     - drmp3_init()
     - drmp3_init_memory()
```

### Comparing `tinyusdz-0.8.0rc0/src/external/dr_wav.h` & `tinyusdz-0.8.0rc1/src/external/dr_wav.h`

 * *Files 21% similar despite different names*

```diff
@@ -1,50 +1,31 @@
 /*
 WAV audio loader and writer. Choice of public domain or MIT-0. See license statements at the end of this file.
-dr_wav - v0.12.0 - 2020-04-04
+dr_wav - v0.13.7 - 2022-09-17
 
 David Reid - mackron@gmail.com
 
 GitHub: https://github.com/mackron/dr_libs
 */
 
 /*
-RELEASE NOTES - VERSION 0.12
-============================
-Version 0.12 includes breaking changes to custom chunk handling.
-
-
-Changes to Chunk Callback
--------------------------
-dr_wav supports the ability to fire a callback when a chunk is encounted (except for WAVE and FMT chunks). The callback has been update to include both the
-container (RIFF or Wave64) and the FMT chunk which contains information about the format of the data in the wave file.
-
-Previously, there was no direct way to determine the container, and therefore no way discriminate against the different IDs in the chunk header (RIFF and
-Wave64 containers encode chunk ID's differently). The `container` parameter can be used to know which ID to use.
-
-Sometimes it can be useful to know the data format at the time the chunk callback is fired. A pointer to a `drwav_fmt` object is now passed into the chunk
-callback which will give you information about the data format. To determine the sample format, use `drwav_fmt_get_format()`. This will return one of the
-`DR_WAVE_FORMAT_*` tokens.
-*/
-
-/*
 Introduction
 ============
 This is a single file library. To use it, do something like the following in one .c file.
-    
+
     ```c
     #define DR_WAV_IMPLEMENTATION
     #include "dr_wav.h"
     ```
 
 You can then #include this file in other parts of the program as you would with any other header file. Do something like the following to read audio data:
 
     ```c
     drwav wav;
-    if (!drwav_init_file(&wav, "my_song.wav")) {
+    if (!drwav_init_file(&wav, "my_song.wav", NULL)) {
         // Error opening WAV file.
     }
 
     drwav_int32* pDecodedInterleavedPCMFrames = malloc(wav.totalPCMFrameCount * wav.channels * sizeof(drwav_int32));
     size_t numberOfSamplesActuallyDecoded = drwav_read_pcm_frames_s32(&wav, wav.totalPCMFrameCount, pDecodedInterleavedPCMFrames);
 
     ...
@@ -54,22 +35,22 @@
 
 If you just want to quickly open and read the audio data in a single operation you can do something like this:
 
     ```c
     unsigned int channels;
     unsigned int sampleRate;
     drwav_uint64 totalPCMFrameCount;
-    float* pSampleData = drwav_open_file_and_read_pcm_frames_f32("my_song.wav", &channels, &sampleRate, &totalPCMFrameCount);
+    float* pSampleData = drwav_open_file_and_read_pcm_frames_f32("my_song.wav", &channels, &sampleRate, &totalPCMFrameCount, NULL);
     if (pSampleData == NULL) {
         // Error opening and reading WAV file.
     }
 
     ...
 
-    drwav_free(pSampleData);
+    drwav_free(pSampleData, NULL);
     ```
 
 The examples above use versions of the API that convert the audio data to a consistent format (32-bit signed PCM, in this case), but you can still output the
 audio data in its internal format (see notes below for supported formats):
 
     ```c
     size_t framesRead = drwav_read_pcm_frames(&wav, wav.totalPCMFrameCount, pDecodedInterleavedPCMFrames);
@@ -107,14 +88,17 @@
 
 #define DR_WAV_NO_CONVERSION_API
   Disables conversion APIs such as `drwav_read_pcm_frames_f32()` and `drwav_s16_to_f32()`.
 
 #define DR_WAV_NO_STDIO
   Disables APIs that initialize a decoder from a file such as `drwav_init_file()`, `drwav_init_file_write()`, etc.
 
+#define DR_WAV_NO_WCHAR
+  Disables all functions ending with `_w`. Use this if your compiler does not provide wchar.h. Not required if DR_WAV_NO_STDIO is also defined.
+
 
 
 Notes
 =====
 - Samples are always interleaved.
 - The default read function does not do any data conversion. Use `drwav_read_pcm_frames_f32()`, `drwav_read_pcm_frames_s32()` and `drwav_read_pcm_frames_s16()`
   to read and convert audio data to 32-bit floating point, signed 32-bit integer and signed 16-bit integer samples respectively. Tested and supported internal
@@ -135,50 +119,57 @@
 #ifndef dr_wav_h
 #define dr_wav_h
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
+#define DRWAV_STRINGIFY(x)      #x
+#define DRWAV_XSTRINGIFY(x)     DRWAV_STRINGIFY(x)
+
+#define DRWAV_VERSION_MAJOR     0
+#define DRWAV_VERSION_MINOR     13
+#define DRWAV_VERSION_REVISION  7
+#define DRWAV_VERSION_STRING    DRWAV_XSTRINGIFY(DRWAV_VERSION_MAJOR) "." DRWAV_XSTRINGIFY(DRWAV_VERSION_MINOR) "." DRWAV_XSTRINGIFY(DRWAV_VERSION_REVISION)
+
 #include <stddef.h> /* For size_t. */
 
-/* Sized types. Prefer built-in types. Fall back to stdint. */
-#ifdef _MSC_VER
-    #if defined(__clang__)
+/* Sized types. */
+typedef   signed char           drwav_int8;
+typedef unsigned char           drwav_uint8;
+typedef   signed short          drwav_int16;
+typedef unsigned short          drwav_uint16;
+typedef   signed int            drwav_int32;
+typedef unsigned int            drwav_uint32;
+#if defined(_MSC_VER) && !defined(__clang__)
+    typedef   signed __int64    drwav_int64;
+    typedef unsigned __int64    drwav_uint64;
+#else
+    #if defined(__clang__) || (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)))
         #pragma GCC diagnostic push
-        #pragma GCC diagnostic ignored "-Wlanguage-extension-token"
-        #pragma GCC diagnostic ignored "-Wlong-long"        
-        #pragma GCC diagnostic ignored "-Wc++11-long-long"
-    #endif
-    typedef   signed __int8  drwav_int8;
-    typedef unsigned __int8  drwav_uint8;
-    typedef   signed __int16 drwav_int16;
-    typedef unsigned __int16 drwav_uint16;
-    typedef   signed __int32 drwav_int32;
-    typedef unsigned __int32 drwav_uint32;
-    typedef   signed __int64 drwav_int64;
-    typedef unsigned __int64 drwav_uint64;
-    #if defined(__clang__)
+        #pragma GCC diagnostic ignored "-Wlong-long"
+        #if defined(__clang__)
+            #pragma GCC diagnostic ignored "-Wc++11-long-long"
+        #endif
+    #endif
+    typedef   signed long long  drwav_int64;
+    typedef unsigned long long  drwav_uint64;
+    #if defined(__clang__) || (defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)))
         #pragma GCC diagnostic pop
     #endif
+#endif
+#if defined(__LP64__) || defined(_WIN64) || (defined(__x86_64__) && !defined(__ILP32__)) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(_M_ARM64) || defined(__powerpc64__)
+    typedef drwav_uint64        drwav_uintptr;
 #else
-    #include <stdint.h>
-    typedef int8_t           drwav_int8;
-    typedef uint8_t          drwav_uint8;
-    typedef int16_t          drwav_int16;
-    typedef uint16_t         drwav_uint16;
-    typedef int32_t          drwav_int32;
-    typedef uint32_t         drwav_uint32;
-    typedef int64_t          drwav_int64;
-    typedef uint64_t         drwav_uint64;
-#endif
-typedef drwav_uint8          drwav_bool8;
-typedef drwav_uint32         drwav_bool32;
-#define DRWAV_TRUE           1
-#define DRWAV_FALSE          0
+    typedef drwav_uint32        drwav_uintptr;
+#endif
+typedef drwav_uint8             drwav_bool8;
+typedef drwav_uint32            drwav_bool32;
+#define DRWAV_TRUE              1
+#define DRWAV_FALSE             0
 
 #if !defined(DRWAV_API)
     #if defined(DRWAV_DLL)
         #if defined(_WIN32)
             #define DRWAV_DLL_IMPORT  __declspec(dllimport)
             #define DRWAV_DLL_EXPORT  __declspec(dllexport)
             #define DRWAV_DLL_PRIVATE static
@@ -267,32 +258,31 @@
 #define DR_WAVE_FORMAT_ADPCM        0x2
 #define DR_WAVE_FORMAT_IEEE_FLOAT   0x3
 #define DR_WAVE_FORMAT_ALAW         0x6
 #define DR_WAVE_FORMAT_MULAW        0x7
 #define DR_WAVE_FORMAT_DVI_ADPCM    0x11
 #define DR_WAVE_FORMAT_EXTENSIBLE   0xFFFE
 
-/* Constants. */
-#ifndef DRWAV_MAX_SMPL_LOOPS
-#define DRWAV_MAX_SMPL_LOOPS        1
-#endif
-
 /* Flags to pass into drwav_init_ex(), etc. */
 #define DRWAV_SEQUENTIAL            0x00000001
 
+DRWAV_API void drwav_version(drwav_uint32* pMajor, drwav_uint32* pMinor, drwav_uint32* pRevision);
+DRWAV_API const char* drwav_version_string(void);
+
 typedef enum
 {
     drwav_seek_origin_start,
     drwav_seek_origin_current
 } drwav_seek_origin;
 
 typedef enum
 {
     drwav_container_riff,
-    drwav_container_w64
+    drwav_container_w64,
+    drwav_container_rf64
 } drwav_container;
 
 typedef struct
 {
     union
     {
         drwav_uint8 fourcc[4];
@@ -405,19 +395,19 @@
 pFMT              [in] A pointer to the object containing the contents of the "fmt" chunk.
 
 Returns the number of bytes read + seeked.
 
 To read data from the chunk, call onRead(), passing in pReadSeekUserData as the first parameter. Do the same for seeking with onSeek(). The return value must
 be the total number of bytes you have read _plus_ seeked.
 
-Use the `container` argument to discriminate the fields in `pChunkHeader->id`. If the container is `drwav_container_riff` you should use `id.fourcc`,
-otherwise you should use `id.guid`.
+Use the `container` argument to discriminate the fields in `pChunkHeader->id`. If the container is `drwav_container_riff` or `drwav_container_rf64` you should
+use `id.fourcc`, otherwise you should use `id.guid`.
 
 The `pFMT` parameter can be used to determine the data format of the wave file. Use `drwav_fmt_get_format()` to get the sample format, which will be one of the
-`DR_WAVE_FORMAT_*` identifiers. 
+`DR_WAVE_FORMAT_*` identifiers.
 
 The read pointer will be sitting on the first byte after the chunk's header. You must not attempt to read beyond the boundary of the chunk.
 */
 typedef drwav_uint64 (* drwav_chunk_proc)(void* pChunkUserData, drwav_read_proc onRead, drwav_seek_proc onSeek, void* pReadSeekUserData, const drwav_chunk_header* pChunkHeader, drwav_container container, const drwav_fmt* pFMT);
 
 typedef struct
 {
@@ -450,40 +440,375 @@
     drwav_container container;  /* RIFF, W64. */
     drwav_uint32 format;        /* DR_WAVE_FORMAT_* */
     drwav_uint32 channels;
     drwav_uint32 sampleRate;
     drwav_uint32 bitsPerSample;
 } drwav_data_format;
 
+typedef enum
+{
+    drwav_metadata_type_none                        = 0,
+
+    /*
+    Unknown simply means a chunk that drwav does not handle specifically. You can still ask to
+    receive these chunks as metadata objects. It is then up to you to interpret the chunk's data.
+    You can also write unknown metadata to a wav file. Be careful writing unknown chunks if you
+    have also edited the audio data. The unknown chunks could represent offsets/sizes that no
+    longer correctly correspond to the audio data.
+    */
+    drwav_metadata_type_unknown                     = 1 << 0,
+
+    /* Only 1 of each of these metadata items are allowed in a wav file. */
+    drwav_metadata_type_smpl                        = 1 << 1,
+    drwav_metadata_type_inst                        = 1 << 2,
+    drwav_metadata_type_cue                         = 1 << 3,
+    drwav_metadata_type_acid                        = 1 << 4,
+    drwav_metadata_type_bext                        = 1 << 5,
+
+    /*
+    Wav files often have a LIST chunk. This is a chunk that contains a set of subchunks. For this
+    higher-level metadata API, we don't make a distinction between a regular chunk and a LIST
+    subchunk. Instead, they are all just 'metadata' items.
+
+    There can be multiple of these metadata items in a wav file.
+    */
+    drwav_metadata_type_list_label                  = 1 << 6,
+    drwav_metadata_type_list_note                   = 1 << 7,
+    drwav_metadata_type_list_labelled_cue_region    = 1 << 8,
+
+    drwav_metadata_type_list_info_software          = 1 << 9,
+    drwav_metadata_type_list_info_copyright         = 1 << 10,
+    drwav_metadata_type_list_info_title             = 1 << 11,
+    drwav_metadata_type_list_info_artist            = 1 << 12,
+    drwav_metadata_type_list_info_comment           = 1 << 13,
+    drwav_metadata_type_list_info_date              = 1 << 14,
+    drwav_metadata_type_list_info_genre             = 1 << 15,
+    drwav_metadata_type_list_info_album             = 1 << 16,
+    drwav_metadata_type_list_info_tracknumber       = 1 << 17,
+
+    /* Other type constants for convenience. */
+    drwav_metadata_type_list_all_info_strings       = drwav_metadata_type_list_info_software
+                                                    | drwav_metadata_type_list_info_copyright
+                                                    | drwav_metadata_type_list_info_title
+                                                    | drwav_metadata_type_list_info_artist
+                                                    | drwav_metadata_type_list_info_comment
+                                                    | drwav_metadata_type_list_info_date
+                                                    | drwav_metadata_type_list_info_genre
+                                                    | drwav_metadata_type_list_info_album
+                                                    | drwav_metadata_type_list_info_tracknumber,
+
+    drwav_metadata_type_list_all_adtl               = drwav_metadata_type_list_label
+                                                    | drwav_metadata_type_list_note
+                                                    | drwav_metadata_type_list_labelled_cue_region,
+
+    drwav_metadata_type_all                         = -2,   /*0xFFFFFFFF & ~drwav_metadata_type_unknown,*/
+    drwav_metadata_type_all_including_unknown       = -1    /*0xFFFFFFFF,*/
+} drwav_metadata_type;
+
+/*
+Sampler Metadata
+
+The sampler chunk contains information about how a sound should be played in the context of a whole
+audio production, and when used in a sampler. See https://en.wikipedia.org/wiki/Sample-based_synthesis.
+*/
+typedef enum
+{
+    drwav_smpl_loop_type_forward  = 0,
+    drwav_smpl_loop_type_pingpong = 1,
+    drwav_smpl_loop_type_backward = 2
+} drwav_smpl_loop_type;
 
-/* See the following for details on the 'smpl' chunk: https://sites.google.com/site/musicgapi/technical-documents/wav-file-format#smpl */
 typedef struct
 {
+    /* The ID of the associated cue point, see drwav_cue and drwav_cue_point. As with all cue point IDs, this can correspond to a label chunk to give this loop a name, see drwav_list_label_or_note. */
     drwav_uint32 cuePointId;
+
+    /* See drwav_smpl_loop_type. */
     drwav_uint32 type;
-    drwav_uint32 start;
-    drwav_uint32 end;
-    drwav_uint32 fraction;
+
+    /* The byte offset of the first sample to be played in the loop. */
+    drwav_uint32 firstSampleByteOffset;
+
+    /* The byte offset into the audio data of the last sample to be played in the loop. */
+    drwav_uint32 lastSampleByteOffset;
+
+    /* A value to represent that playback should occur at a point between samples. This value ranges from 0 to UINT32_MAX. Where a value of 0 means no fraction, and a value of (UINT32_MAX / 2) would mean half a sample. */
+    drwav_uint32 sampleFraction;
+
+    /* Number of times to play the loop. 0 means loop infinitely. */
     drwav_uint32 playCount;
 } drwav_smpl_loop;
 
- typedef struct
+typedef struct
 {
-    drwav_uint32 manufacturer;
-    drwav_uint32 product;
-    drwav_uint32 samplePeriod;
-    drwav_uint32 midiUnityNotes;
+    /* IDs for a particular MIDI manufacturer. 0 if not used. */
+    drwav_uint32 manufacturerId;
+    drwav_uint32 productId;
+
+    /* The period of 1 sample in nanoseconds. */
+    drwav_uint32 samplePeriodNanoseconds;
+
+    /* The MIDI root note of this file. 0 to 127. */
+    drwav_uint32 midiUnityNote;
+
+    /* The fraction of a semitone up from the given MIDI note. This is a value from 0 to UINT32_MAX, where 0 means no change and (UINT32_MAX / 2) is half a semitone (AKA 50 cents). */
     drwav_uint32 midiPitchFraction;
+
+    /* Data relating to SMPTE standards which are used for syncing audio and video. 0 if not used. */
     drwav_uint32 smpteFormat;
     drwav_uint32 smpteOffset;
-    drwav_uint32 numSampleLoops;
-    drwav_uint32 samplerData;
-    drwav_smpl_loop loops[DRWAV_MAX_SMPL_LOOPS];
+
+    /* drwav_smpl_loop loops. */
+    drwav_uint32 sampleLoopCount;
+
+    /* Optional sampler-specific data. */
+    drwav_uint32 samplerSpecificDataSizeInBytes;
+
+    drwav_smpl_loop* pLoops;
+    drwav_uint8* pSamplerSpecificData;
 } drwav_smpl;
 
+/*
+Instrument Metadata
+
+The inst metadata contains data about how a sound should be played as part of an instrument. This
+commonly read by samplers. See https://en.wikipedia.org/wiki/Sample-based_synthesis.
+*/
+typedef struct
+{
+    drwav_int8 midiUnityNote;   /* The root note of the audio as a MIDI note number. 0 to 127. */
+    drwav_int8 fineTuneCents;   /* -50 to +50 */
+    drwav_int8 gainDecibels;    /* -64 to +64 */
+    drwav_int8 lowNote;         /* 0 to 127 */
+    drwav_int8 highNote;        /* 0 to 127 */
+    drwav_int8 lowVelocity;     /* 1 to 127 */
+    drwav_int8 highVelocity;    /* 1 to 127 */
+} drwav_inst;
+
+/*
+Cue Metadata
+
+Cue points are markers at specific points in the audio. They often come with an associated piece of
+drwav_list_label_or_note metadata which contains the text for the marker.
+*/
+typedef struct
+{
+    /* Unique identification value. */
+    drwav_uint32 id;
+
+    /* Set to 0. This is only relevant if there is a 'playlist' chunk - which is not supported by dr_wav. */
+    drwav_uint32 playOrderPosition;
+
+    /* Should always be "data". This represents the fourcc value of the chunk that this cue point corresponds to. dr_wav only supports a single data chunk so this should always be "data". */
+    drwav_uint8 dataChunkId[4];
+
+    /* Set to 0. This is only relevant if there is a wave list chunk. dr_wav, like lots of readers/writers, do not support this. */
+    drwav_uint32 chunkStart;
+
+    /* Set to 0 for uncompressed formats. Else the last byte in compressed wave data where decompression can begin to find the value of the corresponding sample value. */
+    drwav_uint32 blockStart;
+
+    /* For uncompressed formats this is the byte offset of the cue point into the audio data. For compressed formats this is relative to the block specified with blockStart. */
+    drwav_uint32 sampleByteOffset;
+} drwav_cue_point;
+
+typedef struct
+{
+    drwav_uint32 cuePointCount;
+    drwav_cue_point *pCuePoints;
+} drwav_cue;
+
+/*
+Acid Metadata
+
+This chunk contains some information about the time signature and the tempo of the audio.
+*/
+typedef enum
+{
+    drwav_acid_flag_one_shot      = 1,  /* If this is not set, then it is a loop instead of a one-shot. */
+    drwav_acid_flag_root_note_set = 2,
+    drwav_acid_flag_stretch       = 4,
+    drwav_acid_flag_disk_based    = 8,
+    drwav_acid_flag_acidizer      = 16  /* Not sure what this means. */
+} drwav_acid_flag;
+
+typedef struct
+{
+    /* A bit-field, see drwav_acid_flag. */
+    drwav_uint32 flags;
+
+    /* Valid if flags contains drwav_acid_flag_root_note_set. It represents the MIDI root note the file - a value from 0 to 127. */
+    drwav_uint16 midiUnityNote;
+
+    /* Reserved values that should probably be ignored. reserved1 seems to often be 128 and reserved2 is 0. */
+    drwav_uint16 reserved1;
+    float reserved2;
+
+    /* Number of beats. */
+    drwav_uint32 numBeats;
+
+    /* The time signature of the audio. */
+    drwav_uint16 meterDenominator;
+    drwav_uint16 meterNumerator;
+
+    /* Beats per minute of the track. Setting a value of 0 suggests that there is no tempo. */
+    float tempo;
+} drwav_acid;
+
+/*
+Cue Label or Note metadata
+
+These are 2 different types of metadata, but they have the exact same format. Labels tend to be the
+more common and represent a short name for a cue point. Notes might be used to represent a longer
+comment.
+*/
+typedef struct
+{
+    /* The ID of a cue point that this label or note corresponds to. */
+    drwav_uint32 cuePointId;
+
+    /* Size of the string not including any null terminator. */
+    drwav_uint32 stringLength;
+
+    /* The string. The *init_with_metadata functions null terminate this for convenience. */
+    char* pString;
+} drwav_list_label_or_note;
+
+/*
+BEXT metadata, also known as Broadcast Wave Format (BWF)
+
+This metadata adds some extra description to an audio file. You must check the version field to
+determine if the UMID or the loudness fields are valid.
+*/
+typedef struct
+{
+    /*
+    These top 3 fields, and the umid field are actually defined in the standard as a statically
+    sized buffers. In order to reduce the size of this struct (and therefore the union in the
+    metadata struct), we instead store these as pointers.
+    */
+    char* pDescription;                 /* Can be NULL or a null-terminated string, must be <= 256 characters. */
+    char* pOriginatorName;              /* Can be NULL or a null-terminated string, must be <= 32 characters. */
+    char* pOriginatorReference;         /* Can be NULL or a null-terminated string, must be <= 32 characters. */
+    char  pOriginationDate[10];         /* ASCII "yyyy:mm:dd". */
+    char  pOriginationTime[8];          /* ASCII "hh:mm:ss". */
+    drwav_uint64 timeReference;         /* First sample count since midnight. */
+    drwav_uint16 version;               /* Version of the BWF, check this to see if the fields below are valid. */
+
+    /*
+    Unrestricted ASCII characters containing a collection of strings terminated by CR/LF. Each
+    string shall contain a description of a coding process applied to the audio data.
+    */
+    char* pCodingHistory;
+    drwav_uint32 codingHistorySize;
+
+    /* Fields below this point are only valid if the version is 1 or above. */
+    drwav_uint8* pUMID;                  /* Exactly 64 bytes of SMPTE UMID */
+
+    /* Fields below this point are only valid if the version is 2 or above. */
+    drwav_uint16 loudnessValue;         /* Integrated Loudness Value of the file in LUFS (multiplied by 100). */
+    drwav_uint16 loudnessRange;         /* Loudness Range of the file in LU (multiplied by 100). */
+    drwav_uint16 maxTruePeakLevel;      /* Maximum True Peak Level of the file expressed as dBTP (multiplied by 100). */
+    drwav_uint16 maxMomentaryLoudness;  /* Highest value of the Momentary Loudness Level of the file in LUFS (multiplied by 100). */
+    drwav_uint16 maxShortTermLoudness;  /* Highest value of the Short-Term Loudness Level of the file in LUFS (multiplied by 100). */
+} drwav_bext;
+
+/*
+Info Text Metadata
+
+There a many different types of information text that can be saved in this format. This is where
+things like the album name, the artists, the year it was produced, etc are saved. See
+drwav_metadata_type for the full list of types that dr_wav supports.
+*/
+typedef struct
+{
+    /* Size of the string not including any null terminator. */
+    drwav_uint32 stringLength;
+
+    /* The string. The *init_with_metadata functions null terminate this for convenience. */
+    char* pString;
+} drwav_list_info_text;
+
+/*
+Labelled Cue Region Metadata
+
+The labelled cue region metadata is used to associate some region of audio with text. The region
+starts at a cue point, and extends for the given number of samples.
+*/
+typedef struct
+{
+    /* The ID of a cue point that this object corresponds to. */
+    drwav_uint32 cuePointId;
+
+    /* The number of samples from the cue point forwards that should be considered this region */
+    drwav_uint32 sampleLength;
+
+    /* Four characters used to say what the purpose of this region is. */
+    drwav_uint8 purposeId[4];
+
+    /* Unsure of the exact meanings of these. It appears to be acceptable to set them all to 0. */
+    drwav_uint16 country;
+    drwav_uint16 language;
+    drwav_uint16 dialect;
+    drwav_uint16 codePage;
+
+    /* Size of the string not including any null terminator. */
+    drwav_uint32 stringLength;
+
+    /* The string. The *init_with_metadata functions null terminate this for convenience. */
+    char* pString;
+} drwav_list_labelled_cue_region;
+
+/*
+Unknown Metadata
+
+This chunk just represents a type of chunk that dr_wav does not understand.
+
+Unknown metadata has a location attached to it. This is because wav files can have a LIST chunk
+that contains subchunks. These LIST chunks can be one of two types. An adtl list, or an INFO
+list. This enum is used to specify the location of a chunk that dr_wav currently doesn't support.
+*/
+typedef enum
+{
+    drwav_metadata_location_invalid,
+    drwav_metadata_location_top_level,
+    drwav_metadata_location_inside_info_list,
+    drwav_metadata_location_inside_adtl_list
+} drwav_metadata_location;
+
+typedef struct
+{
+    drwav_uint8 id[4];
+    drwav_metadata_location chunkLocation;
+    drwav_uint32 dataSizeInBytes;
+    drwav_uint8* pData;
+} drwav_unknown_metadata;
+
+/*
+Metadata is saved as a union of all the supported types.
+*/
+typedef struct
+{
+    /* Determines which item in the union is valid. */
+    drwav_metadata_type type;
+
+    union
+    {
+        drwav_cue cue;
+        drwav_smpl smpl;
+        drwav_acid acid;
+        drwav_inst inst;
+        drwav_bext bext;
+        drwav_list_label_or_note labelOrNote;   /* List label or list note. */
+        drwav_list_labelled_cue_region labelledCueRegion;
+        drwav_list_info_text infoText;          /* Any of the list info types. */
+        drwav_unknown_metadata unknown;
+    } data;
+} drwav_metadata;
+
 typedef struct
 {
     /* A pointer to the function to call when more data is needed. */
     drwav_read_proc onRead;
 
     /* A pointer to the function to call when data needs to be written. Only used when the drwav object is opened in write mode. */
     drwav_write_proc onWrite;
@@ -519,46 +844,48 @@
 
     /* The total number of PCM frames making up the audio data. */
     drwav_uint64 totalPCMFrameCount;
 
 
     /* The size in bytes of the data chunk. */
     drwav_uint64 dataChunkDataSize;
-    
-    /* The position in the stream of the first byte of the data chunk. This is used for seeking. */
+
+    /* The position in the stream of the first data byte of the data chunk. This is used for seeking. */
     drwav_uint64 dataChunkDataPos;
 
     /* The number of bytes remaining in the data chunk. */
     drwav_uint64 bytesRemaining;
 
+    /* The current read position in PCM frames. */
+    drwav_uint64 readCursorInPCMFrames;
+
 
     /*
     Only used in sequential write mode. Keeps track of the desired size of the "data" chunk at the point of initialization time. Always
     set to 0 for non-sequential writes and when the drwav object is opened in read mode. Used for validation.
     */
     drwav_uint64 dataChunkDataSizeTargetWrite;
 
     /* Keeps track of whether or not the wav writer was initialized in sequential mode. */
     drwav_bool32 isSequentialWrite;
 
 
-    /* smpl chunk. */
-    drwav_smpl smpl;
+    /* A bit-field of drwav_metadata_type values, only bits set in this variable are parsed and saved */
+    drwav_metadata_type allowedMetadataTypes;
+
+    /* A array of metadata. This is valid after the *init_with_metadata call returns. It will be valid until drwav_uninit() is called. You can take ownership of this data with drwav_take_ownership_of_metadata(). */
+    drwav_metadata* pMetadata;
+    drwav_uint32 metadataCount;
 
 
     /* A hack to avoid a DRWAV_MALLOC() when opening a decoder with drwav_init_memory(). */
     drwav__memory_stream memoryStream;
     drwav__memory_stream_write memoryStreamWrite;
 
-    /* Generic data for compressed formats. This data is shared across all block-compressed formats. */
-    struct
-    {
-        drwav_uint64 iCurrentPCMFrame;  /* The index of the next PCM frame that will be read by drwav_read_*(). This is used with "totalPCMFrameCount" to ensure we don't read excess samples at the end of the last block. */
-    } compressed;
-    
+
     /* Microsoft ADPCM specific data. */
     struct
     {
         drwav_uint32 bytesRemainingInBlock;
         drwav_uint16 predictor[2];
         drwav_int32  delta[2];
         drwav_int32  cachedFrames[4];  /* Samples are stored in this cache during decoding. */
@@ -605,21 +932,23 @@
 The onChunk callback is not called for the WAVE or FMT chunks. The contents of the FMT chunk can be read from pWav->fmt
 after the function returns.
 
 See also: drwav_init_file(), drwav_init_memory(), drwav_uninit()
 */
 DRWAV_API drwav_bool32 drwav_init(drwav* pWav, drwav_read_proc onRead, drwav_seek_proc onSeek, void* pUserData, const drwav_allocation_callbacks* pAllocationCallbacks);
 DRWAV_API drwav_bool32 drwav_init_ex(drwav* pWav, drwav_read_proc onRead, drwav_seek_proc onSeek, drwav_chunk_proc onChunk, void* pReadSeekUserData, void* pChunkUserData, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks);
+DRWAV_API drwav_bool32 drwav_init_with_metadata(drwav* pWav, drwav_read_proc onRead, drwav_seek_proc onSeek, void* pUserData, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks);
 
 /*
 Initializes a pre-allocated drwav object for writing.
 
-onWrite   [in]           The function to call when data needs to be written.
-onSeek    [in]           The function to call when the write position needs to move.
-pUserData [in, optional] A pointer to application defined data that will be passed to onWrite and onSeek.
+onWrite               [in]           The function to call when data needs to be written.
+onSeek                [in]           The function to call when the write position needs to move.
+pUserData             [in, optional] A pointer to application defined data that will be passed to onWrite and onSeek.
+metadata, numMetadata [in, optional] An array of metadata objects that should be written to the file. The array is not edited. You are responsible for this metadata memory and it must maintain valid until drwav_uninit() is called.
 
 Returns true if successful; false otherwise.
 
 Close the writer with drwav_uninit().
 
 This is the lowest level function for initializing a WAV file. You can also use drwav_init_file_write() and drwav_init_memory_write()
 to open the stream from a file or from a block of memory respectively.
@@ -628,27 +957,39 @@
 a post-processing step for storing the total sample count and the size of the data chunk which requires a backwards seek.
 
 See also: drwav_init_file_write(), drwav_init_memory_write(), drwav_uninit()
 */
 DRWAV_API drwav_bool32 drwav_init_write(drwav* pWav, const drwav_data_format* pFormat, drwav_write_proc onWrite, drwav_seek_proc onSeek, void* pUserData, const drwav_allocation_callbacks* pAllocationCallbacks);
 DRWAV_API drwav_bool32 drwav_init_write_sequential(drwav* pWav, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, drwav_write_proc onWrite, void* pUserData, const drwav_allocation_callbacks* pAllocationCallbacks);
 DRWAV_API drwav_bool32 drwav_init_write_sequential_pcm_frames(drwav* pWav, const drwav_data_format* pFormat, drwav_uint64 totalPCMFrameCount, drwav_write_proc onWrite, void* pUserData, const drwav_allocation_callbacks* pAllocationCallbacks);
+DRWAV_API drwav_bool32 drwav_init_write_with_metadata(drwav* pWav, const drwav_data_format* pFormat, drwav_write_proc onWrite, drwav_seek_proc onSeek, void* pUserData, const drwav_allocation_callbacks* pAllocationCallbacks, drwav_metadata* pMetadata, drwav_uint32 metadataCount);
 
 /*
 Utility function to determine the target size of the entire data to be written (including all headers and chunks).
 
 Returns the target size in bytes.
 
+The metadata argument can be NULL meaning no metadata exists.
+
 Useful if the application needs to know the size to allocate.
 
 Only writing to the RIFF chunk and one data chunk is currently supported.
 
 See also: drwav_init_write(), drwav_init_file_write(), drwav_init_memory_write()
 */
-DRWAV_API drwav_uint64 drwav_target_write_size_bytes(const drwav_data_format* pFormat, drwav_uint64 totalSampleCount);
+DRWAV_API drwav_uint64 drwav_target_write_size_bytes(const drwav_data_format* pFormat, drwav_uint64 totalFrameCount, drwav_metadata* pMetadata, drwav_uint32 metadataCount);
+
+/*
+Take ownership of the metadata objects that were allocated via one of the init_with_metadata() function calls. The init_with_metdata functions perform a single heap allocation for this metadata.
+
+Useful if you want the data to persist beyond the lifetime of the drwav object.
+
+You must free the data returned from this function using drwav_free().
+*/
+DRWAV_API drwav_metadata* drwav_take_ownership_of_metadata(drwav* pWav);
 
 /*
 Uninitializes the given drwav object.
 
 Use this only for objects initialized with drwav_init*() functions (drwav_init(), drwav_init_ex(), drwav_init_write(), drwav_init_write_sequential()).
 */
 DRWAV_API drwav_result drwav_uninit(drwav* pWav);
@@ -659,14 +1000,16 @@
 
 This is the lowest level function for reading audio data. It simply reads the given number of
 bytes of the raw internal sample data.
 
 Consider using drwav_read_pcm_frames_s16(), drwav_read_pcm_frames_s32() or drwav_read_pcm_frames_f32() for
 reading sample data in a consistent format.
 
+pBufferOut can be NULL in which case a seek will be performed.
+
 Returns the number of bytes actually read.
 */
 DRWAV_API size_t drwav_read_raw(drwav* pWav, size_t bytesToRead, void* pBufferOut);
 
 /*
 Reads up to the specified number of PCM frames from the WAV file.
 
@@ -674,26 +1017,38 @@
 drwav_read_pcm_frames_s16/f32/s32() to read data in a specific format.
 
 If the return value is less than <framesToRead> it means the end of the file has been reached or
 you have requested more PCM frames than can possibly fit in the output buffer.
 
 This function will only work when sample data is of a fixed size and uncompressed. If you are
 using a compressed format consider using drwav_read_raw() or drwav_read_pcm_frames_s16/s32/f32().
+
+pBufferOut can be NULL in which case a seek will be performed.
 */
 DRWAV_API drwav_uint64 drwav_read_pcm_frames(drwav* pWav, drwav_uint64 framesToRead, void* pBufferOut);
 DRWAV_API drwav_uint64 drwav_read_pcm_frames_le(drwav* pWav, drwav_uint64 framesToRead, void* pBufferOut);
 DRWAV_API drwav_uint64 drwav_read_pcm_frames_be(drwav* pWav, drwav_uint64 framesToRead, void* pBufferOut);
 
 /*
 Seeks to the given PCM frame.
 
 Returns true if successful; false otherwise.
 */
 DRWAV_API drwav_bool32 drwav_seek_to_pcm_frame(drwav* pWav, drwav_uint64 targetFrameIndex);
 
+/*
+Retrieves the current read position in pcm frames.
+*/
+DRWAV_API drwav_result drwav_get_cursor_in_pcm_frames(drwav* pWav, drwav_uint64* pCursor);
+
+/*
+Retrieves the length of the file.
+*/
+DRWAV_API drwav_result drwav_get_length_in_pcm_frames(drwav* pWav, drwav_uint64* pLength);
+
 
 /*
 Writes raw audio data.
 
 Returns the number of bytes actually written. If this differs from bytesToWrite, it indicates an error.
 */
 DRWAV_API size_t drwav_write_raw(drwav* pWav, size_t bytesToWrite, const void* pData);
@@ -706,21 +1061,22 @@
 Input samples need to be in native-endian byte order. On big-endian architectures the input data will be converted to
 little-endian. Use drwav_write_raw() to write raw audio data without performing any conversion.
 */
 DRWAV_API drwav_uint64 drwav_write_pcm_frames(drwav* pWav, drwav_uint64 framesToWrite, const void* pData);
 DRWAV_API drwav_uint64 drwav_write_pcm_frames_le(drwav* pWav, drwav_uint64 framesToWrite, const void* pData);
 DRWAV_API drwav_uint64 drwav_write_pcm_frames_be(drwav* pWav, drwav_uint64 framesToWrite, const void* pData);
 
-
 /* Conversion Utilities */
 #ifndef DR_WAV_NO_CONVERSION_API
 
 /*
 Reads a chunk of audio data and converts it to signed 16-bit PCM samples.
 
+pBufferOut can be NULL in which case a seek will be performed.
+
 Returns the number of PCM frames actually read.
 
 If the return value is less than <framesToRead> it means the end of the file has been reached.
 */
 DRWAV_API drwav_uint64 drwav_read_pcm_frames_s16(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut);
 DRWAV_API drwav_uint64 drwav_read_pcm_frames_s16le(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut);
 DRWAV_API drwav_uint64 drwav_read_pcm_frames_s16be(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut);
@@ -746,14 +1102,16 @@
 /* Low-level function for converting u-law samples to signed 16-bit PCM samples. */
 DRWAV_API void drwav_mulaw_to_s16(drwav_int16* pOut, const drwav_uint8* pIn, size_t sampleCount);
 
 
 /*
 Reads a chunk of audio data and converts it to IEEE 32-bit floating point samples.
 
+pBufferOut can be NULL in which case a seek will be performed.
+
 Returns the number of PCM frames actually read.
 
 If the return value is less than <framesToRead> it means the end of the file has been reached.
 */
 DRWAV_API drwav_uint64 drwav_read_pcm_frames_f32(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut);
 DRWAV_API drwav_uint64 drwav_read_pcm_frames_f32le(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut);
 DRWAV_API drwav_uint64 drwav_read_pcm_frames_f32be(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut);
@@ -779,14 +1137,16 @@
 /* Low-level function for converting u-law samples to IEEE 32-bit floating point samples. */
 DRWAV_API void drwav_mulaw_to_f32(float* pOut, const drwav_uint8* pIn, size_t sampleCount);
 
 
 /*
 Reads a chunk of audio data and converts it to signed 32-bit PCM samples.
 
+pBufferOut can be NULL in which case a seek will be performed.
+
 Returns the number of PCM frames actually read.
 
 If the return value is less than <framesToRead> it means the end of the file has been reached.
 */
 DRWAV_API drwav_uint64 drwav_read_pcm_frames_s32(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut);
 DRWAV_API drwav_uint64 drwav_read_pcm_frames_s32le(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut);
 DRWAV_API drwav_uint64 drwav_read_pcm_frames_s32be(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut);
@@ -825,14 +1185,17 @@
 objects because the operating system may restrict the number of file handles an application can have open at
 any given time.
 */
 DRWAV_API drwav_bool32 drwav_init_file(drwav* pWav, const char* filename, const drwav_allocation_callbacks* pAllocationCallbacks);
 DRWAV_API drwav_bool32 drwav_init_file_ex(drwav* pWav, const char* filename, drwav_chunk_proc onChunk, void* pChunkUserData, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks);
 DRWAV_API drwav_bool32 drwav_init_file_w(drwav* pWav, const wchar_t* filename, const drwav_allocation_callbacks* pAllocationCallbacks);
 DRWAV_API drwav_bool32 drwav_init_file_ex_w(drwav* pWav, const wchar_t* filename, drwav_chunk_proc onChunk, void* pChunkUserData, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks);
+DRWAV_API drwav_bool32 drwav_init_file_with_metadata(drwav* pWav, const char* filename, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks);
+DRWAV_API drwav_bool32 drwav_init_file_with_metadata_w(drwav* pWav, const wchar_t* filename, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks);
+
 
 /*
 Helper for initializing a wave file for writing using stdio.
 
 This holds the internal FILE object until drwav_uninit() is called. Keep this in mind if you're caching drwav
 objects because the operating system may restrict the number of file handles an application can have open at
 any given time.
@@ -851,22 +1214,23 @@
 This does not create a copy of the data. It is up to the application to ensure the buffer remains valid for
 the lifetime of the drwav object.
 
 The buffer should contain the contents of the entire wave file, not just the sample data.
 */
 DRWAV_API drwav_bool32 drwav_init_memory(drwav* pWav, const void* data, size_t dataSize, const drwav_allocation_callbacks* pAllocationCallbacks);
 DRWAV_API drwav_bool32 drwav_init_memory_ex(drwav* pWav, const void* data, size_t dataSize, drwav_chunk_proc onChunk, void* pChunkUserData, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks);
+DRWAV_API drwav_bool32 drwav_init_memory_with_metadata(drwav* pWav, const void* data, size_t dataSize, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks);
 
 /*
 Helper for initializing a writer which outputs data to a memory buffer.
 
 dr_wav will manage the memory allocations, however it is up to the caller to free the data with drwav_free().
 
-The buffer will remain allocated even after drwav_uninit() is called. Indeed, the buffer should not be
-considered valid until after drwav_uninit() has been called anyway.
+The buffer will remain allocated even after drwav_uninit() is called. The buffer should not be considered valid
+until after drwav_uninit() has been called.
 */
 DRWAV_API drwav_bool32 drwav_init_memory_write(drwav* pWav, void** ppData, size_t* pDataSize, const drwav_data_format* pFormat, const drwav_allocation_callbacks* pAllocationCallbacks);
 DRWAV_API drwav_bool32 drwav_init_memory_write_sequential(drwav* pWav, void** ppData, size_t* pDataSize, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, const drwav_allocation_callbacks* pAllocationCallbacks);
 DRWAV_API drwav_bool32 drwav_init_memory_write_sequential_pcm_frames(drwav* pWav, void** ppData, size_t* pDataSize, const drwav_data_format* pFormat, drwav_uint64 totalPCMFrameCount, const drwav_allocation_callbacks* pAllocationCallbacks);
 
 
 #ifndef DR_WAV_NO_CONVERSION_API
@@ -901,26 +1265,27 @@
 DRWAV_API drwav_int32* drwav_open_memory_and_read_pcm_frames_s32(const void* data, size_t dataSize, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks);
 #endif
 
 /* Frees data that was allocated internally by dr_wav. */
 DRWAV_API void drwav_free(void* p, const drwav_allocation_callbacks* pAllocationCallbacks);
 
 /* Converts bytes from a wav stream to a sized type of native endian. */
-DRWAV_API drwav_uint16 drwav_bytes_to_u16(const unsigned char* data);
-DRWAV_API drwav_int16 drwav_bytes_to_s16(const unsigned char* data);
-DRWAV_API drwav_uint32 drwav_bytes_to_u32(const unsigned char* data);
-DRWAV_API drwav_int32 drwav_bytes_to_s32(const unsigned char* data);
-DRWAV_API drwav_uint64 drwav_bytes_to_u64(const unsigned char* data);
-DRWAV_API drwav_int64 drwav_bytes_to_s64(const unsigned char* data);
+DRWAV_API drwav_uint16 drwav_bytes_to_u16(const drwav_uint8* data);
+DRWAV_API drwav_int16 drwav_bytes_to_s16(const drwav_uint8* data);
+DRWAV_API drwav_uint32 drwav_bytes_to_u32(const drwav_uint8* data);
+DRWAV_API drwav_int32 drwav_bytes_to_s32(const drwav_uint8* data);
+DRWAV_API drwav_uint64 drwav_bytes_to_u64(const drwav_uint8* data);
+DRWAV_API drwav_int64 drwav_bytes_to_s64(const drwav_uint8* data);
+DRWAV_API float drwav_bytes_to_f32(const drwav_uint8* data);
 
 /* Compares a GUID for the purpose of checking the type of a Wave64 chunk. */
 DRWAV_API drwav_bool32 drwav_guid_equal(const drwav_uint8 a[16], const drwav_uint8 b[16]);
 
 /* Compares a four-character-code for the purpose of checking the type of a RIFF chunk. */
-DRWAV_API drwav_bool32 drwav_fourcc_equal(const unsigned char* a, const char* b);
+DRWAV_API drwav_bool32 drwav_fourcc_equal(const drwav_uint8* a, const char* b);
 
 #ifdef __cplusplus
 }
 #endif
 #endif  /* dr_wav_h */
 
 
@@ -928,22 +1293,32 @@
  ************************************************************************************************************************************************************
 
  IMPLEMENTATION
 
  ************************************************************************************************************************************************************
  ************************************************************************************************************************************************************/
 #if defined(DR_WAV_IMPLEMENTATION) || defined(DRWAV_IMPLEMENTATION)
+#ifndef dr_wav_c
+#define dr_wav_c
+
+#ifdef __MRC__
+/* MrC currently doesn't compile dr_wav correctly with any optimizations enabled. */
+#pragma options opt off
+#endif
+
 #include <stdlib.h>
-#include <string.h> /* For memcpy(), memset() */
+#include <string.h>
 #include <limits.h> /* For INT_MAX */
 
 #ifndef DR_WAV_NO_STDIO
 #include <stdio.h>
+#ifndef DR_WAV_NO_WCHAR
 #include <wchar.h>
 #endif
+#endif
 
 /* Standard library stuff. */
 #ifndef DRWAV_ASSERT
 #include <assert.h>
 #define DRWAV_ASSERT(expression)           assert(expression)
 #endif
 #ifndef DRWAV_MALLOC
@@ -966,14 +1341,15 @@
 #endif
 
 #define drwav_countof(x)                   (sizeof(x) / sizeof(x[0]))
 #define drwav_align(x, a)                  ((((x) + (a) - 1) / (a)) * (a))
 #define drwav_min(a, b)                    (((a) < (b)) ? (a) : (b))
 #define drwav_max(a, b)                    (((a) > (b)) ? (a) : (b))
 #define drwav_clamp(x, lo, hi)             (drwav_max((lo), drwav_min((hi), (x))))
+#define drwav_offset_ptr(p, offset)        (((drwav_uint8*)(p)) + (offset))
 
 #define DRWAV_MAX_SIMD_VECTOR_SIZE         64  /* 64 for AVX-512 in the future. */
 
 /* CPU architecture. */
 #if defined(__x86_64__) || defined(_M_X64)
     #define DRWAV_X64
 #elif defined(__i386) || defined(_M_IX86)
@@ -989,18 +1365,26 @@
     I've had a bug report where GCC is emitting warnings about functions possibly not being inlineable. This warning happens when
     the __attribute__((always_inline)) attribute is defined without an "inline" statement. I think therefore there must be some
     case where "__inline__" is not always defined, thus the compiler emitting these warnings. When using -std=c89 or -ansi on the
     command line, we cannot use the "inline" keyword and instead need to use "__inline__". In an attempt to work around this issue
     I am using "__inline__" only when we're compiling in strict ANSI mode.
     */
     #if defined(__STRICT_ANSI__)
-        #define DRWAV_INLINE __inline__ __attribute__((always_inline))
+        #define DRWAV_GNUC_INLINE_HINT __inline__
     #else
-        #define DRWAV_INLINE inline __attribute__((always_inline))
+        #define DRWAV_GNUC_INLINE_HINT inline
     #endif
+
+    #if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 2)) || defined(__clang__)
+        #define DRWAV_INLINE DRWAV_GNUC_INLINE_HINT __attribute__((always_inline))
+    #else
+        #define DRWAV_INLINE DRWAV_GNUC_INLINE_HINT
+    #endif
+#elif defined(__WATCOMC__)
+    #define DRWAV_INLINE __inline
 #else
     #define DRWAV_INLINE
 #endif
 
 #if defined(SIZE_MAX)
     #define DRWAV_SIZE_MAX  SIZE_MAX
 #else
@@ -1033,14 +1417,34 @@
         #define DRWAV_HAS_BYTESWAP64_INTRINSIC
     #endif
     #if ((__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8))
         #define DRWAV_HAS_BYTESWAP16_INTRINSIC
     #endif
 #endif
 
+DRWAV_API void drwav_version(drwav_uint32* pMajor, drwav_uint32* pMinor, drwav_uint32* pRevision)
+{
+    if (pMajor) {
+        *pMajor = DRWAV_VERSION_MAJOR;
+    }
+
+    if (pMinor) {
+        *pMinor = DRWAV_VERSION_MINOR;
+    }
+
+    if (pRevision) {
+        *pRevision = DRWAV_VERSION_REVISION;
+    }
+}
+
+DRWAV_API const char* drwav_version_string(void)
+{
+    return DRWAV_VERSION_STRING;
+}
+
 /*
 These limits are used for basic validation when initializing the decoder. If you exceed these limits, first of all: what on Earth are
 you doing?! (Let me know, I'd be curious!) Second, you can adjust these by #define-ing them before the dr_wav implementation.
 */
 #ifndef DRWAV_MAX_SAMPLE_RATE
 #define DRWAV_MAX_SAMPLE_RATE       384000
 #endif
@@ -1049,88 +1453,35 @@
 #endif
 #ifndef DRWAV_MAX_BITS_PER_SAMPLE
 #define DRWAV_MAX_BITS_PER_SAMPLE   64
 #endif
 
 static const drwav_uint8 drwavGUID_W64_RIFF[16] = {0x72,0x69,0x66,0x66, 0x2E,0x91, 0xCF,0x11, 0xA5,0xD6, 0x28,0xDB,0x04,0xC1,0x00,0x00};    /* 66666972-912E-11CF-A5D6-28DB04C10000 */
 static const drwav_uint8 drwavGUID_W64_WAVE[16] = {0x77,0x61,0x76,0x65, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A};    /* 65766177-ACF3-11D3-8CD1-00C04F8EDB8A */
-static const drwav_uint8 drwavGUID_W64_JUNK[16] = {0x6A,0x75,0x6E,0x6B, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A};    /* 6B6E756A-ACF3-11D3-8CD1-00C04F8EDB8A */
+/*static const drwav_uint8 drwavGUID_W64_JUNK[16] = {0x6A,0x75,0x6E,0x6B, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A};*/    /* 6B6E756A-ACF3-11D3-8CD1-00C04F8EDB8A */
 static const drwav_uint8 drwavGUID_W64_FMT [16] = {0x66,0x6D,0x74,0x20, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A};    /* 20746D66-ACF3-11D3-8CD1-00C04F8EDB8A */
 static const drwav_uint8 drwavGUID_W64_FACT[16] = {0x66,0x61,0x63,0x74, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A};    /* 74636166-ACF3-11D3-8CD1-00C04F8EDB8A */
 static const drwav_uint8 drwavGUID_W64_DATA[16] = {0x64,0x61,0x74,0x61, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A};    /* 61746164-ACF3-11D3-8CD1-00C04F8EDB8A */
-static const drwav_uint8 drwavGUID_W64_SMPL[16] = {0x73,0x6D,0x70,0x6C, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A};    /* 6C706D73-ACF3-11D3-8CD1-00C04F8EDB8A */
-
-static DRWAV_INLINE drwav_bool32 drwav__guid_equal(const drwav_uint8 a[16], const drwav_uint8 b[16])
-{
-    int i;
-    for (i = 0; i < 16; i += 1) {
-        if (a[i] != b[i]) {
-            return DRWAV_FALSE;
-        }
-    }
-
-    return DRWAV_TRUE;
-}
-
-static DRWAV_INLINE drwav_bool32 drwav__fourcc_equal(const unsigned char* a, const char* b)
-{
-    return
-        a[0] == b[0] &&
-        a[1] == b[1] &&
-        a[2] == b[2] &&
-        a[3] == b[3];
-}
-
+/*static const drwav_uint8 drwavGUID_W64_SMPL[16] = {0x73,0x6D,0x70,0x6C, 0xF3,0xAC, 0xD3,0x11, 0x8C,0xD1, 0x00,0xC0,0x4F,0x8E,0xDB,0x8A};*/    /* 6C706D73-ACF3-11D3-8CD1-00C04F8EDB8A */
 
 
-static DRWAV_INLINE int drwav__is_little_endian()
+static DRWAV_INLINE int drwav__is_little_endian(void)
 {
 #if defined(DRWAV_X86) || defined(DRWAV_X64)
     return DRWAV_TRUE;
 #elif defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && __BYTE_ORDER == __LITTLE_ENDIAN
     return DRWAV_TRUE;
 #else
     int n = 1;
     return (*(char*)&n) == 1;
 #endif
 }
 
-static DRWAV_INLINE drwav_uint16 drwav__bytes_to_u16(const unsigned char* data)
-{
-    return (data[0] << 0) | (data[1] << 8);
-}
-
-static DRWAV_INLINE drwav_int16 drwav__bytes_to_s16(const unsigned char* data)
-{
-    return (short)drwav__bytes_to_u16(data);
-}
-
-static DRWAV_INLINE drwav_uint32 drwav__bytes_to_u32(const unsigned char* data)
-{
-    return (data[0] << 0) | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);
-}
-
-static DRWAV_INLINE drwav_int32 drwav__bytes_to_s32(const unsigned char* data)
-{
-    return (drwav_int32)drwav__bytes_to_u32(data);
-}
-
-static DRWAV_INLINE drwav_uint64 drwav__bytes_to_u64(const unsigned char* data)
-{
-    return
-        ((drwav_uint64)data[0] <<  0) | ((drwav_uint64)data[1] <<  8) | ((drwav_uint64)data[2] << 16) | ((drwav_uint64)data[3] << 24) |
-        ((drwav_uint64)data[4] << 32) | ((drwav_uint64)data[5] << 40) | ((drwav_uint64)data[6] << 48) | ((drwav_uint64)data[7] << 56);
-}
-
-static DRWAV_INLINE drwav_int64 drwav__bytes_to_s64(const unsigned char* data)
-{
-    return (drwav_int64)drwav__bytes_to_u64(data);
-}
 
-static DRWAV_INLINE void drwav__bytes_to_guid(const unsigned char* data, drwav_uint8* guid)
+static DRWAV_INLINE void drwav_bytes_to_guid(const drwav_uint8* data, drwav_uint8* guid)
 {
     int i;
     for (i = 0; i < 16; ++i) {
         guid[i] = data[i];
     }
 }
 
@@ -1189,22 +1540,23 @@
         return _byteswap_uint64(n);
     #elif defined(__GNUC__) || defined(__clang__)
         return __builtin_bswap64(n);
     #else
         #error "This compiler does not support the byte swap intrinsic."
     #endif
 #else
-    return ((n & (drwav_uint64)0xFF00000000000000) >> 56) |
-           ((n & (drwav_uint64)0x00FF000000000000) >> 40) |
-           ((n & (drwav_uint64)0x0000FF0000000000) >> 24) |
-           ((n & (drwav_uint64)0x000000FF00000000) >>  8) |
-           ((n & (drwav_uint64)0x00000000FF000000) <<  8) |
-           ((n & (drwav_uint64)0x0000000000FF0000) << 24) |
-           ((n & (drwav_uint64)0x000000000000FF00) << 40) |
-           ((n & (drwav_uint64)0x00000000000000FF) << 56);
+    /* Weird "<< 32" bitshift is required for C89 because it doesn't support 64-bit constants. Should be optimized out by a good compiler. */
+    return ((n & ((drwav_uint64)0xFF000000 << 32)) >> 56) |
+           ((n & ((drwav_uint64)0x00FF0000 << 32)) >> 40) |
+           ((n & ((drwav_uint64)0x0000FF00 << 32)) >> 24) |
+           ((n & ((drwav_uint64)0x000000FF << 32)) >>  8) |
+           ((n & ((drwav_uint64)0xFF000000      )) <<  8) |
+           ((n & ((drwav_uint64)0x00FF0000      )) << 24) |
+           ((n & ((drwav_uint64)0x0000FF00      )) << 40) |
+           ((n & ((drwav_uint64)0x000000FF      )) << 56);
 #endif
 }
 
 
 static DRWAV_INLINE drwav_int16 drwav__bswap_s16(drwav_int16 n)
 {
     return (drwav_int16)drwav__bswap16((drwav_uint16)n);
@@ -1294,14 +1646,18 @@
 
 
 static DRWAV_INLINE void drwav__bswap_samples_pcm(void* pSamples, drwav_uint64 sampleCount, drwav_uint32 bytesPerSample)
 {
     /* Assumes integer PCM. Floating point PCM is done in drwav__bswap_samples_ieee(). */
     switch (bytesPerSample)
     {
+        case 1: /* u8 */
+        {
+            /* no-op. */
+        } break;
         case 2: /* s16, s12 (loosely packed) */
         {
             drwav__bswap_samples_s16((drwav_int16*)pSamples, sampleCount);
         } break;
         case 3: /* s24 */
         {
             drwav__bswap_samples_s24((drwav_uint8*)pSamples, sampleCount);
@@ -1371,34 +1727,34 @@
             /* Unsupported format. */
             DRWAV_ASSERT(DRWAV_FALSE);
         } break;
     }
 }
 
 
-static void* drwav__malloc_default(size_t sz, void* pUserData)
+DRWAV_PRIVATE void* drwav__malloc_default(size_t sz, void* pUserData)
 {
     (void)pUserData;
     return DRWAV_MALLOC(sz);
 }
 
-static void* drwav__realloc_default(void* p, size_t sz, void* pUserData)
+DRWAV_PRIVATE void* drwav__realloc_default(void* p, size_t sz, void* pUserData)
 {
     (void)pUserData;
     return DRWAV_REALLOC(p, sz);
 }
 
-static void drwav__free_default(void* p, void* pUserData)
+DRWAV_PRIVATE void drwav__free_default(void* p, void* pUserData)
 {
     (void)pUserData;
     DRWAV_FREE(p);
 }
 
 
-static void* drwav__malloc_from_callbacks(size_t sz, const drwav_allocation_callbacks* pAllocationCallbacks)
+DRWAV_PRIVATE void* drwav__malloc_from_callbacks(size_t sz, const drwav_allocation_callbacks* pAllocationCallbacks)
 {
     if (pAllocationCallbacks == NULL) {
         return NULL;
     }
 
     if (pAllocationCallbacks->onMalloc != NULL) {
         return pAllocationCallbacks->onMalloc(sz, pAllocationCallbacks->pUserData);
@@ -1408,15 +1764,15 @@
     if (pAllocationCallbacks->onRealloc != NULL) {
         return pAllocationCallbacks->onRealloc(NULL, sz, pAllocationCallbacks->pUserData);
     }
 
     return NULL;
 }
 
-static void* drwav__realloc_from_callbacks(void* p, size_t szNew, size_t szOld, const drwav_allocation_callbacks* pAllocationCallbacks)
+DRWAV_PRIVATE void* drwav__realloc_from_callbacks(void* p, size_t szNew, size_t szOld, const drwav_allocation_callbacks* pAllocationCallbacks)
 {
     if (pAllocationCallbacks == NULL) {
         return NULL;
     }
 
     if (pAllocationCallbacks->onRealloc != NULL) {
         return pAllocationCallbacks->onRealloc(p, szNew, pAllocationCallbacks->pUserData);
@@ -1438,27 +1794,27 @@
 
         return p2;
     }
 
     return NULL;
 }
 
-static void drwav__free_from_callbacks(void* p, const drwav_allocation_callbacks* pAllocationCallbacks)
+DRWAV_PRIVATE void drwav__free_from_callbacks(void* p, const drwav_allocation_callbacks* pAllocationCallbacks)
 {
     if (p == NULL || pAllocationCallbacks == NULL) {
         return;
     }
 
     if (pAllocationCallbacks->onFree != NULL) {
         pAllocationCallbacks->onFree(p, pAllocationCallbacks->pUserData);
     }
 }
 
 
-static drwav_allocation_callbacks drwav_copy_allocation_callbacks_or_defaults(const drwav_allocation_callbacks* pAllocationCallbacks)
+DRWAV_PRIVATE drwav_allocation_callbacks drwav_copy_allocation_callbacks_or_defaults(const drwav_allocation_callbacks* pAllocationCallbacks)
 {
     if (pAllocationCallbacks != NULL) {
         /* Copy. */
         return *pAllocationCallbacks;
     } else {
         /* Defaults. */
         drwav_allocation_callbacks allocationCallbacks;
@@ -1474,64 +1830,64 @@
 static DRWAV_INLINE drwav_bool32 drwav__is_compressed_format_tag(drwav_uint16 formatTag)
 {
     return
         formatTag == DR_WAVE_FORMAT_ADPCM ||
         formatTag == DR_WAVE_FORMAT_DVI_ADPCM;
 }
 
-static unsigned int drwav__chunk_padding_size_riff(drwav_uint64 chunkSize)
+DRWAV_PRIVATE unsigned int drwav__chunk_padding_size_riff(drwav_uint64 chunkSize)
 {
     return (unsigned int)(chunkSize % 2);
 }
 
-static unsigned int drwav__chunk_padding_size_w64(drwav_uint64 chunkSize)
+DRWAV_PRIVATE unsigned int drwav__chunk_padding_size_w64(drwav_uint64 chunkSize)
 {
     return (unsigned int)(chunkSize % 8);
 }
 
-static drwav_uint64 drwav_read_pcm_frames_s16__msadpcm(drwav* pWav, drwav_uint64 samplesToRead, drwav_int16* pBufferOut);
-static drwav_uint64 drwav_read_pcm_frames_s16__ima(drwav* pWav, drwav_uint64 samplesToRead, drwav_int16* pBufferOut);
-static drwav_bool32 drwav_init_write__internal(drwav* pWav, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount);
+DRWAV_PRIVATE drwav_uint64 drwav_read_pcm_frames_s16__msadpcm(drwav* pWav, drwav_uint64 samplesToRead, drwav_int16* pBufferOut);
+DRWAV_PRIVATE drwav_uint64 drwav_read_pcm_frames_s16__ima(drwav* pWav, drwav_uint64 samplesToRead, drwav_int16* pBufferOut);
+DRWAV_PRIVATE drwav_bool32 drwav_init_write__internal(drwav* pWav, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount);
 
-static drwav_result drwav__read_chunk_header(drwav_read_proc onRead, void* pUserData, drwav_container container, drwav_uint64* pRunningBytesReadOut, drwav_chunk_header* pHeaderOut)
+DRWAV_PRIVATE drwav_result drwav__read_chunk_header(drwav_read_proc onRead, void* pUserData, drwav_container container, drwav_uint64* pRunningBytesReadOut, drwav_chunk_header* pHeaderOut)
 {
-    if (container == drwav_container_riff) {
-        unsigned char sizeInBytes[4];
+    if (container == drwav_container_riff || container == drwav_container_rf64) {
+        drwav_uint8 sizeInBytes[4];
 
         if (onRead(pUserData, pHeaderOut->id.fourcc, 4) != 4) {
             return DRWAV_AT_END;
         }
 
         if (onRead(pUserData, sizeInBytes, 4) != 4) {
             return DRWAV_INVALID_FILE;
         }
 
-        pHeaderOut->sizeInBytes = drwav__bytes_to_u32(sizeInBytes);
+        pHeaderOut->sizeInBytes = drwav_bytes_to_u32(sizeInBytes);
         pHeaderOut->paddingSize = drwav__chunk_padding_size_riff(pHeaderOut->sizeInBytes);
         *pRunningBytesReadOut += 8;
     } else {
-        unsigned char sizeInBytes[8];
+        drwav_uint8 sizeInBytes[8];
 
         if (onRead(pUserData, pHeaderOut->id.guid, 16) != 16) {
             return DRWAV_AT_END;
         }
 
         if (onRead(pUserData, sizeInBytes, 8) != 8) {
             return DRWAV_INVALID_FILE;
         }
 
-        pHeaderOut->sizeInBytes = drwav__bytes_to_u64(sizeInBytes) - 24;    /* <-- Subtract 24 because w64 includes the size of the header. */
+        pHeaderOut->sizeInBytes = drwav_bytes_to_u64(sizeInBytes) - 24;    /* <-- Subtract 24 because w64 includes the size of the header. */
         pHeaderOut->paddingSize = drwav__chunk_padding_size_w64(pHeaderOut->sizeInBytes);
         *pRunningBytesReadOut += 24;
     }
 
     return DRWAV_SUCCESS;
 }
 
-static drwav_bool32 drwav__seek_forward(drwav_seek_proc onSeek, drwav_uint64 offset, void* pUserData)
+DRWAV_PRIVATE drwav_bool32 drwav__seek_forward(drwav_seek_proc onSeek, drwav_uint64 offset, void* pUserData)
 {
     drwav_uint64 bytesRemainingToSeek = offset;
     while (bytesRemainingToSeek > 0) {
         if (bytesRemainingToSeek > 0x7FFFFFFF) {
             if (!onSeek(pUserData, 0x7FFFFFFF, drwav_seek_origin_current)) {
                 return DRWAV_FALSE;
             }
@@ -1543,15 +1899,15 @@
             bytesRemainingToSeek = 0;
         }
     }
 
     return DRWAV_TRUE;
 }
 
-static drwav_bool32 drwav__seek_from_start(drwav_seek_proc onSeek, drwav_uint64 offset, void* pUserData)
+DRWAV_PRIVATE drwav_bool32 drwav__seek_from_start(drwav_seek_proc onSeek, drwav_uint64 offset, void* pUserData)
 {
     if (offset <= 0x7FFFFFFF) {
         return onSeek(pUserData, (int)offset, drwav_seek_origin_start);
     }
 
     /* Larger than 32-bit seek. */
     if (!onSeek(pUserData, 0x7FFFFFFF, drwav_seek_origin_start)) {
@@ -1571,96 +1927,96 @@
     }
 
     /* Should never get here. */
     /*return DRWAV_TRUE; */
 }
 
 
-static drwav_bool32 drwav__read_fmt(drwav_read_proc onRead, drwav_seek_proc onSeek, void* pUserData, drwav_container container, drwav_uint64* pRunningBytesReadOut, drwav_fmt* fmtOut)
+DRWAV_PRIVATE drwav_bool32 drwav__read_fmt(drwav_read_proc onRead, drwav_seek_proc onSeek, void* pUserData, drwav_container container, drwav_uint64* pRunningBytesReadOut, drwav_fmt* fmtOut)
 {
     drwav_chunk_header header;
-    unsigned char fmt[16];
+    drwav_uint8 fmt[16];
 
     if (drwav__read_chunk_header(onRead, pUserData, container, pRunningBytesReadOut, &header) != DRWAV_SUCCESS) {
         return DRWAV_FALSE;
     }
 
 
     /* Skip non-fmt chunks. */
-    while ((container == drwav_container_riff && !drwav__fourcc_equal(header.id.fourcc, "fmt ")) || (container == drwav_container_w64 && !drwav__guid_equal(header.id.guid, drwavGUID_W64_FMT))) {
+    while (((container == drwav_container_riff || container == drwav_container_rf64) && !drwav_fourcc_equal(header.id.fourcc, "fmt ")) || (container == drwav_container_w64 && !drwav_guid_equal(header.id.guid, drwavGUID_W64_FMT))) {
         if (!drwav__seek_forward(onSeek, header.sizeInBytes + header.paddingSize, pUserData)) {
             return DRWAV_FALSE;
         }
         *pRunningBytesReadOut += header.sizeInBytes + header.paddingSize;
 
         /* Try the next header. */
         if (drwav__read_chunk_header(onRead, pUserData, container, pRunningBytesReadOut, &header) != DRWAV_SUCCESS) {
             return DRWAV_FALSE;
         }
     }
 
 
     /* Validation. */
-    if (container == drwav_container_riff) {
-        if (!drwav__fourcc_equal(header.id.fourcc, "fmt ")) {
+    if (container == drwav_container_riff || container == drwav_container_rf64) {
+        if (!drwav_fourcc_equal(header.id.fourcc, "fmt ")) {
             return DRWAV_FALSE;
         }
     } else {
-        if (!drwav__guid_equal(header.id.guid, drwavGUID_W64_FMT)) {
+        if (!drwav_guid_equal(header.id.guid, drwavGUID_W64_FMT)) {
             return DRWAV_FALSE;
         }
     }
 
 
     if (onRead(pUserData, fmt, sizeof(fmt)) != sizeof(fmt)) {
         return DRWAV_FALSE;
     }
     *pRunningBytesReadOut += sizeof(fmt);
 
-    fmtOut->formatTag      = drwav__bytes_to_u16(fmt + 0);
-    fmtOut->channels       = drwav__bytes_to_u16(fmt + 2);
-    fmtOut->sampleRate     = drwav__bytes_to_u32(fmt + 4);
-    fmtOut->avgBytesPerSec = drwav__bytes_to_u32(fmt + 8);
-    fmtOut->blockAlign     = drwav__bytes_to_u16(fmt + 12);
-    fmtOut->bitsPerSample  = drwav__bytes_to_u16(fmt + 14);
+    fmtOut->formatTag      = drwav_bytes_to_u16(fmt + 0);
+    fmtOut->channels       = drwav_bytes_to_u16(fmt + 2);
+    fmtOut->sampleRate     = drwav_bytes_to_u32(fmt + 4);
+    fmtOut->avgBytesPerSec = drwav_bytes_to_u32(fmt + 8);
+    fmtOut->blockAlign     = drwav_bytes_to_u16(fmt + 12);
+    fmtOut->bitsPerSample  = drwav_bytes_to_u16(fmt + 14);
 
     fmtOut->extendedSize       = 0;
     fmtOut->validBitsPerSample = 0;
     fmtOut->channelMask        = 0;
-    memset(fmtOut->subFormat, 0, sizeof(fmtOut->subFormat));
+    DRWAV_ZERO_MEMORY(fmtOut->subFormat, sizeof(fmtOut->subFormat));
 
     if (header.sizeInBytes > 16) {
-        unsigned char fmt_cbSize[2];
+        drwav_uint8 fmt_cbSize[2];
         int bytesReadSoFar = 0;
 
         if (onRead(pUserData, fmt_cbSize, sizeof(fmt_cbSize)) != sizeof(fmt_cbSize)) {
             return DRWAV_FALSE;    /* Expecting more data. */
         }
         *pRunningBytesReadOut += sizeof(fmt_cbSize);
 
         bytesReadSoFar = 18;
 
-        fmtOut->extendedSize = drwav__bytes_to_u16(fmt_cbSize);
+        fmtOut->extendedSize = drwav_bytes_to_u16(fmt_cbSize);
         if (fmtOut->extendedSize > 0) {
             /* Simple validation. */
             if (fmtOut->formatTag == DR_WAVE_FORMAT_EXTENSIBLE) {
                 if (fmtOut->extendedSize != 22) {
                     return DRWAV_FALSE;
                 }
             }
 
             if (fmtOut->formatTag == DR_WAVE_FORMAT_EXTENSIBLE) {
-                unsigned char fmtext[22];
+                drwav_uint8 fmtext[22];
                 if (onRead(pUserData, fmtext, fmtOut->extendedSize) != fmtOut->extendedSize) {
                     return DRWAV_FALSE;    /* Expecting more data. */
                 }
 
-                fmtOut->validBitsPerSample = drwav__bytes_to_u16(fmtext + 0);
-                fmtOut->channelMask        = drwav__bytes_to_u32(fmtext + 2);
-                drwav__bytes_to_guid(fmtext + 6, fmtOut->subFormat);
+                fmtOut->validBitsPerSample = drwav_bytes_to_u16(fmtext + 0);
+                fmtOut->channelMask        = drwav_bytes_to_u32(fmtext + 2);
+                drwav_bytes_to_guid(fmtext + 6, fmtOut->subFormat);
             } else {
                 if (!onSeek(pUserData, fmtOut->extendedSize, drwav_seek_origin_current)) {
                     return DRWAV_FALSE;
                 }
             }
             *pRunningBytesReadOut += fmtOut->extendedSize;
 
@@ -1681,28 +2037,28 @@
         *pRunningBytesReadOut += header.paddingSize;
     }
 
     return DRWAV_TRUE;
 }
 
 
-static size_t drwav__on_read(drwav_read_proc onRead, void* pUserData, void* pBufferOut, size_t bytesToRead, drwav_uint64* pCursor)
+DRWAV_PRIVATE size_t drwav__on_read(drwav_read_proc onRead, void* pUserData, void* pBufferOut, size_t bytesToRead, drwav_uint64* pCursor)
 {
     size_t bytesRead;
 
     DRWAV_ASSERT(onRead != NULL);
     DRWAV_ASSERT(pCursor != NULL);
 
     bytesRead = onRead(pUserData, pBufferOut, bytesToRead);
     *pCursor += bytesRead;
     return bytesRead;
 }
 
 #if 0
-static drwav_bool32 drwav__on_seek(drwav_seek_proc onSeek, void* pUserData, int offset, drwav_seek_origin origin, drwav_uint64* pCursor)
+DRWAV_PRIVATE drwav_bool32 drwav__on_seek(drwav_seek_proc onSeek, void* pUserData, int offset, drwav_seek_origin origin, drwav_uint64* pCursor)
 {
     DRWAV_ASSERT(onSeek != NULL);
     DRWAV_ASSERT(pCursor != NULL);
 
     if (!onSeek(pUserData, offset, origin)) {
         return DRWAV_FALSE;
     }
@@ -1714,43 +2070,937 @@
     }
 
     return DRWAV_TRUE;
 }
 #endif
 
 
+#define DRWAV_SMPL_BYTES                    36
+#define DRWAV_SMPL_LOOP_BYTES               24
+#define DRWAV_INST_BYTES                    7
+#define DRWAV_ACID_BYTES                    24
+#define DRWAV_CUE_BYTES                     4
+#define DRWAV_BEXT_BYTES                    602
+#define DRWAV_BEXT_DESCRIPTION_BYTES        256
+#define DRWAV_BEXT_ORIGINATOR_NAME_BYTES    32
+#define DRWAV_BEXT_ORIGINATOR_REF_BYTES     32
+#define DRWAV_BEXT_RESERVED_BYTES           180
+#define DRWAV_BEXT_UMID_BYTES               64
+#define DRWAV_CUE_POINT_BYTES               24
+#define DRWAV_LIST_LABEL_OR_NOTE_BYTES      4
+#define DRWAV_LIST_LABELLED_TEXT_BYTES      20
+
+#define DRWAV_METADATA_ALIGNMENT            8
+
+typedef enum
+{
+    drwav__metadata_parser_stage_count,
+    drwav__metadata_parser_stage_read
+} drwav__metadata_parser_stage;
+
+typedef struct
+{
+    drwav_read_proc onRead;
+    drwav_seek_proc onSeek;
+    void *pReadSeekUserData;
+    drwav__metadata_parser_stage stage;
+    drwav_metadata *pMetadata;
+    drwav_uint32 metadataCount;
+    drwav_uint8 *pData;
+    drwav_uint8 *pDataCursor;
+    drwav_uint64 metadataCursor;
+    drwav_uint64 extraCapacity;
+} drwav__metadata_parser;
+
+DRWAV_PRIVATE size_t drwav__metadata_memory_capacity(drwav__metadata_parser* pParser)
+{
+    drwav_uint64 cap = sizeof(drwav_metadata) * (drwav_uint64)pParser->metadataCount + pParser->extraCapacity;
+    if (cap > DRWAV_SIZE_MAX) {
+        return 0;   /* Too big. */
+    }
+
+    return (size_t)cap; /* Safe cast thanks to the check above. */
+}
 
-static drwav_uint32 drwav_get_bytes_per_pcm_frame(drwav* pWav)
+DRWAV_PRIVATE drwav_uint8* drwav__metadata_get_memory(drwav__metadata_parser* pParser, size_t size, size_t align)
 {
+    drwav_uint8* pResult;
+
+    if (align) {
+        drwav_uintptr modulo = (drwav_uintptr)pParser->pDataCursor % align;
+        if (modulo != 0) {
+            pParser->pDataCursor += align - modulo;
+        }
+    }
+    
+    pResult = pParser->pDataCursor;
+
+    /*
+    Getting to the point where this function is called means there should always be memory
+    available. Out of memory checks should have been done at an earlier stage.
+    */
+    DRWAV_ASSERT((pResult + size) <= (pParser->pData + drwav__metadata_memory_capacity(pParser)));
+
+    pParser->pDataCursor += size;
+    return pResult;
+}
+
+DRWAV_PRIVATE void drwav__metadata_request_extra_memory_for_stage_2(drwav__metadata_parser* pParser, size_t bytes, size_t align)
+{
+    size_t extra = bytes + (align ? (align - 1) : 0);
+    pParser->extraCapacity += extra;
+}
+
+DRWAV_PRIVATE drwav_result drwav__metadata_alloc(drwav__metadata_parser* pParser, drwav_allocation_callbacks* pAllocationCallbacks)
+{
+    if (pParser->extraCapacity != 0 || pParser->metadataCount != 0) {
+        pAllocationCallbacks->onFree(pParser->pData, pAllocationCallbacks->pUserData);
+
+        pParser->pData = (drwav_uint8*)pAllocationCallbacks->onMalloc(drwav__metadata_memory_capacity(pParser), pAllocationCallbacks->pUserData);
+        pParser->pDataCursor = pParser->pData;
+
+        if (pParser->pData == NULL) {
+            return DRWAV_OUT_OF_MEMORY;
+        }
+
+        /*
+        We don't need to worry about specifying an alignment here because malloc always returns something
+        of suitable alignment. This also means than pParser->pMetadata is all that we need to store in order
+        for us to free when we are done.
+        */
+        pParser->pMetadata = (drwav_metadata*)drwav__metadata_get_memory(pParser, sizeof(drwav_metadata) * pParser->metadataCount, 1);
+        pParser->metadataCursor = 0;
+    }
+
+    return DRWAV_SUCCESS;
+}
+
+DRWAV_PRIVATE size_t drwav__metadata_parser_read(drwav__metadata_parser* pParser, void* pBufferOut, size_t bytesToRead, drwav_uint64* pCursor)
+{
+    if (pCursor != NULL) {
+        return drwav__on_read(pParser->onRead, pParser->pReadSeekUserData, pBufferOut, bytesToRead, pCursor);
+    } else {
+        return pParser->onRead(pParser->pReadSeekUserData, pBufferOut, bytesToRead);
+    }
+}
+
+DRWAV_PRIVATE drwav_uint64 drwav__read_smpl_to_metadata_obj(drwav__metadata_parser* pParser, const drwav_chunk_header* pChunkHeader, drwav_metadata* pMetadata)
+{
+    drwav_uint8 smplHeaderData[DRWAV_SMPL_BYTES];
+    drwav_uint64 totalBytesRead = 0;
+    size_t bytesJustRead = drwav__metadata_parser_read(pParser, smplHeaderData, sizeof(smplHeaderData), &totalBytesRead);
+
+    DRWAV_ASSERT(pParser->stage == drwav__metadata_parser_stage_read);
+    DRWAV_ASSERT(pChunkHeader != NULL);
+
+    if (bytesJustRead == sizeof(smplHeaderData)) {
+        drwav_uint32 iSampleLoop;
+
+        pMetadata->type                                     = drwav_metadata_type_smpl;
+        pMetadata->data.smpl.manufacturerId                 = drwav_bytes_to_u32(smplHeaderData + 0);
+        pMetadata->data.smpl.productId                      = drwav_bytes_to_u32(smplHeaderData + 4);
+        pMetadata->data.smpl.samplePeriodNanoseconds        = drwav_bytes_to_u32(smplHeaderData + 8);
+        pMetadata->data.smpl.midiUnityNote                  = drwav_bytes_to_u32(smplHeaderData + 12);
+        pMetadata->data.smpl.midiPitchFraction              = drwav_bytes_to_u32(smplHeaderData + 16);
+        pMetadata->data.smpl.smpteFormat                    = drwav_bytes_to_u32(smplHeaderData + 20);
+        pMetadata->data.smpl.smpteOffset                    = drwav_bytes_to_u32(smplHeaderData + 24);
+        pMetadata->data.smpl.sampleLoopCount                = drwav_bytes_to_u32(smplHeaderData + 28);
+        pMetadata->data.smpl.samplerSpecificDataSizeInBytes = drwav_bytes_to_u32(smplHeaderData + 32);
+
+        /*
+        The loop count needs to be validated against the size of the chunk for safety so we don't
+        attempt to read over the boundary of the chunk.
+        */
+        if (pMetadata->data.smpl.sampleLoopCount == (pChunkHeader->sizeInBytes - DRWAV_SMPL_BYTES) / DRWAV_SMPL_LOOP_BYTES) {
+            pMetadata->data.smpl.pLoops = (drwav_smpl_loop*)drwav__metadata_get_memory(pParser, sizeof(drwav_smpl_loop) * pMetadata->data.smpl.sampleLoopCount, DRWAV_METADATA_ALIGNMENT);
+
+            for (iSampleLoop = 0; iSampleLoop < pMetadata->data.smpl.sampleLoopCount; ++iSampleLoop) {
+                drwav_uint8 smplLoopData[DRWAV_SMPL_LOOP_BYTES];
+                bytesJustRead = drwav__metadata_parser_read(pParser, smplLoopData, sizeof(smplLoopData), &totalBytesRead);
+
+                if (bytesJustRead == sizeof(smplLoopData)) {
+                    pMetadata->data.smpl.pLoops[iSampleLoop].cuePointId            = drwav_bytes_to_u32(smplLoopData + 0);
+                    pMetadata->data.smpl.pLoops[iSampleLoop].type                  = drwav_bytes_to_u32(smplLoopData + 4);
+                    pMetadata->data.smpl.pLoops[iSampleLoop].firstSampleByteOffset = drwav_bytes_to_u32(smplLoopData + 8);
+                    pMetadata->data.smpl.pLoops[iSampleLoop].lastSampleByteOffset  = drwav_bytes_to_u32(smplLoopData + 12);
+                    pMetadata->data.smpl.pLoops[iSampleLoop].sampleFraction        = drwav_bytes_to_u32(smplLoopData + 16);
+                    pMetadata->data.smpl.pLoops[iSampleLoop].playCount             = drwav_bytes_to_u32(smplLoopData + 20);
+                } else {
+                    break;
+                }
+            }
+
+            if (pMetadata->data.smpl.samplerSpecificDataSizeInBytes > 0) {
+                pMetadata->data.smpl.pSamplerSpecificData = drwav__metadata_get_memory(pParser, pMetadata->data.smpl.samplerSpecificDataSizeInBytes, 1);
+                DRWAV_ASSERT(pMetadata->data.smpl.pSamplerSpecificData != NULL);
+
+                drwav__metadata_parser_read(pParser, pMetadata->data.smpl.pSamplerSpecificData, pMetadata->data.smpl.samplerSpecificDataSizeInBytes, &totalBytesRead);
+            }
+        }
+    }
+
+    return totalBytesRead;
+}
+
+DRWAV_PRIVATE drwav_uint64 drwav__read_cue_to_metadata_obj(drwav__metadata_parser* pParser, const drwav_chunk_header* pChunkHeader, drwav_metadata* pMetadata)
+{
+    drwav_uint8 cueHeaderSectionData[DRWAV_CUE_BYTES];
+    drwav_uint64 totalBytesRead = 0;
+    size_t bytesJustRead = drwav__metadata_parser_read(pParser, cueHeaderSectionData, sizeof(cueHeaderSectionData), &totalBytesRead);
+
+    DRWAV_ASSERT(pParser->stage == drwav__metadata_parser_stage_read);
+
+    if (bytesJustRead == sizeof(cueHeaderSectionData)) {
+        pMetadata->type                   = drwav_metadata_type_cue;
+        pMetadata->data.cue.cuePointCount = drwav_bytes_to_u32(cueHeaderSectionData);
+
+        /*
+        We need to validate the cue point count against the size of the chunk so we don't read
+        beyond the chunk.
+        */
+        if (pMetadata->data.cue.cuePointCount == (pChunkHeader->sizeInBytes - DRWAV_CUE_BYTES) / DRWAV_CUE_POINT_BYTES) {
+            pMetadata->data.cue.pCuePoints    = (drwav_cue_point*)drwav__metadata_get_memory(pParser, sizeof(drwav_cue_point) * pMetadata->data.cue.cuePointCount, DRWAV_METADATA_ALIGNMENT);
+            DRWAV_ASSERT(pMetadata->data.cue.pCuePoints != NULL);
+
+            if (pMetadata->data.cue.cuePointCount > 0) {
+                drwav_uint32 iCuePoint;
+
+                for (iCuePoint = 0; iCuePoint < pMetadata->data.cue.cuePointCount; ++iCuePoint) {
+                    drwav_uint8 cuePointData[DRWAV_CUE_POINT_BYTES];
+                    bytesJustRead = drwav__metadata_parser_read(pParser, cuePointData, sizeof(cuePointData), &totalBytesRead);
+
+                    if (bytesJustRead == sizeof(cuePointData)) {
+                        pMetadata->data.cue.pCuePoints[iCuePoint].id                = drwav_bytes_to_u32(cuePointData + 0);
+                        pMetadata->data.cue.pCuePoints[iCuePoint].playOrderPosition = drwav_bytes_to_u32(cuePointData + 4);
+                        pMetadata->data.cue.pCuePoints[iCuePoint].dataChunkId[0]    = cuePointData[8];
+                        pMetadata->data.cue.pCuePoints[iCuePoint].dataChunkId[1]    = cuePointData[9];
+                        pMetadata->data.cue.pCuePoints[iCuePoint].dataChunkId[2]    = cuePointData[10];
+                        pMetadata->data.cue.pCuePoints[iCuePoint].dataChunkId[3]    = cuePointData[11];
+                        pMetadata->data.cue.pCuePoints[iCuePoint].chunkStart        = drwav_bytes_to_u32(cuePointData + 12);
+                        pMetadata->data.cue.pCuePoints[iCuePoint].blockStart        = drwav_bytes_to_u32(cuePointData + 16);
+                        pMetadata->data.cue.pCuePoints[iCuePoint].sampleByteOffset  = drwav_bytes_to_u32(cuePointData + 20);
+                    } else {
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    return totalBytesRead;
+}
+
+DRWAV_PRIVATE drwav_uint64 drwav__read_inst_to_metadata_obj(drwav__metadata_parser* pParser, drwav_metadata* pMetadata)
+{
+    drwav_uint8 instData[DRWAV_INST_BYTES];
+    drwav_uint64 bytesRead = drwav__metadata_parser_read(pParser, instData, sizeof(instData), NULL);
+
+    DRWAV_ASSERT(pParser->stage == drwav__metadata_parser_stage_read);
+
+    if (bytesRead == sizeof(instData)) {
+        pMetadata->type                    = drwav_metadata_type_inst;
+        pMetadata->data.inst.midiUnityNote = (drwav_int8)instData[0];
+        pMetadata->data.inst.fineTuneCents = (drwav_int8)instData[1];
+        pMetadata->data.inst.gainDecibels  = (drwav_int8)instData[2];
+        pMetadata->data.inst.lowNote       = (drwav_int8)instData[3];
+        pMetadata->data.inst.highNote      = (drwav_int8)instData[4];
+        pMetadata->data.inst.lowVelocity   = (drwav_int8)instData[5];
+        pMetadata->data.inst.highVelocity  = (drwav_int8)instData[6];
+    }
+
+    return bytesRead;
+}
+
+DRWAV_PRIVATE drwav_uint64 drwav__read_acid_to_metadata_obj(drwav__metadata_parser* pParser, drwav_metadata* pMetadata)
+{
+    drwav_uint8 acidData[DRWAV_ACID_BYTES];
+    drwav_uint64 bytesRead = drwav__metadata_parser_read(pParser, acidData, sizeof(acidData), NULL);
+
+    DRWAV_ASSERT(pParser->stage == drwav__metadata_parser_stage_read);
+
+    if (bytesRead == sizeof(acidData)) {
+        pMetadata->type                       = drwav_metadata_type_acid;
+        pMetadata->data.acid.flags            = drwav_bytes_to_u32(acidData + 0);
+        pMetadata->data.acid.midiUnityNote    = drwav_bytes_to_u16(acidData + 4);
+        pMetadata->data.acid.reserved1        = drwav_bytes_to_u16(acidData + 6);
+        pMetadata->data.acid.reserved2        = drwav_bytes_to_f32(acidData + 8);
+        pMetadata->data.acid.numBeats         = drwav_bytes_to_u32(acidData + 12);
+        pMetadata->data.acid.meterDenominator = drwav_bytes_to_u16(acidData + 16);
+        pMetadata->data.acid.meterNumerator   = drwav_bytes_to_u16(acidData + 18);
+        pMetadata->data.acid.tempo            = drwav_bytes_to_f32(acidData + 20);
+    }
+
+    return bytesRead;
+}
+
+DRWAV_PRIVATE size_t drwav__strlen(const char* str)
+{
+    size_t result = 0;
+
+    while (*str++) {
+        result += 1;
+    }
+
+    return result;
+}
+
+DRWAV_PRIVATE size_t drwav__strlen_clamped(const char* str, size_t maxToRead)
+{
+    size_t result = 0;
+
+    while (*str++ && result < maxToRead) {
+        result += 1;
+    }
+
+    return result;
+}
+
+DRWAV_PRIVATE char* drwav__metadata_copy_string(drwav__metadata_parser* pParser, const char* str, size_t maxToRead)
+{
+    size_t len = drwav__strlen_clamped(str, maxToRead);
+
+    if (len) {
+        char* result = (char*)drwav__metadata_get_memory(pParser, len + 1, 1);
+        DRWAV_ASSERT(result != NULL);
+
+        DRWAV_COPY_MEMORY(result, str, len);
+        result[len] = '\0';
+
+        return result;
+    } else {
+        return NULL;
+    }
+}
+
+typedef struct
+{
+    const void* pBuffer;
+    size_t sizeInBytes;
+    size_t cursor;
+} drwav_buffer_reader;
+
+DRWAV_PRIVATE drwav_result drwav_buffer_reader_init(const void* pBuffer, size_t sizeInBytes, drwav_buffer_reader* pReader)
+{
+    DRWAV_ASSERT(pBuffer != NULL);
+    DRWAV_ASSERT(pReader != NULL);
+
+    DRWAV_ZERO_OBJECT(pReader);
+
+    pReader->pBuffer     = pBuffer;
+    pReader->sizeInBytes = sizeInBytes;
+    pReader->cursor      = 0;
+
+    return DRWAV_SUCCESS;
+}
+
+DRWAV_PRIVATE const void* drwav_buffer_reader_ptr(const drwav_buffer_reader* pReader)
+{
+    DRWAV_ASSERT(pReader != NULL);
+
+    return drwav_offset_ptr(pReader->pBuffer, pReader->cursor);
+}
+
+DRWAV_PRIVATE drwav_result drwav_buffer_reader_seek(drwav_buffer_reader* pReader, size_t bytesToSeek)
+{
+    DRWAV_ASSERT(pReader != NULL);
+
+    if (pReader->cursor + bytesToSeek > pReader->sizeInBytes) {
+        return DRWAV_BAD_SEEK;  /* Seeking too far forward. */
+    }
+
+    pReader->cursor += bytesToSeek;
+
+    return DRWAV_SUCCESS;
+}
+
+DRWAV_PRIVATE drwav_result drwav_buffer_reader_read(drwav_buffer_reader* pReader, void* pDst, size_t bytesToRead, size_t* pBytesRead)
+{
+    drwav_result result = DRWAV_SUCCESS;
+    size_t bytesRemaining;
+
+    DRWAV_ASSERT(pReader != NULL);
+    
+    if (pBytesRead != NULL) {
+        *pBytesRead = 0;
+    }
+
+    bytesRemaining = (pReader->sizeInBytes - pReader->cursor);
+    if (bytesToRead > bytesRemaining) {
+        bytesToRead = bytesRemaining;
+    }
+
+    if (pDst == NULL) {
+        /* Seek. */
+        result = drwav_buffer_reader_seek(pReader, bytesToRead);
+    } else {
+        /* Read. */
+        DRWAV_COPY_MEMORY(pDst, drwav_buffer_reader_ptr(pReader), bytesToRead);
+        pReader->cursor += bytesToRead;
+    }
+
+    DRWAV_ASSERT(pReader->cursor <= pReader->sizeInBytes);
+
+    if (result == DRWAV_SUCCESS) {
+        if (pBytesRead != NULL) {
+            *pBytesRead = bytesToRead;
+        }
+    }
+
+    return DRWAV_SUCCESS;
+}
+
+DRWAV_PRIVATE drwav_result drwav_buffer_reader_read_u16(drwav_buffer_reader* pReader, drwav_uint16* pDst)
+{
+    drwav_result result;
+    size_t bytesRead;
+    drwav_uint8 data[2];
+
+    DRWAV_ASSERT(pReader != NULL);
+    DRWAV_ASSERT(pDst != NULL);
+
+    *pDst = 0;  /* Safety. */
+
+    result = drwav_buffer_reader_read(pReader, data, sizeof(*pDst), &bytesRead);
+    if (result != DRWAV_SUCCESS || bytesRead != sizeof(*pDst)) {
+        return result;
+    }
+
+    *pDst = drwav_bytes_to_u16(data);
+
+    return DRWAV_SUCCESS;
+}
+
+DRWAV_PRIVATE drwav_result drwav_buffer_reader_read_u32(drwav_buffer_reader* pReader, drwav_uint32* pDst)
+{
+    drwav_result result;
+    size_t bytesRead;
+    drwav_uint8 data[4];
+
+    DRWAV_ASSERT(pReader != NULL);
+    DRWAV_ASSERT(pDst != NULL);
+
+    *pDst = 0;  /* Safety. */
+
+    result = drwav_buffer_reader_read(pReader, data, sizeof(*pDst), &bytesRead);
+    if (result != DRWAV_SUCCESS || bytesRead != sizeof(*pDst)) {
+        return result;
+    }
+
+    *pDst = drwav_bytes_to_u32(data);
+
+    return DRWAV_SUCCESS;
+}
+
+
+
+DRWAV_PRIVATE drwav_uint64 drwav__read_bext_to_metadata_obj(drwav__metadata_parser* pParser, drwav_metadata* pMetadata, drwav_uint64 chunkSize)
+{
+    drwav_uint8 bextData[DRWAV_BEXT_BYTES];
+    size_t bytesRead = drwav__metadata_parser_read(pParser, bextData, sizeof(bextData), NULL);
+
+    DRWAV_ASSERT(pParser->stage == drwav__metadata_parser_stage_read);
+    
+    if (bytesRead == sizeof(bextData)) {
+        drwav_buffer_reader reader;
+        drwav_uint32 timeReferenceLow;
+        drwav_uint32 timeReferenceHigh;
+        size_t extraBytes;
+
+        pMetadata->type = drwav_metadata_type_bext;
+
+        if (drwav_buffer_reader_init(bextData, bytesRead, &reader) == DRWAV_SUCCESS) {
+            pMetadata->data.bext.pDescription = drwav__metadata_copy_string(pParser, (const char*)drwav_buffer_reader_ptr(&reader), DRWAV_BEXT_DESCRIPTION_BYTES);
+            drwav_buffer_reader_seek(&reader, DRWAV_BEXT_DESCRIPTION_BYTES);
+
+            pMetadata->data.bext.pOriginatorName = drwav__metadata_copy_string(pParser, (const char*)drwav_buffer_reader_ptr(&reader), DRWAV_BEXT_ORIGINATOR_NAME_BYTES);
+            drwav_buffer_reader_seek(&reader, DRWAV_BEXT_ORIGINATOR_NAME_BYTES);
+
+            pMetadata->data.bext.pOriginatorReference = drwav__metadata_copy_string(pParser, (const char*)drwav_buffer_reader_ptr(&reader), DRWAV_BEXT_ORIGINATOR_REF_BYTES);
+            drwav_buffer_reader_seek(&reader, DRWAV_BEXT_ORIGINATOR_REF_BYTES);
+
+            drwav_buffer_reader_read(&reader, pMetadata->data.bext.pOriginationDate, sizeof(pMetadata->data.bext.pOriginationDate), NULL);
+            drwav_buffer_reader_read(&reader, pMetadata->data.bext.pOriginationTime, sizeof(pMetadata->data.bext.pOriginationTime), NULL);
+
+            drwav_buffer_reader_read_u32(&reader, &timeReferenceLow);
+            drwav_buffer_reader_read_u32(&reader, &timeReferenceHigh);
+            pMetadata->data.bext.timeReference = ((drwav_uint64)timeReferenceHigh << 32) + timeReferenceLow;
+
+            drwav_buffer_reader_read_u16(&reader, &pMetadata->data.bext.version);
+
+            pMetadata->data.bext.pUMID = drwav__metadata_get_memory(pParser, DRWAV_BEXT_UMID_BYTES, 1);
+            drwav_buffer_reader_read(&reader, pMetadata->data.bext.pUMID, DRWAV_BEXT_UMID_BYTES, NULL);
+
+            drwav_buffer_reader_read_u16(&reader, &pMetadata->data.bext.loudnessValue);
+            drwav_buffer_reader_read_u16(&reader, &pMetadata->data.bext.loudnessRange);
+            drwav_buffer_reader_read_u16(&reader, &pMetadata->data.bext.maxTruePeakLevel);
+            drwav_buffer_reader_read_u16(&reader, &pMetadata->data.bext.maxMomentaryLoudness);
+            drwav_buffer_reader_read_u16(&reader, &pMetadata->data.bext.maxShortTermLoudness);
+
+            DRWAV_ASSERT((drwav_offset_ptr(drwav_buffer_reader_ptr(&reader), DRWAV_BEXT_RESERVED_BYTES)) == (bextData + DRWAV_BEXT_BYTES));
+
+            extraBytes = (size_t)(chunkSize - DRWAV_BEXT_BYTES);
+            if (extraBytes > 0) {
+                pMetadata->data.bext.pCodingHistory = (char*)drwav__metadata_get_memory(pParser, extraBytes + 1, 1);
+                DRWAV_ASSERT(pMetadata->data.bext.pCodingHistory != NULL);
+
+                bytesRead += drwav__metadata_parser_read(pParser, pMetadata->data.bext.pCodingHistory, extraBytes, NULL);
+                pMetadata->data.bext.codingHistorySize = (drwav_uint32)drwav__strlen(pMetadata->data.bext.pCodingHistory);
+            } else {
+                pMetadata->data.bext.pCodingHistory    = NULL;
+                pMetadata->data.bext.codingHistorySize = 0;
+            }
+        }
+    }
+
+    return bytesRead;
+}
+
+DRWAV_PRIVATE drwav_uint64 drwav__read_list_label_or_note_to_metadata_obj(drwav__metadata_parser* pParser, drwav_metadata* pMetadata, drwav_uint64 chunkSize, drwav_metadata_type type)
+{
+    drwav_uint8 cueIDBuffer[DRWAV_LIST_LABEL_OR_NOTE_BYTES];
+    drwav_uint64 totalBytesRead = 0;
+    size_t bytesJustRead = drwav__metadata_parser_read(pParser, cueIDBuffer, sizeof(cueIDBuffer), &totalBytesRead);
+
+    DRWAV_ASSERT(pParser->stage == drwav__metadata_parser_stage_read);    
+
+    if (bytesJustRead == sizeof(cueIDBuffer)) {
+        drwav_uint32 sizeIncludingNullTerminator;
+
+        pMetadata->type = type;
+        pMetadata->data.labelOrNote.cuePointId = drwav_bytes_to_u32(cueIDBuffer);
+
+        sizeIncludingNullTerminator = (drwav_uint32)chunkSize - DRWAV_LIST_LABEL_OR_NOTE_BYTES;
+        if (sizeIncludingNullTerminator > 0) {
+            pMetadata->data.labelOrNote.stringLength = sizeIncludingNullTerminator - 1;
+            pMetadata->data.labelOrNote.pString      = (char*)drwav__metadata_get_memory(pParser, sizeIncludingNullTerminator, 1);
+            DRWAV_ASSERT(pMetadata->data.labelOrNote.pString != NULL);
+
+            drwav__metadata_parser_read(pParser, pMetadata->data.labelOrNote.pString, sizeIncludingNullTerminator, &totalBytesRead);
+        } else {
+            pMetadata->data.labelOrNote.stringLength = 0;
+            pMetadata->data.labelOrNote.pString      = NULL;
+        }
+    }
+
+    return totalBytesRead;
+}
+
+DRWAV_PRIVATE drwav_uint64 drwav__read_list_labelled_cue_region_to_metadata_obj(drwav__metadata_parser* pParser, drwav_metadata* pMetadata, drwav_uint64 chunkSize)
+{
+    drwav_uint8 buffer[DRWAV_LIST_LABELLED_TEXT_BYTES];
+    drwav_uint64 totalBytesRead = 0;
+    size_t bytesJustRead = drwav__metadata_parser_read(pParser, buffer, sizeof(buffer), &totalBytesRead);
+
+    DRWAV_ASSERT(pParser->stage == drwav__metadata_parser_stage_read);
+
+    if (bytesJustRead == sizeof(buffer)) {
+        drwav_uint32 sizeIncludingNullTerminator;
+
+        pMetadata->type                                = drwav_metadata_type_list_labelled_cue_region;
+        pMetadata->data.labelledCueRegion.cuePointId   = drwav_bytes_to_u32(buffer + 0);
+        pMetadata->data.labelledCueRegion.sampleLength = drwav_bytes_to_u32(buffer + 4);
+        pMetadata->data.labelledCueRegion.purposeId[0] = buffer[8];
+        pMetadata->data.labelledCueRegion.purposeId[1] = buffer[9];
+        pMetadata->data.labelledCueRegion.purposeId[2] = buffer[10];
+        pMetadata->data.labelledCueRegion.purposeId[3] = buffer[11];
+        pMetadata->data.labelledCueRegion.country      = drwav_bytes_to_u16(buffer + 12);
+        pMetadata->data.labelledCueRegion.language     = drwav_bytes_to_u16(buffer + 14);
+        pMetadata->data.labelledCueRegion.dialect      = drwav_bytes_to_u16(buffer + 16);
+        pMetadata->data.labelledCueRegion.codePage     = drwav_bytes_to_u16(buffer + 18);
+
+        sizeIncludingNullTerminator = (drwav_uint32)chunkSize - DRWAV_LIST_LABELLED_TEXT_BYTES;
+        if (sizeIncludingNullTerminator > 0) {
+            pMetadata->data.labelledCueRegion.stringLength = sizeIncludingNullTerminator - 1;
+            pMetadata->data.labelledCueRegion.pString      = (char*)drwav__metadata_get_memory(pParser, sizeIncludingNullTerminator, 1);
+            DRWAV_ASSERT(pMetadata->data.labelledCueRegion.pString != NULL);
+
+            drwav__metadata_parser_read(pParser, pMetadata->data.labelledCueRegion.pString, sizeIncludingNullTerminator, &totalBytesRead);
+        } else {
+            pMetadata->data.labelledCueRegion.stringLength = 0;
+            pMetadata->data.labelledCueRegion.pString      = NULL;
+        }
+    }
+
+    return totalBytesRead;
+}
+
+DRWAV_PRIVATE drwav_uint64 drwav__metadata_process_info_text_chunk(drwav__metadata_parser* pParser, drwav_uint64 chunkSize, drwav_metadata_type type)
+{
+    drwav_uint64 bytesRead = 0;
+    drwav_uint32 stringSizeWithNullTerminator = (drwav_uint32)chunkSize;
+
+    if (pParser->stage == drwav__metadata_parser_stage_count) {
+        pParser->metadataCount += 1;
+        drwav__metadata_request_extra_memory_for_stage_2(pParser, stringSizeWithNullTerminator, 1);
+    } else {
+        drwav_metadata* pMetadata = &pParser->pMetadata[pParser->metadataCursor];
+        pMetadata->type = type;
+        if (stringSizeWithNullTerminator > 0) {
+            pMetadata->data.infoText.stringLength = stringSizeWithNullTerminator - 1;
+            pMetadata->data.infoText.pString = (char*)drwav__metadata_get_memory(pParser, stringSizeWithNullTerminator, 1);
+            DRWAV_ASSERT(pMetadata->data.infoText.pString != NULL);
+
+            bytesRead = drwav__metadata_parser_read(pParser, pMetadata->data.infoText.pString, (size_t)stringSizeWithNullTerminator, NULL);
+            if (bytesRead == chunkSize) {
+                pParser->metadataCursor += 1;
+            } else {
+                /* Failed to parse. */
+            }
+        } else {
+            pMetadata->data.infoText.stringLength = 0;
+            pMetadata->data.infoText.pString      = NULL;
+            pParser->metadataCursor += 1;
+        }
+    }
+
+    return bytesRead;
+}
+
+DRWAV_PRIVATE drwav_uint64 drwav__metadata_process_unknown_chunk(drwav__metadata_parser* pParser, const drwav_uint8* pChunkId, drwav_uint64 chunkSize, drwav_metadata_location location)
+{
+    drwav_uint64 bytesRead = 0;
+
+    if (location == drwav_metadata_location_invalid) {
+        return 0;
+    }
+
+    if (drwav_fourcc_equal(pChunkId, "data") || drwav_fourcc_equal(pChunkId, "fmt") || drwav_fourcc_equal(pChunkId, "fact")) {
+        return 0;
+    }
+
+    if (pParser->stage == drwav__metadata_parser_stage_count) {
+        pParser->metadataCount += 1;
+        drwav__metadata_request_extra_memory_for_stage_2(pParser, (size_t)chunkSize, 1);
+    } else {
+        drwav_metadata* pMetadata = &pParser->pMetadata[pParser->metadataCursor];
+        pMetadata->type                         = drwav_metadata_type_unknown;
+        pMetadata->data.unknown.chunkLocation   = location;
+        pMetadata->data.unknown.id[0]           = pChunkId[0];
+        pMetadata->data.unknown.id[1]           = pChunkId[1];
+        pMetadata->data.unknown.id[2]           = pChunkId[2];
+        pMetadata->data.unknown.id[3]           = pChunkId[3];
+        pMetadata->data.unknown.dataSizeInBytes = (drwav_uint32)chunkSize;
+        pMetadata->data.unknown.pData           = (drwav_uint8 *)drwav__metadata_get_memory(pParser, (size_t)chunkSize, 1);
+        DRWAV_ASSERT(pMetadata->data.unknown.pData != NULL);
+
+        bytesRead = drwav__metadata_parser_read(pParser, pMetadata->data.unknown.pData, pMetadata->data.unknown.dataSizeInBytes, NULL);
+        if (bytesRead == pMetadata->data.unknown.dataSizeInBytes) {
+            pParser->metadataCursor += 1;
+        } else {
+            /* Failed to read. */
+        }
+    }
+
+    return bytesRead;
+}
+
+DRWAV_PRIVATE drwav_bool32 drwav__chunk_matches(drwav_metadata_type allowedMetadataTypes, const drwav_uint8* pChunkID, drwav_metadata_type type, const char* pID)
+{
+    return (allowedMetadataTypes & type) && drwav_fourcc_equal(pChunkID, pID);
+}
+
+DRWAV_PRIVATE drwav_uint64 drwav__metadata_process_chunk(drwav__metadata_parser* pParser, const drwav_chunk_header* pChunkHeader, drwav_metadata_type allowedMetadataTypes)
+{
+    const drwav_uint8 *pChunkID = pChunkHeader->id.fourcc;
+    drwav_uint64 bytesRead = 0;
+
+    if (drwav__chunk_matches(allowedMetadataTypes, pChunkID, drwav_metadata_type_smpl, "smpl")) {
+        if (pChunkHeader->sizeInBytes >= DRWAV_SMPL_BYTES) {
+            if (pParser->stage == drwav__metadata_parser_stage_count) {
+                drwav_uint8 buffer[4];
+                size_t bytesJustRead;
+
+                if (!pParser->onSeek(pParser->pReadSeekUserData, 28, drwav_seek_origin_current)) {
+                    return bytesRead;
+                }
+                bytesRead += 28;
+
+                bytesJustRead = drwav__metadata_parser_read(pParser, buffer, sizeof(buffer), &bytesRead);
+                if (bytesJustRead == sizeof(buffer)) {
+                    drwav_uint32 loopCount = drwav_bytes_to_u32(buffer);
+                    drwav_uint64 calculatedLoopCount;
+
+                    /* The loop count must be validated against the size of the chunk. */
+                    calculatedLoopCount = (pChunkHeader->sizeInBytes - DRWAV_SMPL_BYTES) / DRWAV_SMPL_LOOP_BYTES;
+                    if (calculatedLoopCount == loopCount) {
+                        bytesJustRead = drwav__metadata_parser_read(pParser, buffer, sizeof(buffer), &bytesRead);
+                        if (bytesJustRead == sizeof(buffer)) {
+                            drwav_uint32 samplerSpecificDataSizeInBytes = drwav_bytes_to_u32(buffer);
+
+                            pParser->metadataCount += 1;
+                            drwav__metadata_request_extra_memory_for_stage_2(pParser, sizeof(drwav_smpl_loop) * loopCount, DRWAV_METADATA_ALIGNMENT);
+                            drwav__metadata_request_extra_memory_for_stage_2(pParser, samplerSpecificDataSizeInBytes, 1);
+                        }
+                    } else {
+                        /* Loop count in header does not match the size of the chunk. */
+                    }                    
+                }
+            } else {
+                bytesRead = drwav__read_smpl_to_metadata_obj(pParser, pChunkHeader, &pParser->pMetadata[pParser->metadataCursor]);
+                if (bytesRead == pChunkHeader->sizeInBytes) {
+                    pParser->metadataCursor += 1;
+                } else {
+                    /* Failed to parse. */
+                }
+            }
+        } else {
+            /* Incorrectly formed chunk. */
+        }
+    } else if (drwav__chunk_matches(allowedMetadataTypes, pChunkID, drwav_metadata_type_inst, "inst")) {
+        if (pChunkHeader->sizeInBytes == DRWAV_INST_BYTES) {
+            if (pParser->stage == drwav__metadata_parser_stage_count) {
+                pParser->metadataCount += 1;
+            } else {
+                bytesRead = drwav__read_inst_to_metadata_obj(pParser, &pParser->pMetadata[pParser->metadataCursor]);
+                if (bytesRead == pChunkHeader->sizeInBytes) {
+                    pParser->metadataCursor += 1;
+                } else {
+                    /* Failed to parse. */
+                }
+            }
+        } else {
+            /* Incorrectly formed chunk. */
+        }
+    } else if (drwav__chunk_matches(allowedMetadataTypes, pChunkID, drwav_metadata_type_acid, "acid")) {
+        if (pChunkHeader->sizeInBytes == DRWAV_ACID_BYTES) {
+            if (pParser->stage == drwav__metadata_parser_stage_count) {
+                pParser->metadataCount += 1;
+            } else {
+                bytesRead = drwav__read_acid_to_metadata_obj(pParser, &pParser->pMetadata[pParser->metadataCursor]);
+                if (bytesRead == pChunkHeader->sizeInBytes) {
+                    pParser->metadataCursor += 1;
+                } else {
+                    /* Failed to parse. */
+                }
+            }
+        } else {
+            /* Incorrectly formed chunk. */
+        }
+    } else if (drwav__chunk_matches(allowedMetadataTypes, pChunkID, drwav_metadata_type_cue, "cue ")) {
+        if (pChunkHeader->sizeInBytes >= DRWAV_CUE_BYTES) {
+            if (pParser->stage == drwav__metadata_parser_stage_count) {
+                size_t cueCount;
+
+                pParser->metadataCount += 1;
+                cueCount = (size_t)(pChunkHeader->sizeInBytes - DRWAV_CUE_BYTES) / DRWAV_CUE_POINT_BYTES;
+                drwav__metadata_request_extra_memory_for_stage_2(pParser, sizeof(drwav_cue_point) * cueCount, DRWAV_METADATA_ALIGNMENT);
+            } else {
+                bytesRead = drwav__read_cue_to_metadata_obj(pParser, pChunkHeader, &pParser->pMetadata[pParser->metadataCursor]);
+                if (bytesRead == pChunkHeader->sizeInBytes) {
+                    pParser->metadataCursor += 1;
+                } else {
+                    /* Failed to parse. */
+                }
+            }
+        } else {
+            /* Incorrectly formed chunk. */
+        }
+    } else if (drwav__chunk_matches(allowedMetadataTypes, pChunkID, drwav_metadata_type_bext, "bext")) {
+        if (pChunkHeader->sizeInBytes >= DRWAV_BEXT_BYTES) {
+            if (pParser->stage == drwav__metadata_parser_stage_count) {
+                /* The description field is the largest one in a bext chunk, so that is the max size of this temporary buffer. */
+                char buffer[DRWAV_BEXT_DESCRIPTION_BYTES + 1];
+                size_t allocSizeNeeded = DRWAV_BEXT_UMID_BYTES; /* We know we will need SMPTE umid size. */
+                size_t bytesJustRead;
+
+                buffer[DRWAV_BEXT_DESCRIPTION_BYTES] = '\0';
+                bytesJustRead = drwav__metadata_parser_read(pParser, buffer, DRWAV_BEXT_DESCRIPTION_BYTES, &bytesRead);
+                if (bytesJustRead != DRWAV_BEXT_DESCRIPTION_BYTES) {
+                    return bytesRead;
+                }
+                allocSizeNeeded += drwav__strlen(buffer) + 1;
+
+                buffer[DRWAV_BEXT_ORIGINATOR_NAME_BYTES] = '\0';
+                bytesJustRead = drwav__metadata_parser_read(pParser, buffer, DRWAV_BEXT_ORIGINATOR_NAME_BYTES, &bytesRead);
+                if (bytesJustRead != DRWAV_BEXT_ORIGINATOR_NAME_BYTES) {
+                    return bytesRead;
+                }
+                allocSizeNeeded += drwav__strlen(buffer) + 1;
+
+                buffer[DRWAV_BEXT_ORIGINATOR_REF_BYTES] = '\0';
+                bytesJustRead = drwav__metadata_parser_read(pParser, buffer, DRWAV_BEXT_ORIGINATOR_REF_BYTES, &bytesRead);
+                if (bytesJustRead != DRWAV_BEXT_ORIGINATOR_REF_BYTES) {
+                    return bytesRead;
+                }
+                allocSizeNeeded += drwav__strlen(buffer) + 1;
+                allocSizeNeeded += (size_t)pChunkHeader->sizeInBytes - DRWAV_BEXT_BYTES; /* Coding history. */
+
+                drwav__metadata_request_extra_memory_for_stage_2(pParser, allocSizeNeeded, 1);
+
+                pParser->metadataCount += 1;
+            } else {
+                bytesRead = drwav__read_bext_to_metadata_obj(pParser, &pParser->pMetadata[pParser->metadataCursor], pChunkHeader->sizeInBytes);
+                if (bytesRead == pChunkHeader->sizeInBytes) {
+                    pParser->metadataCursor += 1;
+                } else {
+                    /* Failed to parse. */
+                }
+            }
+        } else {
+            /* Incorrectly formed chunk. */
+        }
+    } else if (drwav_fourcc_equal(pChunkID, "LIST") || drwav_fourcc_equal(pChunkID, "list")) {
+        drwav_metadata_location listType = drwav_metadata_location_invalid;
+        while (bytesRead < pChunkHeader->sizeInBytes) {
+            drwav_uint8 subchunkId[4];
+            drwav_uint8 subchunkSizeBuffer[4];
+            drwav_uint64 subchunkDataSize;
+            drwav_uint64 subchunkBytesRead = 0;
+            drwav_uint64 bytesJustRead = drwav__metadata_parser_read(pParser, subchunkId, sizeof(subchunkId), &bytesRead);
+            if (bytesJustRead != sizeof(subchunkId)) {
+                break;
+            }
+
+            /*
+            The first thing in a list chunk should be "adtl" or "INFO".
+
+              - adtl means this list is a Associated Data List Chunk and will contain labels, notes
+                or labelled cue regions.
+              - INFO means this list is an Info List Chunk containing info text chunks such as IPRD
+                which would specifies the album of this wav file.
+
+            No data follows the adtl or INFO id so we just make note of what type this list is and
+            continue.
+            */
+            if (drwav_fourcc_equal(subchunkId, "adtl")) {
+                listType = drwav_metadata_location_inside_adtl_list;
+                continue;
+            } else if (drwav_fourcc_equal(subchunkId, "INFO")) {
+                listType = drwav_metadata_location_inside_info_list;
+                continue;
+            }
+
+            bytesJustRead = drwav__metadata_parser_read(pParser, subchunkSizeBuffer, sizeof(subchunkSizeBuffer), &bytesRead);
+            if (bytesJustRead != sizeof(subchunkSizeBuffer)) {
+                break;
+            }
+            subchunkDataSize = drwav_bytes_to_u32(subchunkSizeBuffer);
+
+            if (drwav__chunk_matches(allowedMetadataTypes, subchunkId, drwav_metadata_type_list_label, "labl") || drwav__chunk_matches(allowedMetadataTypes, subchunkId, drwav_metadata_type_list_note, "note")) {
+                if (subchunkDataSize >= DRWAV_LIST_LABEL_OR_NOTE_BYTES) {
+                    drwav_uint64 stringSizeWithNullTerm = subchunkDataSize - DRWAV_LIST_LABEL_OR_NOTE_BYTES;
+                    if (pParser->stage == drwav__metadata_parser_stage_count) {
+                        pParser->metadataCount += 1;
+                        drwav__metadata_request_extra_memory_for_stage_2(pParser, (size_t)stringSizeWithNullTerm, 1);
+                    } else {
+                        subchunkBytesRead = drwav__read_list_label_or_note_to_metadata_obj(pParser, &pParser->pMetadata[pParser->metadataCursor], subchunkDataSize, drwav_fourcc_equal(subchunkId, "labl") ? drwav_metadata_type_list_label : drwav_metadata_type_list_note);
+                        if (subchunkBytesRead == subchunkDataSize) {
+                            pParser->metadataCursor += 1;
+                        } else {
+                            /* Failed to parse. */
+                        }
+                    }
+                } else {
+                    /* Incorrectly formed chunk. */
+                }
+            } else if (drwav__chunk_matches(allowedMetadataTypes, subchunkId, drwav_metadata_type_list_labelled_cue_region, "ltxt")) {
+                if (subchunkDataSize >= DRWAV_LIST_LABELLED_TEXT_BYTES) {
+                    drwav_uint64 stringSizeWithNullTerminator = subchunkDataSize - DRWAV_LIST_LABELLED_TEXT_BYTES;
+                    if (pParser->stage == drwav__metadata_parser_stage_count) {
+                        pParser->metadataCount += 1;
+                        drwav__metadata_request_extra_memory_for_stage_2(pParser, (size_t)stringSizeWithNullTerminator, 1);
+                    } else {
+                        subchunkBytesRead = drwav__read_list_labelled_cue_region_to_metadata_obj(pParser, &pParser->pMetadata[pParser->metadataCursor], subchunkDataSize);
+                        if (subchunkBytesRead == subchunkDataSize) {
+                            pParser->metadataCursor += 1;
+                        } else {
+                            /* Failed to parse. */
+                        }
+                    }
+                } else {
+                    /* Incorrectly formed chunk. */
+                }
+            } else if (drwav__chunk_matches(allowedMetadataTypes, subchunkId, drwav_metadata_type_list_info_software, "ISFT")) {
+                subchunkBytesRead = drwav__metadata_process_info_text_chunk(pParser, subchunkDataSize,  drwav_metadata_type_list_info_software);
+            } else if (drwav__chunk_matches(allowedMetadataTypes, subchunkId, drwav_metadata_type_list_info_copyright, "ICOP")) {
+                subchunkBytesRead = drwav__metadata_process_info_text_chunk(pParser, subchunkDataSize,  drwav_metadata_type_list_info_copyright);
+            } else if (drwav__chunk_matches(allowedMetadataTypes, subchunkId, drwav_metadata_type_list_info_title, "INAM")) {
+                subchunkBytesRead = drwav__metadata_process_info_text_chunk(pParser, subchunkDataSize,  drwav_metadata_type_list_info_title);
+            } else if (drwav__chunk_matches(allowedMetadataTypes, subchunkId, drwav_metadata_type_list_info_artist, "IART")) {
+                subchunkBytesRead = drwav__metadata_process_info_text_chunk(pParser, subchunkDataSize,  drwav_metadata_type_list_info_artist);
+            } else if (drwav__chunk_matches(allowedMetadataTypes, subchunkId, drwav_metadata_type_list_info_comment, "ICMT")) {
+                subchunkBytesRead = drwav__metadata_process_info_text_chunk(pParser, subchunkDataSize,  drwav_metadata_type_list_info_comment);
+            } else if (drwav__chunk_matches(allowedMetadataTypes, subchunkId, drwav_metadata_type_list_info_date, "ICRD")) {
+                subchunkBytesRead = drwav__metadata_process_info_text_chunk(pParser, subchunkDataSize,  drwav_metadata_type_list_info_date);
+            } else if (drwav__chunk_matches(allowedMetadataTypes, subchunkId, drwav_metadata_type_list_info_genre, "IGNR")) {
+                subchunkBytesRead = drwav__metadata_process_info_text_chunk(pParser, subchunkDataSize,  drwav_metadata_type_list_info_genre);
+            } else if (drwav__chunk_matches(allowedMetadataTypes, subchunkId, drwav_metadata_type_list_info_album, "IPRD")) {
+                subchunkBytesRead = drwav__metadata_process_info_text_chunk(pParser, subchunkDataSize,  drwav_metadata_type_list_info_album);
+            } else if (drwav__chunk_matches(allowedMetadataTypes, subchunkId, drwav_metadata_type_list_info_tracknumber, "ITRK")) {
+                subchunkBytesRead = drwav__metadata_process_info_text_chunk(pParser, subchunkDataSize,  drwav_metadata_type_list_info_tracknumber);
+            } else if ((allowedMetadataTypes & drwav_metadata_type_unknown) != 0) {
+                subchunkBytesRead = drwav__metadata_process_unknown_chunk(pParser, subchunkId, subchunkDataSize, listType);
+            }
+
+            bytesRead += subchunkBytesRead;
+            DRWAV_ASSERT(subchunkBytesRead <= subchunkDataSize);
+
+            if (subchunkBytesRead < subchunkDataSize) {
+                drwav_uint64 bytesToSeek = subchunkDataSize - subchunkBytesRead;
+
+                if (!pParser->onSeek(pParser->pReadSeekUserData, (int)bytesToSeek, drwav_seek_origin_current)) {
+                    break;
+                }
+                bytesRead += bytesToSeek;
+            }
+
+            if ((subchunkDataSize % 2) == 1) {
+                if (!pParser->onSeek(pParser->pReadSeekUserData, 1, drwav_seek_origin_current)) {
+                    break;
+                }
+                bytesRead += 1;
+            }
+        }
+    } else if ((allowedMetadataTypes & drwav_metadata_type_unknown) != 0) {
+        bytesRead = drwav__metadata_process_unknown_chunk(pParser, pChunkID, pChunkHeader->sizeInBytes, drwav_metadata_location_top_level);
+    }
+
+    return bytesRead;
+}
+
+
+DRWAV_PRIVATE drwav_uint32 drwav_get_bytes_per_pcm_frame(drwav* pWav)
+{
+    drwav_uint32 bytesPerFrame;
+
     /*
     The bytes per frame is a bit ambiguous. It can be either be based on the bits per sample, or the block align. The way I'm doing it here
     is that if the bits per sample is a multiple of 8, use floor(bitsPerSample*channels/8), otherwise fall back to the block align.
     */
     if ((pWav->bitsPerSample & 0x7) == 0) {
         /* Bits per sample is a multiple of 8. */
-        return (pWav->bitsPerSample * pWav->fmt.channels) >> 3;
+        bytesPerFrame = (pWav->bitsPerSample * pWav->fmt.channels) >> 3;
     } else {
-        return pWav->fmt.blockAlign;
+        bytesPerFrame = pWav->fmt.blockAlign;
     }
+
+    /* Validation for known formats. a-law and mu-law should be 1 byte per channel. If it's not, it's not decodable. */
+    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ALAW || pWav->translatedFormatTag == DR_WAVE_FORMAT_MULAW) {
+        if (bytesPerFrame != pWav->fmt.channels) {
+            return 0;   /* Invalid file. */
+        }
+    }
+
+    return bytesPerFrame;
 }
 
 DRWAV_API drwav_uint16 drwav_fmt_get_format(const drwav_fmt* pFMT)
 {
     if (pFMT == NULL) {
         return 0;
     }
 
     if (pFMT->formatTag != DR_WAVE_FORMAT_EXTENSIBLE) {
         return pFMT->formatTag;
     } else {
-        return drwav__bytes_to_u16(pFMT->subFormat);    /* Only the first two bytes are required. */
+        return drwav_bytes_to_u16(pFMT->subFormat);    /* Only the first two bytes are required. */
     }
 }
 
-static drwav_bool32 drwav_preinit(drwav* pWav, drwav_read_proc onRead, drwav_seek_proc onSeek, void* pReadSeekUserData, const drwav_allocation_callbacks* pAllocationCallbacks)
+DRWAV_PRIVATE drwav_bool32 drwav_preinit(drwav* pWav, drwav_read_proc onRead, drwav_seek_proc onSeek, void* pReadSeekUserData, const drwav_allocation_callbacks* pAllocationCallbacks)
 {
     if (pWav == NULL || onRead == NULL || onSeek == NULL) {
         return DRWAV_FALSE;
     }
 
     DRWAV_ZERO_MEMORY(pWav, sizeof(*pWav));
     pWav->onRead    = onRead;
@@ -1761,43 +3011,44 @@
     if (pWav->allocationCallbacks.onFree == NULL || (pWav->allocationCallbacks.onMalloc == NULL && pWav->allocationCallbacks.onRealloc == NULL)) {
         return DRWAV_FALSE;    /* Invalid allocation callbacks. */
     }
 
     return DRWAV_TRUE;
 }
 
-static drwav_bool32 drwav_init__internal(drwav* pWav, drwav_chunk_proc onChunk, void* pChunkUserData, drwav_uint32 flags)
+DRWAV_PRIVATE drwav_bool32 drwav_init__internal(drwav* pWav, drwav_chunk_proc onChunk, void* pChunkUserData, drwav_uint32 flags)
 {
     /* This function assumes drwav_preinit() has been called beforehand. */
 
     drwav_uint64 cursor;    /* <-- Keeps track of the byte position so we can seek to specific locations. */
     drwav_bool32 sequential;
-    unsigned char riff[4];
+    drwav_uint8 riff[4];
     drwav_fmt fmt;
     unsigned short translatedFormatTag;
-    drwav_uint64 sampleCountFromFactChunk;
     drwav_bool32 foundDataChunk;
-    drwav_uint64 dataChunkSize;
+    drwav_uint64 dataChunkSize = 0; /* <-- Important! Don't explicitly set this to 0 anywhere else. Calculation of the size of the data chunk is performed in different paths depending on the container. */
+    drwav_uint64 sampleCountFromFactChunk = 0;  /* Same as dataChunkSize - make sure this is the only place this is initialized to 0. */
     drwav_uint64 chunkSize;
+    drwav__metadata_parser metadataParser;
 
     cursor = 0;
     sequential = (flags & DRWAV_SEQUENTIAL) != 0;
 
     /* The first 4 bytes should be the RIFF identifier. */
     if (drwav__on_read(pWav->onRead, pWav->pUserData, riff, sizeof(riff), &cursor) != sizeof(riff)) {
         return DRWAV_FALSE;
     }
 
     /*
     The first 4 bytes can be used to identify the container. For RIFF files it will start with "RIFF" and for
     w64 it will start with "riff".
     */
-    if (drwav__fourcc_equal(riff, "RIFF")) {
+    if (drwav_fourcc_equal(riff, "RIFF")) {
         pWav->container = drwav_container_riff;
-    } else if (drwav__fourcc_equal(riff, "riff")) {
+    } else if (drwav_fourcc_equal(riff, "riff")) {
         int i;
         drwav_uint8 riff2[12];
 
         pWav->container = drwav_container_w64;
 
         /* Check the rest of the GUID for validity. */
         if (drwav__on_read(pWav->onRead, pWav->pUserData, riff2, sizeof(riff2), &cursor) != sizeof(riff2)) {
@@ -1805,62 +3056,118 @@
         }
 
         for (i = 0; i < 12; ++i) {
             if (riff2[i] != drwavGUID_W64_RIFF[i+4]) {
                 return DRWAV_FALSE;
             }
         }
+    } else if (drwav_fourcc_equal(riff, "RF64")) {
+        pWav->container = drwav_container_rf64;
     } else {
         return DRWAV_FALSE;   /* Unknown or unsupported container. */
     }
 
 
-    if (pWav->container == drwav_container_riff) {
-        unsigned char chunkSizeBytes[4];
-        unsigned char wave[4];
+    if (pWav->container == drwav_container_riff || pWav->container == drwav_container_rf64) {
+        drwav_uint8 chunkSizeBytes[4];
+        drwav_uint8 wave[4];
 
         /* RIFF/WAVE */
         if (drwav__on_read(pWav->onRead, pWav->pUserData, chunkSizeBytes, sizeof(chunkSizeBytes), &cursor) != sizeof(chunkSizeBytes)) {
             return DRWAV_FALSE;
         }
 
-        if (drwav__bytes_to_u32(chunkSizeBytes) < 36) {
-            return DRWAV_FALSE;    /* Chunk size should always be at least 36 bytes. */
+        if (pWav->container == drwav_container_riff) {
+            if (drwav_bytes_to_u32(chunkSizeBytes) < 36) {
+                return DRWAV_FALSE;    /* Chunk size should always be at least 36 bytes. */
+            }
+        } else {
+            if (drwav_bytes_to_u32(chunkSizeBytes) != 0xFFFFFFFF) {
+                return DRWAV_FALSE;    /* Chunk size should always be set to -1/0xFFFFFFFF for RF64. The actual size is retrieved later. */
+            }
         }
 
         if (drwav__on_read(pWav->onRead, pWav->pUserData, wave, sizeof(wave), &cursor) != sizeof(wave)) {
             return DRWAV_FALSE;
         }
 
-        if (!drwav__fourcc_equal(wave, "WAVE")) {
+        if (!drwav_fourcc_equal(wave, "WAVE")) {
             return DRWAV_FALSE;    /* Expecting "WAVE". */
         }
     } else {
-        unsigned char chunkSizeBytes[8];
+        drwav_uint8 chunkSizeBytes[8];
         drwav_uint8 wave[16];
 
         /* W64 */
         if (drwav__on_read(pWav->onRead, pWav->pUserData, chunkSizeBytes, sizeof(chunkSizeBytes), &cursor) != sizeof(chunkSizeBytes)) {
             return DRWAV_FALSE;
         }
 
-        if (drwav__bytes_to_u64(chunkSizeBytes) < 80) {
+        if (drwav_bytes_to_u64(chunkSizeBytes) < 80) {
             return DRWAV_FALSE;
         }
 
         if (drwav__on_read(pWav->onRead, pWav->pUserData, wave, sizeof(wave), &cursor) != sizeof(wave)) {
             return DRWAV_FALSE;
         }
 
-        if (!drwav__guid_equal(wave, drwavGUID_W64_WAVE)) {
+        if (!drwav_guid_equal(wave, drwavGUID_W64_WAVE)) {
             return DRWAV_FALSE;
         }
     }
 
 
+    /* For RF64, the "ds64" chunk must come next, before the "fmt " chunk. */
+    if (pWav->container == drwav_container_rf64) {
+        drwav_uint8 sizeBytes[8];
+        drwav_uint64 bytesRemainingInChunk;
+        drwav_chunk_header header;
+        drwav_result result = drwav__read_chunk_header(pWav->onRead, pWav->pUserData, pWav->container, &cursor, &header);
+        if (result != DRWAV_SUCCESS) {
+            return DRWAV_FALSE;
+        }
+
+        if (!drwav_fourcc_equal(header.id.fourcc, "ds64")) {
+            return DRWAV_FALSE; /* Expecting "ds64". */
+        }
+
+        bytesRemainingInChunk = header.sizeInBytes + header.paddingSize;
+
+        /* We don't care about the size of the RIFF chunk - skip it. */
+        if (!drwav__seek_forward(pWav->onSeek, 8, pWav->pUserData)) {
+            return DRWAV_FALSE;
+        }
+        bytesRemainingInChunk -= 8;
+        cursor += 8;
+
+
+        /* Next 8 bytes is the size of the "data" chunk. */
+        if (drwav__on_read(pWav->onRead, pWav->pUserData, sizeBytes, sizeof(sizeBytes), &cursor) != sizeof(sizeBytes)) {
+            return DRWAV_FALSE;
+        }
+        bytesRemainingInChunk -= 8;
+        dataChunkSize = drwav_bytes_to_u64(sizeBytes);
+
+
+        /* Next 8 bytes is the same count which we would usually derived from the FACT chunk if it was available. */
+        if (drwav__on_read(pWav->onRead, pWav->pUserData, sizeBytes, sizeof(sizeBytes), &cursor) != sizeof(sizeBytes)) {
+            return DRWAV_FALSE;
+        }
+        bytesRemainingInChunk -= 8;
+        sampleCountFromFactChunk = drwav_bytes_to_u64(sizeBytes);
+
+
+        /* Skip over everything else. */
+        if (!drwav__seek_forward(pWav->onSeek, bytesRemainingInChunk, pWav->pUserData)) {
+            return DRWAV_FALSE;
+        }
+        cursor += bytesRemainingInChunk;
+    }
+
+
     /* The next bytes should be the "fmt " chunk. */
     if (!drwav__read_fmt(pWav->onRead, pWav->onSeek, pWav->pUserData, pWav->container, &cursor, &fmt)) {
         return DRWAV_FALSE;    /* Failed to read the "fmt " chunk. */
     }
 
     /* Basic validation. */
     if ((fmt.sampleRate    == 0 || fmt.sampleRate    > DRWAV_MAX_SAMPLE_RATE)     ||
@@ -1870,34 +3177,68 @@
         return DRWAV_FALSE; /* Probably an invalid WAV file. */
     }
 
 
     /* Translate the internal format. */
     translatedFormatTag = fmt.formatTag;
     if (translatedFormatTag == DR_WAVE_FORMAT_EXTENSIBLE) {
-        translatedFormatTag = drwav__bytes_to_u16(fmt.subFormat + 0);
+        translatedFormatTag = drwav_bytes_to_u16(fmt.subFormat + 0);
     }
 
+    DRWAV_ZERO_MEMORY(&metadataParser, sizeof(metadataParser));
 
+    /* Not tested on W64. */
+    if (!sequential && pWav->allowedMetadataTypes != drwav_metadata_type_none && (pWav->container == drwav_container_riff || pWav->container == drwav_container_rf64)) {
+        drwav_uint64 cursorForMetadata = cursor;
+
+        metadataParser.onRead = pWav->onRead;
+        metadataParser.onSeek = pWav->onSeek;
+        metadataParser.pReadSeekUserData = pWav->pUserData;
+        metadataParser.stage = drwav__metadata_parser_stage_count;
+
+        for (;;) {
+            drwav_result result;
+            drwav_uint64 bytesRead;
+            drwav_uint64 remainingBytes;
+            drwav_chunk_header header;
+            
+            result = drwav__read_chunk_header(pWav->onRead, pWav->pUserData, pWav->container, &cursorForMetadata, &header);
+            if (result != DRWAV_SUCCESS) {
+                break;
+            }
+
+            bytesRead = drwav__metadata_process_chunk(&metadataParser, &header, pWav->allowedMetadataTypes);
+            DRWAV_ASSERT(bytesRead <= header.sizeInBytes);
+
+            remainingBytes = header.sizeInBytes - bytesRead + header.paddingSize;
+            if (!drwav__seek_forward(pWav->onSeek, remainingBytes, pWav->pUserData)) {
+                break;
+            }
+            cursorForMetadata += remainingBytes;
+        }
 
-    sampleCountFromFactChunk = 0;
+        if (!drwav__seek_from_start(pWav->onSeek, cursor, pWav->pUserData)) {
+            return DRWAV_FALSE;
+        }
+
+        drwav__metadata_alloc(&metadataParser, &pWav->allocationCallbacks);
+        metadataParser.stage = drwav__metadata_parser_stage_read;
+    }
 
     /*
     We need to enumerate over each chunk for two reasons:
       1) The "data" chunk may not be the next one
       2) We may want to report each chunk back to the client
-    
+
     In order to correctly report each chunk back to the client we will need to keep looping until the end of the file.
     */
     foundDataChunk = DRWAV_FALSE;
-    dataChunkSize = 0;
 
     /* The next chunk we care about is the "data" chunk. This is not necessarily the next chunk so we'll need to loop. */
-    for (;;)
-    {
+    for (;;) {
         drwav_chunk_header header;
         drwav_result result = drwav__read_chunk_header(pWav->onRead, pWav->pUserData, pWav->container, &cursor, &header);
         if (result != DRWAV_SUCCESS) {
             if (!foundDataChunk) {
                 return DRWAV_FALSE;
             } else {
                 break;  /* Probably at the end of the file. Get out of the loop. */
@@ -1914,28 +3255,40 @@
             */
             if (callbackBytesRead > 0) {
                 if (!drwav__seek_from_start(pWav->onSeek, cursor, pWav->pUserData)) {
                     return DRWAV_FALSE;
                 }
             }
         }
-        
+
+        if (!sequential && pWav->allowedMetadataTypes != drwav_metadata_type_none && (pWav->container == drwav_container_riff || pWav->container == drwav_container_rf64)) {
+            drwav_uint64 bytesRead = drwav__metadata_process_chunk(&metadataParser, &header, pWav->allowedMetadataTypes);
+
+            if (bytesRead > 0) {
+                if (!drwav__seek_from_start(pWav->onSeek, cursor, pWav->pUserData)) {
+                    return DRWAV_FALSE;
+                }
+            }
+        }
+
 
         if (!foundDataChunk) {
             pWav->dataChunkDataPos = cursor;
         }
 
         chunkSize = header.sizeInBytes;
-        if (pWav->container == drwav_container_riff) {
-            if (drwav__fourcc_equal(header.id.fourcc, "data")) {
+        if (pWav->container == drwav_container_riff || pWav->container == drwav_container_rf64) {
+            if (drwav_fourcc_equal(header.id.fourcc, "data")) {
                 foundDataChunk = DRWAV_TRUE;
-                dataChunkSize = chunkSize;
+                if (pWav->container != drwav_container_rf64) {  /* The data chunk size for RF64 will always be set to 0xFFFFFFFF here. It was set to it's true value earlier. */
+                    dataChunkSize = chunkSize;
+                }
             }
         } else {
-            if (drwav__guid_equal(header.id.guid, drwavGUID_W64_DATA)) {
+            if (drwav_guid_equal(header.id.guid, drwavGUID_W64_DATA)) {
                 foundDataChunk = DRWAV_TRUE;
                 dataChunkSize = chunkSize;
             }
         }
 
         /*
         If at this point we have found the data chunk and we're running in sequential mode, we need to break out of this loop. The reason for
@@ -1943,15 +3296,15 @@
         */
         if (foundDataChunk && sequential) {
             break;
         }
 
         /* Optional. Get the total sample count from the FACT chunk. This is useful for compressed formats. */
         if (pWav->container == drwav_container_riff) {
-            if (drwav__fourcc_equal(header.id.fourcc, "fact")) {
+            if (drwav_fourcc_equal(header.id.fourcc, "fact")) {
                 drwav_uint32 sampleCount;
                 if (drwav__on_read(pWav->onRead, pWav->pUserData, &sampleCount, 4, &cursor) != 4) {
                     return DRWAV_FALSE;
                 }
                 chunkSize -= 4;
 
                 if (!foundDataChunk) {
@@ -1964,118 +3317,77 @@
                 */
                 if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ADPCM) {
                     sampleCountFromFactChunk = sampleCount;
                 } else {
                     sampleCountFromFactChunk = 0;
                 }
             }
-        } else {
-            if (drwav__guid_equal(header.id.guid, drwavGUID_W64_FACT)) {
+        } else if (pWav->container == drwav_container_w64) {
+            if (drwav_guid_equal(header.id.guid, drwavGUID_W64_FACT)) {
                 if (drwav__on_read(pWav->onRead, pWav->pUserData, &sampleCountFromFactChunk, 8, &cursor) != 8) {
                     return DRWAV_FALSE;
                 }
                 chunkSize -= 8;
 
                 if (!foundDataChunk) {
                     pWav->dataChunkDataPos = cursor;
                 }
             }
-        }
-
-        /* "smpl" chunk. */
-        if (pWav->container == drwav_container_riff) {
-            if (drwav__fourcc_equal(header.id.fourcc, "smpl")) {
-                unsigned char smplHeaderData[36];    /* 36 = size of the smpl header section, not including the loop data. */
-                if (chunkSize >= sizeof(smplHeaderData)) {
-                    drwav_uint64 bytesJustRead = drwav__on_read(pWav->onRead, pWav->pUserData, smplHeaderData, sizeof(smplHeaderData), &cursor);
-                    chunkSize -= bytesJustRead;
-
-                    if (bytesJustRead == sizeof(smplHeaderData)) {
-                        drwav_uint32 iLoop;
-
-                        pWav->smpl.manufacturer      = drwav__bytes_to_u32(smplHeaderData+0);
-                        pWav->smpl.product           = drwav__bytes_to_u32(smplHeaderData+4);
-                        pWav->smpl.samplePeriod      = drwav__bytes_to_u32(smplHeaderData+8);
-                        pWav->smpl.midiUnityNotes    = drwav__bytes_to_u32(smplHeaderData+12);
-                        pWav->smpl.midiPitchFraction = drwav__bytes_to_u32(smplHeaderData+16);
-                        pWav->smpl.smpteFormat       = drwav__bytes_to_u32(smplHeaderData+20);
-                        pWav->smpl.smpteOffset       = drwav__bytes_to_u32(smplHeaderData+24);
-                        pWav->smpl.numSampleLoops    = drwav__bytes_to_u32(smplHeaderData+28);
-                        pWav->smpl.samplerData       = drwav__bytes_to_u32(smplHeaderData+32);
-
-                        for (iLoop = 0; iLoop < pWav->smpl.numSampleLoops && iLoop < drwav_countof(pWav->smpl.loops); ++iLoop) {
-                            unsigned char smplLoopData[24];  /* 24 = size of a loop section in the smpl chunk. */
-                            bytesJustRead = drwav__on_read(pWav->onRead, pWav->pUserData, smplLoopData, sizeof(smplLoopData), &cursor);
-                            chunkSize -= bytesJustRead;
-
-                            if (bytesJustRead == sizeof(smplLoopData)) {
-                                pWav->smpl.loops[iLoop].cuePointId = drwav__bytes_to_u32(smplLoopData+0);
-                                pWav->smpl.loops[iLoop].type       = drwav__bytes_to_u32(smplLoopData+4);
-                                pWav->smpl.loops[iLoop].start      = drwav__bytes_to_u32(smplLoopData+8);
-                                pWav->smpl.loops[iLoop].end        = drwav__bytes_to_u32(smplLoopData+12);
-                                pWav->smpl.loops[iLoop].fraction   = drwav__bytes_to_u32(smplLoopData+16);
-                                pWav->smpl.loops[iLoop].playCount  = drwav__bytes_to_u32(smplLoopData+20);
-                            } else {
-                                break;  /* Break from the smpl loop for loop. */
-                            }
-                        }
-                    }
-                } else {
-                    /* Looks like invalid data. Ignore the chunk. */
-                }
-            }
-        } else {
-            if (drwav__guid_equal(header.id.guid, drwavGUID_W64_SMPL)) {
-                /*
-                This path will be hit when a W64 WAV file contains a smpl chunk. I don't have a sample file to test this path, so a contribution
-                is welcome to add support for this.
-                */
-            }
+        } else if (pWav->container == drwav_container_rf64) {
+            /* We retrieved the sample count from the ds64 chunk earlier so no need to do that here. */
         }
 
         /* Make sure we seek past the padding. */
         chunkSize += header.paddingSize;
         if (!drwav__seek_forward(pWav->onSeek, chunkSize, pWav->pUserData)) {
             break;
         }
         cursor += chunkSize;
 
         if (!foundDataChunk) {
             pWav->dataChunkDataPos = cursor;
         }
     }
 
+    pWav->pMetadata     = metadataParser.pMetadata;
+    pWav->metadataCount = metadataParser.metadataCount;
+
     /* If we haven't found a data chunk, return an error. */
     if (!foundDataChunk) {
         return DRWAV_FALSE;
     }
 
     /* We may have moved passed the data chunk. If so we need to move back. If running in sequential mode we can assume we are already sitting on the data chunk. */
     if (!sequential) {
         if (!drwav__seek_from_start(pWav->onSeek, pWav->dataChunkDataPos, pWav->pUserData)) {
             return DRWAV_FALSE;
         }
         cursor = pWav->dataChunkDataPos;
     }
-    
+
 
     /* At this point we should be sitting on the first byte of the raw audio data. */
 
     pWav->fmt                 = fmt;
     pWav->sampleRate          = fmt.sampleRate;
     pWav->channels            = fmt.channels;
     pWav->bitsPerSample       = fmt.bitsPerSample;
     pWav->bytesRemaining      = dataChunkSize;
     pWav->translatedFormatTag = translatedFormatTag;
     pWav->dataChunkDataSize   = dataChunkSize;
 
     if (sampleCountFromFactChunk != 0) {
         pWav->totalPCMFrameCount = sampleCountFromFactChunk;
     } else {
-        pWav->totalPCMFrameCount = dataChunkSize / drwav_get_bytes_per_pcm_frame(pWav);
+        drwav_uint32 bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
+        if (bytesPerFrame == 0) {
+            return DRWAV_FALSE; /* Invalid file. */
+        }
+
+        pWav->totalPCMFrameCount = dataChunkSize / bytesPerFrame;
 
         if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ADPCM) {
             drwav_uint64 totalBlockHeaderSizeInBytes;
             drwav_uint64 blockCount = dataChunkSize / fmt.blockAlign;
 
             /* Make sure any trailing partial block is accounted for. */
             if ((blockCount * fmt.blockAlign) < dataChunkSize) {
@@ -2107,14 +3419,19 @@
     /* Some formats only support a certain number of channels. */
     if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ADPCM || pWav->translatedFormatTag == DR_WAVE_FORMAT_DVI_ADPCM) {
         if (pWav->channels > 2) {
             return DRWAV_FALSE;
         }
     }
 
+    /* The number of bytes per frame must be known. If not, it's an invalid file and not decodable. */
+    if (drwav_get_bytes_per_pcm_frame(pWav) == 0) {
+        return DRWAV_FALSE;
+    }
+
 #ifdef DR_WAV_LIBSNDFILE_COMPAT
     /*
     I use libsndfile as a benchmark for testing, however in the version I'm using (from the Windows installer on the libsndfile website),
     it appears the total sample count libsndfile uses for MS-ADPCM is incorrect. It would seem they are computing the total sample count
     from the number of blocks, however this results in the inclusion of extra silent samples at the end of the last block. The correct
     way to know the total sample count is to inspect the "fact" chunk, which should always be present for compressed formats, and should
     always include the sample count. This little block of code below is only used to emulate the libsndfile logic so I can properly run my
@@ -2143,49 +3460,599 @@
     if (!drwav_preinit(pWav, onRead, onSeek, pReadSeekUserData, pAllocationCallbacks)) {
         return DRWAV_FALSE;
     }
 
     return drwav_init__internal(pWav, onChunk, pChunkUserData, flags);
 }
 
+DRWAV_API drwav_bool32 drwav_init_with_metadata(drwav* pWav, drwav_read_proc onRead, drwav_seek_proc onSeek, void* pUserData, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks)
+{
+    if (!drwav_preinit(pWav, onRead, onSeek, pUserData, pAllocationCallbacks)) {
+        return DRWAV_FALSE;
+    }
+
+    pWav->allowedMetadataTypes = drwav_metadata_type_all_including_unknown;   /* <-- Needs to be set to tell drwav_init_ex() that we need to process metadata. */
+    return drwav_init__internal(pWav, NULL, NULL, flags);
+}
+
+DRWAV_API drwav_metadata* drwav_take_ownership_of_metadata(drwav* pWav)
+{
+    drwav_metadata *result = pWav->pMetadata;
+
+    pWav->pMetadata     = NULL;
+    pWav->metadataCount = 0;
+
+    return result;
+}
+
 
-static drwav_uint32 drwav__riff_chunk_size_riff(drwav_uint64 dataChunkSize)
+DRWAV_PRIVATE size_t drwav__write(drwav* pWav, const void* pData, size_t dataSize)
 {
-    drwav_uint32 dataSubchunkPaddingSize = drwav__chunk_padding_size_riff(dataChunkSize);
+    DRWAV_ASSERT(pWav          != NULL);
+    DRWAV_ASSERT(pWav->onWrite != NULL);
 
-    if (dataChunkSize <= (0xFFFFFFFFUL - 36 - dataSubchunkPaddingSize)) {
-        return 36 + (drwav_uint32)(dataChunkSize + dataSubchunkPaddingSize);
-    } else {
-        return 0xFFFFFFFF;
+    /* Generic write. Assumes no byte reordering required. */
+    return pWav->onWrite(pWav->pUserData, pData, dataSize);
+}
+
+DRWAV_PRIVATE size_t drwav__write_byte(drwav* pWav, drwav_uint8 byte)
+{
+    DRWAV_ASSERT(pWav          != NULL);
+    DRWAV_ASSERT(pWav->onWrite != NULL);
+
+    return pWav->onWrite(pWav->pUserData, &byte, 1);
+}
+
+DRWAV_PRIVATE size_t drwav__write_u16ne_to_le(drwav* pWav, drwav_uint16 value)
+{
+    DRWAV_ASSERT(pWav          != NULL);
+    DRWAV_ASSERT(pWav->onWrite != NULL);
+
+    if (!drwav__is_little_endian()) {
+        value = drwav__bswap16(value);
+    }
+
+    return drwav__write(pWav, &value, 2);
+}
+
+DRWAV_PRIVATE size_t drwav__write_u32ne_to_le(drwav* pWav, drwav_uint32 value)
+{
+    DRWAV_ASSERT(pWav          != NULL);
+    DRWAV_ASSERT(pWav->onWrite != NULL);
+
+    if (!drwav__is_little_endian()) {
+        value = drwav__bswap32(value);
+    }
+
+    return drwav__write(pWav, &value, 4);
+}
+
+DRWAV_PRIVATE size_t drwav__write_u64ne_to_le(drwav* pWav, drwav_uint64 value)
+{
+    DRWAV_ASSERT(pWav          != NULL);
+    DRWAV_ASSERT(pWav->onWrite != NULL);
+
+    if (!drwav__is_little_endian()) {
+        value = drwav__bswap64(value);
+    }
+
+    return drwav__write(pWav, &value, 8);
+}
+
+DRWAV_PRIVATE size_t drwav__write_f32ne_to_le(drwav* pWav, float value)
+{
+    union {
+       drwav_uint32 u32;
+       float f32;
+    } u;
+
+    DRWAV_ASSERT(pWav          != NULL);
+    DRWAV_ASSERT(pWav->onWrite != NULL);
+
+    u.f32 = value;
+
+    if (!drwav__is_little_endian()) {
+        u.u32 = drwav__bswap32(u.u32);
+    }
+
+    return drwav__write(pWav, &u.u32, 4);
+}
+
+DRWAV_PRIVATE size_t drwav__write_or_count(drwav* pWav, const void* pData, size_t dataSize)
+{
+    if (pWav == NULL) {
+        return dataSize;
+    }
+
+    return drwav__write(pWav, pData, dataSize);
+}
+
+DRWAV_PRIVATE size_t drwav__write_or_count_byte(drwav* pWav, drwav_uint8 byte)
+{
+    if (pWav == NULL) {
+        return 1;
+    }
+
+    return drwav__write_byte(pWav, byte);
+}
+
+DRWAV_PRIVATE size_t drwav__write_or_count_u16ne_to_le(drwav* pWav, drwav_uint16 value)
+{
+    if (pWav == NULL) {
+        return 2;
+    }
+
+    return drwav__write_u16ne_to_le(pWav, value);
+}
+
+DRWAV_PRIVATE size_t drwav__write_or_count_u32ne_to_le(drwav* pWav, drwav_uint32 value)
+{
+    if (pWav == NULL) {
+        return 4;
+    }
+
+    return drwav__write_u32ne_to_le(pWav, value);
+}
+
+#if 0   /* Unused for now. */
+DRWAV_PRIVATE size_t drwav__write_or_count_u64ne_to_le(drwav* pWav, drwav_uint64 value)
+{
+    if (pWav == NULL) {
+        return 8;
+    }
+
+    return drwav__write_u64ne_to_le(pWav, value);
+}
+#endif
+
+DRWAV_PRIVATE size_t drwav__write_or_count_f32ne_to_le(drwav* pWav, float value)
+{
+    if (pWav == NULL) {
+        return 4;
+    }
+
+    return drwav__write_f32ne_to_le(pWav, value);
+}
+
+DRWAV_PRIVATE size_t drwav__write_or_count_string_to_fixed_size_buf(drwav* pWav, char* str, size_t bufFixedSize)
+{
+    size_t len;
+
+    if (pWav == NULL) {
+        return bufFixedSize;
+    }
+
+    len = drwav__strlen_clamped(str, bufFixedSize);
+    drwav__write_or_count(pWav, str, len);
+
+    if (len < bufFixedSize) {
+        size_t i;
+        for (i = 0; i < bufFixedSize - len; ++i) {
+            drwav__write_byte(pWav, 0);
+        }
+    }
+
+    return bufFixedSize;
+}
+
+
+/* pWav can be NULL meaning just count the bytes that would be written. */
+DRWAV_PRIVATE size_t drwav__write_or_count_metadata(drwav* pWav, drwav_metadata* pMetadatas, drwav_uint32 metadataCount)
+{
+    size_t bytesWritten = 0;
+    drwav_bool32 hasListAdtl = DRWAV_FALSE;
+    drwav_bool32 hasListInfo = DRWAV_FALSE;
+    drwav_uint32 iMetadata;
+
+    if (pMetadatas == NULL || metadataCount == 0) {
+        return 0;
+    }
+
+    for (iMetadata = 0; iMetadata < metadataCount; ++iMetadata) {
+        drwav_metadata* pMetadata = &pMetadatas[iMetadata];
+        drwav_uint32 chunkSize = 0;
+
+        if ((pMetadata->type & drwav_metadata_type_list_all_info_strings) || (pMetadata->type == drwav_metadata_type_unknown && pMetadata->data.unknown.chunkLocation == drwav_metadata_location_inside_info_list)) {
+            hasListInfo = DRWAV_TRUE;
+        }
+
+        if ((pMetadata->type & drwav_metadata_type_list_all_adtl) || (pMetadata->type == drwav_metadata_type_unknown && pMetadata->data.unknown.chunkLocation == drwav_metadata_location_inside_adtl_list)) {
+            hasListAdtl = DRWAV_TRUE;
+        }
+
+        switch (pMetadata->type) {
+            case drwav_metadata_type_smpl:
+            {
+                drwav_uint32 iLoop;
+
+                chunkSize = DRWAV_SMPL_BYTES + DRWAV_SMPL_LOOP_BYTES * pMetadata->data.smpl.sampleLoopCount + pMetadata->data.smpl.samplerSpecificDataSizeInBytes;
+
+                bytesWritten += drwav__write_or_count(pWav, "smpl", 4);
+                bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, chunkSize);
+
+                bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.smpl.manufacturerId);
+                bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.smpl.productId);
+                bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.smpl.samplePeriodNanoseconds);
+                bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.smpl.midiUnityNote);
+                bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.smpl.midiPitchFraction);
+                bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.smpl.smpteFormat);
+                bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.smpl.smpteOffset);
+                bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.smpl.sampleLoopCount);
+                bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.smpl.samplerSpecificDataSizeInBytes);
+
+                for (iLoop = 0; iLoop < pMetadata->data.smpl.sampleLoopCount; ++iLoop) {
+                    bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.smpl.pLoops[iLoop].cuePointId);
+                    bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.smpl.pLoops[iLoop].type);
+                    bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.smpl.pLoops[iLoop].firstSampleByteOffset);
+                    bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.smpl.pLoops[iLoop].lastSampleByteOffset);
+                    bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.smpl.pLoops[iLoop].sampleFraction);
+                    bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.smpl.pLoops[iLoop].playCount);
+                }
+
+                if (pMetadata->data.smpl.samplerSpecificDataSizeInBytes > 0) {
+                    bytesWritten += drwav__write(pWav, pMetadata->data.smpl.pSamplerSpecificData, pMetadata->data.smpl.samplerSpecificDataSizeInBytes);
+                }  
+            } break;
+
+            case drwav_metadata_type_inst:
+            {
+                chunkSize = DRWAV_INST_BYTES;
+
+                bytesWritten += drwav__write_or_count(pWav, "inst", 4);
+                bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, chunkSize);
+                bytesWritten += drwav__write_or_count(pWav, &pMetadata->data.inst.midiUnityNote, 1);
+                bytesWritten += drwav__write_or_count(pWav, &pMetadata->data.inst.fineTuneCents, 1);
+                bytesWritten += drwav__write_or_count(pWav, &pMetadata->data.inst.gainDecibels, 1);
+                bytesWritten += drwav__write_or_count(pWav, &pMetadata->data.inst.lowNote, 1);
+                bytesWritten += drwav__write_or_count(pWav, &pMetadata->data.inst.highNote, 1);
+                bytesWritten += drwav__write_or_count(pWav, &pMetadata->data.inst.lowVelocity, 1);
+                bytesWritten += drwav__write_or_count(pWav, &pMetadata->data.inst.highVelocity, 1);
+            } break;
+
+            case drwav_metadata_type_cue:
+            {
+                drwav_uint32 iCuePoint;
+
+                chunkSize = DRWAV_CUE_BYTES + DRWAV_CUE_POINT_BYTES * pMetadata->data.cue.cuePointCount;
+
+                bytesWritten += drwav__write_or_count(pWav, "cue ", 4);
+                bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, chunkSize);
+                bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.cue.cuePointCount);
+                for (iCuePoint = 0; iCuePoint < pMetadata->data.cue.cuePointCount; ++iCuePoint) {
+                    bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.cue.pCuePoints[iCuePoint].id);
+                    bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.cue.pCuePoints[iCuePoint].playOrderPosition);
+                    bytesWritten += drwav__write_or_count(pWav, pMetadata->data.cue.pCuePoints[iCuePoint].dataChunkId, 4);
+                    bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.cue.pCuePoints[iCuePoint].chunkStart);
+                    bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.cue.pCuePoints[iCuePoint].blockStart);
+                    bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.cue.pCuePoints[iCuePoint].sampleByteOffset);
+                }
+            } break;
+
+            case drwav_metadata_type_acid:
+            {
+                chunkSize = DRWAV_ACID_BYTES;
+
+                bytesWritten += drwav__write_or_count(pWav, "acid", 4);
+                bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, chunkSize);
+                bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.acid.flags);
+                bytesWritten += drwav__write_or_count_u16ne_to_le(pWav, pMetadata->data.acid.midiUnityNote);
+                bytesWritten += drwav__write_or_count_u16ne_to_le(pWav, pMetadata->data.acid.reserved1);
+                bytesWritten += drwav__write_or_count_f32ne_to_le(pWav, pMetadata->data.acid.reserved2);
+                bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.acid.numBeats);
+                bytesWritten += drwav__write_or_count_u16ne_to_le(pWav, pMetadata->data.acid.meterDenominator);
+                bytesWritten += drwav__write_or_count_u16ne_to_le(pWav, pMetadata->data.acid.meterNumerator);
+                bytesWritten += drwav__write_or_count_f32ne_to_le(pWav, pMetadata->data.acid.tempo);
+            } break;
+
+            case drwav_metadata_type_bext:
+            {
+                char reservedBuf[DRWAV_BEXT_RESERVED_BYTES];
+                drwav_uint32 timeReferenceLow;
+                drwav_uint32 timeReferenceHigh;
+
+                chunkSize = DRWAV_BEXT_BYTES + pMetadata->data.bext.codingHistorySize;
+
+                bytesWritten += drwav__write_or_count(pWav, "bext", 4);
+                bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, chunkSize);
+
+                bytesWritten += drwav__write_or_count_string_to_fixed_size_buf(pWav, pMetadata->data.bext.pDescription, DRWAV_BEXT_DESCRIPTION_BYTES);
+                bytesWritten += drwav__write_or_count_string_to_fixed_size_buf(pWav, pMetadata->data.bext.pOriginatorName, DRWAV_BEXT_ORIGINATOR_NAME_BYTES);
+                bytesWritten += drwav__write_or_count_string_to_fixed_size_buf(pWav, pMetadata->data.bext.pOriginatorReference, DRWAV_BEXT_ORIGINATOR_REF_BYTES);
+                bytesWritten += drwav__write_or_count(pWav, pMetadata->data.bext.pOriginationDate, sizeof(pMetadata->data.bext.pOriginationDate));
+                bytesWritten += drwav__write_or_count(pWav, pMetadata->data.bext.pOriginationTime, sizeof(pMetadata->data.bext.pOriginationTime));
+
+                timeReferenceLow  = (drwav_uint32)(pMetadata->data.bext.timeReference & 0xFFFFFFFF);
+                timeReferenceHigh = (drwav_uint32)(pMetadata->data.bext.timeReference >> 32);
+                bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, timeReferenceLow);
+                bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, timeReferenceHigh);
+
+                bytesWritten += drwav__write_or_count_u16ne_to_le(pWav, pMetadata->data.bext.version);
+                bytesWritten += drwav__write_or_count(pWav, pMetadata->data.bext.pUMID, DRWAV_BEXT_UMID_BYTES);
+                bytesWritten += drwav__write_or_count_u16ne_to_le(pWav, pMetadata->data.bext.loudnessValue);
+                bytesWritten += drwav__write_or_count_u16ne_to_le(pWav, pMetadata->data.bext.loudnessRange);
+                bytesWritten += drwav__write_or_count_u16ne_to_le(pWav, pMetadata->data.bext.maxTruePeakLevel);
+                bytesWritten += drwav__write_or_count_u16ne_to_le(pWav, pMetadata->data.bext.maxMomentaryLoudness);
+                bytesWritten += drwav__write_or_count_u16ne_to_le(pWav, pMetadata->data.bext.maxShortTermLoudness);
+
+                DRWAV_ZERO_MEMORY(reservedBuf, sizeof(reservedBuf));
+                bytesWritten += drwav__write_or_count(pWav, reservedBuf, sizeof(reservedBuf));
+
+                if (pMetadata->data.bext.codingHistorySize > 0) {
+                    bytesWritten += drwav__write_or_count(pWav, pMetadata->data.bext.pCodingHistory, pMetadata->data.bext.codingHistorySize);
+                }
+            } break;
+
+            case drwav_metadata_type_unknown:
+            {
+                if (pMetadata->data.unknown.chunkLocation == drwav_metadata_location_top_level) {
+                    chunkSize = pMetadata->data.unknown.dataSizeInBytes;
+
+                    bytesWritten += drwav__write_or_count(pWav, pMetadata->data.unknown.id, 4);
+                    bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, chunkSize);
+                    bytesWritten += drwav__write_or_count(pWav, pMetadata->data.unknown.pData, pMetadata->data.unknown.dataSizeInBytes);
+                }
+            } break;
+
+            default: break;
+        }
+        if ((chunkSize % 2) != 0) {
+            bytesWritten += drwav__write_or_count_byte(pWav, 0);
+        }
+    }
+
+    if (hasListInfo) {
+        drwav_uint32 chunkSize = 4; /* Start with 4 bytes for "INFO". */
+        for (iMetadata = 0; iMetadata < metadataCount; ++iMetadata) {
+            drwav_metadata* pMetadata = &pMetadatas[iMetadata];
+
+            if ((pMetadata->type & drwav_metadata_type_list_all_info_strings)) {
+                chunkSize += 8; /* For id and string size. */
+                chunkSize += pMetadata->data.infoText.stringLength + 1; /* Include null terminator. */
+            } else if (pMetadata->type == drwav_metadata_type_unknown && pMetadata->data.unknown.chunkLocation == drwav_metadata_location_inside_info_list) {
+                chunkSize += 8; /* For id string size. */
+                chunkSize += pMetadata->data.unknown.dataSizeInBytes;
+            }
+
+            if ((chunkSize % 2) != 0) {
+                chunkSize += 1;
+            }
+        }
+
+        bytesWritten += drwav__write_or_count(pWav, "LIST", 4);
+        bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, chunkSize);
+        bytesWritten += drwav__write_or_count(pWav, "INFO", 4);
+
+        for (iMetadata = 0; iMetadata < metadataCount; ++iMetadata) {
+            drwav_metadata* pMetadata = &pMetadatas[iMetadata];
+            drwav_uint32 subchunkSize = 0;
+
+            if (pMetadata->type & drwav_metadata_type_list_all_info_strings) {
+                const char* pID = NULL;
+
+                switch (pMetadata->type) {
+                    case drwav_metadata_type_list_info_software:    pID = "ISFT"; break;
+                    case drwav_metadata_type_list_info_copyright:   pID = "ICOP"; break;
+                    case drwav_metadata_type_list_info_title:       pID = "INAM"; break;
+                    case drwav_metadata_type_list_info_artist:      pID = "IART"; break;
+                    case drwav_metadata_type_list_info_comment:     pID = "ICMT"; break;
+                    case drwav_metadata_type_list_info_date:        pID = "ICRD"; break;
+                    case drwav_metadata_type_list_info_genre:       pID = "IGNR"; break;
+                    case drwav_metadata_type_list_info_album:       pID = "IPRD"; break;
+                    case drwav_metadata_type_list_info_tracknumber: pID = "ITRK"; break;
+                    default: break;
+                }
+
+                DRWAV_ASSERT(pID != NULL);
+
+                if (pMetadata->data.infoText.stringLength) {
+                    subchunkSize = pMetadata->data.infoText.stringLength + 1;
+                    bytesWritten += drwav__write_or_count(pWav, pID, 4);
+                    bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, subchunkSize);
+                    bytesWritten += drwav__write_or_count(pWav, pMetadata->data.infoText.pString, pMetadata->data.infoText.stringLength);
+                    bytesWritten += drwav__write_or_count_byte(pWav, '\0');
+                }
+            } else if (pMetadata->type == drwav_metadata_type_unknown && pMetadata->data.unknown.chunkLocation == drwav_metadata_location_inside_info_list) {
+                if (pMetadata->data.unknown.dataSizeInBytes) {
+                    subchunkSize = pMetadata->data.unknown.dataSizeInBytes;
+
+                    bytesWritten += drwav__write_or_count(pWav, pMetadata->data.unknown.id, 4);
+                    bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.unknown.dataSizeInBytes);
+                    bytesWritten += drwav__write_or_count(pWav, pMetadata->data.unknown.pData, subchunkSize);
+                }
+            }
+
+            if ((subchunkSize % 2) != 0) {
+                bytesWritten += drwav__write_or_count_byte(pWav, 0);
+            }
+        }
+    }
+
+    if (hasListAdtl) {
+        drwav_uint32 chunkSize = 4; /* start with 4 bytes for "adtl" */
+
+        for (iMetadata = 0; iMetadata < metadataCount; ++iMetadata) {
+            drwav_metadata* pMetadata = &pMetadatas[iMetadata];
+
+            switch (pMetadata->type)
+            {
+                case drwav_metadata_type_list_label:
+                case drwav_metadata_type_list_note:
+                {
+                    chunkSize += 8; /* for id and chunk size */
+                    chunkSize += DRWAV_LIST_LABEL_OR_NOTE_BYTES;
+
+                    if (pMetadata->data.labelOrNote.stringLength > 0) {
+                        chunkSize += pMetadata->data.labelOrNote.stringLength + 1;
+                    }    
+                } break;
+
+                case drwav_metadata_type_list_labelled_cue_region:
+                {
+                    chunkSize += 8; /* for id and chunk size */
+                    chunkSize += DRWAV_LIST_LABELLED_TEXT_BYTES;
+
+                    if (pMetadata->data.labelledCueRegion.stringLength > 0) {
+                        chunkSize += pMetadata->data.labelledCueRegion.stringLength + 1;
+                    }
+                } break;
+
+                case drwav_metadata_type_unknown:
+                {
+                    if (pMetadata->data.unknown.chunkLocation == drwav_metadata_location_inside_adtl_list) {
+                        chunkSize += 8; /* for id and chunk size */
+                        chunkSize += pMetadata->data.unknown.dataSizeInBytes;
+                    }
+                } break;
+
+                default: break;
+            }
+
+            if ((chunkSize % 2) != 0) {
+                chunkSize += 1;
+            }
+        }
+
+        bytesWritten += drwav__write_or_count(pWav, "LIST", 4);
+        bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, chunkSize);
+        bytesWritten += drwav__write_or_count(pWav, "adtl", 4);
+
+        for (iMetadata = 0; iMetadata < metadataCount; ++iMetadata) {
+            drwav_metadata* pMetadata = &pMetadatas[iMetadata];
+            drwav_uint32 subchunkSize = 0;
+
+            switch (pMetadata->type)
+            {
+                case drwav_metadata_type_list_label:
+                case drwav_metadata_type_list_note:
+                {
+                    if (pMetadata->data.labelOrNote.stringLength > 0) {
+                        const char *pID = NULL;
+
+                        if (pMetadata->type == drwav_metadata_type_list_label) {
+                            pID = "labl";
+                        }
+                        else if (pMetadata->type == drwav_metadata_type_list_note) {
+                            pID = "note";
+                        }
+
+                        DRWAV_ASSERT(pID != NULL);
+                        DRWAV_ASSERT(pMetadata->data.labelOrNote.pString != NULL);
+
+                        subchunkSize = DRWAV_LIST_LABEL_OR_NOTE_BYTES;
+
+                        bytesWritten += drwav__write_or_count(pWav, pID, 4);
+                        subchunkSize += pMetadata->data.labelOrNote.stringLength + 1;
+                        bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, subchunkSize);
+
+                        bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.labelOrNote.cuePointId);
+                        bytesWritten += drwav__write_or_count(pWav, pMetadata->data.labelOrNote.pString, pMetadata->data.labelOrNote.stringLength);
+                        bytesWritten += drwav__write_or_count_byte(pWav, '\0');
+                    }
+                } break;
+
+                case drwav_metadata_type_list_labelled_cue_region:
+                {
+                    subchunkSize = DRWAV_LIST_LABELLED_TEXT_BYTES;
+
+                    bytesWritten += drwav__write_or_count(pWav, "ltxt", 4);
+                    if (pMetadata->data.labelledCueRegion.stringLength > 0) {
+                        subchunkSize += pMetadata->data.labelledCueRegion.stringLength + 1;
+                    }
+                    bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, subchunkSize);
+                    bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.labelledCueRegion.cuePointId);
+                    bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, pMetadata->data.labelledCueRegion.sampleLength);
+                    bytesWritten += drwav__write_or_count(pWav, pMetadata->data.labelledCueRegion.purposeId, 4);
+                    bytesWritten += drwav__write_or_count_u16ne_to_le(pWav, pMetadata->data.labelledCueRegion.country);
+                    bytesWritten += drwav__write_or_count_u16ne_to_le(pWav, pMetadata->data.labelledCueRegion.language);
+                    bytesWritten += drwav__write_or_count_u16ne_to_le(pWav, pMetadata->data.labelledCueRegion.dialect);
+                    bytesWritten += drwav__write_or_count_u16ne_to_le(pWav, pMetadata->data.labelledCueRegion.codePage);
+
+                    if (pMetadata->data.labelledCueRegion.stringLength > 0) {
+                        DRWAV_ASSERT(pMetadata->data.labelledCueRegion.pString != NULL);
+
+                        bytesWritten += drwav__write_or_count(pWav, pMetadata->data.labelledCueRegion.pString, pMetadata->data.labelledCueRegion.stringLength);
+                        bytesWritten += drwav__write_or_count_byte(pWav, '\0');
+                    }
+                } break;
+
+                case drwav_metadata_type_unknown:
+                {
+                    if (pMetadata->data.unknown.chunkLocation == drwav_metadata_location_inside_adtl_list) {
+                        subchunkSize = pMetadata->data.unknown.dataSizeInBytes;
+
+                        DRWAV_ASSERT(pMetadata->data.unknown.pData != NULL);
+                        bytesWritten += drwav__write_or_count(pWav, pMetadata->data.unknown.id, 4);
+                        bytesWritten += drwav__write_or_count_u32ne_to_le(pWav, subchunkSize);
+                        bytesWritten += drwav__write_or_count(pWav, pMetadata->data.unknown.pData, subchunkSize);
+                    }
+                } break;
+
+                default: break;
+            }
+
+            if ((subchunkSize % 2) != 0) {
+                bytesWritten += drwav__write_or_count_byte(pWav, 0);
+            }
+        }
+    }
+
+    DRWAV_ASSERT((bytesWritten % 2) == 0);
+
+    return bytesWritten;
+}
+
+DRWAV_PRIVATE drwav_uint32 drwav__riff_chunk_size_riff(drwav_uint64 dataChunkSize, drwav_metadata* pMetadata, drwav_uint32 metadataCount)
+{
+    drwav_uint64 chunkSize = 4 + 24 + (drwav_uint64)drwav__write_or_count_metadata(NULL, pMetadata, metadataCount) + 8 + dataChunkSize + drwav__chunk_padding_size_riff(dataChunkSize); /* 4 = "WAVE". 24 = "fmt " chunk. 8 = "data" + u32 data size. */
+    if (chunkSize > 0xFFFFFFFFUL) {
+        chunkSize = 0xFFFFFFFFUL;
     }
+
+    return (drwav_uint32)chunkSize; /* Safe cast due to the clamp above. */
 }
 
-static drwav_uint32 drwav__data_chunk_size_riff(drwav_uint64 dataChunkSize)
+DRWAV_PRIVATE drwav_uint32 drwav__data_chunk_size_riff(drwav_uint64 dataChunkSize)
 {
     if (dataChunkSize <= 0xFFFFFFFFUL) {
         return (drwav_uint32)dataChunkSize;
     } else {
         return 0xFFFFFFFFUL;
     }
 }
 
-static drwav_uint64 drwav__riff_chunk_size_w64(drwav_uint64 dataChunkSize)
+DRWAV_PRIVATE drwav_uint64 drwav__riff_chunk_size_w64(drwav_uint64 dataChunkSize)
 {
     drwav_uint64 dataSubchunkPaddingSize = drwav__chunk_padding_size_w64(dataChunkSize);
 
     return 80 + 24 + dataChunkSize + dataSubchunkPaddingSize;   /* +24 because W64 includes the size of the GUID and size fields. */
 }
 
-static drwav_uint64 drwav__data_chunk_size_w64(drwav_uint64 dataChunkSize)
+DRWAV_PRIVATE drwav_uint64 drwav__data_chunk_size_w64(drwav_uint64 dataChunkSize)
 {
     return 24 + dataChunkSize;        /* +24 because W64 includes the size of the GUID and size fields. */
 }
 
+DRWAV_PRIVATE drwav_uint64 drwav__riff_chunk_size_rf64(drwav_uint64 dataChunkSize, drwav_metadata *metadata, drwav_uint32 numMetadata)
+{
+    drwav_uint64 chunkSize = 4 + 36 + 24 + (drwav_uint64)drwav__write_or_count_metadata(NULL, metadata, numMetadata) + 8 + dataChunkSize + drwav__chunk_padding_size_riff(dataChunkSize); /* 4 = "WAVE". 36 = "ds64" chunk. 24 = "fmt " chunk. 8 = "data" + u32 data size. */
+    if (chunkSize > 0xFFFFFFFFUL) {
+        chunkSize = 0xFFFFFFFFUL;
+    }
+
+    return chunkSize;
+}
+
+DRWAV_PRIVATE drwav_uint64 drwav__data_chunk_size_rf64(drwav_uint64 dataChunkSize)
+{
+    return dataChunkSize;
+}
+
+
 
-static drwav_bool32 drwav_preinit_write(drwav* pWav, const drwav_data_format* pFormat, drwav_bool32 isSequential, drwav_write_proc onWrite, drwav_seek_proc onSeek, void* pUserData, const drwav_allocation_callbacks* pAllocationCallbacks)
+DRWAV_PRIVATE drwav_bool32 drwav_preinit_write(drwav* pWav, const drwav_data_format* pFormat, drwav_bool32 isSequential, drwav_write_proc onWrite, drwav_seek_proc onSeek, void* pUserData, const drwav_allocation_callbacks* pAllocationCallbacks)
 {
     if (pWav == NULL || onWrite == NULL) {
         return DRWAV_FALSE;
     }
 
     if (!isSequential && onSeek == NULL) {
         return DRWAV_FALSE; /* <-- onSeek is required when in non-sequential mode. */
@@ -2217,15 +4084,16 @@
     pWav->fmt.bitsPerSample = (drwav_uint16)pFormat->bitsPerSample;
     pWav->fmt.extendedSize = 0;
     pWav->isSequentialWrite = isSequential;
 
     return DRWAV_TRUE;
 }
 
-static drwav_bool32 drwav_init_write__internal(drwav* pWav, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount)
+
+DRWAV_PRIVATE drwav_bool32 drwav_init_write__internal(drwav* pWav, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount)
 {
     /* The function assumes drwav_preinit_write() was called beforehand. */
 
     size_t runningPos = 0;
     drwav_uint64 initialDataChunkSize = 0;
     drwav_uint64 chunkSizeFMT;
 
@@ -2249,75 +4117,91 @@
     }
 
     pWav->dataChunkDataSizeTargetWrite = initialDataChunkSize;
 
 
     /* "RIFF" chunk. */
     if (pFormat->container == drwav_container_riff) {
-        drwav_uint32 chunkSizeRIFF = 36 + (drwav_uint32)initialDataChunkSize;   /* +36 = "RIFF"+[RIFF Chunk Size]+"WAVE" + [sizeof "fmt " chunk] */
-        runningPos += pWav->onWrite(pWav->pUserData, "RIFF", 4);
-        runningPos += pWav->onWrite(pWav->pUserData, &chunkSizeRIFF, 4);
-        runningPos += pWav->onWrite(pWav->pUserData, "WAVE", 4);
-    } else {
-        drwav_uint64 chunkSizeRIFF = 80 + 24 + initialDataChunkSize;   /* +24 because W64 includes the size of the GUID and size fields. */
-        runningPos += pWav->onWrite(pWav->pUserData, drwavGUID_W64_RIFF, 16);
-        runningPos += pWav->onWrite(pWav->pUserData, &chunkSizeRIFF, 8);
-        runningPos += pWav->onWrite(pWav->pUserData, drwavGUID_W64_WAVE, 16);
+        drwav_uint32 chunkSizeRIFF = 28 + (drwav_uint32)initialDataChunkSize;   /* +28 = "WAVE" + [sizeof "fmt " chunk] */
+        runningPos += drwav__write(pWav, "RIFF", 4);
+        runningPos += drwav__write_u32ne_to_le(pWav, chunkSizeRIFF);
+        runningPos += drwav__write(pWav, "WAVE", 4);
+    } else if (pFormat->container == drwav_container_w64) {
+        drwav_uint64 chunkSizeRIFF = 80 + 24 + initialDataChunkSize;            /* +24 because W64 includes the size of the GUID and size fields. */
+        runningPos += drwav__write(pWav, drwavGUID_W64_RIFF, 16);
+        runningPos += drwav__write_u64ne_to_le(pWav, chunkSizeRIFF);
+        runningPos += drwav__write(pWav, drwavGUID_W64_WAVE, 16);
+    } else if (pFormat->container == drwav_container_rf64) {
+        runningPos += drwav__write(pWav, "RF64", 4);
+        runningPos += drwav__write_u32ne_to_le(pWav, 0xFFFFFFFF);               /* Always 0xFFFFFFFF for RF64. Set to a proper value in the "ds64" chunk. */
+        runningPos += drwav__write(pWav, "WAVE", 4);
+    }
+
+
+    /* "ds64" chunk (RF64 only). */
+    if (pFormat->container == drwav_container_rf64) {
+        drwav_uint32 initialds64ChunkSize = 28;                                 /* 28 = [Size of RIFF (8 bytes)] + [Size of DATA (8 bytes)] + [Sample Count (8 bytes)] + [Table Length (4 bytes)]. Table length always set to 0. */
+        drwav_uint64 initialRiffChunkSize = 8 + initialds64ChunkSize + initialDataChunkSize;    /* +8 for the ds64 header. */
+
+        runningPos += drwav__write(pWav, "ds64", 4);
+        runningPos += drwav__write_u32ne_to_le(pWav, initialds64ChunkSize);     /* Size of ds64. */
+        runningPos += drwav__write_u64ne_to_le(pWav, initialRiffChunkSize);     /* Size of RIFF. Set to true value at the end. */
+        runningPos += drwav__write_u64ne_to_le(pWav, initialDataChunkSize);     /* Size of DATA. Set to true value at the end. */
+        runningPos += drwav__write_u64ne_to_le(pWav, totalSampleCount);         /* Sample count. */
+        runningPos += drwav__write_u32ne_to_le(pWav, 0);                        /* Table length. Always set to zero in our case since we're not doing any other chunks than "DATA". */
     }
 
+
     /* "fmt " chunk. */
-    if (pFormat->container == drwav_container_riff) {
+    if (pFormat->container == drwav_container_riff || pFormat->container == drwav_container_rf64) {
         chunkSizeFMT = 16;
-        runningPos += pWav->onWrite(pWav->pUserData, "fmt ", 4);
-        runningPos += pWav->onWrite(pWav->pUserData, &chunkSizeFMT, 4);
-    } else {
+        runningPos += drwav__write(pWav, "fmt ", 4);
+        runningPos += drwav__write_u32ne_to_le(pWav, (drwav_uint32)chunkSizeFMT);
+    } else if (pFormat->container == drwav_container_w64) {
         chunkSizeFMT = 40;
-        runningPos += pWav->onWrite(pWav->pUserData, drwavGUID_W64_FMT, 16);
-        runningPos += pWav->onWrite(pWav->pUserData, &chunkSizeFMT, 8);
+        runningPos += drwav__write(pWav, drwavGUID_W64_FMT, 16);
+        runningPos += drwav__write_u64ne_to_le(pWav, chunkSizeFMT);
     }
 
-    runningPos += pWav->onWrite(pWav->pUserData, &pWav->fmt.formatTag,      2);
-    runningPos += pWav->onWrite(pWav->pUserData, &pWav->fmt.channels,       2);
-    runningPos += pWav->onWrite(pWav->pUserData, &pWav->fmt.sampleRate,     4);
-    runningPos += pWav->onWrite(pWav->pUserData, &pWav->fmt.avgBytesPerSec, 4);
-    runningPos += pWav->onWrite(pWav->pUserData, &pWav->fmt.blockAlign,     2);
-    runningPos += pWav->onWrite(pWav->pUserData, &pWav->fmt.bitsPerSample,  2);
+    runningPos += drwav__write_u16ne_to_le(pWav, pWav->fmt.formatTag);
+    runningPos += drwav__write_u16ne_to_le(pWav, pWav->fmt.channels);
+    runningPos += drwav__write_u32ne_to_le(pWav, pWav->fmt.sampleRate);
+    runningPos += drwav__write_u32ne_to_le(pWav, pWav->fmt.avgBytesPerSec);
+    runningPos += drwav__write_u16ne_to_le(pWav, pWav->fmt.blockAlign);
+    runningPos += drwav__write_u16ne_to_le(pWav, pWav->fmt.bitsPerSample);
 
-    pWav->dataChunkDataPos = runningPos;
+    /* TODO: is a 'fact' chunk required for DR_WAVE_FORMAT_IEEE_FLOAT? */
 
-    /* "data" chunk. */
-    if (pFormat->container == drwav_container_riff) {
-        drwav_uint32 chunkSizeDATA = (drwav_uint32)initialDataChunkSize;
-        runningPos += pWav->onWrite(pWav->pUserData, "data", 4);
-        runningPos += pWav->onWrite(pWav->pUserData, &chunkSizeDATA, 4);
-    } else {
-        drwav_uint64 chunkSizeDATA = 24 + initialDataChunkSize; /* +24 because W64 includes the size of the GUID and size fields. */
-        runningPos += pWav->onWrite(pWav->pUserData, drwavGUID_W64_DATA, 16);
-        runningPos += pWav->onWrite(pWav->pUserData, &chunkSizeDATA, 8);
+    if (!pWav->isSequentialWrite && pWav->pMetadata != NULL && pWav->metadataCount > 0 && (pFormat->container == drwav_container_riff || pFormat->container == drwav_container_rf64)) {
+        runningPos += drwav__write_or_count_metadata(pWav, pWav->pMetadata, pWav->metadataCount);
     }
 
+    pWav->dataChunkDataPos = runningPos;
 
-    /* Simple validation. */
+    /* "data" chunk. */
     if (pFormat->container == drwav_container_riff) {
-        if (runningPos != 20 + chunkSizeFMT + 8) {
-            return DRWAV_FALSE;
-        }
-    } else {
-        if (runningPos != 40 + chunkSizeFMT + 24) {
-            return DRWAV_FALSE;
-        }
+        drwav_uint32 chunkSizeDATA = (drwav_uint32)initialDataChunkSize;
+        runningPos += drwav__write(pWav, "data", 4);
+        runningPos += drwav__write_u32ne_to_le(pWav, chunkSizeDATA);
+    } else if (pFormat->container == drwav_container_w64) {
+        drwav_uint64 chunkSizeDATA = 24 + initialDataChunkSize;     /* +24 because W64 includes the size of the GUID and size fields. */
+        runningPos += drwav__write(pWav, drwavGUID_W64_DATA, 16);
+        runningPos += drwav__write_u64ne_to_le(pWav, chunkSizeDATA);
+    } else if (pFormat->container == drwav_container_rf64) {
+        runningPos += drwav__write(pWav, "data", 4);
+        runningPos += drwav__write_u32ne_to_le(pWav, 0xFFFFFFFF);   /* Always set to 0xFFFFFFFF for RF64. The true size of the data chunk is specified in the ds64 chunk. */
     }
-    
 
     /* Set some properties for the client's convenience. */
     pWav->container = pFormat->container;
     pWav->channels = (drwav_uint16)pFormat->channels;
     pWav->sampleRate = pFormat->sampleRate;
     pWav->bitsPerSample = (drwav_uint16)pFormat->bitsPerSample;
     pWav->translatedFormatTag = (drwav_uint16)pFormat->format;
+    pWav->dataChunkDataPos = runningPos;
 
     return DRWAV_TRUE;
 }
 
 
 DRWAV_API drwav_bool32 drwav_init_write(drwav* pWav, const drwav_data_format* pFormat, drwav_write_proc onWrite, drwav_seek_proc onSeek, void* pUserData, const drwav_allocation_callbacks* pAllocationCallbacks)
 {
@@ -2342,37 +4226,54 @@
     if (pFormat == NULL) {
         return DRWAV_FALSE;
     }
 
     return drwav_init_write_sequential(pWav, pFormat, totalPCMFrameCount*pFormat->channels, onWrite, pUserData, pAllocationCallbacks);
 }
 
-DRWAV_API drwav_uint64 drwav_target_write_size_bytes(const drwav_data_format* pFormat, drwav_uint64 totalSampleCount)
+DRWAV_API drwav_bool32 drwav_init_write_with_metadata(drwav* pWav, const drwav_data_format* pFormat, drwav_write_proc onWrite, drwav_seek_proc onSeek, void* pUserData, const drwav_allocation_callbacks* pAllocationCallbacks, drwav_metadata* pMetadata, drwav_uint32 metadataCount)
+{
+    if (!drwav_preinit_write(pWav, pFormat, DRWAV_FALSE, onWrite, onSeek, pUserData, pAllocationCallbacks)) {
+        return DRWAV_FALSE;
+    }
+
+    pWav->pMetadata     = pMetadata;
+    pWav->metadataCount = metadataCount;
+
+    return drwav_init_write__internal(pWav, pFormat, 0);
+}
+
+
+DRWAV_API drwav_uint64 drwav_target_write_size_bytes(const drwav_data_format* pFormat, drwav_uint64 totalFrameCount, drwav_metadata* pMetadata, drwav_uint32 metadataCount)
 {
-    drwav_uint64 targetDataSizeBytes = (drwav_uint64)(totalSampleCount * pFormat->channels * pFormat->bitsPerSample/8.0);
+    /* Casting totalFrameCount to drwav_int64 for VC6 compatibility. No issues in practice because nobody is going to exhaust the whole 63 bits. */
+    drwav_uint64 targetDataSizeBytes = (drwav_uint64)((drwav_int64)totalFrameCount * pFormat->channels * pFormat->bitsPerSample/8.0);
     drwav_uint64 riffChunkSizeBytes;
-    drwav_uint64 fileSizeBytes;
+    drwav_uint64 fileSizeBytes = 0;
 
     if (pFormat->container == drwav_container_riff) {
-        riffChunkSizeBytes = drwav__riff_chunk_size_riff(targetDataSizeBytes);
-        fileSizeBytes = (8 + riffChunkSizeBytes); /* +8 because WAV doesn't include the size of the ChunkID and ChunkSize fields. */
-    } else {
+        riffChunkSizeBytes = drwav__riff_chunk_size_riff(targetDataSizeBytes, pMetadata, metadataCount);
+        fileSizeBytes = (8 + riffChunkSizeBytes);   /* +8 because WAV doesn't include the size of the ChunkID and ChunkSize fields. */
+    } else if (pFormat->container == drwav_container_w64) {
         riffChunkSizeBytes = drwav__riff_chunk_size_w64(targetDataSizeBytes);
         fileSizeBytes = riffChunkSizeBytes;
+    } else if (pFormat->container == drwav_container_rf64) {
+        riffChunkSizeBytes = drwav__riff_chunk_size_rf64(targetDataSizeBytes, pMetadata, metadataCount);
+        fileSizeBytes = (8 + riffChunkSizeBytes);   /* +8 because WAV doesn't include the size of the ChunkID and ChunkSize fields. */
     }
 
     return fileSizeBytes;
 }
 
 
 #ifndef DR_WAV_NO_STDIO
 
 /* drwav_result_from_errno() is only used for fopen() and wfopen() so putting it inside DR_WAV_NO_STDIO for now. If something else needs this later we can move it out. */
 #include <errno.h>
-static drwav_result drwav_result_from_errno(int e)
+DRWAV_PRIVATE drwav_result drwav_result_from_errno(int e)
 {
     switch (e)
     {
         case 0: return DRWAV_SUCCESS;
     #ifdef EPERM
         case EPERM: return DRWAV_INVALID_OPERATION;
     #endif
@@ -2766,29 +4667,29 @@
     #ifdef EHWPOISON
         case EHWPOISON: return DRWAV_ERROR;
     #endif
         default: return DRWAV_ERROR;
     }
 }
 
-static drwav_result drwav_fopen(FILE** ppFile, const char* pFilePath, const char* pOpenMode)
+DRWAV_PRIVATE drwav_result drwav_fopen(FILE** ppFile, const char* pFilePath, const char* pOpenMode)
 {
-#if _MSC_VER && _MSC_VER >= 1400
+#if defined(_MSC_VER) && _MSC_VER >= 1400
     errno_t err;
 #endif
 
     if (ppFile != NULL) {
         *ppFile = NULL;  /* Safety. */
     }
 
     if (pFilePath == NULL || pOpenMode == NULL || ppFile == NULL) {
         return DRWAV_INVALID_ARGS;
     }
 
-#if _MSC_VER && _MSC_VER >= 1400
+#if defined(_MSC_VER) && _MSC_VER >= 1400
     err = fopen_s(ppFile, pFilePath, pOpenMode);
     if (err != 0) {
         return drwav_result_from_errno(err);
     }
 #else
 #if defined(_WIN32) || defined(__APPLE__)
     *ppFile = fopen(pFilePath, pOpenMode);
@@ -2815,25 +4716,27 @@
 /*
 _wfopen() isn't always available in all compilation environments.
 
     * Windows only.
     * MSVC seems to support it universally as far back as VC6 from what I can tell (haven't checked further back).
     * MinGW-64 (both 32- and 64-bit) seems to support it.
     * MinGW wraps it in !defined(__STRICT_ANSI__).
+    * OpenWatcom wraps it in !defined(_NO_EXT_KEYS).
 
 This can be reviewed as compatibility issues arise. The preference is to use _wfopen_s() and _wfopen() as opposed to the wcsrtombs()
 fallback, so if you notice your compiler not detecting this properly I'm happy to look at adding support.
 */
 #if defined(_WIN32)
-    #if defined(_MSC_VER) || defined(__MINGW64__) || !defined(__STRICT_ANSI__)
+    #if defined(_MSC_VER) || defined(__MINGW64__) || (!defined(__STRICT_ANSI__) && !defined(_NO_EXT_KEYS))
         #define DRWAV_HAS_WFOPEN
     #endif
 #endif
 
-static drwav_result drwav_wfopen(FILE** ppFile, const wchar_t* pFilePath, const wchar_t* pOpenMode, const drwav_allocation_callbacks* pAllocationCallbacks)
+#ifndef DR_WAV_NO_WCHAR
+DRWAV_PRIVATE drwav_result drwav_wfopen(FILE** ppFile, const wchar_t* pFilePath, const wchar_t* pOpenMode, const drwav_allocation_callbacks* pAllocationCallbacks)
 {
     if (ppFile != NULL) {
         *ppFile = NULL;  /* Safety. */
     }
 
     if (pFilePath == NULL || pOpenMode == NULL || ppFile == NULL) {
         return DRWAV_INVALID_ARGS;
@@ -2852,19 +4755,32 @@
         if (*ppFile == NULL) {
             return drwav_result_from_errno(errno);
         }
     #endif
         (void)pAllocationCallbacks;
     }
 #else
-    /*
-    Use fopen() on anything other than Windows. Requires a conversion. This is annoying because fopen() is locale specific. The only real way I can
-    think of to do this is with wcsrtombs(). Note that wcstombs() is apparently not thread-safe because it uses a static global mbstate_t object for
-    maintaining state. I've checked this with -std=c89 and it works, but if somebody get's a compiler error I'll look into improving compatibility.
+	/*
+    Use fopen() on anything other than Windows. Requires a conversion. This is annoying because
+	fopen() is locale specific. The only real way I can think of to do this is with wcsrtombs(). Note
+	that wcstombs() is apparently not thread-safe because it uses a static global mbstate_t object for
+    maintaining state. I've checked this with -std=c89 and it works, but if somebody get's a compiler
+	error I'll look into improving compatibility.
     */
+
+	/*
+	Some compilers don't support wchar_t or wcsrtombs() which we're using below. In this case we just
+	need to abort with an error. If you encounter a compiler lacking such support, add it to this list
+	and submit a bug report and it'll be added to the library upstream.
+	*/
+	#if defined(__DJGPP__)
+	{
+		/* Nothing to do here. This will fall through to the error check below. */
+	}
+	#else
     {
         mbstate_t mbs;
         size_t lenMB;
         const wchar_t* pFilePathTemp = pFilePath;
         char* pFilePathMB = NULL;
         char pOpenModeMB[32] = {0};
 
@@ -2898,114 +4814,164 @@
             }
         }
 
         *ppFile = fopen(pFilePathMB, pOpenModeMB);
 
         drwav__free_from_callbacks(pFilePathMB, pAllocationCallbacks);
     }
+	#endif
 
     if (*ppFile == NULL) {
         return DRWAV_ERROR;
     }
 #endif
 
     return DRWAV_SUCCESS;
 }
+#endif
 
 
-static size_t drwav__on_read_stdio(void* pUserData, void* pBufferOut, size_t bytesToRead)
+DRWAV_PRIVATE size_t drwav__on_read_stdio(void* pUserData, void* pBufferOut, size_t bytesToRead)
 {
     return fread(pBufferOut, 1, bytesToRead, (FILE*)pUserData);
 }
 
-static size_t drwav__on_write_stdio(void* pUserData, const void* pData, size_t bytesToWrite)
+DRWAV_PRIVATE size_t drwav__on_write_stdio(void* pUserData, const void* pData, size_t bytesToWrite)
 {
     return fwrite(pData, 1, bytesToWrite, (FILE*)pUserData);
 }
 
-static drwav_bool32 drwav__on_seek_stdio(void* pUserData, int offset, drwav_seek_origin origin)
+DRWAV_PRIVATE drwav_bool32 drwav__on_seek_stdio(void* pUserData, int offset, drwav_seek_origin origin)
 {
     return fseek((FILE*)pUserData, offset, (origin == drwav_seek_origin_current) ? SEEK_CUR : SEEK_SET) == 0;
 }
 
 DRWAV_API drwav_bool32 drwav_init_file(drwav* pWav, const char* filename, const drwav_allocation_callbacks* pAllocationCallbacks)
 {
     return drwav_init_file_ex(pWav, filename, NULL, NULL, 0, pAllocationCallbacks);
 }
 
 
-static drwav_bool32 drwav_init_file__internal_FILE(drwav* pWav, FILE* pFile, drwav_chunk_proc onChunk, void* pChunkUserData, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks)
+DRWAV_PRIVATE drwav_bool32 drwav_init_file__internal_FILE(drwav* pWav, FILE* pFile, drwav_chunk_proc onChunk, void* pChunkUserData, drwav_uint32 flags, drwav_metadata_type allowedMetadataTypes, const drwav_allocation_callbacks* pAllocationCallbacks)
 {
-    if (!drwav_preinit(pWav, drwav__on_read_stdio, drwav__on_seek_stdio, (void*)pFile, pAllocationCallbacks)) {
+    drwav_bool32 result;
+
+    result = drwav_preinit(pWav, drwav__on_read_stdio, drwav__on_seek_stdio, (void*)pFile, pAllocationCallbacks);
+    if (result != DRWAV_TRUE) {
         fclose(pFile);
-        return DRWAV_FALSE;
+        return result;
     }
+    
+    pWav->allowedMetadataTypes = allowedMetadataTypes;
 
-    return drwav_init__internal(pWav, onChunk, pChunkUserData, flags);
+    result = drwav_init__internal(pWav, onChunk, pChunkUserData, flags);
+    if (result != DRWAV_TRUE) {
+        fclose(pFile);
+        return result;
+    }
+
+    return DRWAV_TRUE;
 }
 
 DRWAV_API drwav_bool32 drwav_init_file_ex(drwav* pWav, const char* filename, drwav_chunk_proc onChunk, void* pChunkUserData, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks)
 {
     FILE* pFile;
     if (drwav_fopen(&pFile, filename, "rb") != DRWAV_SUCCESS) {
         return DRWAV_FALSE;
     }
 
     /* This takes ownership of the FILE* object. */
-    return drwav_init_file__internal_FILE(pWav, pFile, onChunk, pChunkUserData, flags, pAllocationCallbacks);
+    return drwav_init_file__internal_FILE(pWav, pFile, onChunk, pChunkUserData, flags, drwav_metadata_type_none, pAllocationCallbacks);
 }
 
+#ifndef DR_WAV_NO_WCHAR
 DRWAV_API drwav_bool32 drwav_init_file_w(drwav* pWav, const wchar_t* filename, const drwav_allocation_callbacks* pAllocationCallbacks)
 {
     return drwav_init_file_ex_w(pWav, filename, NULL, NULL, 0, pAllocationCallbacks);
 }
 
 DRWAV_API drwav_bool32 drwav_init_file_ex_w(drwav* pWav, const wchar_t* filename, drwav_chunk_proc onChunk, void* pChunkUserData, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks)
 {
     FILE* pFile;
     if (drwav_wfopen(&pFile, filename, L"rb", pAllocationCallbacks) != DRWAV_SUCCESS) {
         return DRWAV_FALSE;
     }
 
     /* This takes ownership of the FILE* object. */
-    return drwav_init_file__internal_FILE(pWav, pFile, onChunk, pChunkUserData, flags, pAllocationCallbacks);
+    return drwav_init_file__internal_FILE(pWav, pFile, onChunk, pChunkUserData, flags, drwav_metadata_type_none, pAllocationCallbacks);
 }
+#endif
+
+DRWAV_API drwav_bool32 drwav_init_file_with_metadata(drwav* pWav, const char* filename, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks)
+{
+    FILE* pFile;
+    if (drwav_fopen(&pFile, filename, "rb") != DRWAV_SUCCESS) {
+        return DRWAV_FALSE;
+    }
 
+    /* This takes ownership of the FILE* object. */
+    return drwav_init_file__internal_FILE(pWav, pFile, NULL, NULL, flags, drwav_metadata_type_all_including_unknown, pAllocationCallbacks);
+}
 
-static drwav_bool32 drwav_init_file_write__internal_FILE(drwav* pWav, FILE* pFile, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, drwav_bool32 isSequential, const drwav_allocation_callbacks* pAllocationCallbacks)
+#ifndef DR_WAV_NO_WCHAR
+DRWAV_API drwav_bool32 drwav_init_file_with_metadata_w(drwav* pWav, const wchar_t* filename, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks)
 {
-    if (!drwav_preinit_write(pWav, pFormat, isSequential, drwav__on_write_stdio, drwav__on_seek_stdio, (void*)pFile, pAllocationCallbacks)) {
-        fclose(pFile);
+    FILE* pFile;
+    if (drwav_wfopen(&pFile, filename, L"rb", pAllocationCallbacks) != DRWAV_SUCCESS) {
         return DRWAV_FALSE;
     }
 
-    return drwav_init_write__internal(pWav, pFormat, totalSampleCount);
+    /* This takes ownership of the FILE* object. */
+    return drwav_init_file__internal_FILE(pWav, pFile, NULL, NULL, flags, drwav_metadata_type_all_including_unknown, pAllocationCallbacks);
+}
+#endif
+
+
+DRWAV_PRIVATE drwav_bool32 drwav_init_file_write__internal_FILE(drwav* pWav, FILE* pFile, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, drwav_bool32 isSequential, const drwav_allocation_callbacks* pAllocationCallbacks)
+{
+    drwav_bool32 result;
+
+    result = drwav_preinit_write(pWav, pFormat, isSequential, drwav__on_write_stdio, drwav__on_seek_stdio, (void*)pFile, pAllocationCallbacks);
+    if (result != DRWAV_TRUE) {
+        fclose(pFile);
+        return result;
+    }
+
+    result = drwav_init_write__internal(pWav, pFormat, totalSampleCount);
+    if (result != DRWAV_TRUE) {
+        fclose(pFile);
+        return result;
+    }
+
+    return DRWAV_TRUE;
 }
 
-static drwav_bool32 drwav_init_file_write__internal(drwav* pWav, const char* filename, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, drwav_bool32 isSequential, const drwav_allocation_callbacks* pAllocationCallbacks)
+DRWAV_PRIVATE drwav_bool32 drwav_init_file_write__internal(drwav* pWav, const char* filename, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, drwav_bool32 isSequential, const drwav_allocation_callbacks* pAllocationCallbacks)
 {
     FILE* pFile;
     if (drwav_fopen(&pFile, filename, "wb") != DRWAV_SUCCESS) {
         return DRWAV_FALSE;
     }
 
     /* This takes ownership of the FILE* object. */
     return drwav_init_file_write__internal_FILE(pWav, pFile, pFormat, totalSampleCount, isSequential, pAllocationCallbacks);
 }
 
-static drwav_bool32 drwav_init_file_write_w__internal(drwav* pWav, const wchar_t* filename, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, drwav_bool32 isSequential, const drwav_allocation_callbacks* pAllocationCallbacks)
+#ifndef DR_WAV_NO_WCHAR
+DRWAV_PRIVATE drwav_bool32 drwav_init_file_write_w__internal(drwav* pWav, const wchar_t* filename, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, drwav_bool32 isSequential, const drwav_allocation_callbacks* pAllocationCallbacks)
 {
     FILE* pFile;
     if (drwav_wfopen(&pFile, filename, L"wb", pAllocationCallbacks) != DRWAV_SUCCESS) {
         return DRWAV_FALSE;
     }
 
     /* This takes ownership of the FILE* object. */
     return drwav_init_file_write__internal_FILE(pWav, pFile, pFormat, totalSampleCount, isSequential, pAllocationCallbacks);
 }
+#endif
 
 DRWAV_API drwav_bool32 drwav_init_file_write(drwav* pWav, const char* filename, const drwav_data_format* pFormat, const drwav_allocation_callbacks* pAllocationCallbacks)
 {
     return drwav_init_file_write__internal(pWav, filename, pFormat, 0, DRWAV_FALSE, pAllocationCallbacks);
 }
 
 DRWAV_API drwav_bool32 drwav_init_file_write_sequential(drwav* pWav, const char* filename, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, const drwav_allocation_callbacks* pAllocationCallbacks)
@@ -3018,14 +4984,15 @@
     if (pFormat == NULL) {
         return DRWAV_FALSE;
     }
 
     return drwav_init_file_write_sequential(pWav, filename, pFormat, totalPCMFrameCount*pFormat->channels, pAllocationCallbacks);
 }
 
+#ifndef DR_WAV_NO_WCHAR
 DRWAV_API drwav_bool32 drwav_init_file_write_w(drwav* pWav, const wchar_t* filename, const drwav_data_format* pFormat, const drwav_allocation_callbacks* pAllocationCallbacks)
 {
     return drwav_init_file_write_w__internal(pWav, filename, pFormat, 0, DRWAV_FALSE, pAllocationCallbacks);
 }
 
 DRWAV_API drwav_bool32 drwav_init_file_write_sequential_w(drwav* pWav, const wchar_t* filename, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, const drwav_allocation_callbacks* pAllocationCallbacks)
 {
@@ -3036,18 +5003,19 @@
 {
     if (pFormat == NULL) {
         return DRWAV_FALSE;
     }
 
     return drwav_init_file_write_sequential_w(pWav, filename, pFormat, totalPCMFrameCount*pFormat->channels, pAllocationCallbacks);
 }
+#endif
 #endif  /* DR_WAV_NO_STDIO */
 
 
-static size_t drwav__on_read_memory(void* pUserData, void* pBufferOut, size_t bytesToRead)
+DRWAV_PRIVATE size_t drwav__on_read_memory(void* pUserData, void* pBufferOut, size_t bytesToRead)
 {
     drwav* pWav = (drwav*)pUserData;
     size_t bytesRemaining;
 
     DRWAV_ASSERT(pWav != NULL);
     DRWAV_ASSERT(pWav->memoryStream.dataSize >= pWav->memoryStream.currentReadPos);
 
@@ -3060,15 +5028,15 @@
         DRWAV_COPY_MEMORY(pBufferOut, pWav->memoryStream.data + pWav->memoryStream.currentReadPos, bytesToRead);
         pWav->memoryStream.currentReadPos += bytesToRead;
     }
 
     return bytesToRead;
 }
 
-static drwav_bool32 drwav__on_seek_memory(void* pUserData, int offset, drwav_seek_origin origin)
+DRWAV_PRIVATE drwav_bool32 drwav__on_seek_memory(void* pUserData, int offset, drwav_seek_origin origin)
 {
     drwav* pWav = (drwav*)pUserData;
     DRWAV_ASSERT(pWav != NULL);
 
     if (origin == drwav_seek_origin_current) {
         if (offset > 0) {
             if (pWav->memoryStream.currentReadPos + offset > pWav->memoryStream.dataSize) {
@@ -3085,19 +5053,19 @@
     } else {
         if ((drwav_uint32)offset <= pWav->memoryStream.dataSize) {
             pWav->memoryStream.currentReadPos = offset;
         } else {
             return DRWAV_FALSE; /* Trying to seek too far forward. */
         }
     }
-    
+
     return DRWAV_TRUE;
 }
 
-static size_t drwav__on_write_memory(void* pUserData, const void* pDataIn, size_t bytesToWrite)
+DRWAV_PRIVATE size_t drwav__on_write_memory(void* pUserData, const void* pDataIn, size_t bytesToWrite)
 {
     drwav* pWav = (drwav*)pUserData;
     size_t bytesRemaining;
 
     DRWAV_ASSERT(pWav != NULL);
     DRWAV_ASSERT(pWav->memoryStreamWrite.dataCapacity >= pWav->memoryStreamWrite.currentWritePos);
 
@@ -3129,15 +5097,15 @@
     }
 
     *pWav->memoryStreamWrite.pDataSize = pWav->memoryStreamWrite.dataSize;
 
     return bytesToWrite;
 }
 
-static drwav_bool32 drwav__on_seek_memory_write(void* pUserData, int offset, drwav_seek_origin origin)
+DRWAV_PRIVATE drwav_bool32 drwav__on_seek_memory_write(void* pUserData, int offset, drwav_seek_origin origin)
 {
     drwav* pWav = (drwav*)pUserData;
     DRWAV_ASSERT(pWav != NULL);
 
     if (origin == drwav_seek_origin_current) {
         if (offset > 0) {
             if (pWav->memoryStreamWrite.currentWritePos + offset > pWav->memoryStreamWrite.dataSize) {
@@ -3154,15 +5122,15 @@
     } else {
         if ((drwav_uint32)offset <= pWav->memoryStreamWrite.dataSize) {
             pWav->memoryStreamWrite.currentWritePos = offset;
         } else {
             pWav->memoryStreamWrite.currentWritePos = pWav->memoryStreamWrite.dataSize;  /* Trying to seek too far forward. */
         }
     }
-    
+
     return DRWAV_TRUE;
 }
 
 DRWAV_API drwav_bool32 drwav_init_memory(drwav* pWav, const void* data, size_t dataSize, const drwav_allocation_callbacks* pAllocationCallbacks)
 {
     return drwav_init_memory_ex(pWav, data, dataSize, NULL, NULL, 0, pAllocationCallbacks);
 }
@@ -3173,23 +5141,42 @@
         return DRWAV_FALSE;
     }
 
     if (!drwav_preinit(pWav, drwav__on_read_memory, drwav__on_seek_memory, pWav, pAllocationCallbacks)) {
         return DRWAV_FALSE;
     }
 
-    pWav->memoryStream.data = (const unsigned char*)data;
+    pWav->memoryStream.data = (const drwav_uint8*)data;
     pWav->memoryStream.dataSize = dataSize;
     pWav->memoryStream.currentReadPos = 0;
 
     return drwav_init__internal(pWav, onChunk, pChunkUserData, flags);
 }
 
+DRWAV_API drwav_bool32 drwav_init_memory_with_metadata(drwav* pWav, const void* data, size_t dataSize, drwav_uint32 flags, const drwav_allocation_callbacks* pAllocationCallbacks)
+{
+    if (data == NULL || dataSize == 0) {
+        return DRWAV_FALSE;
+    }
+
+    if (!drwav_preinit(pWav, drwav__on_read_memory, drwav__on_seek_memory, pWav, pAllocationCallbacks)) {
+        return DRWAV_FALSE;
+    }
+
+    pWav->memoryStream.data = (const drwav_uint8*)data;
+    pWav->memoryStream.dataSize = dataSize;
+    pWav->memoryStream.currentReadPos = 0;
+
+    pWav->allowedMetadataTypes = drwav_metadata_type_all_including_unknown;
+
+    return drwav_init__internal(pWav, NULL, NULL, flags);
+}
+
 
-static drwav_bool32 drwav_init_memory_write__internal(drwav* pWav, void** ppData, size_t* pDataSize, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, drwav_bool32 isSequential, const drwav_allocation_callbacks* pAllocationCallbacks)
+DRWAV_PRIVATE drwav_bool32 drwav_init_memory_write__internal(drwav* pWav, void** ppData, size_t* pDataSize, const drwav_data_format* pFormat, drwav_uint64 totalSampleCount, drwav_bool32 isSequential, const drwav_allocation_callbacks* pAllocationCallbacks)
 {
     if (ppData == NULL || pDataSize == NULL) {
         return DRWAV_FALSE;
     }
 
     *ppData = NULL; /* Important because we're using realloc()! */
     *pDataSize = 0;
@@ -3241,63 +5228,82 @@
       - Make sure the "data" chunk is aligned to 16-bits for RIFF containers, or 64 bits for W64 containers.
       - Set the size of the "data" chunk.
     */
     if (pWav->onWrite != NULL) {
         drwav_uint32 paddingSize = 0;
 
         /* Padding. Do not adjust pWav->dataChunkDataSize - this should not include the padding. */
-        if (pWav->container == drwav_container_riff) {
+        if (pWav->container == drwav_container_riff || pWav->container == drwav_container_rf64) {
             paddingSize = drwav__chunk_padding_size_riff(pWav->dataChunkDataSize);
         } else {
             paddingSize = drwav__chunk_padding_size_w64(pWav->dataChunkDataSize);
         }
-        
+
         if (paddingSize > 0) {
             drwav_uint64 paddingData = 0;
-            pWav->onWrite(pWav->pUserData, &paddingData, paddingSize);
+            drwav__write(pWav, &paddingData, paddingSize);  /* Byte order does not matter for this. */
         }
 
         /*
         Chunk sizes. When using sequential mode, these will have been filled in at initialization time. We only need
         to do this when using non-sequential mode.
         */
         if (pWav->onSeek && !pWav->isSequentialWrite) {
             if (pWav->container == drwav_container_riff) {
                 /* The "RIFF" chunk size. */
                 if (pWav->onSeek(pWav->pUserData, 4, drwav_seek_origin_start)) {
-                    drwav_uint32 riffChunkSize = drwav__riff_chunk_size_riff(pWav->dataChunkDataSize);
-                    pWav->onWrite(pWav->pUserData, &riffChunkSize, 4);
+                    drwav_uint32 riffChunkSize = drwav__riff_chunk_size_riff(pWav->dataChunkDataSize, pWav->pMetadata, pWav->metadataCount);
+                    drwav__write_u32ne_to_le(pWav, riffChunkSize);
                 }
 
-                /* the "data" chunk size. */
-                if (pWav->onSeek(pWav->pUserData, (int)pWav->dataChunkDataPos + 4, drwav_seek_origin_start)) {
+                /* The "data" chunk size. */
+                if (pWav->onSeek(pWav->pUserData, (int)pWav->dataChunkDataPos - 4, drwav_seek_origin_start)) {
                     drwav_uint32 dataChunkSize = drwav__data_chunk_size_riff(pWav->dataChunkDataSize);
-                    pWav->onWrite(pWav->pUserData, &dataChunkSize, 4);
+                    drwav__write_u32ne_to_le(pWav, dataChunkSize);
                 }
-            } else {
+            } else if (pWav->container == drwav_container_w64) {
                 /* The "RIFF" chunk size. */
                 if (pWav->onSeek(pWav->pUserData, 16, drwav_seek_origin_start)) {
                     drwav_uint64 riffChunkSize = drwav__riff_chunk_size_w64(pWav->dataChunkDataSize);
-                    pWav->onWrite(pWav->pUserData, &riffChunkSize, 8);
+                    drwav__write_u64ne_to_le(pWav, riffChunkSize);
                 }
 
                 /* The "data" chunk size. */
-                if (pWav->onSeek(pWav->pUserData, (int)pWav->dataChunkDataPos + 16, drwav_seek_origin_start)) {
+                if (pWav->onSeek(pWav->pUserData, (int)pWav->dataChunkDataPos - 8, drwav_seek_origin_start)) {
                     drwav_uint64 dataChunkSize = drwav__data_chunk_size_w64(pWav->dataChunkDataSize);
-                    pWav->onWrite(pWav->pUserData, &dataChunkSize, 8);
+                    drwav__write_u64ne_to_le(pWav, dataChunkSize);
+                }
+            } else if (pWav->container == drwav_container_rf64) {
+                /* We only need to update the ds64 chunk. The "RIFF" and "data" chunks always have their sizes set to 0xFFFFFFFF for RF64. */
+                int ds64BodyPos = 12 + 8;
+
+                /* The "RIFF" chunk size. */
+                if (pWav->onSeek(pWav->pUserData, ds64BodyPos + 0, drwav_seek_origin_start)) {
+                    drwav_uint64 riffChunkSize = drwav__riff_chunk_size_rf64(pWav->dataChunkDataSize, pWav->pMetadata, pWav->metadataCount);
+                    drwav__write_u64ne_to_le(pWav, riffChunkSize);
+                }
+
+                /* The "data" chunk size. */
+                if (pWav->onSeek(pWav->pUserData, ds64BodyPos + 8, drwav_seek_origin_start)) {
+                    drwav_uint64 dataChunkSize = drwav__data_chunk_size_rf64(pWav->dataChunkDataSize);
+                    drwav__write_u64ne_to_le(pWav, dataChunkSize);
                 }
             }
         }
 
         /* Validation for sequential mode. */
         if (pWav->isSequentialWrite) {
             if (pWav->dataChunkDataSize != pWav->dataChunkDataSizeTargetWrite) {
                 result = DRWAV_INVALID_FILE;
             }
         }
+    } else {
+        if (pWav->pMetadata != NULL) {
+            pWav->allocationCallbacks.onFree(pWav->pMetadata, pWav->allocationCallbacks.pUserData);
+        }
     }
 
 #ifndef DR_WAV_NO_STDIO
     /*
     If we opened the file with drwav_open_file() we will want to close the file handle. We can know whether or not drwav_open_file()
     was used by looking at the onRead and onSeek callbacks.
     */
@@ -3310,61 +5316,125 @@
 }
 
 
 
 DRWAV_API size_t drwav_read_raw(drwav* pWav, size_t bytesToRead, void* pBufferOut)
 {
     size_t bytesRead;
+    drwav_uint32 bytesPerFrame;
 
-    if (pWav == NULL || bytesToRead == 0 || pBufferOut == NULL) {
-        return 0;
+    if (pWav == NULL || bytesToRead == 0) {
+        return 0;   /* Invalid args. */
     }
 
     if (bytesToRead > pWav->bytesRemaining) {
         bytesToRead = (size_t)pWav->bytesRemaining;
     }
 
-    bytesRead = pWav->onRead(pWav->pUserData, pBufferOut, bytesToRead);
+    if (bytesToRead == 0) {
+        return 0;   /* At end. */
+    }
+
+    bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
+    if (bytesPerFrame == 0) {
+        return 0;   /* Could not determine the bytes per frame. */
+    }
+
+    if (pBufferOut != NULL) {
+        bytesRead = pWav->onRead(pWav->pUserData, pBufferOut, bytesToRead);
+    } else {
+        /* We need to seek. If we fail, we need to read-and-discard to make sure we get a good byte count. */
+        bytesRead = 0;
+        while (bytesRead < bytesToRead) {
+            size_t bytesToSeek = (bytesToRead - bytesRead);
+            if (bytesToSeek > 0x7FFFFFFF) {
+                bytesToSeek = 0x7FFFFFFF;
+            }
+
+            if (pWav->onSeek(pWav->pUserData, (int)bytesToSeek, drwav_seek_origin_current) == DRWAV_FALSE) {
+                break;
+            }
+
+            bytesRead += bytesToSeek;
+        }
+
+        /* When we get here we may need to read-and-discard some data. */
+        while (bytesRead < bytesToRead) {
+            drwav_uint8 buffer[4096];
+            size_t bytesSeeked;
+            size_t bytesToSeek = (bytesToRead - bytesRead);
+            if (bytesToSeek > sizeof(buffer)) {
+                bytesToSeek = sizeof(buffer);
+            }
+
+            bytesSeeked = pWav->onRead(pWav->pUserData, buffer, bytesToSeek);
+            bytesRead += bytesSeeked;
+
+            if (bytesSeeked < bytesToSeek) {
+                break;  /* Reached the end. */
+            }
+        }
+    }
+
+    pWav->readCursorInPCMFrames += bytesRead / bytesPerFrame;
 
     pWav->bytesRemaining -= bytesRead;
     return bytesRead;
 }
 
 
 
 DRWAV_API drwav_uint64 drwav_read_pcm_frames_le(drwav* pWav, drwav_uint64 framesToRead, void* pBufferOut)
 {
     drwav_uint32 bytesPerFrame;
+    drwav_uint64 bytesToRead;   /* Intentionally uint64 instead of size_t so we can do a check that we're not reading too much on 32-bit builds. */
 
-    if (pWav == NULL || framesToRead == 0 || pBufferOut == NULL) {
+    if (pWav == NULL || framesToRead == 0) {
         return 0;
     }
 
     /* Cannot use this function for compressed formats. */
     if (drwav__is_compressed_format_tag(pWav->translatedFormatTag)) {
         return 0;
     }
 
     bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
     if (bytesPerFrame == 0) {
         return 0;
     }
 
     /* Don't try to read more samples than can potentially fit in the output buffer. */
-    if (framesToRead * bytesPerFrame > DRWAV_SIZE_MAX) {
-        framesToRead = DRWAV_SIZE_MAX / bytesPerFrame;
+    bytesToRead = framesToRead * bytesPerFrame;
+    if (bytesToRead > DRWAV_SIZE_MAX) {
+        bytesToRead = (DRWAV_SIZE_MAX / bytesPerFrame) * bytesPerFrame; /* Round the number of bytes to read to a clean frame boundary. */
+    }
+
+    /*
+    Doing an explicit check here just to make it clear that we don't want to be attempt to read anything if there's no bytes to read. There
+    *could* be a time where it evaluates to 0 due to overflowing.
+    */
+    if (bytesToRead == 0) {
+        return 0;
     }
 
-    return drwav_read_raw(pWav, (size_t)(framesToRead * bytesPerFrame), pBufferOut) / bytesPerFrame;
+    return drwav_read_raw(pWav, (size_t)bytesToRead, pBufferOut) / bytesPerFrame;
 }
 
 DRWAV_API drwav_uint64 drwav_read_pcm_frames_be(drwav* pWav, drwav_uint64 framesToRead, void* pBufferOut)
 {
     drwav_uint64 framesRead = drwav_read_pcm_frames_le(pWav, framesToRead, pBufferOut);
-    drwav__bswap_samples(pBufferOut, framesRead*pWav->channels, drwav_get_bytes_per_pcm_frame(pWav)/pWav->channels, pWav->translatedFormatTag);
+
+    if (pBufferOut != NULL) {
+        drwav_uint32 bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
+        if (bytesPerFrame == 0) {
+            return 0;   /* Could not get the bytes per frame which means bytes per sample cannot be determined and we don't know how to byte swap. */
+        }
+
+        drwav__bswap_samples(pBufferOut, framesRead*pWav->channels, bytesPerFrame/pWav->channels, pWav->translatedFormatTag);
+    }
 
     return framesRead;
 }
 
 DRWAV_API drwav_uint64 drwav_read_pcm_frames(drwav* pWav, drwav_uint64 framesToRead, void* pBufferOut)
 {
     if (drwav__is_little_endian()) {
@@ -3372,29 +5442,38 @@
     } else {
         return drwav_read_pcm_frames_be(pWav, framesToRead, pBufferOut);
     }
 }
 
 
 
-DRWAV_API drwav_bool32 drwav_seek_to_first_pcm_frame(drwav* pWav)
+DRWAV_PRIVATE drwav_bool32 drwav_seek_to_first_pcm_frame(drwav* pWav)
 {
     if (pWav->onWrite != NULL) {
         return DRWAV_FALSE; /* No seeking in write mode. */
     }
 
     if (!pWav->onSeek(pWav->pUserData, (int)pWav->dataChunkDataPos, drwav_seek_origin_start)) {
         return DRWAV_FALSE;
     }
 
     if (drwav__is_compressed_format_tag(pWav->translatedFormatTag)) {
-        pWav->compressed.iCurrentPCMFrame = 0;
+        /* Cached data needs to be cleared for compressed formats. */
+        if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ADPCM) {
+            DRWAV_ZERO_OBJECT(&pWav->msadpcm);
+        } else if (pWav->translatedFormatTag == DR_WAVE_FORMAT_DVI_ADPCM) {
+            DRWAV_ZERO_OBJECT(&pWav->ima);
+        } else {
+            DRWAV_ASSERT(DRWAV_FALSE);  /* If this assertion is triggered it means I've implemented a new compressed format but forgot to add a branch for it here. */
+        }
     }
-    
+
+    pWav->readCursorInPCMFrames = 0;
     pWav->bytesRemaining = pWav->dataChunkDataSize;
+
     return DRWAV_TRUE;
 }
 
 DRWAV_API drwav_bool32 drwav_seek_to_pcm_frame(drwav* pWav, drwav_uint64 targetFrameIndex)
 {
     /* Seeking should be compatible with wave files > 2GB. */
 
@@ -3409,72 +5488,78 @@
 
     /* If there are no samples, just return DRWAV_TRUE without doing anything. */
     if (pWav->totalPCMFrameCount == 0) {
         return DRWAV_TRUE;
     }
 
     /* Make sure the sample is clamped. */
-    if (targetFrameIndex >= pWav->totalPCMFrameCount) {
-        targetFrameIndex  = pWav->totalPCMFrameCount - 1;
+    if (targetFrameIndex > pWav->totalPCMFrameCount) {
+        targetFrameIndex = pWav->totalPCMFrameCount;
     }
 
     /*
     For compressed formats we just use a slow generic seek. If we are seeking forward we just seek forward. If we are going backwards we need
     to seek back to the start.
     */
     if (drwav__is_compressed_format_tag(pWav->translatedFormatTag)) {
         /* TODO: This can be optimized. */
-        
+
         /*
         If we're seeking forward it's simple - just keep reading samples until we hit the sample we're requesting. If we're seeking backwards,
         we first need to seek back to the start and then just do the same thing as a forward seek.
         */
-        if (targetFrameIndex < pWav->compressed.iCurrentPCMFrame) {
+        if (targetFrameIndex < pWav->readCursorInPCMFrames) {
             if (!drwav_seek_to_first_pcm_frame(pWav)) {
                 return DRWAV_FALSE;
             }
         }
 
-        if (targetFrameIndex > pWav->compressed.iCurrentPCMFrame) {
-            drwav_uint64 offsetInFrames = targetFrameIndex - pWav->compressed.iCurrentPCMFrame;
+        if (targetFrameIndex > pWav->readCursorInPCMFrames) {
+            drwav_uint64 offsetInFrames = targetFrameIndex - pWav->readCursorInPCMFrames;
 
             drwav_int16 devnull[2048];
             while (offsetInFrames > 0) {
                 drwav_uint64 framesRead = 0;
                 drwav_uint64 framesToRead = offsetInFrames;
                 if (framesToRead > drwav_countof(devnull)/pWav->channels) {
                     framesToRead = drwav_countof(devnull)/pWav->channels;
                 }
 
                 if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ADPCM) {
                     framesRead = drwav_read_pcm_frames_s16__msadpcm(pWav, framesToRead, devnull);
                 } else if (pWav->translatedFormatTag == DR_WAVE_FORMAT_DVI_ADPCM) {
                     framesRead = drwav_read_pcm_frames_s16__ima(pWav, framesToRead, devnull);
                 } else {
-                    assert(DRWAV_FALSE);    /* If this assertion is triggered it means I've implemented a new compressed format but forgot to add a branch for it here. */
+                    DRWAV_ASSERT(DRWAV_FALSE);  /* If this assertion is triggered it means I've implemented a new compressed format but forgot to add a branch for it here. */
                 }
 
                 if (framesRead != framesToRead) {
                     return DRWAV_FALSE;
                 }
 
                 offsetInFrames -= framesRead;
             }
         }
     } else {
         drwav_uint64 totalSizeInBytes;
         drwav_uint64 currentBytePos;
         drwav_uint64 targetBytePos;
         drwav_uint64 offset;
+        drwav_uint32 bytesPerFrame;
+
+        bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
+        if (bytesPerFrame == 0) {
+            return DRWAV_FALSE; /* Not able to calculate offset. */
+        }
 
-        totalSizeInBytes = pWav->totalPCMFrameCount * drwav_get_bytes_per_pcm_frame(pWav);
+        totalSizeInBytes = pWav->totalPCMFrameCount * bytesPerFrame;
         DRWAV_ASSERT(totalSizeInBytes >= pWav->bytesRemaining);
 
         currentBytePos = totalSizeInBytes - pWav->bytesRemaining;
-        targetBytePos  = targetFrameIndex * drwav_get_bytes_per_pcm_frame(pWav);
+        targetBytePos  = targetFrameIndex * bytesPerFrame;
 
         if (currentBytePos < targetBytePos) {
             /* Offset forwards. */
             offset = (targetBytePos - currentBytePos);
         } else {
             /* Offset backwards. */
             if (!drwav_seek_to_first_pcm_frame(pWav)) {
@@ -3485,22 +5570,57 @@
 
         while (offset > 0) {
             int offset32 = ((offset > INT_MAX) ? INT_MAX : (int)offset);
             if (!pWav->onSeek(pWav->pUserData, offset32, drwav_seek_origin_current)) {
                 return DRWAV_FALSE;
             }
 
-            pWav->bytesRemaining -= offset32;
-            offset -= offset32;
+            pWav->readCursorInPCMFrames += offset32 / bytesPerFrame;
+            pWav->bytesRemaining        -= offset32;
+            offset                      -= offset32;
         }
     }
 
     return DRWAV_TRUE;
 }
 
+DRWAV_API drwav_result drwav_get_cursor_in_pcm_frames(drwav* pWav, drwav_uint64* pCursor)
+{
+    if (pCursor == NULL) {
+        return DRWAV_INVALID_ARGS;
+    }
+
+    *pCursor = 0;   /* Safety. */
+
+    if (pWav == NULL) {
+        return DRWAV_INVALID_ARGS;
+    }
+
+    *pCursor = pWav->readCursorInPCMFrames;
+
+    return DRWAV_SUCCESS;
+}
+
+DRWAV_API drwav_result drwav_get_length_in_pcm_frames(drwav* pWav, drwav_uint64* pLength)
+{
+    if (pLength == NULL) {
+        return DRWAV_INVALID_ARGS;
+    }
+
+    *pLength = 0;   /* Safety. */
+
+    if (pWav == NULL) {
+        return DRWAV_INVALID_ARGS;
+    }
+
+    *pLength = pWav->totalPCMFrameCount;
+
+    return DRWAV_SUCCESS;
+}
+
 
 DRWAV_API size_t drwav_write_raw(drwav* pWav, size_t bytesToWrite, const void* pData)
 {
     size_t bytesWritten;
 
     if (pWav == NULL || bytesToWrite == 0 || pData == NULL) {
         return 0;
@@ -3508,15 +5628,14 @@
 
     bytesWritten = pWav->onWrite(pWav->pUserData, pData, bytesToWrite);
     pWav->dataChunkDataSize += bytesWritten;
 
     return bytesWritten;
 }
 
-
 DRWAV_API drwav_uint64 drwav_write_pcm_frames_le(drwav* pWav, drwav_uint64 framesToWrite, const void* pData)
 {
     drwav_uint64 bytesToWrite;
     drwav_uint64 bytesWritten;
     const drwav_uint8* pRunningData;
 
     if (pWav == NULL || framesToWrite == 0 || pData == NULL) {
@@ -3567,15 +5686,18 @@
         return 0;
     }
 
     bytesWritten = 0;
     pRunningData = (const drwav_uint8*)pData;
 
     bytesPerSample = drwav_get_bytes_per_pcm_frame(pWav) / pWav->channels;
-    
+    if (bytesPerSample == 0) {
+        return 0;   /* Cannot determine bytes per sample, or bytes per sample is less than one byte. */
+    }
+
     while (bytesToWrite > 0) {
         drwav_uint8 temp[4096];
         drwav_uint32 sampleCount;
         size_t bytesJustWritten;
         drwav_uint64 bytesToWriteThisIteration;
 
         bytesToWriteThisIteration = bytesToWrite;
@@ -3613,97 +5735,101 @@
         return drwav_write_pcm_frames_le(pWav, framesToWrite, pData);
     } else {
         return drwav_write_pcm_frames_be(pWav, framesToWrite, pData);
     }
 }
 
 
-static drwav_uint64 drwav_read_pcm_frames_s16__msadpcm(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)
+DRWAV_PRIVATE drwav_uint64 drwav_read_pcm_frames_s16__msadpcm(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)
 {
     drwav_uint64 totalFramesRead = 0;
 
     DRWAV_ASSERT(pWav != NULL);
     DRWAV_ASSERT(framesToRead > 0);
-    DRWAV_ASSERT(pBufferOut != NULL);
 
     /* TODO: Lots of room for optimization here. */
 
-    while (framesToRead > 0 && pWav->compressed.iCurrentPCMFrame < pWav->totalPCMFrameCount) {
+    while (pWav->readCursorInPCMFrames < pWav->totalPCMFrameCount) {
+        DRWAV_ASSERT(framesToRead > 0); /* This loop iteration will never get hit with framesToRead == 0 because it's asserted at the top, and we check for 0 inside the loop just below. */
+
         /* If there are no cached frames we need to load a new block. */
         if (pWav->msadpcm.cachedFrameCount == 0 && pWav->msadpcm.bytesRemainingInBlock == 0) {
             if (pWav->channels == 1) {
                 /* Mono. */
                 drwav_uint8 header[7];
                 if (pWav->onRead(pWav->pUserData, header, sizeof(header)) != sizeof(header)) {
                     return totalFramesRead;
                 }
                 pWav->msadpcm.bytesRemainingInBlock = pWav->fmt.blockAlign - sizeof(header);
 
                 pWav->msadpcm.predictor[0]     = header[0];
-                pWav->msadpcm.delta[0]         = drwav__bytes_to_s16(header + 1);
-                pWav->msadpcm.prevFrames[0][1] = (drwav_int32)drwav__bytes_to_s16(header + 3);
-                pWav->msadpcm.prevFrames[0][0] = (drwav_int32)drwav__bytes_to_s16(header + 5);
+                pWav->msadpcm.delta[0]         = drwav_bytes_to_s16(header + 1);
+                pWav->msadpcm.prevFrames[0][1] = (drwav_int32)drwav_bytes_to_s16(header + 3);
+                pWav->msadpcm.prevFrames[0][0] = (drwav_int32)drwav_bytes_to_s16(header + 5);
                 pWav->msadpcm.cachedFrames[2]  = pWav->msadpcm.prevFrames[0][0];
                 pWav->msadpcm.cachedFrames[3]  = pWav->msadpcm.prevFrames[0][1];
                 pWav->msadpcm.cachedFrameCount = 2;
             } else {
                 /* Stereo. */
                 drwav_uint8 header[14];
                 if (pWav->onRead(pWav->pUserData, header, sizeof(header)) != sizeof(header)) {
                     return totalFramesRead;
                 }
                 pWav->msadpcm.bytesRemainingInBlock = pWav->fmt.blockAlign - sizeof(header);
 
                 pWav->msadpcm.predictor[0] = header[0];
                 pWav->msadpcm.predictor[1] = header[1];
-                pWav->msadpcm.delta[0] = drwav__bytes_to_s16(header + 2);
-                pWav->msadpcm.delta[1] = drwav__bytes_to_s16(header + 4);
-                pWav->msadpcm.prevFrames[0][1] = (drwav_int32)drwav__bytes_to_s16(header + 6);
-                pWav->msadpcm.prevFrames[1][1] = (drwav_int32)drwav__bytes_to_s16(header + 8);
-                pWav->msadpcm.prevFrames[0][0] = (drwav_int32)drwav__bytes_to_s16(header + 10);
-                pWav->msadpcm.prevFrames[1][0] = (drwav_int32)drwav__bytes_to_s16(header + 12);
+                pWav->msadpcm.delta[0] = drwav_bytes_to_s16(header + 2);
+                pWav->msadpcm.delta[1] = drwav_bytes_to_s16(header + 4);
+                pWav->msadpcm.prevFrames[0][1] = (drwav_int32)drwav_bytes_to_s16(header + 6);
+                pWav->msadpcm.prevFrames[1][1] = (drwav_int32)drwav_bytes_to_s16(header + 8);
+                pWav->msadpcm.prevFrames[0][0] = (drwav_int32)drwav_bytes_to_s16(header + 10);
+                pWav->msadpcm.prevFrames[1][0] = (drwav_int32)drwav_bytes_to_s16(header + 12);
 
                 pWav->msadpcm.cachedFrames[0] = pWav->msadpcm.prevFrames[0][0];
                 pWav->msadpcm.cachedFrames[1] = pWav->msadpcm.prevFrames[1][0];
                 pWav->msadpcm.cachedFrames[2] = pWav->msadpcm.prevFrames[0][1];
                 pWav->msadpcm.cachedFrames[3] = pWav->msadpcm.prevFrames[1][1];
                 pWav->msadpcm.cachedFrameCount = 2;
             }
         }
 
         /* Output anything that's cached. */
-        while (framesToRead > 0 && pWav->msadpcm.cachedFrameCount > 0 && pWav->compressed.iCurrentPCMFrame < pWav->totalPCMFrameCount) {
-            drwav_uint32 iSample = 0;
-            for (iSample = 0; iSample < pWav->channels; iSample += 1) {
-                pBufferOut[iSample] = (drwav_int16)pWav->msadpcm.cachedFrames[(drwav_countof(pWav->msadpcm.cachedFrames) - (pWav->msadpcm.cachedFrameCount*pWav->channels)) + iSample];
+        while (framesToRead > 0 && pWav->msadpcm.cachedFrameCount > 0 && pWav->readCursorInPCMFrames < pWav->totalPCMFrameCount) {
+            if (pBufferOut != NULL) {
+                drwav_uint32 iSample = 0;
+                for (iSample = 0; iSample < pWav->channels; iSample += 1) {
+                    pBufferOut[iSample] = (drwav_int16)pWav->msadpcm.cachedFrames[(drwav_countof(pWav->msadpcm.cachedFrames) - (pWav->msadpcm.cachedFrameCount*pWav->channels)) + iSample];
+                }
+
+                pBufferOut += pWav->channels;
             }
 
-            pBufferOut      += pWav->channels;
             framesToRead    -= 1;
             totalFramesRead += 1;
-            pWav->compressed.iCurrentPCMFrame += 1;
+            pWav->readCursorInPCMFrames += 1;
             pWav->msadpcm.cachedFrameCount -= 1;
         }
 
         if (framesToRead == 0) {
-            return totalFramesRead;
+            break;
         }
 
 
         /*
         If there's nothing left in the cache, just go ahead and load more. If there's nothing left to load in the current block we just continue to the next
         loop iteration which will trigger the loading of a new block.
         */
         if (pWav->msadpcm.cachedFrameCount == 0) {
             if (pWav->msadpcm.bytesRemainingInBlock == 0) {
                 continue;
             } else {
-                static drwav_int32 adaptationTable[] = { 
-                    230, 230, 230, 230, 307, 409, 512, 614, 
-                    768, 614, 512, 409, 307, 230, 230, 230 
+                static drwav_int32 adaptationTable[] = {
+                    230, 230, 230, 230, 307, 409, 512, 614,
+                    768, 614, 512, 409, 307, 230, 230, 230
                 };
                 static drwav_int32 coeff1Table[] = { 256, 512, 0, 192, 240, 460,  392 };
                 static drwav_int32 coeff2Table[] = { 0,  -256, 0, 64,  0,  -208, -232 };
 
                 drwav_uint8 nibbles;
                 drwav_int32 nibble0;
                 drwav_int32 nibble1;
@@ -3791,103 +5917,117 @@
         }
     }
 
     return totalFramesRead;
 }
 
 
-static drwav_uint64 drwav_read_pcm_frames_s16__ima(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)
+DRWAV_PRIVATE drwav_uint64 drwav_read_pcm_frames_s16__ima(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)
 {
     drwav_uint64 totalFramesRead = 0;
+    drwav_uint32 iChannel;
+
+    static drwav_int32 indexTable[16] = {
+        -1, -1, -1, -1, 2, 4, 6, 8,
+        -1, -1, -1, -1, 2, 4, 6, 8
+    };
+
+    static drwav_int32 stepTable[89] = {
+        7,     8,     9,     10,    11,    12,    13,    14,    16,    17,
+        19,    21,    23,    25,    28,    31,    34,    37,    41,    45,
+        50,    55,    60,    66,    73,    80,    88,    97,    107,   118,
+        130,   143,   157,   173,   190,   209,   230,   253,   279,   307,
+        337,   371,   408,   449,   494,   544,   598,   658,   724,   796,
+        876,   963,   1060,  1166,  1282,  1411,  1552,  1707,  1878,  2066,
+        2272,  2499,  2749,  3024,  3327,  3660,  4026,  4428,  4871,  5358,
+        5894,  6484,  7132,  7845,  8630,  9493,  10442, 11487, 12635, 13899,
+        15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767
+    };
 
     DRWAV_ASSERT(pWav != NULL);
     DRWAV_ASSERT(framesToRead > 0);
-    DRWAV_ASSERT(pBufferOut != NULL);
 
     /* TODO: Lots of room for optimization here. */
 
-    while (framesToRead > 0 && pWav->compressed.iCurrentPCMFrame < pWav->totalPCMFrameCount) {
+    while (pWav->readCursorInPCMFrames < pWav->totalPCMFrameCount) {
+        DRWAV_ASSERT(framesToRead > 0); /* This loop iteration will never get hit with framesToRead == 0 because it's asserted at the top, and we check for 0 inside the loop just below. */
+
         /* If there are no cached samples we need to load a new block. */
         if (pWav->ima.cachedFrameCount == 0 && pWav->ima.bytesRemainingInBlock == 0) {
             if (pWav->channels == 1) {
                 /* Mono. */
                 drwav_uint8 header[4];
                 if (pWav->onRead(pWav->pUserData, header, sizeof(header)) != sizeof(header)) {
                     return totalFramesRead;
                 }
                 pWav->ima.bytesRemainingInBlock = pWav->fmt.blockAlign - sizeof(header);
 
-                pWav->ima.predictor[0] = drwav__bytes_to_s16(header + 0);
-                pWav->ima.stepIndex[0] = header[2];
+                if (header[2] >= drwav_countof(stepTable)) {
+                    pWav->onSeek(pWav->pUserData, pWav->ima.bytesRemainingInBlock, drwav_seek_origin_current);
+                    pWav->ima.bytesRemainingInBlock = 0;
+                    return totalFramesRead; /* Invalid data. */
+                }
+
+                pWav->ima.predictor[0] = drwav_bytes_to_s16(header + 0);
+                pWav->ima.stepIndex[0] = drwav_clamp(header[2], 0, (drwav_int32)drwav_countof(stepTable)-1);    /* Clamp not necessary because we checked above, but adding here to silence a static analysis warning. */
                 pWav->ima.cachedFrames[drwav_countof(pWav->ima.cachedFrames) - 1] = pWav->ima.predictor[0];
                 pWav->ima.cachedFrameCount = 1;
             } else {
                 /* Stereo. */
                 drwav_uint8 header[8];
                 if (pWav->onRead(pWav->pUserData, header, sizeof(header)) != sizeof(header)) {
                     return totalFramesRead;
                 }
                 pWav->ima.bytesRemainingInBlock = pWav->fmt.blockAlign - sizeof(header);
 
-                pWav->ima.predictor[0] = drwav__bytes_to_s16(header + 0);
-                pWav->ima.stepIndex[0] = header[2];
-                pWav->ima.predictor[1] = drwav__bytes_to_s16(header + 4);
-                pWav->ima.stepIndex[1] = header[6];
+                if (header[2] >= drwav_countof(stepTable) || header[6] >= drwav_countof(stepTable)) {
+                    pWav->onSeek(pWav->pUserData, pWav->ima.bytesRemainingInBlock, drwav_seek_origin_current);
+                    pWav->ima.bytesRemainingInBlock = 0;
+                    return totalFramesRead; /* Invalid data. */
+                }
+
+                pWav->ima.predictor[0] = drwav_bytes_to_s16(header + 0);
+                pWav->ima.stepIndex[0] = drwav_clamp(header[2], 0, (drwav_int32)drwav_countof(stepTable)-1);    /* Clamp not necessary because we checked above, but adding here to silence a static analysis warning. */
+                pWav->ima.predictor[1] = drwav_bytes_to_s16(header + 4);
+                pWav->ima.stepIndex[1] = drwav_clamp(header[6], 0, (drwav_int32)drwav_countof(stepTable)-1);    /* Clamp not necessary because we checked above, but adding here to silence a static analysis warning. */
 
                 pWav->ima.cachedFrames[drwav_countof(pWav->ima.cachedFrames) - 2] = pWav->ima.predictor[0];
                 pWav->ima.cachedFrames[drwav_countof(pWav->ima.cachedFrames) - 1] = pWav->ima.predictor[1];
                 pWav->ima.cachedFrameCount = 1;
             }
         }
 
         /* Output anything that's cached. */
-        while (framesToRead > 0 && pWav->ima.cachedFrameCount > 0 && pWav->compressed.iCurrentPCMFrame < pWav->totalPCMFrameCount) {
-            drwav_uint32 iSample;
-            for (iSample = 0; iSample < pWav->channels; iSample += 1) {
-                pBufferOut[iSample] = (drwav_int16)pWav->ima.cachedFrames[(drwav_countof(pWav->ima.cachedFrames) - (pWav->ima.cachedFrameCount*pWav->channels)) + iSample];
+        while (framesToRead > 0 && pWav->ima.cachedFrameCount > 0 && pWav->readCursorInPCMFrames < pWav->totalPCMFrameCount) {
+            if (pBufferOut != NULL) {
+                drwav_uint32 iSample;
+                for (iSample = 0; iSample < pWav->channels; iSample += 1) {
+                    pBufferOut[iSample] = (drwav_int16)pWav->ima.cachedFrames[(drwav_countof(pWav->ima.cachedFrames) - (pWav->ima.cachedFrameCount*pWav->channels)) + iSample];
+                }
+                pBufferOut += pWav->channels;
             }
 
-            pBufferOut      += pWav->channels;
             framesToRead    -= 1;
             totalFramesRead += 1;
-            pWav->compressed.iCurrentPCMFrame += 1;
+            pWav->readCursorInPCMFrames += 1;
             pWav->ima.cachedFrameCount -= 1;
         }
 
         if (framesToRead == 0) {
-            return totalFramesRead;
+            break;
         }
 
         /*
         If there's nothing left in the cache, just go ahead and load more. If there's nothing left to load in the current block we just continue to the next
         loop iteration which will trigger the loading of a new block.
         */
         if (pWav->ima.cachedFrameCount == 0) {
             if (pWav->ima.bytesRemainingInBlock == 0) {
                 continue;
             } else {
-                static drwav_int32 indexTable[16] = {
-                    -1, -1, -1, -1, 2, 4, 6, 8,
-                    -1, -1, -1, -1, 2, 4, 6, 8
-                };
-
-                static drwav_int32 stepTable[89] = {
-                    7,     8,     9,     10,    11,    12,    13,    14,    16,    17, 
-                    19,    21,    23,    25,    28,    31,    34,    37,    41,    45, 
-                    50,    55,    60,    66,    73,    80,    88,    97,    107,   118, 
-                    130,   143,   157,   173,   190,   209,   230,   253,   279,   307,
-                    337,   371,   408,   449,   494,   544,   598,   658,   724,   796,
-                    876,   963,   1060,  1166,  1282,  1411,  1552,  1707,  1878,  2066, 
-                    2272,  2499,  2749,  3024,  3327,  3660,  4026,  4428,  4871,  5358,
-                    5894,  6484,  7132,  7845,  8630,  9493,  10442, 11487, 12635, 13899, 
-                    15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767 
-                };
-
-                drwav_uint32 iChannel;
-
                 /*
                 From what I can tell with stereo streams, it looks like every 4 bytes (8 samples) is for one channel. So it goes 4 bytes for the
                 left channel, 4 bytes for the right channel.
                 */
                 pWav->ima.cachedFrameCount = 8;
                 for (iChannel = 0; iChannel < pWav->channels; ++iChannel) {
                     drwav_uint32 iByte;
@@ -3938,48 +6078,48 @@
 
     return totalFramesRead;
 }
 
 
 #ifndef DR_WAV_NO_CONVERSION_API
 static unsigned short g_drwavAlawTable[256] = {
-    0xEA80, 0xEB80, 0xE880, 0xE980, 0xEE80, 0xEF80, 0xEC80, 0xED80, 0xE280, 0xE380, 0xE080, 0xE180, 0xE680, 0xE780, 0xE480, 0xE580, 
-    0xF540, 0xF5C0, 0xF440, 0xF4C0, 0xF740, 0xF7C0, 0xF640, 0xF6C0, 0xF140, 0xF1C0, 0xF040, 0xF0C0, 0xF340, 0xF3C0, 0xF240, 0xF2C0, 
-    0xAA00, 0xAE00, 0xA200, 0xA600, 0xBA00, 0xBE00, 0xB200, 0xB600, 0x8A00, 0x8E00, 0x8200, 0x8600, 0x9A00, 0x9E00, 0x9200, 0x9600, 
-    0xD500, 0xD700, 0xD100, 0xD300, 0xDD00, 0xDF00, 0xD900, 0xDB00, 0xC500, 0xC700, 0xC100, 0xC300, 0xCD00, 0xCF00, 0xC900, 0xCB00, 
-    0xFEA8, 0xFEB8, 0xFE88, 0xFE98, 0xFEE8, 0xFEF8, 0xFEC8, 0xFED8, 0xFE28, 0xFE38, 0xFE08, 0xFE18, 0xFE68, 0xFE78, 0xFE48, 0xFE58, 
-    0xFFA8, 0xFFB8, 0xFF88, 0xFF98, 0xFFE8, 0xFFF8, 0xFFC8, 0xFFD8, 0xFF28, 0xFF38, 0xFF08, 0xFF18, 0xFF68, 0xFF78, 0xFF48, 0xFF58, 
-    0xFAA0, 0xFAE0, 0xFA20, 0xFA60, 0xFBA0, 0xFBE0, 0xFB20, 0xFB60, 0xF8A0, 0xF8E0, 0xF820, 0xF860, 0xF9A0, 0xF9E0, 0xF920, 0xF960, 
-    0xFD50, 0xFD70, 0xFD10, 0xFD30, 0xFDD0, 0xFDF0, 0xFD90, 0xFDB0, 0xFC50, 0xFC70, 0xFC10, 0xFC30, 0xFCD0, 0xFCF0, 0xFC90, 0xFCB0, 
-    0x1580, 0x1480, 0x1780, 0x1680, 0x1180, 0x1080, 0x1380, 0x1280, 0x1D80, 0x1C80, 0x1F80, 0x1E80, 0x1980, 0x1880, 0x1B80, 0x1A80, 
-    0x0AC0, 0x0A40, 0x0BC0, 0x0B40, 0x08C0, 0x0840, 0x09C0, 0x0940, 0x0EC0, 0x0E40, 0x0FC0, 0x0F40, 0x0CC0, 0x0C40, 0x0DC0, 0x0D40, 
-    0x5600, 0x5200, 0x5E00, 0x5A00, 0x4600, 0x4200, 0x4E00, 0x4A00, 0x7600, 0x7200, 0x7E00, 0x7A00, 0x6600, 0x6200, 0x6E00, 0x6A00, 
-    0x2B00, 0x2900, 0x2F00, 0x2D00, 0x2300, 0x2100, 0x2700, 0x2500, 0x3B00, 0x3900, 0x3F00, 0x3D00, 0x3300, 0x3100, 0x3700, 0x3500, 
-    0x0158, 0x0148, 0x0178, 0x0168, 0x0118, 0x0108, 0x0138, 0x0128, 0x01D8, 0x01C8, 0x01F8, 0x01E8, 0x0198, 0x0188, 0x01B8, 0x01A8, 
-    0x0058, 0x0048, 0x0078, 0x0068, 0x0018, 0x0008, 0x0038, 0x0028, 0x00D8, 0x00C8, 0x00F8, 0x00E8, 0x0098, 0x0088, 0x00B8, 0x00A8, 
-    0x0560, 0x0520, 0x05E0, 0x05A0, 0x0460, 0x0420, 0x04E0, 0x04A0, 0x0760, 0x0720, 0x07E0, 0x07A0, 0x0660, 0x0620, 0x06E0, 0x06A0, 
+    0xEA80, 0xEB80, 0xE880, 0xE980, 0xEE80, 0xEF80, 0xEC80, 0xED80, 0xE280, 0xE380, 0xE080, 0xE180, 0xE680, 0xE780, 0xE480, 0xE580,
+    0xF540, 0xF5C0, 0xF440, 0xF4C0, 0xF740, 0xF7C0, 0xF640, 0xF6C0, 0xF140, 0xF1C0, 0xF040, 0xF0C0, 0xF340, 0xF3C0, 0xF240, 0xF2C0,
+    0xAA00, 0xAE00, 0xA200, 0xA600, 0xBA00, 0xBE00, 0xB200, 0xB600, 0x8A00, 0x8E00, 0x8200, 0x8600, 0x9A00, 0x9E00, 0x9200, 0x9600,
+    0xD500, 0xD700, 0xD100, 0xD300, 0xDD00, 0xDF00, 0xD900, 0xDB00, 0xC500, 0xC700, 0xC100, 0xC300, 0xCD00, 0xCF00, 0xC900, 0xCB00,
+    0xFEA8, 0xFEB8, 0xFE88, 0xFE98, 0xFEE8, 0xFEF8, 0xFEC8, 0xFED8, 0xFE28, 0xFE38, 0xFE08, 0xFE18, 0xFE68, 0xFE78, 0xFE48, 0xFE58,
+    0xFFA8, 0xFFB8, 0xFF88, 0xFF98, 0xFFE8, 0xFFF8, 0xFFC8, 0xFFD8, 0xFF28, 0xFF38, 0xFF08, 0xFF18, 0xFF68, 0xFF78, 0xFF48, 0xFF58,
+    0xFAA0, 0xFAE0, 0xFA20, 0xFA60, 0xFBA0, 0xFBE0, 0xFB20, 0xFB60, 0xF8A0, 0xF8E0, 0xF820, 0xF860, 0xF9A0, 0xF9E0, 0xF920, 0xF960,
+    0xFD50, 0xFD70, 0xFD10, 0xFD30, 0xFDD0, 0xFDF0, 0xFD90, 0xFDB0, 0xFC50, 0xFC70, 0xFC10, 0xFC30, 0xFCD0, 0xFCF0, 0xFC90, 0xFCB0,
+    0x1580, 0x1480, 0x1780, 0x1680, 0x1180, 0x1080, 0x1380, 0x1280, 0x1D80, 0x1C80, 0x1F80, 0x1E80, 0x1980, 0x1880, 0x1B80, 0x1A80,
+    0x0AC0, 0x0A40, 0x0BC0, 0x0B40, 0x08C0, 0x0840, 0x09C0, 0x0940, 0x0EC0, 0x0E40, 0x0FC0, 0x0F40, 0x0CC0, 0x0C40, 0x0DC0, 0x0D40,
+    0x5600, 0x5200, 0x5E00, 0x5A00, 0x4600, 0x4200, 0x4E00, 0x4A00, 0x7600, 0x7200, 0x7E00, 0x7A00, 0x6600, 0x6200, 0x6E00, 0x6A00,
+    0x2B00, 0x2900, 0x2F00, 0x2D00, 0x2300, 0x2100, 0x2700, 0x2500, 0x3B00, 0x3900, 0x3F00, 0x3D00, 0x3300, 0x3100, 0x3700, 0x3500,
+    0x0158, 0x0148, 0x0178, 0x0168, 0x0118, 0x0108, 0x0138, 0x0128, 0x01D8, 0x01C8, 0x01F8, 0x01E8, 0x0198, 0x0188, 0x01B8, 0x01A8,
+    0x0058, 0x0048, 0x0078, 0x0068, 0x0018, 0x0008, 0x0038, 0x0028, 0x00D8, 0x00C8, 0x00F8, 0x00E8, 0x0098, 0x0088, 0x00B8, 0x00A8,
+    0x0560, 0x0520, 0x05E0, 0x05A0, 0x0460, 0x0420, 0x04E0, 0x04A0, 0x0760, 0x0720, 0x07E0, 0x07A0, 0x0660, 0x0620, 0x06E0, 0x06A0,
     0x02B0, 0x0290, 0x02F0, 0x02D0, 0x0230, 0x0210, 0x0270, 0x0250, 0x03B0, 0x0390, 0x03F0, 0x03D0, 0x0330, 0x0310, 0x0370, 0x0350
 };
 
 static unsigned short g_drwavMulawTable[256] = {
-    0x8284, 0x8684, 0x8A84, 0x8E84, 0x9284, 0x9684, 0x9A84, 0x9E84, 0xA284, 0xA684, 0xAA84, 0xAE84, 0xB284, 0xB684, 0xBA84, 0xBE84, 
-    0xC184, 0xC384, 0xC584, 0xC784, 0xC984, 0xCB84, 0xCD84, 0xCF84, 0xD184, 0xD384, 0xD584, 0xD784, 0xD984, 0xDB84, 0xDD84, 0xDF84, 
-    0xE104, 0xE204, 0xE304, 0xE404, 0xE504, 0xE604, 0xE704, 0xE804, 0xE904, 0xEA04, 0xEB04, 0xEC04, 0xED04, 0xEE04, 0xEF04, 0xF004, 
-    0xF0C4, 0xF144, 0xF1C4, 0xF244, 0xF2C4, 0xF344, 0xF3C4, 0xF444, 0xF4C4, 0xF544, 0xF5C4, 0xF644, 0xF6C4, 0xF744, 0xF7C4, 0xF844, 
-    0xF8A4, 0xF8E4, 0xF924, 0xF964, 0xF9A4, 0xF9E4, 0xFA24, 0xFA64, 0xFAA4, 0xFAE4, 0xFB24, 0xFB64, 0xFBA4, 0xFBE4, 0xFC24, 0xFC64, 
-    0xFC94, 0xFCB4, 0xFCD4, 0xFCF4, 0xFD14, 0xFD34, 0xFD54, 0xFD74, 0xFD94, 0xFDB4, 0xFDD4, 0xFDF4, 0xFE14, 0xFE34, 0xFE54, 0xFE74, 
-    0xFE8C, 0xFE9C, 0xFEAC, 0xFEBC, 0xFECC, 0xFEDC, 0xFEEC, 0xFEFC, 0xFF0C, 0xFF1C, 0xFF2C, 0xFF3C, 0xFF4C, 0xFF5C, 0xFF6C, 0xFF7C, 
-    0xFF88, 0xFF90, 0xFF98, 0xFFA0, 0xFFA8, 0xFFB0, 0xFFB8, 0xFFC0, 0xFFC8, 0xFFD0, 0xFFD8, 0xFFE0, 0xFFE8, 0xFFF0, 0xFFF8, 0x0000, 
-    0x7D7C, 0x797C, 0x757C, 0x717C, 0x6D7C, 0x697C, 0x657C, 0x617C, 0x5D7C, 0x597C, 0x557C, 0x517C, 0x4D7C, 0x497C, 0x457C, 0x417C, 
-    0x3E7C, 0x3C7C, 0x3A7C, 0x387C, 0x367C, 0x347C, 0x327C, 0x307C, 0x2E7C, 0x2C7C, 0x2A7C, 0x287C, 0x267C, 0x247C, 0x227C, 0x207C, 
-    0x1EFC, 0x1DFC, 0x1CFC, 0x1BFC, 0x1AFC, 0x19FC, 0x18FC, 0x17FC, 0x16FC, 0x15FC, 0x14FC, 0x13FC, 0x12FC, 0x11FC, 0x10FC, 0x0FFC, 
-    0x0F3C, 0x0EBC, 0x0E3C, 0x0DBC, 0x0D3C, 0x0CBC, 0x0C3C, 0x0BBC, 0x0B3C, 0x0ABC, 0x0A3C, 0x09BC, 0x093C, 0x08BC, 0x083C, 0x07BC, 
-    0x075C, 0x071C, 0x06DC, 0x069C, 0x065C, 0x061C, 0x05DC, 0x059C, 0x055C, 0x051C, 0x04DC, 0x049C, 0x045C, 0x041C, 0x03DC, 0x039C, 
-    0x036C, 0x034C, 0x032C, 0x030C, 0x02EC, 0x02CC, 0x02AC, 0x028C, 0x026C, 0x024C, 0x022C, 0x020C, 0x01EC, 0x01CC, 0x01AC, 0x018C, 
-    0x0174, 0x0164, 0x0154, 0x0144, 0x0134, 0x0124, 0x0114, 0x0104, 0x00F4, 0x00E4, 0x00D4, 0x00C4, 0x00B4, 0x00A4, 0x0094, 0x0084, 
+    0x8284, 0x8684, 0x8A84, 0x8E84, 0x9284, 0x9684, 0x9A84, 0x9E84, 0xA284, 0xA684, 0xAA84, 0xAE84, 0xB284, 0xB684, 0xBA84, 0xBE84,
+    0xC184, 0xC384, 0xC584, 0xC784, 0xC984, 0xCB84, 0xCD84, 0xCF84, 0xD184, 0xD384, 0xD584, 0xD784, 0xD984, 0xDB84, 0xDD84, 0xDF84,
+    0xE104, 0xE204, 0xE304, 0xE404, 0xE504, 0xE604, 0xE704, 0xE804, 0xE904, 0xEA04, 0xEB04, 0xEC04, 0xED04, 0xEE04, 0xEF04, 0xF004,
+    0xF0C4, 0xF144, 0xF1C4, 0xF244, 0xF2C4, 0xF344, 0xF3C4, 0xF444, 0xF4C4, 0xF544, 0xF5C4, 0xF644, 0xF6C4, 0xF744, 0xF7C4, 0xF844,
+    0xF8A4, 0xF8E4, 0xF924, 0xF964, 0xF9A4, 0xF9E4, 0xFA24, 0xFA64, 0xFAA4, 0xFAE4, 0xFB24, 0xFB64, 0xFBA4, 0xFBE4, 0xFC24, 0xFC64,
+    0xFC94, 0xFCB4, 0xFCD4, 0xFCF4, 0xFD14, 0xFD34, 0xFD54, 0xFD74, 0xFD94, 0xFDB4, 0xFDD4, 0xFDF4, 0xFE14, 0xFE34, 0xFE54, 0xFE74,
+    0xFE8C, 0xFE9C, 0xFEAC, 0xFEBC, 0xFECC, 0xFEDC, 0xFEEC, 0xFEFC, 0xFF0C, 0xFF1C, 0xFF2C, 0xFF3C, 0xFF4C, 0xFF5C, 0xFF6C, 0xFF7C,
+    0xFF88, 0xFF90, 0xFF98, 0xFFA0, 0xFFA8, 0xFFB0, 0xFFB8, 0xFFC0, 0xFFC8, 0xFFD0, 0xFFD8, 0xFFE0, 0xFFE8, 0xFFF0, 0xFFF8, 0x0000,
+    0x7D7C, 0x797C, 0x757C, 0x717C, 0x6D7C, 0x697C, 0x657C, 0x617C, 0x5D7C, 0x597C, 0x557C, 0x517C, 0x4D7C, 0x497C, 0x457C, 0x417C,
+    0x3E7C, 0x3C7C, 0x3A7C, 0x387C, 0x367C, 0x347C, 0x327C, 0x307C, 0x2E7C, 0x2C7C, 0x2A7C, 0x287C, 0x267C, 0x247C, 0x227C, 0x207C,
+    0x1EFC, 0x1DFC, 0x1CFC, 0x1BFC, 0x1AFC, 0x19FC, 0x18FC, 0x17FC, 0x16FC, 0x15FC, 0x14FC, 0x13FC, 0x12FC, 0x11FC, 0x10FC, 0x0FFC,
+    0x0F3C, 0x0EBC, 0x0E3C, 0x0DBC, 0x0D3C, 0x0CBC, 0x0C3C, 0x0BBC, 0x0B3C, 0x0ABC, 0x0A3C, 0x09BC, 0x093C, 0x08BC, 0x083C, 0x07BC,
+    0x075C, 0x071C, 0x06DC, 0x069C, 0x065C, 0x061C, 0x05DC, 0x059C, 0x055C, 0x051C, 0x04DC, 0x049C, 0x045C, 0x041C, 0x03DC, 0x039C,
+    0x036C, 0x034C, 0x032C, 0x030C, 0x02EC, 0x02CC, 0x02AC, 0x028C, 0x026C, 0x024C, 0x022C, 0x020C, 0x01EC, 0x01CC, 0x01AC, 0x018C,
+    0x0174, 0x0164, 0x0154, 0x0144, 0x0134, 0x0124, 0x0114, 0x0104, 0x00F4, 0x00E4, 0x00D4, 0x00C4, 0x00B4, 0x00A4, 0x0094, 0x0084,
     0x0078, 0x0070, 0x0068, 0x0060, 0x0058, 0x0050, 0x0048, 0x0040, 0x0038, 0x0030, 0x0028, 0x0020, 0x0018, 0x0010, 0x0008, 0x0000
 };
 
 static DRWAV_INLINE drwav_int16 drwav__alaw_to_s16(drwav_uint8 sampleIn)
 {
     return (short)g_drwavAlawTable[sampleIn];
 }
@@ -3987,17 +6127,17 @@
 static DRWAV_INLINE drwav_int16 drwav__mulaw_to_s16(drwav_uint8 sampleIn)
 {
     return (short)g_drwavMulawTable[sampleIn];
 }
 
 
 
-static void drwav__pcm_to_s16(drwav_int16* pOut, const unsigned char* pIn, size_t totalSampleCount, unsigned int bytesPerSample)
+DRWAV_PRIVATE void drwav__pcm_to_s16(drwav_int16* pOut, const drwav_uint8* pIn, size_t totalSampleCount, unsigned int bytesPerSample)
 {
-    unsigned int i;
+    size_t i;
 
     /* Special case for 8-bit sample data because it's treated as unsigned. */
     if (bytesPerSample == 1) {
         drwav_u8_to_s16(pOut, pIn, totalSampleCount);
         return;
     }
 
@@ -4039,153 +6179,240 @@
         }
 
         pIn += j;
         *pOut++ = (drwav_int16)((drwav_int64)sample >> 48);
     }
 }
 
-static void drwav__ieee_to_s16(drwav_int16* pOut, const unsigned char* pIn, size_t totalSampleCount, unsigned int bytesPerSample)
+DRWAV_PRIVATE void drwav__ieee_to_s16(drwav_int16* pOut, const drwav_uint8* pIn, size_t totalSampleCount, unsigned int bytesPerSample)
 {
     if (bytesPerSample == 4) {
         drwav_f32_to_s16(pOut, (const float*)pIn, totalSampleCount);
         return;
     } else if (bytesPerSample == 8) {
         drwav_f64_to_s16(pOut, (const double*)pIn, totalSampleCount);
         return;
     } else {
         /* Only supporting 32- and 64-bit float. Output silence in all other cases. Contributions welcome for 16-bit float. */
         DRWAV_ZERO_MEMORY(pOut, totalSampleCount * sizeof(*pOut));
         return;
     }
 }
 
-static drwav_uint64 drwav_read_pcm_frames_s16__pcm(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)
+DRWAV_PRIVATE drwav_uint64 drwav_read_pcm_frames_s16__pcm(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)
 {
-    drwav_uint32 bytesPerFrame;
     drwav_uint64 totalFramesRead;
-    unsigned char sampleData[4096];
+    drwav_uint8 sampleData[4096] = {0};
+    drwav_uint32 bytesPerFrame;
+    drwav_uint32 bytesPerSample;
+    drwav_uint64 samplesRead;
 
     /* Fast path. */
-    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_PCM && pWav->bitsPerSample == 16) {
+    if ((pWav->translatedFormatTag == DR_WAVE_FORMAT_PCM && pWav->bitsPerSample == 16) || pBufferOut == NULL) {
         return drwav_read_pcm_frames(pWav, framesToRead, pBufferOut);
     }
-    
+
     bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
     if (bytesPerFrame == 0) {
         return 0;
     }
 
+    bytesPerSample = bytesPerFrame / pWav->channels;
+    if (bytesPerSample == 0 || (bytesPerFrame % pWav->channels) != 0) {
+        return 0;   /* Only byte-aligned formats are supported. */
+    }
+
     totalFramesRead = 0;
-    
+
     while (framesToRead > 0) {
-        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);
+        drwav_uint64 framesToReadThisIteration = drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame);
+        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, framesToReadThisIteration, sampleData);
         if (framesRead == 0) {
             break;
         }
 
-        drwav__pcm_to_s16(pBufferOut, sampleData, (size_t)(framesRead*pWav->channels), bytesPerFrame/pWav->channels);
+        DRWAV_ASSERT(framesRead <= framesToReadThisIteration);   /* If this fails it means there's a bug in drwav_read_pcm_frames(). */
 
-        pBufferOut      += framesRead*pWav->channels;
+        /* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */
+        samplesRead = framesRead * pWav->channels;
+        if ((samplesRead * bytesPerSample) > sizeof(sampleData)) {
+            DRWAV_ASSERT(DRWAV_FALSE);  /* This should never happen with a valid file. */
+            break;
+        }
+
+        drwav__pcm_to_s16(pBufferOut, sampleData, (size_t)samplesRead, bytesPerSample);
+
+        pBufferOut      += samplesRead;
         framesToRead    -= framesRead;
         totalFramesRead += framesRead;
     }
 
     return totalFramesRead;
 }
 
-static drwav_uint64 drwav_read_pcm_frames_s16__ieee(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)
+DRWAV_PRIVATE drwav_uint64 drwav_read_pcm_frames_s16__ieee(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)
 {
     drwav_uint64 totalFramesRead;
-    unsigned char sampleData[4096];
+    drwav_uint8 sampleData[4096] = {0};
+    drwav_uint32 bytesPerFrame;
+    drwav_uint32 bytesPerSample;
+    drwav_uint64 samplesRead;
+
+    if (pBufferOut == NULL) {
+        return drwav_read_pcm_frames(pWav, framesToRead, NULL);
+    }
 
-    drwav_uint32 bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
+    bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
     if (bytesPerFrame == 0) {
         return 0;
     }
 
+    bytesPerSample = bytesPerFrame / pWav->channels;
+    if (bytesPerSample == 0 || (bytesPerFrame % pWav->channels) != 0) {
+        return 0;   /* Only byte-aligned formats are supported. */
+    }
+
     totalFramesRead = 0;
-    
+
     while (framesToRead > 0) {
-        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);
+        drwav_uint64 framesToReadThisIteration = drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame);
+        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, framesToReadThisIteration, sampleData);
         if (framesRead == 0) {
             break;
         }
 
-        drwav__ieee_to_s16(pBufferOut, sampleData, (size_t)(framesRead*pWav->channels), bytesPerFrame/pWav->channels);
+        DRWAV_ASSERT(framesRead <= framesToReadThisIteration);   /* If this fails it means there's a bug in drwav_read_pcm_frames(). */
 
-        pBufferOut      += framesRead*pWav->channels;
+        /* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */
+        samplesRead = framesRead * pWav->channels;
+        if ((samplesRead * bytesPerSample) > sizeof(sampleData)) {
+            DRWAV_ASSERT(DRWAV_FALSE);  /* This should never happen with a valid file. */
+            break;
+        }
+
+        drwav__ieee_to_s16(pBufferOut, sampleData, (size_t)samplesRead, bytesPerSample);    /* Safe cast. */
+
+        pBufferOut      += samplesRead;
         framesToRead    -= framesRead;
         totalFramesRead += framesRead;
     }
 
     return totalFramesRead;
 }
 
-static drwav_uint64 drwav_read_pcm_frames_s16__alaw(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)
+DRWAV_PRIVATE drwav_uint64 drwav_read_pcm_frames_s16__alaw(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)
 {
     drwav_uint64 totalFramesRead;
-    unsigned char sampleData[4096];
+    drwav_uint8 sampleData[4096] = {0};
+    drwav_uint32 bytesPerFrame;
+    drwav_uint32 bytesPerSample;
+    drwav_uint64 samplesRead;
 
-    drwav_uint32 bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
+    if (pBufferOut == NULL) {
+        return drwav_read_pcm_frames(pWav, framesToRead, NULL);
+    }
+
+    bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
     if (bytesPerFrame == 0) {
         return 0;
     }
 
+    bytesPerSample = bytesPerFrame / pWav->channels;
+    if (bytesPerSample == 0 || (bytesPerFrame % pWav->channels) != 0) {
+        return 0;   /* Only byte-aligned formats are supported. */
+    }
+
     totalFramesRead = 0;
-    
+
     while (framesToRead > 0) {
-        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);
+        drwav_uint64 framesToReadThisIteration = drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame);
+        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, framesToReadThisIteration, sampleData);
         if (framesRead == 0) {
             break;
         }
 
-        drwav_alaw_to_s16(pBufferOut, sampleData, (size_t)(framesRead*pWav->channels));
+        DRWAV_ASSERT(framesRead <= framesToReadThisIteration);   /* If this fails it means there's a bug in drwav_read_pcm_frames(). */
 
-        pBufferOut      += framesRead*pWav->channels;
+        /* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */
+        samplesRead = framesRead * pWav->channels;
+        if ((samplesRead * bytesPerSample) > sizeof(sampleData)) {
+            DRWAV_ASSERT(DRWAV_FALSE);  /* This should never happen with a valid file. */
+            break;
+        }
+
+        drwav_alaw_to_s16(pBufferOut, sampleData, (size_t)samplesRead);
+
+        pBufferOut      += samplesRead;
         framesToRead    -= framesRead;
         totalFramesRead += framesRead;
     }
 
     return totalFramesRead;
 }
 
-static drwav_uint64 drwav_read_pcm_frames_s16__mulaw(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)
+DRWAV_PRIVATE drwav_uint64 drwav_read_pcm_frames_s16__mulaw(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)
 {
     drwav_uint64 totalFramesRead;
-    unsigned char sampleData[4096];
+    drwav_uint8 sampleData[4096] = {0};
+    drwav_uint32 bytesPerFrame;
+    drwav_uint32 bytesPerSample;
+    drwav_uint64 samplesRead;
+
+    if (pBufferOut == NULL) {
+        return drwav_read_pcm_frames(pWav, framesToRead, NULL);
+    }
 
-    drwav_uint32 bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
+    bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
     if (bytesPerFrame == 0) {
         return 0;
     }
 
+    bytesPerSample = bytesPerFrame / pWav->channels;
+    if (bytesPerSample == 0 || (bytesPerFrame % pWav->channels) != 0) {
+        return 0;   /* Only byte-aligned formats are supported. */
+    }
+
     totalFramesRead = 0;
 
     while (framesToRead > 0) {
-        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);
+        drwav_uint64 framesToReadThisIteration = drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame);
+        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, framesToReadThisIteration, sampleData);
         if (framesRead == 0) {
             break;
         }
 
-        drwav_mulaw_to_s16(pBufferOut, sampleData, (size_t)(framesRead*pWav->channels));
+        DRWAV_ASSERT(framesRead <= framesToReadThisIteration);   /* If this fails it means there's a bug in drwav_read_pcm_frames(). */
 
-        pBufferOut      += framesRead*pWav->channels;
+        /* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */
+        samplesRead = framesRead * pWav->channels;
+        if ((samplesRead * bytesPerSample) > sizeof(sampleData)) {
+            DRWAV_ASSERT(DRWAV_FALSE);  /* This should never happen with a valid file. */
+            break;
+        }
+
+        drwav_mulaw_to_s16(pBufferOut, sampleData, (size_t)samplesRead);
+
+        pBufferOut      += samplesRead;
         framesToRead    -= framesRead;
         totalFramesRead += framesRead;
     }
 
     return totalFramesRead;
 }
 
 DRWAV_API drwav_uint64 drwav_read_pcm_frames_s16(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)
 {
-    if (pWav == NULL || framesToRead == 0 || pBufferOut == NULL) {
+    if (pWav == NULL || framesToRead == 0) {
         return 0;
     }
 
+    if (pBufferOut == NULL) {
+        return drwav_read_pcm_frames(pWav, framesToRead, NULL);
+    }
+
     /* Don't try to read more samples than can potentially fit in the output buffer. */
     if (framesToRead * pWav->channels * sizeof(drwav_int16) > DRWAV_SIZE_MAX) {
         framesToRead = DRWAV_SIZE_MAX / sizeof(drwav_int16) / pWav->channels;
     }
 
     if (pWav->translatedFormatTag == DR_WAVE_FORMAT_PCM) {
         return drwav_read_pcm_frames_s16__pcm(pWav, framesToRead, pBufferOut);
@@ -4213,25 +6440,25 @@
 
     return 0;
 }
 
 DRWAV_API drwav_uint64 drwav_read_pcm_frames_s16le(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)
 {
     drwav_uint64 framesRead = drwav_read_pcm_frames_s16(pWav, framesToRead, pBufferOut);
-    if (!drwav__is_little_endian()) {
+    if (pBufferOut != NULL && drwav__is_little_endian() == DRWAV_FALSE) {
         drwav__bswap_samples_s16(pBufferOut, framesRead*pWav->channels);
     }
 
     return framesRead;
 }
 
 DRWAV_API drwav_uint64 drwav_read_pcm_frames_s16be(drwav* pWav, drwav_uint64 framesToRead, drwav_int16* pBufferOut)
 {
     drwav_uint64 framesRead = drwav_read_pcm_frames_s16(pWav, framesToRead, pBufferOut);
-    if (drwav__is_little_endian()) {
+    if (pBufferOut != NULL && drwav__is_little_endian() == DRWAV_TRUE) {
         drwav__bswap_samples_s16(pBufferOut, framesRead*pWav->channels);
     }
 
     return framesRead;
 }
 
 
@@ -4248,15 +6475,15 @@
 }
 
 DRWAV_API void drwav_s24_to_s16(drwav_int16* pOut, const drwav_uint8* pIn, size_t sampleCount)
 {
     int r;
     size_t i;
     for (i = 0; i < sampleCount; ++i) {
-        int x = ((int)(((unsigned int)(((const unsigned char*)pIn)[i*3+0]) << 8) | ((unsigned int)(((const unsigned char*)pIn)[i*3+1]) << 16) | ((unsigned int)(((const unsigned char*)pIn)[i*3+2])) << 24)) >> 8;
+        int x = ((int)(((unsigned int)(((const drwav_uint8*)pIn)[i*3+0]) << 8) | ((unsigned int)(((const drwav_uint8*)pIn)[i*3+1]) << 16) | ((unsigned int)(((const drwav_uint8*)pIn)[i*3+2])) << 24)) >> 8;
         r = x >> 8;
         pOut[i] = (short)r;
     }
 }
 
 DRWAV_API void drwav_s32_to_s16(drwav_int16* pOut, const drwav_int32* pIn, size_t sampleCount)
 {
@@ -4313,15 +6540,15 @@
     for (i = 0; i < sampleCount; ++i) {
         pOut[i] = drwav__mulaw_to_s16(pIn[i]);
     }
 }
 
 
 
-static void drwav__pcm_to_f32(float* pOut, const unsigned char* pIn, size_t sampleCount, unsigned int bytesPerSample)
+DRWAV_PRIVATE void drwav__pcm_to_f32(float* pOut, const drwav_uint8* pIn, size_t sampleCount, unsigned int bytesPerSample)
 {
     unsigned int i;
 
     /* Special case for 8-bit sample data because it's treated as unsigned. */
     if (bytesPerSample == 1) {
         drwav_u8_to_f32(pOut, pIn, sampleCount);
         return;
@@ -4362,15 +6589,15 @@
         }
 
         pIn += j;
         *pOut++ = (float)((drwav_int64)sample / 9223372036854775807.0);
     }
 }
 
-static void drwav__ieee_to_f32(float* pOut, const unsigned char* pIn, size_t sampleCount, unsigned int bytesPerSample)
+DRWAV_PRIVATE void drwav__ieee_to_f32(float* pOut, const drwav_uint8* pIn, size_t sampleCount, unsigned int bytesPerSample)
 {
     if (bytesPerSample == 4) {
         unsigned int i;
         for (i = 0; i < sampleCount; ++i) {
             *pOut++ = ((const float*)pIn)[i];
         }
         return;
@@ -4381,231 +6608,285 @@
         /* Only supporting 32- and 64-bit float. Output silence in all other cases. Contributions welcome for 16-bit float. */
         DRWAV_ZERO_MEMORY(pOut, sampleCount * sizeof(*pOut));
         return;
     }
 }
 
 
-static drwav_uint64 drwav_read_pcm_frames_f32__pcm(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)
+DRWAV_PRIVATE drwav_uint64 drwav_read_pcm_frames_f32__pcm(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)
 {
     drwav_uint64 totalFramesRead;
-    unsigned char sampleData[4096];
+    drwav_uint8 sampleData[4096] = {0};
+    drwav_uint32 bytesPerFrame;
+    drwav_uint32 bytesPerSample;
+    drwav_uint64 samplesRead;
 
-    drwav_uint32 bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
+    bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
     if (bytesPerFrame == 0) {
         return 0;
     }
 
+    bytesPerSample = bytesPerFrame / pWav->channels;
+    if (bytesPerSample == 0 || (bytesPerFrame % pWav->channels) != 0) {
+        return 0;   /* Only byte-aligned formats are supported. */
+    }
+
     totalFramesRead = 0;
 
     while (framesToRead > 0) {
-        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);
+        drwav_uint64 framesToReadThisIteration = drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame);
+        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, framesToReadThisIteration, sampleData);
         if (framesRead == 0) {
             break;
         }
 
-        drwav__pcm_to_f32(pBufferOut, sampleData, (size_t)framesRead*pWav->channels, bytesPerFrame/pWav->channels);
-
-        pBufferOut      += framesRead*pWav->channels;
-        framesToRead    -= framesRead;
-        totalFramesRead += framesRead;
-    }
+        DRWAV_ASSERT(framesRead <= framesToReadThisIteration);   /* If this fails it means there's a bug in drwav_read_pcm_frames(). */
 
-    return totalFramesRead;
-}
-
-static drwav_uint64 drwav_read_pcm_frames_f32__msadpcm(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)
-{
-    /*
-    We're just going to borrow the implementation from the drwav_read_s16() since ADPCM is a little bit more complicated than other formats and I don't
-    want to duplicate that code.
-    */
-    drwav_uint64 totalFramesRead = 0;
-    drwav_int16 samples16[2048];
-    while (framesToRead > 0) {
-        drwav_uint64 framesRead = drwav_read_pcm_frames_s16(pWav, drwav_min(framesToRead, drwav_countof(samples16)/pWav->channels), samples16);
-        if (framesRead == 0) {
+        /* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */
+        samplesRead = framesRead * pWav->channels;
+        if ((samplesRead * bytesPerSample) > sizeof(sampleData)) {
+            DRWAV_ASSERT(DRWAV_FALSE);  /* This should never happen with a valid file. */
             break;
         }
 
-        drwav_s16_to_f32(pBufferOut, samples16, (size_t)(framesRead*pWav->channels));   /* <-- Safe cast because we're clamping to 2048. */
+        drwav__pcm_to_f32(pBufferOut, sampleData, (size_t)samplesRead, bytesPerSample);
 
-        pBufferOut      += framesRead*pWav->channels;
+        pBufferOut      += samplesRead;
         framesToRead    -= framesRead;
         totalFramesRead += framesRead;
     }
 
     return totalFramesRead;
 }
 
-static drwav_uint64 drwav_read_pcm_frames_f32__ima(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)
+DRWAV_PRIVATE drwav_uint64 drwav_read_pcm_frames_f32__msadpcm_ima(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)
 {
     /*
-    We're just going to borrow the implementation from the drwav_read_s16() since IMA-ADPCM is a little bit more complicated than other formats and I don't
+    We're just going to borrow the implementation from the drwav_read_s16() since ADPCM is a little bit more complicated than other formats and I don't
     want to duplicate that code.
     */
-    drwav_uint64 totalFramesRead = 0;
+    drwav_uint64 totalFramesRead;
     drwav_int16 samples16[2048];
+
+    totalFramesRead = 0;
+
     while (framesToRead > 0) {
-        drwav_uint64 framesRead = drwav_read_pcm_frames_s16(pWav, drwav_min(framesToRead, drwav_countof(samples16)/pWav->channels), samples16);
+        drwav_uint64 framesToReadThisIteration = drwav_min(framesToRead, drwav_countof(samples16)/pWav->channels);
+        drwav_uint64 framesRead = drwav_read_pcm_frames_s16(pWav, framesToReadThisIteration, samples16);
         if (framesRead == 0) {
             break;
         }
 
+        DRWAV_ASSERT(framesRead <= framesToReadThisIteration);   /* If this fails it means there's a bug in drwav_read_pcm_frames(). */
+
         drwav_s16_to_f32(pBufferOut, samples16, (size_t)(framesRead*pWav->channels));   /* <-- Safe cast because we're clamping to 2048. */
 
         pBufferOut      += framesRead*pWav->channels;
         framesToRead    -= framesRead;
         totalFramesRead += framesRead;
     }
 
     return totalFramesRead;
 }
 
-static drwav_uint64 drwav_read_pcm_frames_f32__ieee(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)
+DRWAV_PRIVATE drwav_uint64 drwav_read_pcm_frames_f32__ieee(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)
 {
     drwav_uint64 totalFramesRead;
-    unsigned char sampleData[4096];
+    drwav_uint8 sampleData[4096] = {0};
     drwav_uint32 bytesPerFrame;
+    drwav_uint32 bytesPerSample;
+    drwav_uint64 samplesRead;
 
     /* Fast path. */
     if (pWav->translatedFormatTag == DR_WAVE_FORMAT_IEEE_FLOAT && pWav->bitsPerSample == 32) {
         return drwav_read_pcm_frames(pWav, framesToRead, pBufferOut);
     }
-    
+
     bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
     if (bytesPerFrame == 0) {
         return 0;
     }
 
+    bytesPerSample = bytesPerFrame / pWav->channels;
+    if (bytesPerSample == 0 || (bytesPerFrame % pWav->channels) != 0) {
+        return 0;   /* Only byte-aligned formats are supported. */
+    }
+
     totalFramesRead = 0;
 
     while (framesToRead > 0) {
-        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);
+        drwav_uint64 framesToReadThisIteration = drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame);
+        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, framesToReadThisIteration, sampleData);
         if (framesRead == 0) {
             break;
         }
 
-        drwav__ieee_to_f32(pBufferOut, sampleData, (size_t)(framesRead*pWav->channels), bytesPerFrame/pWav->channels);
+        DRWAV_ASSERT(framesRead <= framesToReadThisIteration);   /* If this fails it means there's a bug in drwav_read_pcm_frames(). */
 
-        pBufferOut      += framesRead*pWav->channels;
+        /* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */
+        samplesRead = framesRead * pWav->channels;
+        if ((samplesRead * bytesPerSample) > sizeof(sampleData)) {
+            DRWAV_ASSERT(DRWAV_FALSE);  /* This should never happen with a valid file. */
+            break;
+        }
+
+        drwav__ieee_to_f32(pBufferOut, sampleData, (size_t)samplesRead, bytesPerSample);
+
+        pBufferOut      += samplesRead;
         framesToRead    -= framesRead;
         totalFramesRead += framesRead;
     }
 
     return totalFramesRead;
 }
 
-static drwav_uint64 drwav_read_pcm_frames_f32__alaw(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)
+DRWAV_PRIVATE drwav_uint64 drwav_read_pcm_frames_f32__alaw(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)
 {
     drwav_uint64 totalFramesRead;
-    unsigned char sampleData[4096];
-    drwav_uint32 bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
+    drwav_uint8 sampleData[4096] = {0};
+    drwav_uint32 bytesPerFrame;
+    drwav_uint32 bytesPerSample;
+    drwav_uint64 samplesRead;
+
+    bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
     if (bytesPerFrame == 0) {
         return 0;
     }
 
+    bytesPerSample = bytesPerFrame / pWav->channels;
+    if (bytesPerSample == 0 || (bytesPerFrame % pWav->channels) != 0) {
+        return 0;   /* Only byte-aligned formats are supported. */
+    }
+
     totalFramesRead = 0;
 
     while (framesToRead > 0) {
-        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);
+        drwav_uint64 framesToReadThisIteration = drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame);
+        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, framesToReadThisIteration, sampleData);
         if (framesRead == 0) {
             break;
         }
 
-        drwav_alaw_to_f32(pBufferOut, sampleData, (size_t)(framesRead*pWav->channels));
+        DRWAV_ASSERT(framesRead <= framesToReadThisIteration);   /* If this fails it means there's a bug in drwav_read_pcm_frames(). */
 
-        pBufferOut      += framesRead*pWav->channels;
+        /* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */
+        samplesRead = framesRead * pWav->channels;
+        if ((samplesRead * bytesPerSample) > sizeof(sampleData)) {
+            DRWAV_ASSERT(DRWAV_FALSE);  /* This should never happen with a valid file. */
+            break;
+        }
+
+        drwav_alaw_to_f32(pBufferOut, sampleData, (size_t)samplesRead);
+
+        pBufferOut      += samplesRead;
         framesToRead    -= framesRead;
         totalFramesRead += framesRead;
     }
 
     return totalFramesRead;
 }
 
-static drwav_uint64 drwav_read_pcm_frames_f32__mulaw(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)
+DRWAV_PRIVATE drwav_uint64 drwav_read_pcm_frames_f32__mulaw(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)
 {
     drwav_uint64 totalFramesRead;
-    unsigned char sampleData[4096];
+    drwav_uint8 sampleData[4096] = {0};
+    drwav_uint32 bytesPerFrame;
+    drwav_uint32 bytesPerSample;
+    drwav_uint64 samplesRead;
 
-    drwav_uint32 bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
+    bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
     if (bytesPerFrame == 0) {
         return 0;
     }
 
+    bytesPerSample = bytesPerFrame / pWav->channels;
+    if (bytesPerSample == 0 || (bytesPerFrame % pWav->channels) != 0) {
+        return 0;   /* Only byte-aligned formats are supported. */
+    }
+
     totalFramesRead = 0;
 
     while (framesToRead > 0) {
-        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);
+        drwav_uint64 framesToReadThisIteration = drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame);
+        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, framesToReadThisIteration, sampleData);
         if (framesRead == 0) {
             break;
         }
 
-        drwav_mulaw_to_f32(pBufferOut, sampleData, (size_t)(framesRead*pWav->channels));
+        DRWAV_ASSERT(framesRead <= framesToReadThisIteration);   /* If this fails it means there's a bug in drwav_read_pcm_frames(). */
 
-        pBufferOut      += framesRead*pWav->channels;
+        /* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */
+        samplesRead = framesRead * pWav->channels;
+        if ((samplesRead * bytesPerSample) > sizeof(sampleData)) {
+            DRWAV_ASSERT(DRWAV_FALSE);  /* This should never happen with a valid file. */
+            break;
+        }
+
+        drwav_mulaw_to_f32(pBufferOut, sampleData, (size_t)samplesRead);
+
+        pBufferOut      += samplesRead;
         framesToRead    -= framesRead;
         totalFramesRead += framesRead;
     }
 
     return totalFramesRead;
 }
 
 DRWAV_API drwav_uint64 drwav_read_pcm_frames_f32(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)
 {
-    if (pWav == NULL || framesToRead == 0 || pBufferOut == NULL) {
+    if (pWav == NULL || framesToRead == 0) {
         return 0;
     }
 
+    if (pBufferOut == NULL) {
+        return drwav_read_pcm_frames(pWav, framesToRead, NULL);
+    }
+
     /* Don't try to read more samples than can potentially fit in the output buffer. */
     if (framesToRead * pWav->channels * sizeof(float) > DRWAV_SIZE_MAX) {
         framesToRead = DRWAV_SIZE_MAX / sizeof(float) / pWav->channels;
     }
 
     if (pWav->translatedFormatTag == DR_WAVE_FORMAT_PCM) {
         return drwav_read_pcm_frames_f32__pcm(pWav, framesToRead, pBufferOut);
     }
 
-    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ADPCM) {
-        return drwav_read_pcm_frames_f32__msadpcm(pWav, framesToRead, pBufferOut);
+    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ADPCM || pWav->translatedFormatTag == DR_WAVE_FORMAT_DVI_ADPCM) {
+        return drwav_read_pcm_frames_f32__msadpcm_ima(pWav, framesToRead, pBufferOut);
     }
 
     if (pWav->translatedFormatTag == DR_WAVE_FORMAT_IEEE_FLOAT) {
         return drwav_read_pcm_frames_f32__ieee(pWav, framesToRead, pBufferOut);
     }
 
     if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ALAW) {
         return drwav_read_pcm_frames_f32__alaw(pWav, framesToRead, pBufferOut);
     }
 
     if (pWav->translatedFormatTag == DR_WAVE_FORMAT_MULAW) {
         return drwav_read_pcm_frames_f32__mulaw(pWav, framesToRead, pBufferOut);
     }
 
-    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_DVI_ADPCM) {
-        return drwav_read_pcm_frames_f32__ima(pWav, framesToRead, pBufferOut);
-    }
-
     return 0;
 }
 
 DRWAV_API drwav_uint64 drwav_read_pcm_frames_f32le(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)
 {
     drwav_uint64 framesRead = drwav_read_pcm_frames_f32(pWav, framesToRead, pBufferOut);
-    if (!drwav__is_little_endian()) {
+    if (pBufferOut != NULL && drwav__is_little_endian() == DRWAV_FALSE) {
         drwav__bswap_samples_f32(pBufferOut, framesRead*pWav->channels);
     }
 
     return framesRead;
 }
 
 DRWAV_API drwav_uint64 drwav_read_pcm_frames_f32be(drwav* pWav, drwav_uint64 framesToRead, float* pBufferOut)
 {
     drwav_uint64 framesRead = drwav_read_pcm_frames_f32(pWav, framesToRead, pBufferOut);
-    if (drwav__is_little_endian()) {
+    if (pBufferOut != NULL && drwav__is_little_endian() == DRWAV_TRUE) {
         drwav__bswap_samples_f32(pBufferOut, framesRead*pWav->channels);
     }
 
     return framesRead;
 }
 
 
@@ -4656,15 +6937,20 @@
     size_t i;
 
     if (pOut == NULL || pIn == NULL) {
         return;
     }
 
     for (i = 0; i < sampleCount; ++i) {
-        double x = (double)(((drwav_int32)(((drwav_uint32)(pIn[i*3+0]) << 8) | ((drwav_uint32)(pIn[i*3+1]) << 16) | ((drwav_uint32)(pIn[i*3+2])) << 24)) >> 8);
+        double x;
+        drwav_uint32 a = ((drwav_uint32)(pIn[i*3+0]) <<  8);
+        drwav_uint32 b = ((drwav_uint32)(pIn[i*3+1]) << 16);
+        drwav_uint32 c = ((drwav_uint32)(pIn[i*3+2]) << 24);
+
+        x = (double)((drwav_int32)(a | b | c) >> 8);
         *pOut++ = (float)(x * 0.00000011920928955078125);
     }
 }
 
 DRWAV_API void drwav_s32_to_f32(float* pOut, const drwav_int32* pIn, size_t sampleCount)
 {
     size_t i;
@@ -4714,15 +7000,15 @@
     for (i = 0; i < sampleCount; ++i) {
         *pOut++ = drwav__mulaw_to_s16(pIn[i]) / 32768.0f;
     }
 }
 
 
 
-static void drwav__pcm_to_s32(drwav_int32* pOut, const unsigned char* pIn, size_t totalSampleCount, unsigned int bytesPerSample)
+DRWAV_PRIVATE void drwav__pcm_to_s32(drwav_int32* pOut, const drwav_uint8* pIn, size_t totalSampleCount, unsigned int bytesPerSample)
 {
     unsigned int i;
 
     /* Special case for 8-bit sample data because it's treated as unsigned. */
     if (bytesPerSample == 1) {
         drwav_u8_to_s32(pOut, pIn, totalSampleCount);
         return;
@@ -4765,15 +7051,15 @@
         }
 
         pIn += j;
         *pOut++ = (drwav_int32)((drwav_int64)sample >> 32);
     }
 }
 
-static void drwav__ieee_to_s32(drwav_int32* pOut, const unsigned char* pIn, size_t totalSampleCount, unsigned int bytesPerSample)
+DRWAV_PRIVATE void drwav__ieee_to_s32(drwav_int32* pOut, const drwav_uint8* pIn, size_t totalSampleCount, unsigned int bytesPerSample)
 {
     if (bytesPerSample == 4) {
         drwav_f32_to_s32(pOut, (const float*)pIn, totalSampleCount);
         return;
     } else if (bytesPerSample == 8) {
         drwav_f64_to_s32(pOut, (const double*)pIn, totalSampleCount);
         return;
@@ -4781,233 +7067,283 @@
         /* Only supporting 32- and 64-bit float. Output silence in all other cases. Contributions welcome for 16-bit float. */
         DRWAV_ZERO_MEMORY(pOut, totalSampleCount * sizeof(*pOut));
         return;
     }
 }
 
 
-static drwav_uint64 drwav_read_pcm_frames_s32__pcm(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)
+DRWAV_PRIVATE drwav_uint64 drwav_read_pcm_frames_s32__pcm(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)
 {
     drwav_uint64 totalFramesRead;
-    unsigned char sampleData[4096];
+    drwav_uint8 sampleData[4096] = {0};
     drwav_uint32 bytesPerFrame;
+    drwav_uint32 bytesPerSample;
+    drwav_uint64 samplesRead;
 
     /* Fast path. */
     if (pWav->translatedFormatTag == DR_WAVE_FORMAT_PCM && pWav->bitsPerSample == 32) {
         return drwav_read_pcm_frames(pWav, framesToRead, pBufferOut);
     }
-    
+
     bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
     if (bytesPerFrame == 0) {
         return 0;
     }
 
+    bytesPerSample = bytesPerFrame / pWav->channels;
+    if (bytesPerSample == 0 || (bytesPerFrame % pWav->channels) != 0) {
+        return 0;   /* Only byte-aligned formats are supported. */
+    }
+
     totalFramesRead = 0;
 
     while (framesToRead > 0) {
-        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);
+        drwav_uint64 framesToReadThisIteration = drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame);
+        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, framesToReadThisIteration, sampleData);
         if (framesRead == 0) {
             break;
         }
 
-        drwav__pcm_to_s32(pBufferOut, sampleData, (size_t)(framesRead*pWav->channels), bytesPerFrame/pWav->channels);
+        DRWAV_ASSERT(framesRead <= framesToReadThisIteration);   /* If this fails it means there's a bug in drwav_read_pcm_frames(). */
 
-        pBufferOut      += framesRead*pWav->channels;
-        framesToRead    -= framesRead;
-        totalFramesRead += framesRead;
-    }
-
-    return totalFramesRead;
-}
-
-static drwav_uint64 drwav_read_pcm_frames_s32__msadpcm(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)
-{
-    /*
-    We're just going to borrow the implementation from the drwav_read_s16() since ADPCM is a little bit more complicated than other formats and I don't
-    want to duplicate that code.
-    */
-    drwav_uint64 totalFramesRead = 0;
-    drwav_int16 samples16[2048];
-    while (framesToRead > 0) {
-        drwav_uint64 framesRead = drwav_read_pcm_frames_s16(pWav, drwav_min(framesToRead, drwav_countof(samples16)/pWav->channels), samples16);
-        if (framesRead == 0) {
+        /* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */
+        samplesRead = framesRead * pWav->channels;
+        if ((samplesRead * bytesPerSample) > sizeof(sampleData)) {
+            DRWAV_ASSERT(DRWAV_FALSE);  /* This should never happen with a valid file. */
             break;
         }
 
-        drwav_s16_to_s32(pBufferOut, samples16, (size_t)(framesRead*pWav->channels));   /* <-- Safe cast because we're clamping to 2048. */
+        drwav__pcm_to_s32(pBufferOut, sampleData, (size_t)samplesRead, bytesPerSample);
 
-        pBufferOut      += framesRead*pWav->channels;
+        pBufferOut      += samplesRead;
         framesToRead    -= framesRead;
         totalFramesRead += framesRead;
     }
 
     return totalFramesRead;
 }
 
-static drwav_uint64 drwav_read_pcm_frames_s32__ima(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)
+DRWAV_PRIVATE drwav_uint64 drwav_read_pcm_frames_s32__msadpcm_ima(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)
 {
     /*
-    We're just going to borrow the implementation from the drwav_read_s16() since IMA-ADPCM is a little bit more complicated than other formats and I don't
+    We're just going to borrow the implementation from the drwav_read_s16() since ADPCM is a little bit more complicated than other formats and I don't
     want to duplicate that code.
     */
     drwav_uint64 totalFramesRead = 0;
     drwav_int16 samples16[2048];
+
     while (framesToRead > 0) {
-        drwav_uint64 framesRead = drwav_read_pcm_frames_s16(pWav, drwav_min(framesToRead, drwav_countof(samples16)/pWav->channels), samples16);
+        drwav_uint64 framesToReadThisIteration = drwav_min(framesToRead, drwav_countof(samples16)/pWav->channels);
+        drwav_uint64 framesRead = drwav_read_pcm_frames_s16(pWav, framesToReadThisIteration, samples16);
         if (framesRead == 0) {
             break;
         }
 
+        DRWAV_ASSERT(framesRead <= framesToReadThisIteration);   /* If this fails it means there's a bug in drwav_read_pcm_frames(). */
+
         drwav_s16_to_s32(pBufferOut, samples16, (size_t)(framesRead*pWav->channels));   /* <-- Safe cast because we're clamping to 2048. */
 
         pBufferOut      += framesRead*pWav->channels;
         framesToRead    -= framesRead;
         totalFramesRead += framesRead;
     }
 
     return totalFramesRead;
 }
 
-static drwav_uint64 drwav_read_pcm_frames_s32__ieee(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)
+DRWAV_PRIVATE drwav_uint64 drwav_read_pcm_frames_s32__ieee(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)
 {
     drwav_uint64 totalFramesRead;
-    unsigned char sampleData[4096];
+    drwav_uint8 sampleData[4096] = {0};
+    drwav_uint32 bytesPerFrame;
+    drwav_uint32 bytesPerSample;
+    drwav_uint64 samplesRead;
 
-    drwav_uint32 bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
+    bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
     if (bytesPerFrame == 0) {
         return 0;
     }
 
+    bytesPerSample = bytesPerFrame / pWav->channels;
+    if (bytesPerSample == 0 || (bytesPerFrame % pWav->channels) != 0) {
+        return 0;   /* Only byte-aligned formats are supported. */
+    }
+
     totalFramesRead = 0;
 
     while (framesToRead > 0) {
-        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);
+        drwav_uint64 framesToReadThisIteration = drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame);
+        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, framesToReadThisIteration, sampleData);
         if (framesRead == 0) {
             break;
         }
 
-        drwav__ieee_to_s32(pBufferOut, sampleData, (size_t)(framesRead*pWav->channels), bytesPerFrame/pWav->channels);
+        DRWAV_ASSERT(framesRead <= framesToReadThisIteration);   /* If this fails it means there's a bug in drwav_read_pcm_frames(). */
 
-        pBufferOut      += framesRead*pWav->channels;
+        /* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */
+        samplesRead = framesRead * pWav->channels;
+        if ((samplesRead * bytesPerSample) > sizeof(sampleData)) {
+            DRWAV_ASSERT(DRWAV_FALSE);  /* This should never happen with a valid file. */
+            break;
+        }
+
+        drwav__ieee_to_s32(pBufferOut, sampleData, (size_t)samplesRead, bytesPerSample);
+
+        pBufferOut      += samplesRead;
         framesToRead    -= framesRead;
         totalFramesRead += framesRead;
     }
 
     return totalFramesRead;
 }
 
-static drwav_uint64 drwav_read_pcm_frames_s32__alaw(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)
+DRWAV_PRIVATE drwav_uint64 drwav_read_pcm_frames_s32__alaw(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)
 {
     drwav_uint64 totalFramesRead;
-    unsigned char sampleData[4096];
+    drwav_uint8 sampleData[4096] = {0};
+    drwav_uint32 bytesPerFrame;
+    drwav_uint32 bytesPerSample;
+    drwav_uint64 samplesRead;
 
-    drwav_uint32 bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
+    bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
     if (bytesPerFrame == 0) {
         return 0;
     }
 
+    bytesPerSample = bytesPerFrame / pWav->channels;
+    if (bytesPerSample == 0 || (bytesPerFrame % pWav->channels) != 0) {
+        return 0;   /* Only byte-aligned formats are supported. */
+    }
+
     totalFramesRead = 0;
 
     while (framesToRead > 0) {
-        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);
+        drwav_uint64 framesToReadThisIteration = drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame);
+        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, framesToReadThisIteration, sampleData);
         if (framesRead == 0) {
             break;
         }
 
-        drwav_alaw_to_s32(pBufferOut, sampleData, (size_t)(framesRead*pWav->channels));
+        DRWAV_ASSERT(framesRead <= framesToReadThisIteration);   /* If this fails it means there's a bug in drwav_read_pcm_frames(). */
 
-        pBufferOut      += framesRead*pWav->channels;
+        /* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */
+        samplesRead = framesRead * pWav->channels;
+        if ((samplesRead * bytesPerSample) > sizeof(sampleData)) {
+            DRWAV_ASSERT(DRWAV_FALSE);  /* This should never happen with a valid file. */
+            break;
+        }
+
+        drwav_alaw_to_s32(pBufferOut, sampleData, (size_t)samplesRead);
+
+        pBufferOut      += samplesRead;
         framesToRead    -= framesRead;
         totalFramesRead += framesRead;
     }
 
     return totalFramesRead;
 }
 
-static drwav_uint64 drwav_read_pcm_frames_s32__mulaw(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)
+DRWAV_PRIVATE drwav_uint64 drwav_read_pcm_frames_s32__mulaw(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)
 {
     drwav_uint64 totalFramesRead;
-    unsigned char sampleData[4096];
+    drwav_uint8 sampleData[4096] = {0};
+    drwav_uint32 bytesPerFrame;
+    drwav_uint32 bytesPerSample;
+    drwav_uint64 samplesRead;
 
-    drwav_uint32 bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
+    bytesPerFrame = drwav_get_bytes_per_pcm_frame(pWav);
     if (bytesPerFrame == 0) {
         return 0;
     }
 
+    bytesPerSample = bytesPerFrame / pWav->channels;
+    if (bytesPerSample == 0 || (bytesPerFrame % pWav->channels) != 0) {
+        return 0;   /* Only byte-aligned formats are supported. */
+    }
+
     totalFramesRead = 0;
 
     while (framesToRead > 0) {
-        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame), sampleData);
+        drwav_uint64 framesToReadThisIteration = drwav_min(framesToRead, sizeof(sampleData)/bytesPerFrame);
+        drwav_uint64 framesRead = drwav_read_pcm_frames(pWav, framesToReadThisIteration, sampleData);
         if (framesRead == 0) {
             break;
         }
 
-        drwav_mulaw_to_s32(pBufferOut, sampleData, (size_t)(framesRead*pWav->channels));
+        DRWAV_ASSERT(framesRead <= framesToReadThisIteration);   /* If this fails it means there's a bug in drwav_read_pcm_frames(). */
 
-        pBufferOut      += framesRead*pWav->channels;
+        /* Validation to ensure we don't read too much from out intermediary buffer. This is to protect from invalid files. */
+        samplesRead = framesRead * pWav->channels;
+        if ((samplesRead * bytesPerSample) > sizeof(sampleData)) {
+            DRWAV_ASSERT(DRWAV_FALSE);  /* This should never happen with a valid file. */
+            break;
+        }
+
+        drwav_mulaw_to_s32(pBufferOut, sampleData, (size_t)samplesRead);
+
+        pBufferOut      += samplesRead;
         framesToRead    -= framesRead;
         totalFramesRead += framesRead;
     }
 
     return totalFramesRead;
 }
 
 DRWAV_API drwav_uint64 drwav_read_pcm_frames_s32(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)
 {
-    if (pWav == NULL || framesToRead == 0 || pBufferOut == NULL) {
+    if (pWav == NULL || framesToRead == 0) {
         return 0;
     }
 
+    if (pBufferOut == NULL) {
+        return drwav_read_pcm_frames(pWav, framesToRead, NULL);
+    }
+
     /* Don't try to read more samples than can potentially fit in the output buffer. */
     if (framesToRead * pWav->channels * sizeof(drwav_int32) > DRWAV_SIZE_MAX) {
         framesToRead = DRWAV_SIZE_MAX / sizeof(drwav_int32) / pWav->channels;
     }
 
-
     if (pWav->translatedFormatTag == DR_WAVE_FORMAT_PCM) {
         return drwav_read_pcm_frames_s32__pcm(pWav, framesToRead, pBufferOut);
     }
 
-    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ADPCM) {
-        return drwav_read_pcm_frames_s32__msadpcm(pWav, framesToRead, pBufferOut);
+    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ADPCM || pWav->translatedFormatTag == DR_WAVE_FORMAT_DVI_ADPCM) {
+        return drwav_read_pcm_frames_s32__msadpcm_ima(pWav, framesToRead, pBufferOut);
     }
 
     if (pWav->translatedFormatTag == DR_WAVE_FORMAT_IEEE_FLOAT) {
         return drwav_read_pcm_frames_s32__ieee(pWav, framesToRead, pBufferOut);
     }
 
     if (pWav->translatedFormatTag == DR_WAVE_FORMAT_ALAW) {
         return drwav_read_pcm_frames_s32__alaw(pWav, framesToRead, pBufferOut);
     }
 
     if (pWav->translatedFormatTag == DR_WAVE_FORMAT_MULAW) {
         return drwav_read_pcm_frames_s32__mulaw(pWav, framesToRead, pBufferOut);
     }
 
-    if (pWav->translatedFormatTag == DR_WAVE_FORMAT_DVI_ADPCM) {
-        return drwav_read_pcm_frames_s32__ima(pWav, framesToRead, pBufferOut);
-    }
-
     return 0;
 }
 
 DRWAV_API drwav_uint64 drwav_read_pcm_frames_s32le(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)
 {
     drwav_uint64 framesRead = drwav_read_pcm_frames_s32(pWav, framesToRead, pBufferOut);
-    if (!drwav__is_little_endian()) {
+    if (pBufferOut != NULL && drwav__is_little_endian() == DRWAV_FALSE) {
         drwav__bswap_samples_s32(pBufferOut, framesRead*pWav->channels);
     }
 
     return framesRead;
 }
 
 DRWAV_API drwav_uint64 drwav_read_pcm_frames_s32be(drwav* pWav, drwav_uint64 framesToRead, drwav_int32* pBufferOut)
 {
     drwav_uint64 framesRead = drwav_read_pcm_frames_s32(pWav, framesToRead, pBufferOut);
-    if (drwav__is_little_endian()) {
+    if (pBufferOut != NULL && drwav__is_little_endian() == DRWAV_TRUE) {
         drwav__bswap_samples_s32(pBufferOut, framesRead*pWav->channels);
     }
 
     return framesRead;
 }
 
 
@@ -5105,15 +7441,15 @@
     for (i= 0; i < sampleCount; ++i) {
         *pOut++ = ((drwav_int32)drwav__mulaw_to_s16(pIn[i])) << 16;
     }
 }
 
 
 
-static drwav_int16* drwav__read_pcm_frames_and_close_s16(drwav* pWav, unsigned int* channels, unsigned int* sampleRate, drwav_uint64* totalFrameCount)
+DRWAV_PRIVATE drwav_int16* drwav__read_pcm_frames_and_close_s16(drwav* pWav, unsigned int* channels, unsigned int* sampleRate, drwav_uint64* totalFrameCount)
 {
     drwav_uint64 sampleDataSize;
     drwav_int16* pSampleData;
     drwav_uint64 framesRead;
 
     DRWAV_ASSERT(pWav != NULL);
 
@@ -5147,15 +7483,15 @@
     if (totalFrameCount) {
         *totalFrameCount = pWav->totalPCMFrameCount;
     }
 
     return pSampleData;
 }
 
-static float* drwav__read_pcm_frames_and_close_f32(drwav* pWav, unsigned int* channels, unsigned int* sampleRate, drwav_uint64* totalFrameCount)
+DRWAV_PRIVATE float* drwav__read_pcm_frames_and_close_f32(drwav* pWav, unsigned int* channels, unsigned int* sampleRate, drwav_uint64* totalFrameCount)
 {
     drwav_uint64 sampleDataSize;
     float* pSampleData;
     drwav_uint64 framesRead;
 
     DRWAV_ASSERT(pWav != NULL);
 
@@ -5189,15 +7525,15 @@
     if (totalFrameCount) {
         *totalFrameCount = pWav->totalPCMFrameCount;
     }
 
     return pSampleData;
 }
 
-static drwav_int32* drwav__read_pcm_frames_and_close_s32(drwav* pWav, unsigned int* channels, unsigned int* sampleRate, drwav_uint64* totalFrameCount)
+DRWAV_PRIVATE drwav_int32* drwav__read_pcm_frames_and_close_s32(drwav* pWav, unsigned int* channels, unsigned int* sampleRate, drwav_uint64* totalFrameCount)
 {
     drwav_uint64 sampleDataSize;
     drwav_int32* pSampleData;
     drwav_uint64 framesRead;
 
     DRWAV_ASSERT(pWav != NULL);
 
@@ -5361,14 +7697,15 @@
         return NULL;
     }
 
     return drwav__read_pcm_frames_and_close_s32(&wav, channelsOut, sampleRateOut, totalFrameCountOut);
 }
 
 
+#ifndef DR_WAV_NO_WCHAR
 DRWAV_API drwav_int16* drwav_open_file_and_read_pcm_frames_s16_w(const wchar_t* filename, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks)
 {
     drwav wav;
 
     if (sampleRateOut) {
         *sampleRateOut = 0;
     }
@@ -5423,15 +7760,16 @@
 
     if (!drwav_init_file_w(&wav, filename, pAllocationCallbacks)) {
         return NULL;
     }
 
     return drwav__read_pcm_frames_and_close_s32(&wav, channelsOut, sampleRateOut, totalFrameCountOut);
 }
-#endif
+#endif /* DR_WAV_NO_WCHAR */
+#endif /* DR_WAV_NO_STDIO */
 
 DRWAV_API drwav_int16* drwav_open_memory_and_read_pcm_frames_s16(const void* data, size_t dataSize, unsigned int* channelsOut, unsigned int* sampleRateOut, drwav_uint64* totalFrameCountOut, const drwav_allocation_callbacks* pAllocationCallbacks)
 {
     drwav wav;
 
     if (channelsOut) {
         *channelsOut = 0;
@@ -5499,245 +7837,201 @@
     if (pAllocationCallbacks != NULL) {
         drwav__free_from_callbacks(p, pAllocationCallbacks);
     } else {
         drwav__free_default(p, NULL);
     }
 }
 
-DRWAV_API drwav_uint16 drwav_bytes_to_u16(const unsigned char* data)
+DRWAV_API drwav_uint16 drwav_bytes_to_u16(const drwav_uint8* data)
 {
-    return drwav__bytes_to_u16(data);
+    return ((drwav_uint16)data[0] << 0) | ((drwav_uint16)data[1] << 8);
 }
 
-DRWAV_API drwav_int16 drwav_bytes_to_s16(const unsigned char* data)
+DRWAV_API drwav_int16 drwav_bytes_to_s16(const drwav_uint8* data)
 {
-    return drwav__bytes_to_s16(data);
+    return (drwav_int16)drwav_bytes_to_u16(data);
 }
 
-DRWAV_API drwav_uint32 drwav_bytes_to_u32(const unsigned char* data)
+DRWAV_API drwav_uint32 drwav_bytes_to_u32(const drwav_uint8* data)
 {
-    return drwav__bytes_to_u32(data);
+    return ((drwav_uint32)data[0] << 0) | ((drwav_uint32)data[1] << 8) | ((drwav_uint32)data[2] << 16) | ((drwav_uint32)data[3] << 24);
 }
 
-DRWAV_API drwav_int32 drwav_bytes_to_s32(const unsigned char* data)
+DRWAV_API float drwav_bytes_to_f32(const drwav_uint8* data)
 {
-    return drwav__bytes_to_s32(data);
+    union {
+        drwav_uint32 u32;
+        float f32;
+    } value;
+
+    value.u32 = drwav_bytes_to_u32(data);
+    return value.f32;
+}
+
+DRWAV_API drwav_int32 drwav_bytes_to_s32(const drwav_uint8* data)
+{
+    return (drwav_int32)drwav_bytes_to_u32(data);
 }
 
-DRWAV_API drwav_uint64 drwav_bytes_to_u64(const unsigned char* data)
+DRWAV_API drwav_uint64 drwav_bytes_to_u64(const drwav_uint8* data)
 {
-    return drwav__bytes_to_u64(data);
+    return
+        ((drwav_uint64)data[0] <<  0) | ((drwav_uint64)data[1] <<  8) | ((drwav_uint64)data[2] << 16) | ((drwav_uint64)data[3] << 24) |
+        ((drwav_uint64)data[4] << 32) | ((drwav_uint64)data[5] << 40) | ((drwav_uint64)data[6] << 48) | ((drwav_uint64)data[7] << 56);
 }
 
-DRWAV_API drwav_int64 drwav_bytes_to_s64(const unsigned char* data)
+DRWAV_API drwav_int64 drwav_bytes_to_s64(const drwav_uint8* data)
 {
-    return drwav__bytes_to_s64(data);
+    return (drwav_int64)drwav_bytes_to_u64(data);
 }
 
 
 DRWAV_API drwav_bool32 drwav_guid_equal(const drwav_uint8 a[16], const drwav_uint8 b[16])
 {
-    return drwav__guid_equal(a, b);
+    int i;
+    for (i = 0; i < 16; i += 1) {
+        if (a[i] != b[i]) {
+            return DRWAV_FALSE;
+        }
+    }
+
+    return DRWAV_TRUE;
 }
 
-DRWAV_API drwav_bool32 drwav_fourcc_equal(const unsigned char* a, const char* b)
+DRWAV_API drwav_bool32 drwav_fourcc_equal(const drwav_uint8* a, const char* b)
 {
-    return drwav__fourcc_equal(a, b);
+    return
+        a[0] == b[0] &&
+        a[1] == b[1] &&
+        a[2] == b[2] &&
+        a[3] == b[3];
 }
 
+#ifdef __MRC__
+/* Undo the pragma at the beginning of this file. */
+#pragma options opt reset
+#endif
+
+#endif  /* dr_wav_c */
 #endif  /* DR_WAV_IMPLEMENTATION */
 
 /*
-RELEASE NOTES - v0.11.0
-=======================
-Version 0.11.0 has breaking API changes.
-
-Improved Client-Defined Memory Allocation
------------------------------------------
-The main change with this release is the addition of a more flexible way of implementing custom memory allocation routines. The
-existing system of DRWAV_MALLOC, DRWAV_REALLOC and DRWAV_FREE are still in place and will be used by default when no custom
-allocation callbacks are specified.
-
-To use the new system, you pass in a pointer to a drwav_allocation_callbacks object to drwav_init() and family, like this:
-
-    void* my_malloc(size_t sz, void* pUserData)
-    {
-        return malloc(sz);
-    }
-    void* my_realloc(void* p, size_t sz, void* pUserData)
-    {
-        return realloc(p, sz);
-    }
-    void my_free(void* p, void* pUserData)
-    {
-        free(p);
-    }
+REVISION HISTORY
+================
+v0.13.7 - 2022-09-17
+  - Fix compilation with DJGPP.
+  - Add support for disabling wchar_t with DR_WAV_NO_WCHAR.
+
+v0.13.6 - 2022-04-10
+  - Fix compilation error on older versions of GCC.
+  - Remove some dependencies on the standard library.
+
+v0.13.5 - 2022-01-26
+  - Fix an error when seeking to the end of the file.
+
+v0.13.4 - 2021-12-08
+  - Fix some static analysis warnings.
+
+v0.13.3 - 2021-11-24
+  - Fix an incorrect assertion when trying to endian swap 1-byte sample formats. This is now a no-op
+    rather than a failed assertion.
+  - Fix a bug with parsing of the bext chunk.
+  - Fix some static analysis warnings.
+
+v0.13.2 - 2021-10-02
+  - Fix a possible buffer overflow when reading from compressed formats.
+
+v0.13.1 - 2021-07-31
+  - Fix platform detection for ARM64.
+
+v0.13.0 - 2021-07-01
+  - Improve support for reading and writing metadata. Use the `_with_metadata()` APIs to initialize
+    a WAV decoder and store the metadata within the `drwav` object. Use the `pMetadata` and
+    `metadataCount` members of the `drwav` object to read the data. The old way of handling metadata
+    via a callback is still usable and valid.
+  - API CHANGE: drwav_target_write_size_bytes() now takes extra parameters for calculating the
+    required write size when writing metadata.
+  - Add drwav_get_cursor_in_pcm_frames()
+  - Add drwav_get_length_in_pcm_frames()
+  - Fix a bug where drwav_read_raw() can call the read callback with a byte count of zero.
+
+v0.12.20 - 2021-06-11
+  - Fix some undefined behavior.
+
+v0.12.19 - 2021-02-21
+  - Fix a warning due to referencing _MSC_VER when it is undefined.
+  - Minor improvements to the management of some internal state concerning the data chunk cursor.
+
+v0.12.18 - 2021-01-31
+  - Clean up some static analysis warnings.
+
+v0.12.17 - 2021-01-17
+  - Minor fix to sample code in documentation.
+  - Correctly qualify a private API as private rather than public.
+  - Code cleanup.
+
+v0.12.16 - 2020-12-02
+  - Fix a bug when trying to read more bytes than can fit in a size_t.
+
+v0.12.15 - 2020-11-21
+  - Fix compilation with OpenWatcom.
+
+v0.12.14 - 2020-11-13
+  - Minor code clean up.
+
+v0.12.13 - 2020-11-01
+  - Improve compiler support for older versions of GCC.
+
+v0.12.12 - 2020-09-28
+  - Add support for RF64.
+  - Fix a bug in writing mode where the size of the RIFF chunk incorrectly includes the header section.
+
+v0.12.11 - 2020-09-08
+  - Fix a compilation error on older compilers.
+
+v0.12.10 - 2020-08-24
+  - Fix a bug when seeking with ADPCM formats.
+
+v0.12.9 - 2020-08-02
+  - Simplify sized types.
+
+v0.12.8 - 2020-07-25
+  - Fix a compilation warning.
+
+v0.12.7 - 2020-07-15
+  - Fix some bugs on big-endian architectures.
+  - Fix an error in s24 to f32 conversion.
+
+v0.12.6 - 2020-06-23
+  - Change drwav_read_*() to allow NULL to be passed in as the output buffer which is equivalent to a forward seek.
+  - Fix a buffer overflow when trying to decode invalid IMA-ADPCM files.
+  - Add include guard for the implementation section.
+
+v0.12.5 - 2020-05-27
+  - Minor documentation fix.
+
+v0.12.4 - 2020-05-16
+  - Replace assert() with DRWAV_ASSERT().
+  - Add compile-time and run-time version querying.
+    - DRWAV_VERSION_MINOR
+    - DRWAV_VERSION_MAJOR
+    - DRWAV_VERSION_REVISION
+    - DRWAV_VERSION_STRING
+    - drwav_version()
+    - drwav_version_string()
 
-    ...
+v0.12.3 - 2020-04-30
+  - Fix compilation errors with VC6.
 
-    drwav_allocation_callbacks allocationCallbacks;
-    allocationCallbacks.pUserData = &myData;
-    allocationCallbacks.onMalloc  = my_malloc;
-    allocationCallbacks.onRealloc = my_realloc;
-    allocationCallbacks.onFree    = my_free;
-    drwav_init_file(&wav, "my_file.wav", &allocationCallbacks);
-
-The advantage of this new system is that it allows you to specify user data which will be passed in to the allocation routines.
-
-Passing in null for the allocation callbacks object will cause dr_wav to use defaults which is the same as DRWAV_MALLOC,
-DRWAV_REALLOC and DRWAV_FREE and the equivalent of how it worked in previous versions.
-
-Every API that opens a drwav object now takes this extra parameter. These include the following:
-
-    drwav_init()
-    drwav_init_ex()
-    drwav_init_file()
-    drwav_init_file_ex()
-    drwav_init_file_w()
-    drwav_init_file_w_ex()
-    drwav_init_memory()
-    drwav_init_memory_ex()
-    drwav_init_write()
-    drwav_init_write_sequential()
-    drwav_init_write_sequential_pcm_frames()
-    drwav_init_file_write()
-    drwav_init_file_write_sequential()
-    drwav_init_file_write_sequential_pcm_frames()
-    drwav_init_file_write_w()
-    drwav_init_file_write_sequential_w()
-    drwav_init_file_write_sequential_pcm_frames_w()
-    drwav_init_memory_write()
-    drwav_init_memory_write_sequential()
-    drwav_init_memory_write_sequential_pcm_frames()
-    drwav_open_and_read_pcm_frames_s16()
-    drwav_open_and_read_pcm_frames_f32()
-    drwav_open_and_read_pcm_frames_s32()
-    drwav_open_file_and_read_pcm_frames_s16()
-    drwav_open_file_and_read_pcm_frames_f32()
-    drwav_open_file_and_read_pcm_frames_s32()
-    drwav_open_file_and_read_pcm_frames_s16_w()
-    drwav_open_file_and_read_pcm_frames_f32_w()
-    drwav_open_file_and_read_pcm_frames_s32_w()
-    drwav_open_memory_and_read_pcm_frames_s16()
-    drwav_open_memory_and_read_pcm_frames_f32()
-    drwav_open_memory_and_read_pcm_frames_s32()
-
-Endian Improvements
--------------------
-Previously, the following APIs returned little-endian audio data. These now return native-endian data. This improves compatibility
-on big-endian architectures.
-
-    drwav_read_pcm_frames()
-    drwav_read_pcm_frames_s16()
-    drwav_read_pcm_frames_s32()
-    drwav_read_pcm_frames_f32()
-    drwav_open_and_read_pcm_frames_s16()
-    drwav_open_and_read_pcm_frames_s32()
-    drwav_open_and_read_pcm_frames_f32()
-    drwav_open_file_and_read_pcm_frames_s16()
-    drwav_open_file_and_read_pcm_frames_s32()
-    drwav_open_file_and_read_pcm_frames_f32()
-    drwav_open_file_and_read_pcm_frames_s16_w()
-    drwav_open_file_and_read_pcm_frames_s32_w()
-    drwav_open_file_and_read_pcm_frames_f32_w()
-    drwav_open_memory_and_read_pcm_frames_s16()
-    drwav_open_memory_and_read_pcm_frames_s32()
-    drwav_open_memory_and_read_pcm_frames_f32()
-
-APIs have been added to give you explicit control over whether or not audio data is read or written in big- or little-endian byte
-order:
-
-    drwav_read_pcm_frames_le()
-    drwav_read_pcm_frames_be()
-    drwav_read_pcm_frames_s16le()
-    drwav_read_pcm_frames_s16be()
-    drwav_read_pcm_frames_f32le()
-    drwav_read_pcm_frames_f32be()
-    drwav_read_pcm_frames_s32le()
-    drwav_read_pcm_frames_s32be()
-    drwav_write_pcm_frames_le()
-    drwav_write_pcm_frames_be()
-
-Removed APIs
-------------
-The following APIs were deprecated in version 0.10.0 and have now been removed:
-
-    drwav_open()
-    drwav_open_ex()
-    drwav_open_write()
-    drwav_open_write_sequential()
-    drwav_open_file()
-    drwav_open_file_ex()
-    drwav_open_file_write()
-    drwav_open_file_write_sequential()
-    drwav_open_memory()
-    drwav_open_memory_ex()
-    drwav_open_memory_write()
-    drwav_open_memory_write_sequential()
-    drwav_close()
-
-
-
-RELEASE NOTES - v0.10.0
-=======================
-Version 0.10.0 has breaking API changes. There are no significant bug fixes in this release, so if you are affected you do
-not need to upgrade.
-
-Removed APIs
-------------
-The following APIs were deprecated in version 0.9.0 and have been completely removed in version 0.10.0:
-
-    drwav_read()
-    drwav_read_s16()
-    drwav_read_f32()
-    drwav_read_s32()
-    drwav_seek_to_sample()
-    drwav_write()
-    drwav_open_and_read_s16()
-    drwav_open_and_read_f32()
-    drwav_open_and_read_s32()
-    drwav_open_file_and_read_s16()
-    drwav_open_file_and_read_f32()
-    drwav_open_file_and_read_s32()
-    drwav_open_memory_and_read_s16()
-    drwav_open_memory_and_read_f32()
-    drwav_open_memory_and_read_s32()
-    drwav::totalSampleCount
-
-See release notes for version 0.9.0 at the bottom of this file for replacement APIs.
-
-Deprecated APIs
----------------
-The following APIs have been deprecated. There is a confusing and completely arbitrary difference between drwav_init*() and
-drwav_open*(), where drwav_init*() initializes a pre-allocated drwav object, whereas drwav_open*() will first allocated a
-drwav object on the heap and then initialize it. drwav_open*() has been deprecated which means you must now use a pre-
-allocated drwav object with drwav_init*(). If you need the previous functionality, you can just do a malloc() followed by
-a called to one of the drwav_init*() APIs.
-
-    drwav_open()
-    drwav_open_ex()
-    drwav_open_write()
-    drwav_open_write_sequential()
-    drwav_open_file()
-    drwav_open_file_ex()
-    drwav_open_file_write()
-    drwav_open_file_write_sequential()
-    drwav_open_memory()
-    drwav_open_memory_ex()
-    drwav_open_memory_write()
-    drwav_open_memory_write_sequential()
-    drwav_close()
+v0.12.2 - 2020-04-21
+  - Fix a bug where drwav_init_file() does not close the file handle after attempting to load an erroneous file.
 
-These APIs will be removed completely in a future version. The rationale for this change is to remove confusion between the
-two different ways to initialize a drwav object.
-*/
+v0.12.1 - 2020-04-13
+  - Fix some pedantic warnings.
 
-/*
-REVISION HISTORY
-================
 v0.12.0 - 2020-04-04
   - API CHANGE: Add container and format parameters to the chunk callback.
   - Minor documentation updates.
 
 v0.11.5 - 2020-03-07
   - Fix compilation error with Visual Studio .NET 2003.
```

### Comparing `tinyusdz-0.8.0rc0/src/external/fast_float/LICENSE-APACHE` & `tinyusdz-0.8.0rc1/src/external/fast_float/LICENSE-APACHE`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/fast_float/LICENSE-MIT` & `tinyusdz-0.8.0rc1/src/external/fast_float/LICENSE-MIT`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/fast_float/README.md` & `tinyusdz-0.8.0rc1/src/external/fast_float/README.md`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/fast_float/include/fast_float/ascii_number.h` & `tinyusdz-0.8.0rc1/src/external/fast_float/include/fast_float/ascii_number.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/fast_float/include/fast_float/bigint.h` & `tinyusdz-0.8.0rc1/src/external/fast_float/include/fast_float/bigint.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/fast_float/include/fast_float/decimal_to_binary.h` & `tinyusdz-0.8.0rc1/src/external/fast_float/include/fast_float/decimal_to_binary.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/fast_float/include/fast_float/digit_comparison.h` & `tinyusdz-0.8.0rc1/src/external/fast_float/include/fast_float/digit_comparison.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/fast_float/include/fast_float/fast_float.h` & `tinyusdz-0.8.0rc1/src/external/fast_float/include/fast_float/fast_float.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/fast_float/include/fast_float/fast_table.h` & `tinyusdz-0.8.0rc1/src/external/fast_float/include/fast_float/fast_table.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/fast_float/include/fast_float/float_common.h` & `tinyusdz-0.8.0rc1/src/external/fast_float/include/fast_float/float_common.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/fast_float/include/fast_float/parse_number.h` & `tinyusdz-0.8.0rc1/src/external/fast_float/include/fast_float/parse_number.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/fast_float/include/fast_float/simple_decimal_conversion.h` & `tinyusdz-0.8.0rc1/src/external/fast_float/include/fast_float/simple_decimal_conversion.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/fpng.cpp` & `tinyusdz-0.8.0rc1/src/external/fpng.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/fpng.h` & `tinyusdz-0.8.0rc1/src/external/fpng.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/jsonhpp/LICENSE.MIT` & `tinyusdz-0.8.0rc1/src/external/jsonhpp/LICENSE.MIT`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 MIT License 
 
-Copyright (c) 2013-2021 Niels Lohmann
+Copyright (c) 2013-2022 Niels Lohmann
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
```

### Comparing `tinyusdz-0.8.0rc0/src/external/jsteemann/LICENSE` & `tinyusdz-0.8.0rc1/src/external/jsteemann/LICENSE`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/jsteemann/README.md` & `tinyusdz-0.8.0rc1/src/external/jsteemann/README.md`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/jsteemann/atoi.h` & `tinyusdz-0.8.0rc1/src/external/jsteemann/atoi.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/mapbox/variant/LICENSE` & `tinyusdz-0.8.0rc1/src/external/pystring.LICENSE`

 * *Files 14% similar despite different names*

```diff
@@ -1,25 +1,27 @@
-Copyright (c) MapBox
-All rights reserved.
+Copyright (c) 2008-present Contributors to the Pystring project.
+All Rights Reserved.
 
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
 
-- Redistributions of source code must retain the above copyright notice, this
-  list of conditions and the following disclaimer.
-- Redistributions in binary form must reproduce the above copyright notice, this
-  list of conditions and the following disclaimer in the documentation and/or
-  other materials provided with the distribution.
-- Neither the name "MapBox" nor the names of its contributors may be
-  used to endorse or promote products derived from this software without
-  specific prior written permission.
+1. Redistributions of source code must retain the above copyright notice, this
+   list of conditions and the following disclaimer.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+2. Redistributions in binary form must reproduce the above copyright notice,
+   this list of conditions and the following disclaimer in the documentation
+   and/or other materials provided with the distribution.
+
+3. Neither the name of the copyright holder nor the names of its
+   contributors may be used to endorse or promote products derived from
+   this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

### Comparing `tinyusdz-0.8.0rc0/src/external/mapbox/variant/LICENSE_1_0.txt` & `tinyusdz-0.8.0rc1/src/external/simple_match/LICENSE_1_0.txt`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/miniz.c` & `tinyusdz-0.8.0rc1/src/external/miniz.c`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/miniz.h` & `tinyusdz-0.8.0rc1/src/external/miniz.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/CMakeLists.txt` & `tinyusdz-0.8.0rc1/src/external/nanobind/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/LICENSE` & `tinyusdz-0.8.0rc1/src/external/nanobind/LICENSE`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/README.md` & `tinyusdz-0.8.0rc1/src/external/nanobind/README.md`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/cmake/nanobind-config.cmake` & `tinyusdz-0.8.0rc1/src/external/nanobind/cmake/nanobind-config.cmake`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/CMakeLists.txt` & `tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/LICENSE` & `tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/LICENSE`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/README.md` & `tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/README.md`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/include/tsl/robin_growth_policy.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/include/tsl/robin_growth_policy.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/include/tsl/robin_hash.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/include/tsl/robin_hash.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/include/tsl/robin_map.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/include/tsl/robin_map.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/include/tsl/robin_set.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/include/tsl/robin_set.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/tests/CMakeLists.txt` & `tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/tests/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/tests/custom_allocator_tests.cpp` & `tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/tests/custom_allocator_tests.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/tests/main.cpp` & `tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/tests/main.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/tests/policy_tests.cpp` & `tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/tests/policy_tests.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/tests/robin_map_tests.cpp` & `tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/tests/robin_map_tests.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/tests/robin_set_tests.cpp` & `tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/tests/robin_set_tests.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/tests/utils.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/tests/utils.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/ext/robin_map/tsl-robin-map.natvis` & `tinyusdz-0.8.0rc1/src/external/nanobind/ext/robin_map/tsl-robin-map.natvis`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nanobind.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nanobind.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_accessor.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_accessor.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_attr.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_attr.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_call.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_call.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_cast.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_cast.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_class.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_class.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_defs.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_defs.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_descr.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_descr.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_enums.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_enums.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_error.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_error.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_func.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_func.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_lib.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_lib.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_misc.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_misc.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_python.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_python.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_traits.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_traits.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_tuple.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_tuple.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/nb_types.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/nb_types.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/operators.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/operators.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/stl/detail/nb_list.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/stl/detail/nb_list.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/stl/function.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/stl/function.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/stl/pair.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/stl/pair.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/stl/shared_ptr.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/stl/shared_ptr.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/stl/string.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/stl/string.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/stl/tuple.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/stl/tuple.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/stl/unique_ptr.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/stl/unique_ptr.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/tensor.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/tensor.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/include/nanobind/trampoline.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/include/nanobind/trampoline.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/src/buffer.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/src/buffer.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/src/common.cpp` & `tinyusdz-0.8.0rc1/src/external/nanobind/src/common.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/src/error.cpp` & `tinyusdz-0.8.0rc1/src/external/nanobind/src/error.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/src/implicit.cpp` & `tinyusdz-0.8.0rc1/src/external/nanobind/src/implicit.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/src/nanobind/__init__.py` & `tinyusdz-0.8.0rc1/src/external/nanobind/src/nanobind/__init__.py`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/src/nb_enum.cpp` & `tinyusdz-0.8.0rc1/src/external/nanobind/src/nb_enum.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/src/nb_func.cpp` & `tinyusdz-0.8.0rc1/src/external/nanobind/src/nb_func.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/src/nb_internals.cpp` & `tinyusdz-0.8.0rc1/src/external/nanobind/src/nb_internals.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/src/nb_internals.h` & `tinyusdz-0.8.0rc1/src/external/nanobind/src/nb_internals.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/src/nb_type.cpp` & `tinyusdz-0.8.0rc1/src/external/nanobind/src/nb_type.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/src/tensor.cpp` & `tinyusdz-0.8.0rc1/src/external/nanobind/src/tensor.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/nanobind/src/trampoline.cpp` & `tinyusdz-0.8.0rc1/src/external/nanobind/src/trampoline.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/ogt_vox.h` & `tinyusdz-0.8.0rc1/src/external/ogt_vox.h`

 * *Files 1% similar despite different names*

```diff
@@ -20,28 +20,28 @@
         #include "ogt_vox.h"
 
     2. From any other module, it is sufficient to just #include this as usual:
         #include "ogt_vox.h"
 
     HOW TO READ A VOX SCENE (See demo_vox.cpp)
 
-    1. load a .vox file off disk into a memory buffer. 
-       
+    1. load a .vox file off disk into a memory buffer.
+
     2. construct a scene from the memory buffer:
        ogt_vox_scene* scene = ogt_vox_read_scene(buffer, buffer_size);
 
     3. use the scene members to extract the information you need. eg.
        printf("# of layers: %u\n", scene->num_layers );
 
     4. destroy the scene:
        ogt_vox_destroy_scene(scene);
-    
+
     HOW TO MERGE MULTIPLE VOX SCENES (See merge_vox.cpp)
 
-    1. construct multiple scenes from files you want to merge. 
+    1. construct multiple scenes from files you want to merge.
 
         // read buffer1/buffer_size1 from "test1.vox"
         // read buffer2/buffer_size2 from "test2.vox"
         // read buffer3/buffer_size3 from "test3.vox"
         ogt_vox_scene* scene1 = ogt_vox_read_scene(buffer1, buffer_size1);
         ogt_vox_scene* scene2 = ogt_vox_read_scene(buffer2, buffer_size2);
         ogt_vox_scene* scene3 = ogt_vox_read_scene(buffer3, buffer_size3);
@@ -105,15 +105,15 @@
     each of the scenes that were passed into it.
 
     The merged scene will have a combined palette of all the source scene
     palettes by trying to match existing colors exactly, and falling back
     to an RGB-distance matched color when all 256 colors in the merged
     scene palette has been allocated.
 
-    You can explicitly control up to 255 merge palette colors by providing 
+    You can explicitly control up to 255 merge palette colors by providing
     those colors to ogt_vox_merge_scenes in the required_colors parameters eg.
 
         const ogt_vox_palette palette;  // load this via .vox or procedurally or whatever
         const ogt_vox_scene* scenes[] = {scene1, scene2, scene3};
         // palette.color[0] is always the empty color which is why we pass 255 colors starting from index 1 only:
         ogt_vox_scene* merged_scene = ogt_vox_merge_scenes(scenes, 3, &palette.color[1], 255);
 
@@ -144,20 +144,20 @@
            2       X-----+
                    |  .  |
            1       +-----+
                    |  .  |
            0       +-----+
              0     1     2     3
 
-     If you were to generate a mesh from this, clearly each vertex and each face would be on an integer 
-     coordinate eg. 1, 2, 3 etc. while the centre of each grid location (ie. the . in the above diagram) 
+     If you were to generate a mesh from this, clearly each vertex and each face would be on an integer
+     coordinate eg. 1, 2, 3 etc. while the centre of each grid location (ie. the . in the above diagram)
      will be on a coordinate that is halfway between integer coordinates. eg. 1.5, 2.5, 3.5 etc.
 
      To ensure your mesh is properly centered such that instance transforms are correctly applied, you
-     want the pivot to be treated as if it were (0,0,0) in model space. To achieve this, simply 
+     want the pivot to be treated as if it were (0,0,0) in model space. To achieve this, simply
      subtract the pivot from any geometry that is generated (eg. vertices in a mesh).
 
      For the 3x4x1 voxel model above, doing this would look like this:
 
            2 +-----+-----+-----+
              |  .  |  .  |  .  |
            1 +-----+-----+-----+
@@ -165,35 +165,42 @@
            0       X-----+
                    |  .  |
           -1       +-----+
                    |  .  |
           -2       +-----+
             -1     0     1     2
 
-   
+
 */
+
+
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Weverything"
+#endif
+
 #ifndef OGT_VOX_H__
 #define OGT_VOX_H__
 
-#if _MSC_VER == 1400	
+#if _MSC_VER == 1400
     // VS2005 doesn't have inttypes or stdint so we just define what we need here.
     typedef unsigned char uint8_t;
     typedef signed int    int32_t;
     typedef unsigned int  uint32_t;
 	#ifndef UINT32_MAX
 		#define UINT32_MAX	((uint32_t)0xFFFFFFFF)
 	#endif
 	#ifndef INT32_MAX
 		#define INT32_MAX	((int32_t)0x7FFFFFFF)
 	#endif
 	#ifndef UINT8_MAX
 		#define UINT8_MAX	((uint8_t)0xFF)
 	#endif
 #elif defined(_MSC_VER)
-    // general VS* 
+    // general VS*
     #include <inttypes.h>
 #elif __APPLE__
     // general Apple compiler
 #elif defined(__GNUC__)
     // any GCC*
     #include <inttypes.h>
     #include <stdlib.h> // for size_t
@@ -372,15 +379,15 @@
 //
 //-----------------------------------------------------------------------------------------------------------------
 #ifdef OGT_VOX_IMPLEMENTATION
     #include <assert.h>
     #include <stdlib.h>
     #include <string.h>
     #include <stdio.h>
-    
+
     // MAKE_VOX_CHUNK_ID: used to construct a literal to describe a chunk in a .vox file.
     #define MAKE_VOX_CHUNK_ID(c0,c1,c2,c3)     ( (c0<<0) | (c1<<8) | (c2<<16) | (c3<<24) )
 
     static const uint32_t CHUNK_ID_VOX_ = MAKE_VOX_CHUNK_ID('V','O','X',' ');
     static const uint32_t CHUNK_ID_MAIN = MAKE_VOX_CHUNK_ID('M','A','I','N');
     static const uint32_t CHUNK_ID_SIZE = MAKE_VOX_CHUNK_ID('S','I','Z','E');
     static const uint32_t CHUNK_ID_XYZI = MAKE_VOX_CHUNK_ID('X','Y','Z','I');
@@ -427,19 +434,19 @@
         0x11, 0x00, 0x00, 0xff, 0x00, 0xee, 0x00, 0xff, 0x00, 0xdd, 0x00, 0xff, 0x00, 0xbb, 0x00, 0xff, 0x00, 0xaa, 0x00, 0xff, 0x00, 0x88, 0x00, 0xff, 0x00, 0x77, 0x00, 0xff, 0x00, 0x55, 0x00, 0xff,
         0x00, 0x44, 0x00, 0xff, 0x00, 0x22, 0x00, 0xff, 0x00, 0x11, 0x00, 0xff, 0x00, 0x00, 0xee, 0xff, 0x00, 0x00, 0xdd, 0xff, 0x00, 0x00, 0xbb, 0xff, 0x00, 0x00, 0xaa, 0xff, 0x00, 0x00, 0x88, 0xff,
         0x00, 0x00, 0x77, 0xff, 0x00, 0x00, 0x55, 0xff, 0x00, 0x00, 0x44, 0xff, 0x00, 0x00, 0x22, 0xff, 0x00, 0x00, 0x11, 0xff, 0xee, 0xee, 0xee, 0xff, 0xdd, 0xdd, 0xdd, 0xff, 0xbb, 0xbb, 0xbb, 0xff,
         0xaa, 0xaa, 0xaa, 0xff, 0x88, 0x88, 0x88, 0xff, 0x77, 0x77, 0x77, 0xff, 0x55, 0x55, 0x55, 0xff, 0x44, 0x44, 0x44, 0xff, 0x22, 0x22, 0x22, 0xff, 0x11, 0x11, 0x11, 0xff, 0x00, 0x00, 0x00, 0xff,
     };
 
     // internal math/helper utilities
-    static inline uint32_t _vox_max(uint32_t a, uint32_t b) { 
-        return (a > b) ? a : b; 
+    static inline uint32_t _vox_max(uint32_t a, uint32_t b) {
+        return (a > b) ? a : b;
     }
-    static inline uint32_t _vox_min(uint32_t a, uint32_t b) { 
-        return (a < b) ? a : b; 
+    static inline uint32_t _vox_min(uint32_t a, uint32_t b) {
+        return (a < b) ? a : b;
     }
 
     // string utilities
     #ifdef _MSC_VER
         #define _vox_str_scanf(str,...)      sscanf_s(str,__VA_ARGS__)
         #define _vox_strcpy_static(dst,src)  strcpy_s(dst,src)
         #define _vox_strcasecmp(a,b)         _stricmp(a,b)
@@ -448,15 +455,15 @@
         #define _vox_sprintf(str,str_max,fmt,...)    sprintf_s(str, str_max, fmt, __VA_ARGS__)
     #else
         #define _vox_str_scanf(str,...)      sscanf(str,__VA_ARGS__)
         #define _vox_strcpy_static(dst,src)  strcpy(dst,src)
         #define _vox_strcasecmp(a,b)         strcasecmp(a,b)
         #define _vox_strcmp(a,b)             strcmp(a,b)
         #define _vox_strlen(a)               strlen(a)
-        #define _vox_sprintf(str,str_max,fmt,...)    snprintf(str, str_max, fmt, __VA_ARGS__)        
+        #define _vox_sprintf(str,str_max,fmt,...)    snprintf(str, str_max, fmt, __VA_ARGS__)
     #endif
 
     // 3d vector utilities
     struct vec3 {
         float x, y, z;
     };
     static inline vec3 vec3_make(float x, float y, float z) { vec3 v; v.x = x; v.y = y; v.z = z; return v; }
@@ -499,15 +506,15 @@
             hash = data[i] + (hash * 65559);
         return hash;
     }
 
     // memory allocation utils.
     static void* _ogt_priv_alloc_default(size_t size) { return malloc(size); }
     static void  _ogt_priv_free_default(void* ptr)    { free(ptr); }
-    static ogt_vox_alloc_func g_alloc_func = _ogt_priv_alloc_default; // default function for allocating 
+    static ogt_vox_alloc_func g_alloc_func = _ogt_priv_alloc_default; // default function for allocating
     static ogt_vox_free_func  g_free_func = _ogt_priv_free_default;   // default  function for freeing.
 
     // set the provided allocate/free functions if they are non-null, otherwise reset to default allocate/free functions
     void ogt_vox_set_memory_allocator(ogt_vox_alloc_func alloc_func, ogt_vox_free_func free_func)
     {
         assert((alloc_func && free_func) ||      // both alloc/free must be non-NULL -OR-
             (!alloc_func && !free_func));    // both alloc/free must be NULL. No mixing 'n matching.
@@ -723,15 +730,15 @@
 
 
     static ogt_vox_transform _vox_make_transform_from_dict_strings(const char* rotation_string, const char* translation_string) {
         ogt_vox_transform transform = _vox_transform_identity();
 
         if (rotation_string != NULL) {
             // compute the per-row indexes into k_vectors[] array.
-            // unpack rotation bits. 
+            // unpack rotation bits.
             //  bits  : meaning
             //  0 - 1 : index of the non-zero entry in the first row
             //  2 - 3 : index of the non-zero entry in the second row
             uint32_t packed_rotation_bits = atoi(rotation_string);
             uint32_t row0_vec_index = (packed_rotation_bits >> 0) & 3;
             uint32_t row1_vec_index = (packed_rotation_bits >> 2) & 3;
             uint32_t row2_vec_index = k_row2_index[(1 << row0_vec_index) | (1 << row1_vec_index)];    // process of elimination to determine row 2 index based on row0/row1 being one of {0,1,2} choose 2.
@@ -804,26 +811,26 @@
     static void generate_instances_for_node(
         const _vox_array<_vox_scene_node_> & nodes, uint32_t node_index, const _vox_array<uint32_t> & child_id_array, uint32_t layer_index,
         const ogt_vox_transform& transform, const _vox_array<ogt_vox_model*> & model_ptrs, const char* transform_last_name, bool transform_last_hidden,
         _vox_array<ogt_vox_instance> & instances, _vox_array<char> & string_data, _vox_array<ogt_vox_group>& groups, uint32_t group_index, bool generate_groups)
     {
         const _vox_scene_node_* node = &nodes[node_index];
         assert(node);
-        switch (node->node_type) 
+        switch (node->node_type)
         {
-            case k_nodetype_transform: 
+            case k_nodetype_transform:
             {
                 ogt_vox_transform new_transform = (generate_groups) ? node->u.transform.transform  // don't multiply by the parent transform. caller wants the group-relative transform
                         : _vox_transform_multiply(node->u.transform.transform, transform);         // flatten the transform if we're not generating groups: child transform * parent transform
                 const char* new_transform_name = node->u.transform.name[0] ? node->u.transform.name : NULL;
                 transform_last_name = new_transform_name ? new_transform_name : transform_last_name;    // if this node has a name, use it instead of our parent name
                 generate_instances_for_node(nodes, node->u.transform.child_node_id, child_id_array, node->u.transform.layer_id, new_transform, model_ptrs, transform_last_name, node->u.transform.hidden, instances, string_data, groups, group_index, generate_groups);
                 break;
             }
-            case k_nodetype_group: 
+            case k_nodetype_group:
             {
                 // create a new group only if we're generating groups.
                 uint32_t next_group_index = 0;
                 if (generate_groups) {
                     next_group_index = (uint32_t)groups.size();
                     ogt_vox_group group;
                     group.parent_group_index = group_index;
@@ -837,28 +844,28 @@
 
                 const uint32_t* child_node_ids = (const uint32_t*)& child_id_array[node->u.group.first_child_node_id_index];
                 for (uint32_t i = 0; i < node->u.group.num_child_nodes; i++) {
                     generate_instances_for_node(nodes, child_node_ids[i], child_id_array, layer_index, transform, model_ptrs, transform_last_name, transform_last_hidden, instances, string_data, groups, next_group_index, generate_groups);
                 }
                 break;
             }
-            case k_nodetype_shape: 
+            case k_nodetype_shape:
             {
                 assert(node->u.shape.model_id < model_ptrs.size());
                 if (node->u.shape.model_id < model_ptrs.size() &&    // model ID is valid
-                    model_ptrs[node->u.shape.model_id] != NULL )     // model is non-NULL.   
+                    model_ptrs[node->u.shape.model_id] != NULL )     // model is non-NULL.
                 {
                     assert(generate_groups || group_index == 0);     // if we're not generating groups, group_index should be zero to map to the root group.
                     ogt_vox_instance new_instance;
                     new_instance.model_index = node->u.shape.model_id;
                     new_instance.transform   = transform;
                     new_instance.layer_index = layer_index;
                     new_instance.group_index = group_index;
                     new_instance.hidden      = transform_last_hidden;
-                    // if we got a transform name, allocate space in string_data for it and keep track of the index 
+                    // if we got a transform name, allocate space in string_data for it and keep track of the index
                     // within string data. This will be patched to a real pointer at the very end.
                     new_instance.name = 0;
                     if (transform_last_name && transform_last_name[0]) {
                         new_instance.name = (const char*)(string_data.size());
                         size_t name_size = _vox_strlen(transform_last_name) + 1;       // +1 for terminator
                         string_data.push_back_many(transform_last_name, name_size);
                     }
@@ -916,16 +923,16 @@
         instances.reserve(256);
         child_ids.reserve(256);
         nodes.reserve(16);
         layers.reserve(8);
         groups.reserve(0);
         string_data.reserve(256);
 
-        // push a sentinel character into these datastructures. This allows us to keep indexes 
-        // rather than pointers into data-structures that grow, and still allow an index of 0 
+        // push a sentinel character into these datastructures. This allows us to keep indexes
+        // rather than pointers into data-structures that grow, and still allow an index of 0
         // to means invalid
         string_data.push_back('X');
         child_ids.push_back(UINT32_MAX);
 
         // copy the default palette into the scene. It may get overwritten by a palette chunk later
         memcpy(&palette, k_default_vox_palette, sizeof(ogt_vox_palette));
 
@@ -1080,15 +1087,15 @@
                 {
                     uint32_t node_id = 0;
                     _vox_file_read(fp, &node_id, sizeof(node_id));
 
                     // parse the node dictionary - data is unused.
                     _vox_file_read_dict(&dict, fp);
 
-                    // setup the group node 
+                    // setup the group node
                     nodes.grow_to_fit_index(node_id);
                     _vox_scene_node_* group_node = &nodes[node_id];
                     group_node->node_type = k_nodetype_group;
                     group_node->u.group.first_child_node_id_index = 0;
                     group_node->u.group.num_child_nodes           = 0;
 
                     // setup all child scene nodes to point back to this node.
@@ -1107,15 +1114,15 @@
                     break;
                 }
                 case CHUNK_ID_nSHP:
                 {
                     uint32_t node_id = 0;
                     _vox_file_read(fp, &node_id, sizeof(node_id));
 
-                    // setup the shape node 
+                    // setup the shape node
                     nodes.grow_to_fit_index(node_id);
                     _vox_scene_node_* shape_node = &nodes[node_id];
                     shape_node->node_type = k_nodetype_shape;
                     shape_node->u.shape.model_id = UINT32_MAX;
 
                     // parse the node dictionary - data is unused.
                     _vox_file_read_dict(&dict, fp);
@@ -1148,15 +1155,15 @@
                     _vox_file_read(fp, &reserved_id, sizeof(reserved_id));
                     assert(reserved_id == -1);
 
                     layers.grow_to_fit_index(layer_id);
                     layers[layer_id].name = NULL;
                     layers[layer_id].hidden = false;
 
-                    // if we got a layer name from the LAYR dictionary, allocate space in string_data for it and keep track of the index 
+                    // if we got a layer name from the LAYR dictionary, allocate space in string_data for it and keep track of the index
                     // within string data. This will be patched to a real pointer at the very end.
                     const char* name_string = _vox_dict_get_value_as_string(&dict, "_name", NULL);
                     if (name_string) {
                         layers[layer_id].name = (const char*)(string_data.size());
                         size_t name_size = _vox_strlen(name_string) + 1;       // +1 for terminator
                         string_data.push_back_many(name_string, name_size);
                     }
@@ -1345,15 +1352,15 @@
             }
             generate_instances_for_node(nodes, 0, child_ids, 0, _vox_transform_identity(), model_ptrs, NULL, false, instances, string_data, groups, k_invalid_group_index, generate_groups);
         }
         else if (model_ptrs.size() == 1) {
             // add a single instance
             ogt_vox_instance new_instance;
             new_instance.model_index = 0;
-            new_instance.group_index = 0;			
+            new_instance.group_index = 0;
             new_instance.transform   = _vox_transform_identity();
             new_instance.layer_index = 0;
             new_instance.name        = 0;
             new_instance.hidden      = false;
             instances.push_back(new_instance);
         }
 
@@ -1365,24 +1372,24 @@
             // add a single layer
             ogt_vox_layer new_layer;
             new_layer.hidden = false;
             new_layer.name   = NULL;
             layers.push_back(new_layer);
         }
 
-        // To support index-level assumptions (eg. artists using top 16 colors for color/palette cycling, 
-        // other ranges for emissive etc), we must ensure the order of colors that the artist sees in the 
-        // magicavoxel tool matches the actual index we'll end up using here. Unfortunately, magicavoxel 
+        // To support index-level assumptions (eg. artists using top 16 colors for color/palette cycling,
+        // other ranges for emissive etc), we must ensure the order of colors that the artist sees in the
+        // magicavoxel tool matches the actual index we'll end up using here. Unfortunately, magicavoxel
         // does an unexpected thing when remapping colors in the editor using ctrl+drag within the palette.
-        // Instead of remapping all indices in all models, it just keeps track of a display index to actual 
+        // Instead of remapping all indices in all models, it just keeps track of a display index to actual
         // palette map and uses that to show reordered colors in the palette window. This is how that
         // map works:
         //   displaycolor[k] = paletteColor[imap[k]]
         // To ensure our indices are in the same order as displayed by magicavoxel within the palette
-        // window, we apply the mapping from the IMAP chunk both to the color palette and indices within each 
+        // window, we apply the mapping from the IMAP chunk both to the color palette and indices within each
         // voxel model.
         if (found_index_map_chunk)
         {
             // the imap chunk maps from display index to actual index.
             // generate an inverse index map (maps from actual index to display index)
             uint8_t index_map_inverse[256];
             for (uint32_t i = 0; i < 256; i++) {
@@ -1423,15 +1430,15 @@
             for (uint32_t i = 255; i > 0; i--)
                 palette.color[i] = palette.color[i - 1];
             palette.color[0] = last_color;
             palette.color[0].a = 0;  // alpha is zero for the 0th color as that color index represents a transparent voxel.
         }
 
         // check for models that are identical by doing a pair-wise compare. If we find identical
-        // models, we'll end up with NULL gaps in the model_ptrs array, but instances will have 
+        // models, we'll end up with NULL gaps in the model_ptrs array, but instances will have
         // been remapped to keep the earlier model.
         for (uint32_t i = 0; i < model_ptrs.size(); i++) {
             if (!model_ptrs[i])
                 continue;
             for (uint32_t j = i+1; j < model_ptrs.size(); j++) {
                 if (!model_ptrs[j] || !_vox_models_are_equal(model_ptrs[i], model_ptrs[j]))
                     continue;
@@ -1442,15 +1449,15 @@
                 for (uint32_t k = 0; k < instances.size(); k++)
                     if (instances[k].model_index == j)
                         instances[k].model_index = i;
             }
         }
 
         // sometimes a model can be created which has no solid voxels within just due to the
-        // authoring flow within magicavoxel. We have already have prevented creation of 
+        // authoring flow within magicavoxel. We have already have prevented creation of
         // instances that refer to empty models, but here we want to compact the model_ptrs
         // array such that it contains no more NULL models. This also requires we remap the
         // indices for instances so they continue to refer to their correct models.
         {
             // first, check to see if we find any empty model. No need to do work otherwise.
             bool found_empty_model = false;
             for (uint32_t i = 0; i < model_ptrs.size() && !found_empty_model; i++) {
@@ -1586,15 +1593,15 @@
         bool is_negative = false;
         for (uint8_t i = 0; i < 3; i++) {
             if (f[i] == 1.0f || f[i] == -1.0f) {
                 out_index = i;
                 is_negative = f[i] < 0.0f ? true : false;
             }
             else {
-                assert(f[i] == 0.0f);   // must be zero 
+                assert(f[i] == 0.0f);   // must be zero
             }
         }
         assert(out_index != 3); // if you hit this, you probably have all zeroes in the vector!
         return is_negative;
     }
 
     static uint8_t _vox_make_packed_rotation_from_transform(const ogt_vox_transform * transform) {
@@ -1666,15 +1673,15 @@
             _vox_sprintf(r_string_buf, sizeof(r_string_buf), "%u", packed_rotation_bits);
             t_string = t_string_buf;
             r_string = r_string_buf;
         }
 
         uint32_t node_dict_size =
             sizeof(uint32_t) + // num key value pairs
-            _vox_dict_key_value_size("_name",   name) +        
+            _vox_dict_key_value_size("_name",   name) +
             _vox_dict_key_value_size("_hidden", hidden_string);
 
         uint32_t frame_dict_size =
             sizeof(uint32_t) + // num key value pairs
             _vox_dict_key_value_size("_t", t_string) +
             _vox_dict_key_value_size("_r", r_string);
 
@@ -1716,15 +1723,15 @@
         _vox_file_writeable_init(&file);
         _vox_file_writeable* fp = &file;
 
         // write file header and file version
         _vox_file_write_uint32(fp, CHUNK_ID_VOX_);
         _vox_file_write_uint32(fp, 150);
 
-        // write the main chunk 
+        // write the main chunk
         _vox_file_write_uint32(fp, CHUNK_ID_MAIN);
         _vox_file_write_uint32(fp, 0);
         _vox_file_write_uint32(fp, 0);  // this main_chunk_child_size will get patched up once everything is written.
 
         // we need to know how to patch up the main chunk size after we've written everything
         const uint32_t offset_post_main_chunk = _vox_file_get_offset(fp);
 
@@ -1736,15 +1743,15 @@
             uint32_t num_voxels_in_grid = model->size_x * model->size_y * model->size_z;
             uint32_t num_solid_voxels = 0;
             for (uint32_t voxel_index = 0; voxel_index < num_voxels_in_grid; voxel_index++)
                 if (model->voxel_data[voxel_index] != 0)
                     num_solid_voxels++;
             uint32_t chunk_size_xyzi = sizeof(uint32_t) + 4 * num_solid_voxels;
 
-            // write the SIZE chunk header 
+            // write the SIZE chunk header
             _vox_file_write_uint32(fp, CHUNK_ID_SIZE);
             _vox_file_write_uint32(fp, 12);
             _vox_file_write_uint32(fp, 0);
 
             // write the SIZE chunk payload
             _vox_file_write_uint32(fp, model->size_x);
             _vox_file_write_uint32(fp, model->size_y);
@@ -1783,16 +1790,16 @@
         // write the nTRN nodes for each of the groups in the scene.
         for (uint32_t group_index = 0; group_index < scene->num_groups; group_index++) {
             const ogt_vox_group* group = &scene->groups[group_index];
             _vox_file_write_chunk_nTRN(fp, first_group_transform_node_id + group_index, first_group_node_id + group_index, NULL, group->hidden, &group->transform, group->layer_index);
         }
         // write the group nodes for each of the groups in the scene
         for (uint32_t group_index = 0; group_index < scene->num_groups; group_index++) {
-            // count how many childnodes  there are. This is simply the sum of all 
-            // groups and instances that have this group as its parent 
+            // count how many childnodes  there are. This is simply the sum of all
+            // groups and instances that have this group as its parent
             uint32_t num_child_nodes = 0;
             for (uint32_t child_group_index = 0; child_group_index < scene->num_groups; child_group_index++)
                 if (scene->groups[child_group_index].parent_group_index == group_index)
                     num_child_nodes++;
             for (uint32_t child_instance_index = 0; child_instance_index < scene->num_instances; child_instance_index++)
                 if (scene->instances[child_instance_index].group_index == group_index)
                     num_child_nodes++;
@@ -2035,48 +2042,48 @@
             uint32_t layer_dict_keyvalue_count = (layer_name_string ? 1 : 0) + (hidden_string ? 1 : 0);
             // write the layer chunk header
             _vox_file_write_uint32(fp, CHUNK_ID_LAYR);
             _vox_file_write_uint32(fp, layer_chunk_size);
             _vox_file_write_uint32(fp, 0);
             // write the layer chunk payload
             _vox_file_write_uint32(fp, i);                          // layer_id
-            _vox_file_write_uint32(fp, layer_dict_keyvalue_count);  // num keyvalue pairs in layer dictionary 
+            _vox_file_write_uint32(fp, layer_dict_keyvalue_count);  // num keyvalue pairs in layer dictionary
             _vox_file_write_dict_key_value(fp, "_name",   layer_name_string);
             _vox_file_write_dict_key_value(fp, "_hidden", hidden_string);
             _vox_file_write_uint32(fp, UINT32_MAX);                 // reserved id
         }
-        
+
         // we deliberately don't free the fp->data field, just pass the buffer pointer and size out to the caller
         *buffer_size = (uint32_t)fp->data.count;
         uint8_t* buffer_data = _vox_file_get_data(fp);
         // we deliberately clear this pointer so it doesn't get auto-freed on exiting. The caller will own the memory hereafter.
         fp->data.data = NULL;
 
         // patch up the main chunk's child chunk size now that we've written everything we're going to write.
         {
             uint32_t* main_chunk_child_size = (uint32_t*)& buffer_data[offset_post_main_chunk - sizeof(uint32_t)];
             *main_chunk_child_size = *buffer_size - offset_post_main_chunk;
         }
 
         return buffer_data;
     }
-    
+
     void* ogt_vox_malloc(size_t size) {
         return _vox_malloc(size);
     }
 
     void ogt_vox_free(void* mem) {
         _vox_free(mem);
     }
 
     // compute the minimum and maximum x coordinate within the scene.
     static void compute_scene_bounding_box_x(const ogt_vox_scene * scene, int32_t & out_min_x, int32_t & out_max_x) {
         if (scene->num_instances && scene->num_models)
         {
-            // We don't apply orientation to the model dimensions and compute the exact min/max. 
+            // We don't apply orientation to the model dimensions and compute the exact min/max.
             // Instead we just conservatively use the maximum dimension of the model.
             int32_t scene_min_x =  0x7ffffff;
             int32_t scene_max_x = -0x7ffffff;
             for (uint32_t instance_index = 0; instance_index < scene->num_instances; instance_index++) {
                 const ogt_vox_instance* instance = &scene->instances[instance_index];
                 // compute the instance transform, taking into account the group hierarchy.
                 ogt_vox_transform instance_transform = instance->transform;
@@ -2084,17 +2091,17 @@
                 while (parent_group_index != k_invalid_group_index) {
                     const ogt_vox_group* group = &scene->groups[parent_group_index];
                     instance_transform = _vox_transform_multiply(instance_transform, group->transform);
                     parent_group_index = group->parent_group_index;
                 }
 
                 const ogt_vox_model* model = scene->models[instance->model_index];
-                // the instance_transform can be rotated, so we try to figure out whether the 
+                // the instance_transform can be rotated, so we try to figure out whether the
                 // model's local x, y or z size is aligned along the world x axis.
-                // One of the column vectors of the transform must have a non-zero in its 
+                // One of the column vectors of the transform must have a non-zero in its
                 // x field and the dimension associated with that column is the correct choice of rus.
                 int32_t max_dim = instance_transform.m00 != 0.0f ? model->size_x :
                                   instance_transform.m10 != 0.0f ? model->size_y :
                                   instance_transform.m20 != 0.0f ? model->size_z : model->size_x;
                 int32_t half_dim = max_dim / 2;
                 int32_t min_x = (int32_t)instance_transform.m30 - half_dim;
                 int32_t max_x = (int32_t)instance_transform.m30 + half_dim;
@@ -2107,15 +2114,15 @@
         }
         else {
             out_min_x = 0;
             out_max_x = 0;
         }
     }
 
-    // returns a mask of which color indices are used by the specified scene. 
+    // returns a mask of which color indices are used by the specified scene.
     // used_mask[0] can be false at the end of this if all models 100% fill their voxel grid with solid voxels, so callers
     // should handle that case properly.
     static void compute_scene_used_color_index_mask(bool* used_mask, const ogt_vox_scene * scene) {
         memset(used_mask, 0, 256);
         for (uint32_t model_index = 0; model_index < scene->num_models; model_index++) {
             const ogt_vox_model* model = scene->models[model_index];
             uint32_t voxel_count = model->size_x * model->size_y * model->size_z;
@@ -2147,15 +2154,15 @@
         // The distance is in R,G,B space, and we choose the color with the lowest score.
         for (uint32_t color_index = 1; color_index < palette_count; color_index++) {
             int32_t r_diff = (int32_t)color_to_find.r - (int32_t)palette[color_index].r;
             int32_t g_diff = (int32_t)color_to_find.g - (int32_t)palette[color_index].g;
             int32_t b_diff = (int32_t)color_to_find.b - (int32_t)palette[color_index].b;
             // There are 2 aspects of our treatment of color here you may want to experiment with:
             // 1. differences in R, differences in G, differences in B are weighted the same rather than perceptually. Different weightings may be better for you.
-            // 2. We treat R,G,B as if they are in a perceptually linear within each channel. eg. the differences between 
+            // 2. We treat R,G,B as if they are in a perceptually linear within each channel. eg. the differences between
             //    a value of 5 and 8 in any channel is perceptually the same as the difference between 233 and 236 in the same channel.
             int32_t score = (r_diff * r_diff) + (g_diff * g_diff) + (b_diff * b_diff);
             if (score < best_score) {
                 best_score = score;
                 best_index = color_index;
             }
         }
@@ -2189,16 +2196,16 @@
                         // otherwise, find the color that is perceptually closest to the original color.
 
                         // TODO(jpaver): It is potentially problematic if we hit this path for a many-scene merge.
                         // Earlier scenes will reserve their colors exactly into the master palette, whereas later
                         // scenes will end up having some of their colors remapped to different colors.
 
                         // A more holistic approach to color allocation may be necessary here eg.
-                        // we might allow the master palette to grow to more than 256 entries, and then use 
-                        // similarity/frequency metrics to reduce the palette from that down to 256 entries. This 
+                        // we might allow the master palette to grow to more than 256 entries, and then use
+                        // similarity/frequency metrics to reduce the palette from that down to 256 entries. This
                         // will mean all scenes will have be equally important if they have a high-frequency
                         // usage of a color.
                         master_index = find_closest_color_in_palette(master_palette, master_palette_count, color);
                     }
                 }
                 // caller needs to know how to map its original color index into the master palette
                 scene_to_master_map[color_index] = master_index;
@@ -2240,15 +2247,15 @@
         uint32_t num_groups    = 0;
 
         // add a single layer.
         layers[num_layers].hidden = false;
         layers[num_layers].name = "merged";
         num_layers++;
 
-        // magicavoxel expects exactly 1 root group, so if we have multiple scenes with multiple roots, 
+        // magicavoxel expects exactly 1 root group, so if we have multiple scenes with multiple roots,
         // we must ensure all merged scenes are parented to the same root group. Allocate it now for the
         // merged scene.
         uint32_t global_root_group_index = num_groups;
         {
             assert(global_root_group_index == 0);
             ogt_vox_group root_group;
             root_group.hidden             = false;
@@ -2262,15 +2269,15 @@
         size_t string_data_size = 0;
         int32_t offset_x = 0;
         for (uint32_t scene_index = 0; scene_index < scene_count; scene_index++) {
             const ogt_vox_scene* scene = scenes[scene_index];
             if (!scene)
                 continue;
 
-            // update the master palette, and get the map of this scene's color indices into the master palette. 
+            // update the master palette, and get the map of this scene's color indices into the master palette.
             uint32_t scene_color_index_to_master_map[256];
             update_master_palette_from_scene(master_palette, master_palette_count, scene, scene_color_index_to_master_map);
 
             // cache away the base model index for this scene.
             uint32_t base_model_index = num_models;
             uint32_t base_group_index = num_groups;
 
@@ -2293,16 +2300,16 @@
                 *override_model = *model;
                 override_model->voxel_data = override_voxel_data;
                 override_model->voxel_hash = _vox_hash(override_voxel_data, voxel_count);
 
                 models[num_models++] = override_model;
             }
 
-            // compute the scene bounding box on x dimension. this is used to offset instances 
-            // and groups in the merged model along X dimension such that they do not overlap 
+            // compute the scene bounding box on x dimension. this is used to offset instances
+            // and groups in the merged model along X dimension such that they do not overlap
             // with instances from another scene in the merged model.
             int32_t scene_min_x, scene_max_x;
             compute_scene_bounding_box_x(scene, scene_min_x, scene_max_x);
             float scene_offset_x = (float)(offset_x - scene_min_x);
 
             // each scene has a root group, and it must the 0th group in its local groups[] array,
             assert(scene->groups[0].parent_group_index == k_invalid_group_index);
@@ -2376,14 +2383,18 @@
             merged_scene->palette.color[color_index] = master_palette[color_index];
 
         return merged_scene;
     }
 
  #endif // #ifdef OGT_VOX_IMPLEMENTATION
 
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
 /* -------------------------------------------------------------------------------------------------------------------------------------------------
 
     MIT License
 
     Copyright (c) 2019 Justin Paver
 
     Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
```

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/CMakeLists.txt` & `tinyusdz-0.8.0rc1/src/external/pybind11/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/LICENSE` & `tinyusdz-0.8.0rc1/src/external/pybind11/LICENSE`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/README.rst` & `tinyusdz-0.8.0rc1/src/external/pybind11/README.rst`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/attr.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/attr.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/buffer_info.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/buffer_info.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/cast.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/cast.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/chrono.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/chrono.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/complex.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/complex.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/detail/class.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/detail/class.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/detail/common.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/detail/common.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/detail/descr.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/detail/descr.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/detail/init.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/detail/init.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/detail/internals.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/detail/internals.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/detail/type_caster_base.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/detail/type_caster_base.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/detail/typeid.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/detail/typeid.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/eigen.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/eigen.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/embed.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/embed.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/eval.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/eval.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/functional.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/functional.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/gil.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/gil.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/iostream.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/iostream.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/numpy.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/numpy.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/operators.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/operators.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/options.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/options.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/pybind11.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/pybind11.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/pytypes.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/pytypes.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/stl/filesystem.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/stl/filesystem.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/stl.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/stl.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/include/pybind11/stl_bind.h` & `tinyusdz-0.8.0rc1/src/external/pybind11/include/pybind11/stl_bind.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/tools/FindCatch.cmake` & `tinyusdz-0.8.0rc1/src/external/pybind11/tools/FindCatch.cmake`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/tools/FindEigen3.cmake` & `tinyusdz-0.8.0rc1/src/external/pybind11/tools/FindEigen3.cmake`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/tools/FindPythonLibsNew.cmake` & `tinyusdz-0.8.0rc1/src/external/pybind11/tools/FindPythonLibsNew.cmake`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/tools/check-style.sh` & `tinyusdz-0.8.0rc1/src/external/pybind11/tools/check-style.sh`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/tools/cmake_uninstall.cmake.in` & `tinyusdz-0.8.0rc1/src/external/pybind11/tools/cmake_uninstall.cmake.in`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/tools/libsize.py` & `tinyusdz-0.8.0rc1/src/external/pybind11/tools/libsize.py`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/tools/make_changelog.py` & `tinyusdz-0.8.0rc1/src/external/pybind11/tools/make_changelog.py`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/tools/pybind11Common.cmake` & `tinyusdz-0.8.0rc1/src/external/pybind11/tools/pybind11Common.cmake`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/tools/pybind11Config.cmake.in` & `tinyusdz-0.8.0rc1/src/external/pybind11/tools/pybind11Config.cmake.in`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/tools/pybind11NewTools.cmake` & `tinyusdz-0.8.0rc1/src/external/pybind11/tools/pybind11NewTools.cmake`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/tools/pybind11Tools.cmake` & `tinyusdz-0.8.0rc1/src/external/pybind11/tools/pybind11Tools.cmake`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/tools/setup_global.py.in` & `tinyusdz-0.8.0rc1/src/external/pybind11/tools/setup_global.py.in`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/pybind11/tools/setup_main.py.in` & `tinyusdz-0.8.0rc1/src/external/pybind11/tools/setup_main.py.in`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/ryu/LICENSE-Boost` & `tinyusdz-0.8.0rc1/src/external/tinycolorio.LICENSE`

 * *Files 20% similar despite different names*

```diff
@@ -1,23 +1,22 @@
-Boost Software License - Version 1.0 - August 17th, 2003
+MIT License
 
-Permission is hereby granted, free of charge, to any person or organization
-obtaining a copy of the software and accompanying documentation covered by
-this license (the "Software") to use, reproduce, display, distribute,
-execute, and transmit the Software, and to prepare derivative works of the
-Software, and to permit third-parties to whom the Software is furnished to
-do so, all subject to the following:
+Copyright (c) 2018 Syoyo Fujita.
 
-The copyright notices in the Software and this entire statement, including
-the above license grant, this restriction and the following disclaimer,
-must be included in all copies of the Software, in whole or in part, and
-all derivative works of the Software, unless such copies or derivative
-works are solely in the form of machine-executable object code generated by
-a source language processor.
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
-SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
-FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
-ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+
```

### Comparing `tinyusdz-0.8.0rc0/src/external/simple_match/LICENSE_1_0.txt` & `tinyusdz-0.8.0rc1/src/external/OpenFBX/LICENSE`

 * *Files 22% similar despite different names*

```diff
@@ -1,23 +1,21 @@
-Boost Software License - Version 1.0 - August 17th, 2003
+MIT License
 
-Permission is hereby granted, free of charge, to any person or organization
-obtaining a copy of the software and accompanying documentation covered by
-this license (the "Software") to use, reproduce, display, distribute,
-execute, and transmit the Software, and to prepare derivative works of the
-Software, and to permit third-parties to whom the Software is furnished to
-do so, all subject to the following:
+Copyright (c) 2017 Mikulas Florek
 
-The copyright notices in the Software and this entire statement, including
-the above license grant, this restriction and the following disclaimer,
-must be included in all copies of the Software, in whole or in part, and
-all derivative works of the Software, unless such copies or derivative
-works are solely in the form of machine-executable object code generated by
-a source language processor.
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
-SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
-FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
-ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
```

### Comparing `tinyusdz-0.8.0rc0/src/external/simple_match/README.md` & `tinyusdz-0.8.0rc1/src/external/simple_match/README.md`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/simple_match/include/simple_match/implementation/some_none.hpp` & `tinyusdz-0.8.0rc1/src/external/simple_match/include/simple_match/implementation/some_none.hpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/simple_match/include/simple_match/simple_match.hpp` & `tinyusdz-0.8.0rc1/src/external/simple_match/include/simple_match/simple_match.hpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/simple_match/include/simple_match/utility.hpp` & `tinyusdz-0.8.0rc1/src/external/simple_match/include/simple_match/utility.hpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/staticstruct.cc` & `tinyusdz-0.8.0rc1/src/external/staticstruct.cc`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/staticstruct.hh` & `tinyusdz-0.8.0rc1/src/external/staticstruct.hh`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/stb_image.h` & `tinyusdz-0.8.0rc1/src/external/stb_image.h`

 * *Files 3% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-/* stb_image - v2.25 - public domain image loader - http://nothings.org/stb
+/* stb_image - v2.28 - public domain image loader - http://nothings.org/stb
                                   no warranty implied; use at your own risk
 
    Do this:
       #define STB_IMAGE_IMPLEMENTATION
    before you include this file in *one* C or C++ file to create the implementation.
 
    // i.e. it should look like this:
@@ -44,14 +44,17 @@
 
 LICENSE
 
   See end of file for license information.
 
 RECENT REVISION HISTORY:
 
+      2.28  (2023-01-29) many error fixes, security errors, just tons of stuff
+      2.27  (2021-07-11) document stbi_info better, 16-bit PNM support, bug fixes
+      2.26  (2020-07-13) many minor fixes
       2.25  (2020-02-02) fix warnings
       2.24  (2020-02-02) fix warnings; thread-local failure_reason and flip_vertically
       2.23  (2019-08-11) fix clang static analysis warning
       2.22  (2019-03-04) gif fixes, fix warnings
       2.21  (2019-02-25) fix typo in comment
       2.20  (2019-02-07) support utf8 filenames in Windows; fix warnings and platform ifdefs
       2.19  (2018-02-11) fix warning
@@ -84,35 +87,45 @@
     Ken Miller (pgm, ppm)                  Richard Mitton (16-bit PSD)
     github:urraka (animated gif)           Junggon Kim (PNM comments)
     Christopher Forseth (animated gif)     Daniel Gibson (16-bit TGA)
                                            socks-the-fox (16-bit PNG)
                                            Jeremy Sawicki (handle all ImageNet JPGs)
  Optimizations & bugfixes                  Mikhail Morozov (1-bit BMP)
     Fabian "ryg" Giesen                    Anael Seghezzi (is-16-bit query)
-    Arseny Kapoulkine
+    Arseny Kapoulkine                      Simon Breuss (16-bit PNM)
     John-Mark Allen
     Carmelo J Fdez-Aguera
 
  Bug & warning fixes
-    Marc LeBlanc            David Woo          Guillaume George   Martins Mozeiko
-    Christpher Lloyd        Jerry Jansson      Joseph Thomson     Phil Jordan
-    Dave Moore              Roy Eltham         Hayaki Saito       Nathan Reed
-    Won Chun                Luke Graham        Johan Duparc       Nick Verigakis
-    the Horde3D community   Thomas Ruf         Ronny Chevalier    github:rlyeh
-    Janez Zemva             John Bartholomew   Michal Cichon      github:romigrou
-    Jonathan Blow           Ken Hamada         Tero Hanninen      github:svdijk
-    Laurent Gomila          Cort Stratton      Sergio Gonzalez    github:snagar
-    Aruelien Pocheville     Thibault Reuille   Cass Everitt       github:Zelex
-    Ryamond Barbiero        Paul Du Bois       Engin Manap        github:grim210
-    Aldo Culquicondor       Philipp Wiesemann  Dale Weiler        github:sammyhw
-    Oriol Ferrer Mesia      Josh Tobin         Matthew Gregan     github:phprus
-    Julian Raschke          Gregory Mullen     Baldur Karlsson    github:poppolopoppo
-    Christian Floisand      Kevin Schmidt      JR Smith           github:darealshinji
-    Brad Weinberger         Matvey Cherevko                       github:Michaelangel007
-    Blazej Dariusz Roszkowski                  Alexander Veselov
+    Marc LeBlanc            David Woo          Guillaume George     Martins Mozeiko
+    Christpher Lloyd        Jerry Jansson      Joseph Thomson       Blazej Dariusz Roszkowski
+    Phil Jordan                                Dave Moore           Roy Eltham
+    Hayaki Saito            Nathan Reed        Won Chun
+    Luke Graham             Johan Duparc       Nick Verigakis       the Horde3D community
+    Thomas Ruf              Ronny Chevalier                         github:rlyeh
+    Janez Zemva             John Bartholomew   Michal Cichon        github:romigrou
+    Jonathan Blow           Ken Hamada         Tero Hanninen        github:svdijk
+    Eugene Golushkov        Laurent Gomila     Cort Stratton        github:snagar
+    Aruelien Pocheville     Sergio Gonzalez    Thibault Reuille     github:Zelex
+    Cass Everitt            Ryamond Barbiero                        github:grim210
+    Paul Du Bois            Engin Manap        Aldo Culquicondor    github:sammyhw
+    Philipp Wiesemann       Dale Weiler        Oriol Ferrer Mesia   github:phprus
+    Josh Tobin              Neil Bickford      Matthew Gregan       github:poppolopoppo
+    Julian Raschke          Gregory Mullen     Christian Floisand   github:darealshinji
+    Baldur Karlsson         Kevin Schmidt      JR Smith             github:Michaelangel007
+                            Brad Weinberger    Matvey Cherevko      github:mosra
+    Luca Sas                Alexander Veselov  Zack Middleton       [reserved]
+    Ryan C. Gordon          [reserved]                              [reserved]
+                     DO NOT ADD YOUR NAME HERE
+
+                     Jacko Dirks
+
+  To add your name to the credits, pick a random blank space in the middle and fill it.
+  80% of merge conflicts on stb PRs are due to people adding their name at the end
+  of the credits.
 */
 
 #ifndef STBI_INCLUDE_STB_IMAGE_H
 #define STBI_INCLUDE_STB_IMAGE_H
 
 // DOCUMENTATION
 //
@@ -124,15 +137,15 @@
 // Basic usage (see HDR discussion below for HDR usage):
 //    int x,y,n;
 //    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
 //    // ... process data if not NULL ...
 //    // ... x = width, y = height, n = # 8-bit components per pixel ...
 //    // ... replace '0' with '1'..'4' to force that many components per pixel
 //    // ... but 'n' will always be the number that it would have been if you said 0
-//    stbi_image_free(data)
+//    stbi_image_free(data);
 //
 // Standard parameters:
 //    int *x                 -- outputs image width in pixels
 //    int *y                 -- outputs image height in pixels
 //    int *channels_in_file  -- outputs # of image components in image file
 //    int desired_channels   -- if non-zero, # of image components requested in result
 //
@@ -163,14 +176,40 @@
 // stbi_failure_reason() can be queried for an extremely brief, end-user
 // unfriendly explanation of why the load failed. Define STBI_NO_FAILURE_STRINGS
 // to avoid compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
 // more user-friendly ones.
 //
 // Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.
 //
+// To query the width, height and component count of an image without having to
+// decode the full file, you can use the stbi_info family of functions:
+//
+//   int x,y,n,ok;
+//   ok = stbi_info(filename, &x, &y, &n);
+//   // returns ok=1 and sets x, y, n if image is a supported format,
+//   // 0 otherwise.
+//
+// Note that stb_image pervasively uses ints in its public API for sizes,
+// including sizes of memory buffers. This is now part of the API and thus
+// hard to change without causing breakage. As a result, the various image
+// loaders all have certain limits on image size; these differ somewhat
+// by format but generally boil down to either just under 2GB or just under
+// 1GB. When the decoded image would be larger than this, stb_image decoding
+// will fail.
+//
+// Additionally, stb_image will reject image files that have any of their
+// dimensions set to a larger value than the configurable STBI_MAX_DIMENSIONS,
+// which defaults to 2**24 = 16777216 pixels. Due to the above memory limit,
+// the only way to have an image with such dimensions load correctly
+// is for it to have a rather extreme aspect ratio. Either way, the
+// assumption here is that such larger images are likely to be malformed
+// or malicious. If you do need to load an image with individual dimensions
+// larger than that, and it still fits in the overall size limit, you can
+// #define STBI_MAX_DIMENSIONS on your own to be something larger.
+//
 // ===========================================================================
 //
 // UNICODE:
 //
 //   If compiling for Windows and you wish to use Unicode filenames, compile
 //   with
 //       #define STBI_WINDOWS_UTF8
@@ -268,19 +307,18 @@
 //
 //     stbi_is_hdr(char *filename);
 //
 // ===========================================================================
 //
 // iPhone PNG support:
 //
-// By default we convert iphone-formatted PNGs back to RGB, even though
-// they are internally encoded differently. You can disable this conversion
-// by calling stbi_convert_iphone_png_to_rgb(0), in which case
-// you will always just get the native iphone "format" through (which
-// is BGR stored in RGB).
+// We optionally support converting iPhone-formatted PNGs (which store
+// premultiplied BGRA) back to RGB, even though they're internally encoded
+// differently. To enable this conversion, call
+// stbi_convert_iphone_png_to_rgb(1).
 //
 // Call stbi_set_unpremultiply_on_load(1) as well to force a divide per
 // pixel to remove any premultiplied alpha *only* if the image file explicitly
 // says there's premultiplied data (currently only happens in iPhone images,
 // and only if iPhone convert-to-rgb processing is on).
 //
 // ===========================================================================
@@ -314,15 +352,22 @@
 //        STBI_ONLY_HDR
 //        STBI_ONLY_PIC
 //        STBI_ONLY_PNM   (.ppm and .pgm)
 //
 //   - If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still
 //     want the zlib decoder to be available, #define STBI_SUPPORT_ZLIB
 //
-
+//  - If you define STBI_MAX_DIMENSIONS, stb_image will reject images greater
+//    than that size (in either width or height) without further processing.
+//    This is to let programs in the wild set an upper bound to prevent
+//    denial-of-service attacks on untrusted data, as one could generate a
+//    valid image of gigantic dimensions and force stb_image to allocate a
+//    huge block of memory and spend disproportionate time decoding it. By
+//    default this is set to (1 << 24), which is 16777216, but that's still
+//    very big.
 
 #ifndef STBI_NO_STDIO
 #include <stdio.h>
 #endif // STBI_NO_STDIO
 
 #define STBI_VERSION 1
 
@@ -469,14 +514,16 @@
 
 // flip the image vertically, so the first pixel in the output array is the bottom left
 STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);
 
 // as above, but only applies to images loaded on the thread that calls the function
 // this function is only available if your compiler supports thread-local variables;
 // calling it will fail to link if your compiler doesn't
+STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply);
+STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert);
 STBIDEF void stbi_set_flip_vertically_on_load_thread(int flag_true_if_should_flip);
 
 // ZLIB client - used by PNG, available for other purposes
 
 STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
 STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);
 STBIDEF char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
@@ -570,24 +617,30 @@
 #else
    #define stbi_inline __forceinline
 #endif
 
 #ifndef STBI_NO_THREAD_LOCALS
    #if defined(__cplusplus) &&  __cplusplus >= 201103L
       #define STBI_THREAD_LOCAL       thread_local
-   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
-      #define STBI_THREAD_LOCAL       _Thread_local
-   #elif defined(__GNUC__)
+   #elif defined(__GNUC__) && __GNUC__ < 5
       #define STBI_THREAD_LOCAL       __thread
    #elif defined(_MSC_VER)
       #define STBI_THREAD_LOCAL       __declspec(thread)
-#endif
+   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L && !defined(__STDC_NO_THREADS__)
+      #define STBI_THREAD_LOCAL       _Thread_local
+   #endif
+
+   #ifndef STBI_THREAD_LOCAL
+      #if defined(__GNUC__)
+        #define STBI_THREAD_LOCAL       __thread
+      #endif
+   #endif
 #endif
 
-#ifdef _MSC_VER
+#if defined(_MSC_VER) || defined(__SYMBIAN32__)
 typedef unsigned short stbi__uint16;
 typedef   signed short stbi__int16;
 typedef unsigned int   stbi__uint32;
 typedef   signed int   stbi__int32;
 #else
 #include <stdint.h>
 typedef uint16_t stbi__uint16;
@@ -608,15 +661,15 @@
 #ifdef _MSC_VER
 #define STBI_HAS_LROTL
 #endif
 
 #ifdef STBI_HAS_LROTL
    #define stbi_lrot(x,y)  _lrotl(x,y)
 #else
-   #define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (32 - (y))))
+   #define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (-(y) & 31)))
 #endif
 
 #if defined(STBI_MALLOC) && defined(STBI_FREE) && (defined(STBI_REALLOC) || defined(STBI_REALLOC_SIZED))
 // ok
 #elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC) && !defined(STBI_REALLOC_SIZED)
 // ok
 #else
@@ -722,22 +775,29 @@
 // ARM NEON
 #if defined(STBI_NO_SIMD) && defined(STBI_NEON)
 #undef STBI_NEON
 #endif
 
 #ifdef STBI_NEON
 #include <arm_neon.h>
-// assume GCC or Clang on ARM targets
+#ifdef _MSC_VER
+#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name
+#else
 #define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))
 #endif
+#endif
 
 #ifndef STBI_SIMD_ALIGN
 #define STBI_SIMD_ALIGN(type, name) type name
 #endif
 
+#ifndef STBI_MAX_DIMENSIONS
+#define STBI_MAX_DIMENSIONS (1 << 24)
+#endif
+
 ///////////////////////////////////////////////
 //
 //  stbi__context struct and start_xxx functions
 
 // stbi__context structure is our basic context used by all images, so it
 // contains all the IO context, plus some basic image information
 typedef struct
@@ -747,58 +807,66 @@
 
    stbi_io_callbacks io;
    void *io_user_data;
 
    int read_from_callbacks;
    int buflen;
    stbi_uc buffer_start[128];
+   int callback_already_read;
 
    stbi_uc *img_buffer, *img_buffer_end;
    stbi_uc *img_buffer_original, *img_buffer_original_end;
 } stbi__context;
 
 
 static void stbi__refill_buffer(stbi__context *s);
 
 // initialize a memory-decode context
 static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
 {
    s->io.read = NULL;
    s->read_from_callbacks = 0;
+   s->callback_already_read = 0;
    s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;
    s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;
 }
 
 // initialize a callback-based context
 static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
 {
    s->io = *c;
    s->io_user_data = user;
    s->buflen = sizeof(s->buffer_start);
    s->read_from_callbacks = 1;
-   s->img_buffer_original = s->buffer_start;
+   s->callback_already_read = 0;
+   s->img_buffer = s->img_buffer_original = s->buffer_start;
    stbi__refill_buffer(s);
    s->img_buffer_original_end = s->img_buffer_end;
 }
 
 #ifndef STBI_NO_STDIO
 
 static int stbi__stdio_read(void *user, char *data, int size)
 {
    return (int) fread(data,1,size,(FILE*) user);
 }
 
 static void stbi__stdio_skip(void *user, int n)
 {
+   int ch;
    fseek((FILE*) user, n, SEEK_CUR);
+   ch = fgetc((FILE*) user);  /* have to read a byte to reset feof()'s flag */
+   if (ch != EOF) {
+      ungetc(ch, (FILE *) user);  /* push byte back onto stream if valid. */
+   }
 }
 
 static int stbi__stdio_eof(void *user)
 {
-   return feof((FILE*) user);
+   return feof((FILE*) user) || ferror((FILE *) user);
 }
 
 static stbi_io_callbacks stbi__stdio_callbacks =
 {
    stbi__stdio_read,
    stbi__stdio_skip,
    stbi__stdio_eof,
@@ -886,14 +954,15 @@
 static int      stbi__gif_info(stbi__context *s, int *x, int *y, int *comp);
 #endif
 
 #ifndef STBI_NO_PNM
 static int      stbi__pnm_test(stbi__context *s);
 static void    *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
 static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp);
+static int      stbi__pnm_is16(stbi__context *s);
 #endif
 
 static
 #ifdef STBI_THREAD_LOCAL
 STBI_THREAD_LOCAL
 #endif
 const char *stbi__g_failure_reason;
@@ -960,15 +1029,15 @@
 static int stbi__mad3sizes_valid(int a, int b, int c, int add)
 {
    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
       stbi__addsizes_valid(a*b*c, add);
 }
 
 // returns 1 if "a*b*c*d + add" has no negative terms/factors and doesn't overflow
-#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
+#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
 static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
 {
    return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
       stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
 }
 #endif
 
@@ -983,22 +1052,39 @@
 
 static void *stbi__malloc_mad3(int a, int b, int c, int add)
 {
    if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;
    return stbi__malloc(a*b*c + add);
 }
 
-#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
+#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR) || !defined(STBI_NO_PNM)
 static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
 {
    if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
    return stbi__malloc(a*b*c*d + add);
 }
 #endif
 
+// returns 1 if the sum of two signed ints is valid (between -2^31 and 2^31-1 inclusive), 0 on overflow.
+static int stbi__addints_valid(int a, int b)
+{
+   if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow
+   if (a < 0 && b < 0) return a >= INT_MIN - b; // same as a + b >= INT_MIN; INT_MIN - b cannot overflow since b < 0.
+   return a <= INT_MAX - b;
+}
+
+// returns 1 if the product of two signed shorts is valid, 0 on overflow.
+static int stbi__mul2shorts_valid(short a, short b)
+{
+   if (b == 0 || b == -1) return 1; // multiplication by 0 is always 0; check for -1 so SHRT_MIN/b doesn't overflow
+   if ((a >= 0) == (b >= 0)) return a <= SHRT_MAX/b; // product is positive, so similar to mul2sizes_valid
+   if (b < 0) return a <= SHRT_MIN / b; // same as a * b >= SHRT_MIN
+   return a >= SHRT_MIN / b;
+}
+
 // stbi__err - error
 // stbi__errpf - error returning pointer to float
 // stbi__errpuc - error returning pointer to unsigned char
 
 #ifdef STBI_NO_FAILURE_STRINGS
    #define stbi__err(x,y)  0
 #elif defined(STBI_FAILURE_USERMSG)
@@ -1049,17 +1135,16 @@
 static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
 {
    memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
    ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
    ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
    ri->num_channels = 0;
 
-   #ifndef STBI_NO_JPEG
-   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
-   #endif
+   // test the formats with a very explicit header first (at least a FOURCC
+   // or distinctive magic number first)
    #ifndef STBI_NO_PNG
    if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
    #endif
    #ifndef STBI_NO_BMP
    if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
    #endif
    #ifndef STBI_NO_GIF
@@ -1069,14 +1154,21 @@
    if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
    #else
    STBI_NOTUSED(bpc);
    #endif
    #ifndef STBI_NO_PIC
    if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
    #endif
+
+   // then the formats that can end up attempting to load with just 1 or 2
+   // bytes matching expectations; these are prone to false positives, so
+   // try them later
+   #ifndef STBI_NO_JPEG
+   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
+   #endif
    #ifndef STBI_NO_PNM
    if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
    #endif
 
    #ifndef STBI_NO_HDR
    if (stbi__hdr_test(s)) {
       float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
@@ -1167,16 +1259,18 @@
 {
    stbi__result_info ri;
    void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);
 
    if (result == NULL)
       return NULL;
 
+   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
+   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);
+
    if (ri.bits_per_channel != 8) {
-      STBI_ASSERT(ri.bits_per_channel == 16);
       result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
       ri.bits_per_channel = 8;
    }
 
    // @TODO: move stbi__convert_format to here
 
    if (stbi__vertically_flip_on_load) {
@@ -1191,16 +1285,18 @@
 {
    stbi__result_info ri;
    void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);
 
    if (result == NULL)
       return NULL;
 
+   // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
+   STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);
+
    if (ri.bits_per_channel != 16) {
-      STBI_ASSERT(ri.bits_per_channel == 8);
       result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
       ri.bits_per_channel = 16;
    }
 
    // @TODO: move stbi__convert_format16 to here
    // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision
 
@@ -1220,39 +1316,39 @@
       stbi__vertical_flip(result, *x, *y, channels * sizeof(float));
    }
 }
 #endif
 
 #ifndef STBI_NO_STDIO
 
-#if defined(_MSC_VER) && defined(STBI_WINDOWS_UTF8)
+#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
 STBI_EXTERN __declspec(dllimport) int __stdcall MultiByteToWideChar(unsigned int cp, unsigned long flags, const char *str, int cbmb, wchar_t *widestr, int cchwide);
 STBI_EXTERN __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, const wchar_t *widestr, int cchwide, char *str, int cbmb, const char *defchar, int *used_default);
 #endif
 
-#if defined(_MSC_VER) && defined(STBI_WINDOWS_UTF8)
+#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
 STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)
 {
 	return WideCharToMultiByte(65001 /* UTF8 */, 0, input, -1, buffer, (int) bufferlen, NULL, NULL);
 }
 #endif
 
 static FILE *stbi__fopen(char const *filename, char const *mode)
 {
    FILE *f;
-#if defined(_MSC_VER) && defined(STBI_WINDOWS_UTF8)
+#if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
    wchar_t wMode[64];
    wchar_t wFilename[1024];
-	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)))
+	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
       return 0;
 
-	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)))
+	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
       return 0;
 
-#if _MSC_VER >= 1400
+#if defined(_MSC_VER) && _MSC_VER >= 1400
 	if (0 != _wfopen_s(&f, wFilename, wMode))
 		f = 0;
 #else
    f = _wfopen(wFilename, wMode);
 #endif
 
 #elif defined(_MSC_VER) && _MSC_VER >= 1400
@@ -1495,14 +1591,15 @@
    STBI__SCAN_type,
    STBI__SCAN_header
 };
 
 static void stbi__refill_buffer(stbi__context *s)
 {
    int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
+   s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);
    if (n == 0) {
       // at end of file, treat same as if from memory, but need to handle case
       // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
       s->read_from_callbacks = 0;
       s->img_buffer = s->buffer_start;
       s->img_buffer_end = s->buffer_start+1;
       *s->img_buffer = 0;
@@ -1540,14 +1637,15 @@
 #endif
 
 #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC)
 // nothing
 #else
 static void stbi__skip(stbi__context *s, int n)
 {
+   if (n == 0) return;  // already there!
    if (n < 0) {
       s->img_buffer = s->img_buffer_end;
       return;
    }
    if (s->io.read) {
       int blen = (int) (s->img_buffer_end - s->img_buffer);
       if (blen < n) {
@@ -1618,15 +1716,16 @@
 }
 #endif
 
 #ifndef STBI_NO_BMP
 static stbi__uint32 stbi__get32le(stbi__context *s)
 {
    stbi__uint32 z = stbi__get16le(s);
-   return z + (stbi__get16le(s) << 16);
+   z += (stbi__uint32)stbi__get16le(s) << 16;
+   return z;
 }
 #endif
 
 #define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings
 
 #if defined(STBI_NO_JPEG) && defined(STBI_NO_PNG) && defined(STBI_NO_BMP) && defined(STBI_NO_PSD) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF) && defined(STBI_NO_PIC) && defined(STBI_NO_PNM)
 // nothing
@@ -1682,15 +1781,15 @@
          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;
          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;
          STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
          STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;
          STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
          STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;
          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;
-         default: STBI_ASSERT(0);
+         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");
       }
       #undef STBI__CASE
    }
 
    STBI_FREE(data);
    return good;
 }
@@ -1739,15 +1838,15 @@
          STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;
          STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;
          STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
          STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;
          STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
          STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;
          STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;
-         default: STBI_ASSERT(0);
+         default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");
       }
       #undef STBI__CASE
    }
 
    STBI_FREE(data);
    return good;
 }
@@ -1900,17 +1999,20 @@
 } stbi__jpeg;
 
 static int stbi__build_huffman(stbi__huffman *h, int *count)
 {
    int i,j,k=0;
    unsigned int code;
    // build size list for each symbol (from JPEG spec)
-   for (i=0; i < 16; ++i)
-      for (j=0; j < count[i]; ++j)
+   for (i=0; i < 16; ++i) {
+      for (j=0; j < count[i]; ++j) {
          h->size[k++] = (stbi_uc) (i+1);
+         if(k >= 257) return stbi__err("bad size list","Corrupt JPEG");
+      }
+   }
    h->size[k] = 0;
 
    // compute actual symbols (from jpeg spec)
    code = 0;
    k = 0;
    for(j=1; j <= 16; ++j) {
       // compute delta to add to code to compute symbol id
@@ -2027,14 +2129,16 @@
    }
 
    if (k > j->code_bits)
       return -1;
 
    // convert the huffman code to the symbol id
    c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
+   if(c < 0 || c >= 256) // symbol id out of bounds!
+       return -1;
    STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);
 
    // convert the id to a symbol
    j->code_bits -= k;
    j->code_buffer <<= k;
    return h->values[c];
 }
@@ -2045,40 +2149,42 @@
 // combined JPEG 'receive' and JPEG 'extend', since baseline
 // always extends everything it receives.
 stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
 {
    unsigned int k;
    int sgn;
    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
+   if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
 
-   sgn = (stbi__int32)j->code_buffer >> 31; // sign bit is always in MSB
+   sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)
    k = stbi_lrot(j->code_buffer, n);
-   STBI_ASSERT(n >= 0 && n < (int) (sizeof(stbi__bmask)/sizeof(*stbi__bmask)));
    j->code_buffer = k & ~stbi__bmask[n];
    k &= stbi__bmask[n];
    j->code_bits -= n;
-   return k + (stbi__jbias[n] & ~sgn);
+   return k + (stbi__jbias[n] & (sgn - 1));
 }
 
 // get some unsigned bits
 stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
 {
    unsigned int k;
    if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
+   if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing
    k = stbi_lrot(j->code_buffer, n);
    j->code_buffer = k & ~stbi__bmask[n];
    k &= stbi__bmask[n];
    j->code_bits -= n;
    return k;
 }
 
 stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
 {
    unsigned int k;
    if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
+   if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing
    k = j->code_buffer;
    j->code_buffer <<= 1;
    --j->code_bits;
    return k & 0x80000000;
 }
 
 // given a value that's at position X in the zigzag stream,
@@ -2102,35 +2208,38 @@
 static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
 {
    int diff,dc,k;
    int t;
 
    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
    t = stbi__jpeg_huff_decode(j, hdc);
-   if (t < 0) return stbi__err("bad huffman code","Corrupt JPEG");
+   if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");
 
    // 0 all the ac values now so we can do it 32-bits at a time
    memset(data,0,64*sizeof(data[0]));
 
    diff = t ? stbi__extend_receive(j, t) : 0;
+   if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta","Corrupt JPEG");
    dc = j->img_comp[b].dc_pred + diff;
    j->img_comp[b].dc_pred = dc;
+   if ((dc > SHRT_MAX) || (dequant[0] > SHRT_MAX) || !stbi__mul2shorts_valid((short) dc, (short) dequant[0])) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
    data[0] = (short) (dc * dequant[0]);
 
    // decode AC components, see JPEG spec
    k = 1;
    do {
       unsigned int zig;
       int c,r,s;
       if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
       c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
       r = fac[c];
       if (r) { // fast-AC path
          k += (r >> 4) & 15; // run
          s = r & 15; // combined length
+         if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
          j->code_buffer <<= s;
          j->code_bits -= s;
          // decode into unzigzag'd location
          zig = stbi__jpeg_dezigzag[k++];
          data[zig] = (short) ((r >> 8) * dequant[zig]);
       } else {
          int rs = stbi__jpeg_huff_decode(j, hac);
@@ -2159,19 +2268,22 @@
 
    if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
 
    if (j->succ_high == 0) {
       // first scan for DC coefficient, must be first
       memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
       t = stbi__jpeg_huff_decode(j, hdc);
+      if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
       diff = t ? stbi__extend_receive(j, t) : 0;
 
+      if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta", "Corrupt JPEG");
       dc = j->img_comp[b].dc_pred + diff;
       j->img_comp[b].dc_pred = dc;
-      data[0] = (short) (dc << j->succ_low);
+      if ((dc > SHRT_MAX) || !stbi__mul2shorts_valid((short) dc, 1 << j->succ_low)) return stbi__err("can't merge dc and ac", "Corrupt JPEG");
+      data[0] = (short) (dc * (1 << j->succ_low));
    } else {
       // refinement scan for DC coefficient
       if (stbi__jpeg_get_bit(j))
          data[0] += (short) (1 << j->succ_low);
    }
    return 1;
 }
@@ -2197,18 +2309,19 @@
          int c,r,s;
          if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
          c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
          r = fac[c];
          if (r) { // fast-AC path
             k += (r >> 4) & 15; // run
             s = r & 15; // combined length
+            if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");
             j->code_buffer <<= s;
             j->code_bits -= s;
             zig = stbi__jpeg_dezigzag[k++];
-            data[zig] = (short) ((r >> 8) << shift);
+            data[zig] = (short) ((r >> 8) * (1 << shift));
          } else {
             int rs = stbi__jpeg_huff_decode(j, hac);
             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
             s = rs & 15;
             r = rs >> 4;
             if (s == 0) {
                if (r < 15) {
@@ -2218,15 +2331,15 @@
                   --j->eob_run;
                   break;
                }
                k += 16;
             } else {
                k += r;
                zig = stbi__jpeg_dezigzag[k++];
-               data[zig] = (short) (stbi__extend_receive(j,s) << shift);
+               data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));
             }
          }
       } while (k <= j->spec_end);
    } else {
       // refinement scan for these AC coefficients
 
       short bit = (short) (1 << j->succ_low);
@@ -3017,14 +3130,15 @@
             int tc = q >> 4;
             int th = q & 15;
             if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
             for (i=0; i < 16; ++i) {
                sizes[i] = stbi__get8(z->s);
                n += sizes[i];
             }
+            if(n > 256) return stbi__err("bad DHT header","Corrupt JPEG"); // Loop over i < n would write past end of values!
             L -= 17;
             if (tc == 0) {
                if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
                v = z->huff_dc[th].values;
             } else {
                if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
                v = z->huff_ac[th].values;
@@ -3149,14 +3263,16 @@
 {
    stbi__context *s = z->s;
    int Lf,p,i,q, h_max=1,v_max=1,c;
    Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG
    p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
    s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
    s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
+   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
+   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
    c = stbi__get8(s);
    if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");
    s->img_n = c;
    for (i=0; i < c; ++i) {
       z->img_comp[i].data = NULL;
       z->img_comp[i].linebuf = NULL;
    }
@@ -3180,14 +3296,21 @@
    if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");
 
    for (i=0; i < s->img_n; ++i) {
       if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
       if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
    }
 
+   // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
+   // and I've never seen a non-corrupted JPEG file actually use them
+   for (i=0; i < s->img_n; ++i) {
+      if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H","Corrupt JPEG");
+      if (v_max % z->img_comp[i].v != 0) return stbi__err("bad V","Corrupt JPEG");
+   }
+
    // compute interleaved mcu info
    z->img_h_max = h_max;
    z->img_v_max = v_max;
    z->img_mcu_w = h_max * 8;
    z->img_mcu_h = v_max * 8;
    // these sizes can't be more than 17 bits
    z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
@@ -3257,14 +3380,36 @@
       }
    }
    z->progressive = stbi__SOF_progressive(m);
    if (!stbi__process_frame_header(z, scan)) return 0;
    return 1;
 }
 
+static stbi_uc stbi__skip_jpeg_junk_at_end(stbi__jpeg *j)
+{
+   // some JPEGs have junk at end, skip over it but if we find what looks
+   // like a valid marker, resume there
+   while (!stbi__at_eof(j->s)) {
+      stbi_uc x = stbi__get8(j->s);
+      while (x == 255) { // might be a marker
+         if (stbi__at_eof(j->s)) return STBI__MARKER_none;
+         x = stbi__get8(j->s);
+         if (x != 0x00 && x != 0xff) {
+            // not a stuffed zero or lead-in to another marker, looks
+            // like an actual marker, return it
+            return x;
+         }
+         // stuffed zero has x=0 now which ends the loop, meaning we go
+         // back to regular scan loop.
+         // repeated 0xff keeps trying to read the next byte of the marker.
+      }
+   }
+   return STBI__MARKER_none;
+}
+
 // decode image to YCbCr format
 static int stbi__decode_jpeg_image(stbi__jpeg *j)
 {
    int m;
    for (m = 0; m < 4; m++) {
       j->img_comp[m].raw_data = NULL;
       j->img_comp[m].raw_coeff = NULL;
@@ -3273,33 +3418,30 @@
    if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
    m = stbi__get_marker(j);
    while (!stbi__EOI(m)) {
       if (stbi__SOS(m)) {
          if (!stbi__process_scan_header(j)) return 0;
          if (!stbi__parse_entropy_coded_data(j)) return 0;
          if (j->marker == STBI__MARKER_none ) {
-            // handle 0s at the end of image data from IP Kamera 9060
-            while (!stbi__at_eof(j->s)) {
-               int x = stbi__get8(j->s);
-               if (x == 255) {
-                  j->marker = stbi__get8(j->s);
-                  break;
-               }
-            }
+         j->marker = stbi__skip_jpeg_junk_at_end(j);
             // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
          }
+         m = stbi__get_marker(j);
+         if (STBI__RESTART(m))
+            m = stbi__get_marker(j);
       } else if (stbi__DNL(m)) {
          int Ld = stbi__get16be(j->s);
          stbi__uint32 NL = stbi__get16be(j->s);
          if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");
          if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");
+         m = stbi__get_marker(j);
       } else {
-         if (!stbi__process_marker(j, m)) return 0;
+         if (!stbi__process_marker(j, m)) return 1;
+         m = stbi__get_marker(j);
       }
-      m = stbi__get_marker(j);
    }
    if (j->progressive)
       stbi__jpeg_finish(j);
    return 1;
 }
 
 // static jfif-centered resampling (across block boundaries)
@@ -3735,14 +3877,18 @@
    is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));
 
    if (z->s->img_n == 3 && n < 3 && !is_rgb)
       decode_n = 1;
    else
       decode_n = z->s->img_n;
 
+   // nothing to do if no components requested; check this now to avoid
+   // accessing uninitialized coutput[0] later
+   if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }
+
    // resample and color-convert
    {
       int k;
       unsigned int i,j;
       stbi_uc *output;
       stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };
 
@@ -3877,26 +4023,30 @@
    }
 }
 
 static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
 {
    unsigned char* result;
    stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
+   if (!j) return stbi__errpuc("outofmem", "Out of memory");
+   memset(j, 0, sizeof(stbi__jpeg));
    STBI_NOTUSED(ri);
    j->s = s;
    stbi__setup_jpeg(j);
    result = load_jpeg_image(j, x,y,comp,req_comp);
    STBI_FREE(j);
    return result;
 }
 
 static int stbi__jpeg_test(stbi__context *s)
 {
    int r;
    stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
+   if (!j) return stbi__err("outofmem", "Out of memory");
+   memset(j, 0, sizeof(stbi__jpeg));
    j->s = s;
    stbi__setup_jpeg(j);
    r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
    stbi__rewind(s);
    STBI_FREE(j);
    return r;
 }
@@ -3913,14 +4063,16 @@
    return 1;
 }
 
 static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
 {
    int result;
    stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
+   if (!j) return stbi__err("outofmem", "Out of memory");
+   memset(j, 0, sizeof(stbi__jpeg));
    j->s = s;
    result = stbi__jpeg_info_raw(j, x, y, comp);
    STBI_FREE(j);
    return result;
 }
 #endif
 
@@ -3932,25 +4084,26 @@
 //      - fast huffman
 
 #ifndef STBI_NO_ZLIB
 
 // fast-way is faster to check than jpeg huffman, but slow way is slower
 #define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
 #define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)
+#define STBI__ZNSYMS 288 // number of symbols in literal/length alphabet
 
 // zlib-style huffman encoding
 // (jpegs packs from left, zlib from right, so can't share code)
 typedef struct
 {
    stbi__uint16 fast[1 << STBI__ZFAST_BITS];
    stbi__uint16 firstcode[16];
    int maxcode[17];
    stbi__uint16 firstsymbol[16];
-   stbi_uc  size[288];
-   stbi__uint16 value[288];
+   stbi_uc  size[STBI__ZNSYMS];
+   stbi__uint16 value[STBI__ZNSYMS];
 } stbi__zhuffman;
 
 stbi_inline static int stbi__bitreverse16(int n)
 {
   n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
   n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
   n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
@@ -4019,34 +4172,42 @@
 //    we require PNG read all the IDATs and combine them into a single
 //    memory buffer
 
 typedef struct
 {
    stbi_uc *zbuffer, *zbuffer_end;
    int num_bits;
+   int hit_zeof_once;
    stbi__uint32 code_buffer;
 
    char *zout;
    char *zout_start;
    char *zout_end;
    int   z_expandable;
 
    stbi__zhuffman z_length, z_distance;
 } stbi__zbuf;
 
+stbi_inline static int stbi__zeof(stbi__zbuf *z)
+{
+   return (z->zbuffer >= z->zbuffer_end);
+}
+
 stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)
 {
-   if (z->zbuffer >= z->zbuffer_end) return 0;
-   return *z->zbuffer++;
+   return stbi__zeof(z) ? 0 : *z->zbuffer++;
 }
 
 static void stbi__fill_bits(stbi__zbuf *z)
 {
    do {
-      STBI_ASSERT(z->code_buffer < (1U << z->num_bits));
+      if (z->code_buffer >= (1U << z->num_bits)) {
+        z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */
+        return;
+      }
       z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
       z->num_bits += 8;
    } while (z->num_bits <= 24);
 }
 
 stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
 {
@@ -4063,47 +4224,67 @@
    int b,s,k;
    // not resolved by fast table, so compute it the slow way
    // use jpeg approach, which requires MSbits at top
    k = stbi__bit_reverse(a->code_buffer, 16);
    for (s=STBI__ZFAST_BITS+1; ; ++s)
       if (k < z->maxcode[s])
          break;
-   if (s == 16) return -1; // invalid code!
+   if (s >= 16) return -1; // invalid code!
    // code size is s, so:
    b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
-   STBI_ASSERT(z->size[b] == s);
+   if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!
+   if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.
    a->code_buffer >>= s;
    a->num_bits -= s;
    return z->value[b];
 }
 
 stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
 {
    int b,s;
-   if (a->num_bits < 16) stbi__fill_bits(a);
+   if (a->num_bits < 16) {
+      if (stbi__zeof(a)) {
+         if (!a->hit_zeof_once) {
+            // This is the first time we hit eof, insert 16 extra padding btis
+            // to allow us to keep going; if we actually consume any of them
+            // though, that is invalid data. This is caught later.
+            a->hit_zeof_once = 1;
+            a->num_bits += 16; // add 16 implicit zero bits
+         } else {
+            // We already inserted our extra 16 padding bits and are again
+            // out, this stream is actually prematurely terminated.
+            return -1;
+         }
+      } else {
+         stbi__fill_bits(a);
+      }
+   }
    b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
    if (b) {
       s = b >> 9;
       a->code_buffer >>= s;
       a->num_bits -= s;
       return b & 511;
    }
    return stbi__zhuffman_decode_slowpath(a, z);
 }
 
 static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
 {
    char *q;
-   int cur, limit, old_limit;
+   unsigned int cur, limit, old_limit;
    z->zout = zout;
    if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");
-   cur   = (int) (z->zout     - z->zout_start);
-   limit = old_limit = (int) (z->zout_end - z->zout_start);
-   while (cur + n > limit)
+   cur   = (unsigned int) (z->zout - z->zout_start);
+   limit = old_limit = (unsigned) (z->zout_end - z->zout_start);
+   if (UINT_MAX - cur < (unsigned) n) return stbi__err("outofmem", "Out of memory");
+   while (cur + n > limit) {
+      if(limit > UINT_MAX / 2) return stbi__err("outofmem", "Out of memory");
       limit *= 2;
+   }
    q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
    STBI_NOTUSED(old_limit);
    if (q == NULL) return stbi__err("outofmem", "Out of memory");
    z->zout_start = q;
    z->zout       = q + cur;
    z->zout_end   = q + limit;
    return 1;
@@ -4136,25 +4317,33 @@
          }
          *zout++ = (char) z;
       } else {
          stbi_uc *p;
          int len,dist;
          if (z == 256) {
             a->zout = zout;
+            if (a->hit_zeof_once && a->num_bits < 16) {
+               // The first time we hit zeof, we inserted 16 extra zero bits into our bit
+               // buffer so the decoder can just do its speculative decoding. But if we
+               // actually consumed any of those bits (which is the case when num_bits < 16),
+               // the stream actually read past the end so it is malformed.
+               return stbi__err("unexpected end","Corrupt PNG");
+            }
             return 1;
          }
+         if (z >= 286) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, length codes 286 and 287 must not appear in compressed data
          z -= 257;
          len = stbi__zlength_base[z];
          if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
          z = stbi__zhuffman_decode(a, &a->z_distance);
-         if (z < 0) return stbi__err("bad huffman code","Corrupt PNG");
+         if (z < 0 || z >= 30) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, distance codes 30 and 31 must not appear in compressed data
          dist = stbi__zdist_base[z];
          if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
          if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");
-         if (zout + len > a->zout_end) {
+         if (len > a->zout_end - zout) {
             if (!stbi__zexpand(a, zout, len)) return 0;
             zout = a->zout;
          }
          p = (stbi_uc *) (zout - dist);
          if (dist == 1) { // run of one byte; common in images.
             stbi_uc v = *p;
             if (len) { do *zout++ = v; while (--len); }
@@ -4193,19 +4382,20 @@
          lencodes[n++] = (stbi_uc) c;
       else {
          stbi_uc fill = 0;
          if (c == 16) {
             c = stbi__zreceive(a,2)+3;
             if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");
             fill = lencodes[n-1];
-         } else if (c == 17)
+         } else if (c == 17) {
             c = stbi__zreceive(a,3)+3;
-         else {
-            STBI_ASSERT(c == 18);
+         } else if (c == 18) {
             c = stbi__zreceive(a,7)+11;
+         } else {
+            return stbi__err("bad codelengths", "Corrupt PNG");
          }
          if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");
          memset(lencodes+n, fill, c);
          n += c;
       }
    }
    if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");
@@ -4223,15 +4413,15 @@
    // drain the bit-packed data into header
    k = 0;
    while (a->num_bits > 0) {
       header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
       a->code_buffer >>= 8;
       a->num_bits -= 8;
    }
-   STBI_ASSERT(a->num_bits == 0);
+   if (a->num_bits < 0) return stbi__err("zlib corrupt","Corrupt PNG");
    // now fill header the normal way
    while (k < 4)
       header[k++] = stbi__zget8(a);
    len  = header[1] * 256 + header[0];
    nlen = header[3] * 256 + header[2];
    if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");
    if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");
@@ -4245,22 +4435,23 @@
 
 static int stbi__parse_zlib_header(stbi__zbuf *a)
 {
    int cmf   = stbi__zget8(a);
    int cm    = cmf & 15;
    /* int cinfo = cmf >> 4; */
    int flg   = stbi__zget8(a);
+   if (stbi__zeof(a)) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
    if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
    if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
    if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png
    // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
    return 1;
 }
 
-static const stbi_uc stbi__zdefault_length[288] =
+static const stbi_uc stbi__zdefault_length[STBI__ZNSYMS] =
 {
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
@@ -4288,25 +4479,26 @@
 static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
 {
    int final, type;
    if (parse_header)
       if (!stbi__parse_zlib_header(a)) return 0;
    a->num_bits = 0;
    a->code_buffer = 0;
+   a->hit_zeof_once = 0;
    do {
       final = stbi__zreceive(a,1);
       type = stbi__zreceive(a,2);
       if (type == 0) {
          if (!stbi__parse_uncompressed_block(a)) return 0;
       } else if (type == 3) {
          return 0;
       } else {
          if (type == 1) {
             // use fixed code lengths
-            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , 288)) return 0;
+            if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;
             if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
          } else {
             if (!stbi__compute_huffman_codes(a)) return 0;
          }
          if (!stbi__parse_huffman_block(a)) return 0;
       }
    } while (!final);
@@ -4506,15 +4698,15 @@
       stbi_uc *prior;
       int filter = *raw++;
 
       if (filter > 4)
          return stbi__err("invalid filter","Corrupt PNG");
 
       if (depth < 8) {
-         STBI_ASSERT(img_width_bytes <= x);
+         if (img_width_bytes > x) return stbi__err("invalid width","Corrupt PNG");
          cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
          filter_bytes = 1;
          width = img_width_bytes;
       }
       prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above
 
       // if first row, use special filter that doesn't sample previous row
@@ -4694,14 +4886,15 @@
    stbi_uc *final;
    int p;
    if (!interlaced)
       return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);
 
    // de-interlacing
    final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
+   if (!final) return stbi__err("outofmem", "Out of memory");
    for (p=0; p < 7; ++p) {
       int xorig[] = { 0,4,0,2,0,1,0 };
       int yorig[] = { 0,0,4,0,2,0,1 };
       int xspc[]  = { 8,8,4,4,2,2,1 };
       int yspc[]  = { 8,8,8,4,4,2,2 };
       int i,j,x,y;
       // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
@@ -4814,27 +5007,54 @@
    a->out = temp_out;
 
    STBI_NOTUSED(len);
 
    return 1;
 }
 
-static int stbi__unpremultiply_on_load = 0;
-static int stbi__de_iphone_flag = 0;
+static int stbi__unpremultiply_on_load_global = 0;
+static int stbi__de_iphone_flag_global = 0;
 
 STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
 {
-   stbi__unpremultiply_on_load = flag_true_if_should_unpremultiply;
+   stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;
 }
 
 STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
 {
-   stbi__de_iphone_flag = flag_true_if_should_convert;
+   stbi__de_iphone_flag_global = flag_true_if_should_convert;
 }
 
+#ifndef STBI_THREAD_LOCAL
+#define stbi__unpremultiply_on_load  stbi__unpremultiply_on_load_global
+#define stbi__de_iphone_flag  stbi__de_iphone_flag_global
+#else
+static STBI_THREAD_LOCAL int stbi__unpremultiply_on_load_local, stbi__unpremultiply_on_load_set;
+static STBI_THREAD_LOCAL int stbi__de_iphone_flag_local, stbi__de_iphone_flag_set;
+
+STBIDEF void stbi_set_unpremultiply_on_load_thread(int flag_true_if_should_unpremultiply)
+{
+   stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;
+   stbi__unpremultiply_on_load_set = 1;
+}
+
+STBIDEF void stbi_convert_iphone_png_to_rgb_thread(int flag_true_if_should_convert)
+{
+   stbi__de_iphone_flag_local = flag_true_if_should_convert;
+   stbi__de_iphone_flag_set = 1;
+}
+
+#define stbi__unpremultiply_on_load  (stbi__unpremultiply_on_load_set           \
+                                       ? stbi__unpremultiply_on_load_local      \
+                                       : stbi__unpremultiply_on_load_global)
+#define stbi__de_iphone_flag  (stbi__de_iphone_flag_set                         \
+                                ? stbi__de_iphone_flag_local                    \
+                                : stbi__de_iphone_flag_global)
+#endif // STBI_THREAD_LOCAL
+
 static void stbi__de_iphone(stbi__png *z)
 {
    stbi__context *s = z->s;
    stbi__uint32 i, pixel_count = s->img_x * s->img_y;
    stbi_uc *p = z->out;
 
    if (s->img_out_n == 3) {  // convert bgr to rgb
@@ -4901,35 +5121,36 @@
             stbi__skip(s, c.length);
             break;
          case STBI__PNG_TYPE('I','H','D','R'): {
             int comp,filter;
             if (!first) return stbi__err("multiple IHDR","Corrupt PNG");
             first = 0;
             if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");
-            s->img_x = stbi__get32be(s); if (s->img_x > (1 << 24)) return stbi__err("too large","Very large image (corrupt?)");
-            s->img_y = stbi__get32be(s); if (s->img_y > (1 << 24)) return stbi__err("too large","Very large image (corrupt?)");
+            s->img_x = stbi__get32be(s);
+            s->img_y = stbi__get32be(s);
+            if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
+            if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
             z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");
             color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");
             if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");
             if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");
             comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");
             filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");
             interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");
             if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");
             if (!pal_img_n) {
                s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
                if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
-               if (scan == STBI__SCAN_header) return 1;
             } else {
                // if paletted, then pal_n is our final components, and
                // img_n is # components to decompress/filter.
                s->img_n = 1;
                if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
-               // if SCAN_header, have to scan to see if we have a tRNS
             }
+            // even with SCAN_header, have to scan to see if we have a tRNS
             break;
          }
 
          case STBI__PNG_TYPE('P','L','T','E'):  {
             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
             if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");
             pal_len = c.length / 3;
@@ -4953,27 +5174,35 @@
                pal_img_n = 4;
                for (i=0; i < c.length; ++i)
                   palette[i*4+3] = stbi__get8(s);
             } else {
                if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");
                if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");
                has_trans = 1;
+               // non-paletted with tRNS = constant alpha. if header-scanning, we can stop now.
+               if (scan == STBI__SCAN_header) { ++s->img_n; return 1; }
                if (z->depth == 16) {
                   for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
                } else {
                   for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
                }
             }
             break;
          }
 
          case STBI__PNG_TYPE('I','D','A','T'): {
             if (first) return stbi__err("first not IHDR", "Corrupt PNG");
             if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");
-            if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }
+            if (scan == STBI__SCAN_header) {
+               // header scan definitely stops at first IDAT
+               if (pal_img_n)
+                  s->img_n = pal_img_n;
+               return 1;
+            }
+            if (c.length > (1u << 30)) return stbi__err("IDAT size limit", "IDAT section larger than 2^30 bytes");
             if ((int)(ioff + c.length) < (int)ioff) return 0;
             if (ioff + c.length > idata_limit) {
                stbi__uint32 idata_limit_old = idata_limit;
                stbi_uc *p;
                if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
                while (ioff + c.length > idata_limit)
                   idata_limit *= 2;
@@ -5051,18 +5280,20 @@
 }
 
 static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
 {
    void *result=NULL;
    if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
    if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
-      if (p->depth < 8)
+      if (p->depth <= 8)
          ri->bits_per_channel = 8;
+      else if (p->depth == 16)
+         ri->bits_per_channel = 16;
       else
-         ri->bits_per_channel = p->depth;
+         return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");
       result = p->out;
       p->out = NULL;
       if (req_comp && req_comp != p->s->img_out_n) {
          if (ri->bits_per_channel == 8)
             result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
          else
             result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
@@ -5203,85 +5434,108 @@
 typedef struct
 {
    int bpp, offset, hsz;
    unsigned int mr,mg,mb,ma, all_a;
    int extra_read;
 } stbi__bmp_data;
 
+static int stbi__bmp_set_mask_defaults(stbi__bmp_data *info, int compress)
+{
+   // BI_BITFIELDS specifies masks explicitly, don't override
+   if (compress == 3)
+      return 1;
+
+   if (compress == 0) {
+      if (info->bpp == 16) {
+         info->mr = 31u << 10;
+         info->mg = 31u <<  5;
+         info->mb = 31u <<  0;
+      } else if (info->bpp == 32) {
+         info->mr = 0xffu << 16;
+         info->mg = 0xffu <<  8;
+         info->mb = 0xffu <<  0;
+         info->ma = 0xffu << 24;
+         info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
+      } else {
+         // otherwise, use defaults, which is all-0
+         info->mr = info->mg = info->mb = info->ma = 0;
+      }
+      return 1;
+   }
+   return 0; // error
+}
+
 static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
 {
    int hsz;
    if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
    stbi__get32le(s); // discard filesize
    stbi__get16le(s); // discard reserved
    stbi__get16le(s); // discard reserved
    info->offset = stbi__get32le(s);
    info->hsz = hsz = stbi__get32le(s);
    info->mr = info->mg = info->mb = info->ma = 0;
    info->extra_read = 14;
 
+   if (info->offset < 0) return stbi__errpuc("bad BMP", "bad BMP");
+
    if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
    if (hsz == 12) {
       s->img_x = stbi__get16le(s);
       s->img_y = stbi__get16le(s);
    } else {
       s->img_x = stbi__get32le(s);
       s->img_y = stbi__get32le(s);
    }
    if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
    info->bpp = stbi__get16le(s);
    if (hsz != 12) {
       int compress = stbi__get32le(s);
       if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
+      if (compress >= 4) return stbi__errpuc("BMP JPEG/PNG", "BMP type not supported: unsupported compression"); // this includes PNG/JPEG modes
+      if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc("bad BMP", "bad BMP"); // bitfields requires 16 or 32 bits/pixel
       stbi__get32le(s); // discard sizeof
       stbi__get32le(s); // discard hres
       stbi__get32le(s); // discard vres
       stbi__get32le(s); // discard colorsused
       stbi__get32le(s); // discard max important
       if (hsz == 40 || hsz == 56) {
          if (hsz == 56) {
             stbi__get32le(s);
             stbi__get32le(s);
             stbi__get32le(s);
             stbi__get32le(s);
          }
          if (info->bpp == 16 || info->bpp == 32) {
             if (compress == 0) {
-               if (info->bpp == 32) {
-                  info->mr = 0xffu << 16;
-                  info->mg = 0xffu <<  8;
-                  info->mb = 0xffu <<  0;
-                  info->ma = 0xffu << 24;
-                  info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
-               } else {
-                  info->mr = 31u << 10;
-                  info->mg = 31u <<  5;
-                  info->mb = 31u <<  0;
-               }
+               stbi__bmp_set_mask_defaults(info, compress);
             } else if (compress == 3) {
                info->mr = stbi__get32le(s);
                info->mg = stbi__get32le(s);
                info->mb = stbi__get32le(s);
                info->extra_read += 12;
                // not documented, but generated by photoshop and handled by mspaint
                if (info->mr == info->mg && info->mg == info->mb) {
                   // ?!?!?
                   return stbi__errpuc("bad BMP", "bad BMP");
                }
             } else
                return stbi__errpuc("bad BMP", "bad BMP");
          }
       } else {
+         // V4/V5 header
          int i;
          if (hsz != 108 && hsz != 124)
             return stbi__errpuc("bad BMP", "bad BMP");
          info->mr = stbi__get32le(s);
          info->mg = stbi__get32le(s);
          info->mb = stbi__get32le(s);
          info->ma = stbi__get32le(s);
+         if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs
+            stbi__bmp_set_mask_defaults(info, compress);
          stbi__get32le(s); // discard color space
          for (i=0; i < 12; ++i)
             stbi__get32le(s); // discard color space parameters
          if (hsz == 124) {
             stbi__get32le(s); // discard rendering intent
             stbi__get32le(s); // discard offset of profile data
             stbi__get32le(s); // discard size of profile data
@@ -5306,29 +5560,48 @@
    info.all_a = 255;
    if (stbi__bmp_parse_header(s, &info) == NULL)
       return NULL; // error code already set
 
    flip_vertically = ((int) s->img_y) > 0;
    s->img_y = abs((int) s->img_y);
 
+   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
+   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
+
    mr = info.mr;
    mg = info.mg;
    mb = info.mb;
    ma = info.ma;
    all_a = info.all_a;
 
    if (info.hsz == 12) {
       if (info.bpp < 24)
          psize = (info.offset - info.extra_read - 24) / 3;
    } else {
       if (info.bpp < 16)
          psize = (info.offset - info.extra_read - info.hsz) >> 2;
    }
    if (psize == 0) {
-      STBI_ASSERT(info.offset == (s->img_buffer - s->buffer_start));
+      // accept some number of extra bytes after the header, but if the offset points either to before
+      // the header ends or implies a large amount of extra data, reject the file as malformed
+      int bytes_read_so_far = s->callback_already_read + (int)(s->img_buffer - s->img_buffer_original);
+      int header_limit = 1024; // max we actually read is below 256 bytes currently.
+      int extra_data_limit = 256*4; // what ordinarily goes here is a palette; 256 entries*4 bytes is its max size.
+      if (bytes_read_so_far <= 0 || bytes_read_so_far > header_limit) {
+         return stbi__errpuc("bad header", "Corrupt BMP");
+      }
+      // we established that bytes_read_so_far is positive and sensible.
+      // the first half of this test rejects offsets that are either too small positives, or
+      // negative, and guarantees that info.offset >= bytes_read_so_far > 0. this in turn
+      // ensures the number computed in the second half of the test can't overflow.
+      if (info.offset < bytes_read_so_far || info.offset - bytes_read_so_far > extra_data_limit) {
+         return stbi__errpuc("bad offset", "Corrupt BMP");
+      } else {
+         stbi__skip(s, info.offset - bytes_read_so_far);
+      }
    }
 
    if (info.bpp == 24 && ma == 0xff000000)
       s->img_n = 3;
    else
       s->img_n = ma ? 4 : 3;
    if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
@@ -5415,14 +5688,15 @@
       if (!easy) {
          if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
          // right shift amt to put high bit in position #7
          rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
          gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
          bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
          ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
+         if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
       }
       for (j=0; j < (int) s->img_y; ++j) {
          if (easy) {
             for (i=0; i < (int) s->img_x; ++i) {
                unsigned char a;
                out[z+2] = stbi__get8(s);
                out[z+1] = stbi__get8(s);
@@ -5639,14 +5913,17 @@
    int RLE_count = 0;
    int RLE_repeating = 0;
    int read_next_pixel = 1;
    STBI_NOTUSED(ri);
    STBI_NOTUSED(tga_x_origin); // @TODO
    STBI_NOTUSED(tga_y_origin); // @TODO
 
+   if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
+   if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
+
    //   do a tiny bit of precessing
    if ( tga_image_type >= 8 )
    {
       tga_image_type -= 8;
       tga_is_RLE = 1;
    }
    tga_inverted = 1 - ((tga_inverted >> 5) & 1);
@@ -5678,14 +5955,19 @@
          stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
          stbi__getn(s, tga_row, tga_width * tga_comp);
       }
    } else  {
       //   do I need to load a palette?
       if ( tga_indexed)
       {
+         if (tga_palette_len == 0) {  /* you have to have at least one entry! */
+            STBI_FREE(tga_data);
+            return stbi__errpuc("bad palette", "Corrupt TGA");
+         }
+
          //   any data to skip? (offset usually = 0)
          stbi__skip(s, tga_palette_start );
          //   load the palette
          tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
          if (!tga_palette) {
             STBI_FREE(tga_data);
             return stbi__errpuc("outofmem", "Out of memory");
@@ -5886,14 +6168,17 @@
    if (channelCount < 0 || channelCount > 16)
       return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");
 
    // Read the rows and columns of the image.
    h = stbi__get32be(s);
    w = stbi__get32be(s);
 
+   if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
+   if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
+
    // Make sure the depth is 8 bits.
    bitdepth = stbi__get16be(s);
    if (bitdepth != 8 && bitdepth != 16)
       return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");
 
    // Make sure the color mode is RGB.
    // Valid options are:
@@ -6240,28 +6525,33 @@
    if (!comp) comp = &internal_comp;
 
    for (i=0; i<92; ++i)
       stbi__get8(s);
 
    x = stbi__get16be(s);
    y = stbi__get16be(s);
+
+   if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
+   if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
+
    if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (pic header)");
    if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc("too large", "PIC image too large to decode");
 
    stbi__get32be(s); //skip `ratio'
    stbi__get16be(s); //skip `fields'
    stbi__get16be(s); //skip `pad'
 
    // intermediate buffer is RGBA
    result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);
+   if (!result) return stbi__errpuc("outofmem", "Out of memory");
    memset(result, 0xff, x*y*4);
 
    if (!stbi__pic_load_core(s,x,y,comp, result)) {
       STBI_FREE(result);
-      result=0;
+      return 0;
    }
    *px = x;
    *py = y;
    if (req_comp == 0) req_comp = *comp;
    result=stbi__convert_format(result,4,req_comp,x,y);
 
    return result;
@@ -6348,27 +6638,31 @@
    g->w = stbi__get16le(s);
    g->h = stbi__get16le(s);
    g->flags = stbi__get8(s);
    g->bgindex = stbi__get8(s);
    g->ratio = stbi__get8(s);
    g->transparent = -1;
 
+   if (g->w > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
+   if (g->h > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");
+
    if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments
 
    if (is_info) return 1;
 
    if (g->flags & 0x80)
       stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);
 
    return 1;
 }
 
 static int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)
 {
    stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));
+   if (!g) return stbi__err("outofmem", "Out of memory");
    if (!stbi__gif_header(s, g, comp, 1)) {
       STBI_FREE(g);
       stbi__rewind( s );
       return 0;
    }
    if (x) *x = g->w;
    if (y) *y = g->h;
@@ -6525,15 +6819,15 @@
       // background colour is only used for pixels that are not rendered first frame, after that "background"
       // color refers to the color that was there the previous frame.
       memset(g->out, 0x00, 4 * pcount);
       memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)
       memset(g->history, 0x00, pcount);        // pixels that were affected previous frame
       first_frame = 1;
    } else {
-      // second frame - how do we dispoase of the previous one?
+      // second frame - how do we dispose of the previous one?
       dispose = (g->eflags & 0x1C) >> 2;
       pcount = g->w * g->h;
 
       if ((dispose == 3) && (two_back == 0)) {
          dispose = 2; // if I don't have an image to revert back to, default to the old background
       }
 
@@ -6670,23 +6964,40 @@
 
          default:
             return stbi__errpuc("unknown code", "Corrupt GIF");
       }
    }
 }
 
+static void *stbi__load_gif_main_outofmem(stbi__gif *g, stbi_uc *out, int **delays)
+{
+   STBI_FREE(g->out);
+   STBI_FREE(g->history);
+   STBI_FREE(g->background);
+
+   if (out) STBI_FREE(out);
+   if (delays && *delays) STBI_FREE(*delays);
+   return stbi__errpuc("outofmem", "Out of memory");
+}
+
 static void *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp)
 {
    if (stbi__gif_test(s)) {
       int layers = 0;
       stbi_uc *u = 0;
       stbi_uc *out = 0;
       stbi_uc *two_back = 0;
       stbi__gif g;
       int stride;
+      int out_size = 0;
+      int delays_size = 0;
+
+      STBI_NOTUSED(out_size);
+      STBI_NOTUSED(delays_size);
+
       memset(&g, 0, sizeof(g));
       if (delays) {
          *delays = 0;
       }
 
       do {
          u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);
@@ -6695,30 +7006,39 @@
          if (u) {
             *x = g.w;
             *y = g.h;
             ++layers;
             stride = g.w * g.h * 4;
 
             if (out) {
-               void *tmp = (stbi_uc*) STBI_REALLOC( out, layers * stride );
-               if (NULL == tmp) {
-                  STBI_FREE(g.out);
-                  STBI_FREE(g.history);
-                  STBI_FREE(g.background);
-                  return stbi__errpuc("outofmem", "Out of memory");
+               void *tmp = (stbi_uc*) STBI_REALLOC_SIZED( out, out_size, layers * stride );
+               if (!tmp)
+                  return stbi__load_gif_main_outofmem(&g, out, delays);
+               else {
+                   out = (stbi_uc*) tmp;
+                   out_size = layers * stride;
                }
-               else
-                  out = (stbi_uc*) tmp;
+
                if (delays) {
-                  *delays = (int*) STBI_REALLOC( *delays, sizeof(int) * layers );
+                  int *new_delays = (int*) STBI_REALLOC_SIZED( *delays, delays_size, sizeof(int) * layers );
+                  if (!new_delays)
+                     return stbi__load_gif_main_outofmem(&g, out, delays);
+                  *delays = new_delays;
+                  delays_size = layers * sizeof(int);
                }
             } else {
                out = (stbi_uc*)stbi__malloc( layers * stride );
+               if (!out)
+                  return stbi__load_gif_main_outofmem(&g, out, delays);
+               out_size = layers * stride;
                if (delays) {
                   *delays = (int*) stbi__malloc( layers * sizeof(int) );
+                  if (!*delays)
+                     return stbi__load_gif_main_outofmem(&g, out, delays);
+                  delays_size = layers * sizeof(int);
                }
             }
             memcpy( out + ((layers - 1) * stride), u, stride );
             if (layers >= 2) {
                two_back = out - 2 * stride;
             }
 
@@ -6889,14 +7209,17 @@
    token += 3;
    height = (int) strtol(token, &token, 10);
    while (*token == ' ') ++token;
    if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
    token += 3;
    width = (int) strtol(token, NULL, 10);
 
+   if (height > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");
+   if (width > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");
+
    *x = width;
    *y = height;
 
    if (comp) *comp = 3;
    if (req_comp == 0) req_comp = 3;
 
    if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))
@@ -6957,20 +7280,20 @@
             i = 0;
             while ((nleft = width - i) > 0) {
                count = stbi__get8(s);
                if (count > 128) {
                   // Run
                   value = stbi__get8(s);
                   count -= 128;
-                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
+                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
                   for (z = 0; z < count; ++z)
                      scanline[i++ * 4 + k] = value;
                } else {
                   // Dump
-                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
+                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
                   for (z = 0; z < count; ++z)
                      scanline[i++ * 4 + k] = stbi__get8(s);
                }
             }
          }
          for (i=0; i < width; ++i)
             stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);
@@ -7031,17 +7354,18 @@
 static int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)
 {
    void *p;
    stbi__bmp_data info;
 
    info.all_a = 255;
    p = stbi__bmp_parse_header(s, &info);
-   stbi__rewind( s );
-   if (p == NULL)
+   if (p == NULL) {
+      stbi__rewind( s );
       return 0;
+   }
    if (x) *x = s->img_x;
    if (y) *y = s->img_y;
    if (comp) {
       if (info.bpp == 24 && info.ma == 0xff000000)
          *comp = 3;
       else
          *comp = info.ma ? 4 : 3;
@@ -7099,16 +7423,16 @@
    }
    stbi__skip(s, 6);
    channelCount = stbi__get16be(s);
    if (channelCount < 0 || channelCount > 16) {
        stbi__rewind( s );
        return 0;
    }
-   (void) stbi__get32be(s);
-   (void) stbi__get32be(s);
+   STBI_NOTUSED(stbi__get32be(s));
+   STBI_NOTUSED(stbi__get32be(s));
    depth = stbi__get16be(s);
    if (depth != 16) {
        stbi__rewind( s );
        return 0;
    }
    return 1;
 }
@@ -7179,15 +7503,14 @@
 //
 // PGM: http://netpbm.sourceforge.net/doc/pgm.html
 // PPM: http://netpbm.sourceforge.net/doc/ppm.html
 //
 // Known limitations:
 //    Does not support comments in the header section
 //    Does not support ASCII image data (formats P2 and P3)
-//    Does not support 16-bit-per-channel
 
 #ifndef STBI_NO_PNM
 
 static int      stbi__pnm_test(stbi__context *s)
 {
    char p, t;
    p = (char) stbi__get8(s);
@@ -7200,30 +7523,41 @@
 }
 
 static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
 {
    stbi_uc *out;
    STBI_NOTUSED(ri);
 
-   if (!stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n))
+   ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);
+   if (ri->bits_per_channel == 0)
       return 0;
 
+   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
+   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");
+
    *x = s->img_x;
    *y = s->img_y;
    if (comp) *comp = s->img_n;
 
-   if (!stbi__mad3sizes_valid(s->img_n, s->img_x, s->img_y, 0))
+   if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))
       return stbi__errpuc("too large", "PNM too large");
 
-   out = (stbi_uc *) stbi__malloc_mad3(s->img_n, s->img_x, s->img_y, 0);
+   out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);
    if (!out) return stbi__errpuc("outofmem", "Out of memory");
-   stbi__getn(s, out, s->img_n * s->img_x * s->img_y);
+   if (!stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8))) {
+      STBI_FREE(out);
+      return stbi__errpuc("bad PNM", "PNM file truncated");
+   }
 
    if (req_comp && req_comp != s->img_n) {
-      out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
+      if (ri->bits_per_channel == 16) {
+         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, s->img_n, req_comp, s->img_x, s->img_y);
+      } else {
+         out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
+      }
       if (out == NULL) return out; // stbi__convert_format frees input on failure
    }
    return out;
 }
 
 static int      stbi__pnm_isspace(char c)
 {
@@ -7252,14 +7586,16 @@
 static int      stbi__pnm_getinteger(stbi__context *s, char *c)
 {
    int value = 0;
 
    while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {
       value = value*10 + (*c - '0');
       *c = (char) stbi__get8(s);
+      if((value > 214748364) || (value == 214748364 && *c > '7'))
+          return stbi__err("integer parse overflow", "Parsing an integer in the PPM header overflowed a 32-bit int");
    }
 
    return value;
 }
 
 static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)
 {
@@ -7282,25 +7618,37 @@
 
    *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm
 
    c = (char) stbi__get8(s);
    stbi__pnm_skip_whitespace(s, &c);
 
    *x = stbi__pnm_getinteger(s, &c); // read width
+   if(*x == 0)
+       return stbi__err("invalid width", "PPM image header had zero or overflowing width");
    stbi__pnm_skip_whitespace(s, &c);
 
    *y = stbi__pnm_getinteger(s, &c); // read height
+   if (*y == 0)
+       return stbi__err("invalid width", "PPM image header had zero or overflowing width");
    stbi__pnm_skip_whitespace(s, &c);
 
    maxv = stbi__pnm_getinteger(s, &c);  // read max value
-
-   if (maxv > 255)
-      return stbi__err("max value > 255", "PPM image not 8-bit");
+   if (maxv > 65535)
+      return stbi__err("max value > 65535", "PPM image supports only 8-bit and 16-bit images");
+   else if (maxv > 255)
+      return 16;
    else
-      return 1;
+      return 8;
+}
+
+static int stbi__pnm_is16(stbi__context *s)
+{
+   if (stbi__pnm_info(s, NULL, NULL, NULL) == 16)
+	   return 1;
+   return 0;
 }
 #endif
 
 static int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)
 {
    #ifndef STBI_NO_JPEG
    if (stbi__jpeg_info(s, x, y, comp)) return 1;
@@ -7348,14 +7696,17 @@
    if (stbi__png_is16(s))  return 1;
    #endif
 
    #ifndef STBI_NO_PSD
    if (stbi__psd_is16(s))  return 1;
    #endif
 
+   #ifndef STBI_NO_PNM
+   if (stbi__pnm_is16(s))  return 1;
+   #endif
    return 0;
 }
 
 #ifndef STBI_NO_STDIO
 STBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)
 {
     FILE *f = stbi__fopen(filename, "rb");
```

### Comparing `tinyusdz-0.8.0rc0/src/external/stb_image_write.h` & `tinyusdz-0.8.0rc1/src/external/stb_image_write.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/string_id/LICENSE` & `tinyusdz-0.8.0rc1/src/external/string_id/LICENSE`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/string_id/README.md` & `tinyusdz-0.8.0rc1/src/external/string_id/README.md`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/string_id/basic_database.hpp` & `tinyusdz-0.8.0rc1/src/external/string_id/basic_database.hpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/string_id/config.hpp.in` & `tinyusdz-0.8.0rc1/src/external/string_id/config.hpp.in`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/string_id/config_impl.hpp` & `tinyusdz-0.8.0rc1/src/external/string_id/config_impl.hpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/string_id/database.cpp` & `tinyusdz-0.8.0rc1/src/external/string_id/database.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/string_id/database.hpp` & `tinyusdz-0.8.0rc1/src/external/string_id/database.hpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/string_id/error.cpp` & `tinyusdz-0.8.0rc1/src/external/string_id/error.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/string_id/error.hpp` & `tinyusdz-0.8.0rc1/src/external/string_id/error.hpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/string_id/generator.cpp` & `tinyusdz-0.8.0rc1/src/external/string_id/generator.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/string_id/generator.hpp` & `tinyusdz-0.8.0rc1/src/external/string_id/generator.hpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/string_id/hash.hpp` & `tinyusdz-0.8.0rc1/src/external/string_id/hash.hpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/string_id/string_id.cpp` & `tinyusdz-0.8.0rc1/src/external/string_id/string_id.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/string_id/string_id.hpp` & `tinyusdz-0.8.0rc1/src/external/string_id/string_id.hpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/tiny_dng_loader.h` & `tinyusdz-0.8.0rc1/src/external/tiny_dng_loader.h`

 * *Files 1% similar despite different names*

```diff
@@ -41,14 +41,17 @@
 
 namespace tinydng {
 
 // TODO: Deal with out-of-memory error
 // e.g. limit maximum images in one DNG/TIFF file
 const size_t kMaxImages = 10240;
 
+// TODO: Set max allowed size in loader option.
+const size_t kMaxImageSizeInMB = 64*1024; // 64 GB
+
 // Avoid stack-overflow of recursive Sub IFD parsing.
 const uint32_t kMaxRecursiveIFDParse = 1024;
 
 typedef enum {
   LIGHTSOURCE_UNKNOWN = 0,
   LIGHTSOURCE_DAYLIGHT = 1,
   LIGHTSOURCE_FLUORESCENT = 2,
@@ -298,22 +301,28 @@
 #else
 #include <Windows.h>
 #endif
 #endif
 
 #include <stdint.h>  // for lj92
 
-#include <cassert>
 #include <cmath>
-#include <cstdio>
 #include <cstdlib>
 #include <cstring>
 #include <iterator>
 #include <map>
 #include <sstream>
+#include <limits>
+
+#if defined(TINY_DNG_LOADER_NO_STDIO)
+#else
+#include <cstdio>
+#include <cassert>
+#include <iostream>
+#endif
 
 // #include <iostream> // dbg
 
 #ifdef TINY_DNG_LOADER_PROFILING
 // Requires C++11 feature
 #include <chrono>
 #endif
@@ -328,15 +337,15 @@
 #endif
 
 #ifdef __clang__
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Weverything"
 #endif
 
-//#define TINY_DNG_LOADER_DEBUG
+// #define TINY_DNG_LOADER_DEBUG
 #ifdef TINY_DNG_LOADER_DEBUG
 #define TINY_DNG_DPRINTF(...) printf(__VA_ARGS__)
 #else
 #define TINY_DNG_DPRINTF(...)
 #endif
 
 #if 0 // DBG
@@ -359,26 +368,46 @@
 
 #define TINY_DNG_ABORT(text)        \
   do {                              \
     throw std::runtime_error(text); \
   } while (false)
 
 #else
+
+#if defined(TINY_DNG_LOADER_NO_STDIO)
+// No output
+
+#define TINY_DNG_ASSERT(assertion, text)                                    \
+  do {                                                                      \
+    if ((assertion) == 0) {                                                 \
+      abort();                                                              \
+    }                                                                       \
+  } while (false)
+#define TINY_DNG_ABORT(text)                                              \
+  do {                                                                    \
+    abort();                                                              \
+  } while (false)
+
+#else // NO_STDIO
+
 #define TINY_DNG_ASSERT(assertion, text)                                    \
   do {                                                                      \
     if ((assertion) == 0) {                                                 \
       std::cerr << __FILE__ << ":" << __LINE__ << " " << text << std::endl; \
       abort();                                                              \
     }                                                                       \
   } while (false)
 #define TINY_DNG_ABORT(text)                                              \
   do {                                                                    \
     std::cerr << __FILE__ << ":" << __LINE__ << " " << text << std::endl; \
     abort();                                                              \
   } while (false)
+
+#endif // NO_STDIO
+
 #endif
 
 #ifdef __clang__
 #pragma clang diagnostic pop
 #endif
 
 #ifdef __clang__
@@ -395,17 +424,21 @@
 
 #ifdef TINY_DNG_LOADER_ENABLE_ZIP
 #ifndef TINY_DNG_LOADER_USE_SYSTEM_ZLIB
 #include "miniz.h"
 #endif
 #endif
 
+#if defined(TINY_DNG_LOADER_NO_STB_IMAGE_INCLUDE)
+#else
+
 // STB image to decode jpeg image.
 // Assume STB_IMAGE_IMPLEMENTATION is defined elsewhere
 #include "stb_image.h"
+#endif
 
 #ifdef __clang__
 #pragma clang diagnostic pop
 #endif
 
 #ifdef _MSC_VER
 #pragma warning(pop)
@@ -994,18 +1027,18 @@
   if (self->ix >= self->datalen) {
     TINY_DNG_DPRINTF("ix = %d, datalen = %d\n", self->ix, self->datalen);
     return ret;
   }
   --write;
   int rowcount = self->x - 1;
   while (rowcount--) {
-    int errcode = LJ92_ERROR_NONE;
-    diff = nextdiff(self, self->num_huff_idx - 1, 0, &errcode);
-    if (errcode != LJ92_ERROR_NONE) {
-      return errcode;
+    int _errcode = LJ92_ERROR_NONE;
+    diff = nextdiff(self, self->num_huff_idx - 1, 0, &_errcode);
+    if (_errcode != LJ92_ERROR_NONE) {
+      return _errcode;
     }
     Px = left;
     left = Px + diff;
     left = (u16)(left % 65536);
     if (self->linearize)
       linear = self->linearize[left];
     else
@@ -1027,18 +1060,18 @@
   temprow = lastrow;
   lastrow = thisrow;
   thisrow = temprow;
   row++;
   // TINY_DNG_DPRINTF("%x %x\n",thisrow,lastrow);
   while (c < pixels) {
     col = 0;
-    int errcode = LJ92_ERROR_NONE;
-    diff = nextdiff(self, self->num_huff_idx - 1, 0, &errcode);
-    if (errcode != LJ92_ERROR_NONE) {
-      return errcode;
+    int _errcode = LJ92_ERROR_NONE;
+    diff = nextdiff(self, self->num_huff_idx - 1, 0, &_errcode);
+    if (_errcode != LJ92_ERROR_NONE) {
+      return _errcode;
     }
     Px = lastrow[col];  // Use value above for first pixel in row
     left = Px + diff;
     left = (u16)(left % 65536);
     if (self->linearize) {
       if (left > self->linlen) return LJ92_ERROR_CORRUPT;
       linear = self->linearize[left];
@@ -1050,18 +1083,18 @@
     if (self->ix >= self->datalen) break;
     rowcount = self->x - 1;
     if (--write == 0) {
       out += self->skiplen;
       write = self->writelen;
     }
     while (rowcount--) {
-      int errcode = LJ92_ERROR_NONE;
-      diff = nextdiff(self, self->num_huff_idx - 1, 0, &errcode);
-      if (errcode != LJ92_ERROR_NONE) {
-        return errcode;
+      int errcode_d2 = LJ92_ERROR_NONE;
+      diff = nextdiff(self, self->num_huff_idx - 1, 0, &errcode_d2);
+      if (errcode_d2 != LJ92_ERROR_NONE) {
+        return errcode_d2;
       }
 
       Px = lastrow[col] + ((left - lastrow[col - 1]) >> 1);
       left = Px + diff;
       left = (u16)(left % 65536);
       // TINY_DNG_DPRINTF("%d %d %d %d %d
       // %x\n",col,diff,left,lastrow[col],lastrow[col-1],&lastrow[col]);
@@ -3025,28 +3058,32 @@
       int ret =
           lj92_open(&ljp, reinterpret_cast<const uint8_t*>(sr.data() + offset),
                     /* data_len */ static_cast<int>(input_len), &lj_width,
                     &lj_height, &lj_bits);
       TINY_DNG_DPRINTF("ret = %d\n", ret);
       TINY_DNG_ASSERT(ret == LJ92_ERROR_NONE, "Error opening JPEG stream.");
 
-      // TINY_DNG_DPRINTF("lj %d, %d, %d\n", lj_width, lj_height, lj_bits);
-      // TINY_DNG_DPRINTF("ljp x %d, y %d, c %d\n", ljp->x, ljp->y,
-      // ljp->components);
-      // TINY_DNG_DPRINTF("tile width = %d\n", image_info.tile_width);
-      // TINY_DNG_DPRINTF("tile height = %d\n", image_info.tile_length);
-      // TINY_DNG_DPRINTF("col = %d, tiff_w = %d / %d\n", column_step, tiff_w,
-      // image_info.width);
-
-      TINY_DNG_ASSERT((lj_width * lj_height) ==
-                          image_info.tile_width * image_info.tile_length,
-                      "Unexpected JPEG tile size.");
-
-      TINY_DNG_ASSERT(ljp->components == image_info.samples_per_pixel,
-                      "# of color channels does not match.");
+      TINY_DNG_DPRINTF("lj %d, %d, %d\n", lj_width, lj_height, lj_bits);
+      TINY_DNG_DPRINTF("ljp x %d, y %d, c %d\n", ljp->x, ljp->y,
+      ljp->components);
+      TINY_DNG_DPRINTF("tile width = %d\n", image_info.tile_width);
+      TINY_DNG_DPRINTF("tile height = %d\n", image_info.tile_length);
+      TINY_DNG_DPRINTF("col = %d, tiff_w = %d / %d\n", int(column_step), tiff_w,
+      image_info.width);
+
+      TINY_DNG_ASSERT(lj_width <= image_info.tile_width, "Unexpected JPEG tile width size.");
+      TINY_DNG_ASSERT(lj_height <= image_info.tile_length, "Unexpected JPEG tile length size.");
+
+      //TINY_DNG_ASSERT((lj_width * lj_height) ==
+      //                    image_info.tile_width * image_info.tile_length,
+      //                "Unexpected JPEG tile size.");
+
+      TINY_DNG_DPRINTF("lj.components %d, samples_per_pixel %d\n", ljp->components, image_info.samples_per_pixel);
+      //TINY_DNG_ASSERT(ljp->components == image_info.samples_per_pixel,
+      //                "# of color channels does not match.");
 
       // int write_length = image_info.tile_width;
       // int skip_length = dst_width - image_info.tile_width;
       // TINY_DNG_DPRINTF("write_len = %d, skip_len = %d\n", write_length,
       // skip_length);
 
       // size_t dst_offset =
@@ -3055,14 +3092,15 @@
 
       // Decode into temporary buffer.
 
       std::vector<uint16_t> tmpbuf;
       tmpbuf.resize(
           static_cast<size_t>(lj_width * lj_height * ljp->components));
 
+      // TODO: ljp->components > image_info.samples_per_pixel
       ret = lj92_decode(ljp, tmpbuf.data(), image_info.tile_width, 0, NULL, 0);
       // ret = lj92_decode(ljp, tmpbuf.data(), write_length, skip_length, NULL,
       // 0);
       TINY_DNG_ASSERT(ret == LJ92_ERROR_NONE, "Error decoding JPEG stream.");
       // ret = lj92_decode(ljp, dst_data + dst_offset, write_length,
       // skip_length,
       //                  NULL, 0);
@@ -3623,14 +3661,21 @@
         if (!sr.read2(&spp)) {
           if (err) {
             (*err) += "Failed to read SamplesPerPixel Tag.\n";
           }
           return false;
         }
 
+        if (spp < 1) {
+          if (err) {
+            (*err) += "SamplesPerPixel must be 1 ~ 4, but got " + std::to_string(spp) + ".\n";
+          }
+          return false;
+        }
+
         if (spp > 4) {
           if (err) {
             (*err) += "SamplesPerPixel must be less than or equal to 4.\n";
           }
           return false;
         }
 
@@ -4994,14 +5039,17 @@
           // Assume 8bit
           image->bits_per_sample_original = 8;
         }
 
         image->bits_per_sample = image->bits_per_sample_original;
 
       } else {
+
+        const size_t kMaxImageSize = size_t(1024)*size_t(1024)*size_t(1024)*size_t(2); // 2GB
+
         if (image->bits_per_sample_original <= 0) {
           if (err) {
             (*err) += "bits_per_sample information not found in the tag.\n";
           }
           return false;
         }
 
@@ -5028,14 +5076,23 @@
         if (len == 0) {
           if (err) {
             (*err) += "Unexpected length.";
           }
           return false;
         }
 
+        if (len > kMaxImageSize) {
+          if (err) {
+            std::stringstream ss;
+            ss << "Image byte size too large. " << len << "bytes in file, but hard-limit is set to " << kMaxImageSize << " bytes.\n";
+            (*err) += ss.str();
+          }
+          return false;
+        }
+
         image->data.resize(len);
         if (!sr.seek_set(data_offset)) {
           if (err) {
             (*err) += "Failed to seek to uncompressed image data position.\n";
           }
           return false;
         }
@@ -5068,15 +5125,15 @@
 #if (__cplusplus > 199711L) && defined(TINY_DNG_LOADER_USE_THREAD)
 
         const int num_strips = int(image->strip_byte_counts.size());
 
         std::vector<std::thread> workers;
         std::atomic<size_t> strip_count(0);
 
-        int num_threads = std::max(1, int(std::thread::hardware_concurrency()));
+        int num_threads = (std::max)(1, int(std::thread::hardware_concurrency()));
         if (num_threads > num_strips) {
           num_threads = num_strips;
         }
 
         bool failed = false;
 
         const size_t dst_strip_len = static_cast<size_t>(
@@ -5166,18 +5223,33 @@
           if (!sr.seek_set(image->strip_offsets[k])) {
             if (err) {
               (*err) += "Failed to seek to strip offset.\n";
             }
             return false;
           }
 
-          const size_t dst_len = static_cast<size_t>(
-              (image->samples_per_pixel * image->width * image->rows_per_strip *
-               image->bits_per_sample) /
-              8);
+          const size_t dst_len = size_t(image->samples_per_pixel) * size_t(image->width) * size_t(image->rows_per_strip) *
+               size_t(image->bits_per_sample) / 8ull;
+          if (dst_len == 0) {
+            if (err) {
+              (*err) += "Image data size is zero.\n";
+              (*err) += "  samples_per_pixel " + std::to_string(image->samples_per_pixel) + "\n";
+              (*err) += "  width " + std::to_string(image->width) + "\n";
+              (*err) += "  rows_per_strip " + std::to_string(image->rows_per_strip) + "\n";
+              (*err) += "  bits_per_sample " + std::to_string(image->bits_per_sample) + "\n";
+            }
+            return false;
+          }
+
+          if ((1024ull * 1024ull * dst_len) > kMaxImageSizeInMB) {
+            if (err) {
+              (*err) += "Image data size too large. Exceeds " + std::to_string(kMaxImageSizeInMB) + " MB.\n";
+            }
+            return false;
+          }
           std::vector<unsigned char> dst(dst_len);
 
           if (!sr.read(image->strip_byte_counts[k], image->strip_byte_counts[k],
                        src.data())) {
             if (err) {
               (*err) += "Cannot read strip_byte_counts bytes from stream.\n";
             }
@@ -5462,18 +5534,26 @@
           } else {
             decoded = true;
 
             image->width = w;
             image->height = h;
             image->samples_per_pixel = components;
 
-            const size_t len =
-                static_cast<size_t>((image->samples_per_pixel * image->width *
-                                     image->height * image->bits_per_sample) /
-                                    8);
+            const uint64_t len = uint64_t(image->samples_per_pixel) * uint64_t(image->width) * uint64_t(image->height) * uint64_t(image->bits_per_sample / 8);
+            // For 32bit
+            if (sizeof(void *) == 4) {
+              // Use 2GB as a max
+              if (len > (std::numeric_limits<int32_t>::max)()) {
+                if (err) {
+                  (*err) += "Decoded image size exceeds 2GB.\n";
+                }
+                return false; 
+              }
+            }
+
             image->data.resize(len);
 
             memcpy(image->data.data(), decoded_image, len);
 
             free(decoded_image);
           }
         }
@@ -5483,28 +5563,42 @@
         // Try to decode as lossless JPEG.
 
         // lj92 decodes data into 16bits, so modify bps.
         image->bits_per_sample = 16;
 
         // std::cout << "w = " << image->width << ", h = " << image->height <<
         // std::endl;
+        
+        TINY_DNG_DPRINTF("image.width = %d\n", image->width);
+        TINY_DNG_DPRINTF("image.height = %d\n", image->height);
+        TINY_DNG_DPRINTF("image.bps = %d\n", image->bits_per_sample);
+        TINY_DNG_DPRINTF("image.spp = %d\n", image->samples_per_pixel);
 
         TINY_DNG_ASSERT(
             ((image->width * image->height * image->bits_per_sample) % 8) == 0,
             "Image must be multiple of 8.");
-        const size_t len =
-            static_cast<size_t>((image->samples_per_pixel * image->width *
-                                 image->height * image->bits_per_sample) /
-                                8);
+        const uint64_t len = uint64_t(image->samples_per_pixel) * uint64_t(image->width) * uint64_t(image->height) * uint64_t(image->bits_per_sample / 8);
+        // For 32bit
+        if (sizeof(void *) == 4) {
+          // Use 2GB as a max
+          if (len > (std::numeric_limits<int32_t>::max)()) {
+            if (err) {
+              (*err) += "Decoded image size exceeds 2GB.\n";
+            }
+            return false; 
+          }
+        }
+
         if (len == 0) {
           if (err) {
             (*err) += "Invalid jpeg data length.\n";
           }
           return false;
         }
+        TINY_DNG_DPRINTF("image.data.size = %lld\n", len);
 
         image->data.resize(len);
         TINY_DNG_DPRINTF("image.data.size = %d\n", int(len));
 
         if (sr.size() < data_offset) {
           if (err) {
             (*err) += "Unexpected file size or data offset.\n";
```

### Comparing `tinyusdz-0.8.0rc0/src/external/tiny_dng_writer.h` & `tinyusdz-0.8.0rc1/src/external/tiny_dng_writer.h`

 * *Files 23% similar despite different names*

```diff
@@ -27,22 +27,15 @@
 */
 
 #ifndef TINY_DNG_WRITER_H_
 #define TINY_DNG_WRITER_H_
 
 #include <sstream>
 #include <vector>
-
-#ifndef ROL32
-#define ROL32(v,a) ((v) << (a) | (v) >> (32-(a)))
-#endif
-
-#ifndef ROL16
-#define ROL16(v,a) ((v) << (a) | (v) >> (16-(a)))
-#endif
+#include <cstring>
 
 namespace tinydngwriter {
 
 typedef enum {
   TIFFTAG_SUB_FILETYPE = 254,
   TIFFTAG_IMAGE_WIDTH = 256,
   TIFFTAG_IMAGE_LENGTH = 257,
@@ -102,14 +95,15 @@
 // PLANARCONFIG
 static const int PLANARCONFIG_CONTIG = 1;
 static const int PLANARCONFIG_SEPARATE = 2;
 
 // COMPRESSION
 // TODO(syoyo) more compressin types.
 static const int COMPRESSION_NONE = 1;
+static const int COMPRESSION_NEW_JPEG = 7;
 
 // ORIENTATION
 static const int ORIENTATION_TOPLEFT = 1;
 static const int ORIENTATION_TOPRIGHT = 2;
 static const int ORIENTATION_BOTRIGHT = 3;
 static const int ORIENTATION_BOTLEFT = 4;
 static const int ORIENTATION_LEFTTOP = 5;
@@ -246,14 +240,17 @@
 
   /// Set image data with packing (take 16-bit values and pack them to input_bpp values).
   bool SetImageDataPacked(const unsigned short *input_buffer, const int input_count, const unsigned int input_bpp, bool big_endian);
 
   /// Set image data.
   bool SetImageData(const unsigned char *data, const size_t data_len);
 
+  /// Set image data.
+  bool SetImageDataJpeg(const unsigned short *data, unsigned int width, unsigned int height, unsigned int bpp);
+
   /// Set custom field.
   bool SetCustomFieldLong(const unsigned short tag, const int value);
   bool SetCustomFieldULong(const unsigned short tag, const unsigned int value);
 
   size_t GetDataSize() const { return data_os_.str().length(); }
 
   size_t GetStripOffset() const { return data_strip_offset_; }
@@ -341,17 +338,585 @@
 #include <cmath>
 #include <cstdint>
 #include <cstdlib>
 #include <cstring>
 #include <fstream>
 #include <iostream>
 #include <sstream>
+#include <limits>
+
+// Undef if you want to use builtin function for clz
+#if 0
+#ifdef _MSC_VER
+#include <intrin.h>
+#endif
+#endif
+
 
 namespace tinydngwriter {
 
+namespace detail {
+
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Weverything"
+#endif
+
+// Begin liblj92, Lossless JPEG decode/encoder ------------------------------
+//
+// With fixes: https://github.com/ilia3101/MLV-App/pull/151
+
+/*
+lj92.c
+(c) Andrew Baldwin 2014
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+of the Software, and to permit persons to whom the Software is furnished to do
+so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
+enum LJ92_ERRORS {
+  LJ92_ERROR_NONE = 0,
+  LJ92_ERROR_CORRUPT = -1,
+  LJ92_ERROR_NO_MEMORY = -2,
+  LJ92_ERROR_BAD_HANDLE = -3,
+  LJ92_ERROR_TOO_WIDE = -4
+};
+
+/*
+ * Encode a grayscale image supplied as 16bit values within the given bitdepth
+ * Read from tile in the image
+ * Apply delinearization if given
+ * Return the encoded lossless JPEG stream
+ */
+int lj92_encode(uint16_t *image, int width, int height, int bitdepth,
+                int readLength, int skipLength, uint16_t *delinearize,
+                int delinearizeLength, uint8_t **encoded, int *encodedLength);
+
+typedef uint8_t u8;
+typedef uint16_t u16;
+typedef uint32_t u32;
+
+//#define LJ92_DEBUG
+
+/* Encoder implementation */
+
+#if 0
+uint32_t __inline clz32(uint32_t value) {
+  unsigned long leading_zero = 0;
+
+  if (_BitScanReverse(&leading_zero, value)) {
+    return 31 - leading_zero;
+  } else {
+    // Same remarks as above
+    return 32;
+  }
+}
+#endif
+
+// Very simple count leading zero implementation.
+static int clz32(unsigned int x) {
+  int n;
+  if (x == 0) return 32;
+  for (n = 0; ((x & 0x80000000) == 0); n++, x <<= 1)
+    ;
+  return n;
+}
+
+typedef struct _lje {
+  uint16_t *image;
+  int width;
+  int height;
+  int bitdepth;
+  int readLength;
+  int skipLength;
+  uint16_t *delinearize;
+  int delinearizeLength;
+  uint8_t *encoded;
+  int encodedWritten;
+  int encodedLength;
+  int hist[17];  // SSSS frequency histogram
+  int bits[17];
+  int huffval[17];
+  u16 huffenc[17];
+  u16 huffbits[17];
+  int huffsym[17];
+} lje;
+
+int frequencyScan(lje *self) {
+  // Scan through the tile using the standard type 6 prediction
+  // Need to cache the previous 2 row in target coordinates because of tiling
+  uint16_t *pixel = self->image;
+  int pixcount = self->width * self->height;
+  int scan = self->readLength;
+  uint16_t *rowcache = (uint16_t *)calloc(1, self->width * 4);
+  uint16_t *rows[2];
+  rows[0] = rowcache;
+  rows[1] = &rowcache[self->width];
+
+  int col = 0;
+  int row = 0;
+  int Px = 0;
+  int32_t diff = 0;
+  int maxval = (1 << self->bitdepth);
+  while (pixcount--) {
+    uint16_t p = *pixel;
+    if (self->delinearize) {
+      if (p >= self->delinearizeLength) {
+        free(rowcache);
+        return LJ92_ERROR_TOO_WIDE;
+      }
+      p = self->delinearize[p];
+    }
+    if (p >= maxval) {
+      free(rowcache);
+      return LJ92_ERROR_TOO_WIDE;
+    }
+    rows[1][col] = p;
+
+    if ((row == 0) && (col == 0))
+      Px = 1 << (self->bitdepth - 1);
+    else if (row == 0)
+      Px = rows[1][col - 1];
+    else if (col == 0)
+      Px = rows[0][col];
+    else
+      Px = rows[0][col] + ((rows[1][col - 1] - rows[0][col - 1]) >> 1);
+    diff = rows[1][col] - Px;
+    int ssss = 32 - clz32(abs(diff));
+    if (diff == 0) ssss = 0;
+    self->hist[ssss]++;
+    // printf("%d %d %d %d %d %d\n",col,row,p,Px,diff,ssss);
+    pixel++;
+    scan--;
+    col++;
+    if (scan == 0) {
+      pixel += self->skipLength;
+      scan = self->readLength;
+    }
+    if (col == self->width) {
+      uint16_t *tmprow = rows[1];
+      rows[1] = rows[0];
+      rows[0] = tmprow;
+      col = 0;
+      row++;
+    }
+  }
+#ifdef DEBUG
+  int sort[17];
+  for (int h = 0; h < 17; h++) {
+    sort[h] = h;
+    printf("%d:%d\n", h, self->hist[h]);
+  }
+#endif
+  free(rowcache);
+  return LJ92_ERROR_NONE;
+}
+
+void createEncodeTable(lje *self) {
+  float freq[18];
+  int codesize[18];
+  int others[18];
+
+  // Calculate frequencies
+  float totalpixels = self->width * self->height;
+  for (int i = 0; i < 17; i++) {
+    freq[i] = (float)(self->hist[i]) / totalpixels;
+#ifdef DEBUG
+    printf("%d:%f\n", i, freq[i]);
+#endif
+    codesize[i] = 0;
+    others[i] = -1;
+  }
+  codesize[17] = 0;
+  others[17] = -1;
+  freq[17] = 1.0f;
+
+  float v1f, v2f;
+  int v1, v2;
+
+  while (1) {
+    v1f = 3.0f;
+    v1 = -1;
+    for (int i = 0; i < 18; i++) {
+      if ((freq[i] <= v1f) && (freq[i] > 0.0f)) {
+        v1f = freq[i];
+        v1 = i;
+      }
+    }
+#ifdef DEBUG
+    printf("v1:%d,%f\n", v1, v1f);
+#endif
+    v2f = 3.0f;
+    v2 = -1;
+    for (int i = 0; i < 18; i++) {
+      if (i == v1) continue;
+      if ((freq[i] < v2f) && (freq[i] > 0.0f)) {
+        v2f = freq[i];
+        v2 = i;
+      }
+    }
+    if (v2 == -1) break;  // Done
+
+    freq[v1] += freq[v2];
+    freq[v2] = 0.0f;
+
+    while (1) {
+      codesize[v1]++;
+      if (others[v1] == -1) break;
+      v1 = others[v1];
+    }
+    others[v1] = v2;
+    while (1) {
+      codesize[v2]++;
+      if (others[v2] == -1) break;
+      v2 = others[v2];
+    }
+  }
+  int *bits = self->bits;
+  memset(bits, 0, sizeof(self->bits));
+  for (int i = 0; i < 18; i++) {
+    if (codesize[i] != 0) {
+      bits[codesize[i]]++;
+    }
+  }
+#ifdef DEBUG
+  for (int i = 0; i < 17; i++) {
+    printf("bits:%d,%d,%d\n", i, bits[i], codesize[i]);
+  }
+#endif
+  int *huffval = self->huffval;
+  int i = 1;
+  int k = 0;
+  int j;
+  memset(huffval, 0, sizeof(self->huffval));
+  while (i <= 32) {
+    j = 0;
+    while (j < 17) {
+      if (codesize[j] == i) {
+        huffval[k++] = j;
+      }
+      j++;
+    }
+    i++;
+  }
+#ifdef DEBUG
+  for (i = 0; i < 17; i++) {
+    printf("i=%d,huffval[i]=%x\n", i, huffval[i]);
+  }
+#endif
+  int maxbits = 16;
+  while (maxbits > 0) {
+    if (bits[maxbits]) break;
+    maxbits--;
+  }
+  u16 *huffenc = self->huffenc;
+  u16 *huffbits = self->huffbits;
+  int *huffsym = self->huffsym;
+  memset(huffenc, 0, sizeof(self->huffenc));
+  memset(huffbits, 0, sizeof(self->huffbits));
+  memset(self->huffsym, 0, sizeof(self->huffsym));
+  i = 0;
+  int hv = 0;
+  int rv = 0;
+  int vl = 0;  // i
+  // int hcode;
+  int bitsused = 1;
+  int sym = 0;
+  // printf("%04x:%x:%d:%x\n",i,huffvals[hv],bitsused,1<<(maxbits-bitsused));
+  while (i < 1 << maxbits) {
+    if (bitsused > maxbits) {
+      break;  // Done. Should never get here!
+    }
+    if (vl >= bits[bitsused]) {
+      bitsused++;
+      vl = 0;
+      continue;
+    }
+    if (rv == 1 << (maxbits - bitsused)) {
+      rv = 0;
+      vl++;
+      hv++;
+      // printf("%04x:%x:%d:%x\n",i,huffvals[hv],bitsused,1<<(maxbits-bitsused));
+      continue;
+    }
+    huffbits[sym] = bitsused;
+    huffenc[sym++] = i >> (maxbits - bitsused);
+    // printf("%d %d %d\n",i,bitsused,hcode);
+    i += (1 << (maxbits - bitsused));
+    rv = 1 << (maxbits - bitsused);
+  }
+  for (i = 0; i < 17; i++) {
+    if (huffbits[i] > 0) {
+      huffsym[huffval[i]] = i;
+    }
+#ifdef DEBUG
+    printf("huffval[%d]=%d,huffenc[%d]=%x,bits=%d\n", i, huffval[i], i,
+           huffenc[i], huffbits[i]);
+#endif
+    if (huffbits[i] > 0) {
+      huffsym[huffval[i]] = i;
+    }
+  }
+#ifdef DEBUG
+  for (i = 0; i < 17; i++) {
+    printf("huffsym[%d]=%d\n", i, huffsym[i]);
+  }
+#endif
+}
+
+void writeHeader(lje *self) {
+  int w = self->encodedWritten;
+  uint8_t *e = self->encoded;
+  e[w++] = 0xff;
+  e[w++] = 0xd8;  // SOI
+  e[w++] = 0xff;
+  e[w++] = 0xc3;  // SOF3
+  // Write SOF
+  e[w++] = 0x0;
+  e[w++] = 11;  // Lf, frame header length
+  e[w++] = self->bitdepth;
+  e[w++] = self->height >> 8;
+  e[w++] = self->height & 0xFF;
+  e[w++] = self->width >> 8;
+  e[w++] = self->width & 0xFF;
+  e[w++] = 1;     // Components
+  e[w++] = 0;     // Component ID
+  e[w++] = 0x11;  // Component X/Y
+  e[w++] = 0;     // Unused (Quantisation)
+  e[w++] = 0xff;
+  e[w++] = 0xc4;  // HUFF
+  // Write HUFF
+  int count = 0;
+  for (int i = 0; i < 17; i++) {
+    count += self->bits[i];
+  }
+  e[w++] = 0x0;
+  e[w++] = 17 + 2 + count;  // Lf, frame header length
+  e[w++] = 0;               // Table ID
+  for (int i = 1; i < 17; i++) {
+    e[w++] = self->bits[i];
+  }
+  for (int i = 0; i < count; i++) {
+    e[w++] = self->huffval[i];
+  }
+  e[w++] = 0xff;
+  e[w++] = 0xda;  // SCAN
+  // Write SCAN
+  e[w++] = 0x0;
+  e[w++] = 8;  // Ls, scan header length
+  e[w++] = 1;  // Components
+  e[w++] = 0;  //
+  e[w++] = 0;  //
+  e[w++] = 6;  // Predictor
+  e[w++] = 0;  //
+  e[w++] = 0;  //
+  self->encodedWritten = w;
+}
+
+void writePost(lje *self) {
+  int w = self->encodedWritten;
+  uint8_t *e = self->encoded;
+  e[w++] = 0xff;
+  e[w++] = 0xd9;  // EOI
+  self->encodedWritten = w;
+}
+
+void writeBody(lje *self) {
+  // Scan through the tile using the standard type 6 prediction
+  // Need to cache the previous 2 row in target coordinates because of tiling
+  uint16_t *pixel = self->image;
+  int pixcount = self->width * self->height;
+  int scan = self->readLength;
+  uint16_t *rowcache = (uint16_t *)calloc(1, self->width * 4);
+  uint16_t *rows[2];
+  rows[0] = rowcache;
+  rows[1] = &rowcache[self->width];
+
+  int col = 0;
+  int row = 0;
+  int Px = 0;
+  int32_t diff = 0;
+  int bitcount = 0;
+  uint8_t *out = self->encoded;
+  int w = self->encodedWritten;
+  uint8_t next = 0;
+  uint8_t nextbits = 8;
+  while (pixcount--) {
+    uint16_t p = *pixel;
+    if (self->delinearize) p = self->delinearize[p];
+    rows[1][col] = p;
+
+    if ((row == 0) && (col == 0))
+      Px = 1 << (self->bitdepth - 1);
+    else if (row == 0)
+      Px = rows[1][col - 1];
+    else if (col == 0)
+      Px = rows[0][col];
+    else
+      Px = rows[0][col] + ((rows[1][col - 1] - rows[0][col - 1]) >> 1);
+    diff = rows[1][col] - Px;
+    int ssss = 32 - clz32(abs(diff));
+    if (diff == 0) ssss = 0;
+    // printf("%d %d %d %d %d\n",col,row,Px,diff,ssss);
+
+    // Write the huffman code for the ssss value
+    int huffcode = self->huffsym[ssss];
+    int huffenc = self->huffenc[huffcode];
+    int huffbits = self->huffbits[huffcode];
+    bitcount += huffbits + ssss;
+
+    int vt = ssss > 0 ? (1 << (ssss - 1)) : 0;
+    // printf("%d %d %d %d\n",rows[1][col],Px,diff,Px+diff);
+#ifdef DEBUG
+#endif
+    if (diff < vt) diff += (1 << (ssss)) - 1;
+
+    // Write the ssss
+    while (huffbits > 0) {
+      int usebits = huffbits > nextbits ? nextbits : huffbits;
+      // Add top usebits from huffval to next usebits of nextbits
+      int tophuff = huffenc >> (huffbits - usebits);
+      next |= (tophuff << (nextbits - usebits));
+      nextbits -= usebits;
+      huffbits -= usebits;
+      huffenc &= (1 << huffbits) - 1;
+      if (nextbits == 0) {
+        out[w++] = next;
+        if (next == 0xff) out[w++] = 0x0;
+        next = 0;
+        nextbits = 8;
+      }
+    }
+    // Write the rest of the bits for the value
+
+    while (ssss > 0) {
+      int usebits = ssss > nextbits ? nextbits : ssss;
+      // Add top usebits from huffval to next usebits of nextbits
+      int tophuff = diff >> (ssss - usebits);
+      next |= (tophuff << (nextbits - usebits));
+      nextbits -= usebits;
+      ssss -= usebits;
+      diff &= (1 << ssss) - 1;
+      if (nextbits == 0) {
+        out[w++] = next;
+        if (next == 0xff) out[w++] = 0x0;
+        next = 0;
+        nextbits = 8;
+      }
+    }
+
+    // printf("%d %d\n",diff,ssss);
+    pixel++;
+    scan--;
+    col++;
+    if (scan == 0) {
+      pixel += self->skipLength;
+      scan = self->readLength;
+    }
+    if (col == self->width) {
+      uint16_t *tmprow = rows[1];
+      rows[1] = rows[0];
+      rows[0] = tmprow;
+      col = 0;
+      row++;
+    }
+  }
+  // Flush the final bits
+  if (nextbits < 8) {
+    out[w++] = next;
+    if (next == 0xff) out[w++] = 0x0;
+  }
+#ifdef DEBUG
+  int sort[17];
+  for (int h = 0; h < 17; h++) {
+    sort[h] = h;
+    printf("%d:%d\n", h, self->hist[h]);
+  }
+  printf("Total bytes: %d\n", bitcount >> 3);
+#endif
+  free(rowcache);
+  self->encodedWritten = w;
+}
+
+/* Encoder
+ * Read tile from an image and encode in one shot
+ * Return the encoded data
+ */
+int lj92_encode(uint16_t *image, int width, int height, int bitdepth,
+                int readLength, int skipLength, uint16_t *delinearize,
+                int delinearizeLength, uint8_t **encoded, int *encodedLength) {
+  int ret = LJ92_ERROR_NONE;
+
+  lje *self = (lje *)calloc(sizeof(lje), 1);
+  if (self == NULL) return LJ92_ERROR_NO_MEMORY;
+  self->image = image;
+  self->width = width;
+  self->height = height;
+  self->bitdepth = bitdepth;
+  self->readLength = readLength;
+  self->skipLength = skipLength;
+  self->delinearize = delinearize;
+  self->delinearizeLength = delinearizeLength;
+  self->encodedLength = width * height * 3 + 200;
+  self->encoded = (uint8_t*)malloc(self->encodedLength);
+  if (self->encoded == NULL) {
+    free(self);
+    return LJ92_ERROR_NO_MEMORY;
+  }
+  // Scan through data to gather frequencies of ssss prefixes
+  ret = frequencyScan(self);
+  if (ret != LJ92_ERROR_NONE) {
+    free(self->encoded);
+    free(self);
+    return ret;
+  }
+  // Create encoded table based on frequencies
+  createEncodeTable(self);
+  // Write JPEG head and scan header
+  writeHeader(self);
+  // Scan through and do the compression
+  writeBody(self);
+  // Finish
+  writePost(self);
+#ifdef DEBUG
+  printf("written:%d\n", self->encodedWritten);
+#endif
+  self->encoded = (uint8_t*)realloc(self->encoded, self->encodedWritten);
+  self->encodedLength = self->encodedWritten;
+  *encoded = self->encoded;
+  *encodedLength = self->encodedLength;
+
+  free(self);
+
+  return ret;
+}
+
+// End liblj92 ---------------------------------------------------------
+
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
+}  // namespace detail
+
 #ifdef __clang__
 #pragma clang diagnostic push
 #if __has_warning("-Wzero-as-null-pointer-constant")
 #pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"
 #endif
 #endif
 
@@ -826,20 +1391,14 @@
   num_fields_++;
   return true;
 }
 
 bool DNGImage::SetCompression(const unsigned short value) {
   unsigned int count = 1;
 
-  if ((value == COMPRESSION_NONE)) {
-    // OK
-  } else {
-    return false;
-  }
-
   const unsigned short data = value;
   bool ret = WriteTIFFTag(
       static_cast<unsigned short>(TIFFTAG_COMPRESSION), TIFF_SHORT, count,
       reinterpret_cast<const unsigned char *>(&data), &ifd_tags_, &data_os_);
 
   if (!ret) {
     return false;
@@ -1590,46 +2149,58 @@
 
   num_fields_++;
   return true;
 }
 
 bool DNGImage::SetImageDataPacked(const unsigned short *input_buffer, const int input_count, const unsigned int input_bpp, bool big_endian)
 {
+
+#ifndef ROL32
+#define ROL32(v,a) ((v) << (a) | (v) >> (32-(a)))
+#endif
+
+#ifndef ROL16
+#define ROL16(v,a) ((v) << (a) | (v) >> (16-(a)))
+#endif
+
   if (input_count <= 0) {
     return false;
   }
 
   if (input_bpp > 16)
     return false;
-  
+
   unsigned int bits_free = 16 - input_bpp;
   const unsigned short *unpacked_bits = input_buffer;
 
   std::vector<unsigned short> output(static_cast<size_t>(input_count));
   unsigned short *packed_bits = output.data();
 
   packed_bits[0] = static_cast<unsigned short>(unpacked_bits[0] << bits_free);
   for (unsigned int pixel_index = 1; pixel_index < static_cast<unsigned int>(input_count); pixel_index++)
   {
     unsigned int bits_offset = (pixel_index * bits_free) % 16;
     unsigned int bits_to_rol = bits_free + bits_offset + (bits_offset > 0) * 16;
-    
+
     unsigned int data = ROL32(static_cast<unsigned int>(unpacked_bits[pixel_index]), bits_to_rol);
     *(reinterpret_cast<unsigned int *>(packed_bits)) = (*(reinterpret_cast<unsigned int *>(packed_bits)) & 0x0000FFFF) | data;
 
     if(bits_offset > 0 && bits_offset <= input_bpp)
     {
       if(big_endian)
         *(reinterpret_cast<unsigned short *>(packed_bits)) = static_cast<unsigned short>(ROL16(*(reinterpret_cast<unsigned short *>(packed_bits)), 8));
 
       ++packed_bits;
     }
   }
 
   return SetImageData(reinterpret_cast<unsigned char*>(output.data()), output.size() * sizeof(unsigned short));
+
+#undef ROL32
+#undef ROL16
 }
 
 bool DNGImage::SetImageData(const unsigned char *data, const size_t data_len) {
   if ((data == NULL) || (data_len < 1)) {
     return false;
   }
 
@@ -1656,14 +2227,56 @@
 
     num_fields_++;
   }
 
   return true;
 }
 
+bool DNGImage::SetImageDataJpeg(const unsigned short *data, unsigned int width,
+                                unsigned int height, unsigned int bpp) {
+  if ((data == NULL) || (height % 2 == 1) || (width % 2 == 1)) {
+    return false;
+  }
+
+  uint8_t *compressed = NULL;
+  int output_buffer_size = 0;
+
+  // Width x2 to move each second line
+  // -----------
+  // Before:
+  //
+  // GRGRGR...
+  // BGBGBG...
+  // GRGRGR...
+  // BGBGBG...
+  // -----------
+  // After:
+  //
+  // GRGRGR...BGBGBG...
+  // GRGRGR...BGBGBG...
+  // -----------
+  int new_width = int(width * 2);
+  int new_height = int(height / 2);
+
+  // Encode image
+  int ret = detail::lj92_encode(const_cast<unsigned short *>(data), new_width, new_height, int(bpp),
+                        new_width * new_height, 0, NULL, 0, &compressed,
+                        &output_buffer_size);
+
+  if (ret != detail::LJ92_ERROR_NONE)
+	  return false;
+
+  bool sid_res = SetImageData(compressed, size_t(output_buffer_size));
+
+  if (compressed)
+	  free(compressed);
+
+  return sid_res;
+}
+
 bool DNGImage::SetCustomFieldLong(const unsigned short tag, const int value) {
   unsigned int count = 1;
 
   // TODO(syoyo): Check if `tag` value does not conflict with existing TIFF tag
   // value.
 
   bool ret = WriteTIFFTag(tag, TIFF_SLONG, count,
```

### Comparing `tinyusdz-0.8.0rc0/src/external/tiny_gltf.h` & `tinyusdz-0.8.0rc1/src/external/tiny_gltf.h`

 * *Files 0% similar despite different names*

```diff
@@ -22,14 +22,19 @@
 // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
 // Version:
+//  - v2.6.3 Fix GLB file with empty BIN chunk was not handled. PR#382 and PR#383.
+//  - v2.6.2 Fix out-of-bounds access of accessors. PR#379.
+//  - v2.6.1 Better GLB validation check when loading.
+//  - v2.6.0 Support serializing sparse accessor(Thanks to @fynv).
+//           Disable expanding file path for security(no use of awkward `wordexp` anymore).
 //  - v2.5.0 Add SetPreserveImageChannels() option to load image data as is.
 //  - v2.4.3 Fix null object output when when material has all default
 //  parameters.
 //  - v2.4.2 Decode percent-encoded URI.
 //  - v2.4.1 Fix some glTF object class does not have `extensions` and/or
 //  `extras` property.
 //  - v2.4.0 Experimental RapidJSON and C++14 support(Thanks to @jrkoone).
@@ -60,14 +65,19 @@
 #include <cstdlib>
 #include <cstring>
 #include <limits>
 #include <map>
 #include <string>
 #include <vector>
 
+//Auto-detect C++14 standard version
+#if !defined(TINYGLTF_USE_CPP14) && defined(__cplusplus) && (__cplusplus >= 201402L)
+#define TINYGLTF_USE_CPP14
+#endif
+
 #ifndef TINYGLTF_USE_CPP14
 #include <functional>
 #endif
 
 #ifdef __ANDROID__
 #ifdef TINYGLTF_ANDROID_LOAD_FROM_ASSETS
 #include <android/asset_manager.h>
@@ -104,15 +114,19 @@
 #define TINYGLTF_COMPONENT_TYPE_BYTE (5120)
 #define TINYGLTF_COMPONENT_TYPE_UNSIGNED_BYTE (5121)
 #define TINYGLTF_COMPONENT_TYPE_SHORT (5122)
 #define TINYGLTF_COMPONENT_TYPE_UNSIGNED_SHORT (5123)
 #define TINYGLTF_COMPONENT_TYPE_INT (5124)
 #define TINYGLTF_COMPONENT_TYPE_UNSIGNED_INT (5125)
 #define TINYGLTF_COMPONENT_TYPE_FLOAT (5126)
-#define TINYGLTF_COMPONENT_TYPE_DOUBLE (5130) // OpenGL double type. Note that some of glTF 2.0 validator does not support double type even the schema seems allow any value of integer: https://github.com/KhronosGroup/glTF/blob/b9884a2fd45130b4d673dd6c8a706ee21ee5c5f7/specification/2.0/schema/accessor.schema.json#L22
+#define TINYGLTF_COMPONENT_TYPE_DOUBLE \
+  (5130)  // OpenGL double type. Note that some of glTF 2.0 validator does not
+          // support double type even the schema seems allow any value of
+          // integer:
+          // https://github.com/KhronosGroup/glTF/blob/b9884a2fd45130b4d673dd6c8a706ee21ee5c5f7/specification/2.0/schema/accessor.schema.json#L22
 
 #define TINYGLTF_TEXTURE_FILTER_NEAREST (9728)
 #define TINYGLTF_TEXTURE_FILTER_LINEAR (9729)
 #define TINYGLTF_TEXTURE_FILTER_NEAREST_MIPMAP_NEAREST (9984)
 #define TINYGLTF_TEXTURE_FILTER_LINEAR_MIPMAP_NEAREST (9985)
 #define TINYGLTF_TEXTURE_FILTER_NEAREST_MIPMAP_LINEAR (9986)
 #define TINYGLTF_TEXTURE_FILTER_LINEAR_MIPMAP_LINEAR (9987)
@@ -609,15 +623,16 @@
       -1;  // optional. -1 = no filter defined. ["NEAREST", "LINEAR"]
   int wrapS =
       TINYGLTF_TEXTURE_WRAP_REPEAT;  // ["CLAMP_TO_EDGE", "MIRRORED_REPEAT",
                                      // "REPEAT"], default "REPEAT"
   int wrapT =
       TINYGLTF_TEXTURE_WRAP_REPEAT;  // ["CLAMP_TO_EDGE", "MIRRORED_REPEAT",
                                      // "REPEAT"], default "REPEAT"
-  //int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;  // TinyGLTF extension. currently not used.
+  // int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;  // TinyGLTF extension. currently
+  // not used.
 
   Value extras;
   ExtensionMap extensions;
 
   // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.
   std::string extras_json_string;
   std::string extensions_json_string;
@@ -1298,16 +1313,18 @@
   bool LoadASCIIFromFile(Model *model, std::string *err, std::string *warn,
                          const std::string &filename,
                          unsigned int check_sections = REQUIRE_VERSION);
 
   ///
   /// Loads glTF ASCII asset from string(memory).
   /// `length` = strlen(str);
-  /// Set warning message to `warn` for example it fails to load asserts.
-  /// Returns false and set error string to `err` if there's an error.
+  /// `base_dir` is a search path of glTF asset(e.g. images). Path Must be an
+  /// expanded path (e.g. no tilde(`~`), no environment variables). Set warning
+  /// message to `warn` for example it fails to load asserts. Returns false and
+  /// set error string to `err` if there's an error.
   ///
   bool LoadASCIIFromString(Model *model, std::string *err, std::string *warn,
                            const char *str, const unsigned int length,
                            const std::string &base_dir,
                            unsigned int check_sections = REQUIRE_VERSION);
 
   ///
@@ -1318,14 +1335,16 @@
   bool LoadBinaryFromFile(Model *model, std::string *err, std::string *warn,
                           const std::string &filename,
                           unsigned int check_sections = REQUIRE_VERSION);
 
   ///
   /// Loads glTF binary asset from memory.
   /// `length` = strlen(str);
+  /// `base_dir` is a search path of glTF asset(e.g. images). Path Must be an
+  /// expanded path (e.g. no tilde(`~`), no environment variables).
   /// Set warning message to `warn` for example it fails to load asserts.
   /// Returns false and set error string to `err` if there's an error.
   ///
   bool LoadBinaryFromMemory(Model *model, std::string *err, std::string *warn,
                             const unsigned char *bytes,
                             const unsigned int length,
                             const std::string &base_dir = "",
@@ -1420,14 +1439,18 @@
   bool serialize_default_values_ = false;  ///< Serialize default values?
 
   bool store_original_json_for_extras_and_extensions_ = false;
 
   bool preserve_image_channels_ = false;  /// Default false(expand channels to
                                           /// RGBA) for backward compatibility.
 
+  // Warning & error messages
+  std::string warn_;
+  std::string err_;
+
   FsCallbacks fs = {
 #ifndef TINYGLTF_NO_FS
       &tinygltf::FileExists, &tinygltf::ExpandFilePath,
       &tinygltf::ReadWholeFile, &tinygltf::WriteWholeFile,
 
       nullptr  // Fs callback user data
 #else
@@ -1601,18 +1624,18 @@
 #include <fcntl.h>  // _O_RDONLY
 
 #include <ext/stdio_filebuf.h>  // fstream (all sorts of IO stuff) + stdio_filebuf (=streambuf)
 
 #endif
 
 #elif !defined(__ANDROID__) && !defined(__OpenBSD__)
-#include <wordexp.h>
+//#include <wordexp.h>
 #endif
 
-#if defined(__sparcv9)
+#if defined(__sparcv9) || defined(__powerpc__)
 // Big endian
 #else
 #if (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || MINIZ_X86_OR_X64_CPU
 #define TINYGLTF_LITTLE_ENDIAN 1
 #endif
 #endif
 
@@ -1929,18 +1952,17 @@
          this->indices == other.indices && this->material == other.material &&
          this->mode == other.mode && this->targets == other.targets;
 }
 bool Sampler::operator==(const Sampler &other) const {
   return this->extensions == other.extensions && this->extras == other.extras &&
          this->magFilter == other.magFilter &&
          this->minFilter == other.minFilter && this->name == other.name &&
-         this->wrapS == other.wrapS &&
-         this->wrapT == other.wrapT;
+         this->wrapS == other.wrapS && this->wrapT == other.wrapT;
 
-         //this->wrapR == other.wrapR
+  // this->wrapR == other.wrapR
 }
 bool Scene::operator==(const Scene &other) const {
   return this->extensions == other.extensions && this->extras == other.extras &&
          this->name == other.name && this->nodes == other.nodes;
 }
 bool Skin::operator==(const Skin &other) const {
   return this->extensions == other.extensions && this->extras == other.extras &&
@@ -2038,16 +2060,15 @@
   if (filepath.find_last_of("/\\") != std::string::npos)
     return filepath.substr(0, filepath.find_last_of("/\\"));
   return "";
 }
 
 static std::string GetBaseFilename(const std::string &filepath) {
   auto idx = filepath.find_last_of("/\\");
-  if (idx != std::string::npos)
-    return filepath.substr(idx + 1);
+  if (idx != std::string::npos) return filepath.substr(idx + 1);
   return filepath;
 }
 
 std::string base64_encode(unsigned char const *, unsigned int len);
 std::string base64_decode(std::string const &s);
 
 /*
@@ -2572,15 +2593,15 @@
     AAsset_close(asset);
     ret = true;
   } else {
     return false;
   }
 #else
 #ifdef _WIN32
-#if defined(_MSC_VER) || defined(__GLIBCXX__)
+#if defined(_MSC_VER) || defined(__GLIBCXX__) || defined(_LIBCPP_VERSION)
   FILE *fp = nullptr;
   errno_t err = _wfopen_s(&fp, UTF8ToWchar(abs_filename).c_str(), L"rb");
   if (err != 0) {
     return false;
   }
 #else
   FILE *fp = nullptr;
@@ -2601,14 +2622,26 @@
   }
 #endif
 
   return ret;
 }
 
 std::string ExpandFilePath(const std::string &filepath, void *) {
+  // https://github.com/syoyo/tinygltf/issues/368
+  //
+  // No file path expansion in built-in FS function anymore, since glTF URI
+  // should not contain tilde('~') and environment variables, and for security
+  // reason(`wordexp`).
+  //
+  // Users need to supply `base_dir`(in `LoadASCIIFromString`,
+  // `LoadBinaryFromMemory`) in expanded absolute path.
+
+  return filepath;
+
+#if 0
 #ifdef _WIN32
   // Assume input `filepath` is encoded in UTF-8
   std::wstring wfilepath = UTF8ToWchar(filepath);
   DWORD wlen = ExpandEnvironmentStringsW(wfilepath.c_str(), nullptr, 0);
   wchar_t *wstr = new wchar_t[wlen];
   ExpandEnvironmentStringsW(wfilepath.c_str(), wstr, wlen);
 
@@ -2648,14 +2681,15 @@
     s = filepath;
   }
 
 #endif
 
   return s;
 #endif
+#endif
 }
 
 bool ReadWholeFile(std::vector<unsigned char> *out, std::string *err,
                    const std::string &filepath, void *) {
 #ifdef TINYGLTF_ANDROID_LOAD_FROM_ASSETS
   if (asset_manager) {
     AAsset *asset = AAssetManager_open(asset_manager, filepath.c_str(),
@@ -3088,19 +3122,25 @@
 
 std::string JsonToString(const json &o, int spacing = -1) {
 #ifdef TINYGLTF_USE_RAPIDJSON
   using namespace rapidjson;
   StringBuffer buffer;
   if (spacing == -1) {
     Writer<StringBuffer> writer(buffer);
-    o.Accept(writer);
+    // TODO: Better error handling.
+    // https://github.com/syoyo/tinygltf/issues/332
+    if (!o.Accept(writer)) {
+      return "tiny_gltf::JsonToString() failed rapidjson conversion";
+    }
   } else {
     PrettyWriter<StringBuffer> writer(buffer);
     writer.SetIndent(' ', uint32_t(spacing));
-    o.Accept(writer);
+    if (!o.Accept(writer)) {
+      return "tiny_gltf::JsonToString() failed rapidjson conversion";
+    }
   }
   return buffer.GetString();
 #else
   return o.dump(spacing);
 #endif
 }
 
@@ -3193,17 +3233,19 @@
     case json::value_t::null:
     case json::value_t::discarded:
     case json::value_t::binary:
       // default:
       break;
   }
 #endif
+  const bool isNotNull = val.Type() != NULL_TYPE;
+
   if (ret) *ret = std::move(val);
 
-  return val.Type() != NULL_TYPE;
+  return isNotNull;
 }
 
 static bool ParseExtrasProperty(Value *ret, const json &o) {
   json_const_iterator it;
   if (!FindMember(o, "extras", it)) {
     return false;
   }
@@ -3635,15 +3677,16 @@
     // Found string property.
     return true;
   } else if (ParseNumberArrayProperty(&param->number_array, err, o, prop,
                                       false)) {
     // Found a number array.
     return true;
   } else if (ParseNumberProperty(&param->number_value, err, o, prop, false)) {
-    return param->has_number_value = true;
+    param->has_number_value = true;
+    return true;
   } else if (ParseJSONProperty(&param->json_double_value, err, o, prop,
                                false)) {
     return true;
   } else if (ParseBooleanProperty(&param->bool_value, err, o, prop, false)) {
     return true;
   } else {
     if (required) {
@@ -3828,15 +3871,15 @@
     }
   } else {
     // Assume external file
     // Keep texture path (for textures that cannot be decoded)
     image->uri = uri;
 #ifdef TINYGLTF_NO_EXTERNAL_IMAGE
     return true;
-#endif
+#else
     std::string decoded_uri = dlib::urldecode(uri);
     if (!LoadExternalFile(&img, err, warn, decoded_uri, basedir,
                           /* required */ false, /* required bytes */ 0,
                           /* checksize */ false, fs)) {
       if (warn) {
         (*warn) += "Failed to load external 'uri' for image[" +
                    std::to_string(image_idx) + "] name = [" + image->name +
@@ -3850,14 +3893,15 @@
       if (warn) {
         (*warn) += "Image data is empty for image[" +
                    std::to_string(image_idx) + "] name = [" + image->name +
                    "] \n";
       }
       return false;
     }
+#endif
   }
 
   if (*LoadImageData == nullptr) {
     if (err) {
       (*err) += "No LoadImageData callback specified.\n";
     }
     return false;
@@ -4066,15 +4110,15 @@
         }
       }
     } else {
       // load data from (embedded) binary data
 
       if ((bin_size == 0) || (bin_data == nullptr)) {
         if (err) {
-          (*err) += "Invalid binary data in `Buffer'.\n";
+          (*err) += "Invalid binary data in `Buffer', or GLB with empty BIN chunk.\n";
         }
         return false;
       }
 
       if (byteLength > bin_size) {
         if (err) {
           std::stringstream ss;
@@ -4232,28 +4276,28 @@
     return false;
   }
 
   const json &indices_obj = GetValue(indices_iterator);
   const json &values_obj = GetValue(values_iterator);
 
   int indices_buffer_view = 0, indices_byte_offset = 0, component_type = 0;
-  if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj, "bufferView",
-                       true, "SparseAccessor")) {
+  if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj,
+                            "bufferView", true, "SparseAccessor")) {
     return false;
   }
   ParseIntegerProperty(&indices_byte_offset, err, indices_obj, "byteOffset",
                        false);
   if (!ParseIntegerProperty(&component_type, err, indices_obj, "componentType",
-                       true, "SparseAccessor")) {
+                            true, "SparseAccessor")) {
     return false;
   }
 
   int values_buffer_view = 0, values_byte_offset = 0;
   if (!ParseIntegerProperty(&values_buffer_view, err, values_obj, "bufferView",
-                       true, "SparseAccessor")) {
+                            true, "SparseAccessor")) {
     return false;
   }
   ParseIntegerProperty(&values_byte_offset, err, values_obj, "byteOffset",
                        false);
 
   accessor->sparse.count = count;
   accessor->sparse.indices.bufferView = indices_buffer_view;
@@ -5084,29 +5128,30 @@
                          bool store_original_json_for_extras_and_extensions) {
   ParseStringProperty(&sampler->name, err, o, "name", false);
 
   int minFilter = -1;
   int magFilter = -1;
   int wrapS = TINYGLTF_TEXTURE_WRAP_REPEAT;
   int wrapT = TINYGLTF_TEXTURE_WRAP_REPEAT;
-  //int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;
+  // int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;
   ParseIntegerProperty(&minFilter, err, o, "minFilter", false);
   ParseIntegerProperty(&magFilter, err, o, "magFilter", false);
   ParseIntegerProperty(&wrapS, err, o, "wrapS", false);
   ParseIntegerProperty(&wrapT, err, o, "wrapT", false);
-  //ParseIntegerProperty(&wrapR, err, o, "wrapR", false);  // tinygltf extension
+  // ParseIntegerProperty(&wrapR, err, o, "wrapR", false);  // tinygltf
+  // extension
 
   // TODO(syoyo): Check the value is alloed one.
   // (e.g. we allow 9728(NEAREST), but don't allow 9727)
 
   sampler->minFilter = minFilter;
   sampler->magFilter = magFilter;
   sampler->wrapS = wrapS;
   sampler->wrapT = wrapT;
-  //sampler->wrapR = wrapR;
+  // sampler->wrapR = wrapR;
 
   ParseExtensionsProperty(&(sampler->extensions), err, o);
   ParseExtrasProperty(&(sampler->extras), o);
 
   if (store_original_json_for_extras_and_extensions) {
     {
       json_const_iterator it;
@@ -5757,28 +5802,35 @@
         model->bufferViews[size_t(bufferView)].target =
             TINYGLTF_TARGET_ELEMENT_ARRAY_BUFFER;
         // we could optionally check if acessors' bufferView type is Scalar, as
         // it should be
       }
 
       for (auto &attribute : primitive.attributes) {
-        model
-            ->bufferViews[size_t(
-                model->accessors[size_t(attribute.second)].bufferView)]
-            .target = TINYGLTF_TARGET_ARRAY_BUFFER;
+        const auto accessorsIndex = size_t(attribute.second);
+        if (accessorsIndex < model->accessors.size()) {
+          const auto bufferView = model->accessors[accessorsIndex].bufferView;
+          // bufferView could be null(-1) for sparse morph target
+          if (bufferView >= 0 && bufferView < model->bufferViews.size()) {
+            model->bufferViews[size_t(bufferView)].target =
+                TINYGLTF_TARGET_ARRAY_BUFFER;
+          }
+        }
       }
 
       for (auto &target : primitive.targets) {
         for (auto &attribute : target) {
-          auto bufferView =
-              model->accessors[size_t(attribute.second)].bufferView;
-          // bufferView could be null(-1) for sparse morph target
-          if (bufferView >= 0) {
-            model->bufferViews[size_t(bufferView)].target =
-                TINYGLTF_TARGET_ARRAY_BUFFER;
+          const auto accessorsIndex = size_t(attribute.second);
+          if (accessorsIndex < model->accessors.size()) {
+            const auto bufferView = model->accessors[accessorsIndex].bufferView;
+            // bufferView could be null(-1) for sparse morph target
+            if (bufferView >= 0 && bufferView < model->bufferViews.size()) {
+              model->bufferViews[size_t(bufferView)].target =
+                  TINYGLTF_TARGET_ARRAY_BUFFER;
+            }
           }
         }
       }
     }
   }
 
   // 7. Parse Node
@@ -6211,52 +6263,133 @@
       (*err) = "Invalid magic.";
     }
     return false;
   }
 
   unsigned int version;       // 4 bytes
   unsigned int length;        // 4 bytes
-  unsigned int model_length;  // 4 bytes
-  unsigned int model_format;  // 4 bytes;
+  unsigned int chunk0_length;  // 4 bytes
+  unsigned int chunk0_format;  // 4 bytes;
 
-  // @todo { Endian swap for big endian machine. }
   memcpy(&version, bytes + 4, 4);
   swap4(&version);
   memcpy(&length, bytes + 8, 4);
   swap4(&length);
-  memcpy(&model_length, bytes + 12, 4);
-  swap4(&model_length);
-  memcpy(&model_format, bytes + 16, 4);
-  swap4(&model_format);
+  memcpy(&chunk0_length, bytes + 12, 4); // JSON data length
+  swap4(&chunk0_length);
+  memcpy(&chunk0_format, bytes + 16, 4);
+  swap4(&chunk0_format);
 
+  // https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#binary-gltf-layout
+  //
   // In case the Bin buffer is not present, the size is exactly 20 + size of
   // JSON contents,
   // so use "greater than" operator.
-  if ((20 + model_length > size) || (model_length < 1) || (length > size) ||
-      (20 + model_length > length) ||
-      (model_format != 0x4E4F534A)) {  // 0x4E4F534A = JSON format.
+  //
+  // https://github.com/syoyo/tinygltf/issues/372
+  // Use 64bit uint to avoid integer overflow.
+  uint64_t header_and_json_size = 20ull + uint64_t(chunk0_length);
+
+  if (header_and_json_size > std::numeric_limits<uint32_t>::max()) {
+    // Do not allow 4GB or more GLB data.
+   (*err) = "Invalid glTF binary. GLB data exceeds 4GB.";
+  }
+
+  if ((header_and_json_size > uint64_t(size)) || (chunk0_length < 1) || (length > size) ||
+      (header_and_json_size > uint64_t(length)) ||
+      (chunk0_format != 0x4E4F534A)) {  // 0x4E4F534A = JSON format.
     if (err) {
       (*err) = "Invalid glTF binary.";
     }
     return false;
   }
 
+  // Padding check
+  // The start and the end of each chunk must be aligned to a 4-byte boundary.
+  // No padding check for chunk0 start since its 4byte-boundary is ensured.
+  if ((header_and_json_size % 4) != 0) {
+    if (err) {
+      (*err) = "JSON Chunk end does not aligned to a 4-byte boundary.";
+    }
+  }
+
+  //std::cout << "header_and_json_size = " << header_and_json_size << "\n";
+  //std::cout << "length = " << length << "\n";
+
+  // Chunk1(BIN) data
+  // The spec says: When the binary buffer is empty or when it is stored by other means, this chunk SHOULD be omitted.
+  // So when header + JSON data == binary size, Chunk1 is omitted.
+  if (header_and_json_size == uint64_t(length)) {
+
+    bin_data_ = nullptr;
+    bin_size_ = 0;
+  } else {
+    // Read Chunk1 info(BIN data)
+    // At least Chunk1 should have 12 bytes(8 bytes(header) + 4 bytes(bin payload could be 1~3 bytes, but need to be aliged to 4 bytes)
+    if ((header_and_json_size + 12ull) > uint64_t(length)) {
+      if (err) {
+        (*err) = "Insufficient storage space for Chunk1(BIN data). At least Chunk1 Must have 4 bytes or more bytes, but got " + std::to_string((header_and_json_size + 12ull) - uint64_t(length)) + ".\n";
+      }
+      return false;
+    }
+
+    unsigned int chunk1_length;  // 4 bytes
+    unsigned int chunk1_format;  // 4 bytes;
+    memcpy(&chunk1_length, bytes + header_and_json_size, 4); // JSON data length
+    swap4(&chunk1_length);
+    memcpy(&chunk1_format, bytes + header_and_json_size + 4, 4);
+    swap4(&chunk1_format);
+
+    //std::cout << "chunk1_length = " << chunk1_length << "\n";
+
+    if (chunk1_length < 4) {
+      if (err) {
+        (*err) = "Insufficient Chunk1(BIN) data size.";
+      }
+      return false;
+    }
+
+    if ((chunk1_length % 4) != 0) {
+      if (err) {
+        (*err) = "BIN Chunk end does not aligned to a 4-byte boundary.";
+      }
+      return false;
+    }
+
+    if (uint64_t(chunk1_length) + header_and_json_size > uint64_t(length)) {
+      if (err) {
+        (*err) = "BIN Chunk data length exceeds the GLB size.";
+      }
+      return false;
+    }
+
+    if (chunk1_format != 0x004e4942) {
+      if (err) {
+        (*err) = "Invlid type for chunk1 data.";
+      }
+      return false;
+    }
+
+    //std::cout << "chunk1_length = " << chunk1_length << "\n";
+
+    bin_data_ = bytes + header_and_json_size +
+                8;  // 4 bytes (bin_buffer_length) + 4 bytes(bin_buffer_format)
+
+    bin_size_ = size_t(chunk1_length);
+  }
+
   // Extract JSON string.
   std::string jsonString(reinterpret_cast<const char *>(&bytes[20]),
-                         model_length);
+                         chunk0_length);
 
   is_binary_ = true;
-  bin_data_ = bytes + 20 + model_length +
-              8;  // 4 bytes (buffer_length) + 4 bytes(buffer_format)
-  bin_size_ =
-      length - (20 + model_length);  // extract header + JSON scene data.
 
   bool ret = LoadFromString(model, err, warn,
                             reinterpret_cast<const char *>(&bytes[20]),
-                            model_length, base_dir, check_sections);
+                            chunk0_length, base_dir, check_sections);
   if (!ret) {
     return ret;
   }
 
   return true;
 }
 
@@ -6679,14 +6812,35 @@
 
   SerializeStringProperty("type", type, o);
   if (!accessor.name.empty()) SerializeStringProperty("name", accessor.name, o);
 
   if (accessor.extras.Type() != NULL_TYPE) {
     SerializeValue("extras", accessor.extras, o);
   }
+
+  // sparse
+  if (accessor.sparse.isSparse)
+  {
+      json sparse;
+      SerializeNumberProperty<int>("count", accessor.sparse.count, sparse);
+      {
+          json indices;
+          SerializeNumberProperty<int>("bufferView", accessor.sparse.indices.bufferView, indices);
+          SerializeNumberProperty<int>("byteOffset", accessor.sparse.indices.byteOffset, indices);
+          SerializeNumberProperty<int>("componentType", accessor.sparse.indices.componentType, indices);
+          JsonAddMember(sparse, "indices", std::move(indices));
+      }
+      {
+          json values;
+          SerializeNumberProperty<int>("bufferView", accessor.sparse.values.bufferView, values);
+          SerializeNumberProperty<int>("byteOffset", accessor.sparse.values.byteOffset, values);
+          JsonAddMember(sparse, "values", std::move(values));
+      }
+      JsonAddMember(o, "sparse", std::move(sparse));
+  }
 }
 
 static void SerializeGltfAnimationChannel(AnimationChannel &channel, json &o) {
   SerializeNumberProperty("sampler", channel.sampler, o);
   {
     json target;
     SerializeNumberProperty("node", channel.target_node, target);
@@ -7161,15 +7315,15 @@
 static void SerializeGltfSampler(Sampler &sampler, json &o) {
   if (sampler.magFilter != -1) {
     SerializeNumberProperty("magFilter", sampler.magFilter, o);
   }
   if (sampler.minFilter != -1) {
     SerializeNumberProperty("minFilter", sampler.minFilter, o);
   }
-  //SerializeNumberProperty("wrapR", sampler.wrapR, o);
+  // SerializeNumberProperty("wrapR", sampler.wrapR, o);
   SerializeNumberProperty("wrapS", sampler.wrapS, o);
   SerializeNumberProperty("wrapT", sampler.wrapT, o);
 
   if (sampler.extras.Type() != NULL_TYPE) {
     SerializeValue("extras", sampler.extras, o);
   }
 }
@@ -7515,25 +7669,27 @@
 #else
   std::ofstream gltfFile(output.c_str());
   if (!gltfFile.is_open()) return false;
 #endif
   return WriteGltfStream(gltfFile, content);
 }
 
-static void WriteBinaryGltfStream(std::ostream &stream,
+static bool WriteBinaryGltfStream(std::ostream &stream,
                                   const std::string &content,
                                   const std::vector<unsigned char> &binBuffer) {
   const std::string header = "glTF";
   const int version = 2;
 
   const uint32_t content_size = uint32_t(content.size());
   const uint32_t binBuffer_size = uint32_t(binBuffer.size());
   // determine number of padding bytes required to ensure 4 byte alignment
-  const uint32_t content_padding_size = content_size % 4 == 0 ? 0 : 4 - content_size % 4;
-  const uint32_t bin_padding_size = binBuffer_size % 4 == 0 ? 0 : 4 - binBuffer_size % 4;
+  const uint32_t content_padding_size =
+      content_size % 4 == 0 ? 0 : 4 - content_size % 4;
+  const uint32_t bin_padding_size =
+      binBuffer_size % 4 == 0 ? 0 : 4 - binBuffer_size % 4;
 
   // 12 bytes for header, JSON content length, 8 bytes for JSON chunk info.
   // Chunk data must be located at 4-byte boundary, which may require padding
   const uint32_t length =
       12 + 8 + content_size + content_padding_size +
       (binBuffer_size ? (8 + binBuffer_size + bin_padding_size) : 0);
 
@@ -7569,17 +7725,20 @@
     if (bin_padding_size > 0) {
       const std::vector<unsigned char> padding =
           std::vector<unsigned char>(size_t(bin_padding_size), 0);
       stream.write(reinterpret_cast<const char *>(padding.data()),
                    std::streamsize(padding.size()));
     }
   }
+
+  // TODO: Check error on stream.write
+  return true;
 }
 
-static void WriteBinaryGltfFile(const std::string &output,
+static bool WriteBinaryGltfFile(const std::string &output,
                                 const std::string &content,
                                 const std::vector<unsigned char> &binBuffer) {
 #ifdef _WIN32
 #if defined(_MSC_VER)
   std::ofstream gltfFile(UTF8ToWchar(output).c_str(), std::ios::binary);
 #elif defined(__GLIBCXX__)
   int file_descriptor = _wopen(UTF8ToWchar(output).c_str(),
@@ -7589,15 +7748,15 @@
   std::ostream gltfFile(&wfile_buf);
 #else
   std::ofstream gltfFile(output.c_str(), std::ios::binary);
 #endif
 #else
   std::ofstream gltfFile(output.c_str(), std::ios::binary);
 #endif
-  WriteBinaryGltfStream(gltfFile, content, binBuffer);
+  return WriteBinaryGltfStream(gltfFile, content, binBuffer);
 }
 
 bool TinyGLTF::WriteGltfSceneToStream(Model *model, std::ostream &stream,
                                       bool prettyPrint = true,
                                       bool writeBinary = false) {
   JsonDocument output;
 
@@ -7628,29 +7787,28 @@
     for (unsigned int i = 0; i < model->images.size(); ++i) {
       json image;
 
       std::string dummystring = "";
       // UpdateImageObject need baseDir but only uses it if embeddedImages is
       // enabled, since we won't write separate images when writing to a stream
       // we
-      UpdateImageObject(model->images[i], dummystring, int(i), false,
+      UpdateImageObject(model->images[i], dummystring, int(i), true,
                         &this->WriteImageData, this->write_image_user_data_);
       SerializeGltfImage(model->images[i], image);
       JsonPushBack(images, std::move(image));
     }
     JsonAddMember(output, "images", std::move(images));
   }
 
   if (writeBinary) {
-    WriteBinaryGltfStream(stream, JsonToString(output), binBuffer);
+    return WriteBinaryGltfStream(stream, JsonToString(output), binBuffer);
   } else {
-    WriteGltfStream(stream, JsonToString(output, prettyPrint ? 2 : -1));
+    return WriteGltfStream(stream, JsonToString(output, prettyPrint ? 2 : -1));
   }
 
-  return true;
 }
 
 bool TinyGLTF::WriteGltfSceneToFile(Model *model, const std::string &filename,
                                     bool embedImages = false,
                                     bool embedBuffers = false,
                                     bool prettyPrint = true,
                                     bool writeBinary = false) {
@@ -7727,20 +7885,19 @@
       SerializeGltfImage(model->images[i], image);
       JsonPushBack(images, std::move(image));
     }
     JsonAddMember(output, "images", std::move(images));
   }
 
   if (writeBinary) {
-    WriteBinaryGltfFile(filename, JsonToString(output), binBuffer);
+    return WriteBinaryGltfFile(filename, JsonToString(output), binBuffer);
   } else {
-    WriteGltfFile(filename, JsonToString(output, (prettyPrint ? 2 : -1)));
+    return WriteGltfFile(filename, JsonToString(output, (prettyPrint ? 2 : -1)));
   }
 
-  return true;
 }
 
 }  // namespace tinygltf
 
 #ifdef __clang__
 #pragma clang diagnostic pop
 #endif
```

### Comparing `tinyusdz-0.8.0rc0/src/external/tiny_obj_loader.h` & `tinyusdz-0.8.0rc1/src/external/tiny_obj_loader.h`

 * *Files 2% similar despite different names*

```diff
@@ -527,15 +527,14 @@
 
 ///
 /// Wavefront .obj reader class(v2 API)
 ///
 class ObjReader {
  public:
   ObjReader() : valid_(false) {}
-  ~ObjReader() {}
 
   ///
   /// Load .obj and .mtl from a file.
   ///
   /// @param[in] filename wavefront .obj filename
   /// @param[in] config Reader configuration
   ///
@@ -654,14 +653,15 @@
 #include <cctype>
 #include <cmath>
 #include <cstddef>
 #include <cstdlib>
 #include <cstring>
 #include <fstream>
 #include <limits>
+#include <set>
 #include <sstream>
 #include <utility>
 
 #ifdef TINYOBJLOADER_USE_MAPBOX_EARCUT
 
 #ifdef TINYOBJLOADER_DONOT_INCLUDE_MAPBOX_EARCUT
 // Assume earcut.hpp is included outside of tiny_obj_loader.h
@@ -1393,14 +1393,49 @@
          (vertx[j] - vertx[i]) * (testy - verty[i]) / (verty[j] - verty[i]) +
              vertx[i]))
       c = !c;
   }
   return c;
 }
 
+struct TinyObjPoint {
+  real_t x, y, z;
+  TinyObjPoint() : x(0), y(0), z(0) {}
+  TinyObjPoint(real_t x_, real_t y_, real_t z_) :
+    x(x_), y(y_), z(z_) {}
+};
+
+inline TinyObjPoint cross(const TinyObjPoint &v1, const TinyObjPoint &v2) {
+  return TinyObjPoint(v1.y * v2.z - v1.z * v2.y,
+                      v1.z * v2.x - v1.x * v2.z,
+                      v1.x * v2.y - v1.y * v2.x);
+}
+
+inline real_t dot(const TinyObjPoint &v1, const TinyObjPoint &v2) {
+  return (v1.x * v2.x + v1.y * v2.y + v1.z * v2.z);
+}
+
+inline real_t GetLength(TinyObjPoint &e) {
+	return std::sqrt(e.x*e.x + e.y*e.y + e.z*e.z);
+}
+
+inline TinyObjPoint Normalize(TinyObjPoint e) {
+	real_t inv_length = 1.0 / GetLength(e);
+	return TinyObjPoint(e.x * inv_length, e.y * inv_length, e.z * inv_length );
+}
+
+
+inline TinyObjPoint WorldToLocal(const TinyObjPoint& a,
+										  const TinyObjPoint& u,
+										  const TinyObjPoint& v,
+										  const TinyObjPoint& w) {
+  return TinyObjPoint(dot(a,u),dot(a,v),dot(a,w));
+}
+
+
 // TODO(syoyo): refactor function.
 static bool exportGroupsToShape(shape_t *shape, const PrimGroup &prim_group,
                                 const std::vector<tag_t> &tags,
                                 const int material_id, const std::string &name,
                                 bool triangulate, const std::vector<real_t> &v,
                                 std::string *warn) {
   if (prim_group.IsEmpty()) {
@@ -1421,15 +1456,15 @@
         // Face must have 3+ vertices.
         if (warn) {
           (*warn) += "Degenerated face found\n.";
         }
         continue;
       }
 
-      if (triangulate) {
+      if (triangulate && npolys != 3) {
         if (npolys == 4) {
           vertex_index_t i0 = face.vertex_indices[0];
           vertex_index_t i1 = face.vertex_indices[1];
           vertex_index_t i2 = face.vertex_indices[2];
           vertex_index_t i3 = face.vertex_indices[3];
 
           size_t vi0 = size_t(i0.v_idx);
@@ -1530,133 +1565,190 @@
           shape->mesh.material_ids.push_back(material_id);
           shape->mesh.material_ids.push_back(material_id);
 
           shape->mesh.smoothing_group_ids.push_back(face.smoothing_group_id);
           shape->mesh.smoothing_group_ids.push_back(face.smoothing_group_id);
 
         } else {
+#ifdef TINYOBJLOADER_USE_MAPBOX_EARCUT
           vertex_index_t i0 = face.vertex_indices[0];
-          vertex_index_t i1(-1);
-          vertex_index_t i2 = face.vertex_indices[1];
+          vertex_index_t i0_2 = i0;
 
-          // find the two axes to work in
-          size_t axes[2] = {1, 2};
+          // TMW change: Find the normal axis of the polygon using Newell's method
+          TinyObjPoint n;
           for (size_t k = 0; k < npolys; ++k) {
-            i0 = face.vertex_indices[(k + 0) % npolys];
-            i1 = face.vertex_indices[(k + 1) % npolys];
-            i2 = face.vertex_indices[(k + 2) % npolys];
+            i0 = face.vertex_indices[k % npolys];
             size_t vi0 = size_t(i0.v_idx);
-            size_t vi1 = size_t(i1.v_idx);
-            size_t vi2 = size_t(i2.v_idx);
 
-            if (((3 * vi0 + 2) >= v.size()) || ((3 * vi1 + 2) >= v.size()) ||
-                ((3 * vi2 + 2) >= v.size())) {
-              // Invalid triangle.
-              // FIXME(syoyo): Is it ok to simply skip this invalid triangle?
-              continue;
-            }
+            size_t j = (k + 1) % npolys;
+            i0_2 = face.vertex_indices[j];
+            size_t vi0_2 = size_t(i0_2.v_idx);
+
             real_t v0x = v[vi0 * 3 + 0];
             real_t v0y = v[vi0 * 3 + 1];
             real_t v0z = v[vi0 * 3 + 2];
-            real_t v1x = v[vi1 * 3 + 0];
-            real_t v1y = v[vi1 * 3 + 1];
-            real_t v1z = v[vi1 * 3 + 2];
-            real_t v2x = v[vi2 * 3 + 0];
-            real_t v2y = v[vi2 * 3 + 1];
-            real_t v2z = v[vi2 * 3 + 2];
-            real_t e0x = v1x - v0x;
-            real_t e0y = v1y - v0y;
-            real_t e0z = v1z - v0z;
-            real_t e1x = v2x - v1x;
-            real_t e1y = v2y - v1y;
-            real_t e1z = v2z - v1z;
-            real_t cx = std::fabs(e0y * e1z - e0z * e1y);
-            real_t cy = std::fabs(e0z * e1x - e0x * e1z);
-            real_t cz = std::fabs(e0x * e1y - e0y * e1x);
-            const real_t epsilon = std::numeric_limits<real_t>::epsilon();
-            // std::cout << "cx " << cx << ", cy " << cy << ", cz " << cz <<
-            // "\n";
-            if (cx > epsilon || cy > epsilon || cz > epsilon) {
-              // std::cout << "corner\n";
-              // found a corner
-              if (cx > cy && cx > cz) {
-                // std::cout << "pattern0\n";
-              } else {
-                // std::cout << "axes[0] = 0\n";
-                axes[0] = 0;
-                if (cz > cx && cz > cy) {
-                  // std::cout << "axes[1] = 1\n";
-                  axes[1] = 1;
-                }
-              }
-              break;
-            }
-          }
 
-#ifdef TINYOBJLOADER_USE_MAPBOX_EARCUT
+            real_t v0x_2 = v[vi0_2 * 3 + 0];
+            real_t v0y_2 = v[vi0_2 * 3 + 1];
+            real_t v0z_2 = v[vi0_2 * 3 + 2];
+
+            const TinyObjPoint point1(v0x,v0y,v0z);
+            const TinyObjPoint point2(v0x_2,v0y_2,v0z_2);
+
+            TinyObjPoint a(point1.x - point2.x, point1.y - point2.y, point1.z - point2.z);
+            TinyObjPoint b(point1.x + point2.x, point1.y + point2.y, point1.z + point2.z);
+
+            n.x += (a.x * b.z);
+            n.y += (a.z * b.x);
+            n.z += (a.x * b.y);
+          }
+          real_t length_n = GetLength(n);
+          //Check if zero length normal
+          if(length_n <= 0) {
+            continue;
+          }
+          //Negative is to flip the normal to the correct direction
+          real_t inv_length = -1.0f / length_n;
+          n.x *= inv_length;
+          n.y *= inv_length;
+          n.z *= inv_length;
+
+          TinyObjPoint axis_w, axis_v, axis_u;
+          axis_w = n;
+          TinyObjPoint a;
+          if(abs(axis_w.x) > 0.9999999) {
+            a = TinyObjPoint(0,1,0);
+          } else {
+            a = TinyObjPoint(1,0,0);
+          }
+          axis_v = Normalize(cross(axis_w, a));
+          axis_u = cross(axis_w, axis_v);
           using Point = std::array<real_t, 2>;
 
           // first polyline define the main polygon.
           // following polylines define holes(not used in tinyobj).
           std::vector<std::vector<Point> > polygon;
 
           std::vector<Point> polyline;
 
+          //TMW change: Find best normal and project v0x and v0y to those coordinates, instead of
+          //picking a plane aligned with an axis (which can flip polygons).
+
           // Fill polygon data(facevarying vertices).
           for (size_t k = 0; k < npolys; k++) {
             i0 = face.vertex_indices[k];
             size_t vi0 = size_t(i0.v_idx);
 
             assert(((3 * vi0 + 2) < v.size()));
 
-            real_t v0x = v[vi0 * 3 + axes[0]];
-            real_t v0y = v[vi0 * 3 + axes[1]];
+            real_t v0x = v[vi0 * 3 + 0];
+            real_t v0y = v[vi0 * 3 + 1];
+            real_t v0z = v[vi0 * 3 + 2];
 
-            polyline.push_back({v0x, v0y});
+            TinyObjPoint polypoint(v0x,v0y,v0z);
+            TinyObjPoint loc = WorldToLocal(polypoint, axis_u, axis_v, axis_w);
+
+            polyline.push_back({loc.x, loc.y});
           }
 
           polygon.push_back(polyline);
           std::vector<uint32_t> indices = mapbox::earcut<uint32_t>(polygon);
           // => result = 3 * faces, clockwise
 
           assert(indices.size() % 3 == 0);
 
           // Reconstruct vertex_index_t
           for (size_t k = 0; k < indices.size() / 3; k++) {
             {
               index_t idx0, idx1, idx2;
               idx0.vertex_index = face.vertex_indices[indices[3 * k + 0]].v_idx;
               idx0.normal_index =
-                  face.vertex_indices[indices[3 * k + 0]].vn_idx;
+                face.vertex_indices[indices[3 * k + 0]].vn_idx;
               idx0.texcoord_index =
-                  face.vertex_indices[indices[3 * k + 0]].vt_idx;
+                face.vertex_indices[indices[3 * k + 0]].vt_idx;
               idx1.vertex_index = face.vertex_indices[indices[3 * k + 1]].v_idx;
               idx1.normal_index =
-                  face.vertex_indices[indices[3 * k + 1]].vn_idx;
+                face.vertex_indices[indices[3 * k + 1]].vn_idx;
               idx1.texcoord_index =
-                  face.vertex_indices[indices[3 * k + 1]].vt_idx;
+                face.vertex_indices[indices[3 * k + 1]].vt_idx;
               idx2.vertex_index = face.vertex_indices[indices[3 * k + 2]].v_idx;
               idx2.normal_index =
-                  face.vertex_indices[indices[3 * k + 2]].vn_idx;
+                face.vertex_indices[indices[3 * k + 2]].vn_idx;
               idx2.texcoord_index =
-                  face.vertex_indices[indices[3 * k + 2]].vt_idx;
+                face.vertex_indices[indices[3 * k + 2]].vt_idx;
 
               shape->mesh.indices.push_back(idx0);
               shape->mesh.indices.push_back(idx1);
               shape->mesh.indices.push_back(idx2);
 
               shape->mesh.num_face_vertices.push_back(3);
               shape->mesh.material_ids.push_back(material_id);
               shape->mesh.smoothing_group_ids.push_back(
                   face.smoothing_group_id);
             }
           }
 
 #else  // Built-in ear clipping triangulation
+          vertex_index_t i0 = face.vertex_indices[0];
+          vertex_index_t i1(-1);
+          vertex_index_t i2 = face.vertex_indices[1];
 
+          // find the two axes to work in
+          size_t axes[2] = {1, 2};
+          for (size_t k = 0; k < npolys; ++k) {
+            i0 = face.vertex_indices[(k + 0) % npolys];
+            i1 = face.vertex_indices[(k + 1) % npolys];
+            i2 = face.vertex_indices[(k + 2) % npolys];
+            size_t vi0 = size_t(i0.v_idx);
+            size_t vi1 = size_t(i1.v_idx);
+            size_t vi2 = size_t(i2.v_idx);
+
+            if (((3 * vi0 + 2) >= v.size()) || ((3 * vi1 + 2) >= v.size()) ||
+                ((3 * vi2 + 2) >= v.size())) {
+              // Invalid triangle.
+              // FIXME(syoyo): Is it ok to simply skip this invalid triangle?
+              continue;
+            }
+            real_t v0x = v[vi0 * 3 + 0];
+            real_t v0y = v[vi0 * 3 + 1];
+            real_t v0z = v[vi0 * 3 + 2];
+            real_t v1x = v[vi1 * 3 + 0];
+            real_t v1y = v[vi1 * 3 + 1];
+            real_t v1z = v[vi1 * 3 + 2];
+            real_t v2x = v[vi2 * 3 + 0];
+            real_t v2y = v[vi2 * 3 + 1];
+            real_t v2z = v[vi2 * 3 + 2];
+            real_t e0x = v1x - v0x;
+            real_t e0y = v1y - v0y;
+            real_t e0z = v1z - v0z;
+            real_t e1x = v2x - v1x;
+            real_t e1y = v2y - v1y;
+            real_t e1z = v2z - v1z;
+            real_t cx = std::fabs(e0y * e1z - e0z * e1y);
+            real_t cy = std::fabs(e0z * e1x - e0x * e1z);
+            real_t cz = std::fabs(e0x * e1y - e0y * e1x);
+            const real_t epsilon = std::numeric_limits<real_t>::epsilon();
+            // std::cout << "cx " << cx << ", cy " << cy << ", cz " << cz <<
+            // "\n";
+            if (cx > epsilon || cy > epsilon || cz > epsilon) {
+              // std::cout << "corner\n";
+              // found a corner
+              if (cx > cy && cx > cz) {
+                // std::cout << "pattern0\n";
+              } else {
+                // std::cout << "axes[0] = 0\n";
+                axes[0] = 0;
+                if (cz > cx && cz > cy) {
+                  // std::cout << "axes[1] = 1\n";
+                  axes[1] = 1;
+                }
+              }
+              break;
+            }
+          }
 
           face_t remainingFace = face;  // copy
           size_t guess_vert = 0;
           vertex_index_t ind[3];
           real_t vx[3];
           real_t vy[3];
 
@@ -2199,23 +2291,17 @@
       token += 7;
       ParseTextureNameAndOption(&(material.specular_highlight_texname),
                                 &(material.specular_highlight_texopt), token);
       continue;
     }
 
     // bump texture
-    if ((0 == strncmp(token, "map_bump", 8)) && IS_SPACE(token[8])) {
-      token += 9;
-      ParseTextureNameAndOption(&(material.bump_texname),
-                                &(material.bump_texopt), token);
-      continue;
-    }
-
-    // bump texture
-    if ((0 == strncmp(token, "map_Bump", 8)) && IS_SPACE(token[8])) {
+    if (((0 == strncmp(token, "map_bump", 8)) ||
+         (0 == strncmp(token, "map_Bump", 8))) &&
+        IS_SPACE(token[8])) {
       token += 9;
       ParseTextureNameAndOption(&(material.bump_texname),
                                 &(material.bump_texopt), token);
       continue;
     }
 
     // bump texture
@@ -2232,14 +2318,24 @@
       material.alpha_texname = token;
       ParseTextureNameAndOption(&(material.alpha_texname),
                                 &(material.alpha_texopt), token);
       continue;
     }
 
     // displacement texture
+    if (((0 == strncmp(token, "map_disp", 8)) ||
+         (0 == strncmp(token, "map_Disp", 8))) &&
+        IS_SPACE(token[8])) {
+      token += 9;
+      ParseTextureNameAndOption(&(material.displacement_texname),
+                                &(material.displacement_texopt), token);
+      continue;
+    }
+
+    // displacement texture
     if ((0 == strncmp(token, "disp", 4)) && IS_SPACE(token[4])) {
       token += 5;
       ParseTextureNameAndOption(&(material.displacement_texname),
                                 &(material.displacement_texopt), token);
       continue;
     }
 
@@ -2442,14 +2538,15 @@
   std::vector<real_t> vc;
   std::vector<skin_weight_t> vw;
   std::vector<tag_t> tags;
   PrimGroup prim_group;
   std::string name;
 
   // material
+  std::set<std::string> material_filenames;
   std::map<std::string, int> material_map;
   int material = -1;
 
   // smoothing group id
   unsigned int current_smoothing_id =
       0;  // Initial value. 0 means no smoothing.
 
@@ -2732,28 +2829,34 @@
                << line_num << ".)\n";
 
             (*warn) += ss.str();
           }
         } else {
           bool found = false;
           for (size_t s = 0; s < filenames.size(); s++) {
+            if (material_filenames.count(filenames[s]) > 0) {
+              found = true;
+              continue;
+            }
+
             std::string warn_mtl;
             std::string err_mtl;
             bool ok = (*readMatFn)(filenames[s].c_str(), materials,
                                    &material_map, &warn_mtl, &err_mtl);
             if (warn && (!warn_mtl.empty())) {
               (*warn) += warn_mtl;
             }
 
             if (err && (!err_mtl.empty())) {
               (*err) += err_mtl;
             }
 
             if (ok) {
               found = true;
+              material_filenames.insert(filenames[s]);
               break;
             }
           }
 
           if (!found) {
             if (warn) {
               (*warn) +=
@@ -2990,14 +3093,15 @@
                          void *user_data /*= NULL*/,
                          MaterialReader *readMatFn /*= NULL*/,
                          std::string *warn, /* = NULL*/
                          std::string *err /*= NULL*/) {
   std::stringstream errss;
 
   // material
+  std::set<std::string> material_filenames;
   std::map<std::string, int> material_map;
   int material_id = -1;  // -1 = invalid
 
   std::vector<index_t> indices;
   std::vector<material_t> materials;
   std::vector<std::string> names;
   names.reserve(2);
@@ -3135,14 +3239,19 @@
             (*warn) +=
                 "Looks like empty filename for mtllib. Use default "
                 "material. \n";
           }
         } else {
           bool found = false;
           for (size_t s = 0; s < filenames.size(); s++) {
+            if (material_filenames.count(filenames[s]) > 0) {
+              found = true;
+              continue;
+            }
+
             std::string warn_mtl;
             std::string err_mtl;
             bool ok = (*readMatFn)(filenames[s].c_str(), &materials,
                                    &material_map, &warn_mtl, &err_mtl);
 
             if (warn && (!warn_mtl.empty())) {
               (*warn) += warn_mtl;  // This should be warn message.
@@ -3150,14 +3259,15 @@
 
             if (err && (!err_mtl.empty())) {
               (*err) += err_mtl;
             }
 
             if (ok) {
               found = true;
+              material_filenames.insert(filenames[s]);
               break;
             }
           }
 
           if (!found) {
             if (warn) {
               (*warn) +=
```

### Comparing `tinyusdz-0.8.0rc0/src/external/tinyexr.h` & `tinyusdz-0.8.0rc1/src/external/tinyexr.h`

 * *Files 2% similar despite different names*

```diff
@@ -100,20 +100,25 @@
 #if (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || TINYEXR_X86_OR_X64_CPU
 #define TINYEXR_LITTLE_ENDIAN 1
 #else
 #define TINYEXR_LITTLE_ENDIAN 0
 #endif
 
 // Use miniz or not to decode ZIP format pixel. Linking with zlib
-// required if this flas is 0.
+// required if this flag is 0 and TINYEXR_USE_STB_ZLIB is 0.
 #ifndef TINYEXR_USE_MINIZ
 #define TINYEXR_USE_MINIZ (1)
 #endif
 
-// Disable PIZ comporession when applying cpplint.
+// Use the ZIP implementation of stb_image.h and stb_image_write.h.
+#ifndef TINYEXR_USE_STB_ZLIB
+#define TINYEXR_USE_STB_ZLIB (0)
+#endif
+
+// Disable PIZ compression when applying cpplint.
 #ifndef TINYEXR_USE_PIZ
 #define TINYEXR_USE_PIZ (1)
 #endif
 
 #ifndef TINYEXR_USE_ZFP
 #define TINYEXR_USE_ZFP (0)  // TinyEXR extension.
 // http://computation.llnl.gov/projects/floating-point-compression
@@ -140,16 +145,17 @@
 #define TINYEXR_ERROR_INVALID_FILE (-5)
 #define TINYEXR_ERROR_INVALID_PARAMETER (-6)
 #define TINYEXR_ERROR_CANT_OPEN_FILE (-7)
 #define TINYEXR_ERROR_UNSUPPORTED_FORMAT (-8)
 #define TINYEXR_ERROR_INVALID_HEADER (-9)
 #define TINYEXR_ERROR_UNSUPPORTED_FEATURE (-10)
 #define TINYEXR_ERROR_CANT_WRITE_FILE (-11)
-#define TINYEXR_ERROR_SERIALZATION_FAILED (-12)
+#define TINYEXR_ERROR_SERIALIZATION_FAILED (-12)
 #define TINYEXR_ERROR_LAYER_NOT_FOUND (-13)
+#define TINYEXR_ERROR_DATA_TOO_LARGE (-14)
 
 // @note { OpenEXR file format: http://www.openexr.com/openexrfilelayout.pdf }
 
 // pixel type: possible values are: UINT = 0 HALF = 1 FLOAT = 2
 #define TINYEXR_PIXELTYPE_UINT (0)
 #define TINYEXR_PIXELTYPE_HALF (1)
 #define TINYEXR_PIXELTYPE_FLOAT (2)
@@ -175,19 +181,19 @@
 #define TINYEXR_TILE_ROUND_DOWN (0)
 #define TINYEXR_TILE_ROUND_UP (1)
 
 typedef struct TEXRVersion {
   int version;    // this must be 2
   // tile format image;
   // not zero for only a single-part "normal" tiled file (according to spec.)
-  int tiled;      
+  int tiled;
   int long_name;  // long name attribute
   // deep image(EXR 2.0);
   // for a multi-part file, indicates that at least one part is of type deep* (according to spec.)
-  int non_image;  
+  int non_image;
   int multipart;  // multi-part(EXR 2.0)
 } EXRVersion;
 
 typedef struct TEXRAttribute {
   char name[256];  // name and type are up to 255 chars long.
   char type[256];
   unsigned char *value;  // uint8_t*
@@ -342,30 +348,55 @@
 // code). Free it using FreeEXRErrorMessage after using this value.
 //
 // @return TINYEXR_SUCCEES upon success.
 //
 extern int EXRLayers(const char *filename, const char **layer_names[],
                      int *num_layers, const char **err);
 
-// @deprecated { to be removed. }
+// @deprecated
 // Simple wrapper API for ParseEXRHeaderFromFile.
 // checking given file is a EXR file(by just look up header)
 // @return TINYEXR_SUCCEES for EXR image, TINYEXR_ERROR_INVALID_HEADER for
 // others
 extern int IsEXR(const char *filename);
 
-// @deprecated { to be removed. }
-// Saves single-frame OpenEXR image. Assume EXR image contains RGB(A) channels.
+// Simple wrapper API for ParseEXRHeaderFromMemory.
+// Check if given data is a EXR image(by just looking up a header section)
+// @return TINYEXR_SUCCEES for EXR image, TINYEXR_ERROR_INVALID_HEADER for
+// others
+extern int IsEXRFromMemory(const unsigned char *memory, size_t size);
+
+// @deprecated
+// Saves single-frame OpenEXR image to a buffer. Assume EXR image contains RGB(A) channels.
+// components must be 1(Grayscale), 3(RGB) or 4(RGBA).
+// Input image format is: `float x width x height`, or `float x RGB(A) x width x
+// hight`
+// Save image as fp16(HALF) format when `save_as_fp16` is positive non-zero
+// value.
+// Save image as fp32(FLOAT) format when `save_as_fp16` is 0.
+// Use ZIP compression by default.
+// `buffer` is the pointer to write EXR data.
+// Memory for `buffer` is allocated internally in SaveEXRToMemory.
+// Returns the data size of EXR file when the value is positive(up to 2GB EXR data).
+// Returns negative value and may set error string in `err` when there's an
+// error
+extern int SaveEXRToMemory(const float *data, const int width, const int height,
+                   const int components, const int save_as_fp16,
+                   const unsigned char **buffer, const char **err);
+
+// @deprecated { Not recommended, but handy to use. }
+// Saves single-frame OpenEXR image to a buffer. Assume EXR image contains RGB(A) channels.
 // components must be 1(Grayscale), 3(RGB) or 4(RGBA).
 // Input image format is: `float x width x height`, or `float x RGB(A) x width x
 // hight`
 // Save image as fp16(HALF) format when `save_as_fp16` is positive non-zero
 // value.
 // Save image as fp32(FLOAT) format when `save_as_fp16` is 0.
 // Use ZIP compression by default.
+// Returns TINYEXR_SUCCEES(0) when success.
 // Returns negative value and may set error string in `err` when there's an
 // error
 extern int SaveEXR(const float *data, const int width, const int height,
                    const int components, const int save_as_fp16,
                    const char *filename, const char **err);
 
 // Returns the number of resolution levels of the image (including the base)
@@ -572,26 +603,33 @@
 
 #ifndef WIN32_LEAN_AND_MEAN
 #define WIN32_LEAN_AND_MEAN
 #endif
 #ifndef NOMINMAX
 #define NOMINMAX
 #endif
-#include <windows.h>  // for UTF-8
+#include <windows.h>  // for UTF-8 and memory-mapping
+#define TINYEXR_USE_WIN32_MMAP (1)
 
+#elif defined(__linux__) || defined(__unix__)
+#include <fcntl.h>     // for open()
+#include <sys/mman.h>  // for memory-mapping
+#include <sys/stat.h>  // for stat
+#include <unistd.h>    // for close()
+#define TINYEXR_USE_POSIX_MMAP (1)
 #endif
 
 #include <algorithm>
 #include <cassert>
 #include <cstdio>
 #include <cstdlib>
 #include <cstring>
 #include <sstream>
 
-// #include <iostream> // debug
+//#include <iostream> // debug
 
 #include <limits>
 #include <string>
 #include <vector>
 #include <set>
 
 // https://stackoverflow.com/questions/5047971/how-do-i-check-for-c11-support
@@ -601,28 +639,41 @@
 #include <cstdint>
 
 #if TINYEXR_USE_THREAD
 #include <atomic>
 #include <thread>
 #endif
 
+#else  // __cplusplus > 199711L
+#define TINYEXR_HAS_CXX11 (0)
 #endif  // __cplusplus > 199711L
 
 #if TINYEXR_USE_OPENMP
 #include <omp.h>
 #endif
 
 #if TINYEXR_USE_MINIZ
-#include <miniz.h>
+// TinyUSDZ mod
+#include "external/miniz.h"
 #else
 //  Issue #46. Please include your own zlib-compatible API header before
 //  including `tinyexr.h`
 //#include "zlib.h"
 #endif
 
+#if TINYEXR_USE_STB_ZLIB
+// Since we don't know where a project has stb_image.h and stb_image_write.h
+// and whether they are in the include path, we don't include them here, and
+// instead declare the two relevant functions manually.
+// from stb_image.h:
+extern "C" int stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);
+// from stb_image_write.h:
+extern "C" unsigned char *stbi_zlib_compress(unsigned char *data, int data_len, int *out_len, int quality);
+#endif
+
 #if TINYEXR_USE_ZFP
 
 #ifdef __clang__
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Weverything"
 #endif
 
@@ -1137,14 +1188,15 @@
   const char *p = reinterpret_cast<const char *>(&data.at(0));
 
   for (;;) {
     if ((*p) == 0) {
       break;
     }
     ChannelInfo info;
+    info.requested_pixel_type = 0;
 
     tinyexr_int64 data_len = static_cast<tinyexr_int64>(data.size()) -
                              (p - reinterpret_cast<const char *>(data.data()));
     if (data_len < 0) {
       return false;
     }
 
@@ -1217,15 +1269,15 @@
     memcpy(p, &y_sampling, sizeof(int));
     p += sizeof(int);
   }
 
   (*p) = '\0';
 }
 
-static void CompressZip(unsigned char *dst,
+static bool CompressZip(unsigned char *dst,
                         tinyexr::tinyexr_uint64 &compressedSize,
                         const unsigned char *src, unsigned long src_size) {
   std::vector<unsigned char> tmpBuf(src_size);
 
   //
   // Apply EXR-specific? postprocess. Grabbed from OpenEXR's
   // ImfZipCompressor.cpp
@@ -1277,33 +1329,48 @@
   // Compress the data using miniz
   //
 
   mz_ulong outSize = mz_compressBound(src_size);
   int ret = mz_compress(
       dst, &outSize, static_cast<const unsigned char *>(&tmpBuf.at(0)),
       src_size);
-  assert(ret == MZ_OK);
-  (void)ret;
+  if (ret != MZ_OK) {
+    return false;
+  }
+
+  compressedSize = outSize;
+#elif TINYEXR_USE_STB_ZLIB
+  int outSize;
+  unsigned char* ret = stbi_zlib_compress(const_cast<unsigned char*>(&tmpBuf.at(0)), src_size, &outSize, 8);
+  if (!ret) {
+    return false;
+  }
+  memcpy(dst, ret, outSize);
+  free(ret);
 
   compressedSize = outSize;
 #else
   uLong outSize = compressBound(static_cast<uLong>(src_size));
   int ret = compress(dst, &outSize, static_cast<const Bytef *>(&tmpBuf.at(0)),
                      src_size);
-  assert(ret == Z_OK);
+  if (ret != Z_OK) {
+    return false;
+  }
 
   compressedSize = outSize;
 #endif
 
   // Use uncompressed data when compressed data is larger than uncompressed.
   // (Issue 40)
   if (compressedSize >= src_size) {
     compressedSize = src_size;
     memcpy(dst, src, src_size);
   }
+
+  return true;
 }
 
 static bool DecompressZip(unsigned char *dst,
                           unsigned long *uncompressed_size /* inout */,
                           const unsigned char *src, unsigned long src_size) {
   if ((*uncompressed_size) == src_size) {
     // Data is not compressed(Issue 40).
@@ -1314,14 +1381,20 @@
 
 #if TINYEXR_USE_MINIZ
   int ret =
       mz_uncompress(&tmpBuf.at(0), uncompressed_size, src, src_size);
   if (MZ_OK != ret) {
     return false;
   }
+#elif TINYEXR_USE_STB_ZLIB
+  int ret = stbi_zlib_decode_buffer(reinterpret_cast<char*>(&tmpBuf.at(0)),
+      *uncompressed_size, reinterpret_cast<const char*>(src), src_size);
+  if (ret < 0) {
+    return false;
+  }
 #else
   int ret = uncompress(&tmpBuf.at(0), uncompressed_size, src, src_size);
   if (Z_OK != ret) {
     return false;
   }
 #endif
 
@@ -1441,15 +1514,15 @@
   }
 
   return static_cast<int>(outWrite - out);
 }
 
 //
 // Uncompress an array of bytes compressed with rleCompress().
-// Returns the length of the oncompressed data, or 0 if the
+// Returns the length of the uncompressed data, or 0 if the
 // length of the uncompressed data would be more than maxLength.
 //
 
 static int rleUncompress(int inLength, int maxLength, const signed char in[],
                          char out[]) {
   char *outStart = out;
 
@@ -1464,15 +1537,15 @@
       memcpy(out, in, count);
       out += count;
       in += count;
     } else {
       int count = *in++;
       inLength -= 2;
 
-      if (0 > (maxLength -= count + 1)) return 0;
+      if ((0 > (maxLength -= count + 1)) || (inLength < 0)) return 0;
 
       memset(out, *reinterpret_cast<const char *>(in), count + 1);
       out += count + 1;
 
       in++;
     }
   }
@@ -2444,15 +2517,15 @@
 
       pl->lit++;
 
       if (pl->p) {
         unsigned int *p = pl->p;
         pl->p = new unsigned int[pl->lit];
 
-        for (int i = 0; i < pl->lit - 1; ++i) pl->p[i] = p[i];
+        for (unsigned int i = 0; i < pl->lit - 1u; ++i) pl->p[i] = p[i];
 
         delete[] p;
       } else {
         pl->p = new unsigned int[1];
       }
 
       pl->p[pl->lit - 1] = im;
@@ -2699,15 +2772,15 @@
         }
         // invalidCode(); // wrong code
 
         //
         // Search long code
         //
 
-        int j;
+        unsigned int j;
 
         for (j = 0; j < pl.lit; j++) {
           int l = hufLength(hcode[pl.p[j]]);
 
           while (lc < l && in < ie)  // get more bits
             getChar(c, lc, in);
 
@@ -3090,41 +3163,65 @@
   // @todo { PIZ compression on BigEndian architecture. }
   assert(0);
   return false;
 #endif
 
   memset(bitmap.data(), 0, BITMAP_SIZE);
 
+  if (inLen < 4) {
+    return false;
+  }
+
+  size_t readLen = 0;
+
   const unsigned char *ptr = inPtr;
   // minNonZero = *(reinterpret_cast<const unsigned short *>(ptr));
   tinyexr::cpy2(&minNonZero, reinterpret_cast<const unsigned short *>(ptr));
   // maxNonZero = *(reinterpret_cast<const unsigned short *>(ptr + 2));
   tinyexr::cpy2(&maxNonZero, reinterpret_cast<const unsigned short *>(ptr + 2));
   ptr += 4;
+  readLen += 4;
 
   if (maxNonZero >= BITMAP_SIZE) {
     return false;
   }
 
+  //printf("maxNonZero = %d\n", maxNonZero);
+  //printf("minNonZero = %d\n", minNonZero);
+  //printf("len = %d\n", (maxNonZero - minNonZero + 1));
+  //printf("BITMAPSIZE - min = %d\n", (BITMAP_SIZE - minNonZero));
+
   if (minNonZero <= maxNonZero) {
+    if (((maxNonZero - minNonZero + 1) + readLen) > inLen) {
+      // Input too short
+      return false;
+    }
+
     memcpy(reinterpret_cast<char *>(&bitmap[0] + minNonZero), ptr,
            maxNonZero - minNonZero + 1);
     ptr += maxNonZero - minNonZero + 1;
+    readLen += maxNonZero - minNonZero + 1;
+  } else {
+    return false;
   }
 
   std::vector<unsigned short> lut(USHORT_RANGE);
   memset(lut.data(), 0, sizeof(unsigned short) * USHORT_RANGE);
   unsigned short maxValue = reverseLutFromBitmap(bitmap.data(), lut.data());
 
   //
   // Huffman decoding
   //
 
   int length;
 
+  if ((readLen + 4) > inLen) {
+    return false;
+  }
+
   // length = *(reinterpret_cast<const int *>(ptr));
   tinyexr::cpy4(&length, reinterpret_cast<const int *>(ptr));
   ptr += sizeof(int);
 
   if (size_t((ptr - inPtr) + length) > inLen) {
     return false;
   }
@@ -3552,16 +3649,16 @@
             *image = val;
           }
         }
       } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {
         assert(requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT);
         for (size_t v = 0; v < static_cast<size_t>(num_lines); v++) {
           const float *line_ptr = reinterpret_cast<float *>(&outBuf.at(
-              v * pixel_data_size * static_cast<size_t>(x_stride) +
-              channel_offset_list[c] * static_cast<size_t>(x_stride)));
+              v * pixel_data_size * static_cast<size_t>(width) +
+              channel_offset_list[c] * static_cast<size_t>(width)));
           for (size_t u = 0; u < static_cast<size_t>(width); u++) {
             float val;
             // val = line_ptr[u];
             tinyexr::cpy4(&val, line_ptr + u);
 
             tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));
 
@@ -3580,15 +3677,15 @@
           }
         }
       } else {
         assert(0);
       }
     }
 #else
-    assert(0 && "PIZ is enabled in this build");
+    assert(0 && "PIZ is disabled in this build");
     return false;
 #endif
 
   } else if (compression_type == TINYEXR_COMPRESSIONTYPE_ZIPS ||
              compression_type == TINYEXR_COMPRESSIONTYPE_ZIP) {
     // Allocate original data size.
     std::vector<unsigned char> outBuf(static_cast<size_t>(width) *
@@ -3973,15 +4070,15 @@
               // Insufficient data size
               return false;
             }
 
             for (int u = 0; u < width; u++) {
               tinyexr::FP16 hf;
 
-              // address may not be aliged. use byte-wise copy for safety.#76
+              // address may not be aligned. use byte-wise copy for safety.#76
               // hf.u = line_ptr[u];
               tinyexr::cpy2(&(hf.u), line_ptr + u);
 
               tinyexr::swap2(reinterpret_cast<unsigned short *>(&hf.u));
 
               tinyexr::FP32 f32 = half_to_float(hf);
 
@@ -4028,20 +4125,21 @@
           if (line_order == 0) {
             outLine += (size_t(y) + v) * size_t(x_stride);
           } else {
             outLine +=
                 (size_t(height) - 1 - (size_t(y) + v)) * size_t(x_stride);
           }
 
+          if (reinterpret_cast<const unsigned char *>(line_ptr + width) >
+              (data_ptr + data_len)) {
+            // Corrupted data
+            return false;
+          }
+
           for (int u = 0; u < width; u++) {
-            if (reinterpret_cast<const unsigned char *>(line_ptr + u) >=
-                (data_ptr + data_len)) {
-              // Corrupsed data?
-              return false;
-            }
 
             unsigned int val;
             tinyexr::cpy4(&val, line_ptr + u);
 
             tinyexr::swap4(reinterpret_cast<unsigned int *>(&val));
 
             outLine[u] = val;
@@ -4114,23 +4212,30 @@
       // ???
       return false;
     }
   }
   return true;
 }
 
+// TODO: Simply return nullptr when failed to allocate?
 static unsigned char **AllocateImage(int num_channels,
                                      const EXRChannelInfo *channels,
                                      const int *requested_pixel_types,
-                                     int data_width, int data_height) {
+                                     int data_width, int data_height, bool *success) {
   unsigned char **images =
       reinterpret_cast<unsigned char **>(static_cast<float **>(
           malloc(sizeof(float *) * static_cast<size_t>(num_channels))));
 
   for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {
+    images[c] = NULL;
+  }
+
+  bool valid = true;
+
+  for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {
     size_t data_len =
         static_cast<size_t>(data_width) * static_cast<size_t>(data_height);
     if (channels[c].pixel_type == TINYEXR_PIXELTYPE_HALF) {
       // pixel_data_size += sizeof(unsigned short);
       // channel_offset += sizeof(unsigned short);
       // Alloc internal image for half type.
       if (requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {
@@ -4150,15 +4255,34 @@
           static_cast<float *>(malloc(sizeof(float) * data_len)));
     } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT) {
       // pixel_data_size += sizeof(unsigned int);
       // channel_offset += sizeof(unsigned int);
       images[c] = reinterpret_cast<unsigned char *>(
           static_cast<unsigned int *>(malloc(sizeof(unsigned int) * data_len)));
     } else {
-      assert(0);
+      images[c] = NULL; // just in case.
+      valid = false;
+      break;
+    }
+  }
+
+  if (!valid) {
+    for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {
+      if (images[c]) {
+        free(images[c]);
+        images[c] = NULL;
+      }
+    }
+
+    if (success) {
+      (*success) = false;
+    }
+  } else {
+    if (success) {
+      (*success) = true;
     }
   }
 
   return images;
 }
 
 #ifdef _WIN32
@@ -4442,14 +4566,15 @@
         strncpy_s(attrib.type, attr_type.c_str(), 255);
 #else
         strncpy(attrib.name, attr_name.c_str(), 255);
         strncpy(attrib.type, attr_type.c_str(), 255);
 #endif
         attrib.name[255] = '\0';
         attrib.type[255] = '\0';
+        //std::cout << "i = " << info->attributes.size() << ", dsize = " << data.size() << "\n";
         attrib.size = static_cast<int>(data.size());
         attrib.value = static_cast<unsigned char *>(malloc(data.size()));
         memcpy(reinterpret_cast<char *>(attrib.value), &data.at(0),
                data.size());
         info->attributes.push_back(attrib);
       }
     }
@@ -4508,14 +4633,15 @@
       }
     }
 
     if (!(ss_err.str().empty())) {
       if (err) {
         (*err) += ss_err.str();
       }
+
       return TINYEXR_ERROR_INVALID_HEADER;
     }
   }
 
   info->header_len = static_cast<unsigned int>(orig_size - size);
 
   return TINYEXR_SUCCESS;
@@ -4632,15 +4758,15 @@
     if (exr_header->num_custom_attributes > TINYEXR_MAX_CUSTOM_ATTRIBUTES) {
       exr_header->num_custom_attributes = TINYEXR_MAX_CUSTOM_ATTRIBUTES;
     }
 
     exr_header->custom_attributes = static_cast<EXRAttribute *>(malloc(
         sizeof(EXRAttribute) * size_t(exr_header->num_custom_attributes)));
 
-    for (size_t i = 0; i < info.attributes.size(); i++) {
+    for (size_t i = 0; i < size_t(exr_header->num_custom_attributes); i++) {
       memcpy(exr_header->custom_attributes[i].name, info.attributes[i].name,
              256);
       memcpy(exr_header->custom_attributes[i].type, info.attributes[i].type,
              256);
       exr_header->custom_attributes[i].size = info.attributes[i].size;
       // Just copy pointer
       exr_header->custom_attributes[i].value = info.attributes[i].value;
@@ -4654,16 +4780,16 @@
 
   return true;
 }
 
 struct OffsetData {
   OffsetData() : num_x_levels(0), num_y_levels(0) {}
   std::vector<std::vector<std::vector <tinyexr::tinyexr_uint64> > > offsets;
-  int	num_x_levels;
-  int	num_y_levels;
+  int num_x_levels;
+  int num_y_levels;
 };
 
 static int LevelIndex(int lx, int ly, int tile_level_mode, int num_x_levels) {
   switch (tile_level_mode) {
   case TINYEXR_TILE_ONE_LEVEL:
     return 0;
 
@@ -4715,15 +4841,15 @@
     EF_FAILED_TO_DECODE = 4
   };
 #if TINYEXR_HAS_CXX11 && (TINYEXR_USE_THREAD > 0)
   std::atomic<unsigned> error_flag(EF_SUCCESS);
 #else
   unsigned error_flag(EF_SUCCESS);
 #endif
-  
+
   // Although the spec says : "...the data window is subdivided into an array of smaller rectangles...",
   // the IlmImf library allows the dimensions of the tile to be larger (or equal) than the dimensions of the data window.
 #if 0
   if ((exr_header->tile_size_x > exr_image->width || exr_header->tile_size_y > exr_image->height) &&
     exr_image->level_x == 0 && exr_image->level_y == 0) {
     if (err) {
       (*err) += "Failed to decode tile data.\n";
@@ -4752,28 +4878,34 @@
 #else
 #if TINYEXR_USE_OPENMP
 #pragma omp parallel for
 #endif
   for (int tile_idx = 0; tile_idx < num_tiles; tile_idx++) {
 #endif
     // Allocate memory for each tile.
+    bool alloc_success = false;
     exr_image->tiles[tile_idx].images = tinyexr::AllocateImage(
       num_channels, exr_header->channels,
       exr_header->requested_pixel_types, exr_header->tile_size_x,
-      exr_header->tile_size_y);
+      exr_header->tile_size_y, &alloc_success);
+
+    if (!alloc_success) {
+      error_flag |= EF_INVALID_DATA;
+      continue;
+    }
 
     int x_tile = tile_idx % num_x_tiles;
     int y_tile = tile_idx / num_x_tiles;
     // 16 byte: tile coordinates
     // 4 byte : data size
     // ~      : data(uncompressed or compressed)
     tinyexr::tinyexr_uint64 offset = offset_data.offsets[size_t(level_index)][size_t(y_tile)][size_t(x_tile)];
     if (offset + sizeof(int) * 5 > size) {
       // Insufficient data size.
-      error_flag |= EF_INSUFFICIENT_DATA; 
+      error_flag |= EF_INSUFFICIENT_DATA;
       continue;
     }
 
     size_t data_size =
       size_t(size - (offset + sizeof(int) * 5));
     const unsigned char* data_ptr =
       reinterpret_cast<const unsigned char*>(head + offset);
@@ -4831,15 +4963,15 @@
 
     exr_image->tiles[tile_idx].offset_x = tile_coordinates[0];
     exr_image->tiles[tile_idx].offset_y = tile_coordinates[1];
     exr_image->tiles[tile_idx].level_x = tile_coordinates[2];
     exr_image->tiles[tile_idx].level_y = tile_coordinates[3];
 
 #if TINYEXR_HAS_CXX11 && (TINYEXR_USE_THREAD > 0)
-  }  
+  }
         }));
     }  // num_thread loop
 
     for (auto& t : workers) {
       t.join();
     }
 
@@ -5033,17 +5165,29 @@
            << ", height = " << data_height << ", channels = " << num_channels
            << std::endl;
         (*err) += ss.str();
       }
       return TINYEXR_ERROR_INVALID_DATA;
     }
 
+    bool alloc_success = false;
     exr_image->images = tinyexr::AllocateImage(
         num_channels, exr_header->channels, exr_header->requested_pixel_types,
-        data_width, data_height);
+        data_width, data_height, &alloc_success);
+
+    if (!alloc_success) {
+      if (err) {
+        std::stringstream ss;
+        ss << "Failed to allocate memory for Images. Maybe EXR header is corrupted or Image data size is too large: width = " << data_width
+           << ", height = " << data_height << ", channels = " << num_channels
+           << std::endl;
+        (*err) += ss.str();
+      }
+      return TINYEXR_ERROR_INVALID_DATA;
+    }
 
 #if TINYEXR_HAS_CXX11 && (TINYEXR_USE_THREAD > 0)
     std::vector<std::thread> workers;
     std::atomic<int> y_count(0);
 
     int num_threads = std::max(1, int(std::thread::hardware_concurrency()));
     if (num_threads > int(num_blocks)) {
@@ -5153,15 +5297,23 @@
 #else
     }  // omp parallel
 #endif
   }
 
   if (invalid_data) {
     if (err) {
-      (*err) += "Invalid data found when decoding pixels.\n";
+      (*err) += "Invalid/Corrupted data found when decoding pixels.\n";
+    }
+
+    // free alloced image.
+    for (size_t c = 0; c < static_cast<size_t>(num_channels); c++) {
+      if (exr_image->images[c]) {
+        free(exr_image->images[c]);
+        exr_image->images[c] = NULL;
+      }
     }
     return TINYEXR_ERROR_INVALID_DATA;
   }
 
   // Overwrite `pixel_type` with `requested_pixel_type`.
   {
     for (int c = 0; c < exr_header->num_channels; c++) {
@@ -5777,19 +5929,22 @@
   std::string name;
 };
 
 static void ChannelsInLayer(const EXRHeader &exr_header,
                             const std::string &layer_name,
                             std::vector<LayerChannel> &channels) {
   channels.clear();
+  //std::cout << "layer_name = " << layer_name << "\n";
   for (int c = 0; c < exr_header.num_channels; c++) {
+    //std::cout << "chan[" << c << "] = " << exr_header.channels[c].name << "\n";
     std::string ch_name(exr_header.channels[c].name);
     if (layer_name.empty()) {
       const size_t pos = ch_name.find_last_of('.');
       if (pos != std::string::npos && pos < ch_name.size()) {
+        if (pos != 0) continue;
         ch_name = ch_name.substr(pos + 1);
       }
     } else {
       const size_t pos = ch_name.find(layer_name + '.');
       if (pos == std::string::npos) continue;
       if (pos == 0) {
         ch_name = ch_name.substr(layer_name.size() + 1);
@@ -5918,16 +6073,22 @@
   std::vector<std::string> layer_names;
   tinyexr::GetLayers(exr_header, layer_names);
 
   std::vector<tinyexr::LayerChannel> channels;
   tinyexr::ChannelsInLayer(
       exr_header, layername == NULL ? "" : std::string(layername), channels);
 
+
   if (channels.size() < 1) {
-    tinyexr::SetErrorMessage("Layer Not Found", err);
+    if (layername == NULL) {
+      tinyexr::SetErrorMessage("Layer Not Found. Seems EXR contains channels with layer(e.g. `diffuse.R`). if you are using LoadEXR(), please try LoadEXRWithLayer(). LoadEXR() cannot load EXR having channels with layer.", err);
+
+    } else {
+      tinyexr::SetErrorMessage("Layer Not Found", err);
+    }
     FreeEXRHeader(&exr_header);
     FreeEXRImage(&exr_image);
     return TINYEXR_ERROR_LAYER_NOT_FOUND;
   }
 
   size_t ch_count = channels.size() < 4 ? channels.size() : 4;
   for (size_t c = 0; c < ch_count; c++) {
@@ -5949,47 +6110,51 @@
     // Grayscale channel only.
 
     (*out_rgba) = reinterpret_cast<float *>(
         malloc(4 * sizeof(float) * static_cast<size_t>(exr_image.width) *
                static_cast<size_t>(exr_image.height)));
 
     if (exr_header.tiled) {
+      const size_t tile_size_x = static_cast<size_t>(exr_header.tile_size_x);
+      const size_t tile_size_y = static_cast<size_t>(exr_header.tile_size_y);
       for (int it = 0; it < exr_image.num_tiles; it++) {
-        for (int j = 0; j < exr_header.tile_size_y; j++) {
-          for (int i = 0; i < exr_header.tile_size_x; i++) {
-            const int ii = exr_image.tiles[it].offset_x *
-                               static_cast<int>(exr_header.tile_size_x) +
-                           i;
-            const int jj = exr_image.tiles[it].offset_y *
-                               static_cast<int>(exr_header.tile_size_y) +
-                           j;
-            const int idx = ii + jj * static_cast<int>(exr_image.width);
+        for (size_t j = 0; j < tile_size_y; j++) {
+          for (size_t i = 0; i < tile_size_x; i++) {
+            const size_t ii =
+              static_cast<size_t>(exr_image.tiles[it].offset_x) * tile_size_x +
+              i;
+            const size_t jj =
+              static_cast<size_t>(exr_image.tiles[it].offset_y) * tile_size_y +
+              j;
+            const size_t idx = ii + jj * static_cast<size_t>(exr_image.width);
 
             // out of region check.
-            if (ii >= exr_image.width) {
+            if (ii >= static_cast<size_t>(exr_image.width)) {
               continue;
             }
-            if (jj >= exr_image.height) {
+            if (jj >= static_cast<size_t>(exr_image.height)) {
               continue;
             }
-            const int srcIdx = i + j * exr_header.tile_size_x;
+            const size_t srcIdx = i + j * tile_size_x;
             unsigned char **src = exr_image.tiles[it].images;
             (*out_rgba)[4 * idx + 0] =
                 reinterpret_cast<float **>(src)[chIdx][srcIdx];
             (*out_rgba)[4 * idx + 1] =
                 reinterpret_cast<float **>(src)[chIdx][srcIdx];
             (*out_rgba)[4 * idx + 2] =
                 reinterpret_cast<float **>(src)[chIdx][srcIdx];
             (*out_rgba)[4 * idx + 3] =
                 reinterpret_cast<float **>(src)[chIdx][srcIdx];
           }
         }
       }
     } else {
-      for (int i = 0; i < exr_image.width * exr_image.height; i++) {
+      const size_t pixel_size = static_cast<size_t>(exr_image.width) *
+        static_cast<size_t>(exr_image.height);
+      for (size_t i = 0; i < pixel_size; i++) {
         const float val =
             reinterpret_cast<float **>(exr_image.images)[chIdx][i];
         (*out_rgba)[4 * i + 0] = val;
         (*out_rgba)[4 * i + 1] = val;
         (*out_rgba)[4 * i + 2] = val;
         (*out_rgba)[4 * i + 3] = val;
       }
@@ -6019,31 +6184,37 @@
       return TINYEXR_ERROR_INVALID_DATA;
     }
 
     (*out_rgba) = reinterpret_cast<float *>(
         malloc(4 * sizeof(float) * static_cast<size_t>(exr_image.width) *
                static_cast<size_t>(exr_image.height)));
     if (exr_header.tiled) {
+      const size_t tile_size_x = static_cast<size_t>(exr_header.tile_size_x);
+      const size_t tile_size_y = static_cast<size_t>(exr_header.tile_size_y);
       for (int it = 0; it < exr_image.num_tiles; it++) {
-        for (int j = 0; j < exr_header.tile_size_y; j++) {
-          for (int i = 0; i < exr_header.tile_size_x; i++) {
-            const int ii =
-                exr_image.tiles[it].offset_x * exr_header.tile_size_x + i;
-            const int jj =
-                exr_image.tiles[it].offset_y * exr_header.tile_size_y + j;
-            const int idx = ii + jj * exr_image.width;
+        for (size_t j = 0; j < tile_size_y; j++) {
+          for (size_t i = 0; i < tile_size_x; i++) {
+            const size_t ii =
+                static_cast<size_t>(exr_image.tiles[it].offset_x) *
+                    tile_size_x +
+                i;
+            const size_t jj =
+                static_cast<size_t>(exr_image.tiles[it].offset_y) *
+                    tile_size_y +
+                j;
+            const size_t idx = ii + jj * static_cast<size_t>(exr_image.width);
 
             // out of region check.
-            if (ii >= exr_image.width) {
+            if (ii >= static_cast<size_t>(exr_image.width)) {
               continue;
             }
-            if (jj >= exr_image.height) {
+            if (jj >= static_cast<size_t>(exr_image.height)) {
               continue;
             }
-            const int srcIdx = i + j * exr_header.tile_size_x;
+            const size_t srcIdx = i + j * tile_size_x;
             unsigned char **src = exr_image.tiles[it].images;
             (*out_rgba)[4 * idx + 0] =
                 reinterpret_cast<float **>(src)[idxR][srcIdx];
             (*out_rgba)[4 * idx + 1] =
                 reinterpret_cast<float **>(src)[idxG][srcIdx];
             (*out_rgba)[4 * idx + 2] =
                 reinterpret_cast<float **>(src)[idxB][srcIdx];
@@ -6053,15 +6224,17 @@
             } else {
               (*out_rgba)[4 * idx + 3] = 1.0;
             }
           }
         }
       }
     } else {
-      for (int i = 0; i < exr_image.width * exr_image.height; i++) {
+      const size_t pixel_size = static_cast<size_t>(exr_image.width) *
+        static_cast<size_t>(exr_image.height);
+      for (size_t i = 0; i < pixel_size; i++) {
         (*out_rgba)[4 * i + 0] =
             reinterpret_cast<float **>(exr_image.images)[idxR][i];
         (*out_rgba)[4 * i + 1] =
             reinterpret_cast<float **>(exr_image.images)[idxG][i];
         (*out_rgba)[4 * i + 2] =
             reinterpret_cast<float **>(exr_image.images)[idxB][i];
         if (idxA != -1) {
@@ -6090,14 +6263,25 @@
   if (ret != TINYEXR_SUCCESS) {
     return ret;
   }
 
   return TINYEXR_SUCCESS;
 }
 
+int IsEXRFromMemory(const unsigned char *memory, size_t size) {
+  EXRVersion exr_version;
+
+  int ret = ParseEXRVersionFromMemory(&exr_version, memory, size);
+  if (ret != TINYEXR_SUCCESS) {
+    return ret;
+  }
+
+  return TINYEXR_SUCCESS;
+}
+
 int ParseEXRHeaderFromMemory(EXRHeader *exr_header, const EXRVersion *version,
                              const unsigned char *memory, size_t size,
                              const char **err) {
   if (memory == NULL || exr_header == NULL) {
     tinyexr::SetErrorMessage(
         "Invalid argument. `memory` or `exr_header` argument is null in "
         "ParseEXRHeaderFromMemory()",
@@ -6131,14 +6315,20 @@
   }
 
   {
     std::string warn;
     std::string err_str;
 
     if (!ConvertHeader(exr_header, info, &warn, &err_str)) {
+      // release mem
+      for (size_t i = 0; i < info.attributes.size(); i++) {
+        if (info.attributes[i].value) {
+          free(info.attributes[i].value);
+        }
+      }
       if (err && !err_str.empty()) {
         tinyexr::SetErrorMessage(err_str, err);
       }
       ret = TINYEXR_ERROR_INVALID_HEADER;
     }
   }
 
@@ -6210,45 +6400,53 @@
     // Grayscale channel only.
 
     (*out_rgba) = reinterpret_cast<float *>(
         malloc(4 * sizeof(float) * static_cast<size_t>(exr_image.width) *
                static_cast<size_t>(exr_image.height)));
 
     if (exr_header.tiled) {
+      const size_t tile_size_x = static_cast<size_t>(exr_header.tile_size_x);
+      const size_t tile_size_y = static_cast<size_t>(exr_header.tile_size_y);
       for (int it = 0; it < exr_image.num_tiles; it++) {
-        for (int j = 0; j < exr_header.tile_size_y; j++) {
-          for (int i = 0; i < exr_header.tile_size_x; i++) {
-            const int ii =
-                exr_image.tiles[it].offset_x * exr_header.tile_size_x + i;
-            const int jj =
-                exr_image.tiles[it].offset_y * exr_header.tile_size_y + j;
-            const int idx = ii + jj * exr_image.width;
+        for (size_t j = 0; j < tile_size_y; j++) {
+          for (size_t i = 0; i < tile_size_x; i++) {
+            const size_t ii =
+                static_cast<size_t>(exr_image.tiles[it].offset_x) *
+                    tile_size_x +
+                i;
+            const size_t jj =
+                static_cast<size_t>(exr_image.tiles[it].offset_y) *
+                    tile_size_y +
+                j;
+            const size_t idx = ii + jj * static_cast<size_t>(exr_image.width);
 
             // out of region check.
-            if (ii >= exr_image.width) {
+            if (ii >= static_cast<size_t>(exr_image.width)) {
               continue;
             }
-            if (jj >= exr_image.height) {
+            if (jj >= static_cast<size_t>(exr_image.height)) {
               continue;
             }
-            const int srcIdx = i + j * exr_header.tile_size_x;
+            const size_t srcIdx = i + j * tile_size_x;
             unsigned char **src = exr_image.tiles[it].images;
             (*out_rgba)[4 * idx + 0] =
                 reinterpret_cast<float **>(src)[0][srcIdx];
             (*out_rgba)[4 * idx + 1] =
                 reinterpret_cast<float **>(src)[0][srcIdx];
             (*out_rgba)[4 * idx + 2] =
                 reinterpret_cast<float **>(src)[0][srcIdx];
             (*out_rgba)[4 * idx + 3] =
                 reinterpret_cast<float **>(src)[0][srcIdx];
           }
         }
       }
     } else {
-      for (int i = 0; i < exr_image.width * exr_image.height; i++) {
+      const size_t pixel_size = static_cast<size_t>(exr_image.width) *
+        static_cast<size_t>(exr_image.height);
+      for (size_t i = 0; i < pixel_size; i++) {
         const float val = reinterpret_cast<float **>(exr_image.images)[0][i];
         (*out_rgba)[4 * i + 0] = val;
         (*out_rgba)[4 * i + 1] = val;
         (*out_rgba)[4 * i + 2] = val;
         (*out_rgba)[4 * i + 3] = val;
       }
     }
@@ -6276,31 +6474,37 @@
     }
 
     (*out_rgba) = reinterpret_cast<float *>(
         malloc(4 * sizeof(float) * static_cast<size_t>(exr_image.width) *
                static_cast<size_t>(exr_image.height)));
 
     if (exr_header.tiled) {
+      const size_t tile_size_x = static_cast<size_t>(exr_header.tile_size_x);
+      const size_t tile_size_y = static_cast<size_t>(exr_header.tile_size_y);
       for (int it = 0; it < exr_image.num_tiles; it++) {
-        for (int j = 0; j < exr_header.tile_size_y; j++)
-          for (int i = 0; i < exr_header.tile_size_x; i++) {
-            const int ii =
-                exr_image.tiles[it].offset_x * exr_header.tile_size_x + i;
-            const int jj =
-                exr_image.tiles[it].offset_y * exr_header.tile_size_y + j;
-            const int idx = ii + jj * exr_image.width;
+        for (size_t j = 0; j < tile_size_y; j++)
+          for (size_t i = 0; i < tile_size_x; i++) {
+            const size_t ii =
+                static_cast<size_t>(exr_image.tiles[it].offset_x) *
+                    tile_size_x +
+                i;
+            const size_t jj =
+                static_cast<size_t>(exr_image.tiles[it].offset_y) *
+                    tile_size_y +
+                j;
+            const size_t idx = ii + jj * static_cast<size_t>(exr_image.width);
 
             // out of region check.
-            if (ii >= exr_image.width) {
+            if (ii >= static_cast<size_t>(exr_image.width)) {
               continue;
             }
-            if (jj >= exr_image.height) {
+            if (jj >= static_cast<size_t>(exr_image.height)) {
               continue;
             }
-            const int srcIdx = i + j * exr_header.tile_size_x;
+            const size_t srcIdx = i + j * tile_size_x;
             unsigned char **src = exr_image.tiles[it].images;
             (*out_rgba)[4 * idx + 0] =
                 reinterpret_cast<float **>(src)[idxR][srcIdx];
             (*out_rgba)[4 * idx + 1] =
                 reinterpret_cast<float **>(src)[idxG][srcIdx];
             (*out_rgba)[4 * idx + 2] =
                 reinterpret_cast<float **>(src)[idxB][srcIdx];
@@ -6309,15 +6513,17 @@
                   reinterpret_cast<float **>(src)[idxA][srcIdx];
             } else {
               (*out_rgba)[4 * idx + 3] = 1.0;
             }
           }
       }
     } else {
-      for (int i = 0; i < exr_image.width * exr_image.height; i++) {
+      const size_t pixel_size = static_cast<size_t>(exr_image.width) *
+        static_cast<size_t>(exr_image.height);
+      for (size_t i = 0; i < pixel_size; i++) {
         (*out_rgba)[4 * i + 0] =
             reinterpret_cast<float **>(exr_image.images)[idxR][i];
         (*out_rgba)[4 * i + 1] =
             reinterpret_cast<float **>(exr_image.images)[idxG][i];
         (*out_rgba)[4 * i + 2] =
             reinterpret_cast<float **>(exr_image.images)[idxB][i];
         if (idxA != -1) {
@@ -6335,65 +6541,221 @@
 
   FreeEXRHeader(&exr_header);
   FreeEXRImage(&exr_image);
 
   return TINYEXR_SUCCESS;
 }
 
+// Represents a read-only file mapped to an address space in memory.
+// If no memory-mapping API is available, falls back to allocating a buffer
+// with a copy of the file's data.
+struct MemoryMappedFile {
+  unsigned char *data;  // To the start of the file's data.
+  size_t size;          // The size of the file in bytes.
+#ifdef TINYEXR_USE_WIN32_MMAP
+  HANDLE windows_file;
+  HANDLE windows_file_mapping;
+#elif defined(TINYEXR_USE_POSIX_MMAP)
+  int posix_descriptor;
+#endif
+
+  // MemoryMappedFile's constructor tries to map memory to a file.
+  // If this succeeds, valid() will return true and all fields
+  // are usable; otherwise, valid() will return false.
+  MemoryMappedFile(const char *filename) {
+    data = NULL;
+    size = 0;
+#ifdef TINYEXR_USE_WIN32_MMAP
+    windows_file_mapping = NULL;
+    windows_file =
+        CreateFileW(tinyexr::UTF8ToWchar(filename).c_str(),  // lpFileName
+                    GENERIC_READ,                            // dwDesiredAccess
+                    FILE_SHARE_READ,                         // dwShareMode
+                    NULL,                     // lpSecurityAttributes
+                    OPEN_EXISTING,            // dwCreationDisposition
+                    FILE_ATTRIBUTE_READONLY,  // dwFlagsAndAttributes
+                    NULL);                    // hTemplateFile
+    if (windows_file == INVALID_HANDLE_VALUE) {
+      return;
+    }
+
+    windows_file_mapping = CreateFileMapping(windows_file,  // hFile
+                                             NULL,  // lpFileMappingAttributes
+                                             PAGE_READONLY,  // flProtect
+                                             0,      // dwMaximumSizeHigh
+                                             0,      // dwMaximumSizeLow
+                                             NULL);  // lpName
+    if (windows_file_mapping == NULL) {
+      return;
+    }
+
+    data = reinterpret_cast<unsigned char *>(
+        MapViewOfFile(windows_file_mapping,  // hFileMappingObject
+                      FILE_MAP_READ,         // dwDesiredAccess
+                      0,                     // dwFileOffsetHigh
+                      0,                     // dwFileOffsetLow
+                      0));                   // dwNumberOfBytesToMap
+    if (!data) {
+      return;
+    }
+
+    LARGE_INTEGER windows_file_size = {};
+    if (!GetFileSizeEx(windows_file, &windows_file_size) ||
+        static_cast<ULONGLONG>(windows_file_size.QuadPart) >
+            std::numeric_limits<size_t>::max()) {
+      UnmapViewOfFile(data);
+      data = NULL;
+      return;
+    }
+    size = static_cast<size_t>(windows_file_size.QuadPart);
+#elif defined(TINYEXR_USE_POSIX_MMAP)
+    posix_descriptor = open(filename, O_RDONLY);
+    if (posix_descriptor == -1) {
+      return;
+    }
+
+    struct stat info;
+    if (fstat(posix_descriptor, &info) < 0) {
+      return;
+    }
+    // Make sure st_size is in the valid range for a size_t. The second case
+    // can only fail if a POSIX implementation defines off_t to be a larger
+    // type than size_t - for instance, compiling with _FILE_OFFSET_BITS=64
+    // on a 32-bit system. On current 64-bit systems, this check can never
+    // fail, so we turn off clang's Wtautological-type-limit-compare warning
+    // around this code.
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wtautological-type-limit-compare"
+#endif
+    if (info.st_size < 0 ||
+        info.st_size > std::numeric_limits<ssize_t>::max()) {
+      return;
+    }
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+    size = static_cast<size_t>(info.st_size);
+
+    data = reinterpret_cast<unsigned char *>(
+        mmap(0, size, PROT_READ, MAP_SHARED, posix_descriptor, 0));
+    if (data == MAP_FAILED) {
+      return;
+    }
+#else
+    FILE *fp = fopen(filename, "rb");
+    if (!fp) {
+      return;
+    }
+
+    // Calling fseek(fp, 0, SEEK_END) isn't strictly-conforming C code, but
+    // since neither the WIN32 nor POSIX APIs are available in this branch, this
+    // is a reasonable fallback option.
+    if (fseek(fp, 0, SEEK_END) != 0) {
+      fclose(fp);
+      return;
+    }
+    const long ftell_result = ftell(fp);
+    if (ftell_result < 0) {
+      // Error from ftell
+      fclose(fp);
+      return;
+    }
+    size = static_cast<size_t>(ftell_result);
+    if (fseek(fp, 0, SEEK_SET) != 0) {
+      fclose(fp);
+      return;
+    }
+
+    data = reinterpret_cast<unsigned char *>(malloc(size));
+    if (!data) {
+      fclose(fp);
+      return;
+    }
+    size_t read_bytes = fread(data, 1, size, fp);
+    assert(read_bytes == size);
+    fclose(fp);
+    (void)read_bytes;
+#endif
+    assert(valid());
+  }
+
+  // MemoryMappedFile's destructor closes all its handles.
+  ~MemoryMappedFile() {
+#ifdef TINYEXR_USE_WIN32_MMAP
+    if (data) {
+      (void)UnmapViewOfFile(data);
+      data = NULL;
+    }
+
+    if (windows_file_mapping != NULL) {
+      (void)CloseHandle(windows_file_mapping);
+    }
+
+    if (windows_file != INVALID_HANDLE_VALUE) {
+      (void)CloseHandle(windows_file);
+    }
+#elif defined(TINYEXR_USE_POSIX_MMAP)
+    if (data) {
+      (void)munmap(data, size);
+      data = NULL;
+    }
+
+    if (posix_descriptor != -1) {
+      (void)close(posix_descriptor);
+    }
+#else
+    if (data) {
+      (void)free(data);
+    }
+    data = NULL;
+#endif
+  }
+
+  // A MemoryMappedFile cannot be copied or moved.
+  // Only check for this when compiling with C++11 or higher, since deleted
+  // function definitions were added then.
+#if TINYEXR_HAS_CXX11
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wc++98-compat"
+#endif
+  MemoryMappedFile(const MemoryMappedFile &) = delete;
+  MemoryMappedFile &operator=(const MemoryMappedFile &) = delete;
+  MemoryMappedFile(MemoryMappedFile &&other) noexcept = delete;
+  MemoryMappedFile &operator=(MemoryMappedFile &&other) noexcept = delete;
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+#endif
+
+  // Returns whether this was successfully opened.
+  bool valid() const { return data; }
+};
+
 int LoadEXRImageFromFile(EXRImage *exr_image, const EXRHeader *exr_header,
                          const char *filename, const char **err) {
   if (exr_image == NULL) {
     tinyexr::SetErrorMessage("Invalid argument for LoadEXRImageFromFile", err);
     return TINYEXR_ERROR_INVALID_ARGUMENT;
   }
 
-  FILE *fp = NULL;
-#ifdef _WIN32
-#if defined(_MSC_VER) || (defined(MINGW_HAS_SECURE_API) && MINGW_HAS_SECURE_API) // MSVC, MinGW GCC, or Clang.
-  errno_t errcode =
-      _wfopen_s(&fp, tinyexr::UTF8ToWchar(filename).c_str(), L"rb");
-  if (errcode != 0) {
-    tinyexr::SetErrorMessage("Cannot read file " + std::string(filename), err);
-    // TODO(syoyo): return wfopen_s erro code
-    return TINYEXR_ERROR_CANT_OPEN_FILE;
-  }
-#else
-  // Unknown compiler or MinGW without MINGW_HAS_SECURE_API.
-  fp = fopen(filename, "rb");
-#endif
-#else
-  fp = fopen(filename, "rb");
-#endif
-  if (!fp) {
+  MemoryMappedFile file(filename);
+  if (!file.valid()) {
     tinyexr::SetErrorMessage("Cannot read file " + std::string(filename), err);
     return TINYEXR_ERROR_CANT_OPEN_FILE;
   }
 
-  size_t filesize;
-  // Compute size
-  fseek(fp, 0, SEEK_END);
-  filesize = static_cast<size_t>(ftell(fp));
-  fseek(fp, 0, SEEK_SET);
-
-  if (filesize < 16) {
-    tinyexr::SetErrorMessage("File size too short " + std::string(filename),
+  if (file.size < 16) {
+    tinyexr::SetErrorMessage("File size too short : " + std::string(filename),
                              err);
     return TINYEXR_ERROR_INVALID_FILE;
   }
 
-  std::vector<unsigned char> buf(filesize);  // @todo { use mmap }
-  {
-    size_t ret;
-    ret = fread(&buf[0], 1, filesize, fp);
-    assert(ret == filesize);
-    fclose(fp);
-    (void)ret;
-  }
-
-  return LoadEXRImageFromMemory(exr_image, exr_header, &buf.at(0), filesize,
+  return LoadEXRImageFromMemory(exr_image, exr_header, file.data, file.size,
                                 err);
 }
 
 int LoadEXRImageFromMemory(EXRImage *exr_image, const EXRHeader *exr_header,
                            const unsigned char *memory, const size_t size,
                            const char **err) {
   if (exr_image == NULL || memory == NULL ||
@@ -6422,26 +6784,27 @@
 #ifdef __clang__
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wsign-conversion"
 #endif
 
 // out_data must be allocated initially with the block-header size
 // of the current image(-part) type
-static bool EncodePixelData(/* out */ std::vector<unsigned char>& out_data,                         
+static bool EncodePixelData(/* out */ std::vector<unsigned char>& out_data,
                             const unsigned char* const* images,
                             int compression_type,
                             int /*line_order*/,
                             int width, // for tiled : tile.width
                             int /*height*/, // for tiled : header.tile_size_y
                             int x_stride, // for tiled : header.tile_size_x
                             int line_no, // for tiled : 0
                             int num_lines, // for tiled : tile.height
                             size_t pixel_data_size,
                             const std::vector<ChannelInfo>& channels,
                             const std::vector<size_t>& channel_offset_list,
+                            std::string *err,
                             const void* compression_param = 0) // zfp compression param
 {
   size_t buf_size = static_cast<size_t>(width) *
                   static_cast<size_t>(num_lines) *
                   static_cast<size_t>(pixel_data_size);
   //int last2bit = (buf_size & 3);
   // buf_size must be multiple of four
@@ -6486,15 +6849,18 @@
             tinyexr::swap2(&val);
 
             // line_ptr[x] = val;
             tinyexr::cpy2(line_ptr + x, &val);
           }
         }
       } else {
-        assert(0);
+        if (err) {
+          (*err) += "Invalid requested_pixel_type.\n";
+        }
+        return false;
       }
 
     } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_FLOAT) {
       if (channels[c].requested_pixel_type == TINYEXR_PIXELTYPE_HALF) {
         for (int y = 0; y < num_lines; y++) {
           // Assume increasing Y
           unsigned short *line_ptr = reinterpret_cast<unsigned short *>(
@@ -6530,15 +6896,18 @@
             tinyexr::swap4(&val);
 
             // line_ptr[x] = val;
             tinyexr::cpy4(line_ptr + x, &val);
           }
         }
       } else {
-        assert(0);
+        if (err) {
+          (*err) += "Invalid requested_pixel_type.\n";
+        }
+        return false;
       }
     } else if (channels[c].pixel_type == TINYEXR_PIXELTYPE_UINT) {
       for (int y = 0; y < num_lines; y++) {
         // Assume increasing Y
         unsigned int *line_ptr = reinterpret_cast<unsigned int *>(&buf.at(
           static_cast<size_t>(pixel_data_size * y * width) +
           channel_offset_list[c] * static_cast<size_t>(width)));
@@ -6562,23 +6931,32 @@
     out_data.insert(out_data.end(), buf.begin(), buf.end());
 
   } else if ((compression_type == TINYEXR_COMPRESSIONTYPE_ZIPS) ||
     (compression_type == TINYEXR_COMPRESSIONTYPE_ZIP)) {
 #if TINYEXR_USE_MINIZ
     std::vector<unsigned char> block(mz_compressBound(
       static_cast<unsigned long>(buf.size())));
+#elif TINYEXR_USE_STB_ZLIB
+    // there is no compressBound() function, so we use a value that
+    // is grossly overestimated, but should always work
+    std::vector<unsigned char> block(256 + 2 * buf.size());
 #else
     std::vector<unsigned char> block(
       compressBound(static_cast<uLong>(buf.size())));
 #endif
     tinyexr::tinyexr_uint64 outSize = block.size();
 
-    tinyexr::CompressZip(&block.at(0), outSize,
+    if (!tinyexr::CompressZip(&block.at(0), outSize,
                          reinterpret_cast<const unsigned char *>(&buf.at(0)),
-                         static_cast<unsigned long>(buf.size()));
+                         static_cast<unsigned long>(buf.size()))) {
+      if (err) {
+        (*err) += "Zip compresssion failed.\n";
+      }
+      return false;
+    }
 
     // 4 byte: scan line
     // 4 byte: data size
     // ~     : pixel data(compressed)
     unsigned int data_len = static_cast<unsigned int>(outSize);  // truncate
 
     out_data.insert(out_data.end(), block.begin(), block.begin() + data_len);
@@ -6615,15 +6993,18 @@
     // 4 byte: scan line
     // 4 byte: data size
     // ~     : pixel data(compressed)
     unsigned int data_len = outSize;
     out_data.insert(out_data.end(), block.begin(), block.begin() + data_len);
 
 #else
-    assert(0);
+    if (err) {
+      (*err) += "PIZ compression is disabled in this build.\n";
+    }
+    return false;
 #endif
   } else if (compression_type == TINYEXR_COMPRESSIONTYPE_ZFP) {
 #if TINYEXR_USE_ZFP
     const ZFPCompressionParam* zfp_compression_param = reinterpret_cast<const ZFPCompressionParam*>(compression_param);
     std::vector<unsigned char> block;
     unsigned int outSize;
 
@@ -6634,19 +7015,21 @@
     // 4 byte: scan line
     // 4 byte: data size
     // ~     : pixel data(compressed)
     unsigned int data_len = outSize;
     out_data.insert(out_data.end(), block.begin(), block.begin() + data_len);
 
 #else
+    if (err) {
+      (*err) += "ZFP compression is disabled in this build.\n";
+    }
     (void)compression_param;
-    assert(0);
+    return false;
 #endif
   } else {
-    assert(0);
     return false;
   }
 
   return true;
 }
 
 static int EncodeTiledLevel(const EXRImage* level_image, const EXRHeader* exr_header,
@@ -6702,33 +7085,33 @@
     size_t tile_idx = static_cast<size_t>(i);
     size_t data_idx = tile_idx + start_index;
 
     int x_tile = i % num_x_tiles;
     int y_tile = i / num_x_tiles;
 
     EXRTile& tile = level_image->tiles[tile_idx];
- 
+
     const unsigned char* const* images =
       static_cast<const unsigned char* const*>(tile.images);
 
     data_list[data_idx].resize(5*sizeof(int));
     size_t data_header_size = data_list[data_idx].size();
-    bool ret = EncodePixelData(data_list[data_idx],                         
+    bool ret = EncodePixelData(data_list[data_idx],
                                images,
                                exr_header->compression_type,
                                0, // increasing y
                                tile.width,
                                exr_header->tile_size_y,
                                exr_header->tile_size_x,
                                0,
                                tile.height,
                                pixel_data_size,
                                channels,
                                channel_offset_list,
-                               compression_param);
+                               err, compression_param);
     if (!ret) {
       invalid_data = true;
       continue;
     }
     assert(data_list[data_idx].size() > data_header_size);
     int data_len = static_cast<int>(data_list[data_idx].size() - data_header_size);
     //tileX, tileY, levelX, levelY // pixel_data_size(int)
@@ -6754,15 +7137,15 @@
     }
 #else
     }  // omp parallel
 #endif
 
   if (invalid_data) {
     if (err) {
-      (*err) += "Failed to encode tile data.\n";  
+      (*err) += "Failed to encode tile data.\n";
     }
     return TINYEXR_ERROR_INVALID_DATA;
   }
   return TINYEXR_SUCCESS;
 }
 
 static int NumScanlines(int compression_type) {
@@ -6925,30 +7308,31 @@
 
       const unsigned char* const* images =
         static_cast<const unsigned char* const*>(exr_image->images);
 
       data_list[i].resize(2*sizeof(int));
       size_t data_header_size = data_list[i].size();
 
-      bool ret = EncodePixelData(data_list[i],                         
+      bool ret = EncodePixelData(data_list[i],
                                  images,
                                  exr_header->compression_type,
                                  0, // increasing y
                                  exr_image->width,
                                  exr_image->height,
                                  exr_image->width,
                                  start_y,
                                  num_lines,
                                  pixel_data_size,
                                  channels,
                                  channel_offset_list,
+                                 err,
                                  compression_param);
       if (!ret) {
         invalid_data = true;
-        continue; // "break" cannot be used with OpenMP 
+        continue; // "break" cannot be used with OpenMP
       }
       assert(data_list[i].size() > data_header_size);
       int data_len = static_cast<int>(data_list[i].size() - data_header_size);
       memcpy(&data_list[i][0], &start_y, sizeof(int));
       memcpy(&data_list[i][4], &data_len, sizeof(int));
 
       swap4(reinterpret_cast<int*>(&data_list[i][0]));
@@ -7184,15 +7568,19 @@
 
       // must be present for multi-part files - according to spec.
       if (num_parts > 1) {
         // name
         {
           size_t len = 0;
           if ((len = strlen(exr_headers[i]->name)) > 0) {
+#if TINYEXR_HAS_CXX11
             partnames.emplace(exr_headers[i]->name);
+#else
+            partnames.insert(std::string(exr_headers[i]->name));
+#endif
             if (partnames.size() != i + 1) {
               SetErrorMessage("'name' attributes must be unique for a multi-part file", err);
               return 0;
             }
             WriteAttributeToMemory(
               &memory, "name", "string",
               reinterpret_cast<const unsigned char*>(exr_headers[i]->name),
@@ -7268,15 +7656,15 @@
   }
 
   // Allocating required memory
   if (total_size == 0) { // something went wrong
     tinyexr::SetErrorMessage("Output memory size is zero", err);
     return 0;
   }
-  (*memory_out) = static_cast<unsigned char*>(malloc(total_size));
+  (*memory_out) = static_cast<unsigned char*>(malloc(size_t(total_size)));
 
   // Writing header
   memcpy((*memory_out), &memory[0], memory.size());
   unsigned char* memory_ptr = *memory_out + memory.size();
   size_t sum = memory.size();
 
   // Writing offset data for chunks
@@ -7321,15 +7709,15 @@
       sum += data_lists[i][j].size();
       assert(sum <= total_size);
       memcpy(memory_ptr, &data_lists[i][j][0], data_lists[i][j].size());
       memory_ptr += data_lists[i][j].size();
     }
   }
   assert(sum == total_size);
-  return total_size;  // OK
+  return size_t(total_size);  // OK
 }
 
 #ifdef __clang__
 #pragma clang diagnostic pop
 #endif
 
 } // tinyexr
@@ -7386,15 +7774,16 @@
                              err);
     return TINYEXR_ERROR_CANT_WRITE_FILE;
   }
 
   unsigned char *mem = NULL;
   size_t mem_size = SaveEXRImageToMemory(exr_image, exr_header, &mem, err);
   if (mem_size == 0) {
-    return TINYEXR_ERROR_SERIALZATION_FAILED;
+    fclose(fp);
+    return TINYEXR_ERROR_SERIALIZATION_FAILED;
   }
 
   size_t written_size = 0;
   if ((mem_size > 0) && mem) {
     written_size = fwrite(mem, 1, mem_size, fp);
   }
   free(mem);
@@ -7455,15 +7844,16 @@
                              err);
     return TINYEXR_ERROR_CANT_WRITE_FILE;
   }
 
   unsigned char *mem = NULL;
   size_t mem_size = SaveEXRMultipartImageToMemory(exr_images, exr_headers, num_parts, &mem, err);
   if (mem_size == 0) {
-    return TINYEXR_ERROR_SERIALZATION_FAILED;
+    fclose(fp);
+    return TINYEXR_ERROR_SERIALIZATION_FAILED;
   }
 
   size_t written_size = 0;
   if ((mem_size > 0) && mem) {
     written_size = fwrite(mem, 1, mem_size, fp);
   }
   free(mem);
@@ -7480,66 +7870,28 @@
 
 int LoadDeepEXR(DeepImage *deep_image, const char *filename, const char **err) {
   if (deep_image == NULL) {
     tinyexr::SetErrorMessage("Invalid argument for LoadDeepEXR", err);
     return TINYEXR_ERROR_INVALID_ARGUMENT;
   }
 
-#ifdef _WIN32
-  FILE *fp = NULL;
-#if defined(_MSC_VER) || (defined(MINGW_HAS_SECURE_API) && MINGW_HAS_SECURE_API) // MSVC, MinGW GCC, or Clang.
-  errno_t errcode =
-      _wfopen_s(&fp, tinyexr::UTF8ToWchar(filename).c_str(), L"rb");
-  if (errcode != 0) {
-    tinyexr::SetErrorMessage("Cannot read a file " + std::string(filename),
-                             err);
-    return TINYEXR_ERROR_CANT_OPEN_FILE;
-  }
-#else
-  // Unknown compiler or MinGW without MINGW_HAS_SECURE_API.
-  fp = fopen(filename, "rb");
-#endif
-  if (!fp) {
-    tinyexr::SetErrorMessage("Cannot read a file " + std::string(filename),
-                             err);
-    return TINYEXR_ERROR_CANT_OPEN_FILE;
-  }
-#else
-  FILE *fp = fopen(filename, "rb");
-  if (!fp) {
-    tinyexr::SetErrorMessage("Cannot read a file " + std::string(filename),
-                             err);
+  MemoryMappedFile file(filename);
+  if (!file.valid()) {
+    tinyexr::SetErrorMessage("Cannot read file " + std::string(filename), err);
     return TINYEXR_ERROR_CANT_OPEN_FILE;
   }
-#endif
-
-  size_t filesize;
-  // Compute size
-  fseek(fp, 0, SEEK_END);
-  filesize = static_cast<size_t>(ftell(fp));
-  fseek(fp, 0, SEEK_SET);
 
-  if (filesize == 0) {
-    fclose(fp);
+  if (file.size == 0) {
     tinyexr::SetErrorMessage("File size is zero : " + std::string(filename),
                              err);
     return TINYEXR_ERROR_INVALID_FILE;
   }
 
-  std::vector<char> buf(filesize);  // @todo { use mmap }
-  {
-    size_t ret;
-    ret = fread(&buf[0], 1, filesize, fp);
-    assert(ret == filesize);
-    (void)ret;
-  }
-  fclose(fp);
-
-  const char *head = &buf[0];
-  const char *marker = &buf[0];
+  const char *head = reinterpret_cast<const char *>(file.data);
+  const char *marker = reinterpret_cast<const char *>(file.data);
 
   // Header check.
   {
     const char header[] = {0x76, 0x2f, 0x31, 0x01};
 
     if (memcmp(marker, header, 4) != 0) {
       tinyexr::SetErrorMessage("Invalid magic number", err);
@@ -7566,15 +7918,15 @@
   int dh = -1;
   int num_scanline_blocks = 1;  // 16 for ZIP compression.
   int compression_type = -1;
   int num_channels = -1;
   std::vector<tinyexr::ChannelInfo> channels;
 
   // Read attributes
-  size_t size = filesize - tinyexr::kEXRVersionSize;
+  size_t size = file.size - tinyexr::kEXRVersionSize;
   for (;;) {
     if (0 == size) {
       return TINYEXR_ERROR_INVALID_DATA;
     } else if (marker[0] == '\0') {
       marker++;
       size--;
       break;
@@ -7997,56 +8349,21 @@
                            const char *filename, const char **err) {
   if (exr_header == NULL || exr_version == NULL || filename == NULL) {
     tinyexr::SetErrorMessage("Invalid argument for ParseEXRHeaderFromFile",
                              err);
     return TINYEXR_ERROR_INVALID_ARGUMENT;
   }
 
-  FILE *fp = NULL;
-#ifdef _WIN32
-#if defined(_MSC_VER) || (defined(MINGW_HAS_SECURE_API) && MINGW_HAS_SECURE_API) // MSVC, MinGW GCC, or Clang.
-  errno_t errcode =
-      _wfopen_s(&fp, tinyexr::UTF8ToWchar(filename).c_str(), L"rb");
-  if (errcode != 0) {
-    tinyexr::SetErrorMessage("Cannot read file " + std::string(filename), err);
-    return TINYEXR_ERROR_INVALID_FILE;
-  }
-#else
-  // Unknown compiler or MinGW without MINGW_HAS_SECURE_API.
-  fp = fopen(filename, "rb");
-#endif
-#else
-  fp = fopen(filename, "rb");
-#endif
-  if (!fp) {
+  MemoryMappedFile file(filename);
+  if (!file.valid()) {
     tinyexr::SetErrorMessage("Cannot read file " + std::string(filename), err);
     return TINYEXR_ERROR_CANT_OPEN_FILE;
   }
 
-  size_t filesize;
-  // Compute size
-  fseek(fp, 0, SEEK_END);
-  filesize = static_cast<size_t>(ftell(fp));
-  fseek(fp, 0, SEEK_SET);
-
-  std::vector<unsigned char> buf(filesize);  // @todo { use mmap }
-  {
-    size_t ret;
-    ret = fread(&buf[0], 1, filesize, fp);
-    assert(ret == filesize);
-    fclose(fp);
-
-    if (ret != filesize) {
-      tinyexr::SetErrorMessage("fread() error on " + std::string(filename),
-                               err);
-      return TINYEXR_ERROR_INVALID_FILE;
-    }
-  }
-
-  return ParseEXRHeaderFromMemory(exr_header, exr_version, &buf.at(0), filesize,
+  return ParseEXRHeaderFromMemory(exr_header, exr_version, file.data, file.size,
                                   err);
 }
 
 int ParseEXRMultipartHeaderFromMemory(EXRHeader ***exr_headers,
                                       int *num_headers,
                                       const EXRVersion *exr_version,
                                       const unsigned char *memory, size_t size,
@@ -8075,25 +8392,41 @@
 
     std::string err_str;
     bool empty_header = false;
     int ret = ParseEXRHeader(&info, &empty_header, exr_version, &err_str,
                              marker, marker_size);
 
     if (ret != TINYEXR_SUCCESS) {
+
+      // Free malloc-allocated memory here.
+      for (size_t i = 0; i < info.attributes.size(); i++) {
+        if (info.attributes[i].value) {
+          free(info.attributes[i].value);
+        }
+      }
+
       tinyexr::SetErrorMessage(err_str, err);
       return ret;
     }
 
     if (empty_header) {
       marker += 1;  // skip '\0'
       break;
     }
 
     // `chunkCount` must exist in the header.
     if (info.chunk_count == 0) {
+
+      // Free malloc-allocated memory here.
+      for (size_t i = 0; i < info.attributes.size(); i++) {
+        if (info.attributes[i].value) {
+          free(info.attributes[i].value);
+        }
+      }
+
       tinyexr::SetErrorMessage(
           "`chunkCount' attribute is not found in the header.", err);
       return TINYEXR_ERROR_INVALID_DATA;
     }
 
     infos.push_back(info);
 
@@ -8102,24 +8435,32 @@
     size -= info.header_len;
   }
 
   // allocate memory for EXRHeader and create array of EXRHeader pointers.
   (*exr_headers) =
       static_cast<EXRHeader **>(malloc(sizeof(EXRHeader *) * infos.size()));
 
-  
+
   int retcode = TINYEXR_SUCCESS;
 
   for (size_t i = 0; i < infos.size(); i++) {
     EXRHeader *exr_header = static_cast<EXRHeader *>(malloc(sizeof(EXRHeader)));
     memset(exr_header, 0, sizeof(EXRHeader));
 
     std::string warn;
     std::string _err;
     if (!ConvertHeader(exr_header, infos[i], &warn, &_err)) {
+
+      // Free malloc-allocated memory here.
+      for (size_t k = 0; k < infos[i].attributes.size(); i++) {
+        if (infos[i].attributes[k].value) {
+          free(infos[i].attributes[k].value);
+        }
+      }
+
       if (!_err.empty()) {
         tinyexr::SetErrorMessage(
             _err, err);
       }
       // continue to converting headers
       retcode = TINYEXR_ERROR_INVALID_HEADER;
     }
@@ -8140,56 +8481,22 @@
   if (exr_headers == NULL || num_headers == NULL || exr_version == NULL ||
       filename == NULL) {
     tinyexr::SetErrorMessage(
         "Invalid argument for ParseEXRMultipartHeaderFromFile()", err);
     return TINYEXR_ERROR_INVALID_ARGUMENT;
   }
 
-  FILE *fp = NULL;
-#ifdef _WIN32
-#if defined(_MSC_VER) || (defined(MINGW_HAS_SECURE_API) && MINGW_HAS_SECURE_API) // MSVC, MinGW GCC, or Clang.
-  errno_t errcode =
-      _wfopen_s(&fp, tinyexr::UTF8ToWchar(filename).c_str(), L"rb");
-  if (errcode != 0) {
-    tinyexr::SetErrorMessage("Cannot read file " + std::string(filename), err);
-    return TINYEXR_ERROR_INVALID_FILE;
-  }
-#else
-  // Unknown compiler or MinGW without MINGW_HAS_SECURE_API.
-  fp = fopen(filename, "rb");
-#endif
-#else
-  fp = fopen(filename, "rb");
-#endif
-  if (!fp) {
+  MemoryMappedFile file(filename);
+  if (!file.valid()) {
     tinyexr::SetErrorMessage("Cannot read file " + std::string(filename), err);
     return TINYEXR_ERROR_CANT_OPEN_FILE;
   }
 
-  size_t filesize;
-  // Compute size
-  fseek(fp, 0, SEEK_END);
-  filesize = static_cast<size_t>(ftell(fp));
-  fseek(fp, 0, SEEK_SET);
-
-  std::vector<unsigned char> buf(filesize);  // @todo { use mmap }
-  {
-    size_t ret;
-    ret = fread(&buf[0], 1, filesize, fp);
-    assert(ret == filesize);
-    fclose(fp);
-
-    if (ret != filesize) {
-      tinyexr::SetErrorMessage("`fread' error. file may be corrupted.", err);
-      return TINYEXR_ERROR_INVALID_FILE;
-    }
-  }
-
   return ParseEXRMultipartHeaderFromMemory(
-      exr_headers, num_headers, exr_version, &buf.at(0), filesize, err);
+      exr_headers, num_headers, exr_version, file.data, file.size, err);
 }
 
 int ParseEXRVersionFromMemory(EXRVersion *version, const unsigned char *memory,
                               size_t size) {
   if (version == NULL || memory == NULL) {
     return TINYEXR_ERROR_INVALID_ARGUMENT;
   }
@@ -8265,24 +8572,18 @@
 #else
   fp = fopen(filename, "rb");
 #endif
   if (!fp) {
     return TINYEXR_ERROR_CANT_OPEN_FILE;
   }
 
-  size_t file_size;
-  // Compute size
-  fseek(fp, 0, SEEK_END);
-  file_size = static_cast<size_t>(ftell(fp));
-  fseek(fp, 0, SEEK_SET);
-
-  if (file_size < tinyexr::kEXRVersionSize) {
-    return TINYEXR_ERROR_INVALID_FILE;
-  }
-
+  // Try to read kEXRVersionSize bytes; if the file is shorter than
+  // kEXRVersionSize, this will produce an error. This avoids a call to
+  // fseek(fp, 0, SEEK_END), which is not required to be supported by C
+  // implementations.
   unsigned char buf[tinyexr::kEXRVersionSize];
   size_t ret = fread(&buf[0], 1, tinyexr::kEXRVersionSize, fp);
   fclose(fp);
 
   if (ret != tinyexr::kEXRVersionSize) {
     return TINYEXR_ERROR_INVALID_FILE;
   }
@@ -8371,26 +8672,26 @@
             tinyexr::swap8(&offset);
             if (offset >= size) {
               tinyexr::SetErrorMessage("Invalid offset size in EXR header chunks.",
                 err);
               return TINYEXR_ERROR_INVALID_DATA;
             }
             offset_data.offsets[l][dy][dx] = offset + 4; // +4 to skip 'part number'
-            marker += sizeof(tinyexr::tinyexr_uint64);  // = 8 
+            marker += sizeof(tinyexr::tinyexr_uint64);  // = 8
           }
         }
       }
     }
   }
 
   // Decode image.
   for (size_t i = 0; i < static_cast<size_t>(num_parts); i++) {
     tinyexr::OffsetData &offset_data = chunk_offset_table_list[i];
 
-    // First check 'part number' is identitical to 'i'
+    // First check 'part number' is identical to 'i'
     for (unsigned int l = 0; l < offset_data.offsets.size(); ++l)
       for (unsigned int dy = 0; dy < offset_data.offsets[l].size(); ++dy)
         for (unsigned int dx = 0; dx < offset_data.offsets[l][dy].size(); ++dx) {
 
           const unsigned char *part_number_addr =
               memory + offset_data.offsets[l][dy][dx] - 4;  // -4 to move to 'part number' field.
           unsigned int part_no;
@@ -8424,52 +8725,172 @@
                                   const char **err) {
   if (exr_images == NULL || exr_headers == NULL || num_parts == 0) {
     tinyexr::SetErrorMessage(
         "Invalid argument for LoadEXRMultipartImageFromFile", err);
     return TINYEXR_ERROR_INVALID_ARGUMENT;
   }
 
-  FILE *fp = NULL;
-#ifdef _WIN32
-#if defined(_MSC_VER) || (defined(MINGW_HAS_SECURE_API) && MINGW_HAS_SECURE_API) // MSVC, MinGW GCC, or Clang.
-  errno_t errcode =
-      _wfopen_s(&fp, tinyexr::UTF8ToWchar(filename).c_str(), L"rb");
-  if (errcode != 0) {
+  MemoryMappedFile file(filename);
+  if (!file.valid()) {
     tinyexr::SetErrorMessage("Cannot read file " + std::string(filename), err);
     return TINYEXR_ERROR_CANT_OPEN_FILE;
   }
+
+  return LoadEXRMultipartImageFromMemory(exr_images, exr_headers, num_parts,
+                                         file.data, file.size, err);
+}
+
+int SaveEXRToMemory(const float *data, int width, int height, int components,
+            const int save_as_fp16, const unsigned char **outbuf, const char **err) {
+
+  if ((components == 1) || components == 3 || components == 4) {
+    // OK
+  } else {
+    std::stringstream ss;
+    ss << "Unsupported component value : " << components << std::endl;
+
+    tinyexr::SetErrorMessage(ss.str(), err);
+    return TINYEXR_ERROR_INVALID_ARGUMENT;
+  }
+
+  EXRHeader header;
+  InitEXRHeader(&header);
+
+  if ((width < 16) && (height < 16)) {
+    // No compression for small image.
+    header.compression_type = TINYEXR_COMPRESSIONTYPE_NONE;
+  } else {
+    header.compression_type = TINYEXR_COMPRESSIONTYPE_ZIP;
+  }
+
+  EXRImage image;
+  InitEXRImage(&image);
+
+  image.num_channels = components;
+
+  std::vector<float> images[4];
+
+  if (components == 1) {
+    images[0].resize(static_cast<size_t>(width * height));
+    memcpy(images[0].data(), data, sizeof(float) * size_t(width * height));
+  } else {
+    images[0].resize(static_cast<size_t>(width * height));
+    images[1].resize(static_cast<size_t>(width * height));
+    images[2].resize(static_cast<size_t>(width * height));
+    images[3].resize(static_cast<size_t>(width * height));
+
+    // Split RGB(A)RGB(A)RGB(A)... into R, G and B(and A) layers
+    for (size_t i = 0; i < static_cast<size_t>(width * height); i++) {
+      images[0][i] = data[static_cast<size_t>(components) * i + 0];
+      images[1][i] = data[static_cast<size_t>(components) * i + 1];
+      images[2][i] = data[static_cast<size_t>(components) * i + 2];
+      if (components == 4) {
+        images[3][i] = data[static_cast<size_t>(components) * i + 3];
+      }
+    }
+  }
+
+  float *image_ptr[4] = {0, 0, 0, 0};
+  if (components == 4) {
+    image_ptr[0] = &(images[3].at(0));  // A
+    image_ptr[1] = &(images[2].at(0));  // B
+    image_ptr[2] = &(images[1].at(0));  // G
+    image_ptr[3] = &(images[0].at(0));  // R
+  } else if (components == 3) {
+    image_ptr[0] = &(images[2].at(0));  // B
+    image_ptr[1] = &(images[1].at(0));  // G
+    image_ptr[2] = &(images[0].at(0));  // R
+  } else if (components == 1) {
+    image_ptr[0] = &(images[0].at(0));  // A
+  }
+
+  image.images = reinterpret_cast<unsigned char **>(image_ptr);
+  image.width = width;
+  image.height = height;
+
+  header.num_channels = components;
+  header.channels = static_cast<EXRChannelInfo *>(malloc(
+      sizeof(EXRChannelInfo) * static_cast<size_t>(header.num_channels)));
+  // Must be (A)BGR order, since most of EXR viewers expect this channel order.
+  if (components == 4) {
+#ifdef _MSC_VER
+    strncpy_s(header.channels[0].name, "A", 255);
+    strncpy_s(header.channels[1].name, "B", 255);
+    strncpy_s(header.channels[2].name, "G", 255);
+    strncpy_s(header.channels[3].name, "R", 255);
 #else
-  // Unknown compiler or MinGW without MINGW_HAS_SECURE_API.
-  fp = fopen(filename, "rb");
+    strncpy(header.channels[0].name, "A", 255);
+    strncpy(header.channels[1].name, "B", 255);
+    strncpy(header.channels[2].name, "G", 255);
+    strncpy(header.channels[3].name, "R", 255);
+#endif
+    header.channels[0].name[strlen("A")] = '\0';
+    header.channels[1].name[strlen("B")] = '\0';
+    header.channels[2].name[strlen("G")] = '\0';
+    header.channels[3].name[strlen("R")] = '\0';
+  } else if (components == 3) {
+#ifdef _MSC_VER
+    strncpy_s(header.channels[0].name, "B", 255);
+    strncpy_s(header.channels[1].name, "G", 255);
+    strncpy_s(header.channels[2].name, "R", 255);
+#else
+    strncpy(header.channels[0].name, "B", 255);
+    strncpy(header.channels[1].name, "G", 255);
+    strncpy(header.channels[2].name, "R", 255);
 #endif
+    header.channels[0].name[strlen("B")] = '\0';
+    header.channels[1].name[strlen("G")] = '\0';
+    header.channels[2].name[strlen("R")] = '\0';
+  } else {
+#ifdef _MSC_VER
+    strncpy_s(header.channels[0].name, "A", 255);
 #else
-  fp = fopen(filename, "rb");
+    strncpy(header.channels[0].name, "A", 255);
 #endif
-  if (!fp) {
-    tinyexr::SetErrorMessage("Cannot read file " + std::string(filename), err);
-    return TINYEXR_ERROR_CANT_OPEN_FILE;
+    header.channels[0].name[strlen("A")] = '\0';
   }
 
-  size_t filesize;
-  // Compute size
-  fseek(fp, 0, SEEK_END);
-  filesize = static_cast<size_t>(ftell(fp));
-  fseek(fp, 0, SEEK_SET);
+  header.pixel_types = static_cast<int *>(
+      malloc(sizeof(int) * static_cast<size_t>(header.num_channels)));
+  header.requested_pixel_types = static_cast<int *>(
+      malloc(sizeof(int) * static_cast<size_t>(header.num_channels)));
+  for (int i = 0; i < header.num_channels; i++) {
+    header.pixel_types[i] =
+        TINYEXR_PIXELTYPE_FLOAT;  // pixel type of input image
 
-  std::vector<unsigned char> buf(filesize);  //  @todo { use mmap }
-  {
-    size_t ret;
-    ret = fread(&buf[0], 1, filesize, fp);
-    assert(ret == filesize);
-    fclose(fp);
-    (void)ret;
+    if (save_as_fp16 > 0) {
+      header.requested_pixel_types[i] =
+          TINYEXR_PIXELTYPE_HALF;  // save with half(fp16) pixel format
+    } else {
+      header.requested_pixel_types[i] =
+          TINYEXR_PIXELTYPE_FLOAT;  // save with float(fp32) pixel format(i.e.
+                                    // no precision reduction)
+    }
   }
 
-  return LoadEXRMultipartImageFromMemory(exr_images, exr_headers, num_parts,
-                                         &buf.at(0), filesize, err);
+
+  unsigned char *mem_buf;
+  size_t mem_size = SaveEXRImageToMemory(&image, &header, &mem_buf, err);
+
+  if (mem_size == 0) {
+    return TINYEXR_ERROR_SERIALIZATION_FAILED;
+  }
+
+  free(header.channels);
+  free(header.pixel_types);
+  free(header.requested_pixel_types);
+
+  if (mem_size > size_t(std::numeric_limits<int>::max())) {
+    free(mem_buf);
+    return TINYEXR_ERROR_DATA_TOO_LARGE;
+  }
+
+  (*outbuf) = mem_buf;
+
+  return int(mem_size);
 }
 
 int SaveEXR(const float *data, int width, int height, int components,
             const int save_as_fp16, const char *outfilename, const char **err) {
   if ((components == 1) || components == 3 || components == 4) {
     // OK
   } else {
@@ -8492,26 +8913,28 @@
 
   EXRImage image;
   InitEXRImage(&image);
 
   image.num_channels = components;
 
   std::vector<float> images[4];
+  const size_t pixel_count =
+      static_cast<size_t>(width) * static_cast<size_t>(height);
 
   if (components == 1) {
-    images[0].resize(static_cast<size_t>(width * height));
-    memcpy(images[0].data(), data, sizeof(float) * size_t(width * height));
+    images[0].resize(pixel_count);
+    memcpy(images[0].data(), data, sizeof(float) * pixel_count);
   } else {
-    images[0].resize(static_cast<size_t>(width * height));
-    images[1].resize(static_cast<size_t>(width * height));
-    images[2].resize(static_cast<size_t>(width * height));
-    images[3].resize(static_cast<size_t>(width * height));
+    images[0].resize(pixel_count);
+    images[1].resize(pixel_count);
+    images[2].resize(pixel_count);
+    images[3].resize(pixel_count);
 
     // Split RGB(A)RGB(A)RGB(A)... into R, G and B(and A) layers
-    for (size_t i = 0; i < static_cast<size_t>(width * height); i++) {
+    for (size_t i = 0; i < pixel_count; i++) {
       images[0][i] = data[static_cast<size_t>(components) * i + 0];
       images[1][i] = data[static_cast<size_t>(components) * i + 1];
       images[2][i] = data[static_cast<size_t>(components) * i + 2];
       if (components == 4) {
         images[3][i] = data[static_cast<size_t>(components) * i + 3];
       }
     }
@@ -8604,13 +9027,13 @@
   free(header.pixel_types);
   free(header.requested_pixel_types);
 
   return ret;
 }
 
 #ifdef __clang__
-// zero-as-null-ppinter-constant
+// zero-as-null-pointer-constant
 #pragma clang diagnostic pop
 #endif
 
 #endif  // TINYEXR_IMPLEMENTATION_DEFINED
 #endif  // TINYEXR_IMPLEMENTATION
```

### Comparing `tinyusdz-0.8.0rc0/src/external/tinyxml2/LICENSE.txt` & `tinyusdz-0.8.0rc1/src/external/tinyxml2/LICENSE.txt`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/tinyxml2/readme.md` & `tinyusdz-0.8.0rc1/src/external/tinyxml2/readme.md`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/tinyxml2/tinyxml2.cpp` & `tinyusdz-0.8.0rc1/src/external/tinyxml2/tinyxml2.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/external/tinyxml2/tinyxml2.h` & `tinyusdz-0.8.0rc1/src/external/tinyxml2/tinyxml2.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/image-loader.hh` & `tinyusdz-0.8.0rc1/src/audio-loader.hh`

 * *Files 22% similar despite different names*

```diff
@@ -1,36 +1,36 @@
-// Simple image loader
-// supported file format: PNG(use fpng), JPEG(use stb_image), OpenEXR(use tinyexr), TIFF(use tinydng)  
+// Simple audio loader
+// supported file format: WAV, MP3  
 #pragma once
 
 #include <cstddef>
 #include <string>
 #include <vector>
 
 #include "tinyusdz.hh"
 
 #include "nonstd/expected.hpp"
 
 namespace tinyusdz {
-namespace image {
+namespace audio {
 
-struct ImageResult {
-  Image image;
+struct AudioResult {
+  //Image image;
   std::string warning;
 };
 
 ///
 /// @param[in] filename Input filename(or URI)
 /// @return ImageResult or error message(std::string)
 ///
-nonstd::expected<ImageResult, std::string> LoadImageFromFile(const std::string &filename);
+nonstd::expected<AudioResult, std::string> LoadAudioFromFile(const std::string &filename);
 
 ///
 /// @param[in] addr Memory address
 /// @param[in] datasize Data size(in bytes)
 /// @param[in] uri Input URI(or filename) as a hint. This is used only in error message.
 /// @return ImageResult or error message(std::string)
 ///
-nonstd::expected<ImageResult, std::string> LoadImageFromMemory(const uint8_t *addr, const size_t datasize, const std::string &uri);
+nonstd::expected<AudioResult, std::string> LoadAudioFromMemory(const uint8_t *addr, const size_t datasize, const std::string &uri);
 
-} // namespace image
+} // namespace audio
 } // namespace tinyusdz
```

### Comparing `tinyusdz-0.8.0rc0/src/image-types.hh` & `tinyusdz-0.8.0rc1/src/image-types.hh`

 * *Files 11% similar despite different names*

```diff
@@ -25,21 +25,30 @@
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 #pragma once
 
 namespace tinyusdz {
 
 // Simple image class.
-// No colorspace conversion will be applied when decoding image data(e.g. from
-// .jpg, .png).
+// No colorspace conversion will be applied when decoding image data
+// (e.g. from .jpg, .png).
 struct Image {
+  enum class PixelFormat {
+    UInt, // LDR and HDR image
+    Int, // For normal/displacement map
+    Float // HDR image
+    // TODO
+    // Half
+  };
+   
   std::string uri;  // filename or uri;
 
   int width{-1};     // -1 = invalid
   int height{-1};    // -1 = invalid
   int channels{-1};  // Image channels. 3=RGB, 4=RGBA. -1 = invalid
-  int bpp{-1};       // bits per pixel. 8=LDR, 16=HDR
-
+  int bpp{-1};       // bits per pixel. 8=LDR, 16,32=HDR
+  PixelFormat format{PixelFormat::UInt};
+  
   std::vector<uint8_t> data; // Raw data.
 };
 
 } // namespace tinyusdz
```

### Comparing `tinyusdz-0.8.0rc0/src/image-writer.hh` & `tinyusdz-0.8.0rc1/src/image-writer.hh`

 * *Files 18% similar despite different names*

```diff
@@ -1,27 +1,36 @@
 // Simple image writer
 // supported file format: PNG(use fpng), JPEG(use stb_image), OpenEXR(use
-// tinyexr), TIFF(use tinydng)
+// tinyexr), TIFF/DNG(use tinydng)
 #pragma once
 
 #include <cstddef>
 #include <string>
 #include <vector>
 
 #include "nonstd/expected.hpp"
 #include "tinyusdz.hh"
 
 namespace tinyusdz {
 namespace image {
 
-enum class WriteImageFormat { Autodetect, PNG, JPEG, EXR, TIFF };
+//
+// Autodetect = determine file format using filename or Image's pixelformat +
+// bpp.
+//
+enum class WriteImageFormat { Autodetect, BMP, PNG, JPEG, EXR, TIFF, DNG };
 
 struct WriteOption {
   WriteImageFormat format{WriteImageFormat::Autodetect};
   bool half{false};  // Use half float for EXR
+
+  // When non-zero value is set, prefer this bitdepth than Image's bpp.
+  // Can specify 10, 12 and 14 for DNG when writing 16bit input image as 10, 12 and 14bit respectively.
+  int bitdepth{
+      0};  
 };
 
 ///
 /// @param[in] filename Output filename
 /// @param[in] image Image data
 /// @param[in] option Image write option(optional)
 ///
```

### Comparing `tinyusdz-0.8.0rc0/src/integerCoding.cpp` & `tinyusdz-0.8.0rc1/src/integerCoding.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/integerCoding.h` & `tinyusdz-0.8.0rc1/src/integerCoding.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/io-util.cc` & `tinyusdz-0.8.0rc1/src/io-util.cc`

 * *Files 20% similar despite different names*

```diff
@@ -40,27 +40,50 @@
 #else
 
 // Assume Posix
 #include <wordexp.h>
 
 #endif
 
+
 #endif // _WIN32
 
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Weverything"
+#endif
+
+#if !defined(__wasi__)
+#include "external/filesystem/include/ghc/filesystem.hpp"
+#include "external/glob/single_include/glob/glob.hpp"
+#endif
+
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
 #include "io-util.hh"
 
 namespace tinyusdz {
 namespace io {
 
 #ifdef TINYUSDZ_ANDROID_LOAD_FROM_ASSETS
 AAssetManager *asset_manager = nullptr;
 #endif
 
 
-std::string ExpandFilePath(const std::string &filepath, void *) {
+std::string ExpandFilePath(const std::string &_filepath, void *) {
+
+  std::string filepath = _filepath;
+  if (filepath.size() > 2048) {
+    // file path too large.
+    // TODO: Report warn.
+    filepath.resize(2048);
+  }
+
 #ifdef _WIN32
   // Assume input `filepath` is encoded in UTF-8
   std::wstring wfilepath = UTF8ToWchar(filepath);
   DWORD wlen = ExpandEnvironmentStringsW(wfilepath.c_str(), nullptr, 0);
   wchar_t *wstr = new wchar_t[wlen];
   ExpandEnvironmentStringsW(wfilepath.c_str(), wstr, wlen);
 
@@ -81,15 +104,17 @@
   if (filepath.empty()) {
     return "";
   }
 
   // Quote the string to keep any spaces in filepath intact.
   std::string quoted_path = "\"" + filepath + "\"";
   // char** w;
-  int ret = wordexp(quoted_path.c_str(), &p, 0);
+  // TODO: wordexp() is a awful API. Implement our own file path expansion routine.
+  // Set NOCMD for security.
+  int ret = wordexp(quoted_path.c_str(), &p, WRDE_NOCMD);
   if (ret) {
     // err
     s = filepath;
     return s;
   }
 
   // Use first element only.
@@ -213,17 +238,106 @@
   f.read(reinterpret_cast<char *>(&out->at(0)),
          static_cast<std::streamsize>(sz));
 
   return true;
 #endif
 }
 
-#if 0 // not used at this momemnt
-bool WriteWholeFile(std::string *err, const std::string &filepath,
-                    const std::vector<unsigned char> &contents, void *) {
+bool ReadFileHeader(std::vector<uint8_t> *out, std::string *err,
+                   const std::string &filepath, uint32_t max_read_bytes, void *userdata) {
+  (void)userdata;
+
+  // hard limit to 1MB.
+  max_read_bytes = (std::max)(1u, (std::min)(uint32_t(1024*1024), max_read_bytes));
+
+#ifdef TINYUSDZ_ANDROID_LOAD_FROM_ASSETS
+  if (tinyusdz::io::asset_manager) {
+    AAsset *asset = AAssetManager_open(asset_manager, filepath.c_str(),
+                                       AASSET_MODE_STREAMING);
+    if (!asset) {
+      if (err) {
+        (*err) += "File open error(from AssestManager) : " + filepath + "\n";
+      }
+      return false;
+    }
+    size_t size = AAsset_getLength(asset);
+    if (size == 0) {
+      if (err) {
+        (*err) += "Invalid file size : " + filepath +
+                  " (does the path point to a directory?)";
+      }
+      return false;
+    }
+
+    size = (std::min)(size_t(max_read_bytes), size);
+    out->resize(size);
+    AAsset_read(asset, reinterpret_cast<char *>(&out->at(0)), size);
+    AAsset_close(asset);
+    return true;
+  } else {
+    if (err) {
+      (*err) += "No asset manager specified : " + filepath + "\n";
+    }
+    return false;
+  }
+
+#else
+#ifdef _WIN32
+#if defined(__GLIBCXX__)  // mingw
+  int file_descriptor =
+      _wopen(UTF8ToWchar(filepath).c_str(), _O_RDONLY | _O_BINARY);
+  __gnu_cxx::stdio_filebuf<char> wfile_buf(file_descriptor, std::ios_base::in);
+  std::istream f(&wfile_buf);
+#elif defined(_MSC_VER) || defined(_LIBCPP_VERSION)
+  // For libcxx, assume _LIBCPP_HAS_OPEN_WITH_WCHAR is defined to accept
+  // `wchar_t *`
+  std::ifstream f(UTF8ToWchar(filepath).c_str(), std::ifstream::binary);
+#else
+  // Unknown compiler/runtime
+  std::ifstream f(filepath.c_str(), std::ifstream::binary);
+#endif
+#else
+  std::ifstream f(filepath.c_str(), std::ifstream::binary);
+#endif
+  if (!f) {
+    if (err) {
+      (*err) += "File does not exit or open error : " + filepath + "\n";
+    }
+    return false;
+  }
+
+  f.seekg(0, f.end);
+  size_t sz = static_cast<size_t>(f.tellg());
+  f.seekg(0, f.beg);
+
+  if (int64_t(sz) < 0) {
+    if (err) {
+      (*err) += "Invalid file size : " + filepath +
+                " (does the path point to a directory?)";
+    }
+    return false;
+  } else if (sz == 0) {
+    if (err) {
+      (*err) += "File is empty : " + filepath + "\n";
+    }
+    return false;
+  }
+
+  sz = (std::min)(size_t(max_read_bytes), sz);
+
+  out->resize(sz);
+  f.read(reinterpret_cast<char *>(&out->at(0)),
+         static_cast<std::streamsize>(sz));
+
+  return true;
+#endif
+}
+
+bool WriteWholeFile(const std::string &filepath,
+                    const unsigned char *contents, size_t content_bytes, std::string *err) {
 #ifdef _WIN32
 #if defined(__GLIBCXX__)  // mingw
   int file_descriptor = _wopen(UTF8ToWchar(filepath).c_str(),
                                _O_CREAT | _O_WRONLY | _O_TRUNC | _O_BINARY);
   __gnu_cxx::stdio_filebuf<char> wfile_buf(
       file_descriptor, std::ios_base::out | std::ios_base::binary);
   std::ostream f(&wfile_buf);
@@ -238,43 +352,93 @@
   if (!f) {
     if (err) {
       (*err) += "File open error for writing : " + filepath + "\n";
     }
     return false;
   }
 
-  f.write(reinterpret_cast<const char *>(&contents.at(0)),
-          static_cast<std::streamsize>(contents.size()));
+  f.write(reinterpret_cast<const char *>(contents),
+          static_cast<std::streamsize>(content_bytes));
   if (!f) {
     if (err) {
       (*err) += "File write error: " + filepath + "\n";
     }
     return false;
   }
 
   return true;
 }
+
+#ifdef _WIN32
+bool WriteWholeFile(const std::wstring &filepath,
+                    const unsigned char *contents, size_t content_bytes, std::string *err) {
+#if defined(__GLIBCXX__)  // mingw
+  int file_descriptor = _wopen(filepath.c_str(),
+                               _O_CREAT | _O_WRONLY | _O_TRUNC | _O_BINARY);
+  __gnu_cxx::stdio_filebuf<char> wfile_buf(
+      file_descriptor, std::ios_base::out | std::ios_base::binary);
+  std::ostream f(&wfile_buf);
+#elif defined(_MSC_VER) || defined(_LIBCPP_VERSION)
+  // MSVC extension allow wstrng as an argument.
+  std::ofstream f(filepath.c_str(), std::ofstream::binary);
+#else  // other C++ compiler for win32?
+#error "Unsupporte platform"
+#endif
+
+  if (!f) {
+    if (err) {
+      // This would print garbage character...
+      // FIXME: First create string in wchar, then convert to wstring?
+      (*err) += "File open error for writing : " + WcharToUTF8(filepath) + "\n";
+    }
+    return false;
+  }
+
+  f.write(reinterpret_cast<const char *>(contents),
+          static_cast<std::streamsize>(content_bytes));
+  if (!f) {
+    if (err) {
+      (*err) += "File write error: " + WcharToUTF8(filepath) + "\n";
+    }
+    return false;
+  }
+
+  return true;
+}
 #endif
 
 std::string GetBaseDir(const std::string &filepath) {
   if (filepath.find_last_of("/\\") != std::string::npos)
     return filepath.substr(0, filepath.find_last_of("/\\"));
   return "";
 }
 
+std::string GetFileExtension(const std::string &FileName) {
+  if (FileName.find_last_of(".") != std::string::npos)
+    return FileName.substr(FileName.find_last_of(".") + 1);
+  return "";
+}
+
+std::string GetBaseFilename(const std::string &filepath) {
+  auto idx = filepath.find_last_of("/\\");
+  if (idx != std::string::npos)
+    return filepath.substr(idx + 1);
+  return filepath;
+}
+
 bool IsAbsPath(const std::string &filename) {
   if (filename.size() > 0) {
     if (filename[0] == '/') {
       return true;
     }
   }
 
   // UNC path?
   if (filename.size() > 2) {
-    if ((filename[1] == '\\') && (filename[1] == '\\')) {
+    if ((filename[0] == '\\') && (filename[1] == '\\')) {
       return true;
     }
   }
 
   // TODO: Windows drive path(e.g. C:\, D:\, ...)
 
   return false;
@@ -290,14 +454,28 @@
       return dir + std::string("/") + filename;
     } else {
       return dir + filename;
     }
   }
 }
 
+bool USDFileExists(const std::string &fpath) {
+  size_t read_len = 9; // USD file must be at least 9 bytes or more.
+
+  std::string err;
+  std::vector<uint8_t> data;
+
+  if (!ReadFileHeader(&data, &err, fpath, uint32_t(read_len))) {
+    return false;
+  }
+
+  return true;
+
+}
+
 bool IsUDIMPath(const std::string &path)
 {
   return SplitUDIMPath(path, nullptr, nullptr);
 }
 
 bool SplitUDIMPath(const std::string &path, std::string *pre, std::string *post)
 {
@@ -325,9 +503,75 @@
   if (post) {
     (*post) = std::string(re, path.end());
   }
 
   return true;
 }
 
+bool FileExists(const std::string &filepath, void *userdata) {
+  (void)userdata;
+
+  bool ret{false};
+#ifdef TINYUSDZ_ANDROID_LOAD_FROM_ASSETS
+  if (asset_manager) {
+    AAsset *asset = AAssetManager_open(asset_manager, abs_filename.c_str(),
+                                       AASSET_MODE_STREAMING);
+    if (!asset) {
+      return false;
+    }
+    AAsset_close(asset);
+    ret = true;
+  } else {
+    return false;
+  }
+#else
+#ifdef _WIN32
+#if defined(_MSC_VER) || defined(__GLIBCXX__) || defined(_LIBCPP_VERSION)
+  FILE *fp = nullptr;
+  errno_t err = _wfopen_s(&fp, UTF8ToWchar(filepath).c_str(), L"rb");
+  if (err != 0) {
+    return false;
+  }
+#else
+  FILE *fp = nullptr;
+  errno_t err = fopen_s(&fp, filepath.c_str(), "rb");
+  if (err != 0) {
+    return false;
+  }
+#endif
+
+#else
+  FILE *fp = fopen(filepath.c_str(), "rb");
+#endif
+  if (fp) {
+    ret = true;
+    fclose(fp);
+  } else {
+    ret = false;
+  }
+#endif
+
+  return ret;
+}
+
+
+std::string FindFile(const std::string &filename, const std::vector<std::string> &search_paths) {
+  // TODO: Use ghc filesystem?
+
+  if (filename.empty()) {
+    return filename;
+  }
+
+  for (size_t i = 0; i < search_paths.size(); i++) {
+    std::string absPath =
+        io::ExpandFilePath(io::JoinPath(search_paths[i], filename), /* userdata */nullptr);
+    if (io::FileExists(absPath, /* userdata */nullptr)) {
+      return absPath;
+    }
+  }
+
+  return std::string();
+
+}
+
 } // namespace io
 } // namespace tinyusdz
```

### Comparing `tinyusdz-0.8.0rc0/src/lz4-compression.cc` & `tinyusdz-0.8.0rc1/src/lz4-compression.cc`

 * *Files 19% similar despite different names*

```diff
@@ -1,22 +1,28 @@
 #ifdef _MSC_VER
 #ifndef NOMINMAX
 #define NOMINMAX
 #endif
 #endif 
 
+//
+#include <cstring>
+#include <cstdlib>
+#include <memory>
+#include <algorithm>
+#include <iostream>
+
+//
+
 /* Suppress DEPRECATE macro warnings */
 #define LZ4_DISABLE_DEPRECATE_WARNINGS
 
 #include "lz4-compression.hh"
+#include "common-macros.inc"
 
-#include <cstring>
-#include <cstdlib>
-#include <memory>
-#include <algorithm>
 
 
 
 // LZ4Compression based on USD's TfFastCompression class
 
 //
 // Copyright 2017 Pixar
@@ -38,17 +44,21 @@
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the Apache License with the above modification is
 // distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 // KIND, either express or implied. See the Apache License for the specific
 // language governing permissions and limitations under the Apache License.
 //
 
-#include "pxrLZ4/lz4.h"
-
-using namespace pxr_lz4;
+#if 0
+//#include "pxrLZ4/lz4.h"
+//using namespace pxr_lz4;
+#else
+// TinyUSDZ : Use orignal lz4.
+#include "lz4/lz4.h"
+#endif
 
 namespace tinyusdz {
 
 size_t LZ4Compression::GetMaxInputSize() {
   return 127 * static_cast<size_t>(LZ4_MAX_INPUT_SIZE);
 }
 
@@ -114,64 +124,134 @@
       writeChunk(input, compressed, partChunkSz);
     }
   }
 
   return size_t(compressed - origCompressed);
 }
 
-size_t LZ4Compression::DecompressFromBuffer(char const *compressed,
-                                               char *output,
+size_t LZ4Compression::DecompressFromBuffer(char const *compressedPtr,
+                                               char *outputPtr,
                                                size_t compressedSize,
                                                size_t maxOutputSize,
                                                std::string *err) {
   if (compressedSize <= 1) {
       if (err) {
         (*err) =
             "Invalid compressedSize.\n";
       }
     return 0;
   }
 
   // Check first byte for # chunks.
-  int nChunks = *compressed++;
+  int nChunks = *compressedPtr++;
+  if (nChunks > 127) {
+    if (err) {
+      (*err) =
+          "Too many chunks in LZ4 compressed data.\n";
+    }
+    return 0;
+  }
+
+  DCOUT("compressedSize = " << compressedSize);
+  DCOUT("maxOutputSize = " << maxOutputSize);
+  DCOUT("nChunks = " << nChunks);
+  //std::cout << "compressedSize = " << compressedSize << "\n";
+  //std::cout << "maxOutputSize = " << maxOutputSize << "\n";
+  //std::cout << "nChunks = " << nChunks << "\n";
+
+  size_t consumedCompressedSize = 1;
+
+  if (maxOutputSize < LZ4_MAX_INPUT_SIZE) {
+    // nChunks must be 0 for < LZ4_MAX_INPUT_SIZE
+    if (nChunks != 0) {
+      if (err) {
+        (*err) = "Corrupted LZ4 compressed data.\n";
+      }
+      return 0;
+    }
+  }
+
   if (nChunks == 0) {
     // Just one.
-    int nDecompressed = LZ4_decompress_safe(compressed, output,
+    int nDecompressed = LZ4_decompress_safe(compressedPtr, outputPtr,
                                             int(compressedSize - 1), int(maxOutputSize));
     if (nDecompressed < 0) {
       if (err) {
         (*err) =
             "Failed to decompress data, possibly corrupt? "
             "LZ4 error code: " +
             std::to_string(nDecompressed) + "\n";
       }
       return 0;
     }
     return size_t(nDecompressed);
   } else {
     // Do each chunk.
     size_t totalDecompressed = 0;
-    for (int i = 0; i != nChunks; ++i) {
+    for (int i = 0; i < nChunks; ++i) {
       int32_t chunkSize = 0;
-      memcpy(&chunkSize, compressed, sizeof(chunkSize));
-      compressed += sizeof(chunkSize);
+      if (consumedCompressedSize + sizeof(chunkSize) > compressedSize) {
+        if (err) {
+           (*err) += "Corrupted chunk data.";
+        }
+        return 0;
+          
+      }
+
+      memcpy(&chunkSize, compressedPtr, sizeof(chunkSize));
+
+      if (chunkSize > LZ4_MAX_INPUT_SIZE) {
+        if (err) {
+           (*err) += "ChunkSize exceeds LZ4_MAX_INPUT_SIZE.\n";
+        }
+        return 0;
+      }
+      if (chunkSize <= 0) {
+        if (err) {
+           (*err) += "Invalid ChunkSize.\n";
+        }
+        return 0;
+      }
+
+      DCOUT("chunk[" << i << "] size = " << chunkSize);
+
+      //std::cout << "chunkSize = " << chunkSize << "\n";
+      consumedCompressedSize += sizeof(chunkSize);
+      //std::cout << "consumedCompressedSize = " << consumedCompressedSize << "\n";
+      //std::cout << "compressedSize = " << compressedSize << "\n";
+      if (consumedCompressedSize > compressedSize) {
+        if (err) {
+           (*err) += "Total chunk size exceeds input compressedSize.\n";
+        }
+        return 0;
+      }
+
+      compressedPtr += sizeof(chunkSize);
       int nDecompressed = LZ4_decompress_safe(
-          compressed, output, chunkSize,
+          compressedPtr, outputPtr, chunkSize,
           int(std::min<size_t>(LZ4_MAX_INPUT_SIZE, maxOutputSize)));
-      if (nDecompressed < 0) {
+      if (nDecompressed <= 0) {
         if (err) {
           (*err) =
               "Failed to decompress data, possibly corrupt? "
               "LZ4 error code: " +
               std::to_string(nDecompressed) + "\n";
         }
         return 0;
       }
-      compressed += chunkSize;
-      output += nDecompressed;
+      //std::cout << "nDecompressed = " << nDecompressed << "\n";
+      if (nDecompressed > maxOutputSize) {
+        if (err) {
+          (*err) =
+              "Failed to decompress data, possibly corrupt?\n";
+        }
+        return 0;
+      }
+      compressedPtr += chunkSize;
+      outputPtr += nDecompressed;
       maxOutputSize -= size_t(nDecompressed);
       totalDecompressed += size_t(nDecompressed);
     }
     return totalDecompressed;
   }
   // unreachable.
 }
```

### Comparing `tinyusdz-0.8.0rc0/src/lz4-compression.hh` & `tinyusdz-0.8.0rc1/src/lz4-compression.hh`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/nonstd/expected.hpp` & `tinyusdz-0.8.0rc1/src/nonstd/expected.hpp`

 * *Files 0% similar despite different names*

```diff
@@ -69,14 +69,21 @@
 
 #ifndef  nsel_P0323R
 # define nsel_P0323R  7
 #endif
 
 // Control presence of C++ exception handling (try and auto discover):
 
+// TinyUSDZ: Disable exception by default
+#ifdef nsel_CONFIG_NO_EXCEPTIONS
+#undef nsel_CONFIG_NO_EXCEPTIONS
+#endif
+
+#define nsel_CONFIG_NO_EXCEPTIONS  1
+
 #ifndef nsel_CONFIG_NO_EXCEPTIONS
 # if _MSC_VER
 #  include <cstddef>    // for _HAS_EXCEPTIONS
 # endif
 # if defined(__cpp_exceptions) || defined(__EXCEPTIONS) || (_HAS_EXCEPTIONS)
 #  define nsel_CONFIG_NO_EXCEPTIONS  0
 # else
```

### Comparing `tinyusdz-0.8.0rc0/src/nonstd/optional.hpp` & `tinyusdz-0.8.0rc1/src/nonstd/optional.hpp`

 * *Files 1% similar despite different names*

```diff
@@ -16,20 +16,27 @@
 #define optional_lite_PATCH  0
 
 #define optional_lite_VERSION  optional_STRINGIFY(optional_lite_MAJOR) "." optional_STRINGIFY(optional_lite_MINOR) "." optional_STRINGIFY(optional_lite_PATCH)
 
 #define optional_STRINGIFY(  x )  optional_STRINGIFY_( x )
 #define optional_STRINGIFY_( x )  #x
 
+
 // optional-lite configuration:
 
 #define optional_OPTIONAL_DEFAULT  0
 #define optional_OPTIONAL_NONSTD   1
 #define optional_OPTIONAL_STD      2
 
+// TinyUSDZ mod. Force use nonstd implementation even on C++17 to avoid possible linkage issue.
+#if defined( optional_CONFIG_SELECT_OPTIONAL )
+#undef optional_CONFIG_SELECT_OPTIONAL
+#endif
+#define optional_CONFIG_SELECT_OPTIONAL (optional_OPTIONAL_NONSTD)
+
 // tweak header support:
 
 #ifdef __has_include
 # if __has_include(<nonstd/optional.tweak.hpp>)
 #  include <nonstd/optional.tweak.hpp>
 # endif
 #define optional_HAVE_TWEAK_HEADER  1
@@ -42,14 +49,20 @@
 
 #if !defined( optional_CONFIG_SELECT_OPTIONAL )
 # define optional_CONFIG_SELECT_OPTIONAL  ( optional_HAVE_STD_OPTIONAL ? optional_OPTIONAL_STD : optional_OPTIONAL_NONSTD )
 #endif
 
 // Control presence of exception handling (try and auto discover):
 
+// TinyUSDZ mod. Force disable exception.
+#if defined( optional_CONFIG_NO_EXCEPTIONS )
+#undef optional_CONFIG_NO_EXCEPTIONS
+#define optional_CONFIG_NO_EXCEPTIONS 1
+#endif
+
 #ifndef optional_CONFIG_NO_EXCEPTIONS
 # if defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)
 #  define optional_CONFIG_NO_EXCEPTIONS  0
 # else
 #  define optional_CONFIG_NO_EXCEPTIONS  1
 # endif
 #endif
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/CMakeLists.txt` & `tinyusdz-0.8.0rc1/src/osd/CMakeLists.txt`

 * *Files 10% similar despite different names*

```diff
@@ -18,17 +18,17 @@
 #   Unless required by applicable law or agreed to in writing, software
 #   distributed under the Apache License with the above modification is
 #   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 #   KIND, either express or implied. See the Apache License for the specific
 #   language governing permissions and limitations under the Apache License.
 #
 
-project(OpenSubdiv)
+cmake_minimum_required(VERSION 3.12)
 
-cmake_minimum_required(VERSION 2.8.6)
+project(OpenSubdiv)
 
 # Turn on folder support
 set_property(GLOBAL PROPERTY USE_FOLDERS ON)
 
 #-------------------------------------------------------------------------------
 # Obtain OpenSubdiv API version from version.h file
 if(EXISTS "${OpenSubdiv_SOURCE_DIR}/opensubdiv/version.h")
@@ -49,18 +49,25 @@
 
     add_definitions(
         -DOPENSUBDIV_VERSION_STRING="${OSD_SONAME}"
     )
 
 #-------------------------------------------------------------------------------
 
-message(STATUS "Compiling ${CMAKE_PROJECT_NAME} version ${OpenSubdiv_VERSION}")
+message(STATUS "Compiling ${PROJECT_NAME} version ${OpenSubdiv_VERSION}")
 message(STATUS "Using cmake version ${CMAKE_VERSION}")
 
 #-------------------------------------------------------------------------------
+# Determine if the project is built as a subproject (using add_subdirectory)
+# or if it is the main project.
+set(MAIN_PROJECT OFF)
+if (CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
+    set(MAIN_PROJECT ON)
+endif()
+
 # Specify the default install path
 if (NOT DEFINED CMAKE_INSTALL_PREFIX)
     SET( CMAKE_INSTALL_PREFIX "${PROJECT_BINARY_DIR}/" )
 endif()
 
 if (NOT DEFINED CMAKE_INCDIR_BASE)
     set( CMAKE_INCDIR_BASE include/opensubdiv )
@@ -93,27 +100,29 @@
 endif()
 
 # Allow install path to be overridden for cross-compile builds
 if(LIBRARY_OUTPUT_PATH_ROOT)
     SET( CMAKE_INSTALL_PREFIX "${LIBRARY_OUTPUT_PATH_ROOT}/" )
 endif()
 
-# Set the directory where the executables will be stored.
-set(EXECUTABLE_OUTPUT_PATH
-    "${PROJECT_BINARY_DIR}/bin"
-    CACHE PATH
-    "Directory where executables will be stored"
-)
+if (MAIN_PROJECT)
+    # Set the directory where the executables will be stored.
+    set(EXECUTABLE_OUTPUT_PATH
+        "${PROJECT_BINARY_DIR}/bin"
+        CACHE PATH
+        "Directory where executables will be stored"
+    )
 
-# Set the directory where the libraries will be stored.
-set(LIBRARY_OUTPUT_PATH
-    "${PROJECT_BINARY_DIR}/lib"
-    CACHE PATH
-    "Directory where all libraries will be stored"
-)
+    # Set the directory where the libraries will be stored.
+    set(LIBRARY_OUTPUT_PATH
+        "${PROJECT_BINARY_DIR}/lib"
+        CACHE PATH
+        "Directory where all libraries will be stored"
+    )
+endif()
 
 # Specify the list of directories to search for cmake modules.
 set(CMAKE_MODULE_PATH
     "${CMAKE_CURRENT_SOURCE_DIR}/cmake"
 )
 
 #-------------------------------------------------------------------------------
@@ -214,16 +223,15 @@
 elseif(MSVC)
 
     # Turn on all warnings
     list(APPEND OSD_COMPILER_FLAGS /Wall)
 
     list(APPEND OSD_COMPILER_FLAGS
                     /W3     # Use warning level recommended for production purposes.
-                    # Disable since OSD fails to compile on VS2019.
-                    #/WX     # Treat all compiler warnings as errors.
+                    /WX     # Treat all compiler warnings as errors.
 
                     # warning C4005: macro redefinition
                     /wd4005
 
                     # these warnings are being triggered from inside VC's header files
                     # warning C4350: behavior change: 'member1' called instead of 'member2'
                     /wd4350
@@ -299,22 +307,22 @@
 option(NO_DOC "Disable documentation build" OFF)
 option(NO_OMP "Disable OpenMP backend" OFF)
 option(NO_TBB "Disable TBB backend" OFF)
 option(NO_CUDA "Disable CUDA backend" OFF)
 option(NO_OPENCL "Disable OpenCL backend" OFF)
 option(NO_CLEW "Disable CLEW wrapper library" OFF)
 option(NO_OPENGL "Disable OpenGL support")
-option(NO_GLES "Disable GLES support" ON)
 option(NO_METAL "Disable Metal support" OFF)
 option(NO_DX "Disable DirectX support")
 option(NO_TESTS "Disable all tests")
 option(NO_GLTESTS "Disable GL tests")
 option(NO_GLEW "Disable use of GLEW" ON)
 option(NO_GLFW "Disable components depending on GLFW" OFF)
 option(NO_GLFW_X11 "Disable GLFW components depending on X11" OFF)
+option(NO_MACOS_FRAMEWORK "Disable generation of framework on macOS" OFF)
 
 option(OPENSUBDIV_GREGORY_EVAL_TRUE_DERIVATIVES "Enable true derivative evaluation for Gregory basis patches" OFF)
 
 option(BUILD_SHARED_LIBS "Build shared libraries" ON)
 
 # Save the current value of BUILD_SHARED_LIBS and restore it after
 # processing Find* modules, since some of the Find* modules invoked
@@ -329,15 +337,15 @@
 endif()
 if(NOT NO_TBB)
     find_package(TBB 4.0)
 endif()
 if (NOT NO_OPENGL)
     find_package(OpenGL)
 endif()
-#find_package(OpenGLES)
+find_package(OpenGLES)
 if(NOT NO_OPENCL)
     if(NOT NO_CLEW)
         find_package(CLEW)
     endif()
     if (NOT CLEW_FOUND)
         find_package(OpenCL 1.1)
     else()
@@ -353,17 +361,15 @@
 if(NOT NO_PTEX)
    find_package(PTex 2.0)
    find_package(ZLIB 1.2)
 endif()
 if(APPLE AND NOT NO_METAL)
     find_package(Metal)
 endif()
-
-# Win32 may report OPENGL_FOUND even if `NO_OPENGL` is set
-if (OPENGL_FOUND AND NOT NO_OPENGL AND NOT IOS)
+if (OPENGL_FOUND AND NOT IOS)
     add_definitions(
         -DOPENSUBDIV_HAS_OPENGL
     )
     if (NOT NO_GLEW)
         if (APPLE)
             find_package(GLEW)
         else()
@@ -384,14 +390,17 @@
 if (NOT NO_DOC)
     find_package(Doxygen 1.8.4)
     find_package(Docutils 0.9)
 else()
     set(DOXYGEN_EXECUTABLE )
 endif()
 
+# Python is used optionally to process source and documentation source files.
+find_package(Python COMPONENTS Interpreter)
+
 set(BUILD_SHARED_LIBS "${build_shared_libs}")
 
 # Warn about missing dependencies that will cause parts of OpenSubdiv to be
 # disabled.  Also, add preprocessor defines that can be used in the source
 # code to determine if a specific dependency is present or not.
 
 if(OPENMP_FOUND)
@@ -468,24 +477,26 @@
 
     osd_detect_gl_version(${GLEW_INCLUDE_DIR}/GL/glew.h)
     set(OPENGL_LOADER_INCLUDE_DIRS
         ${GLEW_INCLUDE_DIR}
         ${PROJECT_SOURCE_DIR}/glLoader)
     set(OPENGL_LOADER_LIBRARIES
         ${GLEW_LIBRARY}
-        ${OPENGL_gl_LIBRARY})
+        ${OPENGL_gl_LIBRARY}
+        ${CMAKE_DL_LIBS})
 
 elseif(OPENGL_FOUND)
 
     osd_detect_gl_version(${PROJECT_SOURCE_DIR}/glLoader/glApi.h)
     set(OPENGL_LOADER_INCLUDE_DIRS
         ${OPENGL_INCLUDE_DIR}
         ${PROJECT_SOURCE_DIR}/glLoader)
     set(OPENGL_LOADER_LIBRARIES
-        ${OPENGL_gl_LIBRARY})
+        ${OPENGL_gl_LIBRARY}
+        ${CMAKE_DL_LIBS})
 
 endif()
 
 # note : (GLSL transform feedback kernels require GL 4.2)
 if(OPENGL_4_2_FOUND)
     add_definitions(
         -DOPENSUBDIV_HAS_GLSL_TRANSFORM_FEEDBACK
@@ -511,15 +522,15 @@
             "OpenGL 4.3 was not found : support for GLSL compute shader kernels "
             "will be disabled in Osd.  If you have an OpenGL SDK installed "
             "(version 4.3 or above), please refer to the FindOpenGL.cmake "
             "shared module in your cmake installation.")
     endif()
 endif()
 
-if(OPENGLES_FOUND AND NOT NO_GLES)
+if(OPENGLES_FOUND)
     add_definitions(
         -DOPENSUBDIV_HAS_OPENGLES
     )
     set(OSD_GPU TRUE)
 endif()
 
 if(OPENCL_FOUND)
@@ -700,42 +711,58 @@
 
             add_custom_target(${targetname} DEPENDS "${outfile}")
 
 
             list(APPEND headerfiles ${targetname} )
         endforeach()
 
-        add_dependencies( public_headers DEPENDS ${headerfiles} )
+        add_dependencies( public_headers ${headerfiles} )
     endif()
 endmacro()
 
 # Kernel Stringification
-# We want to use preprocessor include directives to include GLSL and OpenCL
+# We want to use preprocessor include directives to include GLSL, OpenCL, etc.
 # kernel source files in cpp files, but since the sources contain newline
 # characters we would need raw string literals from C++11 to do this directly.
-# To avoid depending on C++11 we instead use a small tool called "line_quote"
+# To avoid depending on C++11 we instead use a small tool called "stringify"
 # to generate source files that are suitable for direct inclusion.
+
+# We provide a Python implementation for configurability, e.g. to
+# use when cross compiling or building multi-architecture binaries.
+# We also provide a C++ binary implementation so that Python is not
+# required (for backward compatibility).
+if (OPENGL_FOUND OR OPENCL_FOUND OR DXSDK_FOUND OR METAL_FOUND)
+    if(Python_Interpreter_FOUND)
+        set(OSD_STRINGIFY_TOOL ${CMAKE_CURRENT_SOURCE_DIR}/tools/stringify/stringify.py)
+        set(OSD_STRINGIFY ${Python_EXECUTABLE} ${OSD_STRINGIFY_TOOL})
+    else()
+        set(OSD_STRINGIFY_TOOL stringify)
+        set(OSD_STRINGIFY ${OSD_STRINGIFY_TOOL})
+        set(OSD_USES_STRINGIFY_TOOL_BINARY TRUE)
+    endif()
+endif()
+
 function(osd_stringify src_files varname)
 
     set(inc_files "")
 
     foreach(src_file ${src_files})
 
-    string(REGEX REPLACE ".*[.](.*)" "\\1" extension "${src_file}")
+        string(REGEX REPLACE ".*[.](.*)" "\\1" extension "${src_file}")
 
         string(REGEX REPLACE "(.*)[.].*" "\\1.gen.h" inc_file "${src_file}")
         list(APPEND inc_files "${CMAKE_CURRENT_BINARY_DIR}/${inc_file}")
 
         add_custom_command(
             OUTPUT
                 "${CMAKE_CURRENT_BINARY_DIR}/${inc_file}"
             COMMAND
-                stringify "${CMAKE_CURRENT_SOURCE_DIR}/${src_file}" "${CMAKE_CURRENT_BINARY_DIR}/${inc_file}"
+                ${OSD_STRINGIFY} "${CMAKE_CURRENT_SOURCE_DIR}/${src_file}" "${CMAKE_CURRENT_BINARY_DIR}/${inc_file}"
             DEPENDS
-                stringify "${CMAKE_CURRENT_SOURCE_DIR}/${src_file}"
+                ${OSD_STRINGIFY_TOOL} "${CMAKE_CURRENT_SOURCE_DIR}/${src_file}"
         )
 
     endforeach()
     set(${varname} ${inc_files} PARENT_SCOPE)
 endfunction()
 
 # Macro wrapper for adding a non-cuda dependent executable
@@ -817,32 +844,68 @@
 # example: if you have already installed opensubdiv libs in this cmake setup,
 # set (OPENSUBDIV_INCLUDE_DIR ${CMAKE_INSTALL_PREFIX}/${CMAKE_INCDIR_BASE})
 
 if (NOT OPENSUBDIV_INCLUDE_DIR)
     set(OPENSUBDIV_INCLUDE_DIR "${PROJECT_SOURCE_DIR}")
 endif()
 
-#if (NOT NO_TESTS)
-#    enable_testing()
-#endif()
-#
-#if (NOT NO_OPENGL)
-#    add_subdirectory(glLoader)
-#endif()
+if (NOT NO_TESTS)
+    enable_testing()
+endif()
+
+if (NOT NO_OPENGL)
+    add_subdirectory(glLoader)
+endif()
+
+if (OSD_USES_STRINGIFY_TOOL_BINARY)
+    add_subdirectory(tools/stringify)
+endif()
 
 add_subdirectory(opensubdiv)
 
-#if (NOT ANDROID) # XXXdyu
-#    add_subdirectory(regression)
-#endif()
-
-#if (NOT NO_EXAMPLES)
-#    add_subdirectory(examples)
-#endif()
-#
-#if (NOT NO_TUTORIALS)
-#    add_subdirectory(tutorials)
-#endif()
-#
-#if (NOT NO_DOC)
-#    add_subdirectory(documentation)
-#endif()
+if (NOT ANDROID) # XXXdyu
+    add_subdirectory(regression)
+endif()
+
+if (NOT NO_EXAMPLES)
+    add_subdirectory(examples)
+endif()
+
+if (NOT NO_TUTORIALS)
+    add_subdirectory(tutorials)
+endif()
+
+if (NOT NO_DOC)
+    add_subdirectory(documentation)
+endif()
+
+if(CMAKE_VERSION VERSION_GREATER_EQUAL 3.0.2)
+    #
+    # CMake Config.
+    #
+    include(GNUInstallDirs)
+    include(CMakePackageConfigHelpers)
+
+    set(OPENSUBDIV_CONFIG_PATH "${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}")
+
+    configure_package_config_file(
+        opensubdiv-config.cmake.in
+        ${CMAKE_CURRENT_BINARY_DIR}/OpenSubdivConfig.cmake
+        INSTALL_DESTINATION ${OPENSUBDIV_CONFIG_PATH}
+    )
+    write_basic_package_version_file(
+        ${CMAKE_CURRENT_BINARY_DIR}/OpenSubdivConfigVersion.cmake
+        VERSION ${OSD_SONAME}
+        COMPATIBILITY SameMajorVersion
+    )
+
+    install(EXPORT opensubdiv-targets
+        NAMESPACE OpenSubdiv::
+        FILE OpenSubdivTargets.cmake
+        DESTINATION ${OPENSUBDIV_CONFIG_PATH})
+
+    install(FILES
+        ${CMAKE_CURRENT_BINARY_DIR}/OpenSubdivConfig.cmake
+        ${CMAKE_CURRENT_BINARY_DIR}/OpenSubdivConfigVersion.cmake
+        DESTINATION ${OPENSUBDIV_CONFIG_PATH}
+    )
+endif()
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/LICENSE.txt` & `tinyusdz-0.8.0rc1/src/osd/LICENSE.txt`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/CMakeLists.txt` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/CMakeLists.txt`

 * *Files 18% similar despite different names*

```diff
@@ -51,18 +51,14 @@
     if( TBB_FOUND )
         include_directories("${TBB_INCLUDE_DIR}")
         list(APPEND PLATFORM_CPU_LIBRARIES
             ${TBB_LIBRARIES}
         )
     endif()
 
-    if(OPENGL_FOUND OR OPENCL_FOUND OR DXSDK_FOUND OR METAL_FOUND)
-        add_subdirectory(tools/stringify)
-    endif()
-
     if( OPENGL_FOUND )
         include_directories(${OPENGL_LOADER_INCLUDE_DIRS})
         list(APPEND PLATFORM_GPU_LIBRARIES
             ${OPENGL_LOADER_LIBRARIES}
         )
         set(OPENGL_LOADER_OBJS $<TARGET_OBJECTS:glLoader_obj>)
     elseif( OPENGLES_FOUND )
@@ -106,14 +102,16 @@
 
     add_subdirectory(sdc)
 
     add_subdirectory(vtr)
 
     add_subdirectory(far)
 
+    add_subdirectory(bfr)
+
     add_subdirectory(osd)
 
     #---------------------------------------------------------------------------
 
     install( FILES version.h
         DESTINATION
             "${CMAKE_INCDIR_BASE}"
@@ -127,47 +125,53 @@
     # Build static libs ------------------------------------
     add_library(osd_static_cpu
         STATIC
         version.cpp
         $<TARGET_OBJECTS:sdc_obj>
         $<TARGET_OBJECTS:vtr_obj>
         $<TARGET_OBJECTS:far_obj>
+        $<TARGET_OBJECTS:bfr_obj>
         $<TARGET_OBJECTS:osd_cpu_obj>
     )
 
     set_target_properties(osd_static_cpu
         PROPERTIES
             OUTPUT_NAME osdCPU
+            EXPORT_NAME osdCPU_static
             CLEAN_DIRECT_OUTPUT 1
             FOLDER "opensubdiv"
     )
 
     target_link_libraries(osd_static_cpu
         ${PLATFORM_CPU_LIBRARIES}
     )
 
-    install( TARGETS osd_static_cpu DESTINATION "${CMAKE_LIBDIR_BASE}" )
+    install( TARGETS osd_static_cpu EXPORT opensubdiv-targets DESTINATION "${CMAKE_LIBDIR_BASE}" )
 
     if( OSD_GPU )
         # this macro uses FindCUDA.cmake to compile .cu kernel files
         # the target then adds the other obj dependencies and include files
         osd_add_possibly_cuda_library(osd_static_gpu "opensubdiv"
                 STATIC
                 version.cpp
                 $<TARGET_OBJECTS:osd_gpu_obj>
                 ${OPENGL_LOADER_OBJS}
                 ${CUDA_KERNEL_FILES}
         )
-        set_target_properties(osd_static_gpu PROPERTIES OUTPUT_NAME osdGPU CLEAN_DIRECT_OUTPUT 1)
+        set_target_properties(osd_static_gpu
+            PROPERTIES
+                OUTPUT_NAME osdGPU
+                EXPORT_NAME osdGPU_static
+                CLEAN_DIRECT_OUTPUT 1)
 
         target_link_libraries(osd_static_gpu
             ${PLATFORM_CPU_LIBRARIES} ${PLATFORM_GPU_LIBRARIES}
         )
 
-        install( TARGETS osd_static_gpu DESTINATION "${CMAKE_LIBDIR_BASE}" )
+        install( TARGETS osd_static_gpu EXPORT opensubdiv-targets DESTINATION "${CMAKE_LIBDIR_BASE}" )
     endif()
 
 
     # Build dynamic libs  ----------------------------------
     if (BUILD_SHARED_LIBS AND NOT WIN32 AND NOT IOS)
 
         # generate dynamic-link targets
@@ -175,37 +179,40 @@
         #---------------------------------------------------
         add_library(osd_dynamic_cpu
             SHARED
             version.cpp
             $<TARGET_OBJECTS:sdc_obj>
             $<TARGET_OBJECTS:vtr_obj>
             $<TARGET_OBJECTS:far_obj>
+            $<TARGET_OBJECTS:bfr_obj>
             $<TARGET_OBJECTS:osd_cpu_obj>
         )
 
         if (NOT ANDROID)
             set_target_properties(osd_dynamic_cpu
                 PROPERTIES
                     OUTPUT_NAME osdCPU
+                    EXPORT_NAME osdCPU
                     CLEAN_DIRECT_OUTPUT 1
                     SOVERSION ${OSD_SONAME}
                 )
         else()
             set_target_properties(osd_dynamic_cpu
                 PROPERTIES
                     OUTPUT_NAME osdCPU
+                    EXPORT_NAME osdCPU
                     CLEAN_DIRECT_OUTPUT 1
                 )
         endif()
 
         target_link_libraries(osd_dynamic_cpu
             ${PLATFORM_CPU_LIBRARIES}
         )
 
-        install( TARGETS osd_dynamic_cpu LIBRARY DESTINATION "${CMAKE_LIBDIR_BASE}" )
+        install( TARGETS osd_dynamic_cpu EXPORT opensubdiv-targets LIBRARY DESTINATION "${CMAKE_LIBDIR_BASE}" )
 
         #---------------------------------------------------
         if( OSD_GPU )
             osd_add_possibly_cuda_library(osd_dynamic_gpu "opensubdiv"
                 SHARED
                 version.cpp
                 $<TARGET_OBJECTS:osd_gpu_obj>
@@ -213,42 +220,45 @@
                 ${CUDA_KERNEL_FILES}
             )
 
             if (NOT ANDROID)
                 set_target_properties(osd_dynamic_gpu
                     PROPERTIES
                         OUTPUT_NAME osdGPU
+                        EXPORT_NAME osdGPU
                         CLEAN_DIRECT_OUTPUT 1
                         SOVERSION ${OSD_SONAME}
                     )
             else()
                 set_target_properties(osd_dynamic_gpu
                     PROPERTIES
                         OUTPUT_NAME osdGPU
+                        EXPORT_NAME osdGPU
                         CLEAN_DIRECT_OUTPUT 1
                     )
             endif()
 
             target_link_libraries(osd_dynamic_gpu
                 osd_dynamic_cpu
                 ${PLATFORM_CPU_LIBRARIES} ${PLATFORM_GPU_LIBRARIES}
             )
 
-            install( TARGETS osd_dynamic_gpu LIBRARY DESTINATION "${CMAKE_LIBDIR_BASE}" )
+            install( TARGETS osd_dynamic_gpu EXPORT opensubdiv-targets LIBRARY DESTINATION "${CMAKE_LIBDIR_BASE}" )
         endif()
 
     endif()
 
     # Build frameworks  ----------------------------------
-    if(APPLE)
-        get_directory_property(OSD_HEADER_FILES DIRECTORY ${CMAKE_SOURCE_DIR}/opensubdiv/osd DEFINITION PUBLIC_HEADER_FILES)
-        get_directory_property(FAR_HEADER_FILES DIRECTORY ${CMAKE_SOURCE_DIR}/opensubdiv/far DEFINITION PUBLIC_HEADER_FILES)
-        get_directory_property(SDC_HEADER_FILES DIRECTORY ${CMAKE_SOURCE_DIR}/opensubdiv/sdc DEFINITION PUBLIC_HEADER_FILES)
-        get_directory_property(HBR_HEADER_FILES DIRECTORY ${CMAKE_SOURCE_DIR}/opensubdiv/hbr DEFINITION PUBLIC_HEADER_FILES)
-        get_directory_property(VTR_HEADER_FILES DIRECTORY ${CMAKE_SOURCE_DIR}/opensubdiv/vtr DEFINITION PUBLIC_HEADER_FILES)
+    if(APPLE AND NOT NO_MACOS_FRAMEWORK)
+        get_directory_property(OSD_HEADER_FILES DIRECTORY ${PROJECT_SOURCE_DIR}/opensubdiv/osd DEFINITION PUBLIC_HEADER_FILES)
+        get_directory_property(FAR_HEADER_FILES DIRECTORY ${PROJECT_SOURCE_DIR}/opensubdiv/far DEFINITION PUBLIC_HEADER_FILES)
+        get_directory_property(SDC_HEADER_FILES DIRECTORY ${PROJECT_SOURCE_DIR}/opensubdiv/sdc DEFINITION PUBLIC_HEADER_FILES)
+        get_directory_property(HBR_HEADER_FILES DIRECTORY ${PROJECT_SOURCE_DIR}/opensubdiv/hbr DEFINITION PUBLIC_HEADER_FILES)
+        get_directory_property(VTR_HEADER_FILES DIRECTORY ${PROJECT_SOURCE_DIR}/opensubdiv/vtr DEFINITION PUBLIC_HEADER_FILES)
+        get_directory_property(BFR_HEADER_FILES DIRECTORY ${PROJECT_SOURCE_DIR}/opensubdiv/bfr DEFINITION PUBLIC_HEADER_FILES)
 
 
         foreach(file ${OSD_HEADER_FILES})
             list(APPEND PUBLIC_HEADER_FILES "osd/${file}")
         endforeach(file)
 
         foreach(file ${FAR_HEADER_FILES})
@@ -263,78 +273,99 @@
             list(APPEND PUBLIC_HEADER_FILES "hbr/${file}")
         endforeach(file)
 
         foreach(file ${VTR_HEADER_FILES})
             list(APPEND PUBLIC_HEADER_FILES "vtr/${file}")
         endforeach(file)
 
+        foreach(file ${BFR_HEADER_FILES})
+            list(APPEND PUBLIC_HEADER_FILES "bfr/${file}")
+        endforeach(file)
+
         list(APPEND PUBLIC_HEADER_FILES "version.h")
 
         #static framework
         add_library(osd_static_framework
             STATIC
             version.cpp
             $<TARGET_OBJECTS:sdc_obj>
             $<TARGET_OBJECTS:vtr_obj>
             $<TARGET_OBJECTS:far_obj>
+            $<TARGET_OBJECTS:bfr_obj>
             $<TARGET_OBJECTS:osd_cpu_obj>
             $<TARGET_OBJECTS:osd_gpu_obj>
             ${OPENGL_LOADER_OBJS}
         )
 
         set_target_properties(
             osd_static_framework
             PROPERTIES
             FRAMEWORK true
             INSTALL_NAME_DIR "@rpath/OpenSubdiv.framework/OpenSubdiv"
             INSTALL_RPATH "@executable_path/Frameworks;@loader_path/Frameworks"
-            OUTPUT_NAME OpenSubdiv
+            OUTPUT_NAME OpenSubdiv_static
+            EXPORT_NAME OpenSubdiv_static
             CLEAN_DIRECT_OUTPUT true
         )
 
         target_link_libraries(osd_static_framework
             ${PLATFORM_CPU_LIBRARIES} ${PLATFORM_GPU_LIBRARIES}
         )
 
-        install( TARGETS osd_static_framework
+        install( TARGETS osd_static_framework EXPORT opensubdiv-targets
              LIBRARY DESTINATION "${CMAKE_LIBDIR_BASE}"
              FRAMEWORK DESTINATION "${CMAKE_LIBDIR_BASE}"
              PUBLIC_HEADER  DESTINATION "${CMAKE_INCDIR_BASE}"
              ARCHIVE DESTINATION "${CMAKE_LIBDIR_BASE}")
 
+        foreach(file ${PUBLIC_HEADER_FILES})
+            add_custom_command(TARGET osd_static_framework POST_BUILD
+                COMMAND ${CMAKE_COMMAND} -E copy
+                "${CMAKE_SOURCE_DIR}/opensubdiv/${file}"
+                "$<TARGET_FILE_DIR:osd_static_framework>/Headers/${file}"
+            )
+        endforeach(file)
+
+        add_custom_command(TARGET osd_static_framework POST_BUILD
+            COMMAND ln -sf
+            "Versions/Current/Headers"
+            "$<TARGET_FILE_DIR:osd_static_framework>/../../Headers"
+        )
 
         #shared framework
         if (BUILD_SHARED_LIBS)
             add_library(osd_dynamic_framework
                 SHARED
                 version.cpp
                 $<TARGET_OBJECTS:sdc_obj>
                 $<TARGET_OBJECTS:vtr_obj>
                 $<TARGET_OBJECTS:far_obj>
+                $<TARGET_OBJECTS:bfr_obj>
                 $<TARGET_OBJECTS:osd_cpu_obj>
                 $<TARGET_OBJECTS:osd_gpu_obj>
                 ${OPENGL_LOADER_OBJS}
             )
 
             set_target_properties(
                 osd_dynamic_framework
                 PROPERTIES
                 RPATH true
                 FRAMEWORK true
                 INSTALL_NAME_DIR "@rpath/OpenSubdiv.framework/OpenSubdiv"
                 INSTALL_RPATH "@executable_path/Frameworks;@loader_path/Frameworks"
                 OUTPUT_NAME OpenSubdiv
+                EXPORT_NAME OpenSubdiv
                 CLEAN_DIRECT_OUTPUT true
             )
 
             target_link_libraries(osd_dynamic_framework
                 ${PLATFORM_CPU_LIBRARIES} ${PLATFORM_GPU_LIBRARIES}
             )
 
-            install( TARGETS osd_dynamic_framework
+            install( TARGETS osd_dynamic_framework EXPORT opensubdiv-targets
                  FRAMEWORK DESTINATION "${CMAKE_LIBDIR_BASE}"
                  LIBRARY DESTINATION "${CMAKE_LIBDIR_BASE}"
                  PUBLIC_HEADER  DESTINATION "${CMAKE_INCDIR_BASE}"
                  PRIVATE_HEADER  DESTINATION "${CMAKE_INCDIR_BASE}"
                  )
 
             foreach(file ${PUBLIC_HEADER_FILES})
@@ -349,10 +380,61 @@
                 COMMAND ln -sf
                 "Versions/Current/Headers"
                 "$<TARGET_FILE_DIR:osd_dynamic_framework>/../../Headers"
             )
         endif()
 
     endif()
+
+    # Expose preprocessor macro to the interface so that client know which feature are enabled
+    if(CMAKE_VERSION VERSION_GREATER_EQUAL 3.0)
+        foreach(osd_target osd_static_cpu osd_static_gpu osd_dynamic_cpu osd_dynamic_gpu osd_static_framework osd_dynamic_framework)
+            if(TARGET ${osd_target})
+                if(CLEW_FOUND)
+                    target_compile_definitions(${osd_target} INTERFACE OPENSUBDIV_HAS_CLEW)
+                endif()
+                if(CUDA_FOUND)
+                    target_compile_definitions(${osd_target} INTERFACE OPENSUBDIV_HAS_CUDA)
+                endif()
+                if(DXSDK_FOUND)
+                    target_compile_definitions(${osd_target} INTERFACE OPENSUBDIV_HAS_DX11SDK)
+                endif()
+                if(METAL_FOUND)
+                    target_compile_definitions(${osd_target} INTERFACE OPENSUBDIV_HAS_METAL)
+                endif()
+                if(OPENCL_CL_D3D11_EXT_H_FOUND OR OPENCL_CL_D3D11_H_FOUND)
+                    target_compile_definitions(${osd_target} INTERFACE OPENSUBDIV_HAS_OPENCL_DX_INTEROP)
+                endif()
+                if(OPENCL_FOUND)
+                    target_compile_definitions(${osd_target} INTERFACE OPENSUBDIV_HAS_OPENCL)
+                endif()
+                if(OPENGL_4_2_FOUND)
+                    target_compile_definitions(${osd_target} INTERFACE OPENSUBDIV_HAS_GLSL_TRANSFORM_FEEDBACK)
+                endif()
+                if(OPENGL_4_3_FOUND)
+                    target_compile_definitions(${osd_target} INTERFACE OPENSUBDIV_HAS_GLSL_COMPUTE)
+                endif()
+                if(NOT NO_OPENGL AND OPENGL_FOUND)
+                    target_compile_definitions(${osd_target} INTERFACE OPENSUBDIV_HAS_OPENGL)
+                endif()
+                if(NOT NO_OPENGL AND OPENGLES_FOUND)
+                    target_compile_definitions(${osd_target} INTERFACE OPENSUBDIV_HAS_OPENGLES)
+                endif()
+                if(OPENMP_FOUND)
+                    target_compile_definitions(${osd_target} INTERFACE OPENSUBDIV_HAS_OPENMP)
+                endif()
+                if(OPENSUBDIV_GREGORY_EVAL_TRUE_DERIVATIVES)
+                    target_compile_definitions(${osd_target} INTERFACE OPENSUBDIV_GREGORY_EVAL_TRUE_DERIVATIVES)
+                endif()
+                if(PTEX_FOUND)
+                    target_compile_definitions(${osd_target} INTERFACE OPENSUBDIV_HAS_PTEX)
+                endif()
+                if(TBB_FOUND)
+                    target_compile_definitions(${osd_target} INTERFACE OPENSUBDIV_HAS_TBB)
+                endif()
+            endif()
+        endforeach()
+    endif()
+
 endif()
 
 #-------------------------------------------------------------------------------
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/CMakeLists.txt` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/bilinearPatchBuilder.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/bilinearPatchBuilder.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/bilinearPatchBuilder.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/bilinearPatchBuilder.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/catmarkPatchBuilder.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/catmarkPatchBuilder.cpp`

 * *Files 0% similar despite different names*

```diff
@@ -18,18 +18,14 @@
 //   Unless required by applicable law or agreed to in writing, software
 //   distributed under the Apache License with the above modification is
 //   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 //   KIND, either express or implied. See the Apache License for the specific
 //   language governing permissions and limitations under the Apache License.
 //
 
-#ifdef _WIN32
-#define _USE_MATH_DEFINES
-#endif
-
 #include "../far/catmarkPatchBuilder.h"
 #include "../vtr/stackBuffer.h"
 
 #include <cassert>
 #include <cmath>
 #include <cstdio>
 
@@ -38,16 +34,19 @@
 
 using Vtr::Array;
 using Vtr::ConstArray;
 using Vtr::internal::StackBuffer;
 
 namespace Far {
 
+constexpr auto kPI = 3.14159265358979323846;
+constexpr auto kPI_2 = kPI/2.0;
+
 //
-//  Core functions for computing Catmark limit properties that are used 
+//  Core functions for computing Catmark limit properties that are used
 //  in the conversion to multiple patch types.
 //
 //  This struct/class is just a means of grouping common functions.
 //
 //  There is a long and unclear history to the details of the computations
 //  involved in the patch conversion here...
 //
@@ -55,15 +54,15 @@
 //  more widely accepted work of Loop, Shaefer et al or Myles et al.  The
 //  formulae for the limit points and tangents also ultimately need to be
 //  retrieved from Sdc::Scheme to ensure they conform, so future factoring
 //  of the formulae is still necessary.
 //
 //  Regarding support for multiple precision, like Sdc, some intermediate
 //  calculations are performed in double and cast to float.  Historically
-//  this conversion code has been purely float and later extended to 
+//  this conversion code has been purely float and later extended to
 //  support template <typename REAL>.  For math functions such as cos(),
 //  sin(), etc., we rely on overloading via <cmath> through the use of
 //  std::cos(), std::sin(), etc.
 //
 template <typename REAL>
 struct CatmarkLimits {
 public:
@@ -85,30 +84,30 @@
 //  Historically 30 values have been stored -- up to valence 29.
 //
 template <typename REAL>
 inline double
 CatmarkLimits<REAL>::computeCoefficient(int valence) {
 
     static double const efTable[] = {
-        0.0,                    0.0,                    0.0,                   
+        0.0,                    0.0,                    0.0,
         8.1281572906372312e-01, 0.5,                    3.6364406329142801e-01,
         2.8751379706077085e-01, 2.3868786685851678e-01, 2.0454364190756097e-01,
         1.7922903958061159e-01, 1.5965737079986253e-01, 1.4404233443011302e-01,
         1.3127568415883017e-01, 1.2063172212675841e-01, 1.1161437506676930e-01,
         1.0387245516114274e-01, 9.7150019090724835e-02, 9.1255917505950648e-02,
         8.6044378511602668e-02, 8.1402211336798411e-02, 7.7240129516184072e-02,
         7.3486719751997026e-02, 7.0084157479797987e-02, 6.6985104030725440e-02,
         6.4150420569810074e-02, 6.1547457638637268e-02, 5.9148757447233989e-02,
         5.6931056818776957e-02, 5.4874512279256417e-02, 5.2962091433796134e-02
     };
     assert(valence > 0);
     if (valence < 30) return efTable[valence];
 
     double invValence = 1.0 / valence;
-    double cosT = std::cos(2.0 * M_PI * invValence);
+    double cosT = std::cos(2.0 * kPI * invValence);
     double divisor = (cosT + 5.0) + std::sqrt((cosT + 9.0) * (cosT + 1.0));
 
     return (16.0 * invValence / divisor);
 }
 
 template <typename REAL>
 void
@@ -142,15 +141,15 @@
     double fValence        = (double) valence;
     double oneOverValence  = 1.0f / fValence;
     double oneOverValPlus5 = 1.0f / (fValence + 5.0f);
 
     double pCoeff   = oneOverValence * oneOverValPlus5;
     double tanCoeff = computeCoefficient(valence) * 0.5f * oneOverValPlus5;
 
-    double faceAngle = 2.0 * M_PI * oneOverValence;
+    double faceAngle = 2.0 * kPI * oneOverValence;
 
     //
     //  Assign position weights directly while accumulating an intermediate set
     //  of weights for the limit tangent.  And skip over the first weight for
     //  the corner vertex once assigned (zero for tangents) so that we don't
     //  have to deal with the off-by-one offset within the loop:
     //
@@ -204,15 +203,15 @@
 
 template <typename REAL>
 void
 CatmarkLimits<REAL>::ComputeBoundaryPointWeights(int valence, int faceInRing,
                 Weight* pWeights, Weight* epWeights, Weight* emWeights) {
 
     int    numFaces  = valence - 1;
-    double faceAngle = M_PI / numFaces;
+    double faceAngle = kPI / numFaces;
 
     int weightWidth = 2 * valence;
 
     int N = weightWidth - 1;
 
     //
     //  Position weights are trivial:
@@ -465,15 +464,15 @@
             _addSparseRowToFull(dstRow, srcMatrix, srcRowIndices[i], srcRowWeights[i]);
         }
     }
 
     template <typename REAL>
     void
     _matrixPrintDensity(const char* prefix, SparseMatrix<REAL> const & M) {
-    
+
         int fullSize = M.GetNumRows() * M.GetNumColumns();
         int sparseSize = M.GetNumElements();
 
         int nonZeroSize = 0;
         for (int i = 0; i < M.GetNumRows(); ++i) {
             ConstArray<REAL> elements = M.GetRowElements(i);
             for (int j = 0; j < elements.size(); ++j) {
@@ -759,20 +758,20 @@
         corner.faceInRing = srcCorner._patchFace;
         corner.isVal2Int  = srcCorner._val2Interior;
         corner.valence    = corner.numFaces + corner.isBoundary;
 
         corner.isRegular = ((corner.numFaces << corner.isBoundary) == 4)
                          && !corner.isSharp;
         if (corner.isRegular) {
-            corner.faceAngle    = REAL(M_PI_2);
+            corner.faceAngle    = REAL(kPI_2);
             corner.cosFaceAngle = 0.0f;
             corner.sinFaceAngle = 1.0f;
         } else {
             corner.faceAngle =
-                (corner.isBoundary ? REAL(M_PI) : (2.0f * REAL(M_PI)))
+                (corner.isBoundary ? REAL(kPI) : (2.0f * REAL(kPI)))
                     / REAL(corner.numFaces);
             corner.cosFaceAngle = std::cos(corner.faceAngle);
             corner.sinFaceAngle = std::sin(corner.faceAngle);
         }
 
         corner.ringPoints.SetSize(sourcePatch.GetCornerRingSize(cIndex));
         sourcePatch.GetCornerRingPoints(cIndex, corner.ringPoints);
@@ -1602,15 +1601,15 @@
     //  not exist", i.e. it serves as a place-holder for the remainder of the
     //  exterior ring of arbitrary size around P0:
     //
     //        ...
     //    (P5)   P4----P15---P14          X0----X2----X4----X6
     //   .        |     |     |            |     |     |     |
     //   .        |     |     |            |     |     |     |
-    //     P6----P0*---P3----P13          X1----P0*---P3----P13 
+    //     P6----P0*---P3----P13          X1----P0*---P3----P13
     //      |     |P' Em|     |    --->    |     |     |     |
     //      |     |Ep   |     |            |     |     |     |
     //     P7----P1----P2----P12          X3----P1----P2----P12
     //      |     |     |     |            |     |     |     |
     //      |     |     |     |            |     |     |     |
     //     P8----P9----P10---P11          X5----P9----P10---P11
     //
@@ -1952,15 +1951,15 @@
     assert(_schemeType == Sdc::SCHEME_CATMARK);
 
     //
     //  XXXX (barfowl) - consider a CatmarkPatch class to wrap SourcePatch
     //  with the additional corner information that it initializes.  That
     //  can then be used for conversion to all destination patch types...
     //
-    
+
     if (patchType == PatchDescriptor::GREGORY_BASIS) {
         GregoryConverter<REAL>(sourcePatch, matrix);
     } else if (patchType == PatchDescriptor::REGULAR) {
         BSplineConverter<REAL>(sourcePatch, matrix);
     } else if (patchType == PatchDescriptor::QUADS) {
         LinearConverter<REAL>(sourcePatch, matrix);
     } else {
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/catmarkPatchBuilder.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/catmarkPatchBuilder.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/error.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/error.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/error.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/error.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/loopPatchBuilder.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/loopPatchBuilder.cpp`

 * *Files 0% similar despite different names*

```diff
@@ -18,17 +18,19 @@
 //   Unless required by applicable law or agreed to in writing, software
 //   distributed under the Apache License with the above modification is
 //   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 //   KIND, either express or implied. See the Apache License for the specific
 //   language governing permissions and limitations under the Apache License.
 //
 
-#ifdef _WIN32
+#ifdef _MSC_VER
+#ifndef _USE_MATH_DEFINES
 #define _USE_MATH_DEFINES
 #endif
+#endif
 
 #include "../far/loopPatchBuilder.h"
 #include "../vtr/stackBuffer.h"
 #include "../sdc/loopScheme.h"
 
 #include <cassert>
 #include <cmath>
@@ -39,14 +41,16 @@
 
 using Vtr::Array;
 using Vtr::ConstArray;
 using Vtr::internal::StackBuffer;
 
 namespace Far {
 
+constexpr auto kPI = 3.14159265358979323846;
+
 //
 //  A simple struct with methods to compute Loop limit points (following
 //  the pattern established for Catmull-Clark limit points)
 //
 //  Unlike the corresponding Catmull-Clark struct, Loop limit points are
 //  computed using the limit masks provided by the Sdc Scheme for Loop.
 //
@@ -174,15 +178,15 @@
         //  for the scale inherent in the tangent weights, and (2 / 3) to
         //  match desired placement of the cubic point in the regular case.
         //
         //  The weights for t1 can simply be rotated around the ring to yield
         //  t2.  Combine the weights for the point in a single set for t2 and
         //  then copy it into the appropriate orientation for ep and em:
         //
-        double theta = 2.0 * M_PI / (double) valence;
+        double theta = 2.0 * kPI / (double) valence;
 
         REAL tanScale = (REAL) ((3.0 + 2.0 * std::cos(theta)) / (6.0 * valence));
 
         for (int i = 0; i < ringSize; ++i) {
             t2Weights[i] = pWeights[i] + t1Weights[i] * tanScale;
         }
 
@@ -252,15 +256,15 @@
         if (epOnLeadingEdge) {
             std::memset(&epWeights[0], 0, weightWidth * sizeof(REAL));
 
             epWeights[0] = (REAL) (2.0 / 3.0);
             epWeights[1] = (REAL) (1.0 / 3.0);
         } else {
             int  iEdgeNext     = faceInRing;
-            REAL faceAngle     = (REAL) (M_PI / (double)(valence - 1));
+            REAL faceAngle     = (REAL) (kPI / (double)(valence - 1));
             REAL faceAngleNext = faceAngle * (REAL)iEdgeNext;
             REAL cosAngleNext  = std::cos(faceAngleNext);
             REAL sinAngleNext  = std::sin(faceAngleNext);
 
             for (int i = 0; i < weightWidth; ++i) {
                 epWeights[i] = t2Scale * t2Weights[i] * sinAngleNext;
             }
@@ -272,15 +276,15 @@
         if (emOnTrailingEdge) {
             std::memset(&emWeights[0], 0, weightWidth * sizeof(REAL));
 
             emWeights[0]       = (REAL) (2.0 / 3.0);
             emWeights[valence] = (REAL) (1.0 / 3.0);
         } else {
             int  iEdgePrev     = (faceInRing + 1) % valence;
-            REAL faceAngle     = (REAL) (M_PI / (double)(valence - 1));
+            REAL faceAngle     = (REAL) (kPI / (double)(valence - 1));
             REAL faceAnglePrev = faceAngle * (REAL)iEdgePrev;
             REAL cosAnglePrev  = std::cos(faceAnglePrev);
             REAL sinAnglePrev  = std::sin(faceAnglePrev);
 
             for (int i = 0; i < weightWidth; ++i) {
                 emWeights[i] = t2Scale * t2Weights[i] * sinAnglePrev;
             }
@@ -737,19 +741,19 @@
         corner.faceInRing = srcCorner._patchFace;
         corner.isVal2Int  = srcCorner._val2Interior;
         corner.valence    = corner.numFaces + corner.isBoundary;
 
         corner.isRegular = ((corner.numFaces << corner.isBoundary) == 6)
                          && !corner.isSharp;
         if (corner.isRegular) {
-            corner.faceAngle = (REAL)(M_PI / 3.0);
+            corner.faceAngle = (REAL)(kPI / 3.0);
             corner.cosFaceAngle = 0.5f;
         } else {
             corner.faceAngle =
-                (corner.isBoundary ? REAL(M_PI) : REAL(2.0 * M_PI))
+                (corner.isBoundary ? REAL(kPI) : REAL(2.0 * kPI))
                     / REAL(corner.numFaces);
             corner.cosFaceAngle = std::cos(corner.faceAngle);
         }
 
         corner.ringPoints.SetSize(sourcePatch.GetCornerRingSize(cIndex));
         sourcePatch.GetCornerRingPoints(cIndex, corner.ringPoints);
 
@@ -1618,14 +1622,15 @@
                     printf("%6.3f ", (REAL)weights[j]);
                 }
                 printf("\n");
             }
         }
     }
 
+#ifdef FAR_DEBUG_LOOP_PATCH_BUILDER
     void
     _printSourcePatch(SourcePatch const & patch, bool printCornerInfo = true,
                                                  bool printRingPoints = true) {
 
         printf("SoucePatch - %d corners, %d points:\n",
             patch._numCorners, patch._numSourcePoints);
 
@@ -1650,14 +1655,15 @@
                 for (int j = 0; j < ringSize; ++j) {
                     printf("%d ", ringPoints[j]);
                 }
                 printf("\n");
             }
         }
     }
+#endif
 }
 
 
 //
 //  Not using the same "Converter" pattern used above and in the Catmark scheme,
 //  since the two remaining conversions are fairly trivial.
 //
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/loopPatchBuilder.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/loopPatchBuilder.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchBasis.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchBasis.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -85,16 +85,16 @@
             for(int i = 0; i < 4; ++i) {
                 wDss[i] = 0.0f;
                 wDtt[i] = 0.0f;
             }
 
             wDst[0] =  1.0f;
             wDst[1] = -1.0f;
-            wDst[2] = -1.0f;
-            wDst[3] =  1.0f;
+            wDst[2] =  1.0f;
+            wDst[3] = -1.0f;
         }
     }
     return 4;
 }
 
 //
 //  Bicubic BSpline patch:
@@ -408,15 +408,19 @@
 
     //  Use <= here to avoid compiler warnings -- the sums should always be non-negative:
     REAL df0 = s  + t;   df0 = (df0 <= 0.0f) ? (REAL)1.0f : (1.0f / df0);
     REAL df1 = sC + t;   df1 = (df1 <= 0.0f) ? (REAL)1.0f : (1.0f / df1);
     REAL df2 = sC + tC;  df2 = (df2 <= 0.0f) ? (REAL)1.0f : (1.0f / df2);
     REAL df3 = s  + tC;  df3 = (df3 <= 0.0f) ? (REAL)1.0f : (1.0f / df3);
 
-    REAL G[8] = { s*df0, t*df0,  t*df1, sC*df1,  sC*df2, tC*df2,  tC*df3, s*df3 };
+    //  Make sure the G[i] for pairs of interior points sum to 1 in all cases:
+    REAL G[8] = { s*df0, (1.0f -  s*df0),
+                  t*df1, (1.0f -  t*df1),
+                 sC*df2, (1.0f - sC*df2),
+                 tC*df3, (1.0f - tC*df3) };
 
     //  Combined weights for boundary and interior points:
     for (int i = 0; i < 12; ++i) {
         point[boundaryGregory[i]] = Bs[boundaryBezSCol[i]] * Bt[boundaryBezTRow[i]];
     }
     for (int i = 0; i < 8; ++i) {
         point[interiorGregory[i]] = Bs[interiorBezSCol[i]] * Bt[interiorBezTRow[i]] * G[i];
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchBasis.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchBasis.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchBuilder.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchBuilder.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -217,18 +217,18 @@
         //  of the vertex, using the start face and corner of the leading edge:
         //
         Index vIndex = level.getFaceVertices(fIndex)[fCorner];
 
         ConstIndexArray      vFaces   = level.getVertexFaces(vIndex);
         ConstLocalIndexArray vInFaces = level.getVertexFaceLocalIndices(vIndex);
 
-        vSpan._startFace = vFaces.size();
+        vSpan._startFace = (LocalIndex) vFaces.size();
         for (int i = 0; i < vFaces.size(); ++i) {
             if ((vFaces[i] == startFace) && (vInFaces[i] == startCorner)) {
-                vSpan._startFace = i;
+                vSpan._startFace = (LocalIndex) i;
                 break;
             }
         }
         assert(vSpan._startFace < vFaces.size());
     }
 
     //  Simple conveniences for the span search functions:
@@ -1133,16 +1133,16 @@
         if (cornerSpans[corner].isAssigned()) {
             patchCorner._numFaces  = cornerSpans[corner]._numFaces;
             patchCorner._patchFace = cornerSpans[corner]._cornerInSpan;
             patchCorner._boundary  = !cornerSpans[corner]._periodic;
         } else {
             ConstIndexArray vFaces = level.getVertexFaces(fVerts[corner]);
 
-            patchCorner._numFaces  = vFaces.size();
-            patchCorner._patchFace = vFaces.FindIndex(faceIndex);
+            patchCorner._numFaces  = (LocalIndex) vFaces.size();
+            patchCorner._patchFace = (LocalIndex) vFaces.FindIndex(faceIndex);
             patchCorner._boundary  = vTag._boundary;
         }
         patchCorner._sharp = cornerSpans[corner]._sharp;
         patchCorner._dart  = (vTag._rule == Sdc::Crease::RULE_DART) && vTag._infSharpEdges;
     }
     sourcePatch.Finalize(fVerts.size());
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchBuilder.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchBuilder.h`

 * *Files 0% similar despite different names*

```diff
@@ -60,15 +60,15 @@
 //  the library, not exported to clients) -- eliminating the need for the
 //  explicit initialization and required call to the Finalize() method that
 //  the PatchBuilder currently performs internally.
 //
 class SourcePatch {
 public:
     struct Corner {
-        Corner() { std::memset(this, 0, sizeof(Corner)); }
+        Corner() { std::memset((void*) this, 0, sizeof(Corner)); }
 
         LocalIndex _numFaces;   // valence of corner vertex
         LocalIndex _patchFace;  // location of patch within incident faces
 
         unsigned short _boundary : 1;
         unsigned short _sharp    : 1;
         unsigned short _dart     : 1;
@@ -77,15 +77,15 @@
         unsigned short _sharesWithPrev : 1;
         unsigned short _sharesWithNext : 1;
         unsigned short _val2Interior   : 1;
         unsigned short _val2Adjacent   : 1;
     };
 
 public:
-    SourcePatch() { std::memset(this, 0, sizeof(SourcePatch)); }
+    SourcePatch() { std::memset((void*) this, 0, sizeof(SourcePatch)); }
     ~SourcePatch() { }
 
     //  To be called after all Corners have been initialized (hope to
     //  replace this with alternative constructor at some point)
     void Finalize(int size3or4);
 
     int GetNumSourcePoints() const { return _numSourcePoints; }
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchDescriptor.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchDescriptor.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchDescriptor.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchDescriptor.h`

 * *Files 1% similar despite different names*

```diff
@@ -73,14 +73,20 @@
     PatchDescriptor(int type) :
         _type(type) { }
 
     /// \brief Copy Constructor
     PatchDescriptor( PatchDescriptor const & d ) :
         _type(d.GetType()) { }
 
+    /// \brief Assignment operator
+    PatchDescriptor & operator=( PatchDescriptor const & d ) {
+        _type = d.GetType();
+        return *this;
+    }
+
     /// \brief Returns the type of the patch
     Type GetType() const {
         return (Type)_type;
     }
 
     /// \brief Returns true if the type is an adaptive (non-linear) patch
     static inline bool IsAdaptive(Type type) {
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchMap.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchMap.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchMap.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchMap.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchParam.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchParam.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchTable.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchTable.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchTable.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchTable.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchTableFactory.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchTableFactory.cpp`

 * *Files 0% similar despite different names*

```diff
@@ -1272,15 +1272,15 @@
                 //  Initialize and assign the face-varying PatchParam:
                 PatchParam & fvcPatchParam = *arrayBuilder->fpptr[fvc];
                 fvcPatchParam.Set(
                    patchParam.GetFaceId(),
                    patchParam.GetU(), patchParam.GetV(),
                    patchParam.GetDepth(),
                    patchParam.NonQuadRoot(),
-                   fvcPatchInfo.paramBoundaryMask,
+                   (unsigned short) fvcPatchInfo.paramBoundaryMask,
                    patchParam.GetTransition(),
                    fvcPatchInfo.isRegular);
             }
             arrayBuilder->fpptr[fvc] ++;
             arrayBuilder->fptr[fvc] += _table->GetFVarValueStride(fvc);
         }
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/patchTableFactory.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/patchTableFactory.h`

 * *Files 2% similar despite different names*

```diff
@@ -63,15 +63,15 @@
         Options(unsigned int maxIsolation=10) :
              generateAllLevels(false),
              includeBaseLevelIndices(true),
              includeFVarBaseLevelIndices(false),
              triangulateQuads(false),
              useSingleCreasePatch(false),
              useInfSharpPatch(false),
-             maxIsolationLevel(maxIsolation),
+             maxIsolationLevel(maxIsolation & 0xf),
              endCapType(ENDCAP_GREGORY_BASIS),
              shareEndCapPatchPoints(true),
              generateVaryingTables(true),
              generateVaryingLocalPoints(true),
              generateFVarTables(false),
              patchPrecisionDouble(false),
              fvarPatchPrecisionDouble(false),
@@ -81,15 +81,18 @@
              fvarChannelIndices(0)
         { }
 
         /// \brief Get endcap basis type
         EndCapType GetEndCapType() const { return (EndCapType)endCapType; }
 
         /// \brief Set endcap basis type
-        void SetEndCapType(EndCapType e) { endCapType = e; }
+        void SetEndCapType(EndCapType e) { endCapType = e & 0x7; }
+
+        /// \brief Set maximum isolation level
+        void SetMaxIsolationLevel(unsigned int level) { maxIsolationLevel = level & 0xf; }
 
         /// \brief Set precision of vertex patches
         template <typename REAL> void SetPatchPrecision();
 
         /// \brief Set precision of face-varying patches
         template <typename REAL> void SetFVarPatchPrecision();
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/primvarRefiner.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/primvarRefiner.h`

 * *Files 1% similar despite different names*

```diff
@@ -965,17 +965,22 @@
             //      - if the CHILD is a corner, there can be no transition so we have a corner
             //      - otherwise if the PARENT is a crease, both will be creases (no transition)
             //      - otherwise the parent must be a corner and the child a crease (transition)
             //
             Vtr::internal::FVarLevel::ConstValueTagArray pValueTags = parentFVar.getVertexValueTags(vert);
             Vtr::internal::FVarLevel::ConstValueTagArray cValueTags = childFVar.getVertexValueTags(cVert);
 
-            for (int cSibling = 0; cSibling < cVertValues.size(); ++cSibling) {
-                int pSibling = refineFVar.getChildValueParentSource(cVert, cSibling);
-                assert(pSibling == cSibling);
+            for (int cSiblingIndex = 0; cSiblingIndex < cVertValues.size(); ++cSiblingIndex) {
+                int pSiblingIndex = refineFVar.getChildValueParentSource(cVert, cSiblingIndex);
+                assert(pSiblingIndex == cSiblingIndex);
+
+                typedef Vtr::internal::FVarLevel::Sibling SiblingIntType;
+
+                SiblingIntType cSibling = (SiblingIntType) cSiblingIndex;
+                SiblingIntType pSibling = (SiblingIntType) pSiblingIndex;
 
                 Vtr::Index pVertValue = pVertValues[pSibling];
                 Vtr::Index cVertValue = cVertValues[cSibling];
 
                 dst[cVertValue].Clear();
                 if (isLinearFVar || cValueTags[cSibling].isCorner()) {
                     dst[cVertValue].AddWithWeight(src[pVertValue], 1.0f);
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/ptexIndices.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/ptexIndices.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/ptexIndices.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/ptexIndices.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/sparseMatrix.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/sparseMatrix.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/stencilBuilder.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/stencilBuilder.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/stencilBuilder.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/stencilBuilder.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/stencilTable.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/stencilTable.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/stencilTable.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/stencilTable.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/stencilTableFactory.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/stencilTableFactory.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -18,14 +18,20 @@
 //   Unless required by applicable law or agreed to in writing, software
 //   distributed under the Apache License with the above modification is
 //   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 //   KIND, either express or implied. See the Apache License for the specific
 //   language governing permissions and limitations under the Apache License.
 //
 
+#ifdef _MSC_VER
+#ifndef _USE_MATH_DEFINES
+#define _USE_MATH_DEFINES
+#endif
+#endif
+
 #include "../far/stencilTableFactory.h"
 #include "../far/stencilBuilder.h"
 #include "../far/patchTable.h"
 #include "../far/patchTableFactory.h"
 #include "../far/patchMap.h"
 #include "../far/topologyRefiner.h"
 #include "../far/primvarRefiner.h"
@@ -96,18 +102,17 @@
     }
 
     StencilBuilder<REAL> builder(numControlVertices,
                                 /*genControlVerts*/ true,
                                 /*compactWeights*/  true);
 
     //
-    // Interpolate stencils for each refinement level using
-    // PrimvarRefiner::InterpolateLevel<>() for vertex or varying
+    // Interpolate stencils for each refinement level
     //
-    PrimvarRefiner primvarRefiner(refiner);
+    PrimvarRefinerReal<REAL> primvarRefiner(refiner);
 
     typename StencilBuilder<REAL>::Index srcIndex(&builder, 0);
     typename StencilBuilder<REAL>::Index dstIndex(&builder, numControlVertices);
 
     for (int level=1; level<=maxlevel; ++level) {
         if (interpolateVertex) {
             primvarRefiner.Interpolate(level, srcIndex, dstIndex);
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/stencilTableFactory.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/stencilTableFactory.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/topologyDescriptor.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/topologyDescriptor.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/topologyDescriptor.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/topologyDescriptor.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/topologyLevel.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/topologyLevel.h`

 * *Files 12% similar despite different names*

```diff
@@ -126,19 +126,44 @@
 
     /// \brief Return if the edge is non-manifold
     bool IsEdgeNonManifold(Index e) const   { return _level->isEdgeNonManifold(e); }
 
     /// \brief Return if the vertex is non-manifold
     bool IsVertexNonManifold(Index v) const { return _level->isVertexNonManifold(v); }
 
-    /// \brief Return if the edge is a boundary
+    /// \brief Return if the edge is a boundary (only one incident face)
     bool IsEdgeBoundary(Index e) const   { return _level->getEdgeTag(e)._boundary; }
 
-    /// \brief Return if the vertex is a boundary
+    /// \brief Return if the vertex is on a boundary (at least one incident boundary edge)
     bool IsVertexBoundary(Index v) const { return _level->getVertexTag(v)._boundary; }
+
+    /// \brief Return if the vertex is a corner (only one incident face)
+    bool IsVertexCorner(Index v) const { return (_level->getNumVertexFaces(v) == 1); }
+
+    /// \brief Return if the valence of the vertex is regular (must be manifold)
+    ///
+    /// Note that this test only determines if the valence of the vertex is regular
+    /// with respect to the assigned subdivision scheme -- not if the neighborhood
+    /// around the vertex is regular. The latter depends on a number of factors
+    /// including the incident faces of the vertex (they must all be regular) and
+    /// the presence of sharpness at the vertex itself or its incident edges.
+    ///
+    /// The regularity of the valence is a necessary but not a sufficient condition
+    /// in determining the regularity of the neighborhood. For example, while the
+    /// valence of an interior vertex may be regular, its neighborhood is not if the
+    /// vertex was made infinitely sharp.  Conversely, a corner vertex is considered
+    /// regular by its valence but its neighborhood is not if the vertex was not made
+    /// infinitely sharp.
+    ///
+    /// Whether the valence of the vertex is regular is also a property that remains
+    /// the same for the vertex in all subdivision levels. In contrast, the regularity
+    /// of the region around the vertex may change as the presence of irregular faces
+    /// or semi-sharp features is reduced by subdivision.
+    ///
+    bool IsVertexValenceRegular(Index v) const { return !_level->getVertexTag(v)._xordinary || IsVertexCorner(v); }
     //@}
 
     //@{
     /// @name Methods to inspect feature tags for individual components:
     ///
     /// While only a subset of components may have been tagged with features such
     /// as sharpness, all such features have a default value and so all components
@@ -146,14 +171,26 @@
 
     /// \brief Return the sharpness assigned a given edge
     float GetEdgeSharpness(Index e) const   { return _level->getEdgeSharpness(e); }
 
     /// \brief Return the sharpness assigned a given vertex
     float GetVertexSharpness(Index v) const { return _level->getVertexSharpness(v); }
 
+    /// \brief Return if the edge is infinitely-sharp
+    bool IsEdgeInfSharp(Index e) const { return _level->getEdgeTag(e)._infSharp; }
+
+    /// \brief Return if the vertex is infinitely-sharp
+    bool IsVertexInfSharp(Index v) const { return _level->getVertexTag(v)._infSharp; }
+
+    /// \brief Return if the edge is semi-sharp
+    bool IsEdgeSemiSharp(Index e) const { return _level->getEdgeTag(e)._semiSharp; }
+
+    /// \brief Return if the vertex is semi-sharp
+    bool IsVertexSemiSharp(Index v) const { return _level->getVertexTag(v)._semiSharp; }
+
     /// \brief Return if a given face has been tagged as a hole
     bool  IsFaceHole(Index f) const         { return _level->isFaceHole(f); }
 
     /// \brief Return the subdivision rule assigned a given vertex specific to this level
     Sdc::Crease::Rule GetVertexRule(Index v) const { return _level->getVertexRule(v); }
     //@}
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/topologyRefiner.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/topologyRefiner.cpp`

 * *Files 0% similar despite different names*

```diff
@@ -114,14 +114,15 @@
         _levels.resize(1);
         initializeInventory();
     }
     for (int i=0; i<(int)_refinements.size(); ++i) {
         delete _refinements[i];
     }
     _refinements.clear();
+    _maxLevel = 0;
 
     assembleFarLevels();
 }
 
 
 //
 //  Initializing and updating the component inventory:
@@ -727,14 +728,19 @@
         Level::VTag vTags[4];
 
         for (int i = 0; i < fVerts.size(); ++i) {
             vTags[i] = level.getVertexCompositeFVarVTag(fVerts[i], fvarChannel);
         }
         Level::VTag compVTag = Level::VTag::BitwiseOr(vTags, fVerts.size());
 
+        //  Incomplete faces (incomplete neighborhood) are unconditionally excluded:
+        if (compVTag._incomplete) {
+            return false;
+        }
+
         //  Select non-manifold features if specified, otherwise treat as inf-sharp:
         if (compVTag._nonManifold && featureMask.selectNonManifold) {
             return true;
         }
 
         //  Any remaining locally extra-ordinary face-varying boundaries warrant selection:
         if (compVTag._xordinary && featureMask.selectXOrdinaryInterior) {
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/topologyRefiner.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/topologyRefiner.h`

 * *Files 4% similar despite different names*

```diff
@@ -114,18 +114,21 @@
     /// topology traversal of the last level, e.g. inspecting edges or incident
     /// faces of vertices, the option to generate full topology in the last
     /// level should be enabled.
     ///
     struct UniformOptions {
 
         UniformOptions(int level) :
-            refinementLevel(level),
+            refinementLevel(level & 0xf),
             orderVerticesFromFacesFirst(false),
             fullTopologyInLastLevel(false) { }
 
+        /// \brief Set uniform refinement level
+        void SetRefinementLevel(int level) { refinementLevel = level & 0xf; }
+
         unsigned int refinementLevel:4,             ///< Number of refinement iterations
                      orderVerticesFromFacesFirst:1, ///< Order child vertices from faces first
                                                     ///< instead of child vertices of vertices
                      fullTopologyInLastLevel:1;     ///< Skip topological relationships in the last
                                                     ///< level of refinement that are not needed for
                                                     ///< interpolation (keep false if using limit).
     };
@@ -149,21 +152,27 @@
     // Adaptive refinement
     //
 
     /// \brief Adaptive refinement options
     struct AdaptiveOptions {
 
         AdaptiveOptions(int level) :
-            isolationLevel(level),
-            secondaryLevel(15),
+            isolationLevel(level & 0xf),
+            secondaryLevel(0xf),
             useSingleCreasePatch(false),
             useInfSharpPatch(false),
             considerFVarChannels(false),
             orderVerticesFromFacesFirst(false) { }
 
+        /// \brief Set isolation level
+        void SetIsolationLevel(int level) { isolationLevel = level & 0xf; }
+
+        /// \brief Set secondary isolation level
+        void SetSecondaryLevel(int level) { secondaryLevel = level & 0xf; }
+
         unsigned int isolationLevel:4;              ///< Number of iterations applied to isolate
                                                     ///< extraordinary vertices and creases
         unsigned int secondaryLevel:4;              ///< Shallower level to stop isolation of
                                                     ///< smooth irregular features
         unsigned int useSingleCreasePatch:1;        ///< Use 'single-crease' patch and stop
                                                     ///< isolation where applicable
         unsigned int useInfSharpPatch:1;            ///< Use infinitely sharp patches and stop
@@ -218,14 +227,16 @@
     friend class PtexIndices;
     template <typename REAL>
     friend class PrimvarRefinerReal;
 
     //  Copy constructor exposed via the factory class:
     TopologyRefiner(TopologyRefiner const & source);
 
+public:
+    //  Levels and Refinements available internally (avoids need for more friends)
     Vtr::internal::Level & getLevel(int l) { return *_levels[l]; }
     Vtr::internal::Level const & getLevel(int l) const { return *_levels[l]; }
 
     Vtr::internal::Refinement & getRefinement(int l) { return *_refinements[l]; }
     Vtr::internal::Refinement const & getRefinement(int l) const { return *_refinements[l]; }
 
 private:
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/topologyRefinerFactory.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/topologyRefinerFactory.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/topologyRefinerFactory.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/topologyRefinerFactory.h`

 * *Files 2% similar despite different names*

```diff
@@ -318,14 +318,27 @@
     //@}
 
 protected:
     //
     //  Not to be specialized:
     //
     static bool populateBaseLevel(TopologyRefiner& refiner, MESH const& mesh, Options options);
+
+private:
+    //
+    //  An oversight in the interfaces of the error reporting function between the factory
+    //  class and the Vtr::Level requires this adapter function to avoid warnings.
+    //
+    //  The static class method requires a reference as the MESH argument, but the interface
+    //  for Vtr::Level requires a pointer (void*). So this adapter with a MESH* argument is
+    //  used to effectively cast the function pointer required by Vtr::Level error reporting:
+    //
+    static void reportInvalidTopologyAdapter(TopologyError errCode, char const * msg, MESH const * mesh) {
+        reportInvalidTopology(errCode, msg, *mesh);
+    }
 };
 
 
 //
 //  Generic implementations:
 //
 template <class MESH>
@@ -376,15 +389,15 @@
 
     //
     //  Assignment of the topology -- this is a required specialization for MESH.  If edges
     //  are specified, all other topological relations are expected to be defined for them.
     //  Otherwise edges and remaining topology will be completed from the face-vertices:
     //
     bool             validate = options.validateFullTopology;
-    TopologyCallback callback = reinterpret_cast<TopologyCallback>(reportInvalidTopology);
+    TopologyCallback callback = reinterpret_cast<TopologyCallback>(reportInvalidTopologyAdapter);
     void const *     userData = &mesh;
         
     if (! assignComponentTopology(refiner, mesh)) return false;
     if (! prepareComponentTopologyAssignment(refiner, validate, callback, userData)) return false;
 
     //
     //  User assigned and internal tagging of components -- an optional specialization for
@@ -434,15 +447,15 @@
     return newRefiner._levels[0]->getNumVertices();
 }
 
 template <class MESH>
 inline void
 TopologyRefinerFactory<MESH>::setNumBaseFaceVertices(TopologyRefiner & newRefiner, Index f, int count) {
     newRefiner._levels[0]->resizeFaceVertices(f, count);
-    newRefiner._hasIrregFaces |= (count != newRefiner._regFaceSize);
+    newRefiner._hasIrregFaces = newRefiner._hasIrregFaces || (count != newRefiner._regFaceSize);
 }
 template <class MESH>
 inline void
 TopologyRefinerFactory<MESH>::setNumBaseEdgeFaces(TopologyRefiner & newRefiner, Index e, int count) {
     newRefiner._levels[0]->resizeEdgeFaces(e, count);
 }
 template <class MESH>
@@ -536,15 +549,15 @@
 TopologyRefinerFactory<MESH>::setBaseVertexSharpness(TopologyRefiner & newRefiner, Index v, float s) {
     newRefiner._levels[0]->getVertexSharpness(v) = s;
 }
 template <class MESH>
 inline void
 TopologyRefinerFactory<MESH>::setBaseFaceHole(TopologyRefiner & newRefiner, Index f, bool b) {
     newRefiner._levels[0]->setFaceHole(f, b);
-    newRefiner._hasHoles |= b;
+    newRefiner._hasHoles = newRefiner._hasHoles || b;
 }
 
 template <class MESH>
 inline int
 TopologyRefinerFactory<MESH>::createBaseFVarChannel(TopologyRefiner & newRefiner, int numValues) {
     return newRefiner._levels[0]->createFVarChannel(numValues, newRefiner._subdivOptions);
 }
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/far/types.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/far/types.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/CMakeLists.txt` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/allocator.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/allocator.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/bilinear.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/bilinear.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/catmark.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/catmark.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/cornerEdit.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/cornerEdit.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/creaseEdit.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/creaseEdit.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/face.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/face.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/faceEdit.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/faceEdit.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/fvarData.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/fvarData.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/fvarEdit.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/fvarEdit.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/halfedge.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/halfedge.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/hierarchicalEdit.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/hierarchicalEdit.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/holeEdit.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/holeEdit.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/loop.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/loop.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/mesh.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/mesh.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/subdivision.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/subdivision.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/vertex.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/vertex.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/hbr/vertexEdit.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/hbr/vertexEdit.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/Android.mk` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/Android.mk`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/CMakeLists.txt` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/CMakeLists.txt`

 * *Files 1% similar despite different names*

```diff
@@ -255,15 +255,15 @@
         ${METAL_SOURCE_FILES}
         PROPERTIES
         COMPILE_FLAGS
         "-fobjc-arc")
 
     list(APPEND GPU_SOURCE_FILES ${METAL_SOURCE_FILES})
 
-
+    
 
     list(APPEND PUBLIC_HEADER_FILES ${METAL_PUBLIC_HEADERS})
     list(APPEND KERNEL_FILES
        mtlComputeKernel.metal
        mtlPatchCommon.metal
        mtlPatchCommonTess.metal
        mtlPatchBoxSplineTriangle.metal
@@ -380,15 +380,15 @@
 )
 
 set_target_properties(osd_cpu_obj
     PROPERTIES
         FOLDER "opensubdiv"
 )
 
-if( GPU_SOURCE_FILES )
+if( GPU_SOURCE_FILES ) 
     add_library(osd_gpu_obj
         OBJECT
             ${GPU_SOURCE_FILES}
             ${PRIVATE_HEADER_FILES}
             ${PUBLIC_HEADER_FILES}
             ${INC_FILES}
     )
@@ -406,20 +406,20 @@
     DESTINATION
         "${CMAKE_INCDIR_BASE}/osd"
     PERMISSIONS
         OWNER_READ
         GROUP_READ
         WORLD_READ )
 
-#if (ANDROID)
-#    install(
-#        FILES
-#            Android.mk
-#        DESTINATION
-#            "${LIBRARY_OUTPUT_PATH_ROOT}"
-#        PERMISSIONS
-#            OWNER_READ
-#            GROUP_READ
-#            WORLD_READ )
-#endif()
+if (ANDROID)
+    install(
+        FILES
+            Android.mk
+        DESTINATION
+            "${LIBRARY_OUTPUT_PATH_ROOT}"
+        PERMISSIONS
+            OWNER_READ
+            GROUP_READ
+            WORLD_READ )
+endif()
 
 #-------------------------------------------------------------------------------
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/bufferDescriptor.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/bufferDescriptor.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/clD3D11VertexBuffer.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/clD3D11VertexBuffer.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/clD3D11VertexBuffer.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/clD3D11VertexBuffer.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/clEvaluator.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/clEvaluator.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/clEvaluator.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/clEvaluator.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/clGLVertexBuffer.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/clGLVertexBuffer.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/clGLVertexBuffer.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/clGLVertexBuffer.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/clKernel.cl` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/clKernel.cl`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/clPatchTable.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/clPatchTable.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/clPatchTable.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/clPatchTable.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/clVertexBuffer.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/clVertexBuffer.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/clVertexBuffer.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/clVertexBuffer.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuD3D11VertexBuffer.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuD3D11VertexBuffer.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuD3D11VertexBuffer.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuD3D11VertexBuffer.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuEvaluator.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuEvaluator.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuEvaluator.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuEvaluator.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuGLVertexBuffer.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuGLVertexBuffer.cpp`

 * *Files 0% similar despite different names*

```diff
@@ -91,15 +91,15 @@
 
 GLuint
 CpuGLVertexBuffer::BindVBO(void * /*deviceContext*/) {
 
     if (! _dataDirty)
         return _vbo;
 
-    int size = GetNumElements() * GetNumVertices() * sizeof(float);
+    int size = GetNumElements() * GetNumVertices() * (int) sizeof(float);
 
     if (! _vbo) {
         glGenBuffers(1, &_vbo);
     }
 
     glBindBuffer(GL_ARRAY_BUFFER, _vbo);
     glBufferData(GL_ARRAY_BUFFER, size, _cpuBuffer, GL_STATIC_DRAW);
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuGLVertexBuffer.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuGLVertexBuffer.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuKernel.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuKernel.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuKernel.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuKernel.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuPatchTable.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuPatchTable.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuPatchTable.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuPatchTable.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuVertexBuffer.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuVertexBuffer.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cpuVertexBuffer.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cpuVertexBuffer.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cudaD3D11VertexBuffer.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cudaD3D11VertexBuffer.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cudaD3D11VertexBuffer.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cudaD3D11VertexBuffer.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cudaEvaluator.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cudaEvaluator.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cudaEvaluator.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cudaEvaluator.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cudaGLVertexBuffer.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cudaGLVertexBuffer.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cudaGLVertexBuffer.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cudaGLVertexBuffer.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cudaKernel.cu` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cudaKernel.cu`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cudaPatchTable.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cudaPatchTable.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cudaPatchTable.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cudaPatchTable.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cudaVertexBuffer.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cudaVertexBuffer.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/cudaVertexBuffer.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/cudaVertexBuffer.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/d3d11ComputeEvaluator.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/d3d11ComputeEvaluator.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -232,19 +232,19 @@
     std::ostringstream ss;
     ss << srcDesc.length;  std::string lengthValue(ss.str()); ss.str("");
     ss << srcDesc.stride;  std::string srcStrideValue(ss.str()); ss.str("");
     ss << dstDesc.stride;  std::string dstStrideValue(ss.str()); ss.str("");
     ss << _workGroupSize;  std::string workgroupSizeValue(ss.str()); ss.str("");
 
     D3D_SHADER_MACRO defines[] =
-        { "LENGTH", lengthValue.c_str(),
-          "SRC_STRIDE", srcStrideValue.c_str(),
-          "DST_STRIDE", dstStrideValue.c_str(),
-          "WORK_GROUP_SIZE", workgroupSizeValue.c_str(),
-          0, 0 };
+        { { "LENGTH", lengthValue.c_str() },
+          { "SRC_STRIDE", srcStrideValue.c_str() },
+          { "DST_STRIDE", dstStrideValue.c_str() },
+          { "WORK_GROUP_SIZE", workgroupSizeValue.c_str() },
+          { 0, 0 } };
 
     ID3DBlob * computeShaderBuffer = NULL;
     ID3DBlob * errorBuffer = NULL;
 
     HRESULT hr = D3DCompile(shaderSource, strlen(shaderSource),
                             NULL, &defines[0], NULL,
                             "cs_main", "cs_5_0",
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/d3d11ComputeEvaluator.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/d3d11ComputeEvaluator.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/d3d11LegacyGregoryPatchTable.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/d3d11LegacyGregoryPatchTable.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/d3d11LegacyGregoryPatchTable.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/d3d11LegacyGregoryPatchTable.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/d3d11Mesh.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/d3d11Mesh.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/d3d11PatchTable.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/d3d11PatchTable.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/d3d11PatchTable.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/d3d11PatchTable.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/d3d11VertexBuffer.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/d3d11VertexBuffer.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/d3d11VertexBuffer.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/d3d11VertexBuffer.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glComputeEvaluator.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glComputeEvaluator.cpp`

 * *Files 2% similar despite different names*

```diff
@@ -28,15 +28,15 @@
 #include "../osd/glslPatchShaderSource.h"
 
 #include "../far/error.h"
 #include "../far/stencilTable.h"
 
 #include <cassert>
 #include <sstream>
-#include <string>
+#include <cstring>
 #include <vector>
 
 
 namespace OpenSubdiv {
 namespace OPENSUBDIV_VERSION {
 
 namespace Osd {
@@ -124,16 +124,16 @@
 
 // ---------------------------------------------------------------------------
 
 
 GLComputeEvaluator::GLComputeEvaluator()
     : _workGroupSize(64),
       _patchArraysSSBO(0) {
-    memset (&_stencilKernel, 0, sizeof(_stencilKernel));
-    memset (&_patchKernel, 0, sizeof(_patchKernel));
+    std::memset((void*) &_stencilKernel, 0, sizeof(_stencilKernel));
+    std::memset((void*) &_patchKernel, 0, sizeof(_patchKernel));
 
     // Initialize internal OpenGL loader library if necessary
     OpenSubdiv::internal::GLLoader::libraryInitializeGL();
 }
 
 GLComputeEvaluator::~GLComputeEvaluator() {
     if (_patchArraysSSBO) {
@@ -321,14 +321,16 @@
     if (duuWeightsBuffer)
         glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 13, duuWeightsBuffer);
     if (duvWeightsBuffer)
         glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 14, duvWeightsBuffer);
     if (dvvWeightsBuffer)
         glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 15, dvvWeightsBuffer);
 
+    GLint activeProgram;
+    glGetIntegerv(GL_CURRENT_PROGRAM, &activeProgram);
     glUseProgram(_stencilKernel.program);
 
     glUniform1i(_stencilKernel.uniformStart,     start);
     glUniform1i(_stencilKernel.uniformEnd,       end);
     glUniform1i(_stencilKernel.uniformSrcOffset, srcDesc.offset);
     glUniform1i(_stencilKernel.uniformDstOffset, dstDesc.offset);
     if (_stencilKernel.uniformDuDesc > 0) {
@@ -350,15 +352,15 @@
     if (_stencilKernel.uniformDvvDesc > 0) {
         glUniform3i(_stencilKernel.uniformDvvDesc,
                     dvvDesc.offset, dvvDesc.length, dvvDesc.stride);
     }
 
     glDispatchCompute((count + _workGroupSize - 1) / _workGroupSize, 1, 1);
 
-    glUseProgram(0);
+    glUseProgram(activeProgram);
 
     glMemoryBarrier(GL_TEXTURE_FETCH_BARRIER_BIT);
     for (int i = 0; i < 16; ++i) {
         glBindBufferBase(GL_SHADER_STORAGE_BUFFER, i, 0);
     }
 
     return true;
@@ -414,14 +416,16 @@
     glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 10, duuBuffer);
     glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 11, duvBuffer);
     glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 12, dvvBuffer);
     glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 5, patchCoordsBuffer);
     glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 6, patchIndexBuffer);
     glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 7, patchParamsBuffer);
 
+    GLint activeProgram;
+    glGetIntegerv(GL_CURRENT_PROGRAM, &activeProgram);
     glUseProgram(_patchKernel.program);
 
     glUniform1i(_patchKernel.uniformSrcOffset, srcDesc.offset);
     glUniform1i(_patchKernel.uniformDstOffset, dstDesc.offset);
 
     int patchArraySize = sizeof(PatchArray);
     glBindBuffer(GL_SHADER_STORAGE_BUFFER, _patchArraysSSBO);
@@ -452,15 +456,15 @@
     if (_patchKernel.uniformDvvDesc > 0) {
         glUniform3i(_patchKernel.uniformDvvDesc,
                     dvvDesc.offset, dvvDesc.length, dvvDesc.stride);
     }
 
     glDispatchCompute((numPatchCoords + _workGroupSize - 1) / _workGroupSize, 1, 1);
 
-    glUseProgram(0);
+    glUseProgram(activeProgram);
 
     glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, 0);
     glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, 0);
     glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, 0);
     glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 3, 0);
     glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 4, 0);
     glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 5, 0);
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glComputeEvaluator.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glComputeEvaluator.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glLegacyGregoryPatchTable.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glLegacyGregoryPatchTable.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glLegacyGregoryPatchTable.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glLegacyGregoryPatchTable.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glMesh.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glMesh.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glPatchTable.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glPatchTable.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glPatchTable.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glPatchTable.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glVertexBuffer.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glVertexBuffer.cpp`

 * *Files 8% similar despite different names*

```diff
@@ -55,15 +55,15 @@
     return 0;
 }
 
 void
 GLVertexBuffer::UpdateData(const float *src, int startVertex, int numVertices,
                            void * /*deviceContext*/) {
 
-    int size = numVertices * _numElements * sizeof(float);
+    int size = numVertices * _numElements * (int) sizeof(float);
 #if defined(GL_ARB_direct_state_access)
     if (OSD_OPENGL_HAS(ARB_direct_state_access)) {
         glNamedBufferSubData(_vbo,
                              startVertex * _numElements * sizeof(float),
 size, src);
     } else
 #endif
@@ -92,15 +92,15 @@
 
     return _vbo;
 }
 
 bool
 GLVertexBuffer::allocate() {
 
-    int size = _numElements * _numVertices * sizeof(float);
+    int size = _numElements * _numVertices * (int) sizeof(float);
 
 
 #if defined(GL_ARB_direct_state_access)
     if (OSD_OPENGL_HAS(ARB_direct_state_access)) {
         glCreateBuffers(1, &_vbo);
         glNamedBufferDataEXT(_vbo, size, 0, GL_DYNAMIC_DRAW);
     } else
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glVertexBuffer.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glVertexBuffer.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glXFBEvaluator.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glXFBEvaluator.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glXFBEvaluator.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glXFBEvaluator.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslComputeKernel.glsl` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslComputeKernel.glsl`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslPatchBSpline.glsl` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslPatchBSpline.glsl`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslPatchBoxSplineTriangle.glsl` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslPatchBoxSplineTriangle.glsl`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslPatchCommon.glsl` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslPatchCommon.glsl`

 * *Files 0% similar despite different names*

```diff
@@ -93,16 +93,16 @@
 
 // XXXdyu all downstream data can be handled by client code
 struct OutputVertex {
     vec4 position;
     vec3 normal;
     vec3 tangent;
     vec3 bitangent;
-    centroid vec4 patchCoord; // u, v, faceLevel, faceId
-    centroid vec2 tessCoord; // tesscoord.st
+    vec4 patchCoord; // u, v, faceLevel, faceId
+    vec2 tessCoord; // tesscoord.st
 #if defined OSD_COMPUTE_NORMAL_DERIVATIVES
     vec3 Nu;
     vec3 Nv;
 #endif
 };
 
 // osd shaders need following functions defined
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslPatchCommonTess.glsl` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslPatchCommonTess.glsl`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslPatchGregory.glsl` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslPatchGregory.glsl`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslPatchGregoryBasis.glsl` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslPatchGregoryBasis.glsl`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslPatchGregoryTriangle.glsl` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslPatchGregoryTriangle.glsl`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslPatchLegacy.glsl` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslPatchLegacy.glsl`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslPatchShaderSource.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslPatchShaderSource.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslPatchShaderSource.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslPatchShaderSource.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/glslXFBKernel.glsl` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/glslXFBKernel.glsl`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/hlslComputeKernel.hlsl` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/hlslComputeKernel.hlsl`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/hlslPatchBSpline.hlsl` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/hlslPatchBSpline.hlsl`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/hlslPatchBoxSplineTriangle.hlsl` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/hlslPatchBoxSplineTriangle.hlsl`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/hlslPatchCommon.hlsl` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/hlslPatchCommon.hlsl`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/hlslPatchCommonTess.hlsl` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/hlslPatchCommonTess.hlsl`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/hlslPatchGregory.hlsl` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/hlslPatchGregory.hlsl`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/hlslPatchGregoryBasis.hlsl` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/hlslPatchGregoryBasis.hlsl`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/hlslPatchGregoryTriangle.hlsl` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/hlslPatchGregoryTriangle.hlsl`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/hlslPatchLegacy.hlsl` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/hlslPatchLegacy.hlsl`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/hlslPatchShaderSource.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/hlslPatchShaderSource.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/hlslPatchShaderSource.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/hlslPatchShaderSource.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mesh.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mesh.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlCommon.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlCommon.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlComputeEvaluator.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlComputeEvaluator.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlComputeEvaluator.mm` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlComputeEvaluator.mm`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlComputeKernel.metal` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlComputeKernel.metal`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlLegacyGregoryPatchTable.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlLegacyGregoryPatchTable.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlLegacyGregoryPatchTable.mm` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlLegacyGregoryPatchTable.mm`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlMesh.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlMesh.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchBSpline.metal` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchBSpline.metal`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchBoxSplineTriangle.metal` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchBoxSplineTriangle.metal`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchCommon.metal` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchCommon.metal`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchCommonTess.metal` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchCommonTess.metal`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchGregory.metal` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchGregory.metal`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchGregoryBasis.metal` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchGregoryBasis.metal`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchGregoryTriangle.metal` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchGregoryTriangle.metal`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchLegacy.metal` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchLegacy.metal`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchShaderSource.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchShaderSource.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchShaderSource.mm` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchShaderSource.mm`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchTable.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchTable.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlPatchTable.mm` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlPatchTable.mm`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlVertexBuffer.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlVertexBuffer.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/mtlVertexBuffer.mm` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/mtlVertexBuffer.mm`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/nonCopyable.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/nonCopyable.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/ompEvaluator.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/ompEvaluator.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/ompEvaluator.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/ompEvaluator.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/ompKernel.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/ompKernel.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/ompKernel.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/ompKernel.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/opencl.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/opencl.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/opengl.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/opengl.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/patchBasisCommon.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/patchBasisCommon.h`

 * *Files 2% similar despite different names*

```diff
@@ -61,16 +61,16 @@
             for(int i=0;i<4;i++) {
                 wDss[i] = 0.0f;
                 wDtt[i] = 0.0f;
             }
 
             wDst[0] =  1.0f;
             wDst[1] = -1.0f;
-            wDst[2] = -1.0f;
-            wDst[3] =  1.0f;
+            wDst[2] =  1.0f;
+            wDst[3] = -1.0f;
         }
     }
     return 4;
 }
 
 // namespace {
     //
@@ -345,15 +345,19 @@
 
     //  Use <= here to avoid compiler warnings -- the sums should always be non-negative:
     OSD_REAL df0 = s  + t;   df0 = (df0 <= 0.0f) ? 1.0f : (1.0f / df0);
     OSD_REAL df1 = sC + t;   df1 = (df1 <= 0.0f) ? 1.0f : (1.0f / df1);
     OSD_REAL df2 = sC + tC;  df2 = (df2 <= 0.0f) ? 1.0f : (1.0f / df2);
     OSD_REAL df3 = s  + tC;  df3 = (df3 <= 0.0f) ? 1.0f : (1.0f / df3);
 
-    OSD_REAL G[8] = OSD_ARRAY_8(OSD_REAL, s*df0, t*df0,  t*df1, sC*df1,  sC*df2, tC*df2,  tC*df3, s*df3 );
+    //  Make sure the G[i] for pairs of interior points sum to 1 in all cases:
+    OSD_REAL G[8] = OSD_ARRAY_8(OSD_REAL,  s*df0, (1.0f -  s*df0),
+                                           t*df1, (1.0f -  t*df1),
+                                          sC*df2, (1.0f - sC*df2),
+                                          tC*df3, (1.0f - tC*df3) );
 
     //  Combined weights for boundary and interior points:
     for (int i = 0; i < 12; ++i) {
         wP[boundaryGregory[i]] = Bs[boundaryBezSCol[i]] * Bt[boundaryBezTRow[i]];
     }
     for (int j = 0; j < 8; ++j) {
         wP[interiorGregory[j]] = Bs[interiorBezSCol[j]] * Bt[interiorBezTRow[j]] * G[j];
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/patchBasisCommonEval.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/patchBasisCommonEval.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/patchBasisCommonTypes.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/patchBasisCommonTypes.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/tbbEvaluator.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/tbbEvaluator.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/tbbEvaluator.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/tbbEvaluator.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/tbbKernel.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/tbbKernel.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/tbbKernel.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/tbbKernel.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/osd/types.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/osd/types.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/sdc/CMakeLists.txt` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/sdc/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/sdc/bilinearScheme.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/sdc/bilinearScheme.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/sdc/catmarkScheme.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/sdc/catmarkScheme.h`

 * *Files 0% similar despite different names*

```diff
@@ -27,16 +27,14 @@
 #include "../version.h"
 
 #include "../sdc/scheme.h"
 
 #include <cassert>
 #include <cmath>
 
-#define kPI (3.14159265358979323846)
-
 namespace OpenSubdiv {
 namespace OPENSUBDIV_VERSION {
 
 namespace Sdc {
 
 //
 //  Specializations for Scheme<SCHEME_CATMARK>:
@@ -275,17 +273,19 @@
         posMask.EdgeWeight(3) = eWeight;
 
         posMask.FaceWeight(0) = fWeight;
         posMask.FaceWeight(1) = fWeight;
         posMask.FaceWeight(2) = fWeight;
         posMask.FaceWeight(3) = fWeight;
     } else {
-        Weight fWeight = 1.0f / (Weight)(valence * (valence + 5.0f));
+        Weight Valence = (Weight) valence;
+
+        Weight fWeight = 1.0f / (Valence * (Valence + 5.0f));
         Weight eWeight = 4.0f * fWeight;
-        Weight vWeight = (Weight)(1.0f - valence * (eWeight + fWeight));
+        Weight vWeight = 1.0f - Valence * (eWeight + fWeight);
 
         posMask.VertexWeight(0) = vWeight;
         for (int i = 0; i < valence; ++i) {
             posMask.EdgeWeight(i) = eWeight;
             posMask.FaceWeight(i) = fWeight;
         }
     }
@@ -330,14 +330,16 @@
 
 template <>
 template <typename VERTEX, typename MASK>
 inline void
 Scheme<SCHEME_CATMARK>::assignCreaseLimitTangentMasks(VERTEX const& vertex,
         MASK& tan1Mask, MASK& tan2Mask, int const creaseEnds[2]) const {
 
+    constexpr auto kPI = 3.14159265358979323846;
+
     typedef typename MASK::Weight Weight;
 
     //
     //  First, the tangent along the crease:
     //      The first crease edge is considered the "leading" edge of the span
     //  of surface for which we are evaluating tangents and the second edge the
     //  "trailing edge".  By convention, the tangent along the crease is oriented
@@ -449,14 +451,15 @@
 
 template <>
 template <typename VERTEX, typename MASK>
 inline void
 Scheme<SCHEME_CATMARK>::assignSmoothLimitTangentMasks(VERTEX const& vertex,
         MASK& tan1Mask, MASK& tan2Mask) const {
 
+    constexpr auto kPI = 3.14159265358979323846;
     typedef typename MASK::Weight Weight;
 
     int valence = vertex.GetNumFaces();
     if (valence == 2) {
         assignCornerLimitTangentMasks(vertex, tan1Mask, tan2Mask);
         return;
     }
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/sdc/crease.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/sdc/crease.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/sdc/crease.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/sdc/crease.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/sdc/loopScheme.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/sdc/loopScheme.h`

 * *Files 1% similar despite different names*

```diff
@@ -27,21 +27,20 @@
 #include "../version.h"
 
 #include "../sdc/scheme.h"
 
 #include <cassert>
 #include <cmath>
 
-
-#define kPI (3.14159265358979323846)
-
 namespace OpenSubdiv {
 namespace OPENSUBDIV_VERSION {
 namespace Sdc {
 
+constexpr auto kPI = 3.14159265358979323846;
+//constexpr auto kPI_2 = kPI/2.0;
 
 //
 //  Specializations for Sdc::Scheme<SCHEME_LOOP>:
 //
 //
 
 //
@@ -198,16 +197,15 @@
     if (valence != 6) {
         //  From HbrLoopSubdivision<T>::Subdivide(mesh, vertex):
         //     - could use some lookup tables here for common irregular valence (5, 7, 8)
         //       or all of these cosine calls will be adding up...
 
         double dValence   = (double) valence;
         double invValence = 1.0f / dValence;
-        double cosTheta =
-            std::cos(3.14159265358979323846f * 2.0f * invValence);
+        double cosTheta   = std::cos(kPI * 2.0f * invValence);
 
         double beta = 0.25f * cosTheta + 0.375f;
 
         eWeight = (Weight) ((0.625f - (beta * beta)) * invValence);
         vWeight = (Weight) (1.0f - (eWeight * dValence));
     }
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/sdc/options.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/sdc/options.h`

 * *Files 5% similar despite different names*

```diff
@@ -85,41 +85,42 @@
     //  Trivial get/set methods:
     //
 
     /// \brief Get vertex boundary interpolation rule
     VtxBoundaryInterpolation GetVtxBoundaryInterpolation() const { return (VtxBoundaryInterpolation) _vtxBoundInterp; }
 
     /// \brief Set vertex boundary interpolation rule
-    void SetVtxBoundaryInterpolation(VtxBoundaryInterpolation b) { _vtxBoundInterp = b; }
+    void SetVtxBoundaryInterpolation(VtxBoundaryInterpolation b) { _vtxBoundInterp = (EnumIntType) b; }
 
     /// \brief Get face-varying interpolation rule
     FVarLinearInterpolation GetFVarLinearInterpolation() const { return (FVarLinearInterpolation) _fvarLinInterp; }
 
     /// \brief Set face-varying interpolation rule
-    void SetFVarLinearInterpolation(FVarLinearInterpolation b) { _fvarLinInterp = b; }
+    void SetFVarLinearInterpolation(FVarLinearInterpolation b) { _fvarLinInterp = (EnumIntType) b; }
 
     /// \brief Get edge crease rule
     CreasingMethod GetCreasingMethod() const { return (CreasingMethod) _creasingMethod; }
 
     /// \brief Set edge crease rule
-    void SetCreasingMethod(CreasingMethod c) { _creasingMethod = c; }
+    void SetCreasingMethod(CreasingMethod c) { _creasingMethod = (EnumIntType) c; }
 
     /// \brief Get triangle subdivision weights rule (Catmark scheme only !)
     TriangleSubdivision GetTriangleSubdivision() const { return (TriangleSubdivision) _triangleSub; }
 
     /// \brief Set triangle subdivision weights rule (Catmark scheme only !)
-    void SetTriangleSubdivision(TriangleSubdivision t) { _triangleSub = t; }
+    void SetTriangleSubdivision(TriangleSubdivision t) { _triangleSub = (EnumIntType) t; }
 
 private:
+    //  Use a small integer type to pack these rather than bitfields:
+    typedef unsigned char EnumIntType;
 
-    //  Bitfield members:
-    unsigned int _vtxBoundInterp  : 2,
-                 _fvarLinInterp   : 3,
-                 _creasingMethod  : 2,
-                 _triangleSub     : 2;
+    EnumIntType _vtxBoundInterp;
+    EnumIntType _fvarLinInterp;
+    EnumIntType _creasingMethod;
+    EnumIntType _triangleSub;
 };
 
 } // end namespace sdc
 
 } // end namespace OPENSUBDIV_VERSION
 using namespace OPENSUBDIV_VERSION;
 } // end namespace OpenSubdiv
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/sdc/scheme.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/sdc/scheme.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/sdc/typeTraits.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/sdc/typeTraits.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/sdc/types.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/sdc/types.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/tools/stringify/CMakeLists.txt` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/tools/stringify/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/tools/stringify/main.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/tools/stringify/main.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/version.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/version.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/version.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/version.h`

 * *Files 12% similar despite different names*

```diff
@@ -21,21 +21,21 @@
 //   KIND, either express or implied. See the Apache License for the specific
 //   language governing permissions and limitations under the Apache License.
 //
 
 #ifndef OPENSUBDIV3_VERSION_H
 #define OPENSUBDIV3_VERSION_H
 
-#define OPENSUBDIV_VERSION v3_4_3
+#define OPENSUBDIV_VERSION v3_5_0
 
-#define OPENSUBDIV_VERSION_NUMBER 30403
+#define OPENSUBDIV_VERSION_NUMBER 30500
 
 #define OPENSUBDIV_VERSION_MAJOR 3
-#define OPENSUBDIV_VERSION_MINOR 4
-#define OPENSUBDIV_VERSION_PATCH 3
+#define OPENSUBDIV_VERSION_MINOR 5
+#define OPENSUBDIV_VERSION_PATCH 0
 
 namespace OpenSubdiv {
 namespace OPENSUBDIV_VERSION {
 
 
 } // end namespace OPENSUBDIV_VERSION
 using namespace OPENSUBDIV_VERSION;
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/CMakeLists.txt` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/array.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/array.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/componentInterfaces.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/componentInterfaces.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/fvarLevel.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/fvarLevel.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/fvarLevel.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/fvarLevel.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/fvarRefinement.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/fvarRefinement.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/fvarRefinement.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/fvarRefinement.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/level.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/level.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/level.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/level.h`

 * *Files 2% similar despite different names*

```diff
@@ -96,15 +96,15 @@
     //
     struct VTag {
         VTag() { }
 
         //  When cleared, the VTag ALMOST represents a smooth, regular, interior
         //  vertex -- the Type enum requires a bit be explicitly set for Smooth,
         //  so that must be done explicitly if desired on initialization.
-        void clear() { std::memset(this, 0, sizeof(VTag)); }
+        void clear() { std::memset((void*) this, 0, sizeof(VTag)); }
 
         typedef unsigned short VTagSize;
 
         VTagSize _nonManifold     : 1;  // fixed
         VTagSize _xordinary       : 1;  // fixed
         VTagSize _boundary        : 1;  // fixed
         VTagSize _corner          : 1;  // fixed
@@ -137,15 +137,15 @@
 
         static VTag BitwiseOr(VTag const vTags[], int size = 4);
     };
     struct ETag {
         ETag() { }
 
         //  When cleared, the ETag represents a smooth, manifold, interior edge
-        void clear() { std::memset(this, 0, sizeof(ETag)); }
+        void clear() { std::memset((void*) this, 0, sizeof(ETag)); }
 
         typedef unsigned char ETagSize;
 
         ETagSize _nonManifold  : 1;  // fixed
         ETagSize _boundary     : 1;  // fixed
         ETagSize _infSharp     : 1;  // fixed
         ETagSize _semiSharp    : 1;  // variable
@@ -161,15 +161,15 @@
         }
 
         static ETag BitwiseOr(ETag const eTags[], int size = 4);
     };
     struct FTag {
         FTag() { }
 
-        void clear() { std::memset(this, 0, sizeof(FTag)); }
+        void clear() { std::memset((void*) this, 0, sizeof(FTag)); }
 
         typedef unsigned char FTagSize;
 
         FTagSize _hole  : 1;  // fixed
 
         //  On deck -- coming soon...
         //FTagSize _hasEdits : 1;  // variable
@@ -187,17 +187,17 @@
     //  non-manifold cases, e.g. periodic spans at the apex of a double cone.
     //
     //  Currently setting the size to 0 or leaving the span "unassigned" is an
     //  indication to use the full neighborhood rather than a subset -- prefer
     //  use of the const method here to direct inspection of the member.
     //
     struct VSpan {
-        VSpan() { std::memset(this, 0, sizeof(VSpan)); }
+        VSpan() { std::memset((void*) this, 0, sizeof(VSpan)); }
 
-        void clear()            { std::memset(this, 0, sizeof(VSpan)); }
+        void clear()            { std::memset((void*) this, 0, sizeof(VSpan)); }
         bool isAssigned() const { return _numFaces > 0; }
 
         LocalIndex _numFaces;
         LocalIndex _startFace;
         LocalIndex _cornerInSpan;
 
         unsigned short _periodic : 1;
@@ -797,15 +797,15 @@
 //
 inline void
 Level::resizeFaces(int faceCount) {
     _faceCount = faceCount;
     _faceVertCountsAndOffsets.resize(2 * faceCount);
 
     _faceTags.resize(faceCount);
-    std::memset(&_faceTags[0], 0, _faceCount * sizeof(FTag));
+    std::memset((void*) &_faceTags[0], 0, _faceCount * sizeof(FTag));
 }
 inline void
 Level::resizeFaceVertices(int totalFaceVertCount) {
     _faceVertIndices.resize(totalFaceVertCount);
 }
 inline void
 Level::resizeFaceEdges(int totalFaceEdgeCount) {
@@ -818,15 +818,15 @@
     _edgeCount = edgeCount;
     _edgeFaceCountsAndOffsets.resize(2 * edgeCount);
 
     _edgeSharpness.resize(edgeCount);
     _edgeTags.resize(edgeCount);
 
     if (edgeCount>0) {
-        std::memset(&_edgeTags[0], 0, _edgeCount * sizeof(ETag));
+        std::memset((void*) &_edgeTags[0], 0, _edgeCount * sizeof(ETag));
     }
 }
 inline void
 Level::resizeEdgeVertices() {
 
     _edgeVertIndices.resize(2 * _edgeCount);
 }
@@ -842,15 +842,15 @@
 
     _vertCount = vertCount;
     _vertFaceCountsAndOffsets.resize(2 * vertCount);
     _vertEdgeCountsAndOffsets.resize(2 * vertCount);
 
     _vertSharpness.resize(vertCount);
     _vertTags.resize(vertCount);
-    std::memset(&_vertTags[0], 0, _vertCount * sizeof(VTag));
+    std::memset((void*) &_vertTags[0], 0, _vertCount * sizeof(VTag));
 }
 inline void
 Level::resizeVertexFaces(int totalVertFaceCount) {
 
     _vertFaceIndices.resize(totalVertFaceCount);
     _vertFaceLocalIndices.resize(totalVertFaceCount);
 }
```

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/quadRefinement.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/quadRefinement.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/quadRefinement.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/quadRefinement.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/refinement.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/refinement.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/refinement.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/refinement.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/sparseSelector.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/sparseSelector.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/sparseSelector.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/sparseSelector.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/stackBuffer.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/stackBuffer.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/triRefinement.cpp` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/triRefinement.cpp`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/triRefinement.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/triRefinement.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/osd/opensubdiv/vtr/types.h` & `tinyusdz-0.8.0rc1/src/osd/opensubdiv/vtr/types.h`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/pxr-compat.cc` & `tinyusdz-0.8.0rc1/src/pxr-compat.cc`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/pxr-compat.hh` & `tinyusdz-0.8.0rc1/src/pxr-compat.hh`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/stream-reader.hh` & `tinyusdz-0.8.0rc1/src/stream-reader.hh`

 * *Files 2% similar despite different names*

```diff
@@ -104,15 +104,15 @@
 } // namespace
 
 ///
 /// Simple stream reader
 ///
 class StreamReader {
  public:
-  explicit StreamReader(const uint8_t *binary, const size_t length,
+  explicit StreamReader(const uint8_t *binary, const uint64_t length,
                         const bool swap_endian)
       : binary_(binary), length_(length), swap_endian_(swap_endian), idx_(0) {
     (void)pad_;
   }
 
   bool seek_set(const uint64_t offset) const {
     if (offset > length_) {
@@ -124,37 +124,39 @@
   }
 
   bool seek_from_current(const int64_t offset) const {
     if ((int64_t(idx_) + offset) < 0) {
       return false;
     }
 
-    if (size_t((int64_t(idx_) + offset)) > length_) {
+    if (uint64_t((int64_t(idx_) + offset)) > length_) {
       return false;
     }
 
-    idx_ = size_t(int64_t(idx_) + offset);
+    idx_ = uint64_t(int64_t(idx_) + offset);
     return true;
   }
 
-  size_t read(const size_t n, const uint64_t dst_len, uint8_t *dst) const {
-    size_t len = n;
+  uint64_t read(const uint64_t n, const uint64_t dst_len, uint8_t *dst) const {
+    uint64_t len = n;
     if ((idx_ + len) > length_) {
-      len = length_ - size_t(idx_);
+      len = length_ - uint64_t(idx_);
     }
 
     if (len > 0) {
       if (dst_len < len) {
         // dst does not have enough space. return 0 for a while.
         return 0;
       }
 
-      memcpy(dst, &binary_[idx_], len);
-      idx_ += len;
-      return len;
+      size_t nbytes = size_t(len); // may shorten size on 32bit platform
+
+      memcpy(dst, &binary_[idx_], nbytes);
+      idx_ += nbytes;
+      return nbytes;
 
     } else {
       return 0;
     }
   }
 
   bool read1(uint8_t *ret) const {
@@ -337,25 +339,25 @@
       return false;
     }
 
     return true;
   }
 #endif
 
-  size_t tell() const { return size_t(idx_); }
+  uint64_t tell() const { return uint64_t(idx_); }
   bool eof() const { return idx_ >= length_; }
 
   const uint8_t *data() const { return binary_; }
 
   bool swap_endian() const { return swap_endian_; }
 
-  size_t size() const { return length_; }
+  uint64_t size() const { return length_; }
 
  private:
   const uint8_t *binary_;
-  const size_t length_;
+  const uint64_t length_;
   bool swap_endian_;
   char pad_[7];
   mutable uint64_t idx_;
 };
 
 } // namespace tinyusdz
```

### Comparing `tinyusdz-0.8.0rc0/src/stream-writer.hh` & `tinyusdz-0.8.0rc1/src/stream-writer.hh`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/subdiv.cc` & `tinyusdz-0.8.0rc1/src/subdiv.cc`

 * *Files 4% similar despite different names*

```diff
@@ -1,13 +1,25 @@
+// SPDX-License-Identifier: MIT
+// Copyright 2020-Present Syoyo Fujita.
+
+#ifdef _MSC_VER
+#ifndef _USE_MATH_DEFINES
+#define _USE_MATH_DEFINES
+#endif
+#endif
+
 #include <chrono>
 #include <fstream>
 #include <iostream>
+#include <string>
 
 #include "subdiv.hh"
 
+#include "common-macros.inc"
+
 #ifdef __clang__
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Weverything"
 #endif
 
 #include <opensubdiv/far/primvarRefiner.h>
 #include <opensubdiv/far/topologyDescriptor.h>
@@ -54,29 +66,30 @@
     a += weight * src.a;
   }
 
   // Basic 'color' layout channel
   float r, g, b, a;
 };
 
-void subdivide(int subd_level, const ControlQuadMesh &in_mesh, SubdividedMesh *out_mesh,
+bool subdivide(int subd_level, const ControlQuadMesh &in_mesh, SubdividedMesh *out_mesh,
+               std::string *err,
                bool dump) {
   if (subd_level < 0) {
     subd_level = 0;
   }
 
-  std::cout << "SubD: level = " << subd_level << "\n";
+  DCOUT("SubD: level = " << subd_level);
 
   const auto start_t = std::chrono::system_clock::now();
 
   int maxlevel = subd_level;
 
   if (maxlevel > 8) {
     maxlevel = 8;
-    std::cout << "SubD: limit subd level to " << maxlevel << "\n";
+    DCOUT("SubD: limit subd level to " << maxlevel);
   }
 
   typedef Far::TopologyDescriptor Descriptor;
 
   Sdc::SchemeType type = OpenSubdiv::Sdc::SCHEME_CATMARK;
 
   Sdc::Options options;
@@ -189,15 +202,15 @@
     Far::TopologyLevel const &refLastLevel = refiner->GetLevel(maxlevel);
 
     int nverts = refLastLevel.GetNumVertices();
     // int nuvs   = refLastLevel.GetNumFVarValues(channelUV);
     // int ncolors= refLastLevel.GetNumFVarValues(channelColor);
     int nfaces = refLastLevel.GetNumFaces();
 
-    std::cout << "nverts = " << nverts << ", nfaces = " << nfaces << "\n";
+    DCOUT("nverts = " << nverts << ", nfaces = " << nfaces);
 
     // Print vertex positions
     int firstOfLastVerts = refiner->GetNumVerticesTotal() - nverts;
 
     out_mesh->vertices.resize(size_t(nverts) * 3);
 
     for (size_t vert = 0; vert < size_t(nverts); ++vert) {
@@ -236,15 +249,20 @@
     for (int face = 0; face < nfaces; ++face) {
       Far::ConstIndexArray fverts = refLastLevel.GetFaceVertices(face);
       // Far::ConstIndexArray fuvs   = refLastLevel.GetFaceFVarValues(face,
       // channelUV);
 
       // all refined Catmark faces should be quads
       // assert(fverts.size()==4 && fuvs.size()==4);
-      assert(fverts.size() == 4);
+      if (fverts.size() != 4) {
+        if (err) {
+          (*err) += "All refined Catmark faces should be quads.\n";
+        }
+        return false;
+      }
 
       out_mesh->face_index_offsets.push_back(uint32_t(out_mesh->face_num_verts.size()));
 
       out_mesh->face_num_verts.push_back(uint8_t(fverts.size()));
 
       if (dump) {
         ofs << "f";
@@ -285,15 +303,18 @@
   }
 
   const auto end_t = std::chrono::system_clock::now();
   const double elapsed = double(
       std::chrono::duration_cast<std::chrono::milliseconds>(end_t - start_t)
           .count());
 
-  std::cout << "SubD time : " << elapsed << " [ms]\n";
+  (void)elapsed;
+  DCOUT("SubD time : " << elapsed << " [ms]");
 
   if (dump) {
     std::cout << "dumped subdivided mesh as `subd.obj`\n";
   }
+
+  return true;
 }
 
 }  // namespace tinyusdz
```

### Comparing `tinyusdz-0.8.0rc0/src/subdiv.hh` & `tinyusdz-0.8.0rc1/src/subdiv.hh`

 * *Files 2% similar despite different names*

```diff
@@ -99,11 +99,11 @@
 /// Uniformly subdivide the mesh.
 ///
 /// @param[in] level Subdivision level.
 /// @param[in] in_mesh Input quad mesh.
 /// @param[out] out_mesh Subdivided mesh.
 /// @param[in] dump Dump .obj for debugging.
 ///
-void subdivide(int level, const ControlQuadMesh &in_mesh,
-               SubdividedMesh *out_mesh, bool dump = false);
+bool subdivide(int level, const ControlQuadMesh &in_mesh,
+               SubdividedMesh *out_mesh, std::string *err, bool dump = false);
 
 }  // namespace tinyusdz
```

### Comparing `tinyusdz-0.8.0rc0/src/texture-types.hh` & `tinyusdz-0.8.0rc1/src/texture-types.hh`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/tiny-any.inc` & `tinyusdz-0.8.0rc1/src/tiny-any.inc`

 * *Files 3% similar despite different names*

```diff
@@ -11,17 +11,17 @@
 // Copyright (c) 2016 Denilson das Mercs Amorim
 //
 // Distributed under the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 //
 // TinyUSDZ modification
 // - Disable exceptions, RTTI
-// - Use type_id with TypeTrait<T>::type_id
-// - Use type_name with TypeTrait<T>::type_name
-// - Assume this tiny-any.inc is included inside value-type.hh (since TypeTrait<T> implementations are required)
+// - Use type_id with TypeTraits<T>::type_id
+// - Use type_name with TypeTraits<T>::type_name
+// - Assume this tiny-any.inc is included inside value-type.hh (since TypeTraits<T> implementations are required)
 //
 #ifndef LINB_ANY_HPP
 #define LINB_ANY_HPP
 #pragma once
 
 //#include <typeinfo>
 #include <type_traits>
@@ -33,15 +33,15 @@
 //#include "value-type.hh"
 
 namespace tinyusdz {
 namespace value {
 
 // Forward decl.
 template<typename dtype>
-class TypeTrait;
+class TypeTraits;
 
 } // namespace value
 } // namespace tinyusdz
 #endif
 
 #ifndef ANY_IMPL_NO_EXCEPTIONS
 #define ANY_IMPL_NO_EXCEPTIONS
@@ -188,30 +188,30 @@
         return empty()? typeid(void) : this->vtable->type();
     }
 #endif
 
 #if 1 // tinyusdz
     uint32_t type_id() const noexcept
     {
-        return empty()? tinyusdz::value::TypeTrait<void>::type_id : this->vtable->type_id();
+        return empty()? tinyusdz::value::TypeTraits<void>::type_id() : this->vtable->type_id();
     }
 
     uint32_t underlying_type_id() const noexcept
     {
-        return empty()? tinyusdz::value::TypeTrait<void>::underlying_type_id : this->vtable->underlying_type_id();
+        return empty()? tinyusdz::value::TypeTraits<void>::underlying_type_id() : this->vtable->underlying_type_id();
     }
 
     const std::string type_name() const noexcept
     {
-        return empty()? tinyusdz::value::TypeTrait<void>::type_name() : this->vtable->type_name();
+        return empty()? tinyusdz::value::TypeTraits<void>::type_name() : this->vtable->type_name();
     }
 
     const std::string underlying_type_name() const noexcept
     {
-        return empty()? tinyusdz::value::TypeTrait<void>::underlying_type_name() : this->vtable->underlying_type_name();
+        return empty()? tinyusdz::value::TypeTraits<void>::underlying_type_name() : this->vtable->underlying_type_name();
     }
 #endif
 
     /// Exchange the states of *this and rhs.
     void swap(any& rhs) noexcept
     {
         if(this->vtable != rhs.vtable)
@@ -237,14 +237,32 @@
         else // same types
         {
             if(this->vtable != nullptr)
                 this->vtable->swap(this->storage, rhs.storage);
         }
     }
 
+    /// Casts (with no type_info checks) the storage pointer as const T*.
+    template<typename T>
+    const T* cast() const noexcept
+    {
+        return requires_allocation<typename std::decay<T>::type>::value?
+            reinterpret_cast<const T*>(storage.dynamic) :
+            reinterpret_cast<const T*>(&storage.stack);
+    }
+
+    /// Casts (with no type_info checks) the storage pointer as T*.
+    template<typename T>
+    T* cast() noexcept
+    {
+        return requires_allocation<typename std::decay<T>::type>::value?
+            reinterpret_cast<T*>(storage.dynamic) :
+            reinterpret_cast<T*>(&storage.stack);
+    }
+
 private: // Storage and Virtual Method Table
 
     union storage_union
     {
         using stack_storage_t = typename std::aligned_storage<2 * sizeof(void*), std::alignment_of<void*>::value>::type;
 
         void*               dynamic;
@@ -295,30 +313,30 @@
             return typeid(T);
         }
 #endif
 
 #if 1 // tinyusdz
         static uint32_t type_id() noexcept
         {
-            return tinyusdz::value::TypeTrait<T>::type_id;
+            return tinyusdz::value::TypeTraits<T>::type_id();
         }
 
         static uint32_t underlying_type_id() noexcept
         {
-            return tinyusdz::value::TypeTrait<T>::underlying_type_id;
+            return tinyusdz::value::TypeTraits<T>::underlying_type_id();
         }
 
         static const std::string type_name() noexcept
         {
-            return tinyusdz::value::TypeTrait<T>::type_name();
+            return tinyusdz::value::TypeTraits<T>::type_name();
         }
 
         static const std::string underlying_type_name() noexcept
         {
-            return tinyusdz::value::TypeTrait<T>::underlying_type_name();
+            return tinyusdz::value::TypeTraits<T>::underlying_type_name();
         }
 #endif
 
         static void destroy(storage_union& storage) noexcept
         {
             //assert(reinterpret_cast<T*>(storage.dynamic));
             delete reinterpret_cast<T*>(storage.dynamic);
@@ -352,30 +370,30 @@
             return typeid(T);
         }
 #endif
 
 #if 1 // tinyusdz
         static uint32_t type_id() noexcept
         {
-            return tinyusdz::value::TypeTrait<T>::type_id;
+            return tinyusdz::value::TypeTraits<T>::type_id();
         }
 
         static uint32_t underlying_type_id() noexcept
         {
-            return tinyusdz::value::TypeTrait<T>::underlying_type_id;
+            return tinyusdz::value::TypeTraits<T>::underlying_type_id();
         }
 
         static const std::string type_name() noexcept
         {
-            return tinyusdz::value::TypeTrait<T>::type_name();
+            return tinyusdz::value::TypeTraits<T>::type_name();
         }
 
         static const std::string underlying_type_name() noexcept
         {
-            return tinyusdz::value::TypeTrait<T>::underlying_type_name();
+            return tinyusdz::value::TypeTraits<T>::underlying_type_name();
         }
 #endif
 
         static void destroy(storage_union& storage) noexcept
         {
             reinterpret_cast<T*>(&storage.stack)->~T();
         }
@@ -460,31 +478,14 @@
         return &a == &b;
 #else
         return a == b;
 #endif
     }
 #endif
 
-    /// Casts (with no type_info checks) the storage pointer as const T*.
-    template<typename T>
-    const T* cast() const noexcept
-    {
-        return requires_allocation<typename std::decay<T>::type>::value?
-            reinterpret_cast<const T*>(storage.dynamic) :
-            reinterpret_cast<const T*>(&storage.stack);
-    }
-
-    /// Casts (with no type_info checks) the storage pointer as T*.
-    template<typename T>
-    T* cast() noexcept
-    {
-        return requires_allocation<typename std::decay<T>::type>::value?
-            reinterpret_cast<T*>(storage.dynamic) :
-            reinterpret_cast<T*>(&storage.stack);
-    }
 
 private:
     storage_union storage; // on offset(0) so no padding for align
     vtable_type*  vtable;
 
     template<typename ValueType, typename T>
     typename std::enable_if<requires_allocation<T>::value>::type
@@ -594,21 +595,35 @@
 inline ValueType* any_cast(any* operand) noexcept
 {
     using T = typename std::decay<ValueType>::type;
 
 #ifndef ANY_IMPL_NO_RTTI
     if (operand && operand->is_typed(typeid(T)))
 #else
-    if (operand && operand->vtable == any::vtable_for_type<T>())
+    //if (operand && operand->vtable == any::vtable_for_type<T>())
+    if (operand && operand->type_id() == tinyusdz::value::TypeTraits<T>::type_id())
 #endif
         return operand->cast<ValueType>();
     else
         return nullptr;
 }
 
+// Force cast(no type check)
+template<typename ValueType>
+inline const ValueType* cast(const any* operand) noexcept
+{
+    return operand->cast<ValueType>();
+}
+
+template<typename ValueType>
+inline ValueType* cast(any* operand) noexcept
+{
+    return operand->cast<ValueType>();
+}
+
 }
 
 namespace std
 {
     inline void swap(linb::any& lhs, linb::any& rhs) noexcept
     {
         lhs.swap(rhs);
```

### Comparing `tinyusdz-0.8.0rc0/src/tiny-variant.hh` & `tinyusdz-0.8.0rc1/src/tiny-variant.hh`

 * *Files 4% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 // Based on
 // https://gist.github.com/calebh/fd00632d9c616d4b0c14e7c2865f3085
 //
 // Modification by Syoyo Fujita.
-// - Use tinyusdz::value::TypeTrait for type_id
+// - Use tinyusdz::value::TypeTraits for type_id
 // - Disable exception
 // - Implement set and get, get_if
 //
 
 /*
 This is free and unencumbered software released into the public domain.
 Anyone is free to copy, modify, publish, use, compile, sell, or
@@ -30,26 +30,28 @@
 For more information, please refer to <http://unlicense.org/>
 */
 #pragma once
 
 #include <iostream>
 #include <string>
 
-#include "value-types.hh" // import TypeTrait
+#include "value-types.hh" // import TypeTraits
 
 #ifdef __clang__
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Weverything"
 #endif
 
 #include "nonstd/optional.hpp" // for optional<T>& get()
 
 
 namespace tinyusdz {
 
+namespace variant_detail {
+
 // Equivalent to std::aligned_storage
 template <unsigned int Len, unsigned int Align>
 struct aligned_storage {
   struct type {
     alignas(Align) unsigned char data[Len];
   };
 };
@@ -84,34 +86,34 @@
 
 template <typename... Ts>
 struct variant_helper_rec;
 
 template <typename F, typename... Ts>
 struct variant_helper_rec<F, Ts...> {
   inline static void destroy(uint32_t id, void* data) {
-    if (value::TypeTrait<F>::type_id == id) {
+    if (value::TypeTraits<F>::type_id == id) {
       reinterpret_cast<F*>(data)->~F();
     } else {
       variant_helper_rec<Ts...>::destroy(id, data);
     }
   }
 
   inline static void move(uint32_t id, void* from, void* to) {
-    if (value::TypeTrait<F>::type_id == id) {
+    if (value::TypeTraits<F>::type_id == id) {
       // This static_cast and use of remove_reference is equivalent to the use
       // of std::move
       new (to) F(static_cast<typename remove_reference<F>::type&&>(
           *reinterpret_cast<F*>(from)));
     } else {
       variant_helper_rec<Ts...>::move(id, from, to);
     }
   }
 
   inline static void copy(uint32_t id, const void* from, void* to) {
-    if (value::TypeTrait<F>::type_id == id) {
+    if (value::TypeTraits<F>::type_id == id) {
       new (to) F(*reinterpret_cast<const F*>(from));
     } else {
       variant_helper_rec<Ts...>::copy(id, from, to);
     }
   }
 };
 
@@ -185,29 +187,34 @@
 
 template <typename T, typename S, typename... Ts>
 struct is_one_of<T, S, Ts...> {
   static constexpr bool value =
       std::is_same<T, S>::value || is_one_of<T, Ts...>::value;
 };
 
+} // namespace variant_detail
+
+using namespace variant_detail;
+
 template <typename... Ts>
 struct variant {
+
  private:
   static const unsigned int data_size = static_max<sizeof(Ts)...>::value;
   static const unsigned int data_align = static_max<alignof(Ts)...>::value;
 
   using data_t = typename aligned_storage<data_size, data_align>::type;
 
   using helper_t = variant_helper<Ts...>;
 
   // template <uint8_t i>
   // using alternative = typename variant_alternative<i, Ts...>::type;
 
   static inline uint32_t invalid_type() {
-    return value::TypeTrait<void>::type_id;
+    return value::TypeTraits<void>::type_id();
   }
 
   uint32_t variant_id;
   data_t data;
 
   static void *nulldata() {
     return nullptr;
@@ -238,27 +245,27 @@
     variant_id = rhs.variant_id;
     helper_t::move(rhs.variant_id, &rhs.data, &data);
     return *this;
   }
 
   template <typename T>
   bool is() const {
-    return variant_id == value::TypeTrait<T>::type_id;
+    return variant_id == value::TypeTraits<T>::type_id;
   }
 
   uint32_t id() const { return variant_id; }
 
   // template<typename T, typename... Args>
   template <typename T, typename... Args,
             typename =
                 typename std::enable_if<is_one_of<T, Ts...>::value, void>::type>
   void set(Args&&... args) {
     helper_t::destroy(variant_id, &data);
     new (&data) T(std::forward<Args>(args)...);
-    variant_id = value::TypeTrait<T>::type_id;
+    variant_id = value::TypeTraits<T>::type_id;
     // variant_helper_static<alternative<i>>::copy(&value, &data);
   }
 
   template<typename T>
   variant(const T &v) {
     set<T>(v);
   }
@@ -266,69 +273,69 @@
 #if 1
   // allow seg fault.
   template <typename T, typename... Args,
             typename =
                 typename std::enable_if<is_one_of<T, Ts...>::value, void>::type>
   T& cast() {
     // It is a dynamic_cast-like behaviour
-    if (variant_id == value::TypeTrait<T>::type_id) {
+    if (variant_id == value::TypeTraits<T>::type_id) {
       return *reinterpret_cast<T*>(&data);
     }
 
     // Will raise null-pointer dereference error.
     return *reinterpret_cast<T*>(nulldata());
   }
 #endif
 
   template <typename T, typename... Args,
             typename =
                 typename std::enable_if<is_one_of<T, Ts...>::value, void>::type>
   const nonstd::optional<T> get() {
     // It is a dynamic_cast-like behaviour
-    if (variant_id == value::TypeTrait<T>::type_id) {
+    if (variant_id == value::TypeTraits<T>::type_id) {
       return *reinterpret_cast<T*>(&data);
     }
 
     return nonstd::nullopt;
   }
 
   template <typename T, typename... Args,
             typename =
                 typename std::enable_if<is_one_of<T, Ts...>::value, void>::type>
   const nonstd::optional<T> get() const {
     // It is a dynamic_cast-like behaviour
-    if (variant_id == value::TypeTrait<T>::type_id) {
+    if (variant_id == value::TypeTraits<T>::type_id) {
       return *reinterpret_cast<const T*>(&data);
     }
 
     return nonstd::nullopt;
   }
 
   template <typename T, typename... Args,
             typename =
                 typename std::enable_if<is_one_of<T, Ts...>::value, void>::type>
-  T* get_if() {
+  const T* get_if() const {
     // It is a dynamic_cast-like behaviour
-    if (variant_id == value::TypeTrait<T>::type_id) {
-      return reinterpret_cast<T*>(&data);
+    if (variant_id == value::TypeTraits<T>::type_id) {
+      return reinterpret_cast<const T*>(&data);
     }
 
     return nullptr;
   }
 
   ~variant() { helper_t::destroy(variant_id, &data); }
 };
 
 struct monostate {};
 
 namespace value {
 
 #define DEFINE_TYPE_TRAIT(__dty, __name, __tyid, __nc)           \
   template <>                                                    \
-  struct TypeTrait<__dty> {                                      \
+  struct TypeTraits<__dty> {                                      \
     using value_type = __dty;                                    \
     using value_underlying_type = __dty;                         \
     static constexpr uint32_t ndim = 0; /* array dim */          \
     static constexpr uint32_t ncomp =                            \
         __nc; /* the number of components(e.g. float3 => 3) */   \
     static constexpr uint32_t type_id = __tyid;                  \
     static constexpr uint32_t underlying_type_id = __tyid;       \
```

### Comparing `tinyusdz-0.8.0rc0/src/tydra/README.md` & `tinyusdz-0.8.0rc1/src/tydra/README.md`

 * *Files 23% similar despite different names*

```diff
@@ -1,17 +1,27 @@
 # What is Tydra?
 
+![Tydra](tydra.png)
+
 TinyUSDZ does not support Hydra interface at the moment.
-We think Hydra(multi-purpose sceneDelegate/renderDelegate interface) is too much for TinyUSDZ usecases(AR, lightweight 3D viewer/runtime, etc).
+We think Hydra(multi-purpose sceneDelegate/renderDelegate interface) is too much for TinyUSDZ usecases(AR, lightweight 3D viewer/runtime, DCC exchange, etc).
 
-Instead, we'd like to propose Tydra, a three-headed monster(Please imagine Gidorah: https://en.wikipedia.org/wiki/King_Ghidora), which directly converts(`publishes`) USD scene graph(GPrim hierarchy) to a renderer-friendly data structure or `published` data format(imagine glTF). And API design of Tydra is completely different from Hydra.
+Instead, we'd like to propose Tydra, a three-headed monster(Please imagine Gidorah: https://en.wikipedia.org/wiki/King_Ghidora), which directly converts(`publishes`) USD scene graph(Stage. Prim hierarchy) to a renderer-friendly data structure or `published` data format(imagine glTF). API design of Tydra is completely different from Hydra.
 
-Currently Tydra is considering the following three usecases:
+Currently Tydra is considering following three usecases in mind:
 
-- GL/Vulkan renderer
-- Ray tracing renderer
+- Runtime publishment(e.g. to glTF), DCC conversion and exchange for realtime graphics(AR, VR, MR, games, etc).
+- Scene conversion to GL/Vulkan renderer(e.g. WebGL rendering)
+- Scene conversion to Ray tracing renderer(e.g. Vulkan/OptiX ray tracing)
   See `../../examples/sdlviewer/` for SW raytracing example.
-- Runtime publishment, DCC conversion(e.g. to glTF)
 
+## RenderScene
+
+Scene graph representation suited for OpenGL/Vulkan renderer.
+
+## TODO
+
+- Data structure suited for realtime DCC.
+- Data structure suited for Ray tracing
 
 EoL.
```

### Comparing `tinyusdz-0.8.0rc0/src/usdGeom.cc` & `tinyusdz-0.8.0rc1/src/str-util.cc`

 * *Files 27% similar despite different names*

```diff
@@ -1,299 +1,365 @@
-// SPDX-License-Identifier: MIT
-// Copyright 2022 - Present, Syoyo Fujita.
-//
-// UsdGeom API implementations
-
-#include <sstream>
-
-#include "usdGeom.hh"
-#include "prim-types.hh"
+// SPDX-License-Identifier: Apache 2.0
+// Copyright 2023 - Present, Light Transport Entertainment, Inc.
+#include "str-util.hh"
 
 #include "common-macros.inc"
 
 namespace tinyusdz {
+ 
+std::string buildEscapedAndQuotedStringForUSDA(const std::string &str) {
+  // Rule for triple quote string:
+  //
+  // if str contains newline
+  //   if str contains """ and '''
+  //      use quote """ and escape " to \\", no escape for '''
+  //   elif str contains """ only
+  //      use quote ''' and no escape for """
+  //   elif str contains ''' only
+  //      use quote """ and no escape for '''
+  //   else
+  //      use quote """
+  //
+  // Rule for single quote string
+  //   if str contains " and '
+  //      use quote " and escape " to \\", no escape for '
+  //   elif str contains " only
+  //      use quote ' and no escape for "
+  //   elif str contains ' only
+  //      use quote " and no escape for '
+  //   else
+  //      use quote "
+  
+  bool has_newline = hasNewline(str);
+
+  std::string s;
+
+  if (has_newline) {
+    bool has_triple_single_quoted_string = hasTripleQuotes(str, false);
+    bool has_triple_double_quoted_string = hasTripleQuotes(str, true);
+
+    std::string delim = "\"\"\"";
+    if (has_triple_single_quoted_string && has_triple_double_quoted_string) {
+      s = escapeSingleQuote(str, true);
+    } else if (has_triple_single_quoted_string) {
+      s = escapeSingleQuote(str, false);
+    } else if (has_triple_double_quoted_string) {
+      delim = "'''";
+      s = str;
+    } else {
+      s = str;
+    }
 
-namespace {
-
-constexpr auto kPrimvarNormals = "primvar::normals";
 
-} // namespace
+    s = quote(escapeControlSequence(s), delim);
 
-std::vector<value::normal3f> GeomMesh::GetNormals() const {
-  std::vector<value::normal3f> dst;
 
-  if (props.count(kPrimvarNormals)) {
-    const auto prop = props.at(kPrimvarNormals);
-    if (prop.IsRel()) {
-      // TODO:
-      return dst;
+  } else {
+    // single quote string.
+    bool has_single_quote = hasQuotes(str, false);
+    bool has_double_quote = hasQuotes(str, true);
+
+    std::string delim = "\"";
+    if (has_single_quote && has_double_quote) {
+      s = escapeSingleQuote(str, true);
+    } else if (has_single_quote) {
+      s = escapeSingleQuote(str, false);
+    } else if (has_double_quote) {
+      delim = "'";
+      s = str;
+    } else {
+      s = str;
     }
 
-    if (prop.attrib.var.type_name() == "normal3f[]") {
-      if (auto pv = prop.attrib.var.get_value<std::vector<value::normal3f>>()) {
-        dst = pv.value();
-      }
-    }
-  } else if (normals) {
-    if (normals.value().var.type_name() == "normal3f[]") {
-      if (auto pv = normals.value().var.get_value<std::vector<value::normal3f>>()) {
-        dst = pv.value();
-      }
-    }
+    s = quote(escapeControlSequence(s), delim);
   }
 
-  return dst;
+  return s;
 }
 
-Interpolation GeomMesh::GetNormalsInterpolation() const {
+std::string escapeControlSequence(const std::string &str) {
+
+  std::string s;
+
+  for (size_t i = 0; i < str.size(); i++) {
 
-  if (props.count(kPrimvarNormals)) {
-    // TODO: Check if `primvar::normals` type is `normal3f[]`
-    const auto &prop = props.at(kPrimvarNormals);
-    if (prop.attrib.meta.interpolation) {
-      return prop.attrib.meta.interpolation.value();
+    if (str[i] == '\a') {
+      s += "\\x07";
+    } else if (str[i] == '\b') {
+      s += "\\x08";
+    } else if (str[i] == '\t') {
+      s += "\\t";
+    } else if (str[i] == '\v') {
+      s += "\\x0b";
+    } else if (str[i] == '\f') {
+      s += "\\x0c";
+    } else if (str[i] == '\\') {
+      // skip escaping backshash for escaped quote string: \' \"
+      if (i + 1 < str.size()) {
+        if ((str[i+1] == '"') || (str[i+1] == '\'')) {
+          s += str[i];
+        } else {
+          s += "\\\\";
+        }
+      } else {
+        s += "\\\\";
+      }
+    } else {
+      s += str[i];
     }
-  } else if (normals) {
-    return normals.value().meta.interpolation.value();
   }
+  
+  return s;
 
-  return Interpolation::Vertex; // default 'vertex'
 }
 
-void GeomMesh::Initialize(const GPrim &gprim)
-{
-  name = gprim.name;
-  parent_id = gprim.parent_id;
+std::string unescapeControlSequence(const std::string &str) {
 
-  props = gprim.props;
+  std::string s;
 
-#if 0
-  for (auto &prop_item : gprim.props) {
-    std::string attr_name = std::get<0>(prop_item);
-    const Property &prop = std::get<1>(prop_item);
+  if (str.size() < 2) {
+    return str;
+  }
 
-    if (prop.is_rel) {
-      //LOG_INFO("TODO: Rel property:" + attr_name);
-      continue;
+  for (size_t i = 0; i < str.size(); i++) {
+    if (str[i] == '\\') {
+      if (i + 1 < str.size()) {
+        if (str[i+1] == 'a') {
+          s += '\a'; i++;      
+        } else if (str[i+1] == 'b') {
+          s += '\b'; i++;      
+        } else if (str[i+1] == 't') {
+          s += '\t'; i++;      
+        } else if (str[i+1] == 'v') {
+          s += '\v'; i++;      
+        } else if (str[i+1] == 'f') {
+          s += '\f'; i++;      
+        } else if (str[i+1] == 'n') {
+          s += '\n'; i++;      
+        } else if (str[i+1] == 'r') {
+          s += '\r'; i++;      
+        } else if (str[i+1] == '\\') {
+          s += "\\";   
+        } else {
+          // ignore backslash
+        }
+      } else {
+        // ignore backslash
+      }
+    } else {
+      s += str[i];
     }
+  }
+  
+  return s;
 
-    const PrimAttrib &attr = prop.attrib;
+}
+
+bool hasQuotes(const std::string &str, bool is_double_quote) {
 
-    if (attr_name == "points") {
-      //if (auto p = primvar::as_vector<value::float3>(&attr.var)) {
-      //  points = *p;
-      //}
-    } else if (attr_name == "faceVertexIndices") {
-      //if (auto p = primvar::as_vector<int>(&attr.var)) {
-      //  faceVertexIndices = *p;
-      //}
-    } else if (attr_name == "faceVertexCounts") {
-      //if (auto p = primvar::as_vector<int>(&attr.var)) {
-      //  faceVertexCounts = *p;
-      //}
-    } else if (attr_name == "normals") {
-      //if (auto p = primvar::as_vector<value::float3>(&attr.var)) {
-      //  normals.var = *p;
-      //  normals.interpolation = attr.interpolation;
-      //}
-    } else if (attr_name == "velocitiess") {
-      //if (auto p = primvar::as_vector<value::float3>(&attr.var)) {
-      //  velocitiess.var = (*p);
-      //  velocitiess.interpolation = attr.interpolation;
-      //}
-    } else if (attr_name == "primvars:uv") {
-      //if (auto pv2f = primvar::as_vector<Vec2f>(&attr.var)) {
-      //  st.buffer = (*pv2f);
-      //  st.interpolation = attr.interpolation;
-      //} else if (auto pv3f = primvar::as_vector<value::float3>(&attr.var)) {
-      //  st.buffer = (*pv3f);
-      //  st.interpolation = attr.interpolation;
-      //}
+  for (size_t i = 0; i < str.size(); i++) {
+    if (is_double_quote) {
+      if (str[i] == '"') {
+        return true;
+      }
     } else {
-      // Generic PrimAtrr
-      props[attr_name] = attr;
+      if (str[i] == '\'') {
+        return true;
+      }
     }
+  }
+
+  return false;
+}
+
+bool hasTripleQuotes(const std::string &str, bool is_double_quote) {
 
+  for (size_t i = 0; i < str.size(); i++) {
+    if (i + 3 < str.size()) {
+      if (is_double_quote) {
+        if ((str[i+0] == '"') && (str[i+1] == '"') && (str[i+2] == '"')) {
+          return true;
+        }
+      } else {
+        if ((str[i+0] == '\'') && (str[i+1] == '\'') && (str[i+2] == '\'')) {
+          return true;
+        }
+      }
+    }
   }
-#endif
 
-  doubleSided = gprim.doubleSided;
-  orientation = gprim.orientation;
-  visibility = gprim.visibility;
-  extent = gprim.extent;
-  purpose = gprim.purpose;
+  return false;
+}
+
+bool hasEscapedTripleQuotes(const std::string &str, bool is_double_quote, size_t *n) {
+  size_t count = 0;
 
-  displayColor = gprim.displayColor;
-  displayOpacity = gprim.displayOpacity;
+  for (size_t i = 0; i < str.size(); i++) {
+    if (str[i] == '\\') {
+      if (i + 3 < str.size()) {
+        if (is_double_quote) {
+          if ((str[i+1] == '"') && (str[i+2] == '"') && (str[i+3] == '"')) {
+            if (!n) { // early exit
+              return true;
+            }
+
+            count++;
+            i += 3;
+          }
+        } else {
+          if ((str[i+1] == '\'') && (str[i+2] == '\'') && (str[i+3] == '\'')) {
+            if (!n) { // early exit
+              return true;
+            }
+            count++;
+            i += 3;
+          }
+        }
+      }
+    }
+  }
 
-#if 0 // TODO
+  if (n) {
+    (*n) = count;
+  }
 
+  return count > 0;
+}
 
-  // PrimVar(TODO: Remove)
-  UVCoords st;
+std::string escapeSingleQuote(const std::string &str, const bool is_double_quote) {
 
-  //
-  // Properties
-  //
+  std::string s;
 
+  if (is_double_quote) {
+    for (size_t i = 0; i < str.size(); i++) {
+      if (str[i] == '"') {
+        s += "\\\"";
+      } else {
+        s += str[i];
+      }
+    }
+  } else {
+    for (size_t i = 0; i < str.size(); i++) {
+      if (str[i] == '\'') {
+        s += "\\'";
+      } else {
+        s += str[i];
+      }
+    }
+  }
 
-#endif
+  return s;
+}
 
-};
+std::string escapeBackslash(const std::string &str, const bool triple_quoted_string) {
 
-nonstd::expected<bool, std::string> GeomMesh::ValidateGeomSubset() {
+  if (triple_quoted_string) {
 
-  std::stringstream ss;
+    std::string s;
 
-  if (geom_subset_children.empty()) {
-    return true;
-  }
+    // Do not escape \""" or \'''
 
-  auto CheckFaceIds = [](const size_t nfaces, const std::vector<uint32_t> ids) {
-    if (std::any_of(ids.begin(), ids.end(), [&nfaces](uint32_t id) { return id >= nfaces; })) {
-      return false;
+    for (size_t i = 0; i < str.size(); i++) {
+      if (str[i] == '\\') {
+        if (i + 3 < str.size()) {
+          if ((str[i+1] == '\'') && (str[i+2] == '\'') && (str[i+3] == '\'')) {
+            s += "\\'''";
+            i += 3;
+          } else if ((str[i+1] == '"') && (str[i+2] == '"') && (str[i+3] == '"')) {
+            s += "\\\"\"\"";
+            i += 3;
+          } else {
+            s += "\\\\";
+          }
+        } else {
+          s += "\\\\";
+        }
+      } else {
+        s += str[i];
+      }
     }
 
-    return true;
-  };
+    return s;
+  } else {
 
-  size_t n = faceVertexIndices.size();
+    const std::string bs = "\\";
+    const std::string bs_escaped = "\\\\";
 
-  // Currently we only check if face ids are valid.
-  for (size_t i = 0; i < geom_subset_children.size(); i++) {
-    const GeomSubset & subset = geom_subset_children[i];
+    std::string s = str;
 
-    if (!CheckFaceIds(n, subset.indices)) {
-      ss << "Face index out-of-range.\n";
-      return nonstd::make_unexpected(ss.str());
+    std::string::size_type pos = 0;
+    while ((pos = s.find(bs, pos)) != std::string::npos) {
+      s.replace(pos, bs.length(), bs_escaped);
+      pos += bs_escaped.length();
     }
-  }
 
-  return nonstd::make_unexpected("TODO: Implent GeomMesh::ValidateGeomSubset\n");
-  //return true;
+    return s;
+  }
 
 }
 
-namespace {
+std::string unescapeBackslash(const std::string &str) {
+  std::string s = str;
 
-#if 0
-value::matrix4d GetTransform(XformOp xform)
-{
-  value::matrix4d m;
-  Identity(&m);
+  std::string bs = "\\\\";
+  std::string bs_unescaped = "\\";
 
-  if (xform.op == XformOp::OpType::TRANSFORM) {
-    if (auto v = xform.value.get<value::matrix4d>()) {
-      m = v.value();
-    }
-  } else if (xform.op == XformOp::OpType::TRANSLATE) {
-      if (auto sf = xform.value.get<value::float3>()) {
-        m.m[3][0] = double(sf.value()[0]);
-        m.m[3][1] = double(sf.value()[1]);
-        m.m[3][2] = double(sf.value()[2]);
-      } else if (auto sd = xform.value.get<value::double3>()) {
-        m.m[3][0] = sd.value()[0];
-        m.m[3][1] = sd.value()[1];
-        m.m[3][2] = sd.value()[2];
-      }
-  } else if (xform.op == XformOp::OpType::SCALE) {
-      if (auto sf = xform.value.get<value::float3>()) {
-        m.m[0][0] = double(sf.value()[0]);
-        m.m[1][1] = double(sf.value()[1]);
-        m.m[2][2] = double(sf.value()[2]);
-      } else if (auto sd = xform.value.get<value::double3>()) {
-        m.m[0][0] = sd.value()[0];
-        m.m[1][1] = sd.value()[1];
-        m.m[2][2] = sd.value()[2];
-      }
-  } else {
-    DCOUT("TODO: xform.op = " << XformOp::GetOpTypeName(xform.op));
+  std::string::size_type pos = 0;
+  while ((pos = s.find(bs, pos)) != std::string::npos) {
+    s.replace(pos, bs.length(), bs_unescaped);
+    pos += bs_unescaped.length();
   }
 
-  return m;
+  return s;
 }
-#endif
 
-} // namespace
+bool tokenize_variantElement(const std::string &elementName, std::array<std::string, 2> *result) {
 
-bool Xform::EvaluateXformOps(value::matrix4d *out_matrix) const {
-    Identity(out_matrix);
-
-    value::matrix4d cm;
-
-    // Concat matrices
-    for (const auto &x : xformOps) {
-      value::matrix4d m;
-      Identity(&m);
-      (void)x;
-      if (x.op == XformOp::TRANSLATE) {
-        if (auto txf = x.value.get<value::float3>()) {
-          m.m[3][0] = double(txf.value()[0]);
-          m.m[3][1] = double(txf.value()[1]);
-          m.m[3][2] = double(txf.value()[2]);
-        } else if (auto txd = x.value.get<value::double3>()) {
-          m.m[3][0] = txd.value()[0];
-          m.m[3][1] = txd.value()[1];
-          m.m[3][2] = txd.value()[2];
-        } else {
-          return false;
-        }
-      // FIXME: Validate ROTATE_X, _Y, _Z implementation
-      } else if (x.op == XformOp::ROTATE_X) {
-        double theta;
-        if (auto rf = x.value.get<float>()) {
-          theta = double(rf.value());
-        } else if (auto rd = x.value.get<double>()) {
-          theta = rd.value();
-        } else {
-          return false;
-        }
+  std::vector<std::string> toks;
 
-        m.m[1][1] = std::cos(theta);
-        m.m[1][2] = std::sin(theta);
-        m.m[2][1] = -std::sin(theta);
-        m.m[2][2] = std::cos(theta);
-      } else if (x.op == XformOp::ROTATE_Y) {
-        double theta;
-        if (auto f = x.value.get<float>()) {
-          theta = double(f.value());
-        } else if (auto d = x.value.get<double>()) {
-          theta = d.value();
-        } else {
-          return false;
-        }
+  // Ensure ElementPath is quoted with '{' and '}'
+  if (startsWith(elementName, "{") && endsWith(elementName, "}")) {
+    // ok
+  } else {
+    return false;
+  }
 
-        m.m[0][0] = std::cos(theta);
-        m.m[0][2] = -std::sin(theta);
-        m.m[2][0] = std::sin(theta);
-        m.m[2][2] = std::cos(theta);
-      } else if (x.op == XformOp::ROTATE_Z) {
-        double theta;
-        if (auto f = x.value.get<float>()) {
-          theta = double(f.value());
-        } else if (auto d = x.value.get<double>()) {
-          theta = d.value();
-        } else {
-          return false;
-        }
+  // Remove variant quotation
+  std::string name = unwrap(elementName, "{", "}");
 
-        m.m[0][0] = std::cos(theta);
-        m.m[0][1] = std::sin(theta);
-        m.m[1][0] = -std::sin(theta);
-        m.m[1][1] = std::cos(theta);
-      } else {
-        // TODO
-        DCOUT("TODO");
+  toks = split(name, "=");
+  if (toks.size() == 1) {
+    if (result) {
+      // ensure '=' and newline does not exist.
+      if (counts(toks[0], '=') || hasNewline(toks[0])) {
         return false;
       }
 
-      cm = Mult<value::matrix4d, double, 4>(cm, m);
+      (*result)[0] = toks[0];
+      (*result)[1] = std::string();
     }
+    return true;
+  } else if (toks.size() == 2) {
+    if (result) {
+      // ensure '=' and newline does not exist.
+      if (counts(toks[0], '=') || hasNewline(toks[0])) {
+        return false;
+      }
 
-    (*out_matrix) = cm;
+      if (counts(toks[1], '=') || hasNewline(toks[1])) {
+        return false;
+      }
 
-  return true;
+      (*result)[0] = toks[0];
+      (*result)[1] = toks[1];
+    }
+    return true;
+  } else {
+    return false;
+  }
 }
 
-} // namespace tinyusdz
-
+bool is_variantElementName(const std::string &name) {
+  return tokenize_variantElement(name);
+}
 
+}  // namespace tinyusdz
```

### Comparing `tinyusdz-0.8.0rc0/src/usdMtlx.hh` & `tinyusdz-0.8.0rc1/src/usdMtlx.hh`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/usdObj.hh` & `tinyusdz-0.8.0rc1/src/usdObj.hh`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/usdVox.hh` & `tinyusdz-0.8.0rc1/src/usdVox.hh`

 * *Files identical despite different names*

### Comparing `tinyusdz-0.8.0rc0/src/usda-reader.cc` & `tinyusdz-0.8.0rc1/src/usda-reader.cc`

 * *Files 18% similar despite different names*

```diff
@@ -1,31 +1,33 @@
 // SPDX-License-Identifier: MIT
 // Copyright 2021 - Present, Syoyo Fujita.
 //
 // USDA reader
 // TODO:
-//   - [ ] Use common base code for Reconstruct**** with USDC reader
+//   - [ ] Refactor and unify Prim and PrimSpec related code.
 
 #include <algorithm>
 #include <atomic>
-#include <cassert>
+#include <cerrno>
 #include <cstdlib>
 #include <fstream>
 #include <iostream>
 #include <iterator>
 #include <map>
 #include <set>
 #include <sstream>
 #include <stack>
 
 #include "ascii-parser.hh"
+#include "usdGeom.hh"
+#include "usdSkel.hh"
 #if defined(__wasi__)
 #else
-#include <thread>
 #include <mutex>
+#include <thread>
 #endif
 #include <vector>
 
 #include "usda-reader.hh"
 
 //
 #if !defined(TINYUSDZ_DISABLE_MODULE_USDA_READER)
@@ -35,15 +37,14 @@
 #ifdef __clang__
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Weverything"
 #endif
 
 // external
 
-#include "fast_float/fast_float.h"
 #include "nonstd/expected.hpp"
 #include "nonstd/optional.hpp"
 
 //
 
 #ifdef __clang__
 #pragma clang diagnostic pop
@@ -56,106 +57,148 @@
 #pragma clang diagnostic ignored "-Wunused-parameter"
 #endif
 
 #include "io-util.hh"
 #include "math-util.inc"
 #include "pprinter.hh"
 #include "prim-types.hh"
-#include "str-util.hh"
+#include "prim-reconstruct.hh"
 #include "primvar.hh"
+#include "str-util.hh"
 #include "stream-reader.hh"
 #include "tinyusdz.hh"
 #include "usdObj.hh"
 #include "usdShade.hh"
 #include "value-pprint.hh"
 #include "value-types.hh"
-
-#if 0
-#define PUSH_PARSER_ERROR_AND_RETURN() \
-  do {                                 \
-    std::ostringstream ss;             \
-    ss << _parser.GetError();          \
-    _err += ss.str();                  \
-    return false;                      \
-  } while (0)
-#endif
-
-// s = std::string
-#define PUSH_ERROR_AND_RETURN(s)                                   \
-  do {                                                             \
-    std::ostringstream ss;                                         \
-    ss << __FILE__ << ":" << __func__ << "():" << __LINE__ << " "; \
-    ss << s;                                                       \
-    _err += ss.str();                                              \
-    return false;                                                  \
-  } while (0)
-
-#define PUSH_WARN(s)                                               \
-  do {                                                             \
-    std::ostringstream ss;                                         \
-    ss << __FILE__ << ":" << __func__ << "():" << __LINE__ << " "; \
-    ss << s;                                                       \
-    _err += ss.str();                                              \
-  } while (0)
+#include "tiny-format.hh"
 
 #include "common-macros.inc"
 
 namespace tinyusdz {
 
+namespace prim {
+
+// template specialization forward decls.
+// implimentations will be located in prim-reconstruct.cc
+#define RECONSTRUCT_PRIM_DECL(__ty) template<> bool ReconstructPrim<__ty>(const PropertyMap &, const ReferenceList &, __ty *, std::string *, std::string *)
+
+RECONSTRUCT_PRIM_DECL(Xform);
+RECONSTRUCT_PRIM_DECL(Model);
+RECONSTRUCT_PRIM_DECL(Scope);
+RECONSTRUCT_PRIM_DECL(Skeleton);
+RECONSTRUCT_PRIM_DECL(SkelRoot);
+RECONSTRUCT_PRIM_DECL(SkelAnimation);
+RECONSTRUCT_PRIM_DECL(BlendShape);
+RECONSTRUCT_PRIM_DECL(DomeLight);
+RECONSTRUCT_PRIM_DECL(SphereLight);
+RECONSTRUCT_PRIM_DECL(CylinderLight);
+RECONSTRUCT_PRIM_DECL(DiskLight);
+RECONSTRUCT_PRIM_DECL(DistantLight);
+RECONSTRUCT_PRIM_DECL(GeomMesh);
+RECONSTRUCT_PRIM_DECL(GeomSphere);
+RECONSTRUCT_PRIM_DECL(GeomPoints);
+RECONSTRUCT_PRIM_DECL(GeomCone);
+RECONSTRUCT_PRIM_DECL(GeomCube);
+RECONSTRUCT_PRIM_DECL(GeomCylinder);
+RECONSTRUCT_PRIM_DECL(GeomCapsule);
+RECONSTRUCT_PRIM_DECL(GeomBasisCurves);
+RECONSTRUCT_PRIM_DECL(GeomCamera);
+RECONSTRUCT_PRIM_DECL(Material);
+RECONSTRUCT_PRIM_DECL(Shader);
+
+#undef RECONSTRUCT_PRIM_DECL
+
+} // namespace prim
+
 namespace usda {
 
+constexpr auto kTag = "[USDA]";
+
 namespace {
 
+// intermediate data structure for VariantSet
+struct VariantNode {
+  PrimMeta metas;
+  std::map<std::string, Property> props;
+  std::vector<int64_t> primChildren;
+};
+
+struct PrimNode {
+  value::Value prim; // stores typed Prim value. Xform, GeomMesh, ...
+  std::string elementName;
+  std::string typeName; // Prim's typeName
+
+  int64_t parent{-1};            // -1 = root node
+  bool parent_is_variant{false}; // True when this Prim is defined under variantSet stmt.
+  std::vector<size_t> children;  // index to USDAReader._prims[] of childPrims. it contains variant's primChildren also.
+
+  std::map<std::string, std::map<std::string, VariantNode>> variantNodeMap;
+};
+
+// For USD scene read for composition(read by references, subLayers, payloads)
+struct PrimSpecNode {
+  PrimSpec primSpec;
+
+  int64_t parent{-1};            // -1 = root node
+  std::vector<size_t> children;  // index to USDAReader._primspecs[]
+};
+
 // TODO: Move to prim-types.hh?
 
-template<typename T>
-struct PrimTypeTrait;
+template <typename T>
+struct PrimTypeTraits;
 
 #ifdef __clang__
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wunused-const-variable"
 #endif
 
-#define DEFINE_PRIM_TYPE(__dty, __name, __tyid) \
-  template<> \
-  struct PrimTypeTrait<__dty> { \
-    using primt_type = __dty; \
-    static constexpr uint32_t type_id = __tyid; \
+#define DEFINE_PRIM_TYPE(__dty, __name, __tyid)    \
+  template <>                                      \
+  struct PrimTypeTraits<__dty> {                    \
+    using primt_type = __dty;                      \
+    static constexpr uint32_t type_id = __tyid;    \
     static constexpr auto prim_type_name = __name; \
   }
 
-DEFINE_PRIM_TYPE(Xform, "Xform", value::TYPE_ID_GEOM_XFORM);
-DEFINE_PRIM_TYPE(GeomMesh, "Mesh", value::TYPE_ID_GEOM_MESH);
-DEFINE_PRIM_TYPE(GeomSphere, "Sphere", value::TYPE_ID_GEOM_SPHERE);
-DEFINE_PRIM_TYPE(GeomCube, "Cube", value::TYPE_ID_GEOM_CUBE);
-DEFINE_PRIM_TYPE(GeomCone, "Cone", value::TYPE_ID_GEOM_CONE);
-DEFINE_PRIM_TYPE(GeomCapsule, "Capsule", value::TYPE_ID_GEOM_CAPSULE);
-DEFINE_PRIM_TYPE(GeomCylinder, "Cylinder", value::TYPE_ID_GEOM_CYLINDER);
-DEFINE_PRIM_TYPE(GeomBasisCurves, "BasisCurves", value::TYPE_ID_GEOM_BASIS_CURVES);
-DEFINE_PRIM_TYPE(GeomSubset, "GeomSubset", value::TYPE_ID_GEOM_GEOMSUBSET);
-DEFINE_PRIM_TYPE(LuxSphereLight, "SphereLight", value::TYPE_ID_LUX_SPHERE);
-DEFINE_PRIM_TYPE(LuxDomeLight, "DomeLight", value::TYPE_ID_LUX_DOME);
-DEFINE_PRIM_TYPE(Material, "Material", value::TYPE_ID_MATERIAL);
-DEFINE_PRIM_TYPE(Shader, "Shader", value::TYPE_ID_SHADER);
-DEFINE_PRIM_TYPE(SkelRoot, "SkelRoot", value::TYPE_ID_SKEL_ROOT);
-DEFINE_PRIM_TYPE(Skeleton, "Skeleton", value::TYPE_ID_SKELETON);
+DEFINE_PRIM_TYPE(Model, "Model", value::TYPE_ID_MODEL);
+
+DEFINE_PRIM_TYPE(Xform, kGeomXform, value::TYPE_ID_GEOM_XFORM);
+DEFINE_PRIM_TYPE(GeomMesh, kGeomMesh, value::TYPE_ID_GEOM_MESH);
+DEFINE_PRIM_TYPE(GeomPoints, kGeomPoints, value::TYPE_ID_GEOM_POINTS);
+DEFINE_PRIM_TYPE(GeomSphere, kGeomSphere, value::TYPE_ID_GEOM_SPHERE);
+DEFINE_PRIM_TYPE(GeomCube, kGeomCube, value::TYPE_ID_GEOM_CUBE);
+DEFINE_PRIM_TYPE(GeomCone, kGeomCone, value::TYPE_ID_GEOM_CONE);
+DEFINE_PRIM_TYPE(GeomCapsule, kGeomCapsule, value::TYPE_ID_GEOM_CAPSULE);
+DEFINE_PRIM_TYPE(GeomCylinder, kGeomCylinder, value::TYPE_ID_GEOM_CYLINDER);
+DEFINE_PRIM_TYPE(GeomBasisCurves, kGeomBasisCurves,
+                 value::TYPE_ID_GEOM_BASIS_CURVES);
+DEFINE_PRIM_TYPE(GeomSubset, kGeomSubset, value::TYPE_ID_GEOM_GEOMSUBSET);
+DEFINE_PRIM_TYPE(SphereLight, kSphereLight, value::TYPE_ID_LUX_SPHERE);
+DEFINE_PRIM_TYPE(DomeLight, kDomeLight, value::TYPE_ID_LUX_DOME);
+DEFINE_PRIM_TYPE(DiskLight, kDiskLight, value::TYPE_ID_LUX_DISK);
+DEFINE_PRIM_TYPE(DistantLight, kDistantLight, value::TYPE_ID_LUX_DISTANT);
+DEFINE_PRIM_TYPE(CylinderLight,  kCylinderLight, value::TYPE_ID_LUX_CYLINDER);
+DEFINE_PRIM_TYPE(Material, kMaterial, value::TYPE_ID_MATERIAL);
+DEFINE_PRIM_TYPE(Shader, kShader, value::TYPE_ID_SHADER);
+DEFINE_PRIM_TYPE(SkelRoot, kSkelRoot, value::TYPE_ID_SKEL_ROOT);
+DEFINE_PRIM_TYPE(Skeleton, kSkeleton, value::TYPE_ID_SKELETON);
+DEFINE_PRIM_TYPE(SkelAnimation, kSkelAnimation, value::TYPE_ID_SKELANIMATION);
+DEFINE_PRIM_TYPE(BlendShape, kBlendShape, value::TYPE_ID_BLENDSHAPE);
+DEFINE_PRIM_TYPE(GeomCamera, kGeomCamera, value::TYPE_ID_GEOM_CAMERA);
 DEFINE_PRIM_TYPE(Scope, "Scope", value::TYPE_ID_SCOPE);
-DEFINE_PRIM_TYPE(GeomCamera, "Camera", value::TYPE_ID_GEOM_CAMERA);
 
 DEFINE_PRIM_TYPE(GPrim, "GPrim", value::TYPE_ID_GPRIM);
 
-//DEFINE_PRIM_TYPE(PreviewSurface, "PreviewSurface", value::TYPE_ID_IMAGING_PREVIEWSURFACE);
-//DEFINE_PRIM_TYPE(UVTexture, "UVTexture", value::TYPE_ID_IMAGING_UVTEXTURE);
-//DEFINE_PRIM_TYPE(PrimvarReader_float2, "PrimvarReaderUVTexture", value::TYPE_ID_IMAGING_UVTEXTURE);
-
 #ifdef __clang__
 #pragma clang diagnostic pop
 #endif
 
-} // namespace
+}  // namespace
 
 class VariableDef {
  public:
   std::string type;
   std::string name;
 
   VariableDef() = default;
@@ -168,80 +211,73 @@
     type = rhs.type;
     name = rhs.name;
 
     return *this;
   }
 };
 
-namespace {
-
-using ReferenceList = std::vector<std::pair<ListEditQual, Reference>>;
-
-#if 0
-// Extract array of References from Variable.
-ReferenceList GetReferences(
-    const std::tuple<ListEditQual, value::any_value> &_var) {
-  ReferenceList result;
-
-  ListEditQual qual = std::get<0>(_var);
-
-  auto var = std::get<1>(_var);
-
-  SDCOUT << "GetReferences. var.name = " << var.name << "\n";
-
-  if (var.IsArray()) {
-    DCOUT("IsArray");
-    auto parr = var.as_array();
-    if (parr) {
-      DCOUT("parr");
-      for (const auto &v : parr->values) {
-        DCOUT("Maybe Value");
-        if (v.IsValue()) {
-          DCOUT("Maybe Reference");
-          if (auto pref = nonstd::get_if<Reference>(v.as_value())) {
-            DCOUT("Got it");
-            result.push_back({qual, *pref});
-          }
-        }
-      }
-    }
-  } else if (var.IsValue()) {
-    DCOUT("IsValue");
-    if (auto pv = var.as_value()) {
-      DCOUT("Maybe Reference");
-      if (auto pas = nonstd::get_if<Reference>(pv)) {
-        DCOUT("Got it");
-        result.push_back({qual, *pas});
-      }
-    }
-  } else {
-    DCOUT("Unknown var type: " + Variable::type_name(var));
-  }
-
-  return result;
-}
-#endif
-
-}  // namespace
-
 inline bool hasConnect(const std::string &str) {
   return endsWith(str, ".connect");
 }
 
 inline bool hasInputs(const std::string &str) {
   return startsWith(str, "inputs:");
 }
 
 inline bool hasOutputs(const std::string &str) {
   return startsWith(str, "outputs:");
 }
 
+template <class E>
+static nonstd::expected<bool, std::string> CheckAllowedTokens(
+    const std::vector<std::pair<E, const char *>> &allowedTokens,
+    const std::string &tok) {
+  if (allowedTokens.empty()) {
+    return true;
+  }
+
+  for (size_t i = 0; i < allowedTokens.size(); i++) {
+    if (tok.compare(std::get<1>(allowedTokens[i])) == 0) {
+      return true;
+    }
+  }
+
+  std::vector<std::string> toks;
+  for (size_t i = 0; i < allowedTokens.size(); i++) {
+    toks.push_back(std::get<1>(allowedTokens[i]));
+  }
+
+  std::string s = join(", ", tinyusdz::quote(toks));
+
+  return nonstd::make_unexpected("Allowed tokens are [" + s + "] but got " +
+                                 quote(tok) + ".");
+};
+
+template <typename T>
+nonstd::expected<T, std::string> EnumHandler(
+    const std::string &prop_name, const std::string &tok,
+    const std::vector<std::pair<T, const char *>> &enums) {
+  auto ret = CheckAllowedTokens<T>(enums, tok);
+  if (!ret) {
+    return nonstd::make_unexpected(ret.error());
+  }
+
+  for (auto &item : enums) {
+    if (tok == item.second) {
+      return item.first;
+    }
+  }
+  // Should never reach here, though.
+  return nonstd::make_unexpected(
+      quote(tok) + " is an invalid token for attribute `" + prop_name + "`");
+}
+
 class USDAReader::Impl {
  private:
-  Stage stage_;
+  Stage _stage;
 
  public:
   Impl(StreamReader *sr) { _parser.SetStream(sr); }
 
   // Return the flag if the .usda is read from `references`
   bool IsReferenced() { return _referenced; }
 
@@ -254,14 +290,22 @@
   // Return true if the .udsa is read in the top layer(stage)
   bool IsToplevel() {
     return !IsReferenced() && !IsSubLayered() && !IsPayloaded();
   }
 
   void SetBaseDir(const std::string &str) { _base_dir = str; }
 
+  void set_reader_config(const USDAReaderConfig &config) {
+    _config = config;
+  }
+
+  const USDAReaderConfig get_reader_config() const {
+    return _config;
+  }
+
   std::string GetCurrentPath() {
     if (_path_stack.empty()) {
       return "/";
     }
 
     return _path_stack.top();
   }
@@ -272,14 +316,22 @@
 
   void PopPath() {
     if (!_path_stack.empty()) {
       _path_stack.pop();
     }
   }
 
+  void PushError(const std::string &s) {
+    _err += s;
+  }
+
+  void PushWarn(const std::string &s) {
+    _err += s;
+  }
+
 #if 0  // TODO: remove
     if (prim_type.empty()) {
       if (IsToplevel()) {
         if (references.size()) {
           // Infer prim type from referenced asset.
 
           if (references.size() > 1) {
@@ -374,118 +426,689 @@
 
     return true;
   }
 #endif
 
   template <typename T>
   bool ReconstructPrim(
-      const std::map<std::string, Property> &properties,
-      const std::vector<std::pair<ListEditQual, Reference>> &references,
+      const prim::PropertyMap &properties,
+      const prim::ReferenceList &references,
       T *out);
 
-  // T = Prim class(e.g. Xform)
-  template<typename T>
+
+  template <typename T>
   bool RegisterReconstructCallback() {
     _parser.RegisterPrimConstructFunction(
-        PrimTypeTrait<T>::prim_type_name,
-        [&](const Path &path, const std::map<std::string, Property> &properties,
-            const std::vector<std::pair<ListEditQual, Reference>> &references) {
+        PrimTypeTraits<T>::prim_type_name,
+        [&](const Path &full_path, const Specifier spec, const std::string &primTypeName, const Path &prim_name, const int64_t primIdx,
+            const int64_t parentPrimIdx,
+            const prim::PropertyMap &properties,
+            const ascii::AsciiParser::PrimMetaMap &in_meta,
+            const ascii::AsciiParser::VariantSetList &in_variants)
+            -> nonstd::expected<bool, std::string> {
+          if (!prim_name.is_valid()) {
+            return nonstd::make_unexpected("Invalid Prim name: " +
+                                           prim_name.full_path_name());
+          }
+          if (prim_name.is_absolute_path() || prim_name.is_root_path()) {
+            return nonstd::make_unexpected(
+                "Prim name should not starts with '/' or contain `/`: Prim "
+                "name = " +
+                prim_name.full_path_name());
+          }
+
+          if (!prim_name.prop_part().empty()) {
+            return nonstd::make_unexpected(
+                "Prim path should not contain property part(`.`): Prim name "
+                "= " +
+                prim_name.full_path_name());
+          }
+
+          if (primIdx < 0) {
+            return nonstd::make_unexpected(
+                "Unexpected primIdx value. primIdx must be positive.");
+          }
+
           T prim;
 
-          if (ReconstructPrim<T>(properties, references, &prim)) {
-            // TODO
-            PUSH_WARN("TODO: Implement " + std::string(PrimTypeTrait<T>::prim_type_name));
+          if (!ReconstructPrimMeta(in_meta, &prim.meta)) {
+            return nonstd::make_unexpected(
+                "Failed to process Prim metadataum.");
+          }
+
+          DCOUT("primType = " << value::TypeTraits<T>::type_name()
+                              << ", node.size "
+                              << std::to_string(_prim_nodes.size())
+                              << ", primIdx = " << primIdx
+                              << ", parentPrimIdx = " << parentPrimIdx);
+
+          DCOUT("full_path = " << full_path.full_path_name());
+          DCOUT("primName = " << prim_name.full_path_name());
+
+          prim::ReferenceList references;
+          if (prim.meta.references) {
+            references = prim.meta.references.value();
+          }
+
+          bool ret = ReconstructPrim<T>(properties, references, &prim);
+
+          if (!ret) {
+            return nonstd::make_unexpected("Failed to reconstruct Prim: " +
+                                           prim_name.full_path_name());
+          }
+
+          prim.spec = spec;
+          prim.name = prim_name.prim_part();
+
+          //
+          // variants
+          // NOTE: variantChildren setup is delayed. It will be processed in ReconstructNodeRec()
+          //
+          std::map<std::string, std::map<std::string, VariantNode>> variantSets;
+          for (const auto &variantContext : in_variants) {
+            const std::string variant_name = variantContext.first;
+
+            // Convert VariantContent -> VariantNode
+            std::map<std::string, VariantNode> variantNodes;
+            for (const auto &item : variantContext.second) {
+              VariantNode variant;
+              if (!ReconstructPrimMeta(item.second.metas, &variant.metas)) {
+                return nonstd::make_unexpected(fmt::format("Failed to process Prim metadataum in variantSet {} item {} ", variant_name, item.first));
+              }
+              variant.props = item.second.props;
+
+              // child Prim should be already reconstructed.
+              for (const auto &childPrimIdx : item.second.primIndices) {
+                if (childPrimIdx < 0) {
+                  return nonstd::make_unexpected(fmt::format("[InternalError] Invalid primIndex found within VariantSet."));
+                }
+
+                if (size_t(childPrimIdx) >= _prim_nodes.size()) {
+                  return nonstd::make_unexpected(fmt::format("[InternalError] Invalid primIndex found within VariantSet. variantChildPrimIdsx {} Exceeds _prim_nodes.size() {}", childPrimIdx, _prim_nodes.size()));
+                }
+
+                variant.primChildren.push_back(childPrimIdx);
+
+                _prim_nodes[size_t(childPrimIdx)].parent_is_variant = true;
+              }
+              DCOUT("Add variant: " << item.first);
+              variantNodes.emplace(item.first, std::move(variant));
+            }
+
+            DCOUT("Add variantSet: " << variant_name);
+            variantSets.emplace(variant_name, std::move(variantNodes));
+          }
+
+          // Add to scene graph.
+          // NOTE: Scene graph is constructed from bottom up manner(Children
+          // first), so add this primIdx to parent's children.
+          if (size_t(primIdx) >= _prim_nodes.size()) {
+            _prim_nodes.resize(size_t(primIdx) + 1);
+          }
+          DCOUT("sz " << std::to_string(_prim_nodes.size())
+                      << ", primIdx = " << primIdx);
+
+          _prim_nodes[size_t(primIdx)].prim = std::move(prim);
+          _prim_nodes[size_t(primIdx)].typeName = primTypeName;
+          _prim_nodes[size_t(primIdx)].variantNodeMap = variantSets;
+
+
+          // Store actual Prim typeName also for Model Prim type.
+          // TODO: Find more better way.
+          {
+            value::Value *p = &(_prim_nodes[size_t(primIdx)].prim);
+            Model *model = p->as<Model>();
+            if (model) {
+              DCOUT("Set prim typeName " << primTypeName << " to Model Prim[" << primIdx << "]");
+              model->prim_type_name = primTypeName;
+            }
+          }
+
+          DCOUT("prim[" << primIdx << "].ty = "
+                        << _prim_nodes[size_t(primIdx)].prim.type_name());
+          _prim_nodes[size_t(primIdx)].parent = parentPrimIdx;
+
+          if (parentPrimIdx == -1) {
+            _toplevel_prims.push_back(size_t(primIdx));
+          } else {
+            _prim_nodes[size_t(parentPrimIdx)].children.push_back(
+                  size_t(primIdx));
           }
 
           return true;
         });
 
     return true;
   }
 
-  bool ReconstructPreviewSurface(
-      const std::map<std::string, Property> &properties,
-      const std::vector<std::pair<ListEditQual, Reference>> &references,
-      PreviewSurface *surface);
-
-  bool ReconstructUVTexture(
-      const std::map<std::string, Property> &properties,
-      const std::vector<std::pair<ListEditQual, Reference>> &references,
-      UVTexture *texture);
-
-  // Currently float, float2, float3 and float4 only
-  template<typename T>
-  bool ReconstructPrimvarReader(
-      const std::map<std::string, Property> &properties,
-      const std::vector<std::pair<ListEditQual, Reference>> &references,
-      T *reader);
+  void RegisterPrimSpecHandler() {
+    // W.I.P.
+    _parser.RegisterPrimSpecFunction(
+         [&](const Path &full_path, const Specifier spec, const std::string &typeName, const Path &prim_name, const int64_t primIdx,
+            const int64_t parentPrimIdx,
+            const prim::PropertyMap &properties,
+            const ascii::AsciiParser::PrimMetaMap &in_meta,
+            const ascii::AsciiParser::VariantSetList &in_variants)
+            -> nonstd::expected<bool, std::string> {
+
+          if (!prim_name.is_valid()) {
+            return nonstd::make_unexpected("Invalid Prim name: " +
+                                           prim_name.full_path_name());
+          }
+          if (prim_name.is_absolute_path() || prim_name.is_root_path()) {
+            return nonstd::make_unexpected(
+                "Prim name should not starts with '/' or contain `/`: Prim "
+                "name = " +
+                prim_name.full_path_name());
+          }
+
+          if (!prim_name.prop_part().empty()) {
+            return nonstd::make_unexpected(
+                "Prim path should not contain property part(`.`): Prim name "
+                "= " +
+                prim_name.full_path_name());
+          }
+
+          if (primIdx < 0) {
+            return nonstd::make_unexpected(
+                "Unexpected primIdx value. primIdx must be positive.");
+          }
+
+          if (prim_name.prim_part().empty()) {
+            return nonstd::make_unexpected("Prim's name should not be empty ");
+          }
+
+          PrimSpec primspec;
+          primspec.name() = prim_name.prim_part();
+          primspec.specifier() = spec;
+          primspec.typeName() = typeName;
+
+          // TODO: Prim metas
+          // if (!ReconstructPrimMeta(in_meta, &primspec.metas())) {
+          //   return nonstd::make_unexpected(
+          //       "Failed to process Prim metadataum.");
+          // }
 
+          // TODO: props, variants
 
-  void ImportScene(tinyusdz::Stage &scene) { _imported_scene = scene; }
+          DCOUT("primspec name, primType = " << prim_name.prim_part() << ", " << typeName);
+
+          // Assign index for PrimSpec
+          // TODO: Use sample id table(= _prim_nodes)
+
+          if (size_t(primIdx) >= _primspec_nodes.size()) {
+            _primspec_nodes.resize(size_t(primIdx) + 1);
+          }
+          DCOUT("sz " << std::to_string(_primspec_nodes.size())
+                      << ", primIdx = " << primIdx);
+
+          _primspec_nodes[size_t(primIdx)].primSpec = std::move(primspec);
+          DCOUT("primspec[" << primIdx << "].ty = "
+                        << _primspec_nodes[size_t(primIdx)].primSpec.typeName());
+          _primspec_nodes[size_t(primIdx)].parent = parentPrimIdx;
+
+          if (parentPrimIdx == -1) {
+            _toplevel_primspecs.push_back(size_t(primIdx));
+          } else {
+            _primspec_nodes[size_t(parentPrimIdx)].children.push_back(
+                size_t(primIdx));
+            return true;
+          }
+
+          return true;
+      }
+    );
 
-  bool HasPath(const std::string &path) {
-    // TODO
-    TokenizedPath tokPath(path);
-    (void)tokPath;
-    return false;
   }
 
+#if 0 // TODO: Not used. Remove
+  void ImportScene(tinyusdz::Stage &scene) { _imported_scene = scene; }
+#endif
+
   void StageMetaProcessor() {
     _parser.RegisterStageMetaProcessFunction(
         [&](const ascii::AsciiParser::StageMetas &metas) {
           DCOUT("StageMeta CB:");
+
+          _stage.metas().doc = metas.doc;
           if (metas.upAxis) {
-            DCOUT("upAxis = " << to_string(metas.upAxis.value()));
+            _stage.metas().upAxis = metas.upAxis.value();
+          }
+
+          _stage.metas().comment = metas.comment;
+
+          if (metas.subLayers.size()) {
+            _stage.metas().subLayers = metas.subLayers;
+          }
+
+          _stage.metas().defaultPrim = metas.defaultPrim;
+          if (metas.metersPerUnit) {
+            _stage.metas().metersPerUnit = metas.metersPerUnit.value();
+          }
+
+          if (metas.timeCodesPerSecond) {
+            _stage.metas().timeCodesPerSecond =
+                metas.timeCodesPerSecond.value();
+          }
+
+          if (metas.startTimeCode) {
+            _stage.metas().startTimeCode = metas.startTimeCode.value();
+          }
+
+          if (metas.endTimeCode) {
+            _stage.metas().endTimeCode = metas.endTimeCode.value();
+          }
+
+          if (metas.framesPerSecond) {
+            _stage.metas().framesPerSecond = metas.framesPerSecond.value();
+          }
+
+          if (metas.autoPlay) {
+            _stage.metas().autoPlay = metas.autoPlay.value();
+          }
+
+          if (metas.playbackMode) {
+            value::token tok = metas.playbackMode.value();
+            if (tok.str() == "none") {
+              _stage.metas().playbackMode = StageMetas::PlaybackMode::PlaybackModeNone;
+            } else if (tok.str() == "loop") {
+              _stage.metas().playbackMode = StageMetas::PlaybackMode::PlaybackModeLoop;
+            } else {
+              PUSH_ERROR_AND_RETURN("Unsupported playbackMode: " + tok.str());
+            }
           }
 
-          // HACK
-          _upAxis = metas.upAxis;
+          _stage.metas().customLayerData = metas.customLayerData;
+
 
           return true;  // ok
         });
   }
 
+  void RegisterPrimIdxAssignCallback() {
+    _parser.RegisterPrimIdxAssignFunction([&](const int64_t parentPrimIdx) {
+      size_t idx = _prim_nodes.size();
+
+      DCOUT("parentPrimIdx: " << parentPrimIdx << ", idx = " << idx);
+
+      _prim_nodes.resize(idx + 1);
+
+      // if (parentPrimIdx < 0) { // root
+      //   // allocate empty prim to reserve _prim_nodes[idx]
+      //   _prim_nodes.resize(idx + 1);
+      //   DCOUT("resize to : " << (idx + 1));
+      // }
+
+      return idx;
+    });
+  }
+
+  bool ReconstructPrimMeta(const ascii::AsciiParser::PrimMetaMap &in_meta,
+                           PrimMeta *out) {
+
+    auto ApiSchemaHandler = [](const std::string &tok)
+        -> nonstd::expected<APISchemas::APIName, std::string> {
+      using EnumTy = std::pair<APISchemas::APIName, const char *>;
+      const std::vector<EnumTy> enums = {
+          std::make_pair(APISchemas::APIName::SkelBindingAPI, "SkelBindingAPI"),
+          std::make_pair(APISchemas::APIName::MaterialBindingAPI,
+                         "MaterialBindingAPI"),
+          std::make_pair(APISchemas::APIName::Preliminary_PhysicsMaterialAPI,
+                         "Preliminary_PhysicsMaterialAPI"),
+          std::make_pair(APISchemas::APIName::Preliminary_PhysicsRigidBodyAPI,
+                         "Preliminary_PhysicsRigidBodyAPI"),
+          std::make_pair(APISchemas::APIName::Preliminary_PhysicsColliderAPI,
+                         "Preliminary_PhysicsColliderAPI"),
+      };
+      return EnumHandler<APISchemas::APIName>("apiSchemas", tok, enums);
+    };
+
+    auto BuildVariants = [](const CustomDataType &dict) -> nonstd::expected<VariantSelectionMap, std::string> {
+
+      // Allow empty dict.
+
+      VariantSelectionMap m;
+
+      for (const auto &item : dict) {
+        // TODO: duplicated key check?
+        if (auto pv = item.second.get_value<std::string>()) {
+          m[item.first] = pv.value();
+        } else if (auto pvs = item.second.get_value<value::StringData>()) {
+          // TODO: store triple-quote info
+          m[item.first] = pvs.value().value;
+        } else {
+          return nonstd::make_unexpected(fmt::format("TinyUSDZ only accepts `string` value for `variants` element, but got type `{}`(type_id {}).", item.second.type_name(), item.second.type_id()));
+        }
+      }
+
+      return std::move(m);
+
+    };
+
+    DCOUT("ReconstructPrimMeta");
+    for (const auto &meta : in_meta) {
+      DCOUT("meta.name = " << meta.first);
+
+      const auto &listEditQual = std::get<0>(meta.second);
+      const MetaVariable &var = std::get<1>(meta.second);
+
+      if (meta.first == "active") {
+        DCOUT("active. type = " << var.type_name());
+        if (var.type_name() == "bool") {
+          if (auto pv = var.get_value<bool>()) {
+            out->active = pv.value();
+          } else {
+            PUSH_ERROR_AND_RETURN(
+                "(Internal error?) `active` metadataum is not type `bool`.");
+          }
+        } else {
+          PUSH_ERROR_AND_RETURN(
+              "(Internal error?) `active` metadataum is not type `bool`. got `"
+              << var.type_name() << "`.");
+        }
+      } else if (meta.first == "hidden") {
+        DCOUT("hidden. type = " << var.type_name());
+        if (var.type_name() == "bool") {
+          if (auto pv = var.get_value<bool>()) {
+            out->hidden = pv.value();
+          } else {
+            PUSH_ERROR_AND_RETURN(
+                "(Internal error?) `hidden` metadataum is not type `bool`.");
+          }
+        } else {
+          PUSH_ERROR_AND_RETURN(
+              "(Internal error?) `hidden` metadataum is not type `bool`. got `"
+              << var.type_name() << "`.");
+        }
+
+      } else if (meta.first == "sceneName") {
+        DCOUT("sceneName. type = " << var.type_name());
+        if (var.type_name() == value::kString) {
+          if (auto pv = var.get_value<std::string>()) {
+            out->sceneName = pv.value();
+          } else {
+            PUSH_ERROR_AND_RETURN(
+                "(Internal error?) `sceneName` metadataum is not type `string`.");
+          }
+        } else {
+          PUSH_ERROR_AND_RETURN(
+              "(Internal error?) `sceneName` metadataum is not type `string`. got `"
+              << var.type_name() << "`.");
+        }
+      } else if (meta.first == "displayName") {
+        DCOUT("displayName. type = " << var.type_name());
+        if (var.type_name() == value::kString) {
+          if (auto pv = var.get_value<std::string>()) {
+            out->displayName = pv.value();
+          } else {
+            PUSH_ERROR_AND_RETURN(
+                "(Internal error?) `displayName` metadataum is not type `string`.");
+          }
+        } else {
+          PUSH_ERROR_AND_RETURN(
+              "(Internal error?) `displayName` metadataum is not type `string`. got `"
+              << var.type_name() << "`.");
+        }
+      } else if (meta.first == "kind") {
+        // std::tuple<ListEditQual, MetaVariable>
+        // TODO: list-edit qual
+        DCOUT("kind. type = " << var.type_name());
+        if (var.type_name() == "token") {
+          if (auto pv = var.get_value<value::token>()) {
+            const value::token tok = pv.value();
+            if (tok.str() == "subcomponent") {
+              out->kind = Kind::Subcomponent;
+            } else if (tok.str() == "component") {
+              out->kind = Kind::Component;
+            } else if (tok.str() == "model") {
+              out->kind = Kind::Model;
+            } else if (tok.str() == "group") {
+              out->kind = Kind::Group;
+            } else if (tok.str() == "assembly") {
+              out->kind = Kind::Assembly;
+            } else if (tok.str() == "sceneLibrary") {
+              // USDZ specific: https://developer.apple.com/documentation/arkit/usdz_schemas_for_ar/scenelibrary
+              out->kind = Kind::SceneLibrary;
+            } else {
+              PUSH_ERROR_AND_RETURN("Invalid token for `kind` metadataum.");
+            }
+            DCOUT("Added kind: " << to_string(out->kind.value()));
+          } else {
+            PUSH_ERROR_AND_RETURN(
+                "(Internal error?) `kind` metadataum is not type `token`.");
+          }
+        } else {
+          PUSH_ERROR_AND_RETURN(
+              "(Internal error?) `kind` metadataum is not type `token`. got `"
+              << var.type_name() << "`.");
+        }
+      } else if (meta.first == "customData") {
+        DCOUT("customData. type = " << var.type_name());
+        if (var.type_id() == value::TypeTraits<CustomDataType>::type_id()) {
+          if (auto pv = var.get_value<CustomDataType>()) {
+            out->customData = pv.value();
+          } else {
+            PUSH_ERROR_AND_RETURN_TAG(kTag,
+                "(Internal error?) `customData` metadataum is not type "
+                "`dictionary`. got type `"
+                << var.type_name() << "`");
+          }
+
+        } else {
+          PUSH_ERROR_AND_RETURN(
+              "(Internal error?) `customData` metadataum is not type "
+              "`dictionary`. got type `"
+              << var.type_name() << "`");
+        }
+      } else if (meta.first == "assetInfo") {
+        DCOUT("assetInfo. type = " << var.type_name());
+        if (auto pv = var.get_value<CustomDataType>()) {
+          out->assetInfo = pv.value();
+        } else {
+          PUSH_ERROR_AND_RETURN_TAG(kTag,
+              "(Internal error?) `assetInfo` metadataum is not type "
+              "`dictionary`. got type `"
+              << var.type_name() << "`");
+        }
+      } else if (meta.first == "variants") {
+        if (auto pv = var.get_value<CustomDataType>()) {
+          auto pm = BuildVariants(pv.value());
+          if (!pm) {
+            PUSH_ERROR_AND_RETURN(pm.error());
+          }
+          out->variants = (*pm);
+        } else {
+          PUSH_ERROR_AND_RETURN(
+              "(Internal error?) `variants` metadataum is not type "
+              "`dictionary`. got type `"
+              << var.type_name() << "`");
+        }
+      } else if (meta.first == "inherits") {
+        if (auto pvb = var.get_value<value::ValueBlock>()) {
+          out->inherits = std::make_pair(listEditQual, std::vector<Path>());
+        } else if (auto pv = var.get_value<std::vector<Path>>()) {
+          out->inherits = std::make_pair(listEditQual, pv.value());
+        } else if (auto pvp = var.get_value<Path>()) {
+          std::vector<Path> vs;
+          vs.push_back(pvp.value());
+          out->inherits = std::make_pair(listEditQual, vs);
+        } else {
+          PUSH_ERROR_AND_RETURN(
+              "(Internal error?) `inherits` metadataum should be either `path` or `path[]`. "
+              "got type `"
+              << var.type_name() << "`");
+        }
+
+      } else if (meta.first == "specializes") {
+        if (auto pvb = var.get_value<value::ValueBlock>()) {
+          out->specializes = std::make_pair(listEditQual, std::vector<Path>());
+        } else if (auto pv = var.get_value<std::vector<Path>>()) {
+          out->specializes = std::make_pair(listEditQual, pv.value());
+        } else if (auto pvp = var.get_value<Path>()) {
+          std::vector<Path> vs;
+          vs.push_back(pvp.value());
+          out->specializes = std::make_pair(listEditQual, vs);
+        } else {
+          PUSH_ERROR_AND_RETURN(
+              "(Internal error?) `specializes` metadataum should be either `path` or `path[]`. "
+              "got type `"
+              << var.type_name() << "`");
+        }
+
+      } else if (meta.first == "variantSets") {
+        // treat as `string`
+        if (auto pvb = var.get_value<value::ValueBlock>()) {
+          out->variantSets = std::make_pair(listEditQual, std::vector<std::string>());
+        } else if (auto pv = var.get_value<value::StringData>()) {
+          std::vector<std::string> vs;
+          vs.push_back(pv.value().value);
+          out->variantSets = std::make_pair(listEditQual, vs);
+        } else if (auto pvs = var.get_value<std::string>()) {
+          std::vector<std::string> vs;
+          vs.push_back(pvs.value());
+          out->variantSets = std::make_pair(listEditQual, vs);
+        } else if (auto pva = var.get_value<std::vector<std::string>>()) {
+          out->variantSets = std::make_pair(listEditQual, pva.value());
+        } else {
+          PUSH_ERROR_AND_RETURN(
+              "(Internal error?) `variantSets` metadataum is not type "
+              "`string` or `string[]`. got type `"
+              << var.type_name() << "`");
+        }
+      } else if (meta.first == "apiSchemas") {
+        DCOUT("apiSchemas. type = " << var.type_name());
+        if (var.type_name() == "token[]") {
+          APISchemas apiSchemas;
+          if ((listEditQual != ListEditQual::Prepend) && (listEditQual != ListEditQual::ResetToExplicit)) {
+            PUSH_ERROR_AND_RETURN("(PrimMeta) " << "ListEdit op for `apiSchemas` must be empty or `prepend` in TinyUSDZ, but got `" << to_string(listEditQual) << "`");
+          }
+          apiSchemas.listOpQual = listEditQual;
+
+          if (auto pv = var.get_value<std::vector<value::token>>()) {
+
+            for (const auto &item : pv.value()) {
+              // TODO: Multi-apply schema(instance name)
+              auto ret = ApiSchemaHandler(item.str());
+              if (ret) {
+                apiSchemas.names.push_back({ret.value(), /* instanceName */""});
+              } else {
+                PUSH_WARN("(PrimMeta) " << ret.error());
+              }
+            }
+          } else {
+            PUSH_ERROR_AND_RETURN_TAG(kTag, "(Internal error?) `apiSchemas` metadataum is not type "
+            "`token[]`. got type `"
+            << var.type_name() << "`");
+          }
+
+          out->apiSchemas = std::move(apiSchemas);
+        } else {
+          PUSH_ERROR_AND_RETURN_TAG(kTag, "(Internal error?) `apiSchemas` metadataum is not type "
+          "`token[]`. got type `"
+          << var.type_name() << "`");
+        }
+      } else if (meta.first == "references") {
+
+        if (var.is_blocked()) {
+          // make empty
+          std::vector<Reference> refs;
+          out->references = std::make_pair(listEditQual, refs);
+        } else if (auto pv = var.get_value<Reference>()) {
+          // To Reference
+          std::vector<Reference> refs;
+          refs.emplace_back(pv.value());
+          out->references = std::make_pair(listEditQual, refs);
+        } else if (auto pva = var.get_value<std::vector<Reference>>()) {
+          out->references = std::make_pair(listEditQual, pva.value());
+        } else {
+          PUSH_ERROR_AND_RETURN(
+              "(Internal error?) `references` metadataum is not type "
+              "`path` or `path[]`. got type `"
+              << var.type_name() << "`");
+        }
+      } else if (meta.first == "payload") {
+
+        if (var.is_blocked()) {
+          // make empty
+          std::vector<Payload> refs;
+          out->payload = std::make_pair(listEditQual, refs);
+        } else if (auto pv = var.get_value<Reference>()) {
+          // To Payload
+          std::vector<Payload> refs;
+          Payload ref;
+          ref.asset_path = pv.value().asset_path;
+          ref._prim_path = pv.value().prim_path;
+          // TODO: Other member variables
+          refs.emplace_back(ref);
+          out->payload = std::make_pair(listEditQual, refs);
+        } else if (auto pva = var.get_value<std::vector<Reference>>()) {
+          std::vector<Payload> refs;
+          for (const auto &item : pva.value()) {
+            Payload ref;
+            ref.asset_path = item.asset_path;
+            ref._prim_path = item.prim_path;
+            // TODO: Other member variables
+            refs.emplace_back(ref);
+          }
+          out->payload = std::make_pair(listEditQual, refs);
+        } else {
+          PUSH_ERROR_AND_RETURN(
+              "(Internal error?) `references` metadataum is not type "
+              "`path` or `path[]`. got type `"
+              << var.type_name() << "`");
+        }
+      } else if (meta.first == "comment") {
+        if (auto pv = var.get_value<value::StringData>()) {
+          out->comment = pv.value().value;
+        } else if (auto spv = var.get_value<std::string>()) {
+          out->comment = spv.value();
+        }
+      } else {
+        PUSH_WARN("TODO: Prim metadataum : " << meta.first);
+      }
+    }
+
+    return true;
+  }
+
   ///
   /// Reader entry point
   /// TODO: Use callback function(visitor) so that Reconstruct**** function is
   /// invoked in the Parser context.
   ///
-  bool Read(ascii::LoadState state = ascii::LoadState::TOPLEVEL);
+  bool Read(LoadState state = LoadState::Toplevel);
 
   // std::vector<GPrim> GetGPrims() { return _gprims; }
 
   std::string GetDefaultPrimName() const { return _defaultPrim; }
 
   std::string GetError() { return _err; }
 
   std::string GetWarning() { return _warn; }
 
+  ///
+  /// Valid after `Read`.
+  ///
+  bool GetAsLayer(Layer *layer);
+
+  ///
+  /// Valid after `Read`.
+  ///
+  bool ReconstructStage();
+
+  ///
+  /// Valid after `ReconstructStage`.
+  ///
+  const Stage &GetStage() const { return _stage; }
+
+
  private:
-  void RegisterNodeTypes() {
-    _node_types.insert(PrimTypeTrait<Xform>::prim_type_name);
-    _node_types.insert(PrimTypeTrait<GeomSphere>::prim_type_name);
-    _node_types.insert(PrimTypeTrait<GeomCube>::prim_type_name);
-    _node_types.insert(PrimTypeTrait<GeomCylinder>::prim_type_name);
-    _node_types.insert(PrimTypeTrait<GeomBasisCurves>::prim_type_name);
-    _node_types.insert(PrimTypeTrait<GeomMesh>::prim_type_name);
-    _node_types.insert(PrimTypeTrait<GeomSubset>::prim_type_name);
-    _node_types.insert(PrimTypeTrait<Scope>::prim_type_name);
-
-    _node_types.insert(PrimTypeTrait<Material>::prim_type_name);
-    _node_types.insert(PrimTypeTrait<Shader>::prim_type_name);
-
-    //_node_types.insert("NodeGraph");
-
-    _node_types.insert(PrimTypeTrait<LuxSphereLight>::prim_type_name);
-    _node_types.insert(PrimTypeTrait<LuxDomeLight>::prim_type_name);
-    _node_types.insert(PrimTypeTrait<GeomCamera>::prim_type_name);
-    _node_types.insert(PrimTypeTrait<SkelRoot>::prim_type_name);
-    _node_types.insert(PrimTypeTrait<Skeleton>::prim_type_name);
-  }
+  //bool stage_reconstructed_{false};
 
+#if 0
   ///
   /// -- Iterators --
   ///
   class PrimIterator {
    public:
     PrimIterator(const std::vector<size_t> &indices,
                  const std::vector<value::Value> &values, size_t idx = 0)
@@ -513,1773 +1136,768 @@
   const_prim_iterator PrimBegin() {
     return PrimIterator(_toplevel_prims, _prims);
   }
   const_prim_iterator PrimEnd() {
     return PrimIterator(_toplevel_prims, _prims, _toplevel_prims.size());
   }
   size_t PrimSize() { return _toplevel_prims.size(); }
+#endif
 
   ///
   /// -- Members --
   ///
 
-  std::set<std::string> _node_types;
+  // TODO: Remove
+  // std::set<std::string> _node_types;
 
   std::stack<ParseState> parse_stack;
 
   std::string _base_dir;  // Used for importing another USD file
 
-  nonstd::optional<tinyusdz::Stage>
-      _imported_scene;  // Imported scene.
+#if 0 // TODO: Remove since not used.
+  nonstd::optional<tinyusdz::Stage> _imported_scene;  // Imported scene.
+#endif
 
   // "class" defs
-  std::map<std::string, Klass> _klasses;
+  //std::map<std::string, Klass> _klasses;
 
   std::stack<std::string> _path_stack;
 
   std::string _err;
   std::string _warn;
 
   // Cache of loaded `references`
-  // <filename, {defaultPrim index, list of root nodes in referenced usd file}>
-  std::map<std::string, std::pair<uint32_t, std::vector<GPrim>>>
+  // <filename, {defaultPrim index, Layer(PrimSpec data of usd file)}>
+  std::map<std::string, std::pair<uint32_t, Layer>>
       _reference_cache;
 
   // toplevel prims
-  std::vector<size_t> _toplevel_prims;  // index to _prims
+  std::vector<size_t> _toplevel_prims;  // index to _prim_nodes
 
-  // Flattened array of prim nodes.
-  std::vector<value::Value> _prims;
+  // 1D Linearized array of prim nodes.
+  std::vector<PrimNode> _prim_nodes;
 
-  // Path(prim part only) -> index to _prims[]
+  // Path(prim part only) -> index to _prim_nodes[]
   std::map<std::string, size_t> _primpath_to_prim_idx_map;
 
+
+  // toplevel primspecs
+  std::vector<size_t> _toplevel_primspecs;  // index to _prim_nodes
+
+  // Flattened array of primspec nodes.
+  std::vector<PrimSpecNode> _primspec_nodes;
+  // Path(prim part only) -> index to _primspec_nodes[]
+  std::map<std::string, size_t> _primpath_to_primspec_idx_map;
+  bool _primspec_invalidated{true};
+
+
   // load flags
   bool _sub_layered{false};
   bool _referenced{false};
   bool _payloaded{false};
 
   std::string _defaultPrim;
 
-  ascii::AsciiParser _parser;
+  // Used for Ascii parser option
+  USDAReaderConfig _config;
 
-  // HACK
-  nonstd::optional<Axis> _upAxis;
+  ascii::AsciiParser _parser;
 
 };  // namespace usda
 
-#if 1
-// Empty allowedTokens = allow all
-template<class E, size_t N>
-static nonstd::expected<bool, std::string> CheckAllowedTokens(const std::array<std::pair<E, const char *>, N> &allowdTokens, const std::string &tok) {
+namespace {
 
-  if (allowdTokens.empty()) {
-    return true;
-  }
+// bottom up conversion.
+bool ToPrimSpecRec(PrimSpecNode &node,
+                        std::vector<PrimSpecNode> &primspec_nodes, PrimSpec &parent) {
 
-  for (size_t i = 0; i < N; i++) {
-    if (tok.compare(std::get<1>(allowdTokens[i])) == 0) {
-      return true;
+  for (const auto &cidx : node.children) {
+    if (cidx >= primspec_nodes.size()) {
+      return false;
     }
-  }
 
-  std::vector<std::string> toks;
-  for (size_t i = 0; i < N; i++) {
-    toks.push_back(std::get<1>(allowdTokens[i]));
+    PrimSpecNode &child = primspec_nodes[cidx];
+    if (!ToPrimSpecRec(child, primspec_nodes, parent)) {
+      return false;
+    }
   }
 
-  std::string s = join(", ", quote(toks));
-
-  return nonstd::make_unexpected("Allowed tokens are [" + s + "] but got " + quote(tok) + ".");
-};
-#endif
+  parent.children().emplace_back(std::move(node.primSpec));
 
-///
-/// -- Impl reconstruct
-//
-template <>
-bool USDAReader::Impl::ReconstructPrim(
-    const std::map<std::string, Property> &properties,
-    const std::vector<std::pair<ListEditQual, Reference>> &references,
-    Xform *xform) {
-  (void)xform;
+  return true;
+}
 
-  auto CheckAllowedTypeOfXformOp =
-      [](const PrimAttrib &attr,
-         const std::vector<value::TypeId> &allowed_type_ids)
-      -> nonstd::expected<bool, std::string> {
-    for (size_t i = 0; i < allowed_type_ids.size(); i++) {
-      if (attr.var.type_id() == allowed_type_ids[i]) {
-        return true;
-      }
-    }
+}  // namespace
 
-    std::stringstream ss;
+bool USDAReader::Impl::GetAsLayer(Layer *layer) {
 
-    ss << "Allowed type for \"" << attr.name << "\"";
-    if (allowed_type_ids.size() > 1) {
-      ss << " are ";
-    } else {
-      ss << " is ";
-    }
+  if (!layer) {
+    PUSH_ERROR_AND_RETURN("layer arg is nullptr.");
+  }
 
-    for (size_t i = 0; i < allowed_type_ids.size(); i++) {
-      ss << value::GetTypeName(allowed_type_ids[i]);
-      if (i < (allowed_type_ids.size() - 1)) {
-        ss << ", ";
-      } else if (i == (allowed_type_ids.size() - 1)) {
-        ss << " or ";
-      }
-    }
-    ss << ", but got " << value::GetTypeName(attr.var.type_id());
+  if (_primspec_invalidated) {
+    PUSH_ERROR_AND_RETURN("PrimSpec data is invalid. USD data is not loaded or there was an error in earlier GetAsLayer call, or GetAsLayer invoked multiple times.");
+  }
 
-    return nonstd::make_unexpected(ss.str());
-  };
+  layer->prim_specs.clear();
 
-  // ret = (basename, suffix, isTimeSampled?)
-  auto Split =
-      [](const std::string &str) -> std::tuple<std::string, std::string, bool> {
-    bool isTimeSampled{false};
-
-    std::string s = str;
-
-    const std::string tsSuffix = ".timeSamples";
-
-    if (endsWith(s, tsSuffix)) {
-      isTimeSampled = true;
-      // rtrim
-      s = s.substr(0, s.size() - tsSuffix.size());
-    }
+  for (const auto &idx : _toplevel_primspecs) {
+    DCOUT("Toplevel primspec idx: " << std::to_string(idx));
 
-    // TODO: Support multiple namespace(e.g. xformOp:translate:pivot)
-    std::string suffix;
-    if (s.find_last_of(':') != std::string::npos) {
-      suffix = s.substr(s.find_last_of(':') + 1);
+    if (idx >= _primspec_nodes.size()) {
+      PUSH_ERROR_AND_RETURN("[Internal Error] out-of-bounds access.");
     }
 
-    std::string basename = s;
-    if (s.find_last_of(':') != std::string::npos) {
-      basename = s.substr(0, s.find_last_of(':'));
-    }
+    auto &node = _primspec_nodes[idx];
+    PrimSpec &primSpec = node.primSpec;
 
-    return std::make_tuple(basename, suffix, isTimeSampled);
-  };
+    DCOUT("primspec[" << idx << "].typeName = " << primSpec.typeName());
+    DCOUT("primspec[" << idx << "].name = " << primSpec.name());
+    DCOUT("root prim[" << idx << "].num_children = " << primSpec.children().size());
 
-  //
-  // Resolve prepend references
-  //
-  for (const auto &ref : references) {
-    if (std::get<0>(ref) == tinyusdz::ListEditQual::Prepend) {
+    if (!ToPrimSpecRec(node, _primspec_nodes, /* inout */primSpec)) {
+      _primspec_invalidated = true;
+      PUSH_ERROR_AND_RETURN("Construct PrimSpec tree failed.");
     }
-  }
 
-  for (const auto &prop : properties) {
-    DCOUT("prop.name = " << prop.first);
-    if (startsWith(prop.first, "xformOp:translate")) {
-      // TODO: Implement
-      // using allowedTys = tinyusdz::variant<value::float3, value::double3>;
-      std::vector<value::TypeId> ids;
-      auto ret = CheckAllowedTypeOfXformOp(prop.second.attrib, ids);
-      if (!ret) {
-      }
-    }
+    layer->prim_specs.emplace_back(_primspec_nodes[idx].primSpec);
   }
 
-  // Lookup xform values from `xformOpOrder`
-  if (properties.count("xformOpOrder")) {
-    // array of string
-    auto prop = properties.at("xformOpOrder");
-    if (prop.is_rel) {
-      PUSH_WARN("TODO: Rel type for `xformOpOrder`");
-    } else {
-#if 0
-      if (auto parr = value::as_vector<std::string>(&attrib->var)) {
-        for (const auto &item : *parr) {
-          // remove double-quotation
-          std::string identifier = item;
-          identifier.erase(
-              std::remove(identifier.begin(), identifier.end(), '\"'),
-              identifier.end());
-
-          auto tup = Split(identifier);
-          auto basename = std::get<0>(tup);
-          auto suffix = std::get<1>(tup);
-          auto isTimeSampled = std::get<2>(tup);
-          (void)isTimeSampled;
-
-          XformOp op;
-
-          std::string target_name = basename;
-          if (!suffix.empty()) {
-            target_name += ":" + suffix;
-          }
-
-          if (!properties.count(target_name)) {
-            PushError("Property '" + target_name +
-                       "' not found in Xform node.");
-            return false;
-          }
-
-          auto targetProp = properties.at(target_name);
+  // NOTE: _toplevel_primspecs are destroyed(std::move'ed)
+  _primspec_invalidated = true;
 
-          if (basename == "xformOp:rotateZ") {
-            if (auto targetAttr = nonstd::get_if<PrimAttrib>(&targetProp)) {
-              if (auto p = value::as_basic<float>(&targetAttr->var)) {
-                std::cout << "xform got it "
-                          << "\n";
-                op.op = XformOp::OpType::ROTATE_Z;
-                op.suffix = suffix;
-                op.value = (*p);
+  return true;
+}
 
-                xform->xformOps.push_back(op);
-              }
-            }
-          }
-        }
-      }
-      PushError("`xformOpOrder` must be an array of string type.");
-#endif
-      (void)Split;
-    }
+///
+/// -- Impl reconstruct
+//
 
-  } else {
-    // std::cout << "no xformOpOrder\n";
-  }
+namespace {
 
-  // For xformO
-  // TinyUSDZ does no accept arbitrary types for variables with `xformOp` su
 #if 0
-    for (const auto &prop : properties) {
-
-
-      if (prop.first == "xformOpOrder") {
-        if (!prop.second.IsArray()) {
-          PushError("`xformOpOrder` must be an array type.");
-          return false;
-        }
-
-        for (const auto &item : prop.second.array) {
-          if (auto p = nonstd::get_if<std::string>(&item)) {
-            // TODO
-            //XformOp op;
-            //op.op =
+void ReconstructNodeRec(const size_t idx,
+                        const std::vector<PrimNode> &prim_nodes, Prim &parent) {
+  const auto &node = prim_nodes[idx];
+
+  Prim prim(node.prim);
+  prim.prim_type_name() = node.typeName;
+
+  DCOUT("prim[" << idx << "].type = " << node.prim.type_name());
+  //prim.prim_id() = int64_t(idx);
+
+  // First process variants. 
+  std::set<int64_t> variantChildrenIndices; // record variantChildren indices
+
+  std::map<std::string, VariantSet> variantSets;
+  for (const auto &variantNodes : node.variantNodeMap) {
+    VariantSet variantSet;
+    for (const auto &item : variantNodes.second) {
+      Variant variant;
+      for (const int64_t vidx : item.second.primChildren) {
+        if (variantChildrenIndices.count(vidx)) {
+          // Duplicated variant childrenIndices
+          // TODO: Report error.
+        } else {
+          // Add prim to variants
+          if ((vidx >= 0) && (size_t(vidx) <= prim_nodes.size())) {
+            variant.primChildren().emplace_back(std::move(prim_nodes[size_t(vidx)]));
           }
-        }
-
-      } else if (std::get<0>(tup) == "xformOp:rotateZ") {
 
-        if (prop.second.IsTimeSampled()) {
+          variantChildrenIndices.insert(vidx);
+        }
+      }
+      variant.metas() = std::move(item.second.metas);
+      variant.properties() = std::move(item.second.props);
 
-        } else if (prop.second.IsFloat()) {
-          if (auto p = nonstd::get_if<float>(&prop.second.value)) {
-            XformOp op;
-            op.op = XformOp::OpType::ROTATE_Z;
-            op.precision = XformOp::PrecisionType::PRECISION_FLOAT;
-            op.value = *p;
+      variantSet.name = variantNodes.first;
+      variantSet.variantSet.emplace(item.first, std::move(variant));
+    }
+    variantSets.emplace(variantNodes.first, std::move(variantSet));
+  }
 
-            std::cout << "rotateZ value = " << *p << "\n";
+  for (const auto &cidx : node.children) {
+    ReconstructNodeRec(cidx, prim_nodes, prim);
+  }
 
-          } else {
-            PushError("`xformOp:rotateZ` must be an float type.");
-            return false;
-          }
-        } else {
-          PushError(std::to_string(__LINE__) + " TODO: type: " + prop.first +
-                     "\n");
-        }
+  parent.children().emplace_back(std::move(prim));
+}
+#else
 
-      } else {
-        PushError(std::to_string(__LINE__) + " TODO: type: " + prop.first +
-                   "\n");
-        return false;
-      }
+//
+// Construct Prim from PrimNode with botom-up approach 
+// 
+bool ConstructPrimTreeRec(const size_t primIdx,
+                        const std::vector<PrimNode> &prim_nodes,
+                        Prim *destPrim,
+                        std::string *err) {
+
+  if (!destPrim) {
+    if (err) {
+      (*err) = "`destPrim` is nullptr.\n";
     }
-#endif
+    return false;
+  }
 
-  //
-  // Resolve append references
-  // (Overwrite variables with the referenced one).
-  //
-  for (const auto &ref : references) {
-    if (std::get<0>(ref) == tinyusdz::ListEditQual::Append) {
+  if (primIdx >= prim_nodes.size()) {
+    if (err) {
+      (*err) = "primIndex exceeds prim_nodes.size()\n";
     }
+    return false;
   }
 
-  return true;
-}
+  const auto &node = prim_nodes[primIdx];
 
-  ///
-  /// -- RegisterReconstructCallback specializations
-  ///
-  template <>
-  bool USDAReader::Impl::RegisterReconstructCallback<GPrim>() {
-    _parser.RegisterPrimConstructFunction(
-        PrimTypeTrait<GPrim>::prim_type_name,
-        [&](const Path &path, const std::map<std::string, Property> &properties,
-            std::vector<std::pair<ListEditQual, Reference>> &references) {
-          // TODO: Implement
-          GPrim gprim;
+  Prim prim(node.prim);
+  prim.prim_type_name() = node.typeName;
 
-          //
-          // Resolve prepend references
-          //
-          for (const auto &ref : references) {
-            if (std::get<0>(ref) == tinyusdz::ListEditQual::Prepend) {
-            }
+  DCOUT("prim[" << primIdx << "].type = " << node.prim.type_name());
+  DCOUT("prim[" << primIdx << "].variantNodeMap.size = " << node.variantNodeMap.size());
+  //prim.prim_id() = int64_t(idx);
+
+  // Firstly process variants. 
+  std::set<int64_t> variantChildrenIndices; // record variantChildren indices
+
+  std::map<std::string, VariantSet> variantSets;
+  for (const auto &variantNodes : node.variantNodeMap) {
+    DCOUT("variantSet " << variantNodes.first);
+    VariantSet variantSet;
+    for (const auto &item : variantNodes.second) {
+      DCOUT("variant " << item.first);
+      Variant variant;
+      for (const int64_t vidx : item.second.primChildren) {
+        if (variantChildrenIndices.count(vidx)) {
+          // Duplicated variant childrenIndices
+          if (err) {
+            (*err) = fmt::format("variant primIdx {} is referenced multiple times.\n", vidx);
           }
+          return false;
+        } else {
+          // Add prim to variants
+          if ((vidx >= 0) && (size_t(vidx) <= prim_nodes.size())) {
 
-          // Update props;
-          for (auto item : properties) {
-            if (item.second.is_rel) {
-              PUSH_WARN("TODO: rel");
-            } else {
-              gprim.props[item.first].attrib = item.second.attrib;
+            Prim variantChildPrim(value::Value(nullptr)); // dummy
+            if (!ConstructPrimTreeRec(size_t(vidx), prim_nodes, &variantChildPrim, err)) {
+              return false;
             }
-          }
 
-          //
-          // Resolve append references
-          //
-          for (const auto &ref : references) {
-            if (std::get<0>(ref) == tinyusdz::ListEditQual::Prepend) {
+            DCOUT(fmt::format("Added prim {} to variantSet {} : variant {}", variantChildPrim.element_name(), variantNodes.first, item.first));
+            variant.primChildren().emplace_back(variantChildPrim);
+          } else {
+            if (err) {
+              (*err) = "primIndex exceeds prim_nodes.size()\n";
             }
+            return false;
           }
 
-          return true;
-        });
+          variantChildrenIndices.insert(vidx);
+        }
+      }
+      variant.metas() = std::move(item.second.metas);
+      variant.properties() = std::move(item.second.props);
 
-    return true;
+      variantSet.name = variantNodes.first;
+      variantSet.variantSet.emplace(item.first, std::move(variant));
+    }
+    variantSets.emplace(variantNodes.first, std::move(variantSet));
   }
+  prim.variantSets() = std::move(variantSets);
 
-  template<>
-  bool USDAReader::Impl::RegisterReconstructCallback<GeomSubset>() {
-    _parser.RegisterPrimConstructFunction(
-        "GeomSubset",
-        [&](const Path &path, const std::map<std::string, Property> &properties,
-            std::vector<std::pair<ListEditQual, Reference>> &references) {
-          // Parent Prim must be GeomMesh
-          const Path parent = path.GetParentPrim();
-          if (!parent.IsValid()) {
-            PUSH_ERROR_AND_RETURN("Invalid Prim path");
-          }
-
-          if (parent.IsRootPrim()) {
-            PUSH_ERROR_AND_RETURN(
-                "GeomSubset must be a child of GeomMesh prim.");
-          }
-
-          const std::string parent_primpath = parent.GetPrimPart();
-
-          if (!_primpath_to_prim_idx_map.count(parent_primpath)) {
-            PUSH_ERROR_AND_RETURN("Parent Prim not found.");
-          }
-
-          size_t prim_idx = _primpath_to_prim_idx_map[parent_primpath];
-          auto pmesh = _prims[prim_idx].get_value<GeomMesh>();
-          if (!pmesh) {
-            PUSH_ERROR_AND_RETURN("Parent Prim must be GeomMesh, but got " +
-                                  _prims[prim_idx].type_name());
-          }
-          GeomMesh &mesh = pmesh.value();
-
-          GeomSubset subset;
-
-          // uniform token elementType
-          // uniform token familyName
-          // int[] indices
-          // rel material:binding
-
-          if (references.size()) {
-            PUSH_WARN("`references` support in GeomSubset is TODO");
-          }
+  for (const auto &cidx : node.children) {
+    if (variantChildrenIndices.count(int64_t(cidx))) {
+      // Prim is processed
+      continue;
+    }
 
-          // Update props;
-          for (auto item : properties) {
-            if (item.first == "elementType") {
-              if (item.second.IsRel()) {
-                PUSH_ERROR_AND_RETURN(
-                    "`elementType` property as Relation is not supported.");
-              }
-              if (auto pv = item.second.attrib.var.get_value<value::token>()) {
-                if (item.second.attrib.uniform) {
-                  auto e = subset.SetElementType(pv.value().str());
-                  if (!e) {
-                    PUSH_ERROR_AND_RETURN(e.error());
-                  }
-                  continue;
-                }
-              }
-              PUSH_ERROR_AND_RETURN(
-                  "`elementType` property must be `uniform token` type.");
-            } else if (item.first == "familyType") {
-              if (item.second.IsRel()) {
-                PUSH_ERROR_AND_RETURN(
-                    "`familyType` property as Relation is not supported.");
-              }
+    Prim childPrim(value::Value(nullptr)); // dummy
+    if (!ConstructPrimTreeRec(cidx, prim_nodes, &childPrim, err)) {
+      return false;
+    }
 
-              if (auto pv = item.second.attrib.var.get_value<value::token>()) {
-                if (item.second.attrib.uniform) {
-                  auto e = subset.SetFamilyType(pv.value().str());
-                  if (!e) {
-                    PUSH_ERROR_AND_RETURN(e.error());
-                  }
-                  continue;
-                }
-              }
-              PUSH_ERROR_AND_RETURN(
-                  "`familyType` property must be `uniform token` type.");
+    prim.children().emplace_back(std::move(childPrim));
+  }
 
-            } else if (item.first == "indices") {
-              if (item.second.IsRel()) {
-                PUSH_ERROR_AND_RETURN(
-                    "`indices` property as Relation is not supported.");
-              }
+  (*destPrim) = std::move(prim);
+  return true;
+}
 
-              if (auto pv =
-                      item.second.attrib.var.get_value<std::vector<int>>()) {
-                // int -> uint
-                std::transform(pv.value().begin(), pv.value().end(),
-                               std::back_inserter(subset.indices),
-                               [](int a) { return uint32_t(a); });
-              }
+#endif
 
-              PUSH_ERROR_AND_RETURN(
-                  "`indices` property must be `int[]` type, but got `" +
-                  item.second.attrib.var.type_name() + "`");
+}  // namespace
 
-            } else if (item.first == "material:binding") {
-              if (!item.second.IsRel()) {
-                PUSH_ERROR_AND_RETURN(
-                    "`material:binding` property as Attribute is not "
-                    "supported.");
-              }
-            } else {
-              PUSH_WARN("GeomSubeet: TODO: " + item.first);
-            }
-          }
 
-          mesh.geom_subset_children.emplace_back(subset);
 
-          return true;
-        });
+bool USDAReader::Impl::ReconstructStage() {
+  _stage.root_prims().clear();
 
-    return true;
-  }
+  for (const auto &idx : _toplevel_prims) {
+    DCOUT("Toplevel prim idx: " << std::to_string(idx));
 
 #if 0
-  bool RegisterReconstructGeomMeshCallback() {
-    _parser.RegisterPrimConstructFunction(
-        kGeomMesh,
-        [&](const Path &path, const std::map<std::string, Property> &properties,
-            std::vector<std::pair<ListEditQual, Reference>> &references) {
-          GeomMesh mesh;
-
-          if (ReconstructGeomMesh(properties, references, &mesh)) {
-            // TODO
-            PUSH_WARN("TODO: Implement GeomMesh");
-          }
+    const auto &node = _prim_nodes[idx];
 
-          return true;
-        });
+    Prim prim(node.prim);
+    DCOUT("prim[" << idx << "].type = " << node.prim.type_name());
+    //prim.prim_id() = int64_t(idx);
 
-    return true;
-  }
-#endif
+    for (const auto &cidx : node.children) {
+#if 0
+      const auto &child_node = _prim_nodes[cidx];
+      DCOUT("prim[" << idx << "].children = " << cidx << ", type = " << child_node.prim.type_name());
 
-template<>
-bool USDAReader::Impl::ReconstructPrim(
-    const std::map<std::string, Property> &properties,
-    const std::vector<std::pair<ListEditQual, Reference>> &references,
-    GeomSphere *sphere) {
-  (void)sphere;
-
-  //
-  // Resolve prepend references
-  //
-  for (const auto &ref : references) {
-    DCOUT("asset_path = '" + std::get<1>(ref).asset_path + "'\n");
-
-    if ((std::get<0>(ref) == tinyusdz::ListEditQual::ResetToExplicit) ||
-        (std::get<0>(ref) == tinyusdz::ListEditQual::Prepend)) {
-      const Reference &asset_ref = std::get<1>(ref);
-
-      std::string filepath = asset_ref.asset_path;
-      if (!io::IsAbsPath(filepath)) {
-        filepath = io::JoinPath(_base_dir, filepath);
+      prim.children.emplace_back(std::move(child_node.prim));
+#else
+      //ReconstructNodeRec(cidx, _prim_nodes, prim);
+      Prim childPrim(value::Value(nullptr)); // dummy Prim
+      if (!ConstructPrimTreeRec(cidx, _prim_nodes, prim, &childPrim, &_err)) {
+        return false;
       }
-
-      if (_reference_cache.count(filepath)) {
-        DCOUT("Got a cache: filepath = " + filepath);
-
-        const auto root_nodes = _reference_cache.at(filepath);
-        const GPrim &prim = std::get<1>(root_nodes)[std::get<0>(root_nodes)];
-
-        for (const auto &prop : prim.props) {
-          (void)prop;
-#if 0
-          if (auto attr = nonstd::get_if<PrimAttrib>(&prop.second)) {
-            if (prop.first == "radius") {
-              if (auto p = value::as_basic<double>(&attr->var)) {
-                SDCOUT << "prepend reference radius = " << (*p) << "\n";
-                sphere->radius = *p;
-              }
-            }
-          }
 #endif
-        }
-      }
     }
-  }
 
-  for (const auto &prop : properties) {
-    if (prop.first == "material:binding") {
-      // if (auto prel = nonstd::get_if<Rel>(&prop.second)) {
-      //   sphere->materialBinding.materialBinding = prel->path;
-      // } else {
-      //   PushError("`material:binding` must be 'rel' type.");
-      //   return false;
-      // }
-    } else {
-      if (prop.second.is_rel) {
-        PUSH_WARN("TODO: Rel");
-      } else {
-        if (prop.first == "radius") {
-          // const tinyusdz::PrimAttrib &attr = prop.second.attrib;
-          // if (auto p = value::as_basic<double>(&attr->var)) {
-          //   sphere->radius = *p;
-          // } else {
-          //   PushError("`radius` must be double type.");
-          //   return false;
-          // }
-        } else {
-          PUSH_ERROR_AND_RETURN("TODO: type: " + prop.first);
-        }
-      }
-    }
-  }
+    DCOUT("root prim[" << idx << "].elementPath = " << dump_path(prim.element_path()));
+    DCOUT("root prim[" << idx << "].num_children = " << prim.children().size());
 
-  //
-  // Resolve append references
-  // (Overwrite variables with the referenced one).
-  //
-  for (const auto &ref : references) {
-    if (std::get<0>(ref) == tinyusdz::ListEditQual::Append) {
-      const Reference &asset_ref = std::get<1>(ref);
-
-      std::string filepath = asset_ref.asset_path;
-      if (!io::IsAbsPath(filepath)) {
-        filepath = io::JoinPath(_base_dir, filepath);
-      }
+#else
+
+    Prim prim(value::Value(nullptr)); // init with dummy Prim
+    if (!ConstructPrimTreeRec(idx, _prim_nodes, &prim, &_err)) {
+      return false;
+    }
 
-      if (_reference_cache.count(filepath)) {
-        DCOUT("Got a cache: filepath = " + filepath);
+#endif
 
-        const auto root_nodes = _reference_cache.at(filepath);
-        const GPrim &prim = std::get<1>(root_nodes)[std::get<0>(root_nodes)];
+    _stage.root_prims().emplace_back(std::move(prim));
 
-        for (const auto &prop : prim.props) {
-          (void)prop;
-          // if (auto attr = nonstd::get_if<PrimAttrib>(&prop.second)) {
-          //   if (prop.first == "radius") {
-          //     if (auto p = value::as_basic<double>(&attr->var)) {
-          //       SDCOUT << "append reference radius = " << (*p) << "\n";
-          //       sphere->radius = *p;
-          //     }
-          //   }
-          // }
-        }
-      }
-    }
+    DCOUT("num_children = " << _stage.root_prims()[size_t(_stage.root_prims().size() - 1)].children().size());
   }
 
+  // Compute Abs Path from built Prim tree and Assign prim id.
+  _stage.compute_absolute_prim_path_and_assign_prim_id();
+
   return true;
 }
 
-
-template<>
+template <>
 bool USDAReader::Impl::ReconstructPrim(
-    const std::map<std::string, Property> &properties,
-    const std::vector<std::pair<ListEditQual, Reference>> &references,
-    GeomCone *cone) {
-  (void)properties;
-  (void)cone;
-  //
-  // Resolve prepend references
-  //
-  for (const auto &ref : references) {
-    DCOUT("asset_path = '" + std::get<1>(ref).asset_path + "'\n");
-
-    if ((std::get<0>(ref) == tinyusdz::ListEditQual::ResetToExplicit) ||
-        (std::get<0>(ref) == tinyusdz::ListEditQual::Prepend)) {
-      const Reference &asset_ref = std::get<1>(ref);
-
-      std::string filepath = asset_ref.asset_path;
-      if (!io::IsAbsPath(filepath)) {
-        filepath = io::JoinPath(_base_dir, filepath);
-      }
-
-      if (_reference_cache.count(filepath)) {
-        DCOUT("Got a cache: filepath = " + filepath);
+    const prim::PropertyMap &properties,
+    const prim::ReferenceList &references,
+    Xform *xform) {
 
-        const auto root_nodes = _reference_cache.at(filepath);
-        const GPrim &prim = std::get<1>(root_nodes)[std::get<0>(root_nodes)];
+  std::string err;
+  if (!prim::ReconstructPrim(properties, references, xform, &_warn, &err)) {
+    PUSH_ERROR_AND_RETURN("Failed to reconstruct Xform Prim: " << err);
+  }
+  return true;
+}
 
-        for (const auto &prop : prim.props) {
-          (void)prop;
+///
+/// -- RegisterReconstructCallback specializations
+///
 #if 0
-          if (auto attr = nonstd::get_if<PrimAttrib>(&prop.second)) {
-            if (prop.first == "radius") {
-              if (auto p = value::as_basic<double>(&attr->var)) {
-                SDCOUT << "prepend reference radius = " << (*p) << "\n";
-                cone->radius = *p;
-              }
-            } else if (prop.first == "height") {
-              if (auto p = value::as_basic<double>(&attr->var)) {
-                SDCOUT << "prepend reference height = " << (*p) << "\n";
-                cone->height = *p;
-              }
-            }
+template <>
+bool USDAReader::Impl::RegisterReconstructCallback<GPrim>() {
+  // TODO: Move to ReconstructPrim
+  _parser.RegisterPrimConstructFunction(
+      PrimTypeTraits<GPrim>::prim_type_name,
+      [&](const Path &path, const PropertyMap &properties,
+          ReferenceList &references) {
+        // TODO: Implement
+        GPrim gprim;
+
+        //
+        // Resolve prepend references
+        //
+        for (const auto &ref : references) {
+          if (std::get<0>(ref) == tinyusdz::ListEditQual::Prepend) {
           }
-#endif
         }
-      }
-    }
-  }
 
-#if 0
-  for (const auto &prop : properties) {
-    if (prop.first == "material:binding") {
-      if (auto prel = nonstd::get_if<Rel>(&prop.second)) {
-        cone->materialBinding.materialBinding = prel->path;
-      } else {
-        PushError("`material:binding` must be 'rel' type.");
-        return false;
-      }
-    } else if (auto attr = nonstd::get_if<PrimAttrib>(&prop.second)) {
-      if (prop.first == "radius") {
-        if (auto p = value::as_basic<double>(&attr->var)) {
-          cone->radius = *p;
-        } else {
-          PushError("`radius` must be double type.");
-          return false;
-        }
-      } else if (prop.first == "height") {
-        if (auto p = value::as_basic<double>(&attr->var)) {
-          cone->height = *p;
-        } else {
-          PushError("`height` must be double type.");
-          return false;
+        // Update props;
+        for (auto item : properties) {
+          if (item.second.is_relationship()) {
+            PUSH_WARN("TODO: rel");
+          } else {
+            gprim.props[item.first].attrib = item.second.get_attribute();
+          }
         }
-      } else {
-        PushError(std::to_string(__LINE__) + " TODO: type: " + prop.first +
-                   "\n");
-        return false;
-      }
-    }
-  }
-#endif
 
-#if 0
-  //
-  // Resolve append references
-  // (Overwrite variables with the referenced one).
-  //
-  for (const auto &ref : references) {
-    if (std::get<0>(ref) == tinyusdz::ListEditQual::Append) {
-      const Reference &asset_ref = std::get<1>(ref);
-
-      std::string filepath = asset_ref.asset_path;
-      if (!io::IsAbsPath(filepath)) {
-        filepath = io::JoinPath(_base_dir, filepath);
-      }
-
-      if (_reference_cache.count(filepath)) {
-        DCOUT("Got a cache: filepath = " + filepath);
-
-        const auto root_nodes = _reference_cache.at(filepath);
-        const GPrim &prim = std::get<1>(root_nodes)[std::get<0>(root_nodes)];
-
-        for (const auto &prop : prim.props) {
-          if (auto attr = nonstd::get_if<PrimAttrib>(&prop.second)) {
-            if (prop.first == "radius") {
-              if (auto p = value::as_basic<double>(&attr->var)) {
-                SDCOUT << "append reference radius = " << (*p) << "\n";
-                cone->radius = *p;
-              }
-            } else if (prop.first == "height") {
-              if (auto p = value::as_basic<double>(&attr->var)) {
-                SDCOUT << "append reference height = " << (*p) << "\n";
-                cone->height = *p;
-              }
-            }
+        //
+        // Resolve append references
+        //
+        for (const auto &ref : references) {
+          if (std::get<0>(ref) == tinyusdz::ListEditQual::Prepend) {
           }
         }
-      }
-    }
-  }
-#endif
+
+        return true;
+      });
 
   return true;
 }
+#endif
+
+template <>
+bool USDAReader::Impl::RegisterReconstructCallback<GeomSubset>() {
+  _parser.RegisterPrimConstructFunction(
+      "GeomSubset",
+      [&](const Path &full_path, const Specifier spec, const std::string &primTypeName, const Path &prim_name, const int64_t primIdx,
+          const int64_t parentPrimIdx,
+          const prim::PropertyMap &properties,
+          //const prim::ReferenceList &references,
+          const ascii::AsciiParser::PrimMetaMap &in_meta,
+          const ascii::AsciiParser::VariantSetList &in_variantSetList)
+          -> nonstd::expected<bool, std::string> {
+        const Path &parent = full_path.get_parent_prim_path();
+        if (!parent.is_valid()) {
+          return nonstd::make_unexpected("Invalid Prim path.");
+        }
 
+        (void)primTypeName;
 
-template<>
-bool USDAReader::Impl::ReconstructPrim(
-    const std::map<std::string, Property> &properties,
-    const std::vector<std::pair<ListEditQual, Reference>> &references,
-    GeomCube *cube) {
-  (void)properties;
-  (void)cube;
 #if 0
-  //
-  // Resolve prepend references
-  //
-  for (const auto &ref : references) {
-
-    DCOUT("asset_path = '" + std::get<1>(ref).asset_path + "'\n");
-
-    if ((std::get<0>(ref) == tinyusdz::ListEditQual::ResetToExplicit) ||
-        (std::get<0>(ref) == tinyusdz::ListEditQual::Prepend)) {
-      const Reference &asset_ref = std::get<1>(ref);
-
-      std::string filepath = asset_ref.asset_path;
-      if (!io::IsAbsPath(filepath)) {
-        filepath = io::JoinPath(_base_dir, filepath);
-      }
-
-      if (_reference_cache.count(filepath)) {
-        DCOUT("Got a cache: filepath = " + filepath);
+        if (parent.IsRootPrim()) {
+          return nonstd::make_unexpected(
+              "GeomSubset must be defined as a child of GeomMesh prim.");
+        }
+#endif
 
-        const auto root_nodes = _reference_cache.at(filepath);
-        const GPrim &prim = std::get<1>(root_nodes)[std::get<0>(root_nodes)];
+        if (parentPrimIdx < 0) {
+          return nonstd::make_unexpected(
+              "GeomSubset muet be defined as a child of GeomMesh.");
+        }
 
-        for (const auto &prop : prim.props) {
-          if (auto attr = nonstd::get_if<PrimAttrib>(&prop.second)) {
-            if (prop.first == "size") {
-              if (auto p = value::as_basic<double>(&attr->var)) {
-                SDCOUT << "prepend reference size = " << (*p) << "\n";
-                cube->size = *p;
-              }
-            }
-          }
+        if (_prim_nodes.size() < size_t(parentPrimIdx)) {
+          return nonstd::make_unexpected(
+              "Unexpected parentPrimIdx for GeomSubset.");
         }
-      }
-    }
-  }
-#endif
 
-#if 0
-  for (const auto &prop : properties) {
-    if (prop.first == "material:binding") {
-      if (auto prel = nonstd::get_if<Rel>(&prop.second)) {
-        cube->materialBinding.materialBinding = prel->path;
-      } else {
-        PushError("`material:binding` must be 'rel' type.");
-        return false;
-      }
-    } else if (auto attr = nonstd::get_if<PrimAttrib>(&prop.second)) {
-      if (prop.first == "size") {
-        if (auto p = value::as_basic<double>(&attr->var)) {
-          cube->size = *p;
-        } else {
-          PushError("`size` must be double type.");
-          return false;
+        PrimMeta meta;
+        if (!ReconstructPrimMeta(in_meta, &meta)) {
+          return nonstd::make_unexpected("Failed to process Prim metadataum.");
         }
-      } else {
-        PushError(std::to_string(__LINE__) + " TODO: type: " + prop.first +
-                   "\n");
-        return false;
-      }
-    }
-  }
-#endif
 
+    // TODO: Construct GeomMesh first
 #if 0
-  //
-  // Resolve append references
-  // (Overwrite variables with the referenced one).
-  //
-  for (const auto &ref : references) {
-    if (std::get<0>(ref) == tinyusdz::ListEditQual::Append) {
-      const Reference &asset_ref = std::get<1>(ref);
-
-      std::string filepath = asset_ref.asset_path;
-      if (!io::IsAbsPath(filepath)) {
-        filepath = io::JoinPath(_base_dir, filepath);
-      }
+        const std::string parent_primpath = parent.prim_part();
 
-      if (_reference_cache.count(filepath)) {
-        DCOUT("Got a cache: filepath = " + filepath);
+        const PrimNode &pnode = _prim_nodes[size_t(parentPrimIdx)];
+        auto pmesh = pnode.prim.get_value<GeomMesh>();
+        if (!pmesh) {
+          return nonstd::make_unexpected(
+              "Parent Prim must be GeomMesh, but got " +
+              pnode.prim.type_name());
+        }
+        GeomMesh &mesh = pmesh.value();
+
+        GeomSubset subset;
+
+        // uniform token elementType
+        // uniform token familyName
+        // int[] indices
+        // rel material:binding
 
-        const auto root_nodes = _reference_cache.at(filepath);
-        const GPrim &prim = std::get<1>(root_nodes)[std::get<0>(root_nodes)];
+        if (references.size()) {
+          PUSH_WARN("`references` support in GeomSubset is TODO");
+        }
 
-        for (const auto &prop : prim.props) {
-          if (auto attr = nonstd::get_if<PrimAttrib>(&prop.second)) {
-            if (prop.first == "size") {
-              if (auto p = value::as_basic<double>(&attr->var)) {
-                SDCOUT << "append reference size = " << (*p) << "\n";
-                cube->size = *p;
+        // Update props;
+        for (auto item : properties) {
+          if (item.first == "elementType") {
+            if (item.second.is_relationship()) {
+              PUSH_ERROR_AND_RETURN(
+                  "`elementType` property as Relation is not supported.");
+            }
+            if (auto pv = item.second.get_attribute().var.get_value<value::token>()) {
+              if (item.second.get_attribute().uniform) {
+                auto e = subset.SetElementType(pv.value().str());
+                if (!e) {
+                  PUSH_ERROR_AND_RETURN(e.error());
+                }
+                continue;
               }
             }
-          }
-        }
-      }
-    }
-  }
-#endif
-
-  return true;
-}
-
-template<>
-bool USDAReader::Impl::ReconstructPrim(
-    const std::map<std::string, Property> &properties,
-    const std::vector<std::pair<ListEditQual, Reference>> &references,
-    GeomCapsule *capsule) {
-  //
-  // Resolve prepend references
-  //
-  for (const auto &ref : references) {
-    DCOUT("asset_path = '" + std::get<1>(ref).asset_path + "'\n");
-
-    if ((std::get<0>(ref) == tinyusdz::ListEditQual::ResetToExplicit) ||
-        (std::get<0>(ref) == tinyusdz::ListEditQual::Prepend)) {
-      const Reference &asset_ref = std::get<1>(ref);
-
-      std::string filepath = asset_ref.asset_path;
-      if (!io::IsAbsPath(filepath)) {
-        filepath = io::JoinPath(_base_dir, filepath);
-      }
-
-      if (_reference_cache.count(filepath)) {
-        DCOUT("Got a cache: filepath = " + filepath);
-
-        const auto root_nodes = _reference_cache.at(filepath);
-        const GPrim &prim = std::get<1>(root_nodes)[std::get<0>(root_nodes)];
+            PUSH_ERROR_AND_RETURN(
+                "`elementType` property must be `uniform token` type.");
+          } else if (item.first == "familyType") {
+            if (item.second.is_relationship()) {
+              PUSH_ERROR_AND_RETURN(
+                  "`familyType` property as Relation is not supported.");
+            }
 
-        for (const auto &prop : prim.props) {
-          if (prop.second.is_rel) {
-            PUSH_WARN("TODO: Rel");
-          } else {
-            // const PrimAttrib &attrib = prop.second.attrib;
-#if 0
-            if (prop.first == "height") {
-              if (auto p = value::as_basic<double>(&attr->var)) {
-                SDCOUT << "prepend reference height = " << (*p) << "\n";
-                capsule->height = *p;
-              }
-            } else if (prop.first == "radius") {
-              if (auto p = value::as_basic<double>(&attr->var)) {
-                SDCOUT << "prepend reference radius = " << (*p) << "\n";
-                capsule->radius = *p;
-              }
-            } else if (prop.first == "axis") {
-              if (auto p = value::as_basic<Token>(&attr->var)) {
-                SDCOUT << "prepend reference axis = " << p->value << "\n";
-                if (p->value == "x") {
-                  capsule->axis = Axis::X;
-                } else if (p->value == "y") {
-                  capsule->axis = Axis::Y;
-                } else if (p->value == "z") {
-                  capsule->axis = Axis::Z;
-                } else {
-                  PUSH_WARN("Invalid axis token: " + p->value);
+            if (auto pv = item.second.get_attribute().var.get_value<value::token>()) {
+              if (item.second.get_attribute().uniform) {
+                auto e = subset.SetFamilyType(pv.value().str());
+                if (!e) {
+                  PUSH_ERROR_AND_RETURN(e.error());
                 }
+                continue;
               }
             }
-#endif
-          }
-        }
-      }
-    }
-  }
-
-#if 0
-  for (const auto &prop : properties) {
-    if (prop.first == "material:binding") {
-      if (auto prel = nonstd::get_if<Rel>(&prop.second)) {
-        capsule->materialBinding.materialBinding = prel->path;
-      } else {
-        PushError("`material:binding` must be 'rel' type.");
-        return false;
-      }
-    } else if (auto attr = nonstd::get_if<PrimAttrib>(&prop.second)) {
-      if (prop.first == "height") {
-        if (auto p = value::as_basic<double>(&attr->var)) {
-          capsule->height = *p;
-        } else {
-          PushError("`height` must be double type.");
-          return false;
-        }
-      } else if (prop.first == "radius") {
-        if (auto p = value::as_basic<double>(&attr->var)) {
-          capsule->radius = *p;
-        } else {
-          PushError("`radius` must be double type.");
-          return false;
-        }
-      } else if (prop.first == "axis") {
-        if (auto p = value::as_basic<Token>(&attr->var)) {
-          if (p->value == "x") {
-            capsule->axis = Axis::X;
-          } else if (p->value == "y") {
-            capsule->axis = Axis::Y;
-          } else if (p->value == "z") {
-            capsule->axis = Axis::Z;
-          }
-        } else {
-          PushError("`axis` must be token type.");
-          return false;
-        }
-      } else {
-        PushError(std::to_string(__LINE__) + " TODO: type: " + prop.first +
-                   "\n");
-        return false;
-      }
-    }
-  }
+            PUSH_ERROR_AND_RETURN(
+                "`familyType` property must be `uniform token` type.");
 
-  //
-  // Resolve append references
-  // (Overwrite variables with the referenced one).
-  //
-  for (const auto &ref : references) {
-    if (std::get<0>(ref) == tinyusdz::ListEditQual::Append) {
-      const Reference &asset_ref = std::get<1>(ref);
-
-      std::string filepath = asset_ref.asset_path;
-      if (!io::IsAbsPath(filepath)) {
-        filepath = io::JoinPath(_base_dir, filepath);
-      }
+          } else if (item.first == "indices") {
+            if (item.second.is_relationship()) {
+              PUSH_ERROR_AND_RETURN(
+                  "`indices` property as Relation is not supported.");
+            }
 
-      if (_reference_cache.count(filepath)) {
-        DCOUT("Got a cache: filepath = " + filepath);
+            if (auto pv =
+                    item.second.get_attribute().var.get_value<std::vector<int>>()) {
+              // int -> uint
+              std::transform(pv.value().begin(), pv.value().end(),
+                             std::back_inserter(subset.indices),
+                             [](int a) { return uint32_t(a); });
+            }
 
-        const auto root_nodes = _reference_cache.at(filepath);
-        const GPrim &prim = std::get<1>(root_nodes)[std::get<0>(root_nodes)];
+            PUSH_ERROR_AND_RETURN(
+                "`indices` property must be `int[]` type, but got `" +
+                item.second.get_attribute().var.type_name() + "`");
 
-        for (const auto &prop : prim.props) {
-          if (auto attr = nonstd::get_if<PrimAttrib>(&prop.second)) {
-            if (prop.first == "height") {
-              if (auto p = value::as_basic<double>(&attr->var)) {
-                SDCOUT << "append reference height = " << (*p) << "\n";
-                capsule->height = *p;
-              }
-            } else if (prop.first == "radius") {
-              if (auto p = value::as_basic<double>(&attr->var)) {
-                SDCOUT << "append reference radius = " << (*p) << "\n";
-                capsule->radius = *p;
-              }
-            } else if (prop.first == "axis") {
-              if (auto p = value::as_basic<Token>(&attr->var)) {
-                SDCOUT << "prepend reference axis = " << p->value << "\n";
-                if (p->value == "x") {
-                  capsule->axis = Axis::X;
-                } else if (p->value == "y") {
-                  capsule->axis = Axis::Y;
-                } else if (p->value == "z") {
-                  capsule->axis = Axis::Z;
-                } else {
-                  PUSH_WARN("Invalid axis token: " + p->value);
-                }
-              }
+          } else if (item.first == "material:binding") {
+            if (!item.second.is_relationship()) {
+              PUSH_ERROR_AND_RETURN(
+                  "`material:binding` property as Attribute is not "
+                  "supported.");
             }
+          } else {
+            PUSH_WARN("GeomSubset: TODO: " + item.first);
           }
         }
-      }
-    }
-  }
-#endif
 
-  return true;
-}
-
-template<>
-bool USDAReader::Impl::ReconstructPrim(
-    const std::map<std::string, Property> &properties,
-    const std::vector<std::pair<ListEditQual, Reference>> &references,
-    GeomCylinder *cylinder) {
-#if 0
-  //
-  // Resolve prepend references
-  //
-  for (const auto &ref : references) {
-
-    DCOUT("asset_path = '" + std::get<1>(ref).asset_path + "'\n");
-
-    if ((std::get<0>(ref) == tinyusdz::ListEditQual::ResetToExplicit) ||
-        (std::get<0>(ref) == tinyusdz::ListEditQual::Prepend)) {
-      const Reference &asset_ref = std::get<1>(ref);
-
-      std::string filepath = asset_ref.asset_path;
-      if (!io::IsAbsPath(filepath)) {
-        filepath = io::JoinPath(_base_dir, filepath);
-      }
+        mesh.geom_subset_children.emplace_back(subset);
+#else
 
-      if (_reference_cache.count(filepath)) {
-        DCOUT("Got a cache: filepath = " + filepath);
+        // Add GeomSubset to _prim_nodes.
 
-        const auto root_nodes = _reference_cache.at(filepath);
-        const GPrim &prim = std::get<1>(root_nodes)[std::get<0>(root_nodes)];
+        GeomSubset subset;
 
-        for (const auto &prop : prim.props) {
-          if (auto attr = nonstd::get_if<PrimAttrib>(&prop.second)) {
-            if (prop.first == "height") {
-              if (auto p = value::as_basic<double>(&attr->var)) {
-                SDCOUT << "prepend reference height = " << (*p) << "\n";
-                cylinder->height = *p;
-              }
-            } else if (prop.first == "radius") {
-              if (auto p = value::as_basic<double>(&attr->var)) {
-                SDCOUT << "prepend reference radius = " << (*p) << "\n";
-                cylinder->radius = *p;
-              }
-            } else if (prop.first == "axis") {
-              if (auto p = value::as_basic<Token>(&attr->var)) {
-                SDCOUT << "prepend reference axis = " << p->value << "\n";
-                if (p->value == "x") {
-                  cylinder->axis = Axis::X;
-                } else if (p->value == "y") {
-                  cylinder->axis = Axis::Y;
-                } else if (p->value == "z") {
-                  cylinder->axis = Axis::Z;
-                } else {
-                  PUSH_WARN("Invalid axis token: " + p->value);
+        for (auto item : properties) {
+          if (item.first == "elementType") {
+            if (item.second.is_relationship()) {
+              PUSH_ERROR_AND_RETURN(
+                  "`elementType` property as Relation is not supported.");
+            }
+            if (auto pv = item.second.get_attribute().get_value<value::token>()) {
+              if (item.second.get_attribute().variability() == Variability::Uniform) {
+                auto e = subset.SetElementType(pv.value().str());
+                if (!e) {
+                  PUSH_ERROR_AND_RETURN(e.error());
                 }
+                continue;
               }
             }
-          }
-        }
-      }
-    }
-  }
-
-  for (const auto &prop : properties) {
-    if (prop.first == "material:binding") {
-      if (auto prel = nonstd::get_if<Rel>(&prop.second)) {
-        cylinder->materialBinding.materialBinding = prel->path;
-      } else {
-        PushError("`material:binding` must be 'rel' type.");
-        return false;
-      }
-    } else if (auto attr = nonstd::get_if<PrimAttrib>(&prop.second)) {
-      if (prop.first == "height") {
-        if (auto p = value::as_basic<double>(&attr->var)) {
-          cylinder->height = *p;
-        } else {
-          PushError("`height` must be double type.");
-          return false;
-        }
-      } else if (prop.first == "radius") {
-        if (auto p = value::as_basic<double>(&attr->var)) {
-          cylinder->radius = *p;
-        } else {
-          PushError("`radius` must be double type.");
-          return false;
-        }
-      } else if (prop.first == "axis") {
-        if (auto p = value::as_basic<Token>(&attr->var)) {
-          if (p->value == "x") {
-            cylinder->axis = Axis::X;
-          } else if (p->value == "y") {
-            cylinder->axis = Axis::Y;
-          } else if (p->value == "z") {
-            cylinder->axis = Axis::Z;
-          }
-        } else {
-          PushError("`axis` must be token type.");
-          return false;
-        }
-      } else {
-        PushError(std::to_string(__LINE__) + " TODO: type: " + prop.first +
-                   "\n");
-        return false;
-      }
-    }
-  }
-
-  //
-  // Resolve append references
-  // (Overwrite variables with the referenced one).
-  //
-  for (const auto &ref : references) {
-    if (std::get<0>(ref) == tinyusdz::ListEditQual::Append) {
-      const Reference &asset_ref = std::get<1>(ref);
-
-      std::string filepath = asset_ref.asset_path;
-      if (!io::IsAbsPath(filepath)) {
-        filepath = io::JoinPath(_base_dir, filepath);
-      }
-
-      if (_reference_cache.count(filepath)) {
-        DCOUT("Got a cache: filepath = " + filepath);
-
-        const auto root_nodes = _reference_cache.at(filepath);
-        const GPrim &prim = std::get<1>(root_nodes)[std::get<0>(root_nodes)];
+            PUSH_ERROR_AND_RETURN(
+                "`elementType` property must be `uniform token` type.");
+          } else if (item.first == "familyType") {
+            if (item.second.is_relationship()) {
+              PUSH_ERROR_AND_RETURN(
+                  "`familyType` property as Relation is not supported.");
+            }
 
-        for (const auto &prop : prim.props) {
-          if (auto attr = nonstd::get_if<PrimAttrib>(&prop.second)) {
-            if (prop.first == "height") {
-              if (auto p = value::as_basic<double>(&attr->var)) {
-                SDCOUT << "append reference height = " << (*p) << "\n";
-                cylinder->height = *p;
-              }
-            } else if (prop.first == "radius") {
-              if (auto p = value::as_basic<double>(&attr->var)) {
-                SDCOUT << "append reference radius = " << (*p) << "\n";
-                cylinder->radius = *p;
-              }
-            } else if (prop.first == "axis") {
-              if (auto p = value::as_basic<Token>(&attr->var)) {
-                SDCOUT << "prepend reference axis = " << p->value << "\n";
-                if (p->value == "x") {
-                  cylinder->axis = Axis::X;
-                } else if (p->value == "y") {
-                  cylinder->axis = Axis::Y;
-                } else if (p->value == "z") {
-                  cylinder->axis = Axis::Z;
-                } else {
-                  PUSH_WARN("Invalid axis token: " + p->value);
+            if (auto pv = item.second.get_attribute().get_value<value::token>()) {
+              if (item.second.get_attribute().variability() == Variability::Uniform) {
+                auto e = subset.SetFamilyType(pv.value().str());
+                if (!e) {
+                  PUSH_ERROR_AND_RETURN(e.error());
                 }
+                continue;
               }
             }
-          }
-        }
-      }
-    }
-  }
-#endif
-
-  return true;
-}
-
-template<>
-bool USDAReader::Impl::ReconstructPrim(
-    const std::map<std::string, Property> &properties,
-    const std::vector<std::pair<ListEditQual, Reference>> &references,
-    GeomMesh *mesh) {
-  //
-  // Resolve prepend references
-  //
-
-  for (const auto &ref : references) {
-    DCOUT("asset_path = '" + std::get<1>(ref).asset_path + "'\n");
-
-    if ((std::get<0>(ref) == tinyusdz::ListEditQual::ResetToExplicit) ||
-        (std::get<0>(ref) == tinyusdz::ListEditQual::Prepend)) {
-      const Reference &asset_ref = std::get<1>(ref);
-
-      if (endsWith(asset_ref.asset_path, ".obj")) {
-        std::string err;
-        GPrim gprim;
-
-        // abs path.
-        std::string filepath = asset_ref.asset_path;
-
-        if (io::IsAbsPath(asset_ref.asset_path)) {
-          // do nothing
-        } else {
-          if (!_base_dir.empty()) {
-            filepath = io::JoinPath(_base_dir, filepath);
-          }
-        }
-
-        DCOUT("Reading .obj file: " + filepath);
-
-        if (!usdObj::ReadObjFromFile(filepath, &gprim, &err)) {
-          PUSH_ERROR_AND_RETURN("Failed to read .obj(usdObj). err = " + err);
-        }
-        DCOUT("Loaded .obj file: " + filepath);
+            PUSH_ERROR_AND_RETURN(
+                "`familyType` property must be `uniform token` type.");
 
-        mesh->visibility = gprim.visibility;
-        mesh->doubleSided = gprim.doubleSided;
-        mesh->orientation = gprim.orientation;
+          } else if (item.first == "indices") {
+            if (item.second.is_relationship()) {
+              PUSH_ERROR_AND_RETURN(
+                  "`indices` property as Relation is not supported.");
+            }
 
-        if (gprim.props.count("points")) {
-          DCOUT("points");
-          const Property &prop = gprim.props.at("points");
-          if (prop.is_rel) {
-            PUSH_WARN("TODO: points Rel\n");
-          } else {
-            const PrimAttrib &attr = prop.attrib;
-            // PrimVar
-            DCOUT("points.type:" + attr.var.type_name());
-            if (attr.var.is_scalar()) {
-              auto p = attr.var.get_value<std::vector<value::point3f>>();
-              if (p) {
-                mesh->points = p.value();
-              } else {
-                PUSH_ERROR_AND_RETURN("TODO: points.type = " +
-                                      attr.var.type_name());
-              }
-              // if (auto p = value::as_vector<value::float3>(&pattr->var)) {
-              //   DCOUT("points. sz = " + std::to_string(p->size()));
-              //   mesh->points = (*p);
-              // }
+            if (auto pv =
+                    item.second.get_attribute().get_value<std::vector<int>>()) {
+              // int -> uint
+              std::transform(pv.value().begin(), pv.value().end(),
+                             std::back_inserter(subset.indices),
+                             [](int a) { return uint32_t(a); });
             } else {
-              PUSH_ERROR_AND_RETURN("TODO: timesample points.");
+              PUSH_ERROR_AND_RETURN(
+                  "`indices` property must be `int[]` type, but got `" +
+                  item.second.get_attribute().type_name() + "`");
             }
-          }
-        }
 
-      } else {
-        DCOUT("Not a .obj file");
-      }
-    }
-  }
+          } else if (item.first == "material:binding") {
+            if (!item.second.is_relationship()) {
+              PUSH_ERROR_AND_RETURN(
+                  "`material:binding` property as Attribute is not "
+                  "supported.");
+            }
+          } else if (item.first == "familyName") {
+            if (item.second.is_relationship()) {
+              PUSH_ERROR_AND_RETURN(
+                  "`familyName` property as Relation is not supported.");
+            }
 
-  for (const auto &prop : properties) {
-    if (prop.second.is_rel) {
-      if (prop.first == "material:binding") {
-        mesh->materialBinding.materialBinding = prop.second.rel.path;
-      } else {
-        PUSH_WARN("TODO: rel");
-      }
-    } else {
-      const PrimAttrib &attr = prop.second.attrib;
-      if (prop.first == "points") {
-        auto p = attr.var.get_value<std::vector<value::point3f>>();
-        if (p) {
-          mesh->points = (*p);
-        } else {
-          PUSH_ERROR_AND_RETURN(
-              "`GeomMesh::points` must be point3[] type, but got " +
-              attr.var.type_name());
-        }
-      } else if (prop.first == "subdivisionScheme") {
-        auto p = attr.var.get_value<std::string>();
-        if (!p) {
-          PUSH_ERROR_AND_RETURN(
-              "Invalid type for \'subdivisionScheme\'. expected \'STRING\' but "
-              "got " +
-              attr.var.type_name());
-        } else {
-          DCOUT("subdivisionScheme = " + (*p));
-          if (p->compare("none") == 0) {
-            mesh->subdivisionScheme = SubdivisionScheme::None;
-          } else if (p->compare("catmullClark") == 0) {
-            mesh->subdivisionScheme = SubdivisionScheme::CatmullClark;
-          } else if (p->compare("bilinear") == 0) {
-            mesh->subdivisionScheme = SubdivisionScheme::Bilinear;
-          } else if (p->compare("loop") == 0) {
-            mesh->subdivisionScheme = SubdivisionScheme::Loop;
+            if (auto pv = item.second.get_attribute().get_value<value::token>()) {
+              subset.familyName = pv.value();
+            } else {
+              PUSH_ERROR_AND_RETURN(
+                  "`familyName` property must be `token` type, but got `" +
+                  item.second.get_attribute().type_name() + "`");
+            }
           } else {
-            PUSH_ERROR_AND_RETURN("Unknown subdivision scheme: " + (*p));
+            PUSH_WARN("GeomSubset: TODO: " + item.first);
           }
         }
-      } else {
-        PUSH_WARN(" TODO: prop: " + prop.first);
-      }
-    }
-  }
 
-  //
-  // Resolve append references
-  // (Overwrite variables with the referenced one).
-  //
-  for (const auto &ref : references) {
-    if (std::get<0>(ref) == tinyusdz::ListEditQual::Append) {
-      // TODO
-    }
-  }
+        subset.name = prim_name.prim_part();
+        subset.spec = spec;
+        subset.meta = meta;
 
-  return true;
-}
-
-template<>
-bool USDAReader::Impl::ReconstructPrim(
-    const std::map<std::string, Property> &properties,
-    const std::vector<std::pair<ListEditQual, Reference>> &references,
-    GeomBasisCurves *curves) {
-  for (const auto &prop : properties) {
-    if (prop.first == "points") {
-      if (prop.second.is_rel) {
-        PUSH_WARN("TODO: Rel");
-      } else {
-        // const PrimAttrib &attrib = prop.second.attrib;
-#if 0  // TODO
-        attrib.
-        attrib.IsFloat3() && !prop.second.IsArray()) {
-        PushError("`points` must be float3 array type.");
-        return false;
-      }
-
-      const std::vector<float3> p =
-          nonstd::get<std::vector<float3>>(prop.second.value);
-
-      curves->points.resize(p.size() * 3);
-      memcpy(curves->points.data(), p.data(), p.size() * 3);
-#endif
-      }
+        // Add to scene graph.
+        // NOTE: Scene graph is constructed from bottom up manner(Children
+        // first), so add this primIdx to parent's children.
+        if (size_t(primIdx) >= _prim_nodes.size()) {
+          _prim_nodes.resize(size_t(primIdx) + 1);
+        }
+        DCOUT("sz " << std::to_string(_prim_nodes.size())
+                    << ", primIdx = " << primIdx);
 
-    } else if (prop.first == "curveVertexCounts") {
-#if 0  // TODO
-      if (!prop.second.IsInt() && !prop.second.IsArray()) {
-        PushError("`curveVertexCounts` must be int array type.");
-        return false;
-      }
+        _prim_nodes[size_t(primIdx)].prim = std::move(subset);
+        DCOUT("prim[" << primIdx << "].ty = "
+                      << _prim_nodes[size_t(primIdx)].prim.type_name());
+        _prim_nodes[size_t(primIdx)].parent = parentPrimIdx;
 
-      const std::vector<int32_t> p =
-          nonstd::get<std::vector<int32_t>>(prop.second.value);
+        if (parentPrimIdx == -1) {
+          _toplevel_prims.push_back(size_t(primIdx));
+        } else {
+          _prim_nodes[size_t(parentPrimIdx)].children.push_back(
+              size_t(primIdx));
+        }
 
-      curves->curveVertexCounts.resize(p.size());
-      memcpy(curves->curveVertexCounts.data(), p.data(), p.size());
 #endif
 
-    } else {
-      PUSH_WARN("TODO: " << prop.first);
-    }
-  }
+        return true;
+      });
 
   return true;
 }
 
-// TODO(syoyo): TimeSamples, Reference
-#define PARSE_PROPERTY(__prop, __name, __target)             \
-  if (__prop.first == __name) {                               \
-    const PrimAttrib &attr = __prop.second.attrib;                 \
-    if (auto v = attr.var.get_value<decltype(__target)>()) {                     \
-      __target = v.value();                                        \
-    } else {                                                       \
-      PUSH_ERROR_AND_RETURN("Type mismatch. "                      \
-                            << __name << " expects "               \
-                            << value::TypeTrait<decltype(__target)>::type_name()); \
-    } \
-  } else
-
-//#define PARSE_TOKEN_PROPETY(__prop, __name, __ty, __allowed_tokens, __target)             \
-//  if (__prop.first == __name) {                               \
-//    const PrimAttrib &attr = __prop.second.attrib;                 \
-//    if (auto v = attr.var.get_value<__ty>()) {                     \
-//      __target = v.value();                                        \
-//    } else {                                                       \
-//      PUSH_ERROR_AND_RETURN("Type mismatch. "                      \
-//                            << __name << " expects "               \
-//                            << value::TypeTrait<__ty>::type_name()); \
-//    } \
-//  } else
-
-#define PARSE_ENUM_PROPETY(__prop, __name, __enum_handler, __target)             \
-  if (__prop.first == __name) {                               \
-    const PrimAttrib &attr = __prop.second.attrib;                 \
-    if (auto tok = attr.var.get_value<value::token>()) {                     \
-      auto e = __enum_handler(tok.value().str()); \
-      if (e) { \
-        __target = e.value();                                        \
-      } else { \
-        PUSH_ERROR_AND_RETURN(e.error()); \
-      } \
-    } else {                                                       \
-      PUSH_ERROR_AND_RETURN("Type mismatch. "                      \
-                            << __name << " must be `token` type.");     \
-    } \
-  } else
-
-
-#define PARSE_PROPERTY_END_MAKE_ERROR(__prop)  { \
-      PUSH_ERROR_AND_RETURN("Unsupported/unimplemented property: " + __prop.first); \
-    }
-
-#define PARSE_PROPERTY_END_MAKE_WARN(__prop)  { \
-      PUSH_WARN("Unsupported/unimplemented property: " + __prop.first); \
-    }
-
-
-template<>
+template <>
 bool USDAReader::Impl::ReconstructPrim(
-    const std::map<std::string, Property> &properties,
-    const std::vector<std::pair<ListEditQual, Reference>> &references,
-    GeomCamera *camera) {
-
-  auto ProjectionHandler = [](const std::string &tok) -> nonstd::expected<GeomCamera::Projection, std::string> {
-
-    using EnumTy = std::pair<GeomCamera::Projection, const char *>;
-    constexpr std::array<EnumTy, 2> enums = {
-      std::make_pair(GeomCamera::Projection::perspective, "perspective"),
-      std::make_pair(GeomCamera::Projection::orthographic, "orthographic"),
-    };
-
-    auto ret = CheckAllowedTokens<GeomCamera::Projection, enums.size()>(enums, tok);
-    if (!ret) {
-      return nonstd::make_unexpected(ret.error());
-    }
-
-    for (auto &item : enums) {
-      if (tok == item.second) {
-        return item.first;
-      }
-    }
-
-    // Should never reach here, though.
-    return nonstd::make_unexpected(quote(tok) + " is invalid token for `projection` propety");
-  };
-
-  for (const auto &prop : properties) {
-    PARSE_PROPERTY(prop, "focalLength", camera->focalLength)
-    PARSE_PROPERTY(prop, "focusDistance", camera->focusDistance)
-    PARSE_PROPERTY(prop, "exposure", camera->exposure)
-    PARSE_PROPERTY(prop, "fStop", camera->fStop)
-    PARSE_PROPERTY(prop, "horizontalAperture", camera->horizontalAperture)
-    PARSE_PROPERTY(prop, "horizontalApertureOffset", camera->horizontalApertureOffset)
-    PARSE_PROPERTY(prop, "horizontalApertureOffset", camera->horizontalApertureOffset)
-    PARSE_PROPERTY(prop, "clippingRange", camera->clippingRange)
-    PARSE_PROPERTY(prop, "clippingPlanes", camera->clippingPlanes)
-    PARSE_PROPERTY(prop, "shutter:open", camera->shutterOpen)
-    PARSE_PROPERTY(prop, "shutter:close", camera->shutterClose)
-    PARSE_ENUM_PROPETY(prop, "projection", ProjectionHandler, camera->projection)
-    PARSE_PROPERTY_END_MAKE_ERROR(prop)
-  }
-
-  return true;
-}
-
-template<>
-bool USDAReader::Impl::ReconstructPrim<LuxSphereLight>(
-    const std::map<std::string, Property> &properties,
-    const std::vector<std::pair<ListEditQual, Reference>> &references,
-    LuxSphereLight *light) {
-
-  for (const auto &prop : properties) {
-    //PARSE_PROPERTY(prop, "inputs:colorTemperature", light->colorTemperature)
-    PARSE_PROPERTY(prop, "inputs:color", light->color)
-    PARSE_PROPERTY(prop, "inputs:radius", light->color)
-    PARSE_PROPERTY(prop, "inputs:intensity", light->intensity)
-    PARSE_PROPERTY_END_MAKE_WARN(prop)
-  }
-
-  return true;
-}
+    const prim::PropertyMap &properties,
+    const prim::ReferenceList &references,
+    GPrim *gprim) {
+  (void)gprim;
 
+  DCOUT("TODO: Reconstruct GPrim.");
 
-template<>
-bool USDAReader::Impl::ReconstructPrim<LuxDomeLight>(
-    const std::map<std::string, Property> &properties,
-    const std::vector<std::pair<ListEditQual, Reference>> &references,
-    LuxDomeLight *light) {
-
-  for (const auto &prop : properties) {
-    PARSE_PROPERTY(prop, "guideRadius", light->guideRadius)
-    PARSE_PROPERTY(prop, "inputs:diffuse", light->diffuse)
-    PARSE_PROPERTY(prop, "inputs:specular", light->specular)
-    PARSE_PROPERTY(prop, "inputs:colorTemperature", light->colorTemperature)
-    PARSE_PROPERTY(prop, "inputs:color", light->color)
-    PARSE_PROPERTY(prop, "inputs:intensity", light->intensity)
-    PARSE_PROPERTY_END_MAKE_WARN(prop)
-  }
-
-  DCOUT("Implement DomeLight");
-  return true;
-}
-
-template<>
-bool USDAReader::Impl::ReconstructPrim<Scope>(
-    const std::map<std::string, Property> &properties,
-    const std::vector<std::pair<ListEditQual, Reference>> &references, Scope *scope) {
-
-  // `Scope` is just a namespace in scene graph(no node xform)
-
-  // TODO: support custom properties
-  for (const auto &prop : properties) {
-    PUSH_WARN("Unsupported/unimplemented property: " + prop.first);
-  }
+  PUSH_WARN("TODO: Reconstruct GPrim.");
 
   return true;
 }
 
-template<>
-bool USDAReader::Impl::ReconstructPrim<SkelRoot>(
-    const std::map<std::string, Property> &properties,
-    const std::vector<std::pair<ListEditQual, Reference>> &references,
-    SkelRoot *root) {
-  (void)root;
 
-  // TODO: Implement
-  DCOUT("Implement SkelRoot");
-
-  return true;
-}
-
-template<>
-bool USDAReader::Impl::ReconstructPrim<Skeleton>(
-    const std::map<std::string, Property> &properties,
-    const std::vector<std::pair<ListEditQual, Reference>> &references,
-    Skeleton *skel) {
-  (void)skel;
-
-  // TODO: Implement
-  DCOUT("Implement Skeleton");
-
-  return true;
-}
-
-template<>
-bool USDAReader::Impl::ReconstructPrim<Shader>(
-    const std::map<std::string, Property> &properties,
-    const std::vector<std::pair<ListEditQual, Reference>> &references,
-    Shader *shader) {
-  for (const auto &prop : properties) {
-    if (prop.first == "info:id") {
-      const PrimAttrib &attr = prop.second.attrib;
-
-      auto p = attr.var.get_value<std::string>();
-      if (p) {
-        if (p->compare("UsdPreviewSurface") == 0) {
-          PreviewSurface surface;
-          if (!ReconstructPreviewSurface(properties, references, &surface)) {
-            PUSH_WARN("TODO: reconstruct PreviewSurface.");
-          }
-          shader->value = surface;
-        } else if (p->compare("UsdUVTexture") == 0) {
-          UVTexture texture;
-          if (!ReconstructUVTexture(properties, references, &texture)) {
-            PUSH_WARN("TODO: reconstruct UVTexture.");
-          }
-          shader->value = texture;
-        } else if (p->compare("UsdPrimvarReader_float2") == 0) {
-          PrimvarReader_float2 preader;
-          if (!ReconstructPrimvarReader<PrimvarReader_float2>(properties, references,
-                                               &preader)) {
-            PUSH_WARN("TODO: reconstruct PrimvarReader_float2.");
-          }
-          shader->value = preader;
-        } else {
-          PUSH_ERROR_AND_RETURN("Invalid or Unsupported Shader id: " + (*p));
-        }
-      }
-    } else {
-      // std::cout << "TODO: " << prop.first << "\n";
-    }
-  }
-
-  return true;
-}
-
-template<>
+template <>
 bool USDAReader::Impl::ReconstructPrim<NodeGraph>(
-    const std::map<std::string, Property> &properties,
-    const std::vector<std::pair<ListEditQual, Reference>> &references,
+    const prim::PropertyMap &properties,
+    const prim::ReferenceList &references,
     NodeGraph *graph) {
   (void)properties;
   (void)references;
   (void)graph;
 
   PUSH_WARN("TODO: reconstruct NodeGrah.");
 
   return true;
 }
 
-template<>
-bool USDAReader::Impl::ReconstructPrim<Material>(
-    const std::map<std::string, Property> &properties,
-    const std::vector<std::pair<ListEditQual, Reference>> &references,
-    Material *material) {
-  (void)properties;
-  (void)references;
-  (void)material;
-
-  PUSH_WARN("TODO: Implement Material.");
+// Generic Prim handler. T = Xform, GeomMesh, ...
+template <typename T>
+bool USDAReader::Impl::ReconstructPrim(
+    const prim::PropertyMap &properties,
+    const prim::ReferenceList &references,
+    T *prim) {
 
+  std::string err;
+  if (!prim::ReconstructPrim(properties, references, prim, &_warn, &err)) {
+    PUSH_ERROR_AND_RETURN(fmt::format("Failed to reconstruct {} Prim: {}", value::TypeTraits<T>::type_name(), err));
+  }
   return true;
 }
 
-bool USDAReader::Impl::ReconstructPreviewSurface(
-    const std::map<std::string, Property> &properties,
-    const std::vector<std::pair<ListEditQual, Reference>> &references,
-    PreviewSurface *surface) {
-  // TODO:
-  return false;
-}
-
-bool USDAReader::Impl::ReconstructUVTexture(
-    const std::map<std::string, Property> &properties,
-    const std::vector<std::pair<ListEditQual, Reference>> &references,
-    UVTexture *texture) {
-  // TODO:
-  return false;
-}
-
-template<typename T>
-bool USDAReader::Impl::ReconstructPrimvarReader(
-    const std::map<std::string, Property> &properties,
-    const std::vector<std::pair<ListEditQual, Reference>> &references,
-    T *preader) {
-
-  // TODO: string, point, vector, matrix
-  static_assert(
-    std::is_same<T, PrimvarReader_int>::value ||
-    std::is_same<T, PrimvarReader_float>::value ||
-    std::is_same<T, PrimvarReader_float2>::value ||
-    std::is_same<T, PrimvarReader_float3>::value ||
-    std::is_same<T, PrimvarReader_float4>::value, "Invalid type for PrimvarReader");
-
-
-  // Common
-  // uniform token info:implementationSource
-  // uniform asset info:glslfx:sourceAsset
-  // string inputs:varname (`primvar` namespace should be omitted)
-  //   ( sdrMetadata = {
-  //         bool primvarProperty = 1  # or string primvarProperty = "1"
-  //    }
-  //   )
-
-
-  // Per shader
-  // T inputs:fallback
-  // T outputs:result
-
-  // TODO:
-  return false;
-}
-
 ///
 /// -- Impl callback specializations
 ///
-template <>
-bool USDAReader::Impl::RegisterReconstructCallback<Xform>() {
-  _parser.RegisterPrimConstructFunction(
-      PrimTypeTrait<Xform>::prim_type_name,
-      [&](const Path &path, const std::map<std::string, Property> &properties,
-          std::vector<std::pair<ListEditQual, Reference>> &references) {
-        Xform xform;
-
-        DCOUT("Reconstruct Xform: Path.PrimPart = " << path.GetPrimPart());
-
-        if (!ReconstructPrim<Xform>(properties, references, &xform)) {
-          return false;
-        }
-
-        Path parent = path.GetParentPrim();
-        if (parent.IsRootPrim()) {
-          size_t idx = _prims.size();
-          _prims.push_back(xform);
-          _toplevel_prims.push_back(idx);
-        } else {
-          PUSH_WARN("TODO: Implement xform");
-        }
-
-        return true;
-      });
-
-  return true;
-}
 
 ///
 /// -- Impl Read
 ///
 
-bool USDAReader::Impl::Read(ascii::LoadState state) {
+bool USDAReader::Impl::Read(LoadState state) {
+
+  ///
+  /// Convert parser option.
+  ///
+  ascii::AsciiParserOption ascii_parser_option;
+  ascii_parser_option.allow_unknown_prim = _config.allow_unknown_prims;
+  ascii_parser_option.allow_unknown_apiSchema = _config.allow_unknown_apiSchema;
+
   ///
   /// Setup callbacks.
   ///
   StageMetaProcessor();
-  RegisterReconstructCallback<GPrim>();
+
+  RegisterPrimIdxAssignCallback();
+
+  // For composition(load state = !Toplevel)
+  RegisterPrimSpecHandler();
+
+  // For direct Prim reconstruction(load state = Toplevel)
+  RegisterReconstructCallback<Model>();  // Generic prim.
+
+  RegisterReconstructCallback<GPrim>(); // Geometric prim
+
   RegisterReconstructCallback<Xform>();
   RegisterReconstructCallback<GeomCube>();
   RegisterReconstructCallback<GeomSphere>();
   RegisterReconstructCallback<GeomCone>();
+  RegisterReconstructCallback<GeomPoints>();
   RegisterReconstructCallback<GeomCylinder>();
   RegisterReconstructCallback<GeomCapsule>();
   RegisterReconstructCallback<GeomMesh>();
   RegisterReconstructCallback<GeomSubset>();
+  RegisterReconstructCallback<GeomBasisCurves>();
+  RegisterReconstructCallback<GeomCamera>();
+
+  RegisterReconstructCallback<Material>();
+  RegisterReconstructCallback<Shader>();
 
   RegisterReconstructCallback<Scope>();
 
-  RegisterReconstructCallback<LuxSphereLight>();
-  RegisterReconstructCallback<LuxDomeLight>();
+  RegisterReconstructCallback<SphereLight>();
+  RegisterReconstructCallback<DomeLight>();
+  RegisterReconstructCallback<DiskLight>();
+  RegisterReconstructCallback<DistantLight>();
+  RegisterReconstructCallback<CylinderLight>();
 
   RegisterReconstructCallback<SkelRoot>();
   RegisterReconstructCallback<Skeleton>();
+  RegisterReconstructCallback<SkelAnimation>();
+  RegisterReconstructCallback<BlendShape>();
 
-  if (!_parser.Parse(state)) {
+  if (!_parser.Parse(state, ascii_parser_option)) {
     std::string warn = _parser.GetWarning();
     if (!warn.empty()) {
       PUSH_WARN("<parser> " + warn);
     }
 
-    PUSH_ERROR_AND_RETURN("Parse failed:" + _parser.GetError());
-  }
-
-  // HACK
-  if (_upAxis) {
-    DCOUT("upAxis = " << to_string(_upAxis.value()));
-  }
-
-  DCOUT("# of toplevel prims = " << std::to_string(PrimSize()));
-
-  {
-    size_t i = 0;
-    for (auto it = PrimBegin(); it != PrimEnd(); ++it, i++) {
-      DCOUT("Prim[" << std::to_string(i) << "].type = " << (*it).type_name());
-    }
+    PUSH_ERROR_AND_RETURN("Parse failed:\n" + _parser.GetError());
   }
 
-#if 0
-    //_sub_layered = (state == LOAD_STATE_SUBLAYER);
-    //_referenced = (state == LOAD_STATE_REFERENCE);
-    //_payloaded = (state == LOAD_STATE_PAYLOAD);
-
-    // Stage meta.
-    if (!_parser.ParseStageMetas()) {
-      PUSH_PARSER_ERROR_AND_RETURN();
-      return false;
-    }
-
-    DCOUT("Done parsing Stage metas");
-
-    // parse blocks
-    while (!_parser.Eof()) {
-      if (!_parser.SkipCommentAndWhitespaceAndNewline()) {
-        PUSH_PARSER_ERROR_AND_RETURN();
-      }
-
-      if (_parser.Eof()) {
-        // Whitespaces in the end of line.
-        break;
-      }
-
-      // Look ahead token
-      auto curr_loc = _parser.CurrLoc();
-      DCOUT("loc = " << curr_loc);
-
-      std::string tok;
-      if (!_parser.ReadIdentifier(&tok)) {
-        DCOUT("Failed to read identifier");
-        PUSH_PARSER_ERROR_AND_RETURN();
-      }
-      DCOUT("tok = " << tok);
-
-      // Rewind
-      if (!_parser.SeekTo(curr_loc)) {
-        PUSH_PARSER_ERROR_AND_RETURN();
-      }
-
-      if (tok == "def") {
-        DCOUT("`def` block");
-        bool block_ok = _parser.ParseDefBlock();
-        if (!block_ok) {
-          PUSH_PARSER_ERROR_AND_RETURN();
-        }
-      } else if (tok == "over") {
-        DCOUT("`over` block");
-        bool block_ok = _parser.ParseOverBlock();
-        if (!block_ok) {
-          PUSH_PARSER_ERROR_AND_RETURN();
-        }
-      } else if (tok == "class") {
-        DCOUT("`class` block");
-        bool block_ok = _parser.ParseClassBlock();
-        if (!block_ok) {
-          PUSH_PARSER_ERROR_AND_RETURN();
-        }
-      } else {
-        PUSH_ERROR_AND_RETURN("Unknown identifier '" + tok + "' for Prim block statement.");
-      }
-    }
-#endif
   return true;
 }
 
 //
 // --
 //
 
@@ -2301,57 +1919,91 @@
 ///
 /// -- USDAReader
 ///
 USDAReader::USDAReader(StreamReader *sr) { _impl = new Impl(sr); }
 
 USDAReader::~USDAReader() { delete _impl; }
 
-bool USDAReader::Read(ascii::LoadState state) { return _impl->Read(state); }
+bool USDAReader::Read(const LoadState state) { return _impl->Read(state); }
 
 void USDAReader::SetBaseDir(const std::string &dir) {
   return _impl->SetBaseDir(dir);
 }
 
 // std::vector<GPrim> USDAReader::GetGPrims() { return _impl->GetGPrims(); }
 
-std::string USDAReader::GetDefaultPrimName() const {
-  return _impl->GetDefaultPrimName();
-}
+//std::string USDAReader::GetDefaultPrimName() const {
+//  return _impl->GetDefaultPrimName();
+//}
 
 std::string USDAReader::GetError() { return _impl->GetError(); }
 std::string USDAReader::GetWarning() { return _impl->GetWarning(); }
 
+bool USDAReader::GetAsLayer(Layer *layer) { return _impl->GetAsLayer(layer); }
 
-}  // namespace tinyusdz
+bool USDAReader::ReconstructStage() { return _impl->ReconstructStage(); }
+
+const Stage &USDAReader::GetStage() const { return _impl->GetStage(); }
+
+void USDAReader::set_reader_config(const USDAReaderConfig &config) {
+  return _impl->set_reader_config(config);
+}
+
+const USDAReaderConfig USDAReader::get_reader_config() const {
+  return _impl->get_reader_config();
+}
+
+}  // namespace usda
 }  // namespace tinyusdz
 
 #else
 
 namespace tinyusdz {
 namespace usda {
 
-USDAReader::USDAReader(StreamReader *sr) { (void)sr; }
+USDAReader::USDAReader(StreamReader *sr) {
+  _empty_stage = new Stage();
+  (void)sr;
+}
 
-USDAReader::~USDAReader() {}
+USDAReader::~USDAReader() {
+  delete _empty_stage;
+  _empty_stage = nullptr;
+}
 
 bool USDAReader::CheckHeader() { return false; }
 
-bool USDAReader::Parse(ascii::AsciiParser::LoadState state) {
+bool USDAReader::Read(const LoadState state) {
   (void)state;
   return false;
 }
 
 void USDAReader::SetBaseDir(const std::string &dir) { (void)dir; }
 
 std::vector<GPrim> USDAReader::GetGPrims() { return {}; }
 
 std::string USDAReader::GetDefaultPrimName() const { return std::string{}; }
 
 std::string USDAReader::GetError() {
   return "USDA parser feature is disabled in this build.\n";
 }
 std::string USDAReader::GetWarning() { return std::string{}; }
+bool USDAReader::ReconstructStage() { return false; }
+
+bool USDAReader::GetAsLayer(Layer *layer) { return false; }
+
+const Stage &USDAReader::GetStage() const {
+  return *_empty_stage;
+}
+
+void USDAReader::set_reader_config(const USDAReaderConfig &config) {
+  (void)config;
+}
+
+USDAReaderConfig USDAReader::get_reader_config() const {
+  return USDAReaderConfig();
+}
 
 }  // namespace usda
 }  // namespace tinyusdz
 
 #endif
```

### Comparing `tinyusdz-0.8.0rc0/src/usda-reader.hh` & `tinyusdz-0.8.0rc1/src/usda-reader.hh`

 * *Files 26% similar despite different names*

```diff
@@ -7,21 +7,19 @@
 
 #include "ascii-parser.hh"
 
 namespace tinyusdz {
 
 namespace usda {
 
-//enum LoadState {
-//  LOAD_STATE_TOPLEVEL,   // toplevel .usda input
-//  LOAD_STATE_SUBLAYER,   // .usda is read by 'subLayers'
-//  LOAD_STATE_REFERENCE,  // .usda is read by `references`
-//  LOAD_STATE_PAYLOAD,    // .usda is read by `payload`
-//};
-
+struct USDAReaderConfig {
+  bool allow_unknown_prims{true};
+  bool allow_unknown_shader{true};
+  bool allow_unknown_apiSchema{true};
+};
 
 ///
 /// Test if input file is USDA format.
 ///
 bool IsUSDA(const std::string &filename, size_t max_filesize = 0);
 
 class USDAReader {
@@ -41,50 +39,78 @@
 
   ///
   /// Base filesystem directory to search asset files.
   ///
   void SetBaseDir(const std::string &base_dir);
 
   ///
+  /// Set reader option
+  ///
+  void set_reader_config(const USDAReaderConfig &config);
+
+  ///
+  /// Get reader option
+  ///
+  const USDAReaderConfig get_reader_config() const; // NOTE: Not returning reference to avoid static memory allocation.
+
+  ///
   /// Check if header data is USDA
   ///
   bool CheckHeader();
 
   ///
   /// Reader entry point
   ///
-  bool Read(ascii::LoadState state = ascii::LoadState::TOPLEVEL);
+  bool Read(LoadState state = LoadState::Toplevel);
 
+#if 0
   ///
   ///
   ///
   std::string GetDefaultPrimName() const;
 
   ///
   /// Get parsed toplevel "def" nodes(GPrim)
   ///
   std::vector<GPrim> GetGPrims();
+#endif
 
   ///
   /// Get error message(when `Parse` failed)
   ///
   std::string GetError();
 
   ///
   /// Get warning message(warnings in `Parse`)
   ///
   std::string GetWarning();
 
   ///
-  /// Get as stage(scene graph)
+  /// Get read USD scene data as Layer
+  /// Must be called after `Read`
+  ///
+  bool GetAsLayer(Layer *layer);
+
+  ///
+  /// Reconstruct Stage from loaded USD scene data.
+  /// Must be called after `Read`
+  ///
+  bool ReconstructStage();
+
+  ///
+  /// Get as stage(scene graph). Must call `ReconstructStage` beforehand.
   ///
   const Stage& GetStage() const;
 
  private:
+#if defined(TINYUSDZ_DISABLE_MODULE_USDA_READER)
+  Stage *_empty_stage{nullptr};
+#else
   class Impl;
-  Impl *_impl;
+  Impl *_impl{nullptr};
+#endif
 
 };
 
 } // namespace usda
 
 } // namespace tinyusdz
```

### Comparing `tinyusdz-0.8.0rc0/src/usdc-reader.cc` & `tinyusdz-0.8.0rc1/src/tydra/render-data.cc`

 * *Files 24% similar despite different names*

```diff
@@ -1,1889 +1,2216 @@
-// SPDX-License-Identifier: MIT
-// Copyright 2020-Present Syoyo Fujita.
-//
-// USDC(Crate) reader
 //
 // TODO:
+//   - [ ] Support time-varying shader attribute(timeSamples)
 //
-// - [ ] Refactor Reconstruct*** function
-// - [ ] Set `custom` in property by looking up schema.
-// - [ ] And more...
-//
-
-#ifdef _MSC_VER
-#ifndef NOMINMAX
-#define NOMINMAX
-#endif
-#endif
-
-#include "usdc-reader.hh"
-
-#if !defined(TINYUSDZ_DISABLE_MODULE_USDC_READER)
-
-#include <unordered_map>
-#include <unordered_set>
-
+#include "asset-resolution.hh"
+#include "image-loader.hh"
+#include "pprinter.hh"
 #include "prim-types.hh"
+#include "str-util.hh"
+#include "tiny-format.hh"
 #include "tinyusdz.hh"
-#include "value-types.hh"
-#if defined(__wasi__)
-#else
-#include <thread>
-#endif
-
-#include "crate-format.hh"
-#include "crate-pprint.hh"
-#include "crate-reader.hh"
-#include "integerCoding.h"
-#include "lz4-compression.hh"
-#include "path-util.hh"
-#include "pprinter.hh"
-#include "stream-reader.hh"
+#include "usdGeom.hh"
+#include "usdShade.hh"
 #include "value-pprint.hh"
+#include "image-util.hh"
+
+#if defined(TINYUSDZ_WITH_COLORIO)
+#include "external/tiny-color-io.h"
+#endif
 
-//
 #ifdef __clang__
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Weverything"
 #endif
 
-#include "nonstd/expected.hpp"
+// For triangulation.
+// TODO: Use tinyobjloader's triangulation
+#include "external/mapbox/earcut/earcut.hpp"
 
 #ifdef __clang__
 #pragma clang diagnostic pop
 #endif
 
 //
+#include "common-macros.inc"
+#include "math-util.inc"
 
-#ifdef TINYUSDZ_PRODUCTION_BUILD
-// Do not include full filepath for privacy.
-#define PUSH_ERROR(s)                                               \
-  {                                                                 \
-    std::ostringstream ss;                                          \
-    ss << "[usdc-parser] " << __func__ << "():" << __LINE__ << " "; \
-    ss << s;                                                        \
-    _err += ss.str() + "\n";                                        \
-  }                                                                 \
-  while (0)
-
-#define PUSH_WARN(s)                                                \
-  {                                                                 \
-    std::ostringstream ss;                                          \
-    ss << "[usdc-parser] " << __func__ << "():" << __LINE__ << " "; \
-    ss << s;                                                        \
-    _warn += ss.str() + "\n";                                       \
-  }                                                                 \
-  while (0)
+//
+#include "tydra/render-data.hh"
+#include "tydra/scene-access.hh"
+#include "tydra/shader-network.hh"
 
-#else
+namespace tinyusdz {
+
+namespace tydra {
+
+namespace {
 
 #if 0
-#define PUSH_ERROR(s)                                              \
-  {                                                                \
-    std::ostringstream ss;                                         \
-    ss << __FILE__ << ":" << __func__ << "():" << __LINE__ << " "; \
-    ss << s;                                                       \
-    _err += ss.str() + "\n";                                       \
-  }                                                                \
-  while (0)
-
-#define PUSH_WARN(s)                                               \
-  {                                                                \
-    std::ostringstream ss;                                         \
-    ss << __FILE__ << ":" << __func__ << "():" << __LINE__ << " "; \
-    ss << s;                                                       \
-    _warn += ss.str() + "\n";                                      \
-  }                                                                \
-  while (0)
+template <typename T>
+inline T Get(const nonstd::optional<T> &nv, const T &default_value) {
+  if (nv) {
+    return nv.value();
+  }
+  return default_value;
+}
 #endif
 
-#endif
+//
+// Convert vertex attribute with Uniform interpolation to facevarying attribute,
+// by replicating uniform value per face over face vertices(per face).
+//
+template <typename T>
+nonstd::expected<std::vector<T>, std::string> UniformToFaceVarying(
+  const std::vector<T> &inputs,
+  const std::vector<uint32_t> &faceVertexCounts,
+  const std::vector<uint32_t> &faceVertexIndices)
+{
+  (void)faceVertexIndices;
 
-#include "common-macros.inc"
+  std::vector<T> dst;
 
-namespace tinyusdz {
-namespace usdc {
+  if (inputs.size() == faceVertexCounts.size()) {
+    return nonstd::make_unexpected(fmt::format("The number of inputs {} must be the same with faceVertexCounts.size() {}", inputs.size(), faceVertexCounts.size()));
+  }
 
+  for (size_t i = 0; i < faceVertexCounts.size(); i++) {
+    size_t cnt = faceVertexCounts[i];
 
-class USDCReader::Impl {
- public:
-  Impl(StreamReader *sr, int num_threads) : _sr(sr) {
-    if (num_threads == -1) {
-#if defined(__wasi__)
-      num_threads = 1;
-#else
-      num_threads = (std::max)(1, int(std::thread::hardware_concurrency()));
-#endif
+    // repeat cnt times.
+    for (size_t k = 0; k < cnt; k++) {
+      dst.emplace_back(inputs[i]);
     }
+  }
+
+  return dst;
+}
+
+template <typename T>
+nonstd::expected<std::vector<T>, std::string> VertexToFaceVarying(
+  const std::vector<T> &inputs,
+  const std::vector<uint32_t> &faceVertexCounts,
+  const std::vector<uint32_t> &faceVertexIndices)
+{
+  std::vector<T> dst;
+
+  size_t face_offset{0};
+  for (size_t i = 0; i < faceVertexCounts.size(); i++) {
+    size_t cnt = faceVertexCounts[i];
 
-    // Limit to 1024 threads.
-    _num_threads = (std::min)(1024, num_threads);
+    for (size_t k = 0; k < cnt; k++) {
+      size_t idx = k + face_offset;
+
+      if (idx >= faceVertexIndices.size()) {
+        return nonstd::make_unexpected(fmt::format("faeVertexIndex out-of-range at faceVertexCount[{}]", i));
+      }
+
+      size_t v_idx = faceVertexIndices[idx];
+
+      if (v_idx >= inputs.size()) {
+        return nonstd::make_unexpected(fmt::format("faeVertexIndices[{}] {} exceeds input array size {}", idx, v_idx, inputs.size()));
+      }
+
+      dst.emplace_back(inputs[v_idx]);
+    }
+
+    face_offset += cnt;
   }
 
-  ~Impl() {
-    delete crate_reader;
-    crate_reader = nullptr;
+  return dst;
+}
+
+//
+// name does not include "primvars:" prefix.
+// TODO: timeSamples, connected attribute.
+//
+nonstd::expected<VertexAttribute, std::string> GetTextureCoordinate(
+    const Stage &state, const GeomMesh &mesh, const std::string &name) {
+  VertexAttribute vattr;
+
+  (void)state;
+
+  GeomPrimvar primvar;
+  if (!mesh.get_primvar(name, &primvar)) {
+    return nonstd::make_unexpected(fmt::format("No primvars:{}\n", name));
   }
 
-  bool ReadUSDC();
+  if (!primvar.has_value()) {
+    return nonstd::make_unexpected("No value exist for primvars:" + name + "\n");
+  }
 
-#if 0
-  ///
-  /// Parse node's attribute from FieldValuePairVector.
-  ///
-  bool ParseAttribute(const FieldValuePairVector &fvs, PrimAttrib *attr,
-                      const std::string &prop_name);
-
-  bool ReconstructXform(const Node &node, const FieldValuePairVector &fields,
-                        const std::unordered_map<uint32_t, uint32_t>
-                            &path_index_to_spec_index_map,
-                        Xform *xform);
-
-  bool ReconstructGeomSubset(const Node &node,
-                             const FieldValuePairVector &fields,
-                             const std::unordered_map<uint32_t, uint32_t>
-                                 &path_index_to_spec_index_map,
-                             GeomSubset *mesh);
-
-  bool ReconstructGeomMesh(const Node &node, const FieldValuePairVector &fields,
-                           const std::unordered_map<uint32_t, uint32_t>
-                               &path_index_to_spec_index_map,
-                           GeomMesh *mesh);
-
-  bool ReconstructGeomBasisCurves(const Node &node,
-                                  const FieldValuePairVector &fields,
-                                  const std::unordered_map<uint32_t, uint32_t>
-                                      &path_index_to_spec_index_map,
-                                  GeomBasisCurves *curves);
-
-  bool ReconstructMaterial(const Node &node, const FieldValuePairVector &fields,
-                           const std::unordered_map<uint32_t, uint32_t>
-                               &path_index_to_spec_index_map,
-                           Material *material);
-
-  bool ReconstructShader(const Node &node, const FieldValuePairVector &fields,
-                         const std::unordered_map<uint32_t, uint32_t>
-                             &path_index_to_spec_index_map,
-                         Shader *shader);
-
-  bool ReconstructPreviewSurface(const Node &node,
-                                 const FieldValuePairVector &fields,
-                                 const std::unordered_map<uint32_t, uint32_t>
-                                     &path_index_to_spec_index_map,
-                                 PreviewSurface *surface);
-
-  bool ReconstructUVTexture(const Node &node,
-                            const FieldValuePairVector &fields,
-                            const std::unordered_map<uint32_t, uint32_t>
-                                &path_index_to_spec_index_map,
-                            UVTexture *uvtex);
-
-  bool ReconstructPrimvarReader_float2(
-      const Node &node, const FieldValuePairVector &fields,
-      const std::unordered_map<uint32_t, uint32_t>
-          &path_index_to_spec_index_map,
-      PrimvarReader_float2 *preader);
-
-  bool ReconstructSkelRoot(const Node &node, const FieldValuePairVector &fields,
-                           const std::unordered_map<uint32_t, uint32_t>
-                               &path_index_to_spec_index_map,
-                           SkelRoot *skelRoot);
-
-  bool ReconstructSkeleton(const Node &node, const FieldValuePairVector &fields,
-                           const std::unordered_map<uint32_t, uint32_t>
-                               &path_index_to_spec_index_map,
-                           Skeleton *skeleton);
-
-  bool ReconstructSceneRecursively(int parent_id, int level,
-                                   const std::unordered_map<uint32_t, uint32_t>
-                                       &path_index_to_spec_index_map,
-                                   Scene *scene);
-#endif
+  if (primvar.get_type_id() !=
+      value::TypeTraits<std::vector<value::texcoord2f>>::type_id()) {
+    return nonstd::make_unexpected(
+        "Texture coordinate primvar must be texCoord2f[] type, but got " +
+        primvar.get_type_name() + "\n");
+  }
 
-  bool ReconstructStage(Stage *stage);
+  if (primvar.get_interpolation() == Interpolation::Varying) {
+    vattr.variability = VertexVariability::Varying;
+  } else if (primvar.get_interpolation() == Interpolation::Constant) {
+    vattr.variability = VertexVariability::Constant;
+  } else if (primvar.get_interpolation() == Interpolation::Uniform) {
+    vattr.variability = VertexVariability::Uniform;
+  } else if (primvar.get_interpolation() == Interpolation::Vertex) {
+    vattr.variability = VertexVariability::Vertex;
+  } else if (primvar.get_interpolation() == Interpolation::FaceVarying) {
+    vattr.variability = VertexVariability::FaceVarying;
+  }
 
-  ///
-  /// --------------------------------------------------
-  ///
+  std::vector<value::texcoord2f> uvs;
+  if (!primvar.flatten_with_indices(&uvs)) {
+    return nonstd::make_unexpected(
+        "Failed to retrieve texture coordinate primvar with concrete type.\n");
+  }
 
-  std::string GetError() { return _err; }
+  vattr.format = VertexAttributeFormat::Vec2;
+  vattr.data.resize(uvs.size() * sizeof(value::texcoord2f));
+  memcpy(vattr.data.data(), uvs.data(), vattr.data.size());
+  vattr.indices.clear();  // just in case.
 
-  std::string GetWarning() { return _warn; }
+  return std::move(vattr);
+}
 
-  // Approximated memory usage in [mb]
-  size_t GetMemoryUsage() const { return memory_used / (1024 * 1024); }
+///
+/// For GeomSubset. Build offset table to corresponding array index in
+/// mesh.faceVertexIndices. No need to use this function for triangulated mesh,
+/// since the index can be easily computed as `3 * subset.indices[i]`
+///
+bool BuildFaceVertexIndexOffsets(const std::vector<uint32_t> &faceVertexCounts,
+                                 std::vector<size_t> &faceVertexIndexOffsets) {
+  size_t offset = 0;
+  for (size_t i = 0; i < faceVertexCounts.size(); i++) {
+    uint32_t npolys = faceVertexCounts[i];
 
-  //
-  // APIs valid after successfull Parse()
-  //
+    faceVertexIndexOffsets.push_back(offset);
+    offset += npolys;
+  }
 
-  //size_t NumPaths() const { return _paths.size(); }
+  return true;
+}
 
- private:
-  //bool ReadCompressedPaths(const uint64_t ref_num_paths);
+///
+/// Input: points, faceVertexCounts, faceVertexIndices
+/// Output: triangulated faceVertexCounts(all filled with 3), triangulated
+/// faceVertexIndices, indexMap (length = triangulated faceVertexIndices.
+/// indexMap[i] stores array index in original faceVertexIndices. For remapping
+/// primvar attributes.)
+///
+/// Return false when a polygon is degenerated.
+/// No overlap check at the moment
+///
+/// T = value::float3 or value::double3
+/// BaseTy = float or double
+template <typename T, typename BaseTy>
+bool TriangulatePolygon(const std::vector<T> &points,
+                        const std::vector<uint32_t> &faceVertexCounts,
+                        const std::vector<uint32_t> &faceVertexIndices,
+                        std::vector<uint32_t> &triangulatedFaceVertexCounts,
+                        std::vector<uint32_t> &triangulatedFaceVertexIndices,
+                        std::vector<size_t> &faceVertexIndexMap,
+                        std::string &err) {
+  triangulatedFaceVertexCounts.clear();
+  triangulatedFaceVertexIndices.clear();
+
+  faceVertexIndexMap.clear();
+
+  size_t faceIndexOffset = 0;
+
+  // For each polygon(face)
+  for (size_t i = 0; i < faceVertexCounts.size(); i++) {
+    uint32_t npolys = faceVertexCounts[i];
+
+    if (npolys < 3) {
+      err = fmt::format(
+          "faceVertex count must be 3(triangle) or "
+          "more(polygon), but got faceVertexCounts[{}] = {}\n",
+          i, npolys);
+      return false;
+    }
+
+    if (faceIndexOffset + npolys > faceVertexIndices.size()) {
+      err = fmt::format(
+          "Invalid faceVertexIndices or faceVertexCounts. faceVertex index "
+          "exceeds faceVertexIndices.size() at [{}]\n",
+          i);
+      return false;
+    }
+
+    if (npolys == 3) {
+      // No need for triangulation.
+      triangulatedFaceVertexCounts.push_back(3);
+      triangulatedFaceVertexIndices.push_back(
+          faceVertexIndices[faceIndexOffset + 0]);
+      triangulatedFaceVertexIndices.push_back(
+          faceVertexIndices[faceIndexOffset + 1]);
+      triangulatedFaceVertexIndices.push_back(
+          faceVertexIndices[faceIndexOffset + 2]);
+      faceVertexIndexMap.push_back(i);
+#if 1
+    } else if (npolys == 4) {
+      // Use simple split
+      // TODO: Split at shortest edge?
+      triangulatedFaceVertexCounts.push_back(3);
+      triangulatedFaceVertexCounts.push_back(3);
+
+      triangulatedFaceVertexIndices.push_back(
+          faceVertexIndices[faceIndexOffset + 0]);
+      triangulatedFaceVertexIndices.push_back(
+          faceVertexIndices[faceIndexOffset + 1]);
+      triangulatedFaceVertexIndices.push_back(
+          faceVertexIndices[faceIndexOffset + 2]);
+
+      triangulatedFaceVertexIndices.push_back(
+          faceVertexIndices[faceIndexOffset + 0]);
+      triangulatedFaceVertexIndices.push_back(
+          faceVertexIndices[faceIndexOffset + 2]);
+      triangulatedFaceVertexIndices.push_back(
+          faceVertexIndices[faceIndexOffset + 3]);
 
-  crate::CrateReader *crate_reader{nullptr};
+      faceVertexIndexMap.push_back(i);
+      faceVertexIndexMap.push_back(i);
+#endif
+    } else {
+      // Find the normal axis of the polygon using Newell's method
+      T n = {BaseTy(0), BaseTy(0), BaseTy(0)};
 
-  StreamReader *_sr = nullptr;
-  std::string _err;
-  std::string _warn;
+      size_t vi0;
+      size_t vi0_2;
 
-  int _num_threads{1};
+      for (size_t k = 0; k < npolys; ++k) {
+        vi0 = faceVertexIndices[faceIndexOffset + k];
 
-  // Tracks the memory used(In advisorily manner since counting memory usage is
-  // done by manually, so not all memory consumption could be tracked)
-  size_t memory_used{0};  // in bytes.
+        size_t j = (k + 1) % npolys;
+        vi0_2 = faceVertexIndices[faceIndexOffset + j];
 
-};
+        if (vi0 >= points.size()) {
+          err = fmt::format("Invalid vertex index.\n");
+          return false;
+        }
 
-//
-// -- Impl
-//
+        if (vi0_2 >= points.size()) {
+          err = fmt::format("Invalid vertex index.\n");
+          return false;
+        }
 
-#if 0
+        T v0 = points[vi0];
+        T v1 = points[vi0_2];
 
-#define FIELDVALUE_DATATYPE_CHECK(__fv, __name, __req_type) { \
-  if (__fv.first == __name) { \
-    if (__fv.second.GetTypeName() != __req_type) { \
-      PUSH_ERROR("`" << __name << "` attribute must be " << __req_type << " type, but got " << __fv.second.GetTypeName()); \
-      return false; \
-    } \
-  } \
-}
-
-bool USDCReader::Impl::ReconstructXform(
-    uint64_t node_idx,
-    const Node &node, const FieldValuePairVector &fields,
-    const std::unordered_map<uint32_t, uint32_t> &path_index_to_spec_index_map,
-    Xform *xform) {
-  // TODO:
-  //  * [ ] !invert! suffix
-  //  * [ ] !resetXformStack! suffix
-  //  * [ ] maya:pivot support?
+        const T point1 = {v0[0], v0[1], v0[2]};
+        const T point2 = {v1[0], v1[1], v1[2]};
 
-  (void)xform;
+        T a = {point1[0] - point2[0], point1[1] - point2[1],
+               point1[2] - point2[2]};
+        T b = {point1[0] + point2[0], point1[1] + point2[1],
+               point1[2] + point2[2]};
+
+        n[0] += (a[1] * b[2]);
+        n[1] += (a[2] * b[0]);
+        n[2] += (a[0] * b[1]);
+      }
+      BaseTy length_n = vlength(n);
+      // Check if zero length normal
+      if (std::fabs(length_n) < std::numeric_limits<BaseTy>::epsilon()) {
+        err = "Degenerated polygon found.\n";
+        return false;
+      }
 
-  DCOUT("Reconstruct Xform");
+      // Negative is to flip the normal to the correct direction
+      n = vnormalize(n);
 
-  for (const auto &fv : fields) {
-    DCOUT("field = " << fv.first << ", type = " << fv.second.GetTypeName());
+      T axis_w, axis_v, axis_u;
+      axis_w = n;
+      T a;
+      if (std::fabs(axis_w[0]) > BaseTy(0.9999999)) {  // TODO: use 1.0 - eps?
+        a = {BaseTy(0), BaseTy(1), BaseTy(0)};
+      } else {
+        a = {BaseTy(1), BaseTy(0), BaseTy(0)};
+      }
+      axis_v = vnormalize(vcross(axis_w, a));
+      axis_u = vcross(axis_w, axis_v);
 
-    FIELDVALUE_DATATYPE_CHECK(fv, "properties", crate::kTokenVector)
+      using Point3D = std::array<BaseTy, 3>;
+      using Point2D = std::array<BaseTy, 2>;
+      std::vector<Point2D> polyline;
 
-  }
+      // TMW change: Find best normal and project v0x and v0y to those
+      // coordinates, instead of picking a plane aligned with an axis (which
+      // can flip polygons).
 
-  //
-  // NOTE: Currently we assume one deeper node has Xform's attribute
-  //
-  for (size_t i = 0; i < node.GetChildren().size(); i++) {
-    int child_index = int(node.GetChildren()[i]);
-    if ((child_index < 0) || (child_index >= int(_nodes.size()))) {
-      PUSH_ERROR("Invalid child node id: " + std::to_string(child_index) +
-              ". Must be in range [0, " + std::to_string(_nodes.size()) + ")");
-      return false;
-    }
+      // Fill polygon data.
+      for (size_t k = 0; k < npolys; k++) {
+        size_t vidx = faceVertexIndices[faceIndexOffset + k];
 
-    if (!path_index_to_spec_index_map.count(uint32_t(child_index))) {
-      // No specifier assigned to this child node.
-      // Should we report an error?
-      continue;
-    }
+        value::float3 v = points[vidx];
+        // Point3 polypoint = {v0[0],v0[1],v0[2]};
 
-    uint32_t spec_index =
-        path_index_to_spec_index_map.at(uint32_t(child_index));
-    if (spec_index >= _specs.size()) {
-      PUSH_ERROR("Invalid specifier id: " + std::to_string(spec_index) +
-              ". Must be in range [0, " + std::to_string(_specs.size()) + ")");
-      return false;
-    }
+        // world to local
+        Point3D loc = {vdot(v, axis_u), vdot(v, axis_v), vdot(v, axis_w)};
 
-    const crate::Spec &spec = _specs[spec_index];
+        polyline.push_back({loc[0], loc[1]});
+      }
 
-    Path path = GetPath(spec.path_index);
+      std::vector<std::vector<Point2D>> polygon_2d;
+      // Single polygon only(no holes)
 
-    DCOUT("Path prim part: " << path.GetPrimPart()
-                             << ", prop part: " << path.GetPropPart()
-                             << ", spec_index = " << spec_index);
+      std::vector<uint32_t> indices = mapbox::earcut<uint32_t>(polygon_2d);
+      //  => result = 3 * faces, clockwise
 
-    if (!_live_fieldsets.count(spec.fieldset_index)) {
-      PUSH_ERROR("FieldSet id: " + std::to_string(spec.fieldset_index.value) +
-              " must exist in live fieldsets.");
-      return false;
-    }
+      if ((indices.size() % 3) != 0) {
+        // This should not be happen, though.
+        err = "Failed to triangulate.\n";
+        return false;
+      }
 
-    const FieldValuePairVector &child_fields =
-        _live_fieldsets.at(spec.fieldset_index);
+      size_t ntris = indices.size() / 3;
 
-    {
-      std::string prop_name = path.GetPropPart();
+      for (size_t k = 0; k < ntris; k++) {
+        triangulatedFaceVertexCounts.push_back(3);
+        triangulatedFaceVertexIndices.push_back(
+            faceVertexIndices[faceIndexOffset + indices[3 * k + 0]]);
+        triangulatedFaceVertexIndices.push_back(
+            faceVertexIndices[faceIndexOffset + indices[3 * k + 1]]);
+        triangulatedFaceVertexIndices.push_back(
+            faceVertexIndices[faceIndexOffset + indices[3 * k + 2]]);
 
-      PrimAttrib attr;
-      bool ret = ParseAttribute(child_fields, &attr, prop_name);
-      DCOUT("Xform: prop: " << prop_name << ", ret = " << ret);
-      if (ret) {
-        // TODO(syoyo): Implement
-        PUSH_ERROR("TODO: Implemen Xform prop: " + prop_name);
+        faceVertexIndexMap.push_back(i);
       }
     }
+
+    faceIndexOffset += npolys;
   }
 
   return true;
 }
 
-bool USDCReader::Impl::ReconstructGeomBasisCurves(
-    const Node &node, const FieldValuePairVector &fields,
-    const std::unordered_map<uint32_t, uint32_t> &path_index_to_spec_index_map,
-    GeomBasisCurves *curves) {
-  bool has_position{false};
-
-  DCOUT("Reconstruct Xform");
-
-  for (const auto &fv : fields) {
-    if (fv.first == "properties") {
-
-      FIELDVALUE_DATATYPE_CHECK(fv, "properties", crate::kTokenVector)
-
-      auto ret = fv.second.get_value<std::vector<value::token>>();
-      if (!ret) {
-        PUSH_ERROR("Invalid `properties` data");
-        return false;
-      }
+#if 0
+//
+// `Shader` may be nested, so first list up all Shader nodes under Material.
+//
+struct ShaderNode
+{
+  std::name
+};
 
-      for (size_t i = 0; i < ret.value().size(); i++) {
-        if (ret.value()[i].str() == "points") {
-          has_position = true;
-        }
-      }
+nonstd::optional<UsdPrimvarReader_float2> FindPrimvarReader_float2Rec(
+  const Prim &root,
+  RenderMesh &mesh)
+{
+  if (auto sv = root.data.as<Shader>()) {
+    const Shader &shader = (*sv);
+
+    if (auto pv = shader.value.as<UsdUVTexture>()) {
+      const UsdUVTexture &tex = (*pv);
+      (void)tex;
     }
   }
 
-  (void)has_position;
-
-  //
-  // NOTE: Currently we assume one deeper node has GeomMesh's attribute
-  //
-  for (size_t i = 0; i < node.GetChildren().size(); i++) {
-    int child_index = int(node.GetChildren()[i]);
-    if ((child_index < 0) || (child_index >= int(_nodes.size()))) {
-      _err += "Invalid child node id: " + std::to_string(child_index) +
-              ". Must be in range [0, " + std::to_string(_nodes.size()) + ")\n";
-      return false;
+  for (const auto &child : root.children) {
+    auto ret = ListUpShaderGraphRec(child, mesh);
+    if (!ret) {
+      return nonstd::make_unexpected(ret.error());
     }
+  }
 
-    // const Node &child_node = _nodes[size_t(child_index)];
+  return true;
+}
+#endif
+
+}  // namespace
 
-    if (!path_index_to_spec_index_map.count(uint32_t(child_index))) {
-      // No specifier assigned to this child node.
-      // Should we report an error?
 #if 0
-      _err += "GeomBasisCurves: No specifier found for node id: " + std::to_string(child_index) +
-              "\n";
-      return false;
-#else
-      continue;
-#endif
-    }
+// Currently float2 only
+std::vector<UsdPrimvarReader_float2> ExtractPrimvarReadersFromMaterialNode(
+    const Prim &node) {
+  std::vector<UsdPrimvarReader_float2> dst;
 
-    uint32_t spec_index =
-        path_index_to_spec_index_map.at(uint32_t(child_index));
-    if (spec_index >= _specs.size()) {
-      _err += "Invalid specifier id: " + std::to_string(spec_index) +
-              ". Must be in range [0, " + std::to_string(_specs.size()) + ")\n";
-      return false;
-    }
+  if (!node.is<Material>()) {
+    return dst;
+  }
 
-    const crate::Spec &spec = _specs[spec_index];
+  for (const auto &child : node.children()) {
+    (void)child;
+  }
 
-    Path path = GetPath(spec.path_index);
-#ifdef TINYUSDZ_LOCAL_DEBUG_PRINT
-    std::cout << "Path prim part: " << path.GetPrimPart()
-              << ", prop part: " << path.GetPropPart()
-              << ", spec_index = " << spec_index << "\n";
-#endif
+  // Traverse and find PrimvarReader_float2 shader.
+  return dst;
+}
 
-    if (!_live_fieldsets.count(spec.fieldset_index)) {
-      _err += "FieldSet id: " + std::to_string(spec.fieldset_index.value) +
-              " must exist in live fieldsets.\n";
-      return false;
-    }
+nonstd::expected<Node, std::string> Convert(const Stage &stage,
+                                            const Xform &xform) {
+  (void)stage;
 
-    const FieldValuePairVector &child_fields =
-        _live_fieldsets.at(spec.fieldset_index);
+  // TODO: timeSamples
 
-    {
-      std::string prop_name = path.GetPropPart();
+  Node node;
+  if (auto m = xform.GetLocalMatrix()) {
+    node.local_matrix = m.value();
+  }
 
-      PrimAttrib attr;
-      bool ret = ParseAttribute(child_fields, &attr, prop_name);
-#ifdef TINYUSDZ_LOCAL_DEBUG_PRINT
-      std::cout << "prop: " << prop_name << ", ret = " << ret << "\n";
-#endif
-      if (ret) {
-        // TODO(syoyo): Support more prop names
-        if (prop_name == "points") {
-#ifdef TINYUSDZ_LOCAL_DEBUG_PRINT
-          std::cout << "got point\n";
-#endif
-          // if (auto p = primvar::as_vector<value::float3>(&attr.var)) {
-          //   curves->points = *p;
-          // }
-        } else if (prop_name == "extent") {
-          // vec3f[2]
-          // if (auto p = primvar::as_vector<value::float3>(&attr.var)) {
-          //  if (p->size() == 2) {
-          //    curves->extent.value.lower = (*p)[0];
-          //    curves->extent.value.upper = (*p)[1];
-          //  }
-          //}
-        } else if (prop_name == "normals") {
-          // if (auto p = primvar::as_vector<value::float3>(&attr.var)) {
-          //   curves->normals = (*p);
-          // }
-        } else if (prop_name == "widths") {
-          // if (auto p = primvar::as_vector<float>(&attr.var)) {
-          //   curves->widths = (*p);
-          // }
-        } else if (prop_name == "curveVertexCounts") {
-          // if (auto p = primvar::as_vector<int>(&attr.var)) {
-          //   curves->curveVertexCounts = (*p);
-          // }
-        } else if (prop_name == "type") {
-#ifdef TINYUSDZ_LOCAL_DEBUG_PRINT
-          // std::cout << "type:" << attr.stringVal << "\n";
-#endif
-          // if (auto p = primvar::as_basic<std::string>(&attr.var)) {
-          //   if (p->compare("cubic") == 0) {
-          //     curves->type = "cubic";
-          //   } else if (p->compare("linear") == 0) {
-          //     curves->type = "linear";
-          //   } else {
-          //     _err += "Unknown type: " + (*p) + "\n";
-          //     return false;
-          //   }
-          // }
-        } else if (prop_name == "basis") {
-#ifdef TINYUSDZ_LOCAL_DEBUG_PRINT
-          // std::cout << "basis:" << attr.stringVal << "\n";
-#endif
-#if 0
-          if (auto p = nonstd::get_if<std::string>(&attr.var)) {
-            if (p->compare("bezier") == 0) {
-              curves->type = "bezier";
-            } else if (p->compare("catmullRom") == 0) {
-              curves->type = "catmullRom";
-            } else if (p->compare("bspline") == 0) {
-              curves->type = "bspline";
-            } else if (p->compare("hermite") == 0) {
-              _err += "`hermite` basis for BasisCurves is not supported in TinyUSDZ\n";
-              return false;
-            } else if (p->compare("power") == 0) {
-              _err += "`power` basis for BasisCurves is not supported in TinyUSDZ\n";
-              return false;
-            } else {
-              _err += "Unknown basis: " + (*p) + "\n";
-              return false;
-            }
-          }
-#endif
-        } else if (prop_name == "wrap") {
-#if 0
-          if (auto p = nonstd::get_if<std::string>(&attr.var)) {
-            if (p->compare("nonperiodic") == 0) {
-              curves->type = "nonperiodic";
-            } else if (p->compare("periodic") == 0) {
-              curves->type = "periodic";
-            } else if (p->compare("pinned") == 0) {
-              curves->type = "pinned";
-            } else {
-              _err += "Unknown wrap: " + (*p) + "\n";
-              return false;
-            }
-          }
+  return std::move(node);
+}
 #endif
-        } else {
-          // Assume Primvar.
-          if (curves->attribs.count(prop_name)) {
-            _err += "Duplicated property name found: " + prop_name + "\n";
-            return false;
-          }
 
-#ifdef TINYUSDZ_LOCAL_DEBUG_PRINT
-          std::cout << "add [" << prop_name << "] to generic attrs\n";
-#endif
+namespace {
 
-          curves->attribs[prop_name] = std::move(attr);
+bool ListUVNames(const RenderMaterial &material,
+                 const std::vector<UVTexture> &textures,
+                 StringAndIdMap &si_map) {
+  // TODO: Use auto
+  auto fun_vec3 = [&](const ShaderParam<vec3> &param) {
+    int32_t texId = param.textureId;
+    if ((texId >= 0) && (size_t(texId) < textures.size())) {
+      const UVTexture &tex = textures[size_t(texId)];
+      if (tex.varname_uv.size()) {
+        if (!si_map.count(tex.varname_uv)) {
+          uint64_t slotId = si_map.size();
+          DCOUT("Add textureSlot: " << tex.varname_uv << ", " << slotId);
+          si_map.add(tex.varname_uv, slotId);
         }
       }
     }
-  }
+  };
+
+  auto fun_float = [&](const ShaderParam<float> &param) {
+    int32_t texId = param.textureId;
+    if ((texId >= 0) && (size_t(texId) < textures.size())) {
+      const UVTexture &tex = textures[size_t(texId)];
+      if (tex.varname_uv.size()) {
+        if (!si_map.count(tex.varname_uv)) {
+          uint64_t slotId = si_map.size();
+          DCOUT("Add textureSlot: " << tex.varname_uv << ", " << slotId);
+          si_map.add(tex.varname_uv, slotId);
+        }
+      }
+    }
+  };
+
+  fun_vec3(material.surfaceShader.diffuseColor);
+  fun_vec3(material.surfaceShader.normal);
+  fun_float(material.surfaceShader.metallic);
+  fun_float(material.surfaceShader.roughness);
+  fun_float(material.surfaceShader.clearcoat);
+  fun_float(material.surfaceShader.clearcoatRoughness);
+  fun_float(material.surfaceShader.opacity);
+  fun_float(material.surfaceShader.opacityThreshold);
+  fun_float(material.surfaceShader.ior);
+  fun_float(material.surfaceShader.displacement);
+  fun_float(material.surfaceShader.occlusion);
 
   return true;
 }
 
-bool USDCReader::Impl::ReconstructGeomSubset(
-    const Node &node, const FieldValuePairVector &fields,
-    const std::unordered_map<uint32_t, uint32_t> &path_index_to_spec_index_map,
-    GeomSubset *geom_subset) {
-
-  DCOUT("Reconstruct Xform");
-
-  for (const auto &fv : fields) {
-    if (fv.first == "properties") {
-      FIELDVALUE_DATATYPE_CHECK(fv, "properties", crate::kTokenVector)
-
-      // for (size_t i = 0; i < fv.second.GetStringArray().size(); i++) {
-      //   // if (fv.second.GetStringArray()[i] == "points") {
-      //   // }
-      // }
-    }
+}  // namespace
+
+bool RenderSceneConverter::ConvertMesh(const int64_t rmaterial_id,
+                                       const GeomMesh &mesh,
+                                       RenderMesh *dstMesh) {
+  if (!dstMesh) {
+    PUSH_ERROR_AND_RETURN("`dst` mesh pointer is nullptr");
   }
 
-  for (size_t i = 0; i < node.GetChildren().size(); i++) {
-    int child_index = int(node.GetChildren()[i]);
-    if ((child_index < 0) || (child_index >= int(_nodes.size()))) {
-      PUSH_ERROR("Invalid child node id: " + std::to_string(child_index) +
-                 ". Must be in range [0, " + std::to_string(_nodes.size()) +
-                 ")");
-      return false;
-    }
+  RenderMesh dst;
 
-    // const Node &child_node = _nodes[size_t(child_index)];
+  bool triangulate = _mesh_config.triangulate;
 
-    if (!path_index_to_spec_index_map.count(uint32_t(child_index))) {
-      // No specifier assigned to this child node.
-      // TODO: Should we report an error?
-      continue;
+  // indices
+  // TODO: timeSamples, connections
+  if (const auto pv = mesh.faceVertexIndices.get_value()) {
+    std::vector<int32_t> indices;
+    if (pv.value().get_scalar(&indices)) {
+      // to uint32
+      std::transform(indices.cbegin(), indices.cend(),
+                     std::back_inserter(dst.faceVertexIndices),
+                     [](int32_t v) { return uint32_t(v); });
     }
+  }
 
-    uint32_t spec_index =
-        path_index_to_spec_index_map.at(uint32_t(child_index));
-    if (spec_index >= _specs.size()) {
-      PUSH_ERROR("Invalid specifier id: " + std::to_string(spec_index) +
-                 ". Must be in range [0, " + std::to_string(_specs.size()) +
-                 ")");
-      return false;
+  if (const auto pv = mesh.faceVertexCounts.get_value()) {
+    std::vector<int32_t> counts;
+    if (pv.value().get_scalar(&counts)) {
+      // to uint32
+      std::transform(counts.cbegin(), counts.cend(),
+                     std::back_inserter(dst.faceVertexCounts),
+                     [](int32_t v) { return uint32_t(v); });
     }
+  }
 
-    const crate::Spec &spec = _specs[spec_index];
+  if (mesh.get_points().size()) {
+    dst.points.resize(mesh.get_points().size());
+    memcpy(dst.points.data(), mesh.get_points().data(),
+           sizeof(value::float3) * mesh.get_points().size());
+  }
 
-    Path path = GetPath(spec.path_index);
-    DCOUT("Path prim part: " << path.GetPrimPart()
-                             << ", prop part: " << path.GetPropPart()
-                             << ", spec_index = " << spec_index);
-
-    if (!_live_fieldsets.count(spec.fieldset_index)) {
-      _err += "FieldSet id: " + std::to_string(spec.fieldset_index.value) +
-              " must exist in live fieldsets.\n";
-      return false;
+  // normals
+  {
+    std::vector<value::normal3f> normals = mesh.get_normals();
+    Interpolation interp = mesh.get_normalsInterpolation();
+
+    if (normals.size()) {
+      if (interp == Interpolation::Uniform) {
+        auto result = UniformToFaceVarying(normals, dst.faceVertexCounts, dst.faceVertexIndices);
+        if (!result) {
+          PUSH_ERROR_AND_RETURN(
+              fmt::format("Convert uniform `normals` attribute to failed: {}", result.error()));
+        }
+
+        dst.facevaryingNormals.resize(result.value().size());
+        memcpy(dst.facevaryingNormals.data(), result.value().data(),
+               sizeof(value::normal3f) * result.value().size());
+
+      } else if ((interp == Interpolation::Vertex) || (interp == Interpolation::Varying)) {
+        auto result = VertexToFaceVarying(normals, dst.faceVertexCounts, dst.faceVertexIndices);
+        if (!result) {
+          PUSH_ERROR_AND_RETURN(
+              fmt::format("Convert vertex/varying `normals` attribute to failed: {}", result.error()));
+        }
+
+        dst.facevaryingNormals.resize(result.value().size());
+        memcpy(dst.facevaryingNormals.data(), result.value().data(),
+               sizeof(value::normal3f) * result.value().size());
+
+      } else if (interp == Interpolation::FaceVarying) {
+        dst.facevaryingNormals.resize(normals.size());
+        memcpy(dst.facevaryingNormals.data(), normals.data(),
+               sizeof(value::normal3f) * normals.size());
+      } else {
+        PUSH_ERROR_AND_RETURN(
+            "Unsupported/unimplemented interpolation for `normals` attribute: " +
+            to_string(interp) + ".\n");
+      }
+    } else {
+      dst.facevaryingNormals.clear();
+      dst.normalsInterpolation = interp;
     }
+  }
 
-    const FieldValuePairVector &child_fields =
-        _live_fieldsets.at(spec.fieldset_index);
+  // Compute total faceVarying elements;
+  size_t num_fvs = 0;
+  for (size_t i = 0; i < dst.faceVertexCounts.size(); i++) {
+    num_fvs += dst.faceVertexCounts[i];
+  }
 
-    {
-      std::string prop_name = path.GetPropPart();
+  DCOUT("num_fvs = " << num_fvs);
 
-      PrimAttrib attr;
-      bool ret = ParseAttribute(child_fields, &attr, prop_name);
-      DCOUT("prop: " << prop_name << ", ret = " << ret);
+  // uvs from primvars.
+  // uvname(varname) is grabbed from RenderMaterial.
+  //
+  // TODO: list-up varname from PreviewSurfaceShader members.
+  //
+  // Procedure:
+  // - Find Shader
+  // - Lookup PrimvarReader
+  //
 
-      if (ret) {
-        // TODO(syoyo): Support more prop names
-        if (prop_name == "elementType") {
-          auto p = attr.var.get_value<tinyusdz::value::token>();
-          if (p) {
-            std::string str = p->str();
-            if (str == "face") {
-              geom_subset->elementType = GeomSubset::ElementType::Face;
-            } else {
-              PUSH_ERROR("`elementType` must be `face`, but got `" + str + "`");
-              return false;
-            }
-          } else {
-            PUSH_ERROR("`elementType` must be token type, but got " +
-                       value::GetTypeName(attr.var.type_id()));
-            return false;
-          }
-        } else if (prop_name == "faces") {
-          auto p = attr.var.get_value<std::vector<int>>();
-          if (p) {
-            geom_subset->faces = (*p);
-          }
+  if ((rmaterial_id > -1) && (size_t(rmaterial_id) < materials.size())) {
+    const RenderMaterial &material = materials[size_t(rmaterial_id)];
 
-          DCOUT("faces.num = " << geom_subset->faces.size());
+    StringAndIdMap uvname_map;
+    if (!ListUVNames(material, textures, uvname_map)) {
+      return false;
+    }
 
-        } else {
-          // Assume Primvar.
-          if (geom_subset->attribs.count(prop_name)) {
-            _err += "Duplicated property name found: " + prop_name + "\n";
-            return false;
-          }
+    for (auto it = uvname_map.i_begin(); it != uvname_map.i_end(); it++) {
+      uint64_t slotId = it->first;
+      std::string uvname = it->second;
 
-#ifdef TINYUSDZ_LOCAL_DEBUG_PRINT
-          std::cout << "add [" << prop_name << "] to generic attrs\n";
-#endif
+      auto ret = GetTextureCoordinate(*_stage, mesh, uvname);
+      if (ret) {
+        const VertexAttribute vattr = ret.value();
 
-          geom_subset->attribs[prop_name] = std::move(attr);
+        if (vattr.format != VertexAttributeFormat::Vec2) {
+          PUSH_ERROR_AND_RETURN(
+              fmt::format("Texcoord VertexAttribute must be Vec2 type.\n"));
         }
-      }
-    }
-  }
-
-  return true;
-}
 
-bool USDCReader::Impl::ReconstructGeomMesh(
-    const Node &node, const FieldValuePairVector &fields,
-    const std::unordered_map<uint32_t, uint32_t> &path_index_to_spec_index_map,
-    GeomMesh *mesh) {
-  bool has_position{false};
-
-  DCOUT("Reconstruct Xform");
-
-  for (const auto &fv : fields) {
-    if (fv.first == "properties") {
-      FIELDVALUE_DATATYPE_CHECK(fv, "properties", crate::kTokenVector)
+        if (vattr.variability != VertexVariability::FaceVarying) {
+          PUSH_ERROR_AND_RETURN(
+              fmt::format("TODO: non-facevarying UV texcoord attribute is not "
+                          "support yet: {}.\n",
+                          uvname));
+        }
 
-      const auto arr = fv.second.get_value<std::vector<value::token>>();
-      if (!arr) {
-        return false;
-      }
-      for (size_t i = 0; i < arr.value().size(); i++) {
-        if (arr.value()[i] == "points") {
-          has_position = true;
+        if (vattr.counts() != num_fvs) {
+          PUSH_ERROR_AND_RETURN(
+              fmt::format("The number of UV texcoord attributes {} does not "
+                          "match to the number of facevarying elements {}\n",
+                          vattr.counts(), num_fvs));
         }
+
+        DCOUT("Add texcoord attr `" << uvname << "` to slot Id " << slotId);
+        std::vector<vec2> uvs(vattr.counts());
+        memcpy(uvs.data(), vattr.data.data(), vattr.data.size());
+
+        dst.facevaryingTexcoords.emplace(slotId, uvs);
+
+      } else {
+        PUSH_ERROR_AND_RETURN(ret.error());
       }
     }
   }
 
-  (void)has_position;
+  if (triangulate) {
+    std::string err;
 
-  // Disable has_position check for a while, since Mesh may not have "points",
-  // but "position"
+    std::vector<uint32_t> triangulatedFaceVertexCounts;  // should be all 3's
+    std::vector<uint32_t> triangulatedFaceVertexIndices;
+    std::vector<size_t> faceVertexIndexMap;
+    if (!TriangulatePolygon<value::float3, float>(
+            dst.points, dst.faceVertexCounts, dst.faceVertexIndices,
+            triangulatedFaceVertexCounts, triangulatedFaceVertexIndices,
+            faceVertexIndexMap, err)) {
+      PUSH_ERROR_AND_RETURN("Triangulation failed: " + err);
+    }
 
-  // if (!has_position) {
-  //  _err += "No `position` field exist for Mesh node: " + node.GetLocalPath()
-  //  +
-  //          ".\n";
-  //  return false;
-  //}
+    // TODO: Triangulate primvars with faceVertexIndexMap
 
-  //
-  // NOTE: Currently we assume one deeper node has GeomMesh's attribute
-  //
-  for (size_t i = 0; i < node.GetChildren().size(); i++) {
-    int child_index = int(node.GetChildren()[i]);
-    if ((child_index < 0) || (child_index >= int(_nodes.size()))) {
-      _err += "Invalid child node id: " + std::to_string(child_index) +
-              ". Must be in range [0, " + std::to_string(_nodes.size()) + ")\n";
-      return false;
-    }
+    dst.faceVertexCounts = std::move(triangulatedFaceVertexCounts);
+    dst.faceVertexIndices = std::move(triangulatedFaceVertexIndices);
 
-    // const Node &child_node = _nodes[size_t(child_index)];
+  }  // triangulate
 
-    if (!path_index_to_spec_index_map.count(uint32_t(child_index))) {
-      // No specifier assigned to this child node.
-      // Should we report an error?
-      DCOUT("No speciefier assigned to this child node: " << child_index);
-      continue;
-    }
+  // for GeomSubsets
+  if (mesh.geom_subset_children.size()) {
+    std::vector<size_t> faceVertexIndexOffsets;
 
-    uint32_t spec_index =
-        path_index_to_spec_index_map.at(uint32_t(child_index));
-    if (spec_index >= _specs.size()) {
-      PUSH_ERROR("Invalid specifier id: " + std::to_string(spec_index) +
-                 ". Must be in range [0, " + std::to_string(_specs.size()) +
-                 ")");
-      return false;
+    if (!BuildFaceVertexIndexOffsets(dst.faceVertexCounts,
+                                     faceVertexIndexOffsets)) {
+      PUSH_ERROR_AND_RETURN("Build faceVertexIndexOffsets failed.");
     }
+  }
 
-    const crate::Spec &spec = _specs[spec_index];
+  (*dstMesh) = std::move(dst);
+  return true;
+}
 
-    Path path = GetPath(spec.path_index);
-    DCOUT("Path prim part: " << path.GetPrimPart()
-                             << ", prop part: " << path.GetPropPart()
-                             << ", spec_index = " << spec_index);
-
-    if (!_live_fieldsets.count(spec.fieldset_index)) {
-      PUSH_ERROR("FieldSet id: " + std::to_string(spec.fieldset_index.value) +
-                 " must exist in live fieldsets.");
-      return false;
-    }
+namespace {
 
-    const FieldValuePairVector &child_fields =
-        _live_fieldsets.at(spec.fieldset_index);
+#if 1
+// Convert UsdTranform2d -> PrimvarReader_float2 shader network.
+nonstd::expected<bool, std::string> ConvertTexTransform2d(
+    const Stage &stage, const Path &tx_abs_path, const UsdTransform2d &tx,
+    UVTexture *tex_out) {
+  float rotation;  // in angles
+  if (!tx.rotation.get_value().get_scalar(&rotation)) {
+    return nonstd::make_unexpected(
+        fmt::format("Failed to retrieve rotation attribute from {}\n",
+                    tx_abs_path.full_path_name()));
+  }
 
-    {
-      std::string prop_name = path.GetPropPart();
+  value::float2 scale;
+  if (!tx.scale.get_value().get_scalar(&scale)) {
+    return nonstd::make_unexpected(
+        fmt::format("Failed to retrieve scale attribute from {}\n",
+                    tx_abs_path.full_path_name()));
+  }
 
-      PrimAttrib attr;
-      bool ret = ParseAttribute(child_fields, &attr, prop_name);
-      DCOUT("prop: " << prop_name << ", ret = " << ret);
+  value::float2 translation;
+  if (!tx.translation.get_value().get_scalar(&translation)) {
+    return nonstd::make_unexpected(
+        fmt::format("Failed to retrieve translation attribute from {}\n",
+                    tx_abs_path.full_path_name()));
+  }
 
-      if (ret) {
-        // TODO(syoyo): Support more prop names
-        if (prop_name == "points") {
-          auto p = attr.var.get_value<std::vector<value::point3f>>();
-          if (p) {
-            mesh->points = (*p);
-          } else {
-            PUSH_ERROR("`points` must be point3[] type, but got " +
-                       value::GetTypeName(attr.var.type_id()));
-            return false;
-          }
-          // if (auto p = primvar::as_vector<value::float3>(&attr.var)) {
-          //   mesh->points = (*p);
-          // }
-        } else if (prop_name == "doubleSided") {
-          auto p = attr.var.get_value<bool>();
-          if (p) {
-            mesh->doubleSided = (*p);
-          }
-        } else if (prop_name == "extent") {
-          // vec3f[2]
-          auto p = attr.var.get_value<std::vector<value::float3>>();
-          if (p && p->size() == 2) {
-            mesh->extent.value.lower = (*p)[0];
-            mesh->extent.value.upper = (*p)[1];
-          }
-        } else if (prop_name == "normals") {
-          mesh->normals = attr;
-        } else if ((prop_name == "primvars:UVMap") &&
-                   (attr.type_name == "texCoord2f[]")) {
-          // Explicit UV coord attribute.
-          // TODO(syoyo): Write PrimVar parser
-
-          // Currently we only support vec2f for uv coords.
-          // if (auto p = primvar::as_vector<Vec2f>(&attr.var)) {
-          //  mesh->st.buffer = (*p);
-          //  mesh->st.variability = attr.variability;
-          //}
-        } else if (prop_name == "faceVertexCounts") {
-          auto p = attr.var.get_value<std::vector<int>>();
-          if (p) {
-            mesh->faceVertexCounts = (*p);
-          }
-          //}
-        } else if (prop_name == "faceVertexIndices") {
-          auto p = attr.var.get_value<std::vector<int>>();
-          if (p) {
-            mesh->faceVertexIndices = (*p);
-          }
+  // must be authored and connected to PrimvarReader.
+  if (!tx.in.authored()) {
+    return nonstd::make_unexpected("`inputs:in` must be authored.\n");
+  }
 
-        } else if (prop_name == "holeIndices") {
-          // if (auto p = primvar::as_vector<int>(&attr.var)) {
-          //     mesh->holeIndices = (*p);
-          // }
-        } else if (prop_name == "cornerIndices") {
-          // if (auto p = primvar::as_vector<int>(&attr.var)) {
-          //     mesh->cornerIndices = (*p);
-          // }
-        } else if (prop_name == "cornerSharpnesses") {
-          // if (auto p = primvar::as_vector<float>(&attr.var)) {
-          //     mesh->cornerSharpnesses = (*p);
-          // }
-        } else if (prop_name == "creaseIndices") {
-          // if (auto p = primvar::as_vector<int>(&attr.var)) {
-          //     mesh->creaseIndices = (*p);
-          // }
-        } else if (prop_name == "creaseLengths") {
-          // if (auto p = primvar::as_vector<int>(&attr.var)) {
-          //   mesh->creaseLengths = (*p);
-          // }
-        } else if (prop_name == "creaseSharpnesses") {
-          // if (auto p = primvar::as_vector<float>(&attr.var)) {
-          //     mesh->creaseSharpnesses = (*p);
-          // }
-        } else if (prop_name == "subdivisionScheme") {
-          auto p = attr.var.get_value<value::token>();
-          // if (auto p = primvar::as_basic<std::string>(&attr.var)) {
-          //   if (p->compare("none") == 0) {
-          //     mesh->subdivisionScheme = SubdivisionScheme::None;
-          //   } else if (p->compare("catmullClark") == 0) {
-          //     mesh->subdivisionScheme = SubdivisionScheme::CatmullClark;
-          //   } else if (p->compare("bilinear") == 0) {
-          //     mesh->subdivisionScheme = SubdivisionScheme::Bilinear;
-          //   } else if (p->compare("loop") == 0) {
-          //     mesh->subdivisionScheme = SubdivisionScheme::Loop;
-          //   } else {
-          //     _err += "Unknown subdivision scheme: " + (*p) + "\n";
-          //     return false;
-          //   }
-          // }
-        } else if (prop_name.compare("material:binding") == 0) {
-          // rel
-          auto p =
-              attr.var.get_value<std::string>();  // rel, but treat as sting
-          if (p) {
-            mesh->materialBinding.materialBinding = (*p);
-          }
-        } else {
-          // Assume Primvar.
-          if (mesh->props.count(prop_name)) {
-            PUSH_ERROR("Duplicated property name found: " + prop_name);
-            return false;
-          }
+  if (!tx.in.is_connection()) {
+    return nonstd::make_unexpected("`inputs:in` must be a connection.\n");
+  }
 
-          DCOUT("add [" << prop_name << "] to generic attrs.");
+  const auto &paths = tx.in.get_connections();
+  if (paths.size() != 1) {
+    return nonstd::make_unexpected(
+        "`inputs:in` must be a single connection Path.\n");
+  }
 
-          // FIXME: Look-up schema to detect if the property is `custom` or not.
-          bool is_custom{false};
+  std::string prim_part = paths[0].prim_part();
+  std::string prop_part = paths[0].prop_part();
 
-          mesh->props.emplace(prop_name, Property(attr, is_custom));
-        }
-      }
-    }
+  if (prop_part != "outputs:result") {
+    return nonstd::make_unexpected(
+        "`inputs:in` connection Path's property part must be "
+        "`outputs:result`\n");
   }
 
-  return true;
-}
+  std::string err;
 
-bool USDCReader::Impl::ReconstructMaterial(
-    const Node &node, const FieldValuePairVector &fields,
-    const std::unordered_map<uint32_t, uint32_t> &path_index_to_spec_index_map,
-    Material *material) {
-  (void)material;
-
-  DCOUT("Parse mateiral");
-
-  for (const auto &fv : fields) {
-    if (fv.first == "properties") {
-      FIELDVALUE_DATATYPE_CHECK(fv, "properties", crate::kTokenVector)
+  const Prim *pprim{nullptr};
+  if (!stage.find_prim_at_path(Path(prim_part, ""), pprim, &err)) {
+    return nonstd::make_unexpected(fmt::format(
+        "`inputs:in` connection Path not found in the Stage. {}\n", prim_part));
+  }
 
-      // for (size_t i = 0; i < fv.second.GetStringArray().size(); i++) {
-      // }
-    }
+  if (!pprim) {
+    return nonstd::make_unexpected(
+        fmt::format("[InternalError] Prim is nullptr: {}\n", prim_part));
   }
 
-  //
-  // NOTE: Currently we assume one deeper node has Material's attribute
-  //
-  for (size_t i = 0; i < node.GetChildren().size(); i++) {
-    int child_index = int(node.GetChildren()[i]);
-    if ((child_index < 0) || (child_index >= int(_nodes.size()))) {
-      PUSH_ERROR("Invalid child node id: " + std::to_string(child_index) +
-                 ". Must be in range [0, " + std::to_string(_nodes.size()) +
-                 ")");
-      return false;
-    }
+  const Shader *pshader = pprim->as<Shader>();
+  if (!pshader) {
+    return nonstd::make_unexpected(
+        fmt::format("{} must be Shader Prim, but got {}\n", prim_part,
+                    pprim->prim_type_name()));
+  }
 
-    // const Node &child_node = _nodes[size_t(child_index)];
+  const UsdPrimvarReader_float2 *preader =
+      pshader->value.as<UsdPrimvarReader_float2>();
+  if (preader) {
+    return nonstd::make_unexpected(fmt::format(
+        "Shader {} must be UsdPrimvarReader_float2 type, but got {}\n",
+        prim_part, pshader->info_id));
+  }
 
-    if (!path_index_to_spec_index_map.count(uint32_t(child_index))) {
-      // No specifier assigned to this child node.
+  // Get value producing attribute(i.e, follow .connection and return
+  // terminal Attribute value)
+  value::token varname;
 #if 0
-      _err += "Material: No specifier found for node id: " + std::to_string(child_index) +
-              "\n";
-      return false;
+  if (!tydra::EvaluateShaderAttribute(stage, *pshader, "inputs:varname",
+                                      &varname, &err)) {
+    return nonstd::make_unexpected(
+        fmt::format("Failed to evaluate UsdPrimvarReader_float2's "
+                    "inputs:varname: {}\n",
+                    err));
+  }
 #else
-      continue;
+  TerminalAttributeValue attr;
+  if (!tydra::EvaluateAttribute(stage, *pprim, "inputs:varname", &attr, &err)) {
+    return nonstd::make_unexpected(
+        "`inputs:varname` evaluation failed: " + err + "\n");
+  }
+  if (auto pv = attr.as<value::token>()) {
+    varname = *pv;
+  } else {
+    return nonstd::make_unexpected(
+        "`inputs:varname` must be `token` type, but got " + attr.type_name() +
+        "\n");
+  }
+  if (varname.str().empty()) {
+    return nonstd::make_unexpected("`inputs:varname` is empty token\n");
+  }
+  DCOUT("inputs:varname = " << varname);
 #endif
-    }
 
-    uint32_t spec_index =
-        path_index_to_spec_index_map.at(uint32_t(child_index));
-    if (spec_index >= _specs.size()) {
-      PUSH_ERROR("Invalid specifier id: " + std::to_string(spec_index) +
-                 ". Must be in range [0, " + std::to_string(_specs.size()) +
-                 ")");
-      return false;
-    }
-
-    const crate::Spec &spec = _specs[spec_index];
+  // Build transform matrix.
+  // https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform
+  // Since USD uses post-multiply,
+  //
+  // matrix = scale * rotate * translate
+  //
+  {
+    mat3 s;
+    s.set_scale(scale[0], scale[1], 1.0f);
 
-    Path path = GetPath(spec.path_index);
-    DCOUT("Path prim part: " << path.GetPrimPart()
-                             << ", prop part: " << path.GetPropPart()
-                             << ", spec_index = " << spec_index);
-
-    if (!_live_fieldsets.count(spec.fieldset_index)) {
-      PUSH_ERROR("FieldSet id: " + std::to_string(spec.fieldset_index.value) +
-                 " must exist in live fieldsets.");
-      return false;
-    }
+    mat3 r = mat3::identity();
 
-    const FieldValuePairVector &child_fields =
-        _live_fieldsets.at(spec.fieldset_index);
+    r.m[0][0] = std::cos(math::radian(rotation));
+    r.m[0][1] = std::sin(math::radian(rotation));
 
-    (void)child_fields;
-    {
-      std::string prop_name = path.GetPropPart();
+    r.m[1][0] = -std::sin(math::radian(rotation));
+    r.m[1][1] = std::cos(math::radian(rotation));
 
-      PrimAttrib attr;
+    mat3 t = mat3::identity();
+    t.set_translation(translation[0], translation[1], 1.0f);
 
-      bool ret = ParseAttribute(child_fields, &attr, prop_name);
-      if (ret) {
-        if (prop_name.compare("outputs:surface") == 0) {
-          auto p = attr.var.get_value<std::string>();
-          if (p) {
-            material->outputs_surface = (*p);
-          }
-        }
-#ifdef TINYUSDZ_LOCAL_DEBUG_PRINT
-        std::cout << "prop: " << prop_name << "\n";
-#endif
-      }
-    }
+    tex_out->transform = s * r * t;
   }
 
+  tex_out->tx_rotation = rotation;
+  tex_out->tx_translation = translation;
+  tex_out->tx_scale = scale;
+  tex_out->has_transform2d = true;
+
+  tex_out->varname_uv = varname.str();
+
   return true;
 }
+#endif
 
-bool USDCReader::Impl::ReconstructShader(
-    const Node &node, const FieldValuePairVector &fields,
-    const std::unordered_map<uint32_t, uint32_t> &path_index_to_spec_index_map,
-    Shader *shader) {
-  (void)shader;
-
-  for (const auto &fv : fields) {
-    if (fv.first == "properties") {
-      FIELDVALUE_DATATYPE_CHECK(fv, "properties", crate::kTokenVector)
+template <typename T>
+nonstd::expected<bool, std::string> GetConnectedUVTexture(
+    const Stage &stage, const TypedAnimatableAttributeWithFallback<T> &src,
+    Path *tex_abs_path, const UsdUVTexture **dst, const Shader **shader_out) {
+  if (!dst) {
+    return nonstd::make_unexpected("[InternalError] dst is nullptr.\n");
+  }
 
-      // for (size_t i = 0; i < fv.second.GetStringArray().size(); i++) {
-      // }
-    }
+  if (!src.is_connection()) {
+    return nonstd::make_unexpected("Attribute must be connection.\n");
   }
 
-  //
-  // Find shader type.
-  //
-  std::string shader_type;
+  if (src.get_connections().size() != 1) {
+    return nonstd::make_unexpected(
+        "Attribute connections must be single connection Path.\n");
+  }
 
-  for (size_t i = 0; i < node.GetChildren().size(); i++) {
-    int child_index = int(node.GetChildren()[i]);
-    if ((child_index < 0) || (child_index >= int(_nodes.size()))) {
-      PUSH_ERROR("Invalid child node id: " + std::to_string(child_index) +
-                 ". Must be in range [0, " + std::to_string(_nodes.size()) +
-                 ")");
-      return false;
-    }
+  const Path &path = src.get_connections()[0];
 
-    // const Node &child_node = _nodes[size_t(child_index)];
+  const std::string prim_part = path.prim_part();
+  const std::string prop_part = path.prop_part();
 
-    if (!path_index_to_spec_index_map.count(uint32_t(child_index))) {
-      // No specifier assigned to this child node.
-      PUSH_ERROR("No specifier found for node id: " +
-                 std::to_string(child_index));
-      return false;
-    }
+  if (prop_part != "outputs:rgb") {
+    return nonstd::make_unexpected(
+        "connection Path's property part must be `outputs:rgb` at the moment "
+        "for "
+        "UsdUVTexture, but got " +
+        prop_part + " \n");
+  }
 
-    uint32_t spec_index =
-        path_index_to_spec_index_map.at(uint32_t(child_index));
-    if (spec_index >= _specs.size()) {
-      PUSH_ERROR("Invalid specifier id: " + std::to_string(spec_index) +
-                 ". Must be in range [0, " + std::to_string(_specs.size()) +
-                 ")");
-      return false;
+  const Prim *prim{nullptr};
+  std::string err;
+  if (!stage.find_prim_at_path(Path(prim_part, ""), prim, &err)) {
+    return nonstd::make_unexpected(
+        fmt::format("Prim {} not found in the Stage: {}\n", prim_part, err));
+  }
+
+  if (!prim) {
+    return nonstd::make_unexpected("[InternalError] Prim ptr is null.\n");
+  }
+
+  if (tex_abs_path) {
+    (*tex_abs_path) = Path(prim_part, "");
+  }
+
+  if (const Shader *pshader = prim->as<Shader>()) {
+    if (const UsdUVTexture *ptex = pshader->value.as<UsdUVTexture>()) {
+      DCOUT("ptex = " << ptex);
+      (*dst) = ptex;
+
+      if (shader_out) {
+        (*shader_out) = pshader;
+      }
+
+      return true;
     }
+  }
+
+  return nonstd::make_unexpected(fmt::format(
+      "Prim {} must be Shader, but got {}", prim_part, prim->prim_type_name()));
+}
 
-    const crate::Spec &spec = _specs[spec_index];
+}  // namespace
 
-    Path path = GetPath(spec.path_index);
-    DCOUT("Path prim part: " << path.GetPrimPart()
-                             << ", prop part: " << path.GetPropPart()
-                             << ", spec_index = " << spec_index);
-
-    if (!_live_fieldsets.count(spec.fieldset_index)) {
-      PUSH_ERROR("FieldSet id: " + std::to_string(spec.fieldset_index.value) +
-                 " must exist in live fieldsets.");
-      return false;
+// W.I.P.
+// Convert UsdUVTexture shader node.
+// @return true upon conversion success(textures.back() contains the converted
+// UVTexture)
+//
+// Possible network configuration
+//
+// - UsdUVTexture -> UsdPrimvarReader
+// - UsdUVTexture -> UsdTransform2d -> UsdPrimvarReader
+bool RenderSceneConverter::ConvertUVTexture(const Path &tex_abs_path,
+                                            const AssetInfo &assetInfo,
+                                            const UsdUVTexture &texture,
+                                            UVTexture *tex_out) {
+  DCOUT("ConvertUVTexture " << tex_abs_path);
+
+  if (!tex_out) {
+    PUSH_ERROR_AND_RETURN("tex_out arg is nullptr.");
+  }
+  std::string err;
+
+  UVTexture tex;
+
+  // First load texture file.
+  if (!texture.file.authored()) {
+    PUSH_ERROR_AND_RETURN(fmt::format("`asset:file` is not authored. Path = {}",
+                                      tex_abs_path.prim_part()));
+  }
+
+  value::AssetPath assetPath;
+  if (auto apath = texture.file.get_value()) {
+    if (!apath.value().get_scalar(&assetPath)) {
+      PUSH_ERROR_AND_RETURN(
+          fmt::format("Failed to get `asset:file` value from Path {} (Maybe "
+                      "`asset:file` is timeSample value?)",
+                      tex_abs_path.prim_part()));
     }
+  } else {
+    PUSH_ERROR_AND_RETURN(
+        fmt::format("Failed to get `asset:file` value from Path {}",
+                    tex_abs_path.prim_part()));
+  }
 
-    const FieldValuePairVector &child_fields =
-        _live_fieldsets.at(spec.fieldset_index);
+  // TextureImage and BufferData
+  {
+    TextureImage texImage;
+    BufferData assetImageBuffer;
 
-    {
-      std::string prop_name = path.GetPropPart();
+    // Texel data is treated as byte array
+    assetImageBuffer.componentType = ComponentType::UInt8;
+    assetImageBuffer.count = 1;
 
-      PrimAttrib attr;
+    if (_scene_config.load_texture_assets) {
+      std::string warn;
 
-      bool ret = ParseAttribute(child_fields, &attr, prop_name);
-      DCOUT("prop: " << prop_name << ", ret = " << ret);
+      TextureImageLoaderFunction tex_loader_fun =
+          _material_config.texture_image_loader_function;
 
-      if (ret) {
-        // Currently we only support predefined PBR attributes.
+      if (!tex_loader_fun) {
+        tex_loader_fun = DefaultTextureImageLoaderFunction;
+      }
+
+      bool tex_ok = tex_loader_fun(
+          assetPath, assetInfo, _asset_resolver, &texImage, &assetImageBuffer.data,
+          _material_config.texture_image_loader_function_userdata, &warn, &err);
+
+      if (!tex_ok && !_material_config.allow_texture_load_failure) {
+        PUSH_ERROR_AND_RETURN("Failed to load texture image: " + err);
+      }
+
+      if (warn.size()) {
+        DCOUT("WARN: " << warn);
+        PushWarn(warn);
+      }
+
+      if (err.size()) {
+        // report as warning.
+        PushWarn(err);
+      }
 
-        if (prop_name.compare("info:id") == 0) {
-          auto p = attr.var.get_value<value::token>();
-          if (p) {
-            shader_type = p.value().str();
+      // store unresolved asset path.
+      texImage.asset_identifier = assetPath.GetAssetPath();
+
+    } else {
+      // store resolved asset path.
+      texImage.asset_identifier =
+          _asset_resolver.resolve(assetPath.GetAssetPath());
+    }
+
+    // colorSpace
+    if (texture.sourceColorSpace.authored()) {
+      UsdUVTexture::SourceColorSpace cs;
+      if (texture.sourceColorSpace.get_value().get_scalar(&cs)) {
+        if (cs == UsdUVTexture::SourceColorSpace::SRGB) {
+          texImage.usdColorSpace = tydra::ColorSpace::sRGB;
+        } else if (cs == UsdUVTexture::SourceColorSpace::Raw) {
+          texImage.usdColorSpace = tydra::ColorSpace::Linear;
+        } else if (cs == UsdUVTexture::SourceColorSpace::Auto) {
+          // TODO: Read colorspace from a file.
+          if ((texImage.assetTexelComponentType == ComponentType::UInt8) ||
+              (texImage.assetTexelComponentType == ComponentType::Int8)) {
+            texImage.usdColorSpace = tydra::ColorSpace::sRGB;
+          } else {
+            texImage.usdColorSpace = tydra::ColorSpace::Linear;
           }
         }
       }
     }
-  }
 
-  if (shader_type.empty()) {
-    PUSH_ERROR("`info:id` is missing in Shader.");
-    return false;
-  }
+    BufferData imageBuffer;
 
-  return true;
-}
+    // Linearlization and widen texel bit depth if required.
+    if (_material_config.linearize_color_space) {
 
-bool USDCReader::Impl::ReconstructPreviewSurface(
-    const Node &node, const FieldValuePairVector &fields,
-    const std::unordered_map<uint32_t, uint32_t> &path_index_to_spec_index_map,
-    PreviewSurface *shader) {
-  (void)shader;
-
-  for (const auto &fv : fields) {
-    if (fv.first == "properties") {
-      FIELDVALUE_DATATYPE_CHECK(fv, "properties", crate::kTokenVector)
+      size_t width = size_t(texImage.width);
+      size_t height = size_t(texImage.height);
+      size_t channels = size_t(texImage.channels);
+      if (channels == 4) {
+        PUSH_ERROR_AND_RETURN(fmt::format("TODO: RGBA color channels are not supported yet."));
+      }
+      if (channels > 4) {
+        PUSH_ERROR_AND_RETURN(fmt::format("TODO: Multiband color channels(5 or more) are not supported(yet)."));
+      }
 
-      // for (size_t i = 0; i < fv.second.GetStringArray().size(); i++) {
-      // }
-    }
-  }
+      if (assetImageBuffer.componentType == tydra::ComponentType::UInt8) {
 
-  //
-  // NOTE: Currently we assume one deeper node has Shader's attribute
-  //
-  for (size_t i = 0; i < node.GetChildren().size(); i++) {
-    int child_index = int(node.GetChildren()[i]);
-    if ((child_index < 0) || (child_index >= int(_nodes.size()))) {
-      _err += "Invalid child node id: " + std::to_string(child_index) +
-              ". Must be in range [0, " + std::to_string(_nodes.size()) + ")\n";
-      return false;
-    }
+        if (texImage.usdColorSpace == tydra::ColorSpace::sRGB) {
 
-    // const Node &child_node = _nodes[size_t(child_index)];
+          if (_material_config.preserve_texel_bitdepth) {
 
-    if (!path_index_to_spec_index_map.count(uint32_t(child_index))) {
-      // No specifier assigned to this child node.
-      PUSH_ERROR("No specifier found for node id: " +
-                 std::to_string(child_index));
-      return false;
-    }
+            // u8 sRGB -> u8 Linear
+            imageBuffer.componentType = tydra::ComponentType::UInt8;
 
-    uint32_t spec_index =
-        path_index_to_spec_index_map.at(uint32_t(child_index));
-    if (spec_index >= _specs.size()) {
-      PUSH_ERROR("Invalid specifier id: " + std::to_string(spec_index) +
-                 ". Must be in range [0, " + std::to_string(_specs.size()) +
-                 ")");
-      return false;
-    }
+            bool ret = srgb_8bit_to_linear_8bit(assetImageBuffer.data, width, height ,channels, /* channel stride */channels, &imageBuffer.data);
+            if (!ret) {
+              PUSH_ERROR_AND_RETURN("Failed to convert sRGB u8 image to Linear u8 image.");
+            }
 
-    const crate::Spec &spec = _specs[spec_index];
+            imageBuffer.count = 1;
 
-    Path path = GetPath(spec.path_index);
-    DCOUT("Path prim part: " << path.GetPrimPart()
-                             << ", prop part: " << path.GetPropPart()
-                             << ", spec_index = " << spec_index);
-
-    if (!_live_fieldsets.count(spec.fieldset_index)) {
-      PUSH_ERROR("FieldSet id: " + std::to_string(spec.fieldset_index.value) +
-                 " must exist in live fieldsets.");
-      return false;
-    }
+          } else {
+
+            // u8 sRGB -> fp32 Linear
+            imageBuffer.componentType = tydra::ComponentType::Float;
+
+            std::vector<float> buf;
+            bool ret = srgb_8bit_to_linear_f32(assetImageBuffer.data, width, height ,channels, /* channel stride */channels, &buf);
+            if (!ret) {
+              PUSH_ERROR_AND_RETURN("Failed to convert sRGB u8 image to Linear f32 image.");
+            }
 
-    const FieldValuePairVector &child_fields =
-        _live_fieldsets.at(spec.fieldset_index);
+            imageBuffer.data.resize(buf.size() * sizeof(float));
+            memcpy(imageBuffer.data.data(), buf.data(), sizeof(float) * buf.size());
+            imageBuffer.count = 1;
+          }
 
-    {
-      std::string prop_name = path.GetPropPart();
+          texImage.colorSpace = tydra::ColorSpace::Linear;
 
-      PrimAttrib attr;
+        } else if (texImage.usdColorSpace == tydra::ColorSpace::Linear) {
 
-      bool ret = ParseAttribute(child_fields, &attr, prop_name);
-      DCOUT("prop: " << prop_name << ", ret = " << ret);
+          if (_material_config.preserve_texel_bitdepth) {
 
-      if (ret) {
-        // Currently we only support predefined PBR attributes.
+            // no op.
+            imageBuffer = std::move(assetImageBuffer);
 
-        if (prop_name.compare("info:id") == 0) {
-          auto p = attr.var.get_value<std::string>();  // `token` type, but
-                                                       // treat it as string
-          if (p) {
-            if (p->compare("UsdPreviewSurface") != 0) {
-              PUSH_ERROR("`info:id` must be `UsdPreviewSurface`.");
-              return false;
+          } else {
+
+            // u8 -> fp32
+            imageBuffer.componentType = tydra::ComponentType::Float;
+
+            std::vector<float> buf;
+            bool ret = u8_to_f32_image(assetImageBuffer.data, width, height ,channels, &buf);
+            if (!ret) {
+              PUSH_ERROR_AND_RETURN("Failed to convert u8 image to f32 image.");
             }
+
+            imageBuffer.data.resize(buf.size() * sizeof(float));
+            memcpy(imageBuffer.data.data(), buf.data(), sizeof(float) * buf.size());
+            imageBuffer.count = 1;
           }
-        } else if (prop_name.compare("outputs:surface") == 0) {
-          // Surface shader output available
-        } else if (prop_name.compare("outputs:displacement") == 0) {
-          // Displacement shader output available
-        } else if (prop_name.compare("inputs:roughness") == 0) {
-          // type: float
-          auto p = attr.var.get_value<float>();
-          if (p) {
-            shader->roughness.value = (*p);
-          }
-        } else if (prop_name.compare("inputs:specular") == 0) {
-          // type: float
-          auto p = attr.var.get_value<float>();
-          if (p) {
-            shader->specular.value = (*p);
-          }
-        } else if (prop_name.compare("inputs:ior") == 0) {
-          // type: float
-          auto p = attr.var.get_value<float>();
-          if (p) {
-            shader->ior.value = (*p);
-          }
-        } else if (prop_name.compare("inputs:opacity") == 0) {
-          // type: float
-          auto p = attr.var.get_value<float>();
-          if (p) {
-            shader->opacity.value = (*p);
-          }
-        } else if (prop_name.compare("inputs:clearcoat") == 0) {
-          // type: float
-          auto p = attr.var.get_value<float>();
-          if (p) {
-            shader->clearcoat.value = (*p);
-          }
-        } else if (prop_name.compare("inputs:clearcoatRoughness") == 0) {
-          // type: float
-          auto p = attr.var.get_value<float>();
-          if (p) {
-            shader->clearcoatRoughness.value = (*p);
-          }
-        } else if (prop_name.compare("inputs:metallic") == 0) {
-          // type: float
-          auto p = attr.var.get_value<float>();
-          if (p) {
-            shader->metallic.value = (*p);
-          }
-        } else if (prop_name.compare("inputs:metallic.connect") == 0) {
-          // Currently we assume texture is assigned to this attribute.
-          auto p = attr.var.get_value<std::string>();
-          if (p) {
-            shader->metallic.path = *p;
-          }
-        } else if (prop_name.compare("inputs:diffuseColor") == 0) {
-          auto p = attr.var.get_value<value::float3>();
-          if (p) {
-            shader->diffuseColor.color = (*p);
-
-            DCOUT("diffuseColor: " << shader->diffuseColor.color[0] << ", "
-                                   << shader->diffuseColor.color[1] << ", "
-                                   << shader->diffuseColor.color[2]);
-          }
-        } else if (prop_name.compare("inputs:diffuseColor.connect") == 0) {
-          // Currently we assume texture is assigned to this attribute.
-          auto p = attr.var.get_value<std::string>();
-          if (p) {
-            shader->diffuseColor.path = *p;
+
+          texImage.colorSpace = tydra::ColorSpace::Linear;
+
+        } else {
+          PUSH_ERROR(fmt::format("TODO: Color space {}", to_string(texImage.usdColorSpace)));
+        }
+
+      } else if (assetImageBuffer.componentType == tydra::ComponentType::Float) {
+
+        // ignore preserve_texel_bitdepth
+
+        if (texImage.usdColorSpace == tydra::ColorSpace::sRGB) {
+
+          // srgb f32 -> linear f32
+          std::vector<float> in_buf;
+          std::vector<float> out_buf;
+          in_buf.resize(assetImageBuffer.data.size() / sizeof(float));
+          memcpy(in_buf.data(), assetImageBuffer.data.data(), in_buf.size() * sizeof(float));
+
+          out_buf.resize(assetImageBuffer.data.size() / sizeof(float));
+
+          bool ret = srgb_f32_to_linear_f32(in_buf, width, height ,channels, /* channel stride */channels, &out_buf);
+
+          imageBuffer.data.resize(assetImageBuffer.data.size());
+          memcpy(imageBuffer.data.data(), out_buf.data(), imageBuffer.data.size());
+
+          if (!ret) {
+            PUSH_ERROR_AND_RETURN("Failed to convert sRGB f32 image to Linear f32 image.");
           }
-        } else if (prop_name.compare("inputs:emissiveColor") == 0) {
-          // if (auto p = primvar::as_basic<value::float3>(&attr.var)) {
-          //  shader->emissiveColor.color = (*p);
-
-          //}
-        } else if (prop_name.compare("inputs:emissiveColor.connect") == 0) {
-          // Currently we assume texture is assigned to this attribute.
-          // if (auto p = primvar::as_basic<std::string>(&attr.var)) {
-          //  shader->emissiveColor.path = *p;
-          //}
+
+        } else if (texImage.usdColorSpace == tydra::ColorSpace::Linear) {
+
+          // no op
+          imageBuffer = std::move(assetImageBuffer);
+
+        } else {
+          PUSH_ERROR(fmt::format("TODO: Color space {}", to_string(texImage.usdColorSpace)));
         }
+
+      } else {
+        PUSH_ERROR(fmt::format("TODO: asset texture texel format {}", to_string(assetImageBuffer.componentType)));
       }
+
+
+    } else {
+
+      // Same color space.
+
+      if (assetImageBuffer.componentType == tydra::ComponentType::UInt8) {
+
+        if (_material_config.preserve_texel_bitdepth) {
+
+          // Do nothing.
+          imageBuffer = std::move(assetImageBuffer);
+
+        } else {
+
+          // u8 to f32
+          imageBuffer.componentType = tydra::ComponentType::Float;
+
+        }
+
+        texImage.colorSpace = texImage.usdColorSpace;
+
+      } else if (assetImageBuffer.componentType == tydra::ComponentType::Float) {
+
+        // ignore preserve_texel_bitdepth
+
+        // f32 to f32, so no op
+        imageBuffer = std::move(assetImageBuffer);
+
+      } else {
+        PUSH_ERROR(fmt::format("TODO: asset texture texel format {}", to_string(assetImageBuffer.componentType)));
+      }
+
     }
+
+    // Assign buffer id
+    texImage.buffer_id = int64_t(buffers.size());
+
+    // TODO: Share image data as much as possible.
+    // e.g. Texture A and B uses same image file, but texturing parameter is
+    // different.
+    buffers.emplace_back(imageBuffer);
+
+
+    tex.texture_image_id = int64_t(images.size());
+
+    images.emplace_back(texImage);
   }
 
-  return true;
-}
+  //
+  // Convert other UVTexture parameters
+  //
 
-bool USDCReader::Impl::ReconstructSkelRoot(
-    const Node &node, const FieldValuePairVector &fields,
-    const std::unordered_map<uint32_t, uint32_t> &path_index_to_spec_index_map,
-    SkelRoot *skelRoot) {
-  DCOUT("Parse skelRoot");
-  (void)skelRoot;
-
-  for (const auto &fv : fields) {
-    if (fv.first == "properties") {
-      FIELDVALUE_DATATYPE_CHECK(fv, "properties", crate::kTokenVector)
-
-      // for (size_t i = 0; i < fv.second.GetStringArray().size(); i++) {
-      // }
-    }
+  if (texture.bias.authored()) {
+    tex.bias = texture.bias.get_value();
   }
 
-  for (size_t i = 0; i < node.GetChildren().size(); i++) {
-    int child_index = int(node.GetChildren()[i]);
-    if ((child_index < 0) || (child_index >= int(_nodes.size()))) {
-      PUSH_ERROR("Invalid child node id: " + std::to_string(child_index) +
-                 ". Must be in range [0, " + std::to_string(_nodes.size()) +
-                 ")");
-      return false;
-    }
+  if (texture.scale.authored()) {
+    tex.scale = texture.scale.get_value();
+  }
 
-    // const Node &child_node = _nodes[size_t(child_index)];
+  if (texture.st.authored()) {
+    if (texture.st.is_connection()) {
+      const auto &paths = texture.st.get_connections();
+      if (paths.size() != 1) {
+        PUSH_ERROR_AND_RETURN(
+            "UsdUVTexture inputs:st connection must be single Path.");
+      }
+      const Path &path = paths[0];
 
-    if (!path_index_to_spec_index_map.count(uint32_t(child_index))) {
-      // No specifier assigned to this child node.
-      PUSH_ERROR("No specifier found for node id: " +
-                 std::to_string(child_index));
-      return false;
-    }
+      const Prim *readerPrim{nullptr};
+      if (!_stage->find_prim_at_path(Path(path.prim_part(), ""), readerPrim,
+                                     &err)) {
+        PUSH_ERROR_AND_RETURN(
+            "UsdUVTexture inputs:st connection targetPath not found in the "
+            "Stage: " +
+            err);
+      }
 
-    uint32_t spec_index =
-        path_index_to_spec_index_map.at(uint32_t(child_index));
-    if (spec_index >= _specs.size()) {
-      PUSH_ERROR("Invalid specifier id: " + std::to_string(spec_index) +
-                 ". Must be in range [0, " + std::to_string(_specs.size()) +
-                 ").");
-      return false;
-    }
+      if (!readerPrim) {
+        PUSH_ERROR_AND_RETURN(
+            "[InternlError] Invalid Prim connected to inputs:st");
+      }
 
-    const crate::Spec &spec = _specs[spec_index];
+      const Shader *pshader = readerPrim->as<Shader>();
+      if (!pshader) {
+        PUSH_ERROR_AND_RETURN(
+            fmt::format("UsdUVTexture inputs:st connected Prim must be "
+                        "Shader Prim, but got {} Prim",
+                        readerPrim->prim_type_name()));
+      }
 
-    Path path = GetPath(spec.path_index);
-    DCOUT("Path prim part: " << path.GetPrimPart()
-                             << ", prop part: " << path.GetPropPart()
-                             << ", spec_index = " << spec_index);
-
-    if (!_live_fieldsets.count(spec.fieldset_index)) {
-      _err += "FieldSet id: " + std::to_string(spec.fieldset_index.value) +
-              " must exist in live fieldsets.\n";
-      return false;
+      // currently UsdTranform2d or PrimvarReaer_float2 only for inputs:st
+      if (const UsdPrimvarReader_float2 *preader =
+              pshader->value.as<UsdPrimvarReader_float2>()) {
+        if (!preader) {
+          PUSH_ERROR_AND_RETURN(
+              fmt::format("Shader's info:id must be UsdPrimvarReader_float2, "
+                          "but got {}",
+                          pshader->info_id));
+        }
+
+        // Get value producing attribute(i.e, follow .connection and return
+        // terminal Attribute value)
+        value::token varname;
+        TerminalAttributeValue attr;
+        if (!tydra::EvaluateAttribute(*_stage, *readerPrim, "inputs:varname",
+                                      &attr, &err)) {
+          PUSH_ERROR_AND_RETURN(
+              fmt::format("Failed to evaluate UsdPrimvarReader_float2's "
+                          "inputs:varname.\n{}",
+                          err));
+        }
+
+        if (auto pv = attr.as<value::token>()) {
+          varname = *pv;
+        } else {
+          PUSH_ERROR_AND_RETURN(
+              "`inputs:varname` must be `token` type, but got " +
+              attr.type_name());
+        }
+        if (varname.str().empty()) {
+          PUSH_ERROR_AND_RETURN("`inputs:varname` is empty token.");
+        }
+        DCOUT("inputs:varname = " << varname);
+
+        tex.varname_uv = varname.str();
+      } else if (const UsdTransform2d *ptransform =
+                     pshader->value.as<UsdTransform2d>()) {
+        auto result = ConvertTexTransform2d(*_stage, path, *ptransform, &tex);
+        if (!result) {
+          PUSH_ERROR_AND_RETURN(result.error());
+        }
+      } else {
+        PUSH_ERROR_AND_RETURN(
+            "Unsupported Shader type for `inputs:st` connection: " +
+            pshader->info_id + "\n");
+      }
+
+    } else {
+      Animatable<value::texcoord2f> fallbacks = texture.st.get_value();
+      value::texcoord2f uv;
+      if (fallbacks.get_scalar(&uv)) {
+        tex.fallback_uv[0] = uv[0];
+        tex.fallback_uv[1] = uv[1];
+      } else {
+        // TODO: report warning.
+        PUSH_WARN(
+            "Failed to get fallback `st` texcoord attribute. Maybe `st` is "
+            "timeSamples attribute?\n");
+      }
     }
+  }
 
-    const FieldValuePairVector &child_fields =
-        _live_fieldsets.at(spec.fieldset_index);
+  if (texture.wrapS.authored()) {
+    tinyusdz::UsdUVTexture::Wrap wrap;
 
-    {
-      std::string prop_name = path.GetPropPart();
+    if (!texture.wrapS.get_value().get_scalar(&wrap)) {
+      PUSH_ERROR_AND_RETURN("Invalid UsdUVTexture inputs:wrapS value.");
+    }
 
-      PrimAttrib attr;
+    if (wrap == UsdUVTexture::Wrap::Repeat) {
+      tex.wrapS = UVTexture::WrapMode::REPEAT;
+    } else if (wrap == UsdUVTexture::Wrap::Mirror) {
+      tex.wrapS = UVTexture::WrapMode::MIRROR;
+    } else if (wrap == UsdUVTexture::Wrap::Clamp) {
+      tex.wrapS = UVTexture::WrapMode::CLAMP_TO_EDGE;
+    } else if (wrap == UsdUVTexture::Wrap::Black) {
+      tex.wrapS = UVTexture::WrapMode::CLAMP_TO_BORDER;
+    } else {
+      tex.wrapS = UVTexture::WrapMode::CLAMP_TO_EDGE;
+    }
+  }
 
-      bool ret = ParseAttribute(child_fields, &attr, prop_name);
-      DCOUT("prop:" << prop_name << ", ret = " << ret);
+  if (texture.wrapT.authored()) {
+    tinyusdz::UsdUVTexture::Wrap wrap;
 
-      if (ret) {
-        // Currently we only support predefined PBR attributes.
+    if (!texture.wrapT.get_value().get_scalar(&wrap)) {
+      PUSH_ERROR_AND_RETURN("Invalid UsdUVTexture inputs:wrapT value.");
+    }
 
-        if (prop_name.compare("info:id") == 0) {
-          auto p = attr.var.get_value<std::string>();  // `token` type, but
-                                                       // treat it as string
-          if (p) {
-            // shader_type = (*p);
-          }
-        }
-      }
+    if (wrap == UsdUVTexture::Wrap::Repeat) {
+      tex.wrapT = UVTexture::WrapMode::REPEAT;
+    } else if (wrap == UsdUVTexture::Wrap::Mirror) {
+      tex.wrapT = UVTexture::WrapMode::MIRROR;
+    } else if (wrap == UsdUVTexture::Wrap::Clamp) {
+      tex.wrapT = UVTexture::WrapMode::CLAMP_TO_EDGE;
+    } else if (wrap == UsdUVTexture::Wrap::Black) {
+      tex.wrapT = UVTexture::WrapMode::CLAMP_TO_BORDER;
+    } else {
+      tex.wrapT = UVTexture::WrapMode::CLAMP_TO_EDGE;
     }
   }
 
+  DCOUT("Converted UVTexture.");
+
+  (*tex_out) = tex;
   return true;
 }
 
-bool USDCReader::Impl::ReconstructSkeleton(
-    const Node &node, const FieldValuePairVector &fields,
-    const std::unordered_map<uint32_t, uint32_t> &path_index_to_spec_index_map,
-    Skeleton *skeleton) {
-  DCOUT("Parse skeleton");
-  (void)skeleton;
-
-  for (const auto &fv : fields) {
-    if (fv.first == "properties") {
-      FIELDVALUE_DATATYPE_CHECK(fv, "properties", crate::kTokenVector)
-
-      // for (size_t i = 0; i < fv.second.GetStringArray().size(); i++) {
-      // }
-    }
+template <typename T, typename Dty>
+bool RenderSceneConverter::ConvertPreviewSurfaceShaderParam(
+    const Path &shader_abs_path,
+    const TypedAttributeWithFallback<Animatable<T>> &param,
+    const std::string &param_name, ShaderParam<Dty> &dst_param) {
+  if (!param.authored()) {
+    return true;
   }
 
-  for (size_t i = 0; i < node.GetChildren().size(); i++) {
-    int child_index = int(node.GetChildren()[i]);
-    if ((child_index < 0) || (child_index >= int(_nodes.size()))) {
-      PUSH_ERROR("Invalid child node id: " + std::to_string(child_index) +
-                 ". Must be in range [0, " + std::to_string(_nodes.size()) +
-                 ")");
-      return false;
-    }
+  if (param.is_blocked()) {
+    PUSH_ERROR_AND_RETURN(fmt::format("{} attribute is blocked.", param_name));
+  } else if (param.is_connection()) {
+    DCOUT(fmt::format("{] is attribute connection.", param_name));
 
-    // const Node &child_node = _nodes[size_t(child_index)];
+    const UsdUVTexture *ptex{nullptr};
+    const Shader *pshader{nullptr};
+    Path texPath;
+    auto result = GetConnectedUVTexture(*_stage, param, &texPath, &ptex, &pshader);
 
-    if (!path_index_to_spec_index_map.count(uint32_t(child_index))) {
-      // No specifier assigned to this child node.
-      PUSH_ERROR("No specifier found for node id: " +
-                 std::to_string(child_index));
-      return false;
+    if (!result) {
+      PUSH_ERROR_AND_RETURN(result.error());
     }
 
-    uint32_t spec_index =
-        path_index_to_spec_index_map.at(uint32_t(child_index));
-    if (spec_index >= _specs.size()) {
-      PUSH_ERROR("Invalid specifier id: " + std::to_string(spec_index) +
-                 ". Must be in range [0, " + std::to_string(_specs.size()) +
-                 ")");
-      return false;
+    if (!ptex) {
+      PUSH_ERROR_AND_RETURN("[InternalError] ptex is nullptr.");
     }
+    DCOUT("ptex = " << ptex->name);
 
-    const crate::Spec &spec = _specs[spec_index];
+    if (!pshader) {
+      PUSH_ERROR_AND_RETURN("[InternalError] pshader is nullptr.");
+    }
 
-    Path path = GetPath(spec.path_index);
-    DCOUT("Path prim part: " << path.GetPrimPart()
-                             << ", prop part: " << path.GetPropPart()
-                             << ", spec_index = " << spec_index);
-
-    if (!_live_fieldsets.count(spec.fieldset_index)) {
-      PUSH_ERROR("FieldSet id: " + std::to_string(spec.fieldset_index.value) +
-                 " must exist in live fieldsets.");
-      return false;
+    DCOUT("Get connected UsdUVTexture Prim: " << texPath);
+
+    UVTexture rtex;
+    const AssetInfo &assetInfo = pshader->metas().get_assetInfo();
+    if (!ConvertUVTexture(texPath, assetInfo, *ptex, &rtex)) {
+      PUSH_ERROR_AND_RETURN(fmt::format(
+          "Failed to convert UVTexture connected to {}", param_name));
     }
 
-    const FieldValuePairVector &child_fields =
-        _live_fieldsets.at(spec.fieldset_index);
+    uint64_t texId = textures.size();
+    textures.push_back(rtex);
 
-    {
-      std::string prop_name = path.GetPropPart();
+    textureMap.add(texId, shader_abs_path.prim_part() + "." + param_name);
 
-      PrimAttrib attr;
+    DCOUT(fmt::format("TexId {} = {}",
+                      shader_abs_path.prim_part() + ".diffuseColor", texId));
 
-      bool ret = ParseAttribute(child_fields, &attr, prop_name);
-      DCOUT("prop:" << prop_name << ", ret = " << ret);
+    dst_param.textureId = int32_t(texId);
 
-      if (ret) {
-        // Currently we only support predefined PBR attributes.
+    return true;
+  } else {
+    T val;
+    if (!param.get_value().get_scalar(&val)) {
+      PUSH_ERROR_AND_RETURN(
+          fmt::format("Failed to get {} at `default` timecode.", param_name));
+    }
 
-        if (prop_name.compare("info:id") == 0) {
-          auto p = attr.var.get_value<std::string>();  // `token` type, but
-                                                       // treat it as string
-          if (p) {
-            // shader_type = (*p);
-          }
-        }
+    dst_param.set_value(val);
+
+    return true;
+  }
+}
+
+// TODO: timeSamples
+bool RenderSceneConverter::ConvertPreviewSurfaceShader(
+    const Path &shader_abs_path, const UsdPreviewSurface &shader,
+    PreviewSurfaceShader *rshader_out) {
+  if (!rshader_out) {
+    PUSH_ERROR_AND_RETURN("rshader_out arg is nullptr.");
+  }
+
+  PreviewSurfaceShader rshader;
+
+  if (shader.useSpecularWorkflow.authored()) {
+    if (shader.useSpecularWorkflow.is_blocked()) {
+      PUSH_ERROR_AND_RETURN(
+          fmt::format("useSpecularWorkflow attribute is blocked."));
+    } else if (shader.useSpecularWorkflow.is_connection()) {
+      PUSH_ERROR_AND_RETURN(
+          fmt::format("TODO: useSpecularWorkflow with connection."));
+    } else {
+      int val;
+      if (!shader.useSpecularWorkflow.get_value().get_scalar(&val)) {
+        PUSH_ERROR_AND_RETURN(fmt::format(
+            "Failed to get useSpcularWorkFlow value at `default` timecode."));
       }
+
+      rshader.useSpecularWorkFlow = val ? true : false;
     }
   }
 
+  if (!ConvertPreviewSurfaceShaderParam(shader_abs_path, shader.diffuseColor,
+                                        "diffuseColor", rshader.diffuseColor)) {
+    return false;
+  }
+
+  if (!ConvertPreviewSurfaceShaderParam(shader_abs_path, shader.normal,
+                                        "normal", rshader.normal)) {
+    return false;
+  }
+
+  if (!ConvertPreviewSurfaceShaderParam(shader_abs_path, shader.roughness,
+                                        "roughness", rshader.roughness)) {
+    return false;
+  }
+
+  if (!ConvertPreviewSurfaceShaderParam(shader_abs_path, shader.metallic,
+                                        "metallic", rshader.metallic)) {
+    return false;
+  }
+
+  if (!ConvertPreviewSurfaceShaderParam(shader_abs_path, shader.clearcoat,
+                                        "clearcoat", rshader.clearcoat)) {
+    return false;
+  }
+
+  if (!ConvertPreviewSurfaceShaderParam(
+          shader_abs_path, shader.clearcoatRoughness, "clearcoatRoughness",
+          rshader.clearcoatRoughness)) {
+    return false;
+  }
+
+  if (!ConvertPreviewSurfaceShaderParam(shader_abs_path, shader.opacity,
+                                        "opacity", rshader.opacity)) {
+    return false;
+  }
+
+  if (!ConvertPreviewSurfaceShaderParam(
+          shader_abs_path, shader.opacityThreshold, "opacityThreshold",
+          rshader.opacityThreshold)) {
+    return false;
+  }
+
+  if (!ConvertPreviewSurfaceShaderParam(shader_abs_path, shader.ior, "ior",
+                                        rshader.ior)) {
+    return false;
+  }
+
+  if (!ConvertPreviewSurfaceShaderParam(shader_abs_path, shader.occlusion,
+                                        "occlusion", rshader.occlusion)) {
+    return false;
+  }
+
+  if (!ConvertPreviewSurfaceShaderParam(shader_abs_path, shader.displacement,
+                                        "displacement", rshader.displacement)) {
+    return false;
+  }
+
+  (*rshader_out) = rshader;
   return true;
 }
 
-bool USDCReader::Impl::ReconstructSceneRecursively(
-    int parent, int level,
-    const std::unordered_map<uint32_t, uint32_t> &path_index_to_spec_index_map,
-    Scene *scene) {
-
-  DCOUT("ReconstructSceneRecursively: parent = " << std::to_string(parent) << ", level = " << std::to_string(level));
-
-  if ((parent < 0) || (parent >= int(_nodes.size()))) {
-    PUSH_ERROR("Invalid parent node id: " + std::to_string(parent) +
-               ". Must be in range [0, " + std::to_string(_nodes.size()) + ")");
-    return false;
+bool RenderSceneConverter::ConvertMaterial(const Path &mat_abs_path,
+                                           const tinyusdz::Material &material,
+                                           RenderMaterial *rmat_out) {
+  if (!_stage) {
+    PUSH_ERROR_AND_RETURN("stage is nullptr.");
+  }
+
+  if (!rmat_out) {
+    PUSH_ERROR_AND_RETURN("rmat_out argument is nullptr.");
   }
 
-  const Node &node = _nodes[size_t(parent)];
+  RenderMaterial rmat;
+  rmat.abs_path = mat_abs_path.prim_part();
+  rmat.name = mat_abs_path.element_name();
+  DCOUT("rmat.abs_path = " << rmat.abs_path);
+  DCOUT("rmat.name = " << rmat.name);
 
-#ifdef TINYUSDZ_LOCAL_DEBUG_PRINT
-  auto IndentStr = [](int l) -> std::string {
-    std::string indent;
-    for (size_t i = 0; i < size_t(l); i++) {
-      indent += "  ";
+  std::string err;
+
+  Path surfacePath;
+
+  //
+  // surface shader
+  {
+    if (material.surface.authored()) {
+      auto paths = material.surface.get_connections();
+      DCOUT("paths = " << paths);
+      // must have single targetPath.
+      if (paths.size() != 1) {
+        PUSH_ERROR_AND_RETURN(
+            fmt::format("{}'s outputs:surface must be connection with single "
+                        "target Path.\n",
+                        mat_abs_path.full_path_name()));
+      }
+      surfacePath = paths[0];
+    } else {
+      PUSH_ERROR_AND_RETURN(
+          fmt::format("{}'s outputs:surface isn't authored.\n",
+                      mat_abs_path.full_path_name()));
     }
 
-    return indent;
-  };
-  std::cout << IndentStr(level) << "lv[" << level << "] node_index[" << parent
-            << "] " << node.GetLocalPath() << " ==\n";
-  std::cout << IndentStr(level) << " childs = [";
-  for (size_t i = 0; i < node.GetChildren().size(); i++) {
-    std::cout << node.GetChildren()[i];
-    if (i != (node.GetChildren().size() - 1)) {
-      std::cout << ", ";
+    const Prim *shaderPrim{nullptr};
+    if (!_stage->find_prim_at_path(
+            Path(surfacePath.prim_part(), /* prop part */ ""), shaderPrim,
+            &err)) {
+      PUSH_ERROR_AND_RETURN(fmt::format(
+          "{}'s outputs:surface isn't connected to exising Prim path.\n",
+          mat_abs_path.full_path_name()));
+    }
+
+    if (!shaderPrim) {
+      // this should not happen though.
+      PUSH_ERROR_AND_RETURN("[InternalError] invalid Shader Prim.\n");
+    }
+
+    const Shader *shader = shaderPrim->as<Shader>();
+
+    if (!shader) {
+      PUSH_ERROR_AND_RETURN(
+          fmt::format("{}'s outputs:surface must be connected to Shader Prim, "
+                      "but connected to `{}` Prim.\n",
+                      shaderPrim->prim_type_name()));
+    }
+
+    // Currently must be UsdPreviewSurface
+    const UsdPreviewSurface *psurface = shader->value.as<UsdPreviewSurface>();
+    if (!psurface) {
+      PUSH_ERROR_AND_RETURN(
+          fmt::format("Shader's info:id must be UsdPreviewSurface, but got {}",
+                      shader->info_id));
     }
-  }
-  std::cout << "]\n";
-#endif
 
-  if (!path_index_to_spec_index_map.count(uint32_t(parent))) {
-    // No specifier assigned to this node.
-    DCOUT("No specifier assigned to this node: " << parent);
-    return true;  // would be OK.
+    // prop part must be `outputs:surface` for now.
+    if (surfacePath.prop_part() != "outputs:surface") {
+      PUSH_ERROR_AND_RETURN(
+          fmt::format("{}'s outputs:surface connection must point to property "
+                      "`outputs:surface`, but got `{}`",
+                      mat_abs_path.full_path_name(), surfacePath.prop_part()));
+    }
+
+    PreviewSurfaceShader pss;
+    if (!ConvertPreviewSurfaceShader(surfacePath, *psurface, &pss)) {
+      PUSH_ERROR_AND_RETURN(fmt::format(
+          "Failed to convert UsdPreviewSurface : {}", surfacePath.prim_part()));
+    }
+
+    rmat.surfaceShader = pss;
   }
 
-  uint32_t spec_index = path_index_to_spec_index_map.at(uint32_t(parent));
-  if (spec_index >= _specs.size()) {
-    PUSH_ERROR("Invalid specifier id: " + std::to_string(spec_index) +
-               ". Must be in range [0, " + std::to_string(_specs.size()) + ")");
+  DCOUT("Converted Material: " << mat_abs_path);
+
+  (*rmat_out) = rmat;
+  return true;
+}
+
+namespace {
+
+bool MeshVisitor(const tinyusdz::Path &abs_path, const tinyusdz::Prim &prim,
+                 const int32_t level, void *userdata, std::string *err) {
+  if (!userdata) {
     return false;
   }
 
-  const crate::Spec &spec = _specs[spec_index];
+  RenderSceneConverter *converter =
+      reinterpret_cast<RenderSceneConverter *>(userdata);
 
-  DCOUT(Indent(uint32_t(level)) << "  specTy = " << to_string(spec.spec_type));
-  DCOUT(Indent(uint32_t(level))
-        << "  fieldSetIndex = " << spec.fieldset_index.value);
-
-  if (!_live_fieldsets.count(spec.fieldset_index)) {
-    PUSH_ERROR("FieldSet id: " + std::to_string(spec.fieldset_index.value) +
-               " must exist in live fieldsets.");
+  if (level > 1024 * 1024) {
+    if (err) {
+      (*err) += "Scene graph is too deep.\n";
+    }
+    // Too deep
     return false;
   }
 
-  const FieldValuePairVector &fields = _live_fieldsets.at(spec.fieldset_index);
+  if (const tinyusdz::GeomMesh *pmesh = prim.as<tinyusdz::GeomMesh>()) {
+    DCOUT("Material: " << abs_path);
 
-  // root only attributes.
-  if (parent == 0) {
-    for (const auto &fv : fields) {
-      if (fv.first == "upAxis") {
-        auto vt = fv.second.get_value<value::token>();
-        if (!vt) {
-          PUSH_ERROR("`upAxis` must be `token` type.");
+    //
+    // First convert Material
+    //
+
+    const std::string mesh_path_str = abs_path.full_path_name();
+
+    std::vector<RenderMaterial> &rmaterials = converter->materials;
+
+    tinyusdz::Path bound_material_path;
+    const tinyusdz::Material *bound_material{nullptr};
+    bool ret = tinyusdz::tydra::FindBoundMaterial(
+        *converter->GetStagePtr(), /* GeomMesh prim path */ abs_path,
+        /* suffix */ "", &bound_material_path, &bound_material, err);
+
+    int64_t rmaterial_id = -1;
+
+    if (ret && bound_material) {
+      DCOUT("Bound material path: " << bound_material_path);
+
+      const auto matIt =
+          converter->materialMap.find(bound_material_path.full_path_name());
+
+      if (matIt != converter->materialMap.s_end()) {
+        // Got material in the cache.
+        uint64_t mat_id = matIt->second;
+        if (mat_id >=
+            converter->materials.size()) {  // this should not happen though
+          if (err) {
+            (*err) += "Material index out-of-range.\n";
+          }
           return false;
         }
 
-        std::string v = vt.value().str();
-        if ((v != "Y") && (v != "Z") && (v != "X")) {
-          PUSH_ERROR("`upAxis` must be 'X', 'Y' or 'Z' but got '" + v + "'");
+        if (mat_id >= (std::numeric_limits<int64_t>::max)()) {
+          if (err) {
+            (*err) += "Material index too large.\n";
+          }
           return false;
         }
-        DCOUT("upAxis = " << v);
-        scene->upAxis = std::move(v);
 
-      } else if (fv.first == "metersPerUnit") {
-        if (auto vf = fv.second.get_value<float>()) {
-          scene->metersPerUnit = double(vf.value());
-        } else if (auto vd = fv.second.get_value<double>()) {
-          scene->metersPerUnit = vd.value();
-        } else {
-          PUSH_ERROR(
-              "`metersPerUnit` value must be double or float type, but got '" +
-              fv.second.GetTypeName() + "'");
-          return false;
-        }
-        DCOUT("metersPerUnit = " << scene->metersPerUnit);
-      } else if (fv.first == "timeCodesPerSecond") {
-        if (auto vf = fv.second.get_value<float>()) {
-          scene->timeCodesPerSecond = double(vf.value());
-        } else if (auto vd = fv.second.get_value<double>()) {
-          scene->timeCodesPerSecond = vd.value();
-        } else {
-          PUSH_ERROR(
-              "`timeCodesPerSecond` value must be double or float "
-              "type, but got '" +
-              fv.second.GetTypeName() + "'");
-          return false;
-        }
-        DCOUT("timeCodesPerSecond = " << scene->timeCodesPerSecond);
-      } else if ((fv.first == "defaultPrim")) {
-        auto v = fv.second.get_value<value::token>();
-        if (!v) {
-          PUSH_ERROR("`defaultPrim` must be `token` type.");
-          return false;
-        }
+        rmaterial_id = int64_t(mat_id);
 
-        scene->defaultPrim = v.value().str();
-        DCOUT("defaultPrim = " << scene->defaultPrim);
-      } else if (fv.first == "customLayerData") {
-        if (auto v = fv.second.get_value<crate::CrateValue::Dictionary>()) {
-          auto dict = v.value();
-          (void)dict;
-          PUSH_WARN("TODO: Store customLayerData.");
-          // scene->customLayerData = fv.second.GetDictionary();
-        } else {
-          PUSH_ERROR("customLayerData must be `dict` type.");
-          return false;
-        }
-      } else if (fv.first == "primChildren") {
-        auto v = fv.second.get_value<std::vector<value::token>>();
-        if (!v) {
-          PUSH_ERROR("Type must be TokenArray for `primChildren`, but got " +
-                     fv.second.GetTypeName() + "\n");
+      } else {
+        RenderMaterial rmat;
+        if (!converter->ConvertMaterial(bound_material_path, *bound_material,
+                                        &rmat)) {
+          if (err) {
+            (*err) += fmt::format("Material conversion failed: {}",
+                                  bound_material_path);
+          }
           return false;
         }
 
-        // convert to string.
-        std::vector<std::string> children;
-        for (const auto &item : v.value()) {
-          children.push_back(item.str());
-        }
-        scene->primChildren = children;
-        DCOUT("primChildren = " << children);
-      } else if (fv.first == "documentation") {  // 'doc'
-
-        auto v = fv.second.get_value<std::string>();
-        if (!v) {
-          PUSH_ERROR("Type must be String for `documentation`, but got " +
-                     fv.second.GetTypeName() + "\n");
+        // Assign new material ID
+        uint64_t mat_id = rmaterials.size();
+
+        if (mat_id >= (std::numeric_limits<int64_t>::max)()) {
+          if (err) {
+            (*err) += "Material index too large.\n";
+          }
           return false;
         }
-        scene->doc = v.value();
-        DCOUT("doc = " << v.value());
-      } else {
-        PUSH_WARN("TODO: " + fv.first + "\n");
-        //_err += "TODO: " + fv.first + "\n";
-        return false;
-        // TODO(syoyo):
+        rmaterial_id = int64_t(mat_id);
+
+        converter->materialMap.add(bound_material_path.full_path_name(),
+                                   uint64_t(rmaterial_id));
+        DCOUT("Add material: " << mat_id << " " << rmat.abs_path << " ( "
+                               << rmat.name << " ) ");
+
+        rmaterials.push_back(rmat);
       }
     }
-  }
 
-  std::string node_type;
-  crate::CrateValue::Dictionary assetInfo;
+    RenderMesh rmesh;
 
-  auto GetTypeName = [](const FieldValuePairVector &fvs) -> nonstd::optional<std::string> {
-    for (const auto &fv : fvs) {
-      DCOUT(" fv.first = " << fv.first << ", type = " << fv.second.GetTypeName());
-      if (fv.first == "typeName") {
-        auto v = fv.second.get_value<value::token>();
-        if (v) {
-          return v.value().str();
-        }
+    if (!converter->ConvertMesh(rmaterial_id, *pmesh, &rmesh)) {
+      if (err) {
+        (*err) += fmt::format("Mesh conversion failed: {}",
+                              abs_path.full_path_name());
       }
+      return false;
     }
 
-    return nonstd::nullopt;
-  };
+    DCOUT("renderMaterialId = " << rmaterial_id);
 
-  DCOUT("---");
+    // Do not assign materialIds when no material bound to this Mesh.
+    // TODO: per-face material.
+    if ((rmaterial_id > -1) &&
+        (rmaterial_id < (std::numeric_limits<int32_t>::max)())) {
+      rmesh.materialIds.resize(rmesh.faceVertexCounts.size(),
+                               int32_t(rmaterial_id));
+    }
 
-  if (auto v = GetTypeName(fields)) {
-    node_type = v.value();
+    converter->meshes.emplace_back(std::move(rmesh));
   }
 
-  DCOUT("===");
+  return true;  // continue traversal
+}
+}  // namespace
 
-#if 0  // TODO: Refactor)
-  for (const auto &fv : fields) {
-    DCOUT(IndentStr(level) << "  \"" << fv.first
-                           << "\" : ty = " << fv.second.GetTypeName());
-
-    if (fv.second.GetTypeId() == VALUE_TYPE_SPECIFIER) {
-      DCOUT(IndentStr(level)
-            << "    specifier = " << to_string(fv.second.GetSpecifier()));
-    } else if ((fv.first == "primChildren") &&
-               (fv.second.GetTypeName() == "TokenArray")) {
-      // Check if TokenArray contains known child nodes
-      const auto &tokens = fv.second.GetStringArray();
-
-      // bool valid = true;
-      for (const auto &token : tokens) {
-        if (!node.GetPrimChildren().count(token)) {
-          _err += "primChild '" + token + "' not found in node '" +
-                  node.GetPath().full_path_name() + "'\n";
-          // valid = false;
-          break;
-        }
-      }
-    } else if (fv.second.GetTypeName() == "TokenArray") {
-      assert(fv.second.IsArray());
-      const auto &strs = fv.second.GetStringArray();
-      for (const auto &str : strs) {
-        (void)str;
-        DCOUT(IndentStr(level + 2) << str);
-      }
-    } else if ((fv.first == "customLayerData") &&
-               (fv.second.GetTypeName() == "Dictionary")) {
-      const auto &dict = fv.second.GetDictionary();
-
-      for (const auto &item : dict) {
-        if (item.second.GetTypeName() == "String") {
-          scene->customLayerData[item.first] = item.second.GetString();
-        } else if (item.second.GetTypeName() == "IntArray") {
-          const auto arr = item.second.GetIntArray();
-          scene->customLayerData[item.first] = arr;
-        } else {
-          PUSH_WARN("TODO(customLayerData): name " + item.first + ", type " +
-                    item.second.GetTypeName());
-        }
-      }
+bool RenderSceneConverter::ConvertToRenderScene(const Stage &stage,
+                                                RenderScene *scene) {
+  if (!scene) {
+    PUSH_ERROR_AND_RETURN("nullptr for RenderScene argument.");
+  }
 
-    } else if (fv.second.GetTypeName() == "TokenListOp") {
-      PUSH_WARN("TODO: name " + fv.first + ", type TokenListOp.");
-    } else if (fv.second.GetTypeName() == "Vec3fArray") {
-      PUSH_WARN("TODO: name: " + fv.first +
-                ", type: " + fv.second.GetTypeName());
+  _stage = &stage;
 
-    } else if ((fv.first == "assetInfo") &&
-               (fv.second.GetTypeName() == "Dictionary")) {
-      node_type = "assetInfo";
-      assetInfo = fv.second.GetDictionary();
+  // Build Xform at default time.
+  XformNode xform_node;
+  if (!BuildXformNodeFromStage(stage, &xform_node)) {
+    PUSH_ERROR_AND_RETURN("Failed to build Xform node hierarchy.\n");
+  }
 
-    } else {
-      PUSH_WARN("TODO: name: " + fv.first +
-                ", type: " + fv.second.GetTypeName());
-      // return false;
-    }
+  // W.I.P.
+
+  RenderScene render_scene;
+
+  // 1. Visit GeomMesh
+  // 2. If the mesh has bound material
+  //   1. Create Material
+  //
+  // TODO: GeomSubset(per-face material)
+
+  std::string err;
+
+  // Pass `this` through userdata ptr
+  bool ret = tydra::VisitPrims(stage, MeshVisitor, this, &err);
+
+  if (!ret) {
+    _err += err;
+
+    return false;
   }
-#endif
 
-  DCOUT("node_type = " << node_type);
+  // render_scene.meshMap = std::move(meshMap);
+  // render_scene.materialMap = std::move(materialMap);
+  // render_scene.textureMap = std::move(textureMap);
+  // render_scene.imageMap = std::move(imageMap);
+  // render_scene.bufferMap = std::move(bufferMap);
+
+  render_scene.nodes = std::move(nodes);
+  render_scene.meshes = std::move(meshes);
+  render_scene.textures = std::move(textures);
+  render_scene.images = std::move(images);
+  render_scene.buffers = std::move(buffers);
+  render_scene.materials = std::move(materials);
 
+  (*scene) = std::move(render_scene);
+  return true;
+}
 
-  if (node_type == "Xform") {
-    Xform xform;
-    if (!ReconstructXform(node, fields, path_index_to_spec_index_map, &xform)) {
-      _err += "Failed to reconstruct Xform.\n";
-      return false;
+bool DefaultTextureImageLoaderFunction(const value::AssetPath &assetPath,
+                                       const AssetInfo &assetInfo,
+                                       AssetResolutionResolver &assetResolver,
+                                       TextureImage *texImageOut,
+                                       std::vector<uint8_t> *imageData,
+                                       void *userdata, std::string *warn,
+                                       std::string *err) {
+  if (!texImageOut) {
+    if (err) {
+      (*err) = "`imageOut` argument is nullptr\n";
     }
-    scene->xforms.push_back(xform);
-  } else if (node_type == "BasisCurves") {
-    GeomBasisCurves curves;
-    if (!ReconstructGeomBasisCurves(node, fields, path_index_to_spec_index_map,
-                                    &curves)) {
-      _err += "Failed to reconstruct GeomBasisCurves.\n";
-      return false;
-    }
-    curves.name = node.GetLocalPath();  // FIXME
-    scene->geom_basis_curves.push_back(curves);
-  } else if (node_type == "GeomSubset") {
-    GeomSubset geom_subset;
-    // TODO(syoyo): Pass Parent 'Geom' node.
-    if (!ReconstructGeomSubset(node, fields, path_index_to_spec_index_map,
-                               &geom_subset)) {
-      _err += "Failed to reconstruct GeomSubset.\n";
-      return false;
-    }
-    geom_subset.name = node.GetLocalPath();  // FIXME
-    // TODO(syoyo): add GeomSubset to parent `Mesh`.
-    _err += "TODO: Add GeomSubset to Mesh.\n";
     return false;
+  }
 
-  } else if (node_type == "Mesh") {
-    GeomMesh mesh;
-    if (!ReconstructGeomMesh(node, fields, path_index_to_spec_index_map,
-                             &mesh)) {
-      PUSH_ERROR("Failed to reconstruct GeomMesh.");
-      return false;
+  if (!imageData) {
+    if (err) {
+      (*err) = "`imageData` argument is nullptr\n";
     }
-    mesh.name = node.GetLocalPath();  // FIXME
-    scene->geom_meshes.push_back(mesh);
-  } else if (node_type == "Material") {
-    Material material;
-    if (!ReconstructMaterial(node, fields, path_index_to_spec_index_map,
-                             &material)) {
-      PUSH_ERROR("Failed to reconstruct Material.");
-      return false;
+    return false;
+  }
+
+  // TODO: assetInfo
+  (void)assetInfo;
+  (void)userdata;
+  (void)warn;
+
+  std::string resolvedPath = assetResolver.resolve(assetPath.GetAssetPath());
+
+  if (resolvedPath.empty()) {
+    if (err) {
+      (*err) += fmt::format("Failed to resolve asset path: {}\n",
+                            assetPath.GetAssetPath());
     }
-    material.name = node.GetLocalPath();  // FIXME
-    scene->materials.push_back(material);
-  } else if (node_type == "Shader") {
-    Shader shader;
-    if (!ReconstructShader(node, fields, path_index_to_spec_index_map,
-                           &shader)) {
-      PUSH_ERROR("Failed to reconstruct PreviewSurface(Shader).");
-      return false;
+    return false;
+  }
+
+  DCOUT("Resolved asset path = " << resolvedPath);
+  auto result = tinyusdz::image::LoadImageFromFile(resolvedPath);
+  if (!result) {
+    if (err) {
+      (*err) += "Failed to load image file: " + result.error() + "\n";
     }
+    return false;
+  }
 
-    shader.name = node.GetLocalPath();  // FIXME
+  TextureImage texImage;
 
-    scene->shaders.push_back(shader);
-  } else if (node_type == "Scope") {
-    std::cout << "TODO: Scope\n";
-  } else if (node_type == "assetInfo") {
-    PUSH_WARN("TODO: Reconstruct dictionary value of `assetInfo`");
-    //_nodes[size_t(parent)].SetAssetInfo(assetInfo);
-  } else if (node_type == "Skeleton") {
-    Skeleton skeleton;
-    if (!ReconstructSkeleton(node, fields, path_index_to_spec_index_map,
-                             &skeleton)) {
-      PUSH_ERROR("Failed to reconstruct Skeleton.");
-      return false;
+  texImage.asset_identifier = resolvedPath;
+  texImage.channels = result.value().image.channels;
+
+  if (result.value().image.bpp == 8) {
+    // assume uint8
+    texImage.assetTexelComponentType = ComponentType::UInt8;
+  } else {
+    DCOUT("TODO: bpp = " << result.value().image.bpp);
+    if (err) {
+      (*err) = "TODO or unsupported bpp: " +
+               std::to_string(result.value().image.bpp) + "\n";
     }
+    return false;
+  }
 
-    skeleton.name = node.GetLocalPath();  // FIXME
+  texImage.channels = result.value().image.channels;
+  texImage.width = result.value().image.width;
+  texImage.height = result.value().image.height;
 
-    scene->skeletons.push_back(skeleton);
+  (*texImageOut) = texImage;
 
-  } else if (node_type == "SkelRoot") {
-    SkelRoot skelRoot;
-    if (!ReconstructSkelRoot(node, fields, path_index_to_spec_index_map,
-                             &skelRoot)) {
-      PUSH_ERROR("Failed to reconstruct SkelRoot.");
-      return false;
-    }
+  // raw image data
+  (*imageData) = result.value().image.data;
+
+  return true;
+}
 
-    skelRoot.name = node.GetLocalPath();  // FIXME
 
-    scene->skel_roots.push_back(skelRoot);
-  } else {
-    if (!node_type.empty()) {
-      DCOUT("TODO or we can ignore this node: node_type: " << node_type);
+std::string to_string(ColorSpace cty) {
+  std::string s;
+  switch (cty) {
+    case ColorSpace::sRGB: {
+      s = "srgb";
+      break;
+    }
+    case ColorSpace::Linear: {
+      s = "linear";
+      break;
+    }
+    case ColorSpace::Rec709: {
+      s = "rec709";
+      break;
+    }
+    case ColorSpace::OCIO: {
+      s = "ocio";
+      break;
+    }
+    case ColorSpace::Custom: {
+      s = "custom";
+      break;
     }
   }
 
-  DCOUT("Children.size = " << node.GetChildren().size());
+  return s;
+}
 
-  for (size_t i = 0; i < node.GetChildren().size(); i++) {
-    if (!ReconstructSceneRecursively(int(node.GetChildren()[i]), level + 1,
-                                     path_index_to_spec_index_map, scene)) {
-      return false;
+std::string to_string(ComponentType cty) {
+  std::string s;
+  switch (cty) {
+    case ComponentType::UInt8: {
+      s = "uint8";
+      break;
+    }
+    case ComponentType::Int8: {
+      s = "int8";
+      break;
+    }
+    case ComponentType::UInt16: {
+      s = "uint16";
+      break;
+    }
+    case ComponentType::Int16: {
+      s = "int16";
+      break;
+    }
+    case ComponentType::UInt32: {
+      s = "uint32";
+      break;
+    }
+    case ComponentType::Int32: {
+      s = "int32";
+      break;
+    }
+    case ComponentType::Half: {
+      s = "half";
+      break;
+    }
+    case ComponentType::Float: {
+      s = "float";
+      break;
+    }
+    case ComponentType::Double: {
+      s = "double";
+      break;
     }
   }
 
-  return true;
+  return s;
 }
-#endif
 
-bool USDCReader::Impl::ReconstructStage(Stage *stage) {
-  (void)stage;
-
-#if 0 // TODO
-  if (_nodes.empty()) {
-    PUSH_WARN("Empty scene.");
-    return true;
+std::string to_string(UVTexture::WrapMode mode) {
+  std::string s;
+  switch (mode) {
+    case UVTexture::WrapMode::REPEAT: {
+      s = "repeat";
+      break;
+    }
+    case UVTexture::WrapMode::CLAMP_TO_BORDER: {
+      s = "clamp_to_border";
+      break;
+    }
+    case UVTexture::WrapMode::CLAMP_TO_EDGE: {
+      s = "clamp_to_edge";
+      break;
+    }
+    case UVTexture::WrapMode::MIRROR: {
+      s = "mirror";
+      break;
+    }
   }
 
-  std::unordered_map<uint32_t, uint32_t>
-      path_index_to_spec_index_map;  // path_index -> spec_index
+  return s;
+}
 
-  {
-    for (size_t i = 0; i < _specs.size(); i++) {
-      if (_specs[i].path_index.value == ~0u) {
-        continue;
-      }
+namespace {
 
-      // path_index should be unique.
-      assert(path_index_to_spec_index_map.count(_specs[i].path_index.value) ==
-             0);
-      path_index_to_spec_index_map[_specs[i].path_index.value] = uint32_t(i);
-    }
+std::string DumpMesh(const RenderMesh &mesh, uint32_t indent) {
+  std::stringstream ss;
+
+  ss << "RenderMesh {\n";
+
+  ss << pprint::Indent(indent + 1) << "num_points "
+     << std::to_string(mesh.points.size()) << "\n";
+  ss << pprint::Indent(indent + 1) << "points \""
+     << value::print_array_snipped(mesh.points) << "\"\n";
+  ss << pprint::Indent(indent + 1) << "num_faceVertexCounts "
+     << std::to_string(mesh.faceVertexCounts.size()) << "\n";
+  ss << pprint::Indent(indent + 1) << "faceVertexCounts \""
+     << value::print_array_snipped(mesh.faceVertexCounts) << "\"\n";
+  ss << pprint::Indent(indent + 1) << "num_faceVertexIndices "
+     << std::to_string(mesh.faceVertexIndices.size()) << "\n";
+  ss << pprint::Indent(indent + 1) << "faceVertexIndices \""
+     << value::print_array_snipped(mesh.faceVertexIndices) << "\"\n";
+  ss << pprint::Indent(indent + 1) << "num_materialIds "
+     << std::to_string(mesh.materialIds.size()) << "\n";
+  ss << pprint::Indent(indent + 1) << "materialIds \""
+     << value::print_array_snipped(mesh.materialIds) << "\"\n";
+  ss << pprint::Indent(indent + 1) << "num_facevaryingNormals "
+     << mesh.facevaryingNormals.size() << "\n";
+  ss << pprint::Indent(indent + 1) << "facevaryingNormals \""
+     << value::print_array_snipped(mesh.facevaryingNormals) << "\"\n";
+  ss << pprint::Indent(indent + 1) << "num_texcoordSlots "
+     << std::to_string(mesh.facevaryingTexcoords.size()) << "\n";
+  for (const auto &uvs : mesh.facevaryingTexcoords) {
+    ss << pprint::Indent(indent + 1) << "num_texcoords_"
+       << std::to_string(uvs.first) << " " << uvs.second.size() << "\n";
+    ss << pprint::Indent(indent + 2) << "texcoords_" << uvs.first << " \""
+       << value::print_array_snipped(uvs.second) << "\"\n";
   }
 
-  int root_node_id = 0;
+  // TODO: primvars
 
-  bool ret = ReconstructSceneRecursively(root_node_id, /* level */ 0,
-                                         path_index_to_spec_index_map, scene);
+  ss << "\n";
 
-  if (!ret) {
-    _err += "Failed to reconstruct scene.\n";
-    return false;
-  }
+  ss << pprint::Indent(indent) << "}\n";
 
-  return true;
-#else
-  return false;
-#endif
+  return ss.str();
 }
 
+std::string DumpPreviewSurface(const PreviewSurfaceShader &shader,
+                               uint32_t indent) {
+  std::stringstream ss;
 
-bool USDCReader::Impl::ReadUSDC() {
-  if (crate_reader) {
-    delete crate_reader;
-  }
+  ss << "PreviewSurfaceShader {\n";
 
-  crate_reader = new crate::CrateReader(_sr, _num_threads);
+  ss << pprint::Indent(indent + 1)
+     << "useSpecularWorkFlow = " << std::to_string(shader.useSpecularWorkFlow)
+     << "\n";
 
-  if (!crate_reader->ReadBootStrap()) {
-    _warn = crate_reader->GetWarning();
-    _err = crate_reader->GetError();
-    return false;
+  ss << pprint::Indent(indent + 1) << "diffuseColor = ";
+  if (shader.diffuseColor.is_texture()) {
+    ss << "textureId[" << shader.diffuseColor.textureId << "]";
+  } else {
+    ss << shader.diffuseColor.value;
   }
+  ss << "\n";
 
-  if (!crate_reader->ReadTOC()) {
-    _warn = crate_reader->GetWarning();
-    _err = crate_reader->GetError();
-    return false;
+  ss << pprint::Indent(indent + 1) << "metallic = ";
+  if (shader.metallic.is_texture()) {
+    ss << "textureId[" << shader.metallic.textureId << "]";
+  } else {
+    ss << shader.metallic.value;
   }
+  ss << "\n";
 
-  // Read known sections
-
-  if (!crate_reader->ReadTokens()) {
-    _warn = crate_reader->GetWarning();
-    _err = crate_reader->GetError();
-    return false;
+  ss << pprint::Indent(indent + 1) << "roughness = ";
+  if (shader.roughness.is_texture()) {
+    ss << "textureId[" << shader.roughness.textureId << "]";
+  } else {
+    ss << shader.roughness.value;
   }
+  ss << "\n";
 
-  if (!crate_reader->ReadStrings()) {
-    _warn = crate_reader->GetWarning();
-    _err = crate_reader->GetError();
-    return false;
+  ss << pprint::Indent(indent + 1) << "ior = ";
+  if (shader.ior.is_texture()) {
+    ss << "textureId[" << shader.ior.textureId << "]";
+  } else {
+    ss << shader.ior.value;
   }
+  ss << "\n";
 
-  if (!crate_reader->ReadFields()) {
-    _warn = crate_reader->GetWarning();
-    _err = crate_reader->GetError();
-    return false;
+  ss << pprint::Indent(indent + 1) << "clearcoat = ";
+  if (shader.clearcoat.is_texture()) {
+    ss << "textureId[" << shader.clearcoat.textureId << "]";
+  } else {
+    ss << shader.clearcoat.value;
   }
+  ss << "\n";
 
-  if (!crate_reader->ReadFieldSets()) {
-    _warn = crate_reader->GetWarning();
-    _err = crate_reader->GetError();
-    return false;
+  ss << pprint::Indent(indent + 1) << "clearcoatRoughness = ";
+  if (shader.clearcoatRoughness.is_texture()) {
+    ss << "textureId[" << shader.clearcoatRoughness.textureId << "]";
+  } else {
+    ss << shader.clearcoatRoughness.value;
   }
+  ss << "\n";
 
-  if (!crate_reader->ReadPaths()) {
-    _warn = crate_reader->GetWarning();
-    _err = crate_reader->GetError();
-    return false;
+  ss << pprint::Indent(indent + 1) << "opacity = ";
+  if (shader.opacity.is_texture()) {
+    ss << "textureId[" << shader.opacity.textureId << "]";
+  } else {
+    ss << shader.opacity.value;
   }
+  ss << "\n";
 
-  if (!crate_reader->ReadSpecs()) {
-    _warn = crate_reader->GetWarning();
-    _err = crate_reader->GetError();
-    return false;
+  ss << pprint::Indent(indent + 1) << "opacityThreshold = ";
+  if (shader.opacityThreshold.is_texture()) {
+    ss << "textureId[" << shader.opacityThreshold.textureId << "]";
+  } else {
+    ss << shader.opacityThreshold.value;
   }
+  ss << "\n";
 
-  // TODO(syoyo): Read unknown sections
+  ss << pprint::Indent(indent + 1) << "normal = ";
+  if (shader.normal.is_texture()) {
+    ss << "textureId[" << shader.normal.textureId << "]";
+  } else {
+    ss << shader.normal.value;
+  }
+  ss << "\n";
 
-  ///
-  /// Reconstruct C++ representation of USD scene graph.
-  ///
-  if (!crate_reader->BuildLiveFieldSets()) {
-    _warn = crate_reader->GetWarning();
-    _err = crate_reader->GetError();
+  ss << pprint::Indent(indent + 1) << "displacement = ";
+  if (shader.displacement.is_texture()) {
+    ss << "textureId[" << shader.displacement.textureId << "]";
+  } else {
+    ss << shader.displacement.value;
+  }
+  ss << "\n";
 
-    return false;
+  ss << pprint::Indent(indent + 1) << "occlusion = ";
+  if (shader.occlusion.is_texture()) {
+    ss << "textureId[" << shader.occlusion.textureId << "]";
+  } else {
+    ss << shader.occlusion.value;
   }
+  ss << "\n";
 
-  // TODO
-  return false;
+  ss << pprint::Indent(indent) << "}\n";
 
+  return ss.str();
 }
 
-//
-// -- Interface --
-//
-USDCReader::USDCReader(StreamReader *sr, int num_threads) {
-  impl_ = new USDCReader::Impl(sr, num_threads);
-}
+std::string DumpMaterial(const RenderMaterial &material, uint32_t indent) {
+  std::stringstream ss;
 
-USDCReader::~USDCReader() {
-  delete impl_;
-  impl_ = nullptr;
-}
+  ss << "RenderMaterial " << material.abs_path << " ( " << material.name
+     << " ) {\n";
 
-bool USDCReader::ReconstructStage(Stage *stage) {
-  DCOUT("Reconstruct Stage.");
-  return impl_->ReconstructStage(stage);
+  ss << pprint::Indent(indent + 1) << "surfaceShader = ";
+  ss << DumpPreviewSurface(material.surfaceShader, indent + 1);
+  ss << "\n";
+
+  ss << pprint::Indent(indent) << "}\n";
+
+  return ss.str();
 }
 
-std::string USDCReader::GetError() { return impl_->GetError(); }
+std::string DumpUVTexture(const UVTexture &texture, uint32_t indent) {
+  std::stringstream ss;
+
+  // TODO
+  ss << "UVTexture {\n";
+  ss << pprint::Indent(indent + 1) << "primvar_name " << texture.varname_uv
+     << "\n";
+  ss << pprint::Indent(indent + 1) << "bias " << texture.bias << "\n";
+  ss << pprint::Indent(indent + 1) << "scale " << texture.scale << "\n";
+  ss << pprint::Indent(indent + 1) << "wrapS " << to_string(texture.wrapS)
+     << "\n";
+  ss << pprint::Indent(indent + 1) << "wrapT " << to_string(texture.wrapT)
+     << "\n";
+  ss << pprint::Indent(indent + 1) << "fallback_uv " << texture.fallback_uv
+     << "\n";
+  ss << pprint::Indent(indent + 1) << "textureImageID "
+     << std::to_string(texture.texture_image_id) << "\n";
+  ss << pprint::Indent(indent + 1) << "has UsdTransform2d "
+     << std::to_string(texture.has_transform2d) << "\n";
+  if (texture.has_transform2d) {
+    ss << pprint::Indent(indent + 2) << "rotation " << texture.tx_rotation
+       << "\n";
+    ss << pprint::Indent(indent + 2) << "scale " << texture.tx_scale << "\n";
+    ss << pprint::Indent(indent + 2) << "translation " << texture.tx_translation
+       << "\n";
+    ss << pprint::Indent(indent + 2) << "computed_transform "
+       << texture.transform << "\n";
+  }
 
-std::string USDCReader::GetWarning() { return impl_->GetWarning(); }
+  ss << "\n";
 
-bool USDCReader::ReadUSDC() {
-  return impl_->ReadUSDC();
+  ss << pprint::Indent(indent) << "}\n";
+
+  return ss.str();
 }
 
-}  // namespace usdc
-}  // namespace tinyusdz
+std::string DumpImage(const TextureImage &image, uint32_t indent) {
+  std::stringstream ss;
 
+  ss << "TextureImage {\n";
+  ss << pprint::Indent(indent + 1) << "asset_identifier \""
+     << image.asset_identifier << "\"\n";
+  ss << pprint::Indent(indent + 1) << "channels "
+     << std::to_string(image.channels) << "\n";
+  ss << pprint::Indent(indent + 1) << "width " << std::to_string(image.width)
+     << "\n";
+  ss << pprint::Indent(indent + 1) << "height " << std::to_string(image.height)
+     << "\n";
+  ss << pprint::Indent(indent + 1) << "miplevel "
+     << std::to_string(image.miplevel) << "\n";
+  ss << pprint::Indent(indent + 1) << "colorSpace "
+     << to_string(image.colorSpace) << "\n";
+  ss << pprint::Indent(indent + 1) << "bufferID "
+     << std::to_string(image.buffer_id) << "\n";
 
-#else
+  ss << "\n";
 
-namespace tinyusdz {
-namespace usdc {
+  ss << pprint::Indent(indent) << "}\n";
 
-//
-// -- Interface --
-//
-USDCReader::USDCReader(StreamReader *sr, int num_threads) {
-  (void)sr;
-  (void)num_threads;
+  return ss.str();
 }
 
-USDCReader::~USDCReader() {
-}
+std::string DumpBuffer(const BufferData &buffer, uint32_t indent) {
+  std::stringstream ss;
 
-bool USDCReader::ReconstructScene(Scene *scene) {
-  (void)scene;
-  DCOUT("Reconstruct Scene.");
-  return false;
-}
+  ss << "Buffer {\n";
+  ss << pprint::Indent(indent + 1) << "bytes " << buffer.data.size() << "\n";
+  ss << pprint::Indent(indent + 1) << "count " << std::to_string(buffer.count)
+     << "\n";
+  ss << pprint::Indent(indent + 1) << "componentType "
+     << to_string(buffer.componentType) << "\n";
+
+  ss << "\n";
+
+  ss << pprint::Indent(indent) << "}\n";
 
-std::string USDCReader::GetError() {
-  return "USDC reader feature is disabled in this build.\n";
+  return ss.str();
 }
 
-std::string USDCReader::GetWarning() { return ""; }
+}  // namespace
 
-}  // namespace usdc
-}  // namespace tinyusdz
+std::string DumpRenderScene(const RenderScene &scene,
+                            const std::string &format) {
+  std::stringstream ss;
 
-#endif
+  // Currently kdl only.
+  if (format == "json") {
+    // not supported yet.
+  }
+
+  // KDL does not support array, so quote it as done in USD
+
+  ss << "title RenderScene\n";
+  ss << "// # of Meshes : " << scene.meshes.size() << "\n";
+  ss << "// # of Animations : " << scene.animations.size() << "\n";
+  ss << "// # of Materials : " << scene.materials.size() << "\n";
+  ss << "// # of UVTextures : " << scene.textures.size() << "\n";
+  ss << "// # of TextureImages : " << scene.images.size() << "\n";
+  ss << "// # of Buffers : " << scene.buffers.size() << "\n";
+
+  ss << "\n";
+
+  ss << "meshes {\n";
+  for (size_t i = 0; i < scene.meshes.size(); i++) {
+    ss << "[" << i << "] " << DumpMesh(scene.meshes[i], 1);
+  }
+  ss << "}\n";
+
+  ss << "\n";
+  ss << "materials {\n";
+  for (size_t i = 0; i < scene.materials.size(); i++) {
+    ss << "[" << i << "] " << DumpMaterial(scene.materials[i], 1);
+  }
+  ss << "}\n";
+
+  ss << "\n";
+  ss << "textures {\n";
+  for (size_t i = 0; i < scene.textures.size(); i++) {
+    ss << "[" << i << "] " << DumpUVTexture(scene.textures[i], 1);
+  }
+  ss << "}\n";
+
+  ss << "\n";
+  ss << "images {\n";
+  for (size_t i = 0; i < scene.images.size(); i++) {
+    ss << "[" << i << "] " << DumpImage(scene.images[i], 1);
+  }
+  ss << "}\n";
+
+  ss << "\n";
+  ss << "buffers {\n";
+  for (size_t i = 0; i < scene.buffers.size(); i++) {
+    ss << "[" << i << "] " << DumpBuffer(scene.buffers[i], 1);
+  }
+  ss << "}\n";
+
+  // ss << "TODO: Animations, ...\n";
+
+  return ss.str();
+}
+
+}  // namespace tydra
+}  // namespace tinyusdz
```

### Comparing `tinyusdz-0.8.0rc0/src/usdc-writer.hh` & `tinyusdz-0.8.0rc1/src/usdc-writer.hh`

 * *Files identical despite different names*

